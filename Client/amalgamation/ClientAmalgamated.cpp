// Auto-generated amalgamation of client sources.
// Generated on 2025-12-28T06:53:47.080657Z
// Do not edit this file manually; run create_amalgamated_source.py instead.

// ===== BEGIN JpegFile/JpegFile.cpp =====
#line 1 "JpegFile/JpegFile.cpp"
﻿////////////////////////////////////////////////////////////
//	JpegFile - A C++ class to allow reading and writing of
//	RGB and Grayscale JPEG images.
//	It is based on the IJG V.6 code.
//
//	This class Copyright 1997, Chris Losinger
//	This is free to use and modify provided my name is 
//	included.
//
//	See jpegfile.h for usage.
//
////////////////////////////////////////////////////////////
#include <Windows.h>
#include "JpegFile.h"

#include <assert.h>
#include <filesystem>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

/*
 * <setjmp.h> is used for the optional error recovery mechanism shown in
 * the second part of the example.
 */

//#include <setjmp.h>
#include <time.h>

// error handler, to avoid those pesky exit(0)'s

struct my_error_mgr {
  struct jpeg_error_mgr pub;	/* "public" fields */

  jmp_buf setjmp_buffer;	/* for return to caller */
};

typedef struct my_error_mgr * my_error_ptr;

//
//
//

METHODDEF(void) my_error_exit (j_common_ptr cinfo);

//
//	to handle fatal errors.
//	the original JPEG code will just exit(0). can't really
//	do that in Windows....
//

METHODDEF(void) my_error_exit (j_common_ptr cinfo)
{
	/* cinfo->err really points to a my_error_mgr struct, so coerce pointer */
	my_error_ptr myerr = (my_error_ptr) cinfo->err;

	char buffer[JMSG_LENGTH_MAX];

	/* Create the message */
	(*cinfo->err->format_message) (cinfo, buffer);

	/* Always display the message. */
	//MessageBox(nullptr,buffer,"JPEG Fatal Error",MB_ICONSTOP);


	/* Return control to the setjmp point */
	longjmp(myerr->setjmp_buffer, 1);
}

// store a scanline to our data buffer
void j_putRGBScanline(BYTE *jpegline, 
						 int widthPix,
						 BYTE *outBuf,
						 int row);

void j_putGrayScanlineToRGB(BYTE *jpegline, 
						 int widthPix,
						 BYTE *outBuf,
						 int row);


//
//	constructor doesn't do much - there's no real class here...
//

WORD CJpegFile::m_r = 1124;
WORD CJpegFile::m_c1 = 52845;
WORD CJpegFile::m_c2 = 22719;

CJpegFile::CJpegFile()
{
}

//
//	
//

CJpegFile::~CJpegFile()
{
}

//
//	read a JPEG file
//

BYTE * CJpegFile::JpegFileToRGB(std::string fileName,
							   UINT *width,
							   UINT *height)

{
	// get our buffer set to hold data
	BYTE *dataBuf = nullptr;

	// basic code from IJG Jpeg Code v6 example.c

	*width=0;
	*height=0;

	/* This struct contains the JPEG decompression parameters and pointers to
	* working space (which is allocated as needed by the JPEG library).
	*/
	struct jpeg_decompress_struct cinfo;
	/* We use our private extension JPEG error handler.
	* Note that this struct must live as long as the main JPEG parameter
	* struct, to avoid dangling-pointer problems.
	*/
	struct my_error_mgr jerr;
	/* More stuff */
	FILE * infile=nullptr;		/* source file */

	JSAMPARRAY buffer;		/* Output row buffer */
	int row_stride;		/* physical row width in output buffer */

	/* In this example we want to open the input file before doing anything else,
	* so that the setjmp() error recovery below can assume the file is open.
	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
	* requires it in order to read binary files.
	*/

	if ((infile = fopen(fileName.c_str(), "rb")) == nullptr) {
		return nullptr;
	}

	/* Step 1: allocate and initialize JPEG decompression object */

	/* We set up the normal JPEG error routines, then override error_exit. */
	cinfo.err = jpeg_std_error(&jerr.pub);
	jerr.pub.error_exit = my_error_exit;


	/* Establish the setjmp return context for my_error_exit to use. */
	if (setjmp(jerr.setjmp_buffer)) {
		/* If we get here, the JPEG code has signaled an error.
		 * We need to clean up the JPEG object, close the input file, and return.
		 */

		jpeg_destroy_decompress(&cinfo);

		if (infile!=nullptr)
			fclose(infile);

      if (dataBuf!=nullptr)
      {
         delete [] dataBuf;
      }

		return nullptr;
	}

	/* Now we can initialize the JPEG decompression object. */
	jpeg_create_decompress(&cinfo);

	/* Step 2: specify data source (eg, a file) */

	jpeg_stdio_src(&cinfo, infile);

	/* Step 3: read file parameters with jpeg_read_header() */

	(void) jpeg_read_header(&cinfo, TRUE);
	/* We can ignore the return value from jpeg_read_header since
	*   (a) suspension is not possible with the stdio data source, and
	*   (b) we passed TRUE to reject a tables-only JPEG file as an error.
	* See libjpeg.doc for more info.
	*/

	/* Step 4: set parameters for decompression */

	/* In this example, we don't need to change any of the defaults set by
	* jpeg_read_header(), so we do nothing here.
	*/

	/* Step 5: Start decompressor */

	(void) jpeg_start_decompress(&cinfo);
	/* We can ignore the return value since suspension is not possible
	* with the stdio data source.
	*/

	/* We may need to do some setup of our own at this point before reading
	* the data.  After jpeg_start_decompress() we have the correct scaled
	* output image dimensions available, as well as the output colormap
	* if we asked for color quantization.
	* In this example, we need to make an output work buffer of the right size.
	*/ 

	////////////////////////////////////////////////////////////
	// alloc and open our new buffer
	dataBuf=(BYTE *)new BYTE[cinfo.output_width * 3 * cinfo.output_height];
	if (dataBuf==nullptr) {

//		AfxMessageBox("JpegFile :\nOut of memory",MB_ICONSTOP);

		jpeg_destroy_decompress(&cinfo);
		
		fclose(infile);

		return nullptr;
	}

	// how big is this thing gonna be?
	*width = cinfo.output_width;
	*height = cinfo.output_height;
	
	/* JSAMPLEs per row in output buffer */
	row_stride = cinfo.output_width * cinfo.output_components;

	/* Make a one-row-high sample array that will go away when done with image */
	buffer = (*cinfo.mem->alloc_sarray)
		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);

	/* Step 6: while (scan lines remain to be read) */
	/*           jpeg_read_scanlines(...); */

	/* Here we use the library's state variable cinfo.output_scanline as the
	* loop counter, so that we don't have to keep track ourselves.
	*/
	while (cinfo.output_scanline < cinfo.output_height) {
		/* jpeg_read_scanlines expects an array of pointers to scanlines.
		 * Here the array is only one element long, but you could ask for
		 * more than one scanline at a time if that's more convenient.
		 */
		(void) jpeg_read_scanlines(&cinfo, buffer, 1);
		/* Assume put_scanline_someplace wants a pointer and sample count. */

		// asuumer all 3-components are RGBs
		if (cinfo.out_color_components==3) {
			
			j_putRGBScanline(buffer[0], 
								*width,
								dataBuf,
								cinfo.output_scanline-1);

		} else if (cinfo.out_color_components==1) {

			// assume all single component images are grayscale
			j_putGrayScanlineToRGB(buffer[0], 
								*width,
								dataBuf,
								cinfo.output_scanline-1);

		}

	}

	/* Step 7: Finish decompression */

	(void) jpeg_finish_decompress(&cinfo);
	/* We can ignore the return value since suspension is not possible
	* with the stdio data source.
	*/

	/* Step 8: Release JPEG decompression object */

	/* This is an important step since it will release a good deal of memory. */
	jpeg_destroy_decompress(&cinfo);

	/* After finish_decompress, we can close the input file.
	* Here we postpone it until after no more JPEG errors are possible,
	* so as to simplify the setjmp error logic above.  (Actually, I don't
	* think that jpeg_destroy can do an error exit, but why assume anything...)
	*/
	fclose(infile);

	/* At this point you may want to check to see whether any corrupt-data
	* warnings occurred (test whether jerr.pub.num_warnings is nonzero).
	*/

	return dataBuf;
}

BOOL CJpegFile::GetJPGDimensions(std::string fileName,
								UINT *width,
								UINT *height)

{
	// basic code from IJG Jpeg Code v6 example.c

	/* This struct contains the JPEG decompression parameters and pointers to
	* working space (which is allocated as needed by the JPEG library).
	*/
	struct jpeg_decompress_struct cinfo;
	/* We use our private extension JPEG error handler.
	* Note that this struct must live as long as the main JPEG parameter
	* struct, to avoid dangling-pointer problems.
	*/
	struct my_error_mgr jerr;
	/* More stuff */
	FILE * infile=nullptr;		/* source file */

	/* In this example we want to open the input file before doing anything else,
	* so that the setjmp() error recovery below can assume the file is open.
	* VERY IMPORTANT: use "b" option to fopen() if you are on a machine that
	* requires it in order to read binary files.
	*/

	if ((infile = fopen(fileName.c_str(), "rb")) == nullptr) {
		return FALSE;
	}

	/* Step 1: allocate and initialize JPEG decompression object */

	/* We set up the normal JPEG error routines, then override error_exit. */
	cinfo.err = jpeg_std_error(&jerr.pub);
	jerr.pub.error_exit = my_error_exit;


	/* Establish the setjmp return context for my_error_exit to use. */
	if (setjmp(jerr.setjmp_buffer)) {
		/* If we get here, the JPEG code has signaled an error.
		 * We need to clean up the JPEG object, close the input file, and return.
		 */

		jpeg_destroy_decompress(&cinfo);

		if (infile!=nullptr)
			fclose(infile);
		return FALSE;
	}

	/* Now we can initialize the JPEG decompression object. */
	jpeg_create_decompress(&cinfo);

	/* Step 2: specify data source (eg, a file) */

	jpeg_stdio_src(&cinfo, infile);

	/* Step 3: read file parameters with jpeg_read_header() */

	(void) jpeg_read_header(&cinfo, TRUE);
	/* We can ignore the return value from jpeg_read_header since
	*   (a) suspension is not possible with the stdio data source, and
	*   (b) we passed TRUE to reject a tables-only JPEG file as an error.
	* See libjpeg.doc for more info.
	*/


	// how big is this thing ?
	*width = cinfo.image_width;
	*height = cinfo.image_height;

	/* Step 8: Release JPEG decompression object */

	/* This is an important step since it will release a good deal of memory. */
	jpeg_destroy_decompress(&cinfo);

	/* After finish_decompress, we can close the input file.
	* Here we postpone it until after no more JPEG errors are possible,
	* so as to simplify the setjmp error logic above.  (Actually, I don't
	* think that jpeg_destroy can do an error exit, but why assume anything...)
	*/
	fclose(infile);

	/* At this point you may want to check to see whether any corrupt-data
	* warnings occurred (test whether jerr.pub.num_warnings is nonzero).
	*/

	return TRUE;
}

//
//
//

BYTE *CJpegFile::RGBFromDWORDAligned(BYTE *inBuf,
									UINT widthPix, 
									UINT widthBytes,
									UINT height)
{
	if (inBuf==nullptr)
		return nullptr;


	BYTE *tmp;
	tmp=(BYTE *)new BYTE[height * widthPix * 3];
	if (tmp==nullptr)
		return nullptr;

	UINT row;

	for (row=0;row<height;row++) {
		memcpy((tmp+row * widthPix * 3), 
				(inBuf + row * widthBytes), 
				widthPix * 3);
	}

	return tmp;
}

//
//
//

BOOL CJpegFile::RGBToJpegFile(std::string fileName, 
							BYTE *dataBuf,
							UINT widthPix,
							UINT height,
							BOOL color, 
							int quality)
{
	if (dataBuf==nullptr)
		return FALSE;
	if (widthPix==0)
		return FALSE;
	if (height==0)
		return FALSE;

	LPBYTE tmp;
	if (!color) {
		tmp = (BYTE*)new BYTE[widthPix*height];
		if (tmp==nullptr) {
//			AfxMessageBox("Memory error");
			return FALSE;
		}

		UINT row,col;
		for (row=0;row<height;row++) {
			for (col=0;col<widthPix;col++) {
				LPBYTE pRed, pGrn, pBlu;
				pRed = dataBuf + row * widthPix * 3 + col * 3;
				pGrn = dataBuf + row * widthPix * 3 + col * 3 + 1;
				pBlu = dataBuf + row * widthPix * 3 + col * 3 + 2;

				// luminance
				int lum = (int)(.299 * (double)(*pRed) + .587 * (double)(*pGrn) + .114 * (double)(*pBlu));
				LPBYTE pGray;
				pGray = tmp + row * widthPix + col;
				*pGray = (BYTE)lum;
			}
		}
	}

	struct jpeg_compress_struct cinfo;
	/* More stuff */
	FILE * outfile=nullptr;			/* target file */
	int row_stride;			/* physical row widthPix in image buffer */

	struct my_error_mgr jerr;

	/* Step 1: allocate and initialize JPEG compression object */
	cinfo.err = jpeg_std_error(&jerr.pub);
	jerr.pub.error_exit = my_error_exit;

	/* Establish the setjmp return context for my_error_exit to use. */
	if (setjmp(jerr.setjmp_buffer)) {
		/* If we get here, the JPEG code has signaled an error.
		 * We need to clean up the JPEG object, close the input file, and return.
		 */

		jpeg_destroy_compress(&cinfo);

		if (outfile!=nullptr)
			fclose(outfile);

		if (!color) {
			delete [] tmp;
		}
		return FALSE;
	}

	/* Now we can initialize the JPEG compression object. */
	jpeg_create_compress(&cinfo);

	/* Step 2: specify data destination (eg, a file) */
	/* Note: steps 2 and 3 can be done in either order. */

	if ((outfile = fopen(fileName.c_str(), "wb")) == nullptr) {
		return FALSE;
	}

	jpeg_stdio_dest(&cinfo, outfile);

	/* Step 3: set parameters for compression */
												    
	/* First we supply a description of the input image.
	* Four fields of the cinfo struct must be filled in:
	*/
	cinfo.image_width = widthPix; 	/* image widthPix and height, in pixels */
	cinfo.image_height = height;
	if (color) {
		cinfo.input_components = 3;		/* # of color components per pixel */
		cinfo.in_color_space = JCS_RGB; 	/* colorspace of input image */
	} else {
		cinfo.input_components = 1;		/* # of color components per pixel */
		cinfo.in_color_space = JCS_GRAYSCALE; 	/* colorspace of input image */
	}

 
/* Now use the library's routine to set default compression parameters.
   * (You must set at least cinfo.in_color_space before calling this,
   * since the defaults depend on the source color space.)
   */

  jpeg_set_defaults(&cinfo);
  /* Now you can set any non-default parameters you wish to.
   * Here we just illustrate the use of quality (quantization table) scaling:
   */
  jpeg_set_quality(&cinfo, quality, TRUE /* limit to baseline-JPEG values */);

  /* Step 4: Start compressor */

  /* TRUE ensures that we will write a complete interchange-JPEG file.
   * Pass TRUE unless you are very sure of what you're doing.
   */
  jpeg_start_compress(&cinfo, TRUE);

  /* Step 5: while (scan lines remain to be written) */
  /*           jpeg_write_scanlines(...); */

  /* Here we use the library's state variable cinfo.next_scanline as the
   * loop counter, so that we don't have to keep track ourselves.
   * To keep things simple, we pass one scanline per call; you can pass
   * more if you wish, though.
   */
  row_stride = widthPix * 3;	/* JSAMPLEs per row in image_buffer */

  while (cinfo.next_scanline < cinfo.image_height) {
    /* jpeg_write_scanlines expects an array of pointers to scanlines.
     * Here the array is only one element long, but you could pass
     * more than one scanline at a time if that's more convenient.
     */
	LPBYTE outRow;
	if (color) {
		outRow = dataBuf + (cinfo.next_scanline * widthPix * 3);
	} else {
		outRow = tmp + (cinfo.next_scanline * widthPix);
	}

    (void) jpeg_write_scanlines(&cinfo, &outRow, 1);
  }

  /* Step 6: Finish compression */

  jpeg_finish_compress(&cinfo);

  /* After finish_compress, we can close the output file. */
  fclose(outfile);

  /* Step 7: release JPEG compression object */

  /* This is an important step since it will release a good deal of memory. */
  jpeg_destroy_compress(&cinfo);

  if (!color)
	  delete [] tmp;
  /* And we're done! */

  return TRUE;
}

//
//	stash a scanline
//

void j_putRGBScanline(BYTE *jpegline, 
					 int widthPix,
					 BYTE *outBuf,
					 int row)
{
	int offset = row * widthPix * 3;
	int count;
	for (count=0;count<widthPix;count++) 
	{
		*(outBuf + offset + count * 3 + 0) = *(jpegline + count * 3 + 0);
		*(outBuf + offset + count * 3 + 1) = *(jpegline + count * 3 + 1);
		*(outBuf + offset + count * 3 + 2) = *(jpegline + count * 3 + 2);
	}
}

//
//	stash a gray scanline
//

void j_putGrayScanlineToRGB(BYTE *jpegline, 
							 int widthPix,
							 BYTE *outBuf,
							 int row)
{
	int offset = row * widthPix * 3;
	int count;
	for (count=0;count<widthPix;count++) {

		BYTE iGray;

		// get our grayscale value
		iGray = *(jpegline + count);

		*(outBuf + offset + count * 3 + 0) = iGray;
		*(outBuf + offset + count * 3 + 1) = iGray;
		*(outBuf + offset + count * 3 + 2) = iGray;
	}
}

//
// copies BYTE buffer into DWORD-aligned BYTE buffer
// return addr of new buffer
//

BYTE * CJpegFile::MakeDwordAlignedBuf(BYTE *dataBuf,
									 UINT widthPix,				// pixels!!
									 UINT height,
									 UINT *uiOutWidthBytes)		// bytes!!!
{
	////////////////////////////////////////////////////////////
	// what's going on here? this certainly means trouble 
	if (dataBuf==nullptr)
		return nullptr;

	////////////////////////////////////////////////////////////
	// how big is the smallest DWORD-aligned buffer that we can use?
	UINT uiWidthBytes;
	uiWidthBytes = WIDTHBYTES(widthPix * 24);

	DWORD dwNewsize=(DWORD)((DWORD)uiWidthBytes * 
							(DWORD)height);
	BYTE *pNew;

	////////////////////////////////////////////////////////////
	// alloc and open our new buffer
	pNew=(BYTE *)new BYTE[dwNewsize];
	if (pNew==nullptr) {
		return nullptr;
	}
	
	////////////////////////////////////////////////////////////
	// copy row-by-row
	UINT uiInWidthBytes = widthPix * 3;
	UINT uiCount;
	for (uiCount=0;uiCount < height;uiCount++) {
		BYTE * bpInAdd;
		BYTE * bpOutAdd;
		ULONG lInOff;
		ULONG lOutOff;

		lInOff=uiInWidthBytes * uiCount;
		lOutOff=uiWidthBytes * uiCount;

		bpInAdd= dataBuf + lInOff;
		bpOutAdd= pNew + lOutOff;

		memcpy(bpOutAdd,bpInAdd,uiInWidthBytes);
	}

	*uiOutWidthBytes=uiWidthBytes;
	return pNew;
}

//
//	vertically flip a buffer 
//	note, this operates on a buffer of widthBytes bytes, not pixels!!!
//

BOOL CJpegFile::VertFlipBuf(BYTE  * inbuf, 
					   UINT widthBytes, 
					   UINT height)
{   
	BYTE  *tb1;
	BYTE  *tb2;

	if (inbuf==nullptr)
		return FALSE;

	UINT bufsize;

	bufsize=widthBytes;

	tb1= (BYTE *)new BYTE[bufsize];
	if (tb1==nullptr) {
		return FALSE;
	}

	tb2= (BYTE *)new BYTE [bufsize];
	if (tb2==nullptr) {
		delete [] tb1;
		return FALSE;
	}
	
	UINT row_cnt;     
	ULONG off1=0;
	ULONG off2=0;

	for (row_cnt=0;row_cnt<(height+1)/2;row_cnt++) {
		off1=row_cnt*bufsize;
		off2=((height-1)-row_cnt)*bufsize;   
		
		memcpy(tb1,inbuf+off1,bufsize);
		memcpy(tb2,inbuf+off2,bufsize);	
		memcpy(inbuf+off1,tb2,bufsize);
		memcpy(inbuf+off2,tb1,bufsize);
	}	

	delete [] tb1;
	delete [] tb2;

	return TRUE;
}        


//
//	swap Rs and Bs
//
//	Note! this does its stuff on buffers with a whole number of pixels
//	per data row!!
//


BOOL CJpegFile::BGRFromRGB(BYTE *buf, UINT widthPix, UINT height)
{
	if (buf==nullptr)
		return FALSE;

	UINT col, row;
	for (row=0;row<height;row++) {
		for (col=0;col<widthPix;col++) {
			LPBYTE pRed, pGrn, pBlu;
			pRed = buf + row * widthPix * 3 + col * 3;
			pGrn = buf + row * widthPix * 3 + col * 3 + 1;
			pBlu = buf + row * widthPix * 3 + col * 3 + 2;

			// swap red and blue
			BYTE tmp;
			tmp = *pRed;
			*pRed = *pBlu;
			*pBlu = tmp;
		}
	}
	return TRUE;
}

//
//	Note! this does its stuff on buffers with a whole number of pixels
//	per data row!!
//

BOOL CJpegFile::MakeGrayScale(BYTE *buf, UINT widthPix, UINT height)
{
	if (buf==nullptr)
		return FALSE;

	UINT row,col;
	for (row=0;row<height;row++) {
		for (col=0;col<widthPix;col++) {
			LPBYTE pRed, pGrn, pBlu;
			pRed = buf + row * widthPix * 3 + col * 3;
			pGrn = buf + row * widthPix * 3 + col * 3 + 1;
			pBlu = buf + row * widthPix * 3 + col * 3 + 2;

			// luminance
			int lum = (int)(.299 * (double)(*pRed) + .587 * (double)(*pGrn) + .114 * (double)(*pBlu));

			*pRed = (BYTE)lum;
			*pGrn = (BYTE)lum;
			*pBlu = (BYTE)lum;
		}
	}
	return TRUE;
}


int FAR CJpegFile::PalEntriesOnDevice(HDC hDC)
{
	int nColors;  // number of colors
	
	/*  Find out the number of palette entries on this
	 *  device.
	 */
	
//	nColors = GetDeviceCaps(hDC, SIZEPALETTE);
	nColors = GetDeviceCaps(hDC, BITSPIXEL);
	if(nColors > 8) return 0;
	else nColors = 2 << nColors;
	
	/*  For non-palette devices, we'll use the # of system
	 *  colors for our palette size.
	 */
	if (!nColors)
		nColors = GetDeviceCaps(hDC, NUMCOLORS);
	assert(nColors);
	return nColors;
}

HPALETTE FAR CJpegFile::GetSystemPalette(void)
{
	HDC hDC;                // handle to a DC
	static HPALETTE hPal = nullptr;   // handle to a palette
	HANDLE hLogPal;         // handle to a logical palette
	LPLOGPALETTE lpLogPal;  // pointer to a logical palette
	int nColors;            // number of colors
	
	/* Find out how many palette entries we want. */
	
	hDC = GetDC(nullptr);
	if (!hDC)
		return nullptr;
	nColors = PalEntriesOnDevice(hDC);   // Number of palette entries
	if(nColors == 0) return nullptr;
	
	/* Allocate room for the palette and lock it. */
	hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + nColors * sizeof(
		PALETTEENTRY));
	
	/* if we didn't get a logical palette, return nullptr */
	if (!hLogPal)
		return nullptr;
	
	/* get a pointer to the logical palette */
	lpLogPal = (LPLOGPALETTE)GlobalLock(hLogPal);
	
	/* set some important fields */
	lpLogPal->palVersion = PALVERSION;
	lpLogPal->palNumEntries = nColors;
	
	/* Copy the current system palette into our logical palette */
	
	GetSystemPaletteEntries(hDC, 0, nColors, 
		(LPPALETTEENTRY)(lpLogPal->palPalEntry));
	
	/*  Go ahead and create the palette.  Once it's created,
	 *  we no longer need the LOGPALETTE, so free it.
     */
	
	hPal = CreatePalette(lpLogPal);
	
	/* clean up */
	GlobalUnlock(hLogPal);
	GlobalFree(hLogPal);
	ReleaseDC(nullptr, hDC);
	
	return hPal;
}

WORD FAR CJpegFile::DIBNumColors(LPSTR lpDIB)
{
	WORD wBitCount;  // DIB bit count
	
	/*  If this is a Windows-style DIB, the number of colors in the
	 *  color table can be less than the number of bits per pixel
	 *  allows for (i.e. lpbi->biClrUsed can be set to some value).
	 *  If this is the case, return the appropriate value.
     */
	
	if (IS_WIN30_DIB(lpDIB))
	{
		DWORD dwClrUsed;
		
		dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;
		if (dwClrUsed)
			return (WORD)dwClrUsed;
	}
	
	/*  Calculate the number of colors in the color table based on
     *  the number of bits per pixel for the DIB.
     */
	if (IS_WIN30_DIB(lpDIB))
		wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;
	else
		wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;
	
	/* return number of colors based on bits per pixel */
	switch (wBitCount)
	{
	case 1:
		return 2;
		
	case 4:
		return 16;
		
	case 8:
		return 256;
		
	default:
		return 0;
	}
}

WORD FAR CJpegFile::PaletteSize(LPSTR lpDIB)
{
	/* calculate the size required by the palette */
	if (IS_WIN30_DIB (lpDIB))
		return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));
	else
		return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));
}

HDIB FAR CJpegFile::BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal)
{
	BITMAP bm;                   // bitmap structure
	BITMAPINFOHEADER bi;         // bitmap header
	BITMAPINFOHEADER FAR *lpbi;  // pointer to BITMAPINFOHEADER
	DWORD dwLen;                 // size of memory block
	HANDLE hDIB, h;              // handle to DIB, temp handle
	HDC hDC;                     // handle to DC
	WORD biBits;                 // bits per pixel
	
	/* check if bitmap handle is valid */
	
	if (!hBitmap)
		return nullptr;
	
	/* fill in BITMAP structure, return nullptr if it didn't work */
	if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm))
		return nullptr;
	
	/* if no palette is specified, use default palette */
	if (hPal == nullptr)
		hPal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
	
	/* calculate bits per pixel */
	biBits = bm.bmPlanes * bm.bmBitsPixel;
	
	/* make sure bits per pixel is valid */
	if (biBits <= 1)
		biBits = 1;
	else if (biBits <= 4)
		biBits = 4;
	else if (biBits <= 8)
		biBits = 8;
	else /* if greater than 8-bit, force to 24-bit */
		biBits = 24;
	
	/* initialize BITMAPINFOHEADER */
	bi.biSize = sizeof(BITMAPINFOHEADER);
	bi.biWidth = bm.bmWidth;
	bi.biHeight = bm.bmHeight;
	bi.biPlanes = 1;
	bi.biBitCount = biBits;
	bi.biCompression = BI_RGB;
	bi.biSizeImage = 0;
	bi.biXPelsPerMeter = 0;
	bi.biYPelsPerMeter = 0;
	bi.biClrUsed = 0;
	bi.biClrImportant = 0;
	
	/* calculate size of memory block required to store BITMAPINFO */
	dwLen = bi.biSize + PaletteSize((LPSTR)&bi);
	
	/* get a DC */
	hDC = GetDC(nullptr);
	
	/* select and realize our palette */
	hPal = SelectPalette(hDC, hPal, FALSE);
	RealizePalette(hDC);
	
	/* alloc memory block to store our bitmap */
	hDIB = GlobalAlloc(GHND, dwLen);
	
	/* if we couldn't get memory block */
	if (!hDIB)
	{
		/* clean up and return nullptr */
		SelectPalette(hDC, hPal, TRUE);
		RealizePalette(hDC);
		ReleaseDC(nullptr, hDC);
		return nullptr;
	}
	
	/* lock memory and get pointer to it */
	lpbi = (BITMAPINFOHEADER FAR *)GlobalLock(hDIB);
	
	/* use our bitmap info. to fill BITMAPINFOHEADER */
	*lpbi = bi;
	
	/*  call GetDIBits with a nullptr lpBits param, so it will calculate the
	 *  biSizeImage field for us
	 */
	GetDIBits(hDC, hBitmap, 0, (WORD)bi.biHeight, nullptr, (LPBITMAPINFO)lpbi,
		DIB_RGB_COLORS);
	
	/* get the info. returned by GetDIBits and unlock memory block */
	bi = *lpbi;
	GlobalUnlock(hDIB);
	
	/* if the driver did not fill in the biSizeImage field, make one up */
	if (bi.biSizeImage == 0)
		bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
	
	/* realloc the buffer big enough to hold all the bits */
	dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage;
	if (h = GlobalReAlloc(hDIB, dwLen, 0))
		hDIB = h;
	else
	{
		/* clean up and return nullptr */
		GlobalFree(hDIB);
		hDIB = nullptr;
		SelectPalette(hDC, hPal, TRUE);
		RealizePalette(hDC);
		ReleaseDC(nullptr, hDC);
		return nullptr;
	}
	
	/* lock memory block and get pointer to it */
	lpbi = (BITMAPINFOHEADER FAR *)GlobalLock(hDIB);
	
	/*  call GetDIBits with a NON-nullptr lpBits param, and actualy get the
	 *  bits this time
	 */
	if (GetDIBits(hDC, hBitmap, 0, (WORD)bi.biHeight, (LPSTR)lpbi + (WORD)lpbi->biSize + 
		PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0)
	{
		/* clean up and return nullptr */
		GlobalUnlock(hDIB);
		hDIB = nullptr;
		SelectPalette(hDC, hPal, TRUE);
		RealizePalette(hDC);
		ReleaseDC(nullptr, hDC);
		return nullptr;
	}
	bi = *lpbi;
	
	/* clean up */
	GlobalUnlock(hDIB);
	SelectPalette(hDC, hPal, TRUE);
	RealizePalette(hDC);
	ReleaseDC(nullptr, hDC);
	
	/* return handle to the DIB */
	return hDIB;
}

HBITMAP FAR CJpegFile::CopyScreenToBitmap(LPRECT lpRect)
{
	HDC hScrDC, hMemDC;           // screen DC and memory DC
	HBITMAP hBitmap, hOldBitmap;  // handles to deice-dependent bitmaps
	int nX, nY, nX2, nY2;         // coordinates of rectangle to grab
	int nWidth, nHeight;          // DIB width and height
	int xScrn, yScrn;             // screen resolution
	
	/* check for an empty rectangle */
	
	if (IsRectEmpty(lpRect))
		return nullptr;
	
	/*  create a DC for the screen and create
	 *  a memory DC compatible to screen DC
     */
	hScrDC = CreateDC("DISPLAY", nullptr, nullptr, nullptr);
	hMemDC = CreateCompatibleDC(hScrDC);
	
	/* get points of rectangle to grab */
	nX = lpRect->left;
	nY = lpRect->top;
	nX2 = lpRect->right;
	nY2 = lpRect->bottom;
	
	/* get screen resolution */
	xScrn = GetDeviceCaps(hScrDC, HORZRES);
	yScrn = GetDeviceCaps(hScrDC, VERTRES);
	
	/* make sure bitmap rectangle is visible */
	if (nX < 0)
		nX = 0;
	if (nY < 0)
		nY = 0;
	if (nX2 > xScrn)
		nX2 = xScrn;
	if (nY2 > yScrn)
		nY2 = yScrn;
	nWidth = nX2 - nX;
	nHeight = nY2 - nY;
	
	/* create a bitmap compatible with the screen DC */
	hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight);
	
	/* select new bitmap into memory DC */
	hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
	
	/* bitblt screen DC to memory DC */
	BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY);
	
	/*  select old bitmap back into memory DC and get handle to
	 *  bitmap of the screen
	 */
	hBitmap = (HBITMAP)SelectObject(hMemDC, hOldBitmap);
	
	/* clean up */
	DeleteDC(hScrDC);
	DeleteDC(hMemDC);
	
	/* return handle to the bitmap */
	return hBitmap;
}

HDIB FAR CJpegFile::CopyScreenToDIB(LPRECT lpRect)
{
	HBITMAP hBitmap;    // handle to device-dependent bitmap
	HPALETTE hPalette;  // handle to palette
	HDIB hDIB = nullptr;   // handle to DIB
	
	/*  get the device-dependent bitmap in lpRect by calling
	 *  CopyScreenToBitmap and passing it the rectangle to grab
     */
	
	hBitmap = CopyScreenToBitmap(lpRect);
	
	/* check for a valid bitmap handle */
	if (!hBitmap)
		return nullptr;
	
	/* get the current palette */
	hPalette = GetSystemPalette();
	
	/* convert the bitmap to a DIB */
	hDIB = BitmapToDIB(hBitmap, hPalette);
	
	/* clean up */
	DeleteObject(hPalette);
	DeleteObject(hBitmap);
	
	/* return handle to the packed-DIB */
	return hDIB;
}

HANDLE CJpegFile::AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap)
{
	DWORD              dwLen;
	HANDLE             hDIB;
	HDC                hDC;
	LPBITMAPINFOHEADER lpbi;
	HANDLE             hTemp;
	
	/* Figure out the size needed to hold the BITMAPINFO structure
     * (which includes the BITMAPINFOHEADER and the color table).
     */
	
	dwLen = bi.biSize + PaletteSize((LPSTR) &bi);
	hDIB  = GlobalAlloc(GHND,dwLen);
	
	/* Check that DIB handle is valid */
	if (!hDIB)
		return nullptr;
	
	/* Set up the BITMAPINFOHEADER in the newly allocated global memory,
	 * then call GetDIBits() with lpBits = nullptr to have it fill in the
	 * biSizeImage field for us.
     */
	lpbi  = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
	*lpbi = bi;
	
	hDC   = GetDC(nullptr);
	GetDIBits(hDC, hBitmap, 0, (WORD) bi.biHeight,
		nullptr, (LPBITMAPINFO) lpbi, DIB_RGB_COLORS);
	ReleaseDC(nullptr, hDC);
	
	/* If the driver did not fill in the biSizeImage field,
     * fill it in -- NOTE: this is a bug in the driver!
     */
	if (lpbi->biSizeImage == 0)
		lpbi->biSizeImage = WIDTHBYTES((DWORD)lpbi->biWidth * lpbi->biBitCount) *
		lpbi->biHeight;
	
	/* Get the size of the memory block we need */
	dwLen = lpbi->biSize + PaletteSize((LPSTR) &bi) + lpbi->biSizeImage;
	
	/* Unlock the memory block */
	GlobalUnlock(hDIB);
	
	/* ReAlloc the buffer big enough to hold all the bits */
	if (hTemp = GlobalReAlloc(hDIB,dwLen,0))
		return hTemp;
	else
	{
		/* Else free memory block and return failure */
		GlobalFree(hDIB);
		return nullptr;
	}
}

HDIB FAR CJpegFile::ChangeBitmapFormat(HBITMAP  hBitmap, WORD     wBitCount, DWORD    dwCompression, HPALETTE hPal)
{
	HDC                hDC = nullptr;// Screen DC
	HDIB               hNewDIB=nullptr; // Handle to new DIB
	BITMAP             Bitmap;       // BITMAP data structure
	BITMAPINFOHEADER   bi;           // Bitmap info. header
	LPBITMAPINFOHEADER lpbi;         // Pointer to bitmap header
	HPALETTE           hOldPal=nullptr; // Handle to palette
	WORD               NewBPP;       // New bits per pixel
	DWORD              NewComp;      // New compression format
	
	/* Check for a valid bitmap handle */
	if (!hBitmap)
		return nullptr;
	
	/* Validate wBitCount and dwCompression
	 * They must match correctly (i.e., BI_RLE4 and 4 BPP or
	 * BI_RLE8 and 8BPP, etc.) or we return failure
     */
	if (wBitCount == 0)
	{
		NewComp = dwCompression;
		if (NewComp == BI_RLE4)
			NewBPP = 4;
		else if (NewComp == BI_RLE8)
			NewBPP = 8;
		else /* Not enough info */
			return nullptr;
	}
	else if (wBitCount == 1 && dwCompression == BI_RGB)
	{
		NewBPP = wBitCount;
		NewComp = BI_RGB;
	}
	else if (wBitCount == 4)
	{
		NewBPP = wBitCount;
		if (dwCompression == BI_RGB || dwCompression == BI_RLE4)
			NewComp = dwCompression;
		else
			return nullptr;
	}
	else if (wBitCount == 8)
	{
		NewBPP = wBitCount;
		if (dwCompression == BI_RGB || dwCompression == BI_RLE8)
			NewComp = dwCompression;
		else
			return nullptr;
	}
	else if (wBitCount == 24 && dwCompression == BI_RGB)
	{
		NewBPP = wBitCount;
		NewComp = BI_RGB;
	}
	else
		return nullptr;
	
	/* Get info about the bitmap */
	GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap);
	
	/* Fill in the BITMAPINFOHEADER appropriately */
	bi.biSize               = sizeof(BITMAPINFOHEADER);
	bi.biWidth              = Bitmap.bmWidth;
	bi.biHeight             = Bitmap.bmHeight;
	bi.biPlanes             = 1;
	bi.biBitCount           = NewBPP;
	bi.biCompression        = NewComp;
	bi.biSizeImage          = 0;
	bi.biXPelsPerMeter      = 0;
	bi.biYPelsPerMeter      = 0;
	bi.biClrUsed            = 0;
	bi.biClrImportant       = 0;
	
	/* Go allocate room for the new DIB */
	hNewDIB = (HDIB)AllocRoomForDIB(bi, hBitmap);
	if (!hNewDIB)
		return nullptr;
	
	/* Get a pointer to the new DIB */
	lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB);
	
	/* If we have a palette, get a DC and select/realize it */
	if (hPal)
	{
		hDC  = GetDC(nullptr);
		hOldPal = SelectPalette(hDC, hPal, FALSE);
		RealizePalette(hDC);
	}
	
	/* Call GetDIBits and get the new DIB bits */
	if (!GetDIBits(hDC, hBitmap, 0, (WORD) lpbi->biHeight,
		(LPSTR)lpbi + (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi),
		(LPBITMAPINFO)lpbi, DIB_RGB_COLORS))
	{
		GlobalUnlock(hNewDIB);
		GlobalFree(hNewDIB);
		hNewDIB = nullptr;
	}
	
	/* Clean up and return */
	if (hOldPal)
	{
		SelectPalette(hDC, hOldPal, TRUE);
		RealizePalette(hDC);
		ReleaseDC(nullptr, hDC);
	}
	
	if (hNewDIB)
	{
		/* Unlock the new DIB's memory block */
		GlobalUnlock(hNewDIB);
	}
	
	return hNewDIB;
}

DWORD PASCAL CJpegFile::MyWrite(int iFileHandle, VOID FAR *lpBuffer, DWORD dwBytes)
{
	DWORD dwBytesTmp = dwBytes;       // Save # of bytes for return value
	BYTE *hpBuffer = (BYTE *)lpBuffer;   // make a huge pointer to the data
	
	/*
	 * Write out the data in 32767 byte chunks.
     */
	
	while (dwBytes > 32767)
	{
		if (_lwrite(iFileHandle, (LPSTR)hpBuffer, (WORD)32767) != 32767)
			return 0;
		dwBytes -= 32767;
		hpBuffer += 32767;
	}
	
	/* Write out the last chunk (which is < 32767 bytes) */
	if (_lwrite(iFileHandle, (LPSTR)hpBuffer, (WORD)dwBytes) != (WORD)dwBytes)
		return 0;
	return dwBytesTmp;
}

WORD FAR CJpegFile::SaveDIB(HDIB hDib, LPSTR lpFileName)
{
	BITMAPFILEHEADER bmfHdr; // Header for Bitmap file
	LPBITMAPINFOHEADER lpBI;   // Pointer to DIB info structure
	FILE* fileHandle;     // file handle for opened file
	DWORD dwDIBSize;
//	DWORD dwError;   // Error return from MyWrite
	
	if (hDib == nullptr)
		return ERR_INVALIDHANDLE;

#ifdef _MSC_VER
	fopen_s(&fileHandle, lpFileName, "wb");
#else
	fileHandle = fopen(lpFileName, "wb");
#endif

	if (fileHandle == nullptr)
		return ERR_OPEN;
	
	/*
	* Get a pointer to the DIB memory, the first of which contains
	* a BITMAPINFO structure
    */
	lpBI = (LPBITMAPINFOHEADER)GlobalLock(hDib);
	if (!lpBI)
		return ERR_LOCK;
	
	// Check to see if we're dealing with an OS/2 DIB.  If so, don't
	// save it because our functions aren't written to deal with these
	// DIBs.
	
	if (lpBI->biSize != sizeof(BITMAPINFOHEADER))
	{
		GlobalUnlock(hDib);
		return ERR_NOT_DIB;
	}
	
	/*
    * Fill in the fields of the file header
    */
	
	/* Fill in file type (first 2 bytes must be "BM" for a bitmap) */
	bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM"
	
	// Calculating the size of the DIB is a bit tricky (if we want to
	// do it right).  The easiest way to do this is to call GlobalSize()
	// on our global handle, but since the size of our global memory may have
	// been padded a few bytes, we may end up writing out a few too
	// many bytes to the file (which may cause problems with some apps,
	// like HC 3.0).
	//
	// So, instead let's calculate the size manually.
	//
	// To do this, find size of header plus size of color table.  Since the
	// first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains
	// the size of the structure, let's use this.
	
	dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);  // Partial Calculation
	
	// Now calculate the size of the image
	
	if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4)) {
		
		// It's an RLE bitmap, we can't calculate size, so trust the
		// biSizeImage field
		
		dwDIBSize += lpBI->biSizeImage;
	}
	else {
		DWORD dwBmBitsSize;  // Size of Bitmap Bits only
		
		// It's not RLE, so size is Width (DWORD aligned) * Height
		
		dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) * lpBI->biHeight;
		
		dwDIBSize += dwBmBitsSize;
		
		// Now, since we have calculated the correct size, why don't we
		// fill in the biSizeImage field (this will fix any .BMP files which 
		// have this field incorrect).
		
		lpBI->biSizeImage = dwBmBitsSize;
	}
	
	
	// Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER)
	
	bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);
	bmfHdr.bfReserved1 = 0;
	bmfHdr.bfReserved2 = 0;
	
	/*
    * Now, calculate the offset the actual bitmap bits will be in
    * the file -- It's the Bitmap file header plus the DIB header,
    * plus the size of the color table.
    */
	bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize +
		PaletteSize((LPSTR)lpBI);
	
	// Encrypt Data
	BYTE *encrypt_data;
	DWORD encrypt_len, i, j;
	BYTE random_byte[4];

	// Generate Random Byte.
	srand((unsigned) time(nullptr));
	for (i = 0; i < 4; i++)
		random_byte[i] = rand() % 0x100;

	encrypt_len = sizeof(BITMAPFILEHEADER) + dwDIBSize + 4;
	encrypt_data = new BYTE[encrypt_len];
	for (i = 0, j = 0; i < 4; i++, j++)
		encrypt_data[j] = Encrypt(random_byte[i]);

	for (i = 0; i < sizeof(BITMAPFILEHEADER); i++, j++)
		encrypt_data[j] = Encrypt(*((BYTE*) (&bmfHdr) + i));

	for (i = 0; i < dwDIBSize; i++, j++)
		encrypt_data[j] = Encrypt(*((BYTE*) lpBI + i));

	assert(j == encrypt_len);
	fwrite(encrypt_data, encrypt_len, 1, fileHandle);
	/* Write the file header */
//	fwrite(&bmfHdr, sizeof(BITMAPFILEHEADER), 1, fileHandle);
	
	/*
    * Write the DIB header and the bits -- use local version of
    * MyWrite, so we can write more than 32767 bytes of data
    */
//	dwError = MyWrite(fh, (LPSTR)lpBI, dwDIBSize);
//	fwrite(lpBI, dwDIBSize, 1, fileHandle);
	GlobalUnlock(hDib);
	fclose(fileHandle);

	delete[] encrypt_data;

	return 0;
	
//	if (dwError == 0)
//		return ERR_OPEN; // oops, something happened in the write
//	else
//		return 0; // Success code
}

RGBQUAD CJpegFile::QuadFromWord(WORD b16)
{
   BYTE bytVals[] =
   {
     0,  16, 24, 32,  40, 48, 56, 64,
     72, 80, 88, 96, 104,112,120,128,
     136,144,152,160,168,176,184,192,
     200,208,216,224,232,240,248,255
   };

   WORD wR = b16;
   WORD wG = b16;
   WORD wB = b16;

   wR <<= 1; wR >>= 11;
   wG <<= 6; wG >>= 11;
   wB <<= 11; wB >>= 11;

   RGBQUAD rgb;

   rgb.rgbReserved = 0;
   rgb.rgbBlue     = bytVals[wB];
   rgb.rgbGreen    = bytVals[wG];
   rgb.rgbRed      = bytVals[wR];

   return rgb;
}

BOOL CJpegFile::DibToSamps(
	HANDLE					hDib,
	int						nSampsPerRow,
	jpeg_compress_struct	cinfo,
	JSAMPARRAY				jsmpPixels,
	const char*				pcsMsg)
{
	//Sanity...
	if (hDib == nullptr    ||
		nSampsPerRow <= 0 || pcsMsg == nullptr) 
	{ 
		if (pcsMsg !=nullptr) 
			pcsMsg="Invalid input data"; 
		return FALSE; 
	} 
	
	int r=0, p=0, q=0, b=0, n=0, 
		nUnused=0, nBytesWide=0, nUsed=0, nLastBits=0, nLastNibs=0, nCTEntries=0,
		nRow=0, nByte=0, nPixel=0;
	BYTE bytCTEnt=0;
	LPBITMAPINFOHEADER pbBmHdr = (LPBITMAPINFOHEADER)GlobalLock(hDib);
	
	switch (pbBmHdr->biBitCount)
	{
	case 1:
		nCTEntries = 2;   //Monochrome
		break;
		
	case 4:
		nCTEntries = 16;  //16-color
		break;
		
	case 8:
		nCTEntries = 256; //256-color
		break;
		
	case 16:
	case 24:
	case 32:
		nCTEntries = 0;   //No color table needed
		break;
		
	default:
		pcsMsg = "Invalid bitmap bit count";
		GlobalUnlock(hDib);
		return FALSE; //Unsupported format
	}
	
	//Point to the color table and pixels
	uintptr_t     dwCTab = (uintptr_t)pbBmHdr + pbBmHdr->biSize;
	LPRGBQUAD pCTab  = (LPRGBQUAD)(dwCTab);
	LPSTR     lpBits = (LPSTR)pbBmHdr +
		(WORD)pbBmHdr->biSize +
		(WORD)(nCTEntries * sizeof(RGBQUAD));
	
	//Different formats for the image bits
	LPBYTE   lpPixels = (LPBYTE)  lpBits;
	RGBQUAD* pRgbQs   = (RGBQUAD*)lpBits;
	WORD*    wPixels  = (WORD*)   lpBits;
	
	//Set up the jsamps according to the bitmap's format.
	//Note that rows are processed bottom to top, because
	//that's how bitmaps are created.
	switch (pbBmHdr->biBitCount)
	{
	case 1:
		nUsed      = (pbBmHdr->biWidth + 7) / 8;
		nUnused    = (((nUsed + 3) / 4) * 4) - nUsed;
		nBytesWide = nUsed + nUnused;
		nLastBits  = 8 - ((nUsed * 8) - pbBmHdr->biWidth);
		
		for (r=0; r < pbBmHdr->biHeight; r++)
		{
			for (p=0,q=0; p < nUsed; p++) 
			{ 
				nRow=(pbBmHdr->biHeight-r-1) * nBytesWide;
				nByte =  nRow + p;
				
				int nBUsed = (p <(nUsed-1)) ? 8 : nLastBits;
				for(b=0; b < nBUsed;b++) 
				{ 
					bytCTEnt = lpPixels[nByte] << b; 
					bytCTEnt = bytCTEnt >> 7;
					
					jsmpPixels[r][q+0] = pCTab[bytCTEnt].rgbRed;
					jsmpPixels[r][q+1] = pCTab[bytCTEnt].rgbGreen;
					jsmpPixels[r][q+2] = pCTab[bytCTEnt].rgbBlue;
					
					q += 3;
				}
			}
		}
		break;
		
	case 4:
		nUsed      = (pbBmHdr->biWidth + 1) / 2;
		nUnused    = (((nUsed + 3) / 4) * 4) - nUsed;
		nBytesWide = nUsed + nUnused;
		nLastNibs  = 2 - ((nUsed * 2) - pbBmHdr->biWidth);
		
		for (r=0; r < pbBmHdr->biHeight;r++)
		{
			for (p=0,q=0; p < nUsed;p++) 
			{ 
				nRow=(pbBmHdr->biHeight-r-1) * nBytesWide;
				nByte = nRow + p;
				
				int nNibbles = (p < nUsed - 1) ?
					2 : nLastNibs;
				
				for(n=0;n < nNibbles;n++)
				{
					bytCTEnt = lpPixels[nByte] << (n*4);
					bytCTEnt = bytCTEnt >> (4-(n*4));
					jsmpPixels[r][q+0] = pCTab[bytCTEnt].rgbRed;
					jsmpPixels[r][q+1] = pCTab[bytCTEnt].rgbGreen;
					jsmpPixels[r][q+2] = pCTab[bytCTEnt].rgbBlue;
					q += 3;
				}
			}
		}
		break;
		
	default:
	case 8: //Each byte is a pointer to a pixel color
		nUnused = (((pbBmHdr->biWidth + 3) / 4) * 4) -
			pbBmHdr->biWidth;
		
		for (r=0;r < pbBmHdr->biHeight; r++)
		{
			for (p=0,q=0; p < pbBmHdr->biWidth; p++,q+=3)
			{
				nRow   = (pbBmHdr->biHeight-r-1) * (pbBmHdr->biWidth + nUnused);
				nPixel =  nRow + p;
				
				jsmpPixels[r][q+0] = pCTab[lpPixels[nPixel]].rgbRed;
				jsmpPixels[r][q+1] = pCTab[lpPixels[nPixel]].rgbGreen;
				jsmpPixels[r][q+2] = pCTab[lpPixels[nPixel]].rgbBlue;
			}
		}
		break;
		
	case 16: //Hi-color (16 bits per pixel)
		for (r=0;r < pbBmHdr->biHeight; r++)
		{
			for (p=0,q=0; p < pbBmHdr->biWidth; p++,q+=3)
			{
				nRow    = (pbBmHdr->biHeight-r-1) * pbBmHdr->biWidth;
				nPixel  = nRow + p;
				
				RGBQUAD quad = QuadFromWord(wPixels[nPixel]);
				
				jsmpPixels[r][q+0] = quad.rgbRed;
				jsmpPixels[r][q+1] = quad.rgbGreen;
				jsmpPixels[r][q+2] = quad.rgbBlue;
			}
		}
		break;
		
	case 24:
		nBytesWide =  (pbBmHdr->biWidth*3);
		nUnused    =  (((nBytesWide + 3) / 4) * 4) -
			nBytesWide;
		nBytesWide += nUnused;
		
		for (r=0;r < pbBmHdr->biHeight;r++)
		{
			for (p=0,q=0;p < (nBytesWide-nUnused); p+=3,q+=3)
			{ 
				nRow = (pbBmHdr->biHeight-r-1) * nBytesWide;
				nPixel  = nRow + p;
				
				jsmpPixels[r][q+0] = lpPixels[nPixel+2]; //Red
				jsmpPixels[r][q+1] = lpPixels[nPixel+1]; //Green
				jsmpPixels[r][q+2] = lpPixels[nPixel+0]; //Blue
			}
		}
		break;
		
	case 32:
		for (r=0; r < pbBmHdr->biHeight; r++)
		{
			for (p=0,q=0; p < pbBmHdr->biWidth; p++,q+=3)
			{
				nRow    = (pbBmHdr->biHeight-r-1) *
					pbBmHdr->biWidth;
				nPixel  = nRow + p;
				
				jsmpPixels[r][q+0] = pRgbQs[nPixel].rgbRed;
				jsmpPixels[r][q+1] = pRgbQs[nPixel].rgbGreen;
				jsmpPixels[r][q+2] = pRgbQs[nPixel].rgbBlue;
			}
		}
		break;
	}   //end switch

	GlobalUnlock(hDib);

	return TRUE;
}

BOOL CJpegFile::JpegFromDib(
	HANDLE		hDib,     // Handle to DIB
	int			nQuality, // JPEG quality (0-100)
	std::string csJpeg,   // Pathname to jpeg file
	const char* pcsMsg)   // Error msg to return
{
	//Basic sanity checks...
	if (nQuality < 0 || nQuality > 100 ||
		hDib   == nullptr ||
		pcsMsg == nullptr ||
		csJpeg == "")
	{
		if (pcsMsg != nullptr)
			pcsMsg = "Invalid input data";
		
		return FALSE;
	}
	
	pcsMsg = "";
	
	LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDib);
	
	byte *buf2 = 0;
	
	//Use libjpeg functions to write scanlines to disk in JPEG format
	struct jpeg_compress_struct cinfo;
	struct jpeg_error_mgr       jerr;
	
	FILE*      pOutFile;     //Target file 
	int        nSampsPerRow; //Physical row width in image buffer 
	JSAMPARRAY jsmpArray;    //Pixel RGB buffer for JPEG file
	
	cinfo.err = jpeg_std_error(&jerr); //Use default error handling (ugly!)
	
	jpeg_create_compress(&cinfo);
	
	if ((pOutFile = fopen(csJpeg.c_str(), "wb")) == nullptr)
	{
		pcsMsg = "Cannot open Fail";
		jpeg_destroy_compress(&cinfo);
		GlobalUnlock(hDib);
		return FALSE;
	}
	
	jpeg_stdio_dest(&cinfo, pOutFile);
	
	cinfo.image_width      = lpbi->biWidth;  //Image width and height, in pixels 
	cinfo.image_height     = lpbi->biHeight;
	cinfo.input_components = 3;              //Color components per pixel
	//(RGB_PIXELSIZE - see jmorecfg.h)
	cinfo.in_color_space   = JCS_RGB; 	     //Colorspace of input image
	
	jpeg_set_defaults(&cinfo);
	
	jpeg_set_quality(&cinfo,
		nQuality, //Quality: 0-100 scale
		TRUE);    //Limit to baseline-JPEG values
	
	jpeg_start_compress(&cinfo, TRUE);
	
	//JSAMPLEs per row in output buffer
	nSampsPerRow = cinfo.image_width * cinfo.input_components; 
	
	//Allocate array of pixel RGB values
	jsmpArray = (*cinfo.mem->alloc_sarray)
		((j_common_ptr) &cinfo,
		JPOOL_IMAGE,
		nSampsPerRow,
		cinfo.image_height);
	
	GlobalUnlock(hDib);

	if (DibToSamps(hDib,
		nSampsPerRow,
		cinfo,
		jsmpArray,
		pcsMsg))
	{
		//Write the array of scan lines to the JPEG file
		(void)jpeg_write_scanlines(&cinfo,
			jsmpArray,
			cinfo.image_height);
	}
	
	jpeg_finish_compress(&cinfo); //Always finish
	
	fclose(pOutFile);
	
	jpeg_destroy_compress(&cinfo); //Free resources
	
	if(strlen(pcsMsg) > 0 )
		return FALSE;
	else
		return TRUE;
}

BOOL CJpegFile::EncryptJPEG(
	HANDLE			hDib,	// Handle to DIB
	int			nQuality,	// JPEG quality (0-100)
	std::string	csJpeg,		// Pathname to jpeg file
	const char*	pcsMsg)		// Error msg to return
{
	if (!JpegFromDib(hDib, nQuality, csJpeg, pcsMsg))
		return FALSE;

	uint8_t* data_byte;
	size_t encrypt_len, i;
	FILE* fileHandle = nullptr;

	// JPEG 파일 읽어오기
#ifdef _MSC_VER
	fopen_s(&fileHandle, csJpeg.c_str(), "rb");
#else
	fileHandle = fopen(csJpeg.c_str(), "rb");
#endif
	if (fileHandle == nullptr)
		return FALSE;

	size_t fileSize = 0;
	fseek(fileHandle, 0, SEEK_END);
	fileSize = static_cast<size_t>(ftell(fileHandle));

	if (fileSize == 0)
	{
		fclose(fileHandle);
		return FALSE;
	}

	fseek(fileHandle, 0, SEEK_SET);

	data_byte = new BYTE[fileSize+8];

	srand((unsigned)time( nullptr ));
	for(i = 0; i < 4; i++) data_byte[i] = rand() % 0x100;

	data_byte[4] = 'K';
	data_byte[5] = 'S';
	data_byte[6] = 'C';
	data_byte[7] = 1;

	fread(data_byte + 8, fileSize, 1, fileHandle);
	fclose(fileHandle);
	fileHandle = nullptr;

	m_r = 1124;

	// JPEG 파일 Encoding
	encrypt_len = fileSize + 8;
	for (i = 0; i < encrypt_len; i++)
		data_byte[i] = Encrypt(data_byte[i]);

	// Encoding 파일 Writing
#ifdef _MSC_VER
	fileHandle = nullptr;
	fopen_s(&fileHandle, csJpeg.c_str(), "wb");
#else
	fileHandle = fopen(csJpeg.c_str(), "wb");
#endif
	if (fileHandle == nullptr)
	{
		delete[] data_byte;
		return FALSE;
	}

	fwrite(data_byte, encrypt_len, 1, fileHandle);
	fclose(fileHandle);

	delete[] data_byte;

	return TRUE;
}

BOOL CJpegFile::DecryptJPEG(std::string csJpeg)
{
	char szTempName[MAX_PATH] = {};
	std::string szDstpath;
	uint8_t* dst_data, *src_data;
	size_t jpegLen, kscLen;
	size_t i, j;

	size_t rfv = csJpeg.rfind('\\');
	szDstpath = csJpeg;

	if (rfv != std::string::npos)
		szDstpath.resize(rfv);

	if (szDstpath.size() == 2)
		szDstpath += '\\';//_T('\\');

	if (GetTempFileName(szDstpath.c_str(), "ksc", 0, szTempName) == 0)
	{
//		AfxMessageBox("임시 파일을 생성할 수가 없습니다.", MB_ICONSTOP|MB_OK);
		return FALSE;
	}

	FILE* kscHandle = nullptr;
	FILE* jpegHandle = nullptr;

#ifdef _MSC_VER
	fopen_s(&kscHandle, csJpeg.c_str(), "rb");
#else
	kscHandle = fopen(csJpeg.c_str(), "rb");
#endif

	if (kscHandle == nullptr)
	{
//		AfxMessageBox("소스 파일이 존재하지 않습니다. 다른 파일을 선택해주세요.", MB_ICONSTOP|MB_OK);
		return FALSE;
	}

#ifdef _MSC_VER
	fopen_s(&jpegHandle, szTempName, "wb");
#else
	jpegHandle = fopen(szTempName, "wb");
#endif

	if (jpegHandle == nullptr)
	{
		fclose(kscHandle);
		return FALSE;
	}

	fseek(kscHandle, 0, SEEK_END);
	kscLen = static_cast<size_t>(ftell(kscHandle));
	if (kscLen < 8)
	{
		fclose(kscHandle);
		fclose(jpegHandle);
		return FALSE;
	}

	fseek(kscHandle, 0, SEEK_SET);

	jpegLen = kscLen - 8;

	src_data = new uint8_t[kscLen];
	dst_data = new uint8_t[jpegLen];

	fread(src_data, kscLen, 1, kscHandle);
	fclose(kscHandle);
	kscHandle = nullptr;

	m_r = 1124;
	for (i = 0; i < 4; i++)
		Decrypt(src_data[i]);

	uint8_t magic[4];
	for (i = 4; i < 8; i++)
		magic[i - 4] = Decrypt(src_data[i]);

	if (magic[0] == 'K' && magic[1] == 'S' && magic[2] == 'C' && magic[3] == 1)
	{
		//버전 1번
	}
	else
	{
		fclose(jpegHandle);

		delete[] dst_data;
		delete[] src_data;
		return FALSE;
	}

	for (j = 0; i < kscLen; i++, j++)
		dst_data[j] = Decrypt(src_data[i]);

	fwrite(dst_data, jpegLen, 1, jpegHandle);
	fclose(jpegHandle);

	delete[] dst_data;
	delete[] src_data;

	LoadJpegFile(szTempName);

	std::error_code ec;
	std::filesystem::remove(szTempName, ec);

	return TRUE;
}

BOOL CJpegFile::SaveFromDecryptToJpeg(std::string csKsc, std::string csJpeg)
{
	FILE* kscHandle = nullptr;
	FILE* jpegHandle = nullptr;
	uint8_t* dst_data, *src_data;
	size_t i, j;

#ifdef _MSC_VER
	fopen_s(&kscHandle, csKsc.c_str(), "rb");
#else
	kscHandle = fopen(csKsc.c_str(), "rb");
#endif

	if (kscHandle == nullptr)
		return FALSE;

#ifdef _MSC_VER
	fopen_s(&jpegHandle, csJpeg.c_str(), "wb");
#else
	jpegHandle = fopen(csJpeg.c_str(), "wb");
#endif

	if (jpegHandle == nullptr)
	{
		fclose(kscHandle);
		return FALSE;
	}

	size_t kscLen = 0;
	
	fseek(kscHandle, 0, SEEK_END);
	kscLen = static_cast<size_t>(ftell(kscHandle));
	if (kscLen < 8)
	{
		fclose(jpegHandle);
		fclose(kscHandle);
		return FALSE;
	}

	fseek(kscHandle, 0, SEEK_SET);

	size_t jpegLen = kscLen - 8;

	src_data = new uint8_t[kscLen];
	dst_data = new uint8_t[jpegLen];

	fread(src_data, kscLen, 1, kscHandle);
	fclose(kscHandle);
	kscHandle = nullptr;

	m_r = 1124;
	for (i = 0; i < 8; i++)
		Decrypt(src_data[i]);

	for (j = 0; i < kscLen; i++, j++)
		dst_data[j] = Decrypt(src_data[i]);

	fwrite(dst_data, jpegLen, 1, jpegHandle);
	fclose(jpegHandle);

	delete[] dst_data;
	delete[] src_data;

	return TRUE;
}

// ===== END JpegFile/JpegFile.cpp =====

// ===== BEGIN JpegFile/JpegFile.h =====
#line 1 "JpegFile/JpegFile.h"
﻿////////////////////////////////////////////////////////////
//
//	JpegFile - A C++ class to allow reading and writing of
//	RGB and Grayscale JPEG images. (actually, it reads all forms
//	that the JPEG lib will decode into RGB or grayscale) and
//	writes only RGB and Grayscale.
//
//	It is based on a Win32 compilation of the IJG V.6a code.
//
//	This will only work on 32-bit Windows systems. I have only 
//	tried this with Win 95, VC++ 4.1.
//
//	This class Copyright 1997, Chris Losinger
//	This is free to use and modify provided my name is included.
//
//	Comments:
//	Thanks to Robert Johnson for discovering a DWORD-alignment bug
//	Thanks to Lee Bode for catching a bug in CMfcappView::OnFileGetdimensionsjpg() 
//
////////////////////////////////////////////////////////////
//
//	General Usage:
//
//	#include this file.
//	link with jpeglib2.lib
//
//	All functions here are static. There is no need to have a JpegFile object.
//	There is actually nothing in a JpegFile object anyway. 
//
//	So, you can do this :
//
//		BOOL ok = JpegFile::vertFlipBuf(buf, widthbytes, height);
//
//	instead of this :
//
//		JpegFile jpgOb;
//		BOOL ok = jpgOb.vertFlipBuf(buf, widthbytes, height);
//
/////
//
//	Linking usage :
//	It is sometimes necessary to set /NODEFAULTLIB:LIBC (or LIBCD) to use this
//	class. 
//
/////
//
//	Error reporting:
//	The class generates message boxes in response to JPEG errors.
//
//	The JpegFile.cpp fn my_error_exit defines the behavior for
//	fatal errors : show msg box, return to caller.
//
//	Warnings are handled by jpeglib.lib - which	generates msg boxes too.
//	
////////////////////////////////////////////////////////////////

/*
////////////////////////////////////////////////////////////////
//	Reading Usage :

	UINT height;
	UINT width;
	BYTE *dataBuf;
   //read the file
   dataBuf=JpegFile::JpegFileToRGB(fileName,
								&width,
								&height);
	if (dataBuf==nullptr) {
		return;
	}

	// RGB -> BGR
	JpegFile::BGRFromRGB(dataBuf, m_width, m_height);


	BYTE *buf;
	// create a DWORD aligned buffer from the JpegFile object
	buf = JpegFile::MakeDwordAlignedBuf(dataBuf,
									width,
									height,
									&m_widthDW);

	// flip that buffer
	JpegFile::VertFlipBuf(m_buf, m_widthDW, m_height);

	// you now have a buffer ready to be used as a DIB

	// be sure to delete [] dataBuf;	// !!!!!!!!!!
	//			delete [] buf;


	// Writing Usage


	// this assumes your data is stored as a 24-bit RGB DIB.
	// if you have a 1,4,8,15/16 or 32 bit DIB, you'll have to 
	// do some work to get it into a 24-bit RGB state.

	BYTE *tmp=nullptr;

	// assume buf is a DWORD-aligned BGR buffer, vertically flipped
	// as if read from a BMP file.

	// un-DWORD-align
	tmp=JpegFile::RGBFromDWORDAligned(buf,
									widthPix,
									widthBytes,
									height);

	// vertical flip
	JpegFile::VertFlipBuf(tmp, widthPix * 3, height);

	// reverse BGR
	JpegFile::BGRFromRGB(tmp, widthPix, height);

	if (tmp==nullptr) {
		AfxMessageBox("~DWORD Memory Error");
		return;
	}

	// write it
	BOOL ok=JpegFile::RGBToJpegFile(fileName, 
						tmp,
						width,
						height,
						TRUE, 
						75);
	if (!ok) {
		AfxMessageBox("Write Error");
	}

	delete [] tmp;

////////////////////////////////////////////////////////////////

*/

//
//	for DWORD aligning a buffer
//

#ifndef _INCLUDE_JPEGFILE
#define _INCLUDE_JPEGFILE

#include <stdio.h>
#include <string>

#ifdef __cplusplus
	extern "C" {
#endif // __cplusplus

#include "jpeglib.h"

#ifdef __cplusplus
	}
#endif // __cplusplus

/*
 * <setjmp.h> is used for the optional error recovery mechanism shown in
 * the second part of the example.
 */
#include <setjmp.h>

#define HDIB HANDLE
#define PALVERSION   0x300
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

enum {
      ERR_MIN = 0,                     // All error #s >= this value
      ERR_NOT_DIB = 0,                 // Tried to load a file, NOT a DIB!
      ERR_MEMORY,                      // Not enough memory!
      ERR_READ,                        // Error reading file!
      ERR_LOCK,                        // Error on a GlobalLock()!
      ERR_OPEN,                        // Error opening a file!
      ERR_CREATEPAL,                   // Error creating palette.
      ERR_GETDC,                       // Couldn't get a DC.
      ERR_CREATEDDB,                   // Error create a DDB.
      ERR_STRETCHBLT,                  // StretchBlt() returned failure.
      ERR_STRETCHDIBITS,               // StretchDIBits() returned failure.
      ERR_SETDIBITSTODEVICE,           // SetDIBitsToDevice() failed.
      ERR_STARTDOC,                    // Error calling StartDoc().
      ERR_NOGDIMODULE,                 // Couldn't find GDI module in memory.
      ERR_SETABORTPROC,                // Error calling SetAbortProc().
      ERR_STARTPAGE,                   // Error calling StartPage().
      ERR_NEWFRAME,                    // Error calling NEWFRAME escape.
      ERR_ENDPAGE,                     // Error calling EndPage().
      ERR_ENDDOC,                      // Error calling EndDoc().
      ERR_SETDIBITS,                   // Error calling SetDIBits().
      ERR_FILENOTFOUND,                // Error opening file in GetDib()
      ERR_INVALIDHANDLE,               // Invalid Handle
      ERR_DIBFUNCTION,                 // Error on call to DIB function
      ERR_MAX                          // All error #s < this value
     };

#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)


class CJpegFile 
{
public:
	////////////////////////////////////////////////////////////////
	// read a JPEG file to an RGB buffer - 3 bytes per pixel
	// returns a ptr to a buffer .
	// caller is responsible for cleanup!!!
	// BYTE *buf = JpegFile::JpegFileToRGB(....);
	// delete [] buf;

	BYTE * JpegFileToRGB(std::string fileName,			// path to image
						 UINT *width,					// image width in pixels
						 UINT *height);				// image height

	////////////////////////////////////////////////////////////////
	// write a JPEG file from a 3-component, 1-byte per component buffer

	BOOL RGBToJpegFile( std::string fileName,				// path
						BYTE *dataBuf,					// RGB buffer
						UINT width,						// pixels
						UINT height,					// rows
						BOOL color,						// TRUE = RGB
														// FALSE = Grayscale
						int quality);					// 0 - 100


	////////////////////////////////////////////////////////////////
	// fetch width / height of an image
	
	BOOL GetJPGDimensions(	std::string fileName,			// path
							UINT *width,				// pixels
							UINT *height);

	////////////////////////////////////////////////////////////////
	//	utility functions
	//	to do things like DWORD-align, flip, convert to grayscale, etc.
	//

	////////////////////////////////////////////////////////////////
	// allocates a DWORD-aligned buffer, copies data buffer
	// caller is responsible for delete []'ing the buffer

	BYTE * MakeDwordAlignedBuf( BYTE *dataBuf,			// input buf
								UINT widthPix,			// input pixels
								UINT height,			// lines
								UINT *uiOutWidthBytes);	// new width bytes


	////////////////////////////////////////////////////////////////
	// if you have a DWORD aligned buffer, this will copy the
	// RGBs out of it into a new buffer. new width is widthPix * 3 bytes
	// caller is responsible for delete []'ing the buffer
	
	BYTE *RGBFromDWORDAligned(	BYTE *inBuf,			// input buf
								UINT widthPix,			// input size
								UINT widthBytes,		// input size
								UINT height);

	////////////////////////////////////////////////////////////////
	// vertically flip a buffer - for BMPs
	// in-place
	
	// note, this routine works on a buffer of width widthBytes: not a 
	// buffer of widthPixels.
	BOOL VertFlipBuf(	BYTE * inbuf,					// input buf
						UINT widthBytes,				// input width bytes
						UINT height);					// height

	// NOTE :
	// the following routines do their magic on buffers with a whole number
	// of pixels per data row! these are assumed to be non DWORD-aligned buffers.

	////////////////////////////////////////////////////////////////
	// convert RGB to grayscale	using luminance calculation
	// in-place
	
	BOOL MakeGrayScale(	BYTE *buf,						// input buf 
						UINT widthPix,					// width in pixels
						UINT height);					// height

	////////////////////////////////////////////////////////////////
	// swap Red and Blue bytes
	// in-place
	
	BOOL BGRFromRGB(BYTE *buf,							// input buf
					UINT widthPix,						// width in pixels
					UINT height);						// lines

	int FAR			PalEntriesOnDevice(HDC hDC);
	WORD FAR		DIBNumColors(LPSTR lpDIB);
	WORD FAR		PaletteSize(LPSTR lpDIB);
	HDIB FAR		BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal);
	HBITMAP FAR		CopyScreenToBitmap(LPRECT lpRect);
	HDIB FAR		CopyScreenToDIB(LPRECT lpRect);
	HANDLE			AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap);
	HDIB FAR		ChangeBitmapFormat(HBITMAP  hBitmap, WORD wBitCount, DWORD wCompression, HPALETTE hPal);
	DWORD PASCAL	MyWrite(int iFileHandle, VOID FAR *lpBuffer, DWORD dwBytes);
	HPALETTE FAR	GetSystemPalette(void);
	WORD FAR		SaveDIB(HDIB hDib, LPSTR lpFileName);
	RGBQUAD			QuadFromWord(WORD b16);
	BOOL			DibToSamps(	HANDLE hDib,
								int nSampsPerRow,
								struct jpeg_compress_struct cinfo,
								JSAMPARRAY jsmpPixels,
								const char* pcsMsg);
	BOOL			JpegFromDib(HANDLE hDib,		//Handle to DIB
								int nQuality,		//JPEG quality (0-100)
								std::string csJpeg, //Pathname to jpeg file
								const char* pcsMsg);		//Error msg to return
	virtual BOOL	EncryptJPEG(HANDLE hDib,		//Handle to DIB
								int nQuality,		//JPEG quality (0-100)
								std::string csJpeg, //Pathname to jpeg file
								const char* pcsMsg);		//Error msg to return

	BOOL			SaveFromDecryptToJpeg(std::string csKsc, std::string csJpeg);
	virtual BOOL	DecryptJPEG(std::string csJpeg);
	virtual BOOL	LoadJpegFile(std::string csJpeg) { return TRUE;}

	virtual void	DrawImage(HDC hDC) {}

	static WORD m_r;
	static WORD m_c1;
	static WORD m_c2;
	static BYTE Encrypt(BYTE plain)
	{
		BYTE cipher;
		cipher = (plain ^ (m_r>>8));
		m_r = (cipher + m_r) * m_c1 + m_c2;
		return cipher;
	}

	static BYTE Decrypt(BYTE cipher)
	{
		BYTE plain;
		plain = (cipher ^ (m_r>>8));
		m_r = (cipher + m_r) * m_c1 + m_c2;
		return plain;
	}


	////////////////////////////////////////////////////////////////
	// these do nothing
	CJpegFile();		// creates an empty object
	~CJpegFile();	// destroys nothing
};

#endif 

// ===== END JpegFile/JpegFile.h =====

// ===== BEGIN KscViewer/KscViewer.cpp =====
#line 1 "KscViewer/KscViewer.cpp"
﻿// KscViewer.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "KscViewer.h"

#include "MainFrm.h"
#include "KscViewerDoc.h"
#include "KscViewerView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKscViewerApp

BEGIN_MESSAGE_MAP(CKscViewerApp, CWinApp)
	//{{AFX_MSG_MAP(CKscViewerApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKscViewerApp construction

CKscViewerApp::CKscViewerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CKscViewerApp object

CKscViewerApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CKscViewerApp initialization

static BOOL NEAR PASCAL SetRegKey(LPCSTR lpszKey, LPCSTR lpszValue) 
{ 
	if (::RegSetValue(HKEY_CLASSES_ROOT, lpszKey, REG_SZ, lpszValue, lstrlen(lpszValue)) != ERROR_SUCCESS)
	{
		TRACE1("Warning: registration database update failed for key'%Fs'\n", lpszKey);
		return FALSE;
	}

	return TRUE;
} 

BOOL CKscViewerApp::InitInstance()
{
	AfxEnableControlContainer();

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("NoahSystem"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CKscViewerDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CKscViewerView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	EnableShellOpen();
	RegisterShellFileTypes();

	CString strFileTypeName;

	pDocTemplate->GetDocString(strFileTypeName, CDocTemplate::regFileTypeId);
	SetRegKey(".ksc", strFileTypeName);

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CKscViewerApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CKscViewerApp message handlers


// ===== END KscViewer/KscViewer.cpp =====

// ===== BEGIN KscViewer/KscViewer.h =====
#line 1 "KscViewer/KscViewer.h"
// KscViewer.h : main header file for the KSCVIEWER application
//

#if !defined(AFX_KSCVIEWER_H__AA838AD8_1B20_44DE_8160_D2D367204465__INCLUDED_)
#define AFX_KSCVIEWER_H__AA838AD8_1B20_44DE_8160_D2D367204465__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CKscViewerApp:
// See KscViewer.cpp for the implementation of this class
//

class CKscViewerApp : public CWinApp
{
public:
	CKscViewerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKscViewerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CKscViewerApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KSCVIEWER_H__AA838AD8_1B20_44DE_8160_D2D367204465__INCLUDED_)

// ===== END KscViewer/KscViewer.h =====

// ===== BEGIN KscViewer/KscViewerDoc.cpp =====
#line 1 "KscViewer/KscViewerDoc.cpp"
﻿// KscViewerDoc.cpp : implementation of the CKscViewerDoc class
//

#include "stdafx.h"
#include "KscViewer.h"

#include "KscViewerDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKscViewerDoc

IMPLEMENT_DYNCREATE(CKscViewerDoc, CDocument)

BEGIN_MESSAGE_MAP(CKscViewerDoc, CDocument)
	//{{AFX_MSG_MAP(CKscViewerDoc)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKscViewerDoc construction/destruction

CKscViewerDoc::CKscViewerDoc()
{
	m_pJpegFile = nullptr;
	m_pJpegFile = new CN3JpegFile;
}

CKscViewerDoc::~CKscViewerDoc()
{
	if(m_pJpegFile) delete m_pJpegFile; m_pJpegFile = nullptr;
}

BOOL CKscViewerDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	if(m_pJpegFile)
		m_pJpegFile->Release();

	m_szKscPath.Empty();

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CKscViewerDoc serialization

void CKscViewerDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CKscViewerDoc diagnostics

#ifdef _DEBUG
void CKscViewerDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CKscViewerDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CKscViewerDoc commands

BOOL CKscViewerDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
//	if (!CDocument::OnOpenDocument(lpszPathName))
//		return FALSE;
	if(m_pJpegFile == nullptr)
		return FALSE;

	char* szExt = nullptr;
	size_t nLen = strlen(lpszPathName);

	szExt = (char*)lpszPathName + nLen - 3;
	
	if(0 == lstrcmpi(szExt,"ksc"))
	{
		if(m_pJpegFile->DecryptJPEG(lpszPathName))
		{
			m_szKscPath = lpszPathName;
		}
	}
	else if(0 == lstrcmpi(szExt,"jpg"))
	{
		if(m_pJpegFile->LoadJpegFile(lpszPathName))
		{
			m_szKscPath = lpszPathName;
		}
	}

	UpdateAllViews(nullptr);
	return TRUE;
}

CN3JpegFile* CKscViewerDoc::GetJpegFile()
{
	return m_pJpegFile;
}

BOOL CKscViewerDoc::OnSaveDocument(LPCTSTR lpszPathName) 
{
	if(m_pJpegFile == nullptr) return FALSE;
	if(m_szKscPath.IsEmpty()) return FALSE;

	CString szTemp = m_szKscPath.Right(3);
	if(szTemp.CompareNoCase("ksc") != 0) return FALSE;

	m_pJpegFile->SaveFromDecryptToJpeg(m_szKscPath.GetBuffer(m_szKscPath.GetLength()), lpszPathName);

	return TRUE;
}

void CKscViewerDoc::OnFileSave() 
{
	AfxGetApp()->DoWaitCursor(1);

	CString fileName = m_szKscPath.Left(m_szKscPath.GetLength()-3);
	fileName += "jpg";

	OnSaveDocument(fileName);
	AfxGetApp()->DoWaitCursor(-1);
}

void CKscViewerDoc::OnFileSaveAs() 
{
	if(m_szKscPath.IsEmpty()) return;
	CString szTemp = m_szKscPath.Right(3);
	if(szTemp.CompareNoCase("ksc") != 0) return;

	szTemp = m_szKscPath.Right(m_szKscPath.GetLength() - (m_szKscPath.ReverseFind('\\') + 1));
	szTemp = szTemp.Left(szTemp.GetLength() - 3) + "jpg";

	CString fileName;
	CString filt="Jpeg File (*.jpg)|*.jpg||";
    
    // OPENFILENAME - so i can get to its Help page easily
	DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	CFileDialog fileDlg(FALSE,szTemp,szTemp,dwFlags,filt);

	CString initial_dir;
	GetCurrentDirectory(MAX_PATH, initial_dir.GetBuffer(MAX_PATH));
	fileDlg.m_ofn.lpstrInitialDir = (LPCTSTR)initial_dir;
	fileDlg.m_ofn.Flags|=OFN_FILEMUSTEXIST;

	if (fileDlg.DoModal()==IDOK) 
	{
		AfxGetApp()->DoWaitCursor(1);

		fileName = fileDlg.GetPathName();

		OnSaveDocument(fileName);
		AfxGetApp()->DoWaitCursor(-1);
	}            
}

// ===== END KscViewer/KscViewerDoc.cpp =====

// ===== BEGIN KscViewer/KscViewerDoc.h =====
#line 1 "KscViewer/KscViewerDoc.h"
// KscViewerDoc.h : interface of the CKscViewerDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_KSCVIEWERDOC_H__F42EC8EB_E49B_4638_B2B2_F25E9C226D55__INCLUDED_)
#define AFX_KSCVIEWERDOC_H__F42EC8EB_E49B_4638_B2B2_F25E9C226D55__INCLUDED_

#include "N3JpegFile.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CKscViewerDoc : public CDocument
{
protected: // create from serialization only
	CKscViewerDoc();
	DECLARE_DYNCREATE(CKscViewerDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKscViewerDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	//}}AFX_VIRTUAL

// Implementation
public:
	CString			m_szKscPath;
	CN3JpegFile*	m_pJpegFile;
	CN3JpegFile*	GetJpegFile();
	virtual ~CKscViewerDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CKscViewerDoc)
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KSCVIEWERDOC_H__F42EC8EB_E49B_4638_B2B2_F25E9C226D55__INCLUDED_)

// ===== END KscViewer/KscViewerDoc.h =====

// ===== BEGIN KscViewer/KscViewerView.cpp =====
#line 1 "KscViewer/KscViewerView.cpp"
﻿// KscViewerView.cpp : implementation of the CKscViewerView class
//

#include "stdafx.h"
#include "KscViewer.h"

#include "KscViewerDoc.h"
#include "KscViewerView.h"
#include <JpegFile/JpegFile.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKscViewerView

IMPLEMENT_DYNCREATE(CKscViewerView, CView)

BEGIN_MESSAGE_MAP(CKscViewerView, CView)
	//{{AFX_MSG_MAP(CKscViewerView)
	ON_WM_CREATE()
	ON_WM_DROPFILES()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKscViewerView construction/destruction

CKscViewerView::CKscViewerView()
{
	// TODO: add construction code here

}

CKscViewerView::~CKscViewerView()
{
}

BOOL CKscViewerView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CKscViewerView drawing

void CKscViewerView::OnDraw(CDC* pDC)
{
	CKscViewerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	DrawImage();
}

/////////////////////////////////////////////////////////////////////////////
// CKscViewerView diagnostics

#ifdef _DEBUG
void CKscViewerView::AssertValid() const
{
	CView::AssertValid();
}

void CKscViewerView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CKscViewerDoc* CKscViewerView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CKscViewerDoc)));
	return (CKscViewerDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CKscViewerView message handlers

int CKscViewerView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	DragAcceptFiles();
	return 0;
}

void CKscViewerView::OnDropFiles(HDROP hDropInfo) 
{
	CKscViewerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	char szFile[MAX_PATH];
	char* szExt = nullptr;
	UINT uiFiles;

	uiFiles = DragQueryFile(hDropInfo,0xFFFF,nullptr,0);

	::DragQueryFile(hDropInfo, 0, szFile, MAX_PATH - 1);
	::DragFinish(hDropInfo);

	size_t nLen = strlen(szFile);

	szExt = szFile + nLen - 3;

	if(pDoc) pDoc->OnOpenDocument(szFile);
	
	CView::OnDropFiles(hDropInfo);
}

BOOL CKscViewerView::DrawImage()
{
	CKscViewerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	if(pDoc == nullptr) return FALSE;
	CN3JpegFile* pFile = pDoc->GetJpegFile();

	if(pFile == nullptr) return FALSE;


	CDC *theDC = GetDC();
	pFile->DrawImage(theDC->m_hDC);

	ReleaseDC(theDC);
	return TRUE;
}

// ===== END KscViewer/KscViewerView.cpp =====

// ===== BEGIN KscViewer/KscViewerView.h =====
#line 1 "KscViewer/KscViewerView.h"
// KscViewerView.h : interface of the CKscViewerView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_KSCVIEWERVIEW_H__AC830AF2_D01D_48DD_A29E_036847EB5E61__INCLUDED_)
#define AFX_KSCVIEWERVIEW_H__AC830AF2_D01D_48DD_A29E_036847EB5E61__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CKscViewerView : public CView
{
protected: // create from serialization only
	CKscViewerView();
	DECLARE_DYNCREATE(CKscViewerView)

// Attributes
public:
	CKscViewerDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKscViewerView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL DrawImage();
	virtual ~CKscViewerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CKscViewerView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in KscViewerView.cpp
inline CKscViewerDoc* CKscViewerView::GetDocument()
   { return (CKscViewerDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KSCVIEWERVIEW_H__AC830AF2_D01D_48DD_A29E_036847EB5E61__INCLUDED_)

// ===== END KscViewer/KscViewerView.h =====

// ===== BEGIN KscViewer/MainFrm.cpp =====
#line 1 "KscViewer/MainFrm.cpp"
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "KscViewer.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;

	CRect rc;
	rc.SetRect(0,0,1024,768);
	DWORD dwStyle = GetWindowLong(m_hWnd, GWL_STYLE);
	AdjustWindowRect(&rc, dwStyle|WS_CAPTION, TRUE);
	cs.cx = rc.Width();
	cs.cy = rc.Height();
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


// ===== END KscViewer/MainFrm.cpp =====

// ===== BEGIN KscViewer/MainFrm.h =====
#line 1 "KscViewer/MainFrm.h"
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__5C3A71CC_7A05_4B75_9650_5C1396B5D48A__INCLUDED_)
#define AFX_MAINFRM_H__5C3A71CC_7A05_4B75_9650_5C1396B5D48A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__5C3A71CC_7A05_4B75_9650_5C1396B5D48A__INCLUDED_)

// ===== END KscViewer/MainFrm.h =====

// ===== BEGIN KscViewer/N3JpegFile.cpp =====
#line 1 "KscViewer/N3JpegFile.cpp"
﻿// N3JpegFile.cpp: implementation of the CN3JpegFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "KscViewer.h"
#include "N3JpegFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3JpegFile::CN3JpegFile()
{
	m_uiWidth	= 0;
	m_uiHeight	= 0;
	m_pImageBuf = nullptr;
}

CN3JpegFile::~CN3JpegFile()
{
	if(m_pImageBuf) delete m_pImageBuf; m_pImageBuf = nullptr;
}

void CN3JpegFile::Release()
{
	if(m_pImageBuf) delete m_pImageBuf; m_pImageBuf = nullptr;

	m_uiWidth	= 0;
	m_uiHeight	= 0;
}

BOOL CN3JpegFile::LoadJpegFile(std::string csJpeg)
{
	// m_buf is the global buffer
	Release();

	// read to buffer tmp
	m_pImageBuf=CJpegFile::JpegFileToRGB(csJpeg.c_str(), &m_uiWidth, &m_uiHeight);

	//////////////////////
	// set up for display

	// do this before DWORD-alignment!!!
	// this works on packed (not DWORD-aligned) buffers
	// swap red and blue for display
	CJpegFile::BGRFromRGB(m_pImageBuf, m_uiWidth, m_uiHeight);

	// vertical flip for display
	CJpegFile::VertFlipBuf(m_pImageBuf, m_uiWidth * 3, m_uiHeight);

	return TRUE;
}

void CN3JpegFile::DrawImage(HDC hDC)
{
	if(hDC == nullptr) return;
	if(m_pImageBuf == nullptr) return;
	if(m_uiWidth == 0 || m_uiHeight == 0) return;

	// Center It
//		int left = max(clientRect.left, ((clientRect.Width() - (int)m_width) / 2));
//		int top = max(clientRect.top, ((clientRect.Height() - (int)m_height) / 2));
	int left = 0;
	int top = 0;

	// a 24-bit DIB is DWORD-aligned, vertically flipped and 
	// has Red and Blue bytes swapped. we already did the 
	// RGB->BGR and the flip when we read the images, now do
	// the DWORD-align

	UINT uiOutWidthBytes = 0;
	BYTE *tmp;
	// DWORD-align for display
	tmp = CJpegFile::MakeDwordAlignedBuf(m_pImageBuf,
									 m_uiWidth,
									 m_uiHeight,
									 &uiOutWidthBytes);

	// set up a DIB 
	BITMAPINFOHEADER bmiHeader;
	bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmiHeader.biWidth = m_uiWidth;
	bmiHeader.biHeight = m_uiHeight;
	bmiHeader.biPlanes = 1;
	bmiHeader.biBitCount = 24;
	bmiHeader.biCompression = BI_RGB;
	bmiHeader.biSizeImage = 0;
	bmiHeader.biXPelsPerMeter = 0;
	bmiHeader.biYPelsPerMeter = 0;
	bmiHeader.biClrUsed = 0;
	bmiHeader.biClrImportant = 0;


	// now blast it to the CDC passed in.
	// lines returns the number of lines actually displayed
	int lines = StretchDIBits(hDC,
								left, top,
								bmiHeader.biWidth,
								bmiHeader.biHeight,
								0,0,
								bmiHeader.biWidth,
								bmiHeader.biHeight,
								tmp,
								(LPBITMAPINFO)&bmiHeader,
								DIB_RGB_COLORS,
								SRCCOPY);

	delete [] tmp;
}

// ===== END KscViewer/N3JpegFile.cpp =====

// ===== BEGIN KscViewer/N3JpegFile.h =====
#line 1 "KscViewer/N3JpegFile.h"
﻿// N3JpegFile.h: interface for the CN3JpegFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3JPEGFILE_H__680B8929_B03D_45EF_8986_51561B4BDC79__INCLUDED_)
#define AFX_N3JPEGFILE_H__680B8929_B03D_45EF_8986_51561B4BDC79__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <JpegFile/JpegFile.h>

class CN3JpegFile  : public CJpegFile
{
private:
	BYTE*		m_pImageBuf;
	UINT		m_uiWidth;
	UINT		m_uiHeight;
public:
	void		DrawImage(HDC hDC);
	BOOL		LoadJpegFile(std::string csJpeg);
	UINT		GetWidth() { return m_uiWidth; }
	UINT		GetHeight() { return m_uiHeight; }
	BYTE*		GetImageBuf() { return m_pImageBuf; }
	void		Release();

	CN3JpegFile();
	virtual ~CN3JpegFile();

};

#endif // !defined(AFX_N3JPEGFILE_H__680B8929_B03D_45EF_8986_51561B4BDC79__INCLUDED_)

// ===== END KscViewer/N3JpegFile.h =====

// ===== BEGIN KscViewer/Resource.h =====
#line 1 "KscViewer/Resource.h"
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by KSCVIEWER.RC
//
#define IDD_ABOUTBOX				100
#define IDR_MAINFRAME				128
#define IDR_KSCVIETYPE				129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif

// ===== END KscViewer/Resource.h =====

// ===== BEGIN KscViewer/StdAfx.cpp =====
#line 1 "KscViewer/StdAfx.cpp"
// stdafx.cpp : source file that includes just the standard includes
//	KscViewer.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"




// ===== END KscViewer/StdAfx.cpp =====

// ===== BEGIN KscViewer/StdAfx.h =====
#line 1 "KscViewer/StdAfx.h"
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BCC2A5C5_9F40_4DED_BE79_F5766124E283__INCLUDED_)
#define AFX_STDAFX_H__BCC2A5C5_9F40_4DED_BE79_F5766124E283__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BCC2A5C5_9F40_4DED_BE79_F5766124E283__INCLUDED_)

// ===== END KscViewer/StdAfx.h =====

// ===== BEGIN Launcher/APISocket.cpp =====
#line 1 "Launcher/APISocket.cpp"
﻿// APISocket.cpp: implementation of the CAPISocket class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "APISocket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
WSAData		CAPISocket::s_WSData;
int			CAPISocket::s_nInstanceCount = 0;


//#define STX 1007
//#define ETX 1005
const WORD PACKET_HEADER = 0XAA55;
const WORD PACKET_TAIL = 0X55AA;

CAPISocket::CAPISocket()
{
	m_hSocket = INVALID_SOCKET;
	if (s_nInstanceCount == 0)
	{
		WSAStartup(0x0101, &s_WSData);
	}
	s_nInstanceCount++;

	m_iSendByteCount = 0;
}

CAPISocket::~CAPISocket()
{
	Release();

	s_nInstanceCount--;
	if (s_nInstanceCount==0)
	{
		WSACleanup();
	}
}

void CAPISocket::Release()
{
	this->Disconnect();

	DataPack* pBuf;
	while ( m_qRecvPkt.size() > 0 )
	{
		pBuf = m_qRecvPkt.front();
		delete pBuf;
		m_qRecvPkt.pop();
	}

	m_iSendByteCount = 0;
}

BOOL CAPISocket::Disconnect()
{
	if (m_hSocket != INVALID_SOCKET)
		closesocket(m_hSocket);
	m_hSocket = INVALID_SOCKET;

	return TRUE;
}

BOOL CAPISocket::Connect(HWND hWnd, const char* pszIP, DWORD port)
{	
	if (!pszIP || !port) return FALSE;

	//
	if (m_hSocket != INVALID_SOCKET)
	{	
		this->Disconnect();
	}

	//
	int i=0;
	struct sockaddr_in far server;
	struct hostent far *hp;
  
	if( (pszIP[0] >= '0') && (pszIP[0] <= '9') ) 
	{
	   memset((char *) &server,0,sizeof(server));
	   server.sin_family      = AF_INET;
	   server.sin_addr.s_addr = inet_addr(pszIP);
	   server.sin_port        = htons((u_short)port);
	}
	else
	{ 
		if ( (hp = (hostent far *)gethostbyname(pszIP)) == nullptr)
		{
#ifdef _DEBUG
			TCHAR msg[256] = {};
			_stprintf(msg, _T("Error: Connecting to %hs."), pszIP);
			MessageBox(hWnd, msg, _T("socket error"), MB_OK | MB_ICONSTOP );
#endif
			return FALSE;
		}
		memset((char *) &server,0,sizeof(server));
		memcpy((char *) &server.sin_addr,hp->h_addr,hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((u_short)port);  
	}// else 

	// create socket 
	if( (m_hSocket = socket(AF_INET, SOCK_STREAM, 0)) < 1) 
	{
#ifdef _DEBUG
		TCHAR msg[256] = {};
		_tcscpy(msg, _T("Error opening stream socket"));
		MessageBox(hWnd, msg, _T("socket error"), MB_OK | MB_ICONSTOP);
#endif
		return FALSE;
	}
  
	if (connect(m_hSocket, (struct sockaddr far *)&server, sizeof(server)) != 0) 
	{
		int iErrCode = ::WSAGetLastError();

		closesocket(m_hSocket);
		m_hSocket = INVALID_SOCKET;

#ifdef _DEBUG
		TCHAR msg[256] = {};
		_stprintf(msg, _T("Cannot connect to %hs on port %u : ErrorCode : %d"), pszIP, port, iErrCode);
		MessageBox(hWnd, msg, _T("socket error"), MB_OK | MB_ICONSTOP);
#endif
		return FALSE;
	}

//	WSAAsyncSelect(m_hSocket, hWnd, WM_SOCKETMSG, FD_CONNECT | FD_ACCEPT | FD_READ | FD_CLOSE);
	WSAAsyncSelect(m_hSocket, hWnd, WM_SOCKETMSG, FD_CONNECT | FD_READ | FD_CLOSE);

	m_hWndTarget = hWnd;
	
	return TRUE;
}

void CAPISocket::Receive()
{
	if (m_hSocket == INVALID_SOCKET)	return;

	DWORD	dwPktSize;
	DWORD	dwRead = 0;
	int		count = 0;

	ioctlsocket(m_hSocket, FIONREAD, &dwPktSize);
	while(dwRead < dwPktSize)
	{
		count = recv(m_hSocket, (char*)m_RecvBuf, RECEIVE_BUF_SIZE, 0);
		if (count == SOCKET_ERROR)
		{
			ASSERT(0);
			break;
		}
		if (count)
		{
			dwRead += count;
			m_CB.PutData(m_RecvBuf, count);
		}
	}

	// packet analysis.
	while(ReceiveProcess());
}

BOOL CAPISocket::ReceiveProcess()
{
	int iCount = m_CB.GetValidCount();
	BOOL bFoundTail = FALSE;
	if (iCount >=7 )
	{
		BYTE *pData = new BYTE[iCount];
		m_CB.GetData(pData, iCount);
		int head_inc_size = 0;

		if ( PACKET_HEADER == ntohs(*((WORD*)pData)) )
		{
			short siCore = *((short*)(pData+2));
			if ( siCore <= iCount )
			{
				if ( PACKET_TAIL == ntohs(*((WORD*)(pData+iCount-2))) ) // 패킷 꼬리 부분 검사..
				{
					DataPack *pDP = new DataPack(siCore, pData+4);
					m_qRecvPkt.push(pDP);
					m_CB.HeadIncrease(siCore + 6); // 환형 버퍼 인덱스 증가 시키기..

					bFoundTail = TRUE;
				}
			}
		}

		delete[] pData, pData = nullptr;
	}

	return bFoundTail;
}

void CAPISocket::Send(BYTE* pData, int nSize)
{
	if (m_hSocket == INVALID_SOCKET)	return;

	// UZDream 패킷 형식에 맞춰주는 부분. STX, ETX, size만 붙여준다. 따라서 나머지 부분은 패킷만들때 붙여서 넣어줘야 함. 
	// 불합리하지만 이전의 패킷 형식에 맞추기 위해선... 
//	int nTotalSize = nSize+10;
//	BYTE *pSndData = m_RecvBuf;
//	*((WORD*)pSndData) = STX;			pSndData+=2;
//	*((WORD*)pSndData) = nTotalSize;	pSndData+=2;
//	*((WORD*)pSndData) = 0x0000;		pSndData+=2;
//	*((WORD*)pSndData) = 0x0000;		pSndData+=2;
//	memcpy(pSndData, pData, nSize);		pSndData += nSize;
//	*((WORD*)pSndData) = ETX;			pSndData+=2;	
	
	int nTotalSize = nSize+6;
	BYTE *pSendData = m_RecvBuf;
	*((WORD*)pSendData) = htons(PACKET_HEADER);	pSendData+=2;
	*((WORD*)pSendData) = nSize;			pSendData+=2;
	memcpy(pSendData, pData, nSize);		pSendData += nSize;
	*((WORD*)pSendData) = htons(PACKET_TAIL);		pSendData+=2;

	int nSent = 0;
	int count = 0;
	while(nSent < nTotalSize)
	{
		count = send(m_hSocket, (char*)m_RecvBuf, nTotalSize, 0);
		if (count == SOCKET_ERROR)
		{
//			__ASSERT(0,"socket send error!");
//			DWORD dwErr = GetLastError();
//			TRACE("%d\n", dwErr);
			break;
		}
		if (count)
		{
			nSent += count;
		}
	}

	m_iSendByteCount += nTotalSize;
}

// ===== END Launcher/APISocket.cpp =====

// ===== BEGIN Launcher/APISocket.h =====
#line 1 "Launcher/APISocket.h"
﻿// APISocket.h: interface for the CAPISocket class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_)
#define AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include <winsock.h>

#include <queue>
#include <string>

#include "BB_CircularBuffer.h"

#define WM_SOCKETMSG	(WM_USER+1)
#define RECEIVE_BUF_SIZE	4096

class DataPack
{
public:
	int		m_Size;
	BYTE*	m_pData;

public:
	DataPack()
	{
		m_Size = 0;
		m_pData = nullptr;
	}
	DataPack(int size, BYTE *pData)
	{
		ASSERT(size);
		m_Size = size;
		m_pData = new BYTE[size];
		CopyMemory(m_pData, pData, size);
	}
	virtual ~DataPack(){delete[] m_pData;}
};

class CAPISocket  
{
protected:
	SOCKET	m_hSocket;
	HWND	m_hWndTarget;
	BYTE	m_RecvBuf[RECEIVE_BUF_SIZE];

	BB_CircularBuffer	m_CB;

public:
	static int			s_nInstanceCount;
	static WSADATA		s_WSData;

	int					m_iSendByteCount;
	std::queue< DataPack* >	m_qRecvPkt;

public:
	BOOL	Connect(HWND hWnd, const char* pszIP, DWORD port);
	BOOL	Disconnect();

	void	Release();	
	void	Receive();
	BOOL	ReceiveProcess();
	void	Send(BYTE* pData, int nSize);


	//패킷 만들기 함수
	static	void	MP_AddByte(BYTE *dest, int& iOffset, BYTE byte) { CopyMemory(dest+iOffset, &byte, 1); iOffset ++; }
	static	void	MP_AddShort(BYTE *dest, int& iOffset, short value) { CopyMemory(dest+iOffset, &value, 2); iOffset += 2; }
	static	void	MP_AddWord(BYTE *dest, int& offset, WORD value) { CopyMemory(dest+offset, &value, 2); offset += 2; }
	static	void	MP_AddDword(BYTE *dest, int &iOffset, DWORD dword) { CopyMemory(dest+iOffset, &dword, 4); iOffset += 4; }
	static	void	MP_AddFloat(BYTE *dest, int &iOffset, float value) { CopyMemory(dest+iOffset, &value, 4);	iOffset += 4; }
//	static	void	MP_AddString(BYTE *dest, int &iOffset, BYTE *sor, int len) { CopyMemory(dest+iOffset, sor, len); iOffset += len; }
	static	void	MP_AddString(BYTE *dest, int &iOffset, const std::string& szString)
	{
		if (!szString.empty())
		{
			CopyMemory(dest + iOffset, &szString[0], szString.size());
			iOffset += static_cast<int>(szString.size());
		}
	}

	//패킷 Parsing 함수
	static	BYTE&	Parse_GetByte(const BYTE* buf, int &iOffset) { iOffset ++; return *(BYTE*)(buf+iOffset-1); }
	static	short&	Parse_GetShort(const BYTE* buf, int& iOffset) { iOffset += 2; return *(short*)(buf+iOffset-2); }
	static  WORD&	Parse_GetWord(const BYTE* buf, int &iOffset) { iOffset += 2; return *(PWORD)(buf+iOffset-2); }
	static	DWORD&	Parse_GetDword(const BYTE* buf, int &iOffset) { iOffset += 4; return *(DWORD*)(buf+iOffset-4); }
	static	float&	Parse_GetFloat(const BYTE* buf, int& iOffset) { iOffset += 4; return *(float*)(buf+iOffset-4); }
//	static	void	Parse_GetString(const BYTE* buf, int &iOffset, char *dest, int len) { if (len) { CopyMemory(dest, buf+iOffset, len); iOffset += len; } dest[len] = 0; }
	static	void	Parse_GetString(const BYTE* buf, int &iOffset, std::string& szString, int len)
	{
		if (len > 0) { szString.assign(len, ' '); memcpy(&(szString[0]), buf + iOffset, len); iOffset += len; }
		else { szString = ""; }
	}
	//static	DWORD&	Parse_GetDword(char *buf, int &iOffset);

	CAPISocket();
	virtual ~CAPISocket();
};

#endif // !defined(AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_)

// ===== END Launcher/APISocket.h =====

// ===== BEGIN Launcher/BB_CircularBuffer.cpp =====
#line 1 "Launcher/BB_CircularBuffer.cpp"
﻿// BB_CircularBuffer.cpp: implementation of the BB_CircularBuffer class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BB_CircularBuffer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

BB_CircularBuffer::BB_CircularBuffer(int size)
{
	ASSERT(size>0);
	m_iBufSize = size;
	m_pBuffer = new BYTE[m_iBufSize];

	m_iHeadPos = 0;
	m_iTailPos = 0;
}

BB_CircularBuffer::~BB_CircularBuffer()
{
	ASSERT(m_pBuffer);
	if (m_pBuffer)
		delete[] m_pBuffer, m_pBuffer = nullptr;
}

// ===== END Launcher/BB_CircularBuffer.cpp =====

// ===== BEGIN Launcher/BB_CircularBuffer.h =====
#line 1 "Launcher/BB_CircularBuffer.h"
﻿// BB_CircularBuffer.h: interface for the BB_CircularBuffer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BB_CIRCULARBUFFER_H__F4D345A4_CE05_11D1_8BEE_0060979C5900__INCLUDED_)
#define AFX_BB_CIRCULARBUFFER_H__F4D345A4_CE05_11D1_8BEE_0060979C5900__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class BB_CircularBuffer  
{
public:
	BB_CircularBuffer(int size=32768);
	virtual ~BB_CircularBuffer();

	void	PutData(BYTE *pData, int len);
	void	GetData(BYTE *pData, int len);
	int		GetOutData(BYTE *pData); //HeadPos, 변화
	void	PutData(BYTE& data);
	BYTE&	GetHeadData(){return m_pBuffer[m_iHeadPos];}
	//1 Byte Operation;
	//false : 모든데이터 다빠짐, TRUE: 정상적으로 진행중
	BOOL	HeadIncrease(int increasement=1);
	void	SetEmpty() {m_iHeadPos=0; m_iTailPos=0;}

	int&	GetBufferSize() {return m_iBufSize;}
	int&	GetHeadPos() {return m_iHeadPos;}
	int&	GetTailPos() {return m_iTailPos;}
	int		GetValidCount();
protected:
	//over flow 먼저 점검한 후 IndexOverFlow 점검
	BOOL	IsOverFlowCondition(int &len) {return (len >= m_iBufSize-GetValidCount()) ? TRUE: FALSE;}
	BOOL	IsIndexOverFlow(int &len) {return (len+m_iTailPos>=m_iBufSize) ? TRUE:FALSE;}
	void	BufferResize(); //overflow condition 일때 size를 현재의 두배로 늘림
protected:
	int		m_iBufSize;
	BYTE	*m_pBuffer;

	int		m_iHeadPos;
	int		m_iTailPos;
};

inline int BB_CircularBuffer::GetValidCount()
{
	int count = m_iTailPos-m_iHeadPos;
	if (count<0) count = m_iBufSize+count;
	return count;
}

inline void BB_CircularBuffer::BufferResize()
{
	int prevBufSize = m_iBufSize;
	m_iBufSize <<= 1;
	BYTE *pNewData = new BYTE[m_iBufSize];
	CopyMemory(pNewData, m_pBuffer, prevBufSize);
	if (m_iTailPos<m_iHeadPos) 
	{
		CopyMemory(pNewData+prevBufSize, m_pBuffer, m_iTailPos);
		m_iTailPos += prevBufSize;
	}
	delete [] m_pBuffer;
	m_pBuffer = pNewData;
}

inline void BB_CircularBuffer::PutData(BYTE &data)
{
	int len = 1;
	while (IsOverFlowCondition(len)) BufferResize();
	m_pBuffer[m_iTailPos++] = data;
	if (m_iTailPos==m_iBufSize) m_iTailPos = 0;
}

inline void BB_CircularBuffer::PutData(BYTE *pData, int len)
{
	if (len<=0)
	{
		TRACE("BB_CircularBuffer::PutData len is <= 0\n");
		return;
	}
	while (IsOverFlowCondition(len)) BufferResize();
	if (IsIndexOverFlow(len))
	{
		int FirstCopyLen = m_iBufSize-m_iTailPos;
		int SecondCopyLen = len - FirstCopyLen;
		ASSERT(FirstCopyLen);
		CopyMemory(m_pBuffer+m_iTailPos, pData, FirstCopyLen);
		if (SecondCopyLen)
		{
			CopyMemory(m_pBuffer, pData+FirstCopyLen, SecondCopyLen);
			m_iTailPos = SecondCopyLen;
		}
		else m_iTailPos = 0;
	}
	else
	{
		CopyMemory(m_pBuffer+m_iTailPos, pData, len);
		m_iTailPos += len;
	}
}

inline int BB_CircularBuffer::GetOutData(BYTE *pData)
{
	int len = GetValidCount();
	int fc, sc;
	fc = m_iBufSize-m_iHeadPos;
	if (len>fc)
	{
		sc = len - fc;
		CopyMemory(pData, m_pBuffer+m_iHeadPos, fc);
		CopyMemory(pData+fc, m_pBuffer, sc);
		m_iHeadPos = sc;
		ASSERT(m_iHeadPos==m_iTailPos);
	}
	else
	{
		CopyMemory(pData, m_pBuffer+m_iHeadPos, len);
		m_iHeadPos += len;
		if (m_iHeadPos==m_iBufSize) m_iHeadPos = 0;
	}
	return len;
}

inline void BB_CircularBuffer::GetData(BYTE *pData, int len)
{
	ASSERT(len>0&&len<=GetValidCount());
	if (len < m_iBufSize-m_iHeadPos)
		CopyMemory(pData, m_pBuffer+m_iHeadPos, len);
	else
	{
		int fc, sc;
		fc = m_iBufSize-m_iHeadPos;
		sc = len - fc;
		CopyMemory(pData, m_pBuffer+m_iHeadPos, fc);
		if (sc) CopyMemory(pData+fc, m_pBuffer, sc);
	}
}

inline BOOL BB_CircularBuffer::HeadIncrease(int increasement)
{
	ASSERT(increasement<=GetValidCount());
	m_iHeadPos += increasement;
	m_iHeadPos %= m_iBufSize;
	return m_iHeadPos!=m_iTailPos;
}

#endif // !defined(AFX_BB_CIRCULARBUFFER_H__F4D345A4_CE05_11D1_8BEE_0060979C5900__INCLUDED_)

// ===== END Launcher/BB_CircularBuffer.h =====

// ===== BEGIN Launcher/BackgroundUtil.cpp =====
#line 1 "Launcher/BackgroundUtil.cpp"
﻿#include "stdafx.h"
#include "BackgroundUtil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBackgroundUtil::CBackgroundUtil()
{
}


CBackgroundUtil::~CBackgroundUtil()
{
	m_BmpPattern.Detach();
	m_BmpPalette.Detach();
}


BOOL CBackgroundUtil::SetBitmap(UINT uResourceID)
{
	BITMAP bm;
	BOOL bRet;

	// Detach previous resources
	m_BmpPattern.Detach();  
	m_BmpPalette.Detach();  

	// Default return value
	bRet = TRUE;

	// Load new bitmap
	if (uResourceID != 0)
	{
		bRet = GetBitmapAndPalette(uResourceID, m_BmpPattern, m_BmpPalette);

		// If all ok
		if (bRet == TRUE)
		{
			// Get dimension
			m_BmpPattern.GetBitmap(&bm);
			// Width of the bitmap
			m_nBmpWidth = bm.bmWidth;
			// Height of the bitmap
			m_nBmpHeight = bm.bmHeight;
		}
	}

	return bRet;

} // End of SetBitmap


BOOL CBackgroundUtil::GetBitmapAndPalette(UINT nIDResource, CBitmap & bitmap, CPalette & pal)
{
	LPCTSTR lpszResourceName = (LPCTSTR)(UINT_PTR) nIDResource;

	HBITMAP hBmp = (HBITMAP)::LoadImage( AfxGetInstanceHandle(), 
		lpszResourceName, IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);

	if (hBmp == nullptr) return FALSE;

	bitmap.Attach(hBmp);

	// Create a logical palette for the bitmap
	DIBSECTION ds;
	BITMAPINFOHEADER &bmInfo = ds.dsBmih;
	bitmap.GetObject(sizeof(ds), &ds);

	int nColors = bmInfo.biClrUsed ? bmInfo.biClrUsed : 1 << bmInfo.biBitCount;

	// Create a halftone palette if colors > 256. 
	CClientDC dc(nullptr); // Desktop DC

	if(nColors > 256)
		pal.CreateHalftonePalette(&dc);
	else
	{
		// Create the palette
		RGBQUAD *pRGB = new RGBQUAD[nColors];
		CDC memDC;
		memDC.CreateCompatibleDC(&dc);
		memDC.SelectObject( &bitmap );
		::GetDIBColorTable( memDC, 0, nColors, pRGB );
		UINT nSize = sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * nColors);
		LOGPALETTE *pLP = (LOGPALETTE *) new BYTE[nSize];
		pLP->palVersion = 0x300;
		pLP->palNumEntries = nColors;
		for (int i=0; i < nColors; i++)
		{
			pLP->palPalEntry[i].peRed = pRGB[i].rgbRed;
			pLP->palPalEntry[i].peGreen = pRGB[i].rgbGreen;
			pLP->palPalEntry[i].peBlue = pRGB[i].rgbBlue;
			pLP->palPalEntry[i].peFlags = 0;
		}
		pal.CreatePalette( pLP );
		delete[] pLP;
		delete[] pRGB;
	}
	return TRUE;
} // End of GetBitmapAndPalette


BOOL CBackgroundUtil::TileBitmap(CDC* pDC, CRect rc)
{
	CDC MemDC;

	int x = 0, y = 0;

	// If there is a bitmap loaded
	if (m_BmpPattern.m_hObject != nullptr)
	{
		MemDC.CreateCompatibleDC(pDC);
		CBitmap* pOldBitmap = MemDC.SelectObject(&m_BmpPattern);

		// Tile the bitmap
		while (y < rc.Height()) 
		{
			while(x < rc.Width()) 
			{
				pDC->BitBlt(x, y, m_nBmpWidth, m_nBmpHeight, &MemDC, 0, 0, SRCCOPY);
				x += m_nBmpWidth;
			}
			x = 0;
			y += m_nBmpHeight;
		}

		MemDC.SelectObject(pOldBitmap);

		return TRUE;
	}

	return FALSE; // Normal behaviour
} // End of TileBitmap

// ===== END Launcher/BackgroundUtil.cpp =====

// ===== BEGIN Launcher/BackgroundUtil.h =====
#line 1 "Launcher/BackgroundUtil.h"
﻿#ifndef _BACKGROUNDUTIL_H_
#define _BACKGROUNDUTIL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CBackgroundUtil  
{
public:
	BOOL SetBitmap(UINT uResourceID = 0);
	CBackgroundUtil();
	virtual ~CBackgroundUtil();

	int BMPWidth() { return m_nBmpWidth; }
	int BMPHeight() { return m_nBmpHeight; }

protected:
	BOOL TileBitmap(CDC* pDC, CRect rc);
	BOOL GetBitmapAndPalette(UINT nIDResource, CBitmap& bitmap, CPalette& pal);
	// For background bitmap
	CBitmap m_BmpPattern;
	CPalette m_BmpPalette;
	int m_nBmpWidth;
	int m_nBmpHeight;
};

#endif

// ===== END Launcher/BackgroundUtil.h =====

// ===== BEGIN Launcher/BkDialog.cpp =====
#line 1 "Launcher/BkDialog.cpp"
﻿// BkDialog.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "BkDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CBkDialog::CBkDialog(CWnd* pParent /*=NULL*/)
{
	//{{AFX_DATA_INIT(CBkDialog)
		// NOTE: the ClassWizard will add member initialization here

	//}}AFX_DATA_INIT
}


CBkDialog::CBkDialog(UINT uResourceID, CWnd* pParent)
	: CDialog(uResourceID, pParent)
{

}


CBkDialog::CBkDialog(LPCTSTR pszResourceID, CWnd* pParent)
	: CDialog(pszResourceID, pParent)
{

}


CBkDialog::~CBkDialog()
{

}


void CBkDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBkDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}




BEGIN_MESSAGE_MAP(CBkDialog, CDialog)
	//{{AFX_MSG_MAP(CBkDialog)
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()




BOOL CBkDialog::OnEraseBkgnd(CDC* pDC) 
{
	CRect rc;

	GetClientRect(rc);

	m_pDC = pDC;

	if (TileBitmap(pDC, rc) == TRUE)
		return TRUE;
	else
		return CDialog::OnEraseBkgnd(pDC);

} // End of OnEraseBkgnd

// ===== END Launcher/BkDialog.cpp =====

// ===== BEGIN Launcher/BkDialog.h =====
#line 1 "Launcher/BkDialog.h"
﻿#ifndef _BKDIALOG_H_
#define _BKDIALOG_H_

#include "BackgroundUtil.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBkDialog dialog

class CBkDialog : public CDialog, public CBackgroundUtil
{
// Construction
public:
	CDC* m_pDC;
	~CBkDialog();
	CBkDialog(LPCTSTR pszResourceID, CWnd* pParent = NULL);
	CBkDialog(UINT uResourceID, CWnd* pParent = NULL);
	CBkDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CBkDialog)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBkDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBkDialog)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif

// ===== END Launcher/BkDialog.h =====

// ===== BEGIN Launcher/BtnST.cpp =====
#line 1 "Launcher/BtnST.cpp"
﻿#include "stdafx.h"
#include "BtnST.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CButtonST

CButtonST::CButtonST()
{
	m_bIsPressed		= FALSE;
	m_bIsFocused		= FALSE;
	m_bIsDisabled		= FALSE;
	m_bMouseOnButton	= FALSE;

	FreeResources(FALSE);

	// Default type is "flat" button
	m_bIsFlat = TRUE; 
  
	// By default draw border in "flat" button 
	m_bDrawBorder = TRUE; 
  
	// By default icon is aligned horizontally
	m_nAlign = ST_ALIGN_HORIZ; 
  
	// By default, for "flat" button, don't draw the focus rect
	m_bDrawFlatFocus = FALSE;

	// By default the button is not the default button
	m_bIsDefault = FALSE;

	// By default the button is not a checkbox
	m_bIsCheckBox = FALSE;
	m_nCheck = 0;

	// Set default colors
	SetDefaultColors(FALSE);

	// No tooltip created
	m_ToolTip.m_hWnd = NULL;

	// Do not draw as a transparent button
	m_bDrawTransparent = FALSE;
	m_pbmpOldBk = NULL;

	// No URL defined
	::ZeroMemory(&m_szURL, sizeof(m_szURL));

	// No cursor defined
	m_hCursor = NULL;	// Fix by kawasaki@us.dnttm.ro

	// No autorepeat
	m_bAutoRepeat = FALSE;
	m_hWndAutoRepeat = NULL;
	m_nMsgAutoRepeat = WM_APP;
	m_dwPeriodAutoRepeat = 100;
} // End of CButtonST


CButtonST::~CButtonST()
{
	// Restore old bitmap (if any)
	if (m_dcBk.m_hDC != NULL && m_pbmpOldBk != NULL)
	{
		m_dcBk.SelectObject(m_pbmpOldBk);
	}

	FreeResources();

	// Destroy the cursor (if any)
	if (m_hCursor != NULL) ::DestroyCursor(m_hCursor);
} // End of ~CButtonST


BEGIN_MESSAGE_MAP(CButtonST, CButton)
    //{{AFX_MSG_MAP(CButtonST)
	ON_WM_CAPTURECHANGED()
	ON_WM_SETCURSOR()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEMOVE()
	ON_WM_SYSCOLORCHANGE()
	ON_CONTROL_REFLECT_EX(BN_CLICKED, OnClicked)
	ON_WM_ACTIVATE()
	ON_WM_ENABLE()
	ON_WM_CANCELMODE()
	ON_WM_CTLCOLOR_REFLECT()
	ON_WM_LBUTTONDOWN()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD CButtonST::SetIcon(int nIconInId, int nIconOutId)
{
	HICON		hIconIn;
	HICON		hIconOut;
	HINSTANCE	hInstResource;

	// Find correct resource handle
	hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nIconInId), RT_GROUP_ICON);

	// Set icon when the mouse is IN the button
	hIconIn = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconInId), IMAGE_ICON, 0, 0, 0);
  	// Set icon when the mouse is OUT the button
	hIconOut = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconOutId), IMAGE_ICON, 0, 0, 0);

	return SetIcon(hIconIn, hIconOut);
} // End of SetIcon

DWORD CButtonST::SetIcon(HICON hIconIn, HICON hIconOut)
{
	BOOL		bRetValue;
	ICONINFO	ii;

	// Free any loaded resource
	FreeResources();

	if (hIconIn != NULL)
	{
		m_csIcons[0].hIcon = hIconIn;

		// Get icon dimension
		ZeroMemory(&ii, sizeof(ICONINFO));
		bRetValue = ::GetIconInfo(hIconIn, &ii);
		if (bRetValue == FALSE)
		{
			FreeResources();
			return BTNST_INVALIDRESOURCE;
		} // if

		m_csIcons[0].dwWidth	= (DWORD)(ii.xHotspot * 2);
		m_csIcons[0].dwHeight	= (DWORD)(ii.yHotspot * 2);
		::DeleteObject(ii.hbmMask);
		::DeleteObject(ii.hbmColor);

		if (hIconOut != NULL)
		{
			m_csIcons[1].hIcon = hIconOut;

			// Get icon dimension
			ZeroMemory(&ii, sizeof(ICONINFO));
			bRetValue = ::GetIconInfo(hIconOut, &ii);
			if (bRetValue == FALSE)
			{
				FreeResources();
				return BTNST_INVALIDRESOURCE;
			} // if

			m_csIcons[1].dwWidth	= (DWORD)(ii.xHotspot * 2);
			m_csIcons[1].dwHeight	= (DWORD)(ii.yHotspot * 2);
			::DeleteObject(ii.hbmMask);
			::DeleteObject(ii.hbmColor);
		} // if
	} // if

	RedrawWindow();

	return BTNST_OK;
} // End of SetIcon

BOOL CButtonST::SetBtnCursor(int nCursorId)
{
	HINSTANCE hInstResource;
	// Destroy any previous cursor
	if (m_hCursor != NULL) ::DestroyCursor(m_hCursor);
	m_hCursor = NULL;

	// If we want a cursor
	if (nCursorId != NULL)
	{
		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nCursorId),
											RT_GROUP_CURSOR);
		// Load icon resource
		m_hCursor = (HCURSOR)::LoadImage(hInstResource/*AfxGetApp()->m_hInstance*/, MAKEINTRESOURCE(nCursorId), IMAGE_CURSOR, 0, 0, 0);
		// If something wrong then return FALSE
		if (m_hCursor == NULL) return FALSE;
	}

	return TRUE;
} // End of SetBtnCursor


void CButtonST::SetFlat(BOOL bState)
{
	m_bIsFlat = bState;
	Invalidate();
} // End of SetFlat


BOOL CButtonST::GetFlat()
{
	return m_bIsFlat;
} // End of GetFlat


void CButtonST::SetAlign(int nAlign)
{
	switch (nAlign)
	{    
		case ST_ALIGN_HORIZ:
		case ST_ALIGN_HORIZ_RIGHT:
		case ST_ALIGN_VERT:
			m_nAlign = nAlign;
			break;
	}
	Invalidate();
} // End of SetAlign


int CButtonST::GetAlign()
{
	return m_nAlign;
} // End of GetAlign


void CButtonST::DrawBorder(BOOL bEnable)
{
	m_bDrawBorder = bEnable;
} // End of DrawBorder

void CButtonST::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd*	pWnd;		// Active window
	CWnd*	pParent;	// Window that owns the button

	CButton::OnMouseMove(nFlags, point);

	// If the mouse enter the button with the left button pressed then do nothing
	if (nFlags & MK_LBUTTON && m_bMouseOnButton == FALSE) return;

	// If our button is not flat then do nothing
	if (m_bIsFlat == FALSE) return;

	pWnd = GetActiveWindow();
	pParent = GetOwner();

	if ((GetCapture() != this) && 
		(
#ifndef ST_LIKEIE
		pWnd != NULL && 
#endif
		pParent != NULL)) 
	{
		m_bMouseOnButton = TRUE;
		//SetFocus();	// Thanks Ralph!
		SetCapture();
		Invalidate();
	} // if
	else
	{
		/*
		CRect rc;
		GetClientRect(&rc);
		if (!rc.PtInRect(point))
		{
		*/

		POINT p2 = point;
		ClientToScreen(&p2);
		CWnd* wndUnderMouse = WindowFromPoint(p2);
//		if (wndUnderMouse != this)
		if (wndUnderMouse && wndUnderMouse->m_hWnd != this->m_hWnd)
		{
			// Redraw only if mouse goes out
			if (m_bMouseOnButton == TRUE)
			{
				m_bMouseOnButton = FALSE;
				Invalidate();
			} // if
			// If user is NOT pressing left button then release capture!
			if (!(nFlags & MK_LBUTTON)) ReleaseCapture();
		} // if
	} // else
} // End of OnMouseMove

void CButtonST::OnKillFocus(CWnd * pNewWnd)
{
	CButton::OnKillFocus(pNewWnd);

	CancelHover();
} // End of OnKillFocus

void CButtonST::OnLButtonDown(UINT nFlags, CPoint point) 
{
	CButton::OnLButtonDown(nFlags, point);

	if (m_bAutoRepeat == TRUE)
	{
		MSG		csMsg;
		int		nButtonID;
		HWND	hWndParent;
		BOOL	bInitialState = TRUE;

		nButtonID = GetDlgCtrlID();
		hWndParent = GetParent()->GetSafeHwnd();
		SetCapture();
		while (PeekMessage(&csMsg, m_hWnd, WM_LBUTTONUP, WM_LBUTTONUP, PM_REMOVE) == FALSE)
		{
			::SendMessage(hWndParent, WM_COMMAND, MAKEWPARAM((WORD)nButtonID, BN_CLICKED), (LPARAM)m_hWnd);
			::Sleep(m_dwPeriodAutoRepeat);
			bInitialState = !bInitialState;
		} // while

		if (!bInitialState)
		{
			::SendMessage(hWndParent, WM_COMMAND, MAKEWPARAM((WORD)nButtonID, BN_CLICKED), (LPARAM)m_hWnd);
		} // if
		ReleaseCapture();
		SendMessage(WM_LBUTTONUP);
		CPoint	ptCursor;
		GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);
		SendMessage(WM_MOUSEMOVE, 0, MAKELPARAM(ptCursor.x, ptCursor.y));
	} // if
} // End of OnLButtonDown

void CButtonST::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	CButton::OnActivate(nState, pWndOther, bMinimized);
	
	if (nState == WA_INACTIVE)	CancelHover();
} // End of OnActivate

void CButtonST::OnEnable(BOOL bEnable) 
{
	CButton::OnEnable(bEnable);
	
	if (bEnable == FALSE)	CancelHover();
} // End of OnEnable

void CButtonST::OnCancelMode() 
{
	CButton::OnCancelMode();
		
	CancelHover();
} // End of OnCancelMode

void CButtonST::OnCaptureChanged(CWnd *pWnd) 
{
	if (m_bMouseOnButton == TRUE)
	{
		ReleaseCapture();
		Invalidate();
	} // if

	CButton::OnCaptureChanged(pWnd);
} // End of OnCaptureChanged

void CButtonST::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC*	pDC = CDC::FromHandle(lpDIS->hDC);

	CPen	*pOldPen;

	// Checkbox or Radiobutton style ?
	if (m_bIsCheckBox == TRUE)
	{
		m_bIsPressed  =  (lpDIS->itemState & ODS_SELECTED)
						|| (m_nCheck != 0);
		//m_bIsPressed = TRUE;
	}
	// Normal button OR other button style ...
	else
	{
		m_bIsPressed = (lpDIS->itemState & ODS_SELECTED);
	}

	m_bIsFocused  = (lpDIS->itemState & ODS_FOCUS);
	m_bIsDisabled = (lpDIS->itemState & ODS_DISABLED);

	CRect itemRect = lpDIS->rcItem;

	pDC->SetBkMode(TRANSPARENT);

	if (m_bIsFlat == FALSE)
	{
		if (m_bIsFocused || (GetDefault() == TRUE))
		{
			CBrush br(RGB(0,0,0));  
			pDC->FrameRect(&itemRect, &br);
			itemRect.DeflateRect(1, 1);
		} // if
	} // if

	// Prepare draw... paint button background

	// Draw transparent?
	if (m_bDrawTransparent == TRUE)
		PaintBk(pDC);
	else
		OnDrawBackground(pDC, &itemRect);

	// Draw pressed button
	if (m_bIsPressed)
	{
		if (m_bIsFlat == TRUE)
		{
			if (m_bDrawBorder)
				OnDrawBorder(pDC, &itemRect);
		}
		else    
		{
			CBrush brBtnShadow(GetSysColor(COLOR_BTNSHADOW));
			pDC->FrameRect(&itemRect, &brBtnShadow);
		}
	}
	else // ...else draw non pressed button
	{
		CPen penBtnHiLight(PS_SOLID, 0, GetSysColor(COLOR_BTNHILIGHT)); // White
		CPen pen3DLight(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));       // Light gray
		CPen penBtnShadow(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));   // Dark gray
		CPen pen3DDKShadow(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW)); // Black

		if (m_bIsFlat == TRUE)
		{
			if (m_bMouseOnButton && m_bDrawBorder)
				OnDrawBorder(pDC, &itemRect);
		}
		else
		{
			// Draw top-left borders
			// White line
			pOldPen = pDC->SelectObject(&penBtnHiLight);
			pDC->MoveTo(itemRect.left, itemRect.bottom-1);
			pDC->LineTo(itemRect.left, itemRect.top);
			pDC->LineTo(itemRect.right, itemRect.top);
			// Light gray line
			pDC->SelectObject(pen3DLight);
			pDC->MoveTo(itemRect.left+1, itemRect.bottom-1);
			pDC->LineTo(itemRect.left+1, itemRect.top+1);
			pDC->LineTo(itemRect.right, itemRect.top+1);
			// Draw bottom-right borders
			// Black line
			pDC->SelectObject(pen3DDKShadow);
			pDC->MoveTo(itemRect.left, itemRect.bottom-1);
			pDC->LineTo(itemRect.right-1, itemRect.bottom-1);
			pDC->LineTo(itemRect.right-1, itemRect.top-1);
			// Dark gray line
			pDC->SelectObject(penBtnShadow);
			pDC->MoveTo(itemRect.left+1, itemRect.bottom-2);
			pDC->LineTo(itemRect.right-2, itemRect.bottom-2);
			pDC->LineTo(itemRect.right-2, itemRect.top);
			//
			pDC->SelectObject(pOldPen);
		}
	}

	// Read the button's title
	CString sTitle;
	GetWindowText(sTitle);

	CRect captionRect = lpDIS->rcItem;

	// Draw the icon
	if (m_csIcons[0].hIcon != NULL)
	{
		DrawTheIcon(pDC, !sTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
	}

	if (m_csBitmaps[0].hBitmap != NULL)
	{
		pDC->SetBkColor(RGB(255,255,255));
		DrawTheBitmap(pDC, !sTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
	} // if

	// Write the button title (if any)
	if (sTitle.IsEmpty() == FALSE)
	{
		// Draw the button's title
		// If button is pressed then "press" title also
		if (m_bIsPressed && m_bIsCheckBox == FALSE)
			captionRect.OffsetRect(1, 1);
    
		// ONLY FOR DEBUG 
		//CBrush brBtnShadow(RGB(255, 0, 0));
		//pDC->FrameRect(&captionRect, &brBtnShadow);

		/*
		if ((m_bMouseOnButton == TRUE) || (bIsPressed)) 
		{
			pDC->SetTextColor(GetActiveFgColor());
			pDC->SetBkColor(GetActiveBgColor());
		} 
		else 
		{
			pDC->SetTextColor(GetInactiveFgColor());
			pDC->SetBkColor(GetInactiveBgColor());
		}
		*/
		// Center text
		CRect centerRect = captionRect;
		pDC->DrawText(sTitle, -1, captionRect, DT_WORDBREAK | DT_CENTER | DT_CALCRECT);
		captionRect.OffsetRect((centerRect.Width() - captionRect.Width())/2, (centerRect.Height() - captionRect.Height())/2);
		/* RFU
		captionRect.OffsetRect(0, (centerRect.Height() - captionRect.Height())/2);
		captionRect.OffsetRect((centerRect.Width() - captionRect.Width())-4, (centerRect.Height() - captionRect.Height())/2);
		*/

		pDC->SetBkMode(TRANSPARENT);
		/*
		pDC->DrawState(captionRect.TopLeft(), captionRect.Size(), (LPCTSTR)sTitle, (bIsDisabled ? DSS_DISABLED : DSS_NORMAL), 
						TRUE, 0, (CBrush*)NULL);
		*/
		if (m_bIsDisabled)
		{
			captionRect.OffsetRect(1, 1);
			pDC->SetTextColor(::GetSysColor(COLOR_3DHILIGHT));
			pDC->DrawText(sTitle, -1, captionRect, DT_WORDBREAK | DT_CENTER);
			captionRect.OffsetRect(-1, -1);
			pDC->SetTextColor(::GetSysColor(COLOR_3DSHADOW));
			pDC->DrawText(sTitle, -1, captionRect, DT_WORDBREAK | DT_CENTER);
		} // if
		else
		{
			if (m_bMouseOnButton || m_bIsPressed) 
			{
				pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_IN]);
				pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_IN]);
			} // if
			else 
			{
				pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_OUT]);
				pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_OUT]);
			} // else
			pDC->DrawText(sTitle, -1, captionRect, DT_WORDBREAK | DT_CENTER);
		} // if
	} // if

	if (m_bIsFlat == FALSE || (m_bIsFlat == TRUE && m_bDrawFlatFocus == TRUE))
	{
		// Draw the focus rect
		if (m_bIsFocused)
		{
			CRect focusRect = itemRect;
			focusRect.DeflateRect(3, 3);
			pDC->DrawFocusRect(&focusRect);
		} // if
	} // if
} // End of DrawItem

void CButtonST::DrawTheIcon(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, BOOL bIsDisabled)
{
	BYTE		byIndex		= 0;

	// Select the icon to use
	if (m_bIsCheckBox == TRUE)
	{
		if (bIsPressed == TRUE)
			byIndex = 0;
		else
			byIndex = (m_csIcons[1].hIcon == NULL ? 0 : 1);
	} // if
	else
	{
		if (m_bMouseOnButton == TRUE || bIsPressed == TRUE)
			byIndex = 0;
		else
			byIndex = (m_csIcons[1].hIcon == NULL ? 0 : 1);
	} // else

	CRect	rImage;
	PrepareImageRect(bHasTitle, rpItem, rpTitle, bIsPressed, m_csIcons[byIndex].dwWidth, m_csIcons[byIndex].dwHeight, &rImage);

	// Ole'!
	pDC->DrawState(	rImage.TopLeft(),
					rImage.Size(), 
					m_csIcons[byIndex].hIcon,
					(bIsDisabled ? DSS_DISABLED : DSS_NORMAL), 
					(CBrush*)NULL);
} // End of DrawTheIcon

void CButtonST::PreSubclassWindow() 
{
	UINT nBS;

	nBS = GetButtonStyle();

	// Check if this is the default button
	if (nBS & BS_DEFPUSHBUTTON) m_bIsDefault = TRUE;

	// Check if this is a checkbox
	if (nBS & BS_CHECKBOX) m_bIsCheckBox = TRUE;

	// Add BS_OWNERDRAW style
	SetButtonStyle(nBS | BS_OWNERDRAW);

	CButton::PreSubclassWindow();
} // End of PreSubclassWindow

BOOL CButtonST::PreTranslateMessage(MSG* pMsg) 
{
	InitToolTip();
	m_ToolTip.RelayEvent(pMsg);
	
	return CButton::PreTranslateMessage(pMsg);
} // End of PreTranslateMessage

LRESULT CButtonST::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	if (message == WM_LBUTTONDBLCLK)
	{
		message = WM_LBUTTONDOWN;
	} // if
	return CButton::DefWindowProc(message, wParam, lParam);
} // End of DefWindowProc

void CButtonST::SetFlatFocus(BOOL bDrawFlatFocus, BOOL bRepaint)
{
	m_bDrawFlatFocus = bDrawFlatFocus;
	
	// Repaint the button
	if (bRepaint == TRUE) Invalidate();
} // End of SetFlatFocus

BOOL CButtonST::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// If a cursor was specified then use it!
	if (m_hCursor != NULL)
	{
		::SetCursor(m_hCursor);
		return TRUE;
	} // if

	return CButton::OnSetCursor(pWnd, nHitTest, message);
} // End of OnSetCursor

void CButtonST::SetTooltipText(LPCTSTR lpszText, BOOL bActivate)
{
	// We cannot accept NULL pointer
	if (lpszText == NULL) return;

	// Initialize ToolTip
	InitToolTip();

	// If there is no tooltip defined then add it
	if (m_ToolTip.GetToolCount() == 0)
	{
		CRect rectBtn; 
		GetClientRect(rectBtn);
		m_ToolTip.AddTool(this, lpszText, rectBtn, 1);
	}

	// Set text for tooltip
	m_ToolTip.UpdateTipText(lpszText, this, 1);
	m_ToolTip.Activate(bActivate);
} // End of SetTooltipText


void CButtonST::SetTooltipText(int nId, BOOL bActivate)
{
	CString sText;

	// load string resource
	sText.LoadString(nId);
	// If string resource is not empty
	if (sText.IsEmpty() == FALSE) SetTooltipText((LPCTSTR)sText, bActivate);
} // End of SetTooltipText


void CButtonST::ActivateTooltip(BOOL bActivate)
{
	// If there is no tooltip then do nothing
	if (m_ToolTip.GetToolCount() == 0) return;

	// Activate tooltip
	m_ToolTip.Activate(bActivate);
} // End of EnableTooltip


BOOL CButtonST::GetDefault()
{
	return m_bIsDefault;
} // End of GetDefault


void CButtonST::DrawTransparent(BOOL bRepaint)
{
	m_bDrawTransparent = TRUE;

	// Restore old bitmap (if any)
	if (m_dcBk.m_hDC != NULL && m_pbmpOldBk != NULL)
	{
		m_dcBk.SelectObject(m_pbmpOldBk);
	} // if

	m_bmpBk.DeleteObject();
	m_dcBk.DeleteDC();

	// Repaint the button
	if (bRepaint == TRUE) Invalidate();
} // End of DrawTransparent


void CButtonST::InitToolTip()
{
	if (m_ToolTip.m_hWnd == NULL)
	{
		// Create ToolTip control
		m_ToolTip.Create(this);
		// Create inactive
		m_ToolTip.Activate(FALSE);
		// Enable multiline
		m_ToolTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, 400);
	} // if
} // End of InitToolTip


void CButtonST::PaintBk(CDC* pDC)
{
	CClientDC clDC(GetParent());
	CRect rect;
	CRect rect1;

	GetClientRect(rect);

	GetWindowRect(rect1);
	GetParent()->ScreenToClient(rect1);

	if (m_dcBk.m_hDC == NULL)
	{
		m_dcBk.CreateCompatibleDC(&clDC);
		m_bmpBk.CreateCompatibleBitmap(&clDC, rect.Width(), rect.Height());
		m_pbmpOldBk = m_dcBk.SelectObject(&m_bmpBk);
		m_dcBk.BitBlt(0, 0, rect.Width(), rect.Height(), &clDC, rect1.left, rect1.top, SRCCOPY);
	} // if

	pDC->BitBlt(0, 0, rect.Width(), rect.Height(), &m_dcBk, 0, 0, SRCCOPY);
} // End of PaintBk


HBRUSH CButtonST::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	return (HBRUSH)::GetStockObject(NULL_BRUSH); 
} // End of CtlColor


void CButtonST::OnSysColorChange() 
{
	CButton::OnSysColorChange();

	m_dcBk.DeleteDC();
	m_bmpBk.DeleteObject();	
} // End of OnSysColorChange

BOOL CButtonST::OnClicked() 
{	
	if (m_bIsCheckBox == TRUE)
	{
		m_nCheck = !m_nCheck;
		Invalidate();
	} // if
	else
	{
		// Handle the URL (if any)
		if (::lstrlen(m_szURL) > 0)
			::ShellExecute(NULL, _T("open"), m_szURL, NULL,NULL, SW_SHOWMAXIMIZED);
	} // else

	return FALSE;
} // End of OnClicked

void CButtonST::SetCheck(int nCheck, BOOL bRepaint)
{
	if (m_bIsCheckBox == TRUE)
	{
		if (nCheck == 0) m_nCheck = 0;
		else m_nCheck = 1;

		if (bRepaint == TRUE) Invalidate();
	} // if
} // End of SetCheck

int CButtonST::GetCheck()
{
	return m_nCheck;
} // End of GetCheck

void CButtonST::FreeResources(BOOL bCheckForNULL)
{
	if (bCheckForNULL == TRUE)
	{
		// Destroy icons
		// Note: the following two lines MUST be here! even if
		// BoundChecker says they are unnecessary!
		if (m_csIcons[0].hIcon != NULL)	::DeleteObject(m_csIcons[0].hIcon);
		if (m_csIcons[1].hIcon != NULL)	::DeleteObject(m_csIcons[1].hIcon);

		// Destroy bitmaps
		if (m_csBitmaps[0].hBitmap != NULL)	::DeleteObject(m_csBitmaps[0].hBitmap);
		if (m_csBitmaps[1].hBitmap != NULL)	::DeleteObject(m_csBitmaps[1].hBitmap);

		// Destroy mask bitmaps
		if (m_csBitmaps[0].hMask != NULL)	::DeleteObject(m_csBitmaps[0].hMask);
		if (m_csBitmaps[1].hMask != NULL)	::DeleteObject(m_csBitmaps[1].hMask);
	} // if

	::ZeroMemory(&m_csIcons, sizeof(m_csIcons));
	::ZeroMemory(&m_csBitmaps, sizeof(m_csBitmaps));
} // End of FreeResources

DWORD CButtonST::SetBitmaps(HBITMAP hBitmapIn, COLORREF crTransColorIn, HBITMAP hBitmapOut, COLORREF crTransColorOut)
{
	int		nRetValue;
	BITMAP	csBitmapSize;

	// Free any loaded resource
	FreeResources();

	if (hBitmapIn != NULL)
	{
		m_csBitmaps[0].hBitmap = hBitmapIn;
		m_csBitmaps[0].crTransparent = crTransColorIn;
		// Get bitmap size
		nRetValue = ::GetObject(hBitmapIn, sizeof(csBitmapSize), &csBitmapSize);
		if (nRetValue == 0)
		{
			FreeResources();
			return BTNST_INVALIDRESOURCE;
		} // if
		m_csBitmaps[0].dwWidth = (DWORD)csBitmapSize.bmWidth;
		m_csBitmaps[0].dwHeight = (DWORD)csBitmapSize.bmHeight;

		// Create mask for bitmap In
		m_csBitmaps[0].hMask = CreateBitmapMask(hBitmapIn, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight, crTransColorIn);
		if (m_csBitmaps[0].hMask == NULL)
		{
			FreeResources();
			return BTNST_FAILEDMASK;
		} // if

		if (hBitmapOut != NULL)
		{
			m_csBitmaps[1].hBitmap = hBitmapOut;
			m_csBitmaps[1].crTransparent = crTransColorOut;
			// Get bitmap size
			nRetValue = ::GetObject(hBitmapOut, sizeof(csBitmapSize), &csBitmapSize);
			if (nRetValue == 0)
			{
				FreeResources();
				return BTNST_INVALIDRESOURCE;
			} // if
			m_csBitmaps[1].dwWidth = (DWORD)csBitmapSize.bmWidth;
			m_csBitmaps[1].dwHeight = (DWORD)csBitmapSize.bmHeight;

			// Create mask for bitmap Out
			m_csBitmaps[1].hMask = CreateBitmapMask(hBitmapOut, m_csBitmaps[1].dwWidth, m_csBitmaps[1].dwHeight, crTransColorOut);
			if (m_csBitmaps[1].hMask == NULL)
			{
				FreeResources();
				return BTNST_FAILEDMASK;
			} // if
		} // if
	} // if

	RedrawWindow();

	return BTNST_OK;
} // End of SetBitmaps

DWORD CButtonST::SetBitmaps(int nBitmapIn, COLORREF crTransColorIn, int nBitmapOut, COLORREF crTransColorOut)
{
	HBITMAP		hBitmapIn	= NULL;
	HBITMAP		hBitmapOut	= NULL;
	HINSTANCE hInstResource	= NULL;
	
	// Find correct resource handle
	hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapIn), RT_BITMAP);

	// Load bitmap In
	hBitmapIn = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapIn), IMAGE_BITMAP, 0, 0, 0);

	// Load bitmap Out
	hBitmapOut = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapOut), IMAGE_BITMAP, 0, 0, 0);

	return SetBitmaps(hBitmapIn, crTransColorIn, hBitmapOut, crTransColorOut);
} // End of SetBitmaps

void CButtonST::DrawTheBitmap(CDC* pDC, BOOL bHasTitle, RECT* rItem, CRect *rCaption, BOOL bIsPressed, BOOL bIsDisabled)
{
	HDC			hdcBmpMem	= NULL;
	HBITMAP		hbmOldBmp	= NULL;
	HDC			hdcMem		= NULL;
	HBITMAP		hbmT		= NULL;

	BYTE		byIndex		= 0;

	// Select the bitmap to use
	if (m_bIsCheckBox == TRUE)
	{
		if (bIsPressed == TRUE)
			byIndex = 0;
		else
			byIndex = (m_csBitmaps[1].hBitmap == NULL ? 0 : 1);
	} // if
	else
	{
		if (m_bMouseOnButton == TRUE || bIsPressed == TRUE)
			byIndex = 0;
		else
			byIndex = (m_csBitmaps[1].hBitmap == NULL ? 0 : 1);
	} // else

	CRect	rImage;
	PrepareImageRect(bHasTitle, rItem, rCaption, bIsPressed, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, &rImage);

	hdcBmpMem = ::CreateCompatibleDC(pDC->m_hDC);

	hbmOldBmp = (HBITMAP)::SelectObject(hdcBmpMem, m_csBitmaps[byIndex].hBitmap);

	hdcMem = ::CreateCompatibleDC(NULL);

	hbmT = (HBITMAP)::SelectObject(hdcMem, m_csBitmaps[byIndex].hMask);

	::BitBlt(pDC->m_hDC, rImage.left, rImage.top, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcMem, 0, 0, SRCAND);

	::BitBlt(pDC->m_hDC, rImage.left, rImage.top, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcBmpMem, 0, 0, SRCPAINT);

	::SelectObject(hdcMem, hbmT);
	::DeleteDC(hdcMem);

	::SelectObject(hdcBmpMem, hbmOldBmp);
	::DeleteDC(hdcBmpMem);
} // End of DrawTheBitmap

HBITMAP CButtonST::CreateBitmapMask(HBITMAP hSourceBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTransColor)
{
	HBITMAP		hMask		= NULL;
	HDC			hdcSrc		= NULL;
	HDC			hdcDest		= NULL;
	HBITMAP		hbmSrcT		= NULL;
	HBITMAP		hbmDestT	= NULL;
	COLORREF	crSaveBk;
	COLORREF	crSaveDestText;

	hMask = ::CreateBitmap(dwWidth, dwHeight, 1, 1, NULL);
	if (hMask == NULL)	return NULL;

	hdcSrc	= ::CreateCompatibleDC(NULL);
	hdcDest	= ::CreateCompatibleDC(NULL);

	hbmSrcT = (HBITMAP)::SelectObject(hdcSrc, hSourceBitmap);
	hbmDestT = (HBITMAP)::SelectObject(hdcDest, hMask);

	crSaveBk = ::SetBkColor(hdcSrc, crTransColor);

	::BitBlt(hdcDest, 0, 0, dwWidth, dwHeight, hdcSrc, 0, 0, SRCCOPY);

	crSaveDestText = ::SetTextColor(hdcSrc, RGB(255, 255, 255));
	::SetBkColor(hdcSrc,RGB(0, 0, 0));

	::BitBlt(hdcSrc, 0, 0, dwWidth, dwHeight, hdcDest, 0, 0, SRCAND);

	SetTextColor(hdcDest, crSaveDestText);

	::SetBkColor(hdcSrc, crSaveBk);
	::SelectObject(hdcSrc, hbmSrcT);
	::SelectObject(hdcDest, hbmDestT);

	::DeleteDC(hdcSrc);
	::DeleteDC(hdcDest);

	return hMask;
} // End of CreateBitmapMask

//
// Parameters:
//		[IN]	bHasTitle
//				TRUE if the button has a text
//		[IN]	rpItem
//				A pointer to a RECT structure indicating the allowed paint area
//		[IN/OUT]rpTitle
//				A pointer to a CRect object indicating the paint area reserved for the
//				text. This structure will be modified if necessary.
//		[IN]	bIsPressed
//				TRUE if the button is currently pressed
//		[IN]	dwWidth
//				Width of the image (icon or bitmap)
//		[IN]	dwHeight
//				Height of the image (icon or bitmap)
//		[OUT]	rpImage
//				A pointer to a CRect object that will receive the area available to the image
//
void CButtonST::PrepareImageRect(BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, DWORD dwWidth, DWORD dwHeight, CRect* rpImage)
{
	CRect rBtn;

	rpImage->CopyRect(rpItem);

	switch (m_nAlign)
	{
		case ST_ALIGN_HORIZ:
			if (bHasTitle == FALSE /*spTitle->IsEmpty()*/)
			{
				// Center image horizontally
				rpImage->left += ((rpImage->Width() - dwWidth)/2);
			}
			else
			{
				// Image must be placed just inside the focus rect
				rpImage->left += 3;  
				rpTitle->left += dwWidth + 3;
			}
			// Center image vertically
			rpImage->top += ((rpImage->Height() - dwHeight)/2);
			break;

		case ST_ALIGN_HORIZ_RIGHT:
			GetClientRect(&rBtn);
			if (bHasTitle == FALSE /*spTitle->IsEmpty()*/)
			{
				// Center image horizontally
				rpImage->left += ((rpImage->Width() - dwWidth)/2);
			}
			else
			{
				// Image must be placed just inside the focus rect
				rpTitle->right = rpTitle->Width() - dwWidth - 3;
				rpTitle->left = 3;
				rpImage->left = rBtn.right - dwWidth - 3;
				// Center image vertically
				rpImage->top += ((rpImage->Height() - dwHeight)/2);
			}
			break;
		
		case ST_ALIGN_VERT:
			// Center image horizontally
			rpImage->left += ((rpImage->Width() - dwWidth)/2);
			if (bHasTitle == FALSE /*spTitle->IsEmpty()*/)
			{
				// Center image vertically
				rpImage->top += ((rpImage->Height() - dwHeight)/2);           
			}
			else
			{
				rpImage->top = 3;
				rpTitle->top += dwHeight;
			}
			break;
	}
    
	// If button is pressed then press image also
	if (bIsPressed == TRUE && m_bIsCheckBox == FALSE)
		rpImage->OffsetRect(1, 1);
} // End of PrepareImageRect

//
// Parameters:
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetDefaultColors(BOOL bRepaint)
{
	m_crColors[BTNST_COLOR_BK_IN]	= ::GetSysColor(COLOR_BTNFACE);
	m_crColors[BTNST_COLOR_FG_IN]	= ::GetSysColor(COLOR_BTNTEXT);
	m_crColors[BTNST_COLOR_BK_OUT]	= ::GetSysColor(COLOR_BTNFACE);
	m_crColors[BTNST_COLOR_FG_OUT]	= ::GetSysColor(COLOR_BTNTEXT);

	if (bRepaint == TRUE)	Invalidate();

	return BTNST_OK;
} // End of SetDefaultColors

//
// Parameters:
//		[IN]	byColorIndex
//				Index of the color to set. This index is zero-based.
//		[IN]	crColor
//				New color.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDINDEX
//			Invalid color index.
//
DWORD CButtonST::SetColor(BYTE byColorIndex, COLORREF crColor, BOOL bRepaint)
{
	if (byColorIndex >= BTNST_MAX_COLORS)	return BTNST_INVALIDINDEX;

	// Set new color
	m_crColors[byColorIndex] = crColor;

	if (bRepaint == TRUE)	Invalidate();

	return BTNST_OK;
} // End of SetColor

//
// Parameters:
//		[IN]	byColorIndex
//				Index of the color to get. This index is zero-based.
//		[OUT]	crpColor
//				A pointer to a COLORREF that will receive the color.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDINDEX
//			Invalid color index.
//
DWORD CButtonST::GetColor(BYTE byColorIndex, COLORREF* crpColor)
{
	if (byColorIndex >= BTNST_MAX_COLORS)	return BTNST_INVALIDINDEX;

	// Get color
	*crpColor = m_crColors[byColorIndex];

	return BTNST_OK;
} // End of GetColor

//
// Parameters:
//		[IN]	lpszURL
//				Pointer to a null-terminated string that contains the URL.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetURL(LPCTSTR lpszURL)
{
	if (lpszURL != NULL)
	{
		// Store the URL
		::lstrcpyn(m_szURL, lpszURL, _MAX_PATH);
	} // if
	else
	{
		// Remove any existing URL
		::ZeroMemory(&m_szURL, sizeof(m_szURL));
	} // else

	return BTNST_OK;
} // End of SetURL

void CButtonST::CancelHover()
{
	// If our button is not flat then do nothing
	if (m_bIsFlat == FALSE) return;

	if (m_bMouseOnButton == TRUE)
	{
		m_bMouseOnButton = FALSE;
		Invalidate();
	} // if
} // End of CancelHover

// This function enable or disable the autorepeat feature.
//
// Parameters:
//		[IN]	bSet
//				TRUE to enable autorepeat. FALSE to disable.
//		[IN]	dwMilliseconds
//				Time (in milliseconds) between each button click.
//				If bSet is FALSE this parameter is ignored.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetAutoRepeat(BOOL bSet, DWORD dwMilliseconds)
{
	m_bAutoRepeat = bSet;
	m_dwPeriodAutoRepeat = dwMilliseconds;

	return BTNST_OK;
} // End of SetAutoRepeat

// This function is called every time the button background needs to be painted.
// If the button is in transparent mode this function will NOT be called.
//
// Parameters:
//		[IN]	pDC
//				Pointer to a CDC object that indicates the device context.
//		[IN]	pRect
//				Pointer to a CRect object that indicates the bounds of the
//				area to be painted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::OnDrawBackground(CDC* pDC, LPCRECT pRect)
{
	COLORREF	crColor;

	if (m_bMouseOnButton || m_bIsPressed)
		crColor = m_crColors[BTNST_COLOR_BK_IN];
	else
		crColor = m_crColors[BTNST_COLOR_BK_OUT];

	CBrush		brBackground(crColor);

	pDC->FillRect(pRect, &brBackground);

	return BTNST_OK;
} // End of OnDrawBackground

// This function is called every time the button border needs to be painted.
// If the button is in standard (not flat) mode this function will NOT be called.
//
// Parameters:
//		[IN]	pDC
//				Pointer to a CDC object that indicates the device context.
//		[IN]	pRect
//				Pointer to a CRect object that indicates the bounds of the
//				area to be painted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::OnDrawBorder(CDC* pDC, LPCRECT pRect)
{
	if (m_bIsPressed)
		pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHILIGHT));
	else
		pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNHILIGHT), ::GetSysColor(COLOR_BTNSHADOW));

	return BTNST_OK;
} // End of OnDrawBorder

#undef ST_LIKEIE

// ===== END Launcher/BtnST.cpp =====

// ===== BEGIN Launcher/BtnST.h =====
#line 1 "Launcher/BtnST.h"
﻿//
//	Class:		CButtonST
//
//	Compiler:	Visual C++
//	Tested on:	Visual C++ 5.0
//				Visual C++ 6.0
//
//	Version:	See GetVersionC() or GetVersionI()
//
//	Created:	xx/xxxx/1998
//	Updated:	14/June/2001
//
//	Author:		Davide Calabro'		davide_calabro@yahoo.com
//
#ifndef _BTNST_H
#define _BTNST_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CBtnST.h : header file
//

// Comment this if you don't want that CButtonST hilights itself
// also when the window is inactive (like happens in Internet Explorer)
//#define ST_LIKEIE

// Return values
#ifndef	BTNST_OK
#define	BTNST_OK						0
#endif
#ifndef	BTNST_INVALIDRESOURCE
#define	BTNST_INVALIDRESOURCE			1
#endif
#ifndef	BTNST_FAILEDMASK
#define	BTNST_FAILEDMASK				2
#endif
#ifndef	BTNST_INVALIDINDEX
#define	BTNST_INVALIDINDEX				3
#endif

class CButtonST : public CButton
{
public:
    CButtonST();
	~CButtonST();

    enum {ST_ALIGN_HORIZ, ST_ALIGN_VERT, ST_ALIGN_HORIZ_RIGHT};

	enum	{	BTNST_COLOR_BK_IN	= 0,		// Background color when mouse is INside
				BTNST_COLOR_FG_IN,				// Text color when mouse is INside
				BTNST_COLOR_BK_OUT,				// Background color when mouse is OUTside
				BTNST_COLOR_FG_OUT,				// Text color when mouse is OUTside

				BTNST_MAX_COLORS
			};

	// ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CButtonST)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void PreSubclassWindow();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

public:
	DWORD SetAutoRepeat(BOOL bSet, DWORD dwMilliseconds = 100);
	DWORD SetURL(LPCTSTR lpszURL);
	DWORD GetColor(BYTE byColorIndex, COLORREF* crpColor);
	DWORD SetColor(BYTE byColorIndex, COLORREF crColor, BOOL bRepaint = TRUE);
	DWORD SetDefaultColors(BOOL bRepaint = TRUE);
	int GetCheck();
	void SetCheck(int nCheck, BOOL bRepaint = TRUE);
	void DrawTransparent(BOOL bRepaint = FALSE);

	BOOL GetDefault();

	void SetTooltipText(int nId, BOOL bActivate = TRUE);
	void SetTooltipText(LPCTSTR lpszText, BOOL bActivate = TRUE);
	void ActivateTooltip(BOOL bEnable = TRUE);

	BOOL SetBtnCursor(int nCursorId = NULL);

	void SetFlatFocus(BOOL bDrawFlatFocus, BOOL bRepaint = FALSE);

	void SetAlign(int nAlign);
	int GetAlign();

	void SetFlat(BOOL bState = TRUE);
	BOOL GetFlat();

	void DrawBorder(BOOL bEnable = TRUE);
	DWORD SetIcon(int nIconInId, int nIconOutId = NULL);
	DWORD SetIcon(HICON hIconIn, HICON hIconOut = NULL);

	DWORD SetBitmaps(int nBitmapIn, COLORREF crTransColorIn, int nBitmapOut = NULL, COLORREF crTransColorOut = 0);
	DWORD SetBitmaps(HBITMAP hBitmapIn, COLORREF crTransColorIn, HBITMAP hBitmapOut = NULL, COLORREF crTransColorOut = 0);

	static short GetVersionI()		{return 32;}
	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("3.2");}

protected:
    //{{AFX_MSG(CButtonST)
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSysColorChange();
	afx_msg BOOL OnClicked();
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG

	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	virtual DWORD OnDrawBackground(CDC* pDC, LPCRECT pRect);
	virtual DWORD OnDrawBorder(CDC* pDC, LPCRECT pRect);

	BOOL		m_bDrawTransparent;
	BOOL		m_bMouseOnButton;
	BOOL		m_bIsPressed;
	BOOL		m_bIsFocused;
	BOOL		m_bIsDisabled;
	COLORREF	m_crColors[BTNST_MAX_COLORS];

private:
	void CancelHover();
	void PrepareImageRect(BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, DWORD dwWidth, DWORD dwHeight, CRect* rpImage);
	HBITMAP CreateBitmapMask(HBITMAP hSourceBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTransColor);
	void DrawTheBitmap(CDC* pDC, BOOL bHasTitle, RECT *rItem, CRect *rCaption, BOOL bIsPressed, BOOL bIsDisabled);
	void FreeResources(BOOL bCheckForNULL = TRUE);
	void DrawTheIcon(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, BOOL bIsDisabled);
	void InitToolTip();
	void PaintBk(CDC* pDC);

	int		m_nAlign;
	BOOL	m_bDrawBorder;
	BOOL	m_bIsFlat;
	BOOL	m_bDrawFlatFocus;
	BOOL	m_bAutoRepeat;
	HWND	m_hWndAutoRepeat;
	UINT	m_nMsgAutoRepeat;
	DWORD	m_dwPeriodAutoRepeat;

	HCURSOR m_hCursor;
	CToolTipCtrl m_ToolTip;

#pragma pack(1)
	typedef struct _STRUCT_ICONS
	{
		HICON		hIcon;			// Handle to icon
		DWORD		dwWidth;		// Width of icon
		DWORD		dwHeight;		// Height of icon
	} STRUCT_ICONS;
#pragma pack()

#pragma pack(1)
	typedef struct _STRUCT_BITMAPS
	{
		HBITMAP		hBitmap;		// Handle to bitmap
		DWORD		dwWidth;		// Width of bitmap
		DWORD		dwHeight;		// Height of bitmap
		HBITMAP		hMask;			// Handle to mask bitmap
		COLORREF	crTransparent;	// Transparent color
	} STRUCT_BITMAPS;
#pragma pack()

	STRUCT_ICONS	m_csIcons[2];
	STRUCT_BITMAPS	m_csBitmaps[2];

	CDC			m_dcBk;
	CBitmap		m_bmpBk;
	CBitmap*	m_pbmpOldBk;

	BOOL		m_bIsDefault;
	BOOL		m_bIsCheckBox;
	int			m_nCheck;

	TCHAR		m_szURL[_MAX_PATH];

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif

// ===== END Launcher/BtnST.h =====

// ===== BEGIN Launcher/CButtonST_DemoDlg.h =====
#line 1 "Launcher/CButtonST_DemoDlg.h"
﻿#ifndef _CBUTTONST_DEMODLG_H_
#define _CBUTTONST_DEMODLG_H_

#include "BtnST.h"
#include "MyTabCtrl.h"
#include "HyperLink.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CCButtonST_DemoDlg : public CDialog
{
public:
	CCButtonST_DemoDlg(CWnd* pParent = NULL);

	//{{AFX_DATA(CCButtonST_DemoDlg)
	enum { IDD = IDD_CBUTTONST_DEMO_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCButtonST_DemoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CCButtonST_DemoDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

private:
	CButtonST		m_btnClose;

	CMyTabCtrl		m_tabMyTabCtrl;
	CHyperLink		m_EMailLink;
	CHyperLink		m_HomePageLink;

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif

// ===== END Launcher/CButtonST_DemoDlg.h =====

// ===== BEGIN Launcher/Define.h =====
#line 1 "Launcher/Define.h"
﻿#ifndef _DEFINE_H
#define _DEFINE_H

#define SM_EVENTS_RECEIVE			0
#define SM_EVENTS_SEND				1

#define PS_1						0XAA
#define PS_2						0X55
#define PE_1						0X55
#define PE_2						0XAA

#define SM_PACKETPENDING_SEND		0
#define	SM_PACKETPENDING_RECEIVE	1

#define SAFE_DELETE(p)  { if(p) { delete (p);     (p)=nullptr; } }
#define SAFE_DELETES(p) { if(p) { delete[] (p);	  (p)=nullptr; } }
#define SAFE_RELEASE(p) { if(p) { (p)->Release(); (p)=nullptr; } }
#define INIT_PTR(p)		{ (p) = nullptr;}

#define WM_PACKET_ARRIVED			(WM_USER+1)
#define WM_MESSAGE_RESTOREALL		(WM_USER+2)
#define WM_PACKET_PROCESS_PENDING	(WM_USER+100)

#define CONNECT_PORT		15100

#endif
// ===== END Launcher/Define.h =====

// ===== BEGIN Launcher/Launcher.cpp =====
#line 1 "Launcher/Launcher.cpp"
﻿// Launcher.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Launcher.h"
#include "LauncherDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLauncherApp

BEGIN_MESSAGE_MAP(CLauncherApp, CWinApp)
	//{{AFX_MSG_MAP(CLauncherApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLauncherApp construction

CLauncherApp::CLauncherApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLauncherApp object

CLauncherApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLauncherApp initialization

BOOL CLauncherApp::InitInstance()
{
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();
		 
//	SetDialogBkColor(RGB(255, 0, 255), RGB(0, 255, 0));

	CLauncherDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	// application, rather than start the application's message pump.

	return FALSE;
}

CWnd* CLauncherApp::GetMainWnd() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CWinApp::GetMainWnd();
}

void CLauncherApp::DoWaitCursor(int nCode) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	CWinApp::DoWaitCursor(nCode);
}

// ===== END Launcher/Launcher.cpp =====

// ===== BEGIN Launcher/Launcher.h =====
#line 1 "Launcher/Launcher.h"
﻿// Launcher.h : main header file for the LAUNCHER application
//

#if !defined(AFX_LAUNCHER_H__E8289BE5_E48B_4B72_AA38_5C6AFAA024EC__INCLUDED_)
#define AFX_LAUNCHER_H__E8289BE5_E48B_4B72_AA38_5C6AFAA024EC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CLauncherApp:
// See Launcher.cpp for the implementation of this class
//

class CLauncherApp : public CWinApp
{
public:
	CLauncherApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLauncherApp)
	public:
	virtual BOOL InitInstance();
	virtual CWnd* GetMainWnd();
	virtual void DoWaitCursor(int nCode);
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CLauncherApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LAUNCHER_H__E8289BE5_E48B_4B72_AA38_5C6AFAA024EC__INCLUDED_)

// ===== END Launcher/Launcher.h =====

// ===== BEGIN Launcher/LauncherDlg.cpp =====
#line 1 "Launcher/LauncherDlg.cpp"
﻿// LauncherDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Launcher.h"
#include "LauncherDlg.h"
#include <wininet.h>

#include "PacketDef.h"
#include "APISocket.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLauncherDlg dialog

CLauncherDlg::CLauncherDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(CLauncherDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLauncherDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	
	m_pSocket = nullptr;

	memset(m_strServiceName, 0, sizeof(m_strServiceName));
	m_nCurVersion = 0;
	m_nServerVersion = 0;
	m_nGetFileNum = 0;
}



void CLauncherDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLauncherDlg)
	DDX_Control(pDX, IDC_STATUS, m_Status);
	DDX_Control(pDX, IDC_PROGRESS, m_progress);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLauncherDlg, CDialog)
	//{{AFX_MSG_MAP(CLauncherDlg)
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CLauncherDlg message handlers

BOOL CLauncherDlg::OnInitDialog()
{
	CDialog::OnInitDialog() ;

	CString szInfo; szInfo.LoadString(IDS_INFO_VERSION_CHECK);
	m_Status.SetWindowText(szInfo); // 화면에 표시..
			
	m_progress.SetColor(RGB(64, 255, 64)); // 프로그래스 색을 정한다.

	m_pSocket = new CAPISocket();

	CString szProduct, szKey = "SOFTWARE\\";
	szProduct.LoadString(IDS_PRODUCT);
	szKey += szProduct;

	m_hRegistryKey = nullptr;
	long lStatus = RegOpenKey(HKEY_CURRENT_USER, szKey, &m_hRegistryKey);
	if(ERROR_SUCCESS != lStatus) { CString szErr; szErr.LoadString(IDS_ERR_REGISTRY_OPEN); MessageBox(szErr); exit(-1); }

	DWORD dwType = REG_SZ; DWORD dwBytes = 0;
	TCHAR szBuff[256] = {};

	dwType = REG_DWORD; dwBytes = 4;
	lStatus = RegQueryValueEx(m_hRegistryKey, _T("VERSION"), nullptr, &dwType, (BYTE*)(&m_nCurVersion), &dwBytes);
	if(ERROR_SUCCESS != lStatus) { CString szErr; szErr.LoadString(IDS_ERR_REGISTRY_READ_VERSION); MessageBox(szErr); exit(-1); }

	for(int j = 0 ; j < MAX_DOWNLOAD_FILE ; j++)
		m_nVersionNum[j] = m_nCurVersion;

	dwType = REG_SZ; dwBytes = 256;
	lStatus = RegQueryValueEx(m_hRegistryKey, _T("PATH"), nullptr, &dwType, (BYTE*)szBuff, &dwBytes); // 인스톨 경로
	if(ERROR_SUCCESS != lStatus) { CString szErr; szErr.LoadString(IDS_ERR_REGISTRY_READ_PATH); MessageBox(szErr); exit(-1); }
	m_szInstalledPath = szBuff;

	dwType = REG_SZ; dwBytes = 256;
	lStatus = RegQueryValueEx(m_hRegistryKey, _T("EXE"), nullptr, &dwType, (BYTE*)szBuff, &dwBytes); // 실행파일 이름
	if(ERROR_SUCCESS != lStatus) { CString szErr; szErr.LoadString(IDS_ERR_REGISTRY_READ_EXE); MessageBox(szErr); exit(-1); }
	m_szExeName = szBuff;

	dwType = REG_SZ; dwBytes = 256;
	lStatus = RegQueryValueEx(m_hRegistryKey, _T("SERVICE"), nullptr, &dwType, (BYTE*)m_strServiceName, &dwBytes); // 서비스 이름..
	if(ERROR_SUCCESS != lStatus) { CString szErr; szErr.LoadString(IDS_ERR_REGISTRY_READ_SERVICE); MessageBox(szErr); exit(-1); }


	
	
	
	
	
	
	
	
	
	// 소켓 접속..
	TCHAR szIniPath[_MAX_PATH] = {};
	::GetCurrentDirectory(_MAX_PATH, szIniPath);
	lstrcat(szIniPath, _T("\\Server.Ini"));
	int iServerCount = GetPrivateProfileInt(_T("Server"), _T("Count"), 0, szIniPath);

	char szIPs[256][128] = {};
	for(int i = 0; i < iServerCount; i++)
	{
		TCHAR szKey[32] = {}, szIP[128] = {};
		_stprintf(szKey, _T("IP%d"), i);
		GetPrivateProfileString(_T("Server"), szKey, _T(""), szIP, _countof(szIP), szIniPath);
		
		// Just a hack for now; we should be able to trust IPs and hostnames to not be too special.
		sprintf(szIPs[i], "%ls", szIP);
	}

	if(iServerCount > 0)
	{
		int iServer = rand()%iServerCount;
		while( !m_pSocket->Connect(m_hWnd, szIPs[iServer], CONNECT_PORT) )
		{
			int iErrCode = GetLastError();
			CString szFmt; szFmt.LoadString(IDS_FMT_FAILED_CONNECT_LOGIN_SERVER);
			CString szErr; szErr.Format(szFmt, iErrCode);
			if( MessageBox(szErr, _T(""), MB_YESNO) == IDNO )
			{
				AfxPostQuitMessage(0);
				return FALSE;
			}
			else
				continue;
		}
	}
	else
	{
		CString szErr; szErr.LoadString(IDS_ERR_INVALID_SERVER_COUNT);
		this->MessageBox(szInfo); // 끝낸다.
		PostQuitMessage(0);
	}

	TCHAR titlebar[256] = {};
	_stprintf( titlebar, _T("%s AUTO UPGRADE LAUNCHER"), m_strServiceName );
	SetWindowText( titlebar );

	this->PacketSend_VersionReq();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
BOOL CLauncherDlg::DestroyWindow() 
{
	if(m_pSocket) {
		m_pSocket->Disconnect();
		delete m_pSocket;
		m_pSocket = nullptr;
	}
	
	return CDialog::DestroyWindow();
}

CString CLauncherDlg::GetProgPath()
{
	TCHAR Buf[256], Path[256];
	TCHAR drive[_MAX_DRIVE], dir[_MAX_DIR], fname[_MAX_FNAME], ext[_MAX_EXT];

	::GetModuleFileName(AfxGetApp()->m_hInstance, Buf, 256);
	_tsplitpath(Buf,drive,dir,fname,ext);
	_tcscpy(Path, drive);
	_tcscat(Path, dir);		
	return Path;
}

void CLauncherDlg::PacketSend_VersionReq()
{
	int iOffset = 0;
	BYTE byBuffs[128] = {};

	m_pSocket->MP_AddByte( byBuffs, iOffset, VERSION_REQ );
	m_pSocket->MP_AddShort( byBuffs, iOffset , m_nCurVersion );
	
	m_pSocket->Send(byBuffs, iOffset);
}

void CLauncherDlg::PacketSend_DownloadInfo()
{
	int iOffset = 0;
	BYTE byBuffs[128] = {};

	m_pSocket->MP_AddByte( byBuffs, iOffset, DOWNLOAD_INFO_REQ );
	m_pSocket->MP_AddShort( byBuffs, iOffset, (short)m_nCurVersion );
	
	m_pSocket->Send(byBuffs, iOffset);
}

void CLauncherDlg::PacketProcess(BYTE *pBuf, int size)
{
	if (nullptr==pBuf) return;

	BYTE command;
	int iIndex = 0;
	command = m_pSocket->Parse_GetByte( pBuf, iIndex );
	switch(command)
	{
		case VERSION_REQ:		this->PacketReceive_Version(pBuf, iIndex); break;
		case DOWNLOAD_INFO_REQ:	this->PacketReceive_DownloadInfo( pBuf, iIndex ); break;
	}
}

void CLauncherDlg::PacketReceive_DownloadInfo(const BYTE *pBuf, int& iIndex)
{
	int iLen = 0;
	
	iLen = m_pSocket->Parse_GetShort( pBuf, iIndex );
	m_pSocket->Parse_GetString( pBuf, iIndex, m_szFtpUrl, iLen );
	iLen = m_pSocket->Parse_GetShort( pBuf, iIndex );
	m_pSocket->Parse_GetString( pBuf, iIndex, m_szFtpPath, iLen );
	m_nGetFileNum = m_pSocket->Parse_GetShort( pBuf, iIndex );
	
	if( m_nGetFileNum < 1 || m_nGetFileNum >= 32)
	{
		CString szErr; szErr.LoadString(IDS_ERR_INVALID_DOWNLOAD_FILE_COUNT);
		MessageBox(szErr);
		AfxPostQuitMessage(0);
	}
	
	char szBuf[MAX_PATH];
	std::string szVersion;
	int nVersion = 0;
	for( int i=0; i<m_nGetFileNum; i++ )
	{
		iLen = m_pSocket->Parse_GetShort( pBuf, iIndex );
		m_pSocket->Parse_GetString( pBuf, iIndex, m_szGetFileNames[i], iLen );

		sscanf(m_szGetFileNames[i].c_str(), "patch%s", szBuf);
		szVersion = szBuf;
		szVersion.resize(4);
		nVersion = atoi(szVersion.c_str());
		if(m_nVersionNum[i] < nVersion)
			m_nVersionNum[i] = nVersion;
	}

	DownloadProcess();
}

void CLauncherDlg::PacketReceive_Version(const BYTE *pBuf, int &iIndex)
{
	m_nServerVersion = m_pSocket->Parse_GetShort( pBuf, iIndex );
	if( m_nCurVersion == m_nServerVersion ) // 버전이 일치하면.. 
	{
		this->StartGame(); // 게임 실행..
	}
	else if( m_nCurVersion < m_nServerVersion ) // 버전이 낮으면..
	{
		PacketSend_DownloadInfo(); // 다운로드 요청..
	}
	else 
	{
		CString szErr; szErr.LoadString(IDS_ERR_INVALID_VERSION);
		MessageBox(szErr);
		PostQuitMessage(-1);
	}
}

void CLauncherDlg::StartGame()
{
	CString szCmd = GetCommandLine(); // 커맨드 라인을 가져오고..
	TCHAR szApp[_MAX_PATH] = {};
	GetModuleFileName(nullptr, szApp, _MAX_PATH);
	int iML = lstrlen(szApp);

	CString szParam;
	if(iML >= 0)
	{
		int ii = szCmd.Find(szApp);
		if(ii >= 0 && szCmd.GetLength() > ii + iML + 2)
			szParam = szCmd.Mid(ii + iML + 2);
	}

	CString szExeFN = m_szInstalledPath + _T("\\") + m_szExeName; // 실행 파일 이름 만들고..
	::ShellExecute(nullptr, _T("open"), szExeFN, szParam, m_szInstalledPath, SW_SHOWNORMAL); // 게임 실행..

	PostQuitMessage(0);
}

void CLauncherDlg::DownloadProcess()
{
	if( !FTP_Open() )
	{
		PostQuitMessage(0);
		return;
	}

	m_progress.SetRange(0, 100);
	m_progress.SetPos(0);

	std::string		szFullPath;
	CString			szLocalFName;

	bool bExtractSuccess = true;

	for( int i=0; i<m_nGetFileNum; i++ )
	{
		szFullPath = m_szFtpPath + "/" + m_szGetFileNames[i];
		BOOL bDownloadSuccess = GetDownloadFile( szFullPath, m_szGetFileNames[i] );
		while(!bDownloadSuccess)
		{
			CString szErr; szErr.LoadString(IDS_ERR_DOWNLOAD_PATCH_FILE_AND_RETRY); // 다시 시도할까여??
			int iID = MessageBox(szErr, _T("Patch error"), MB_YESNO);
			if(IDYES == iID) bDownloadSuccess = GetDownloadFile( szFullPath, m_szGetFileNames[i] );
			else 
			{
				AfxPostQuitMessage(-1);
				break;
			}
		}

		if(bDownloadSuccess)
		{
			szLocalFName.Format(
				_T("%s\\%hs"),
				m_szInstalledPath.GetString(),
				m_szGetFileNames[i].c_str());

			CString szInfo; szInfo.LoadString(IDS_INFO_EXTRACTING);
			m_Status.SetWindowText(szInfo);

			if(false == ArchiveClose()) { bExtractSuccess = false; break; }
			if(false == ArchiveOpen(szLocalFName)) { bExtractSuccess = false; break; }
			if(false == ArchiveExtract(m_szInstalledPath)) { bExtractSuccess = false; break; }
			if(false == ArchiveClose()) { bExtractSuccess = false; break; }

			CFile file;
			if( file.Open( szLocalFName, CFile::modeRead | CFile::shareDenyNone , nullptr ) )
			{
				file.Close();
				file.Remove(szLocalFName);
				if(m_hRegistryKey) // 압축 풀기와 쓰기, 압축 파일 삭제에 성공하면 버전을 쓰고..
				{
					RegSetValueEx(m_hRegistryKey, _T("VERSION"), 0, REG_DWORD, ((BYTE*)(&m_nVersionNum[i])), 4);
				}
			}
			else
			{
				bExtractSuccess = false;
				break;
			}
		}
		else
		{
			FTP_Close();

			CString szErr, szMsg;
			szErr.LoadString(IDS_ERR_DOWNLOAD_PATCH_FILE);
			szMsg.Format(_T("%hs"), m_szGetFileNames[i].c_str());
			MessageBox(szMsg, szErr);

			PostQuitMessage(0);

			bExtractSuccess = false;
			break;
		}
	}

	FTP_Close();

//	CString inipath, version;
//	inipath.Format( "%s\\server.ini", GetProgPath() );
//	itoa( m_nServerVersion, (char*)(LPCTSTR)version, 10 );
//	WritePrivateProfileString("VERSION","CURRENT",version, inipath);

	if(true == bExtractSuccess && m_hRegistryKey) // 압축 풀기와 쓰기, 압축 파일 삭제에 성공하면 버전을 쓰고..
	{
		long lStatus = RegSetValueEx(m_hRegistryKey, _T("VERSION"), 0, REG_DWORD, ((BYTE*)(&m_nServerVersion)), 4);
		this->StartGame(); // 게임 실행..
	}
	else
	{
		CString szErr; szErr.LoadString(IDS_ERR_PATCH);
		MessageBox(szErr);
		PostQuitMessage(-1);
	}
}

BOOL CLauncherDlg::FTP_Open()
{
	m_hInetSession = InternetOpen(
		_T("3DOnline"),
		INTERNET_OPEN_TYPE_PRECONFIG,
		nullptr,
		nullptr,
		0);
	if (!m_hInetSession)
	{
		CString szErr, szMsg;
		szErr.LoadString(IDS_ERR_INIT_INTERNET);
		szMsg.Format(_T("%hs"), m_szFtpUrl.c_str());
		MessageBox(szMsg, szErr);
		return FALSE;
	}

	m_hFtpConnection = InternetConnectA(
		m_hInetSession,
		m_szFtpUrl.c_str(),
		INTERNET_DEFAULT_FTP_PORT,
		"anonymous",
		"download",
		INTERNET_SERVICE_FTP,
		INTERNET_FLAG_PASSIVE,
		0);

	if (!m_hFtpConnection)
	{
		CString szErr, szMsg;
		szErr.LoadString(IDS_ERR_CONNECT_FTP);
		szMsg.Format(_T("%hs"), m_szFtpUrl.c_str());
		MessageBox(szMsg, szErr);
		return FALSE;
	}

	return TRUE;
}

void CLauncherDlg::FTP_Close()
{
	if (m_hFtpConnection)
	{
		InternetCloseHandle(m_hFtpConnection);
		m_hFtpConnection = nullptr;
	}

	if (m_hInetSession)
	{
		InternetCloseHandle(m_hInetSession);
		m_hInetSession = nullptr;
	}
}

BOOL CLauncherDlg::GetDownloadFile(const std::string& szFtpUrl, const std::string& szFileName)
{
	if (!m_hFtpConnection)
		return FALSE;

	DWORD dwFileSize = IsFtpExistFile( szFtpUrl, szFileName );

	// open the file
	HINTERNET hFile;

	//CInternetFile *pFile;
	hFile = FtpOpenFileA(m_hFtpConnection,
						szFtpUrl.c_str(),
						GENERIC_READ,
						FTP_TRANSFER_TYPE_BINARY,
						0);
	
	if (!hFile) return FALSE;

	// read & save the file...
	CString szLocalFName;
	szLocalFName.Format(
		_T("%s\\%hs"),
		m_szInstalledPath.GetString(),
		szFileName.c_str());

	FILE *fp = _tfopen(szLocalFName, _T("wb"));
	if (fp == nullptr)
	{
		MessageBox(_T("Can`t open local file"));

		InternetCloseHandle(hFile);
		return TRUE;
	}

	DWORD dwReadSize, dwTemp;
	char  Buffer[1024];
	BOOL  bRes;
	dwReadSize = 0;
	DWORD dwElaspedTime = 0;
	DWORD dwCurrent;
	MSG pMsg;
	BOOL bPeekMessage;

	DWORD dwLastTime = ::GetTickCount ();
	
	while (dwReadSize < dwFileSize)
	{
		bRes = InternetReadFile(hFile, Buffer, 1024, &dwTemp);
		fwrite(Buffer, 1, dwTemp, fp);
		dwReadSize += dwTemp;

		if ((dwFileSize/1024) == 0 )
			m_progress.SetPos( (dwReadSize/1024) * 100 / 1 );
		else
			m_progress.SetPos( (dwReadSize/1024) * 100 / (dwFileSize/1024) );

		dwCurrent = ::GetTickCount ();
		dwElaspedTime += dwCurrent - dwLastTime;

		CString szInfo;
		szInfo.Format(_T("%hs Downloading..."), szFileName.c_str());
		m_Status.SetWindowText(szInfo);

		bPeekMessage = ::PeekMessage(&pMsg, nullptr, 0, 0, PM_REMOVE);
		if(bPeekMessage)
		{
			TranslateMessage(&pMsg);
			DispatchMessage(&pMsg);
		}

		dwLastTime = dwCurrent;

//		if ( m_fCancel || !bRes )
//			break;

//		Sleep(100);
	}
	fclose(fp);

	//if (dwReadSize != dwFileSize)
	if (dwReadSize < dwFileSize)
	{
		InternetCloseHandle(hFile);

/*		if ( m_fCancel )
		{
			MessageBox("File Size Error");
			//// added by manseek for DOWNLOAD
			CString sLink;
			sLink.Format("http://download.mgame.com/download/%s.exe", (LPCTSTR)m_strGameID );
			HINSTANCE t = ShellExecute(GetSafeHwnd(), "open", sLink, nullptr,  nullptr, SW_SHOWNORMAL);
			//// 2001.5.23

			return FALSE;
		};
*/
		MessageBox(_T("File Size Error"));

		return FALSE;
	}

	// close the file
	InternetCloseHandle(hFile);

	return TRUE;
}

BOOL CLauncherDlg::IsFtpExistFile(const std::string& szFtpUrl, const std::string& szFileName)
{
	CString strNameU, strNameL, strName;

	strNameU = szFtpUrl.c_str();
	strNameU.MakeUpper();

	strNameL = szFtpUrl.c_str();
	strNameL.MakeLower();

	CString strSub1, strSub2;

	CString strTemp;
	strTemp = szFileName.c_str();
	

	strSub1 = strNameU.Left( strNameU.GetLength() - strTemp.GetLength() + 1);
	strSub2 = strNameU.Right( strTemp.GetLength() - 1);
	
	strSub2.MakeLower();

	strName = strSub1+strSub2;


	if (!m_hFtpConnection)
		return 0;

	// find the file...
	WIN32_FIND_DATA FindFileData;
	HINTERNET hFind;

	hFind = FtpFindFirstFile(m_hFtpConnection,
							 strName,
							 &FindFileData,
							 0,
							 0);
	if (!hFind)
	{	
		hFind = FtpFindFirstFile(m_hFtpConnection,
							 strNameU,
							 &FindFileData,
							 0,
							 0);
		
		if (!hFind)
		{
			hFind = FtpFindFirstFile(m_hFtpConnection,
							 strNameL,
							 &FindFileData,
							 0,
							 0);
		
			if (!hFind)
				return 0;
		}
	}

	InternetCloseHandle(hFind);

	return FindFileData.nFileSizeLow;
}

bool CLauncherDlg::ArchiveClose()
{
	int berr = false;
	
	//// ArchiveClose
	try
	{
		m_zip.Close(false);	
	}
	catch (CException* e)
	{
		e->Delete();
		berr = true;
	}
	catch(...) // thrown in the STL version
	{
		berr = true;		
	}
	if (berr)
	{
		MessageBox(_T("Archive close failed"), _T(""), MB_ICONSTOP);
		return false;
	}

	return true;
	///
}

bool CLauncherDlg::ArchiveOpen( CString OpenFileName )
{
	int berr = 0;

	//// ArchiveOpen
	do 
	{
		try
		{
			m_zip.Open(OpenFileName, CZipArchive::open, 1 );
			berr = 0;
		}
		catch (CZipException* e)
		{
			if (e->m_iCause == CZipException::cdirNotFound)
				berr = -1;
			else
				berr = 1;
			e->Delete();
		}
		catch (CException* e)
		{
			e->Delete();
			berr = 1;
			
		}
		// thrown in the STL version
		catch (const CZipException& e)
		{
			if (e.m_iCause == CZipException::cdirNotFound)
				berr = -1;
			else
				berr = 1;

		}
		catch(...) 
		{
			berr = 1;
		}
		if (berr == -1)
		{
			if (MessageBox(_T("The central directory was not found. If you're opening a multi-disk archive, make sure you have inserted the last disk. Retry?"), _T(""), MB_ICONSTOP|MB_YESNO) == IDNO)
				berr = 1;
			else
				m_zip.Close(true);
		}

		if (berr == 1)
		{
			MessageBox(_T("Archive open failed"), _T(""), MB_ICONSTOP);
			return false;
		}

	} while (berr == -1);
	////
	
	return true;
}

bool CLauncherDlg::ArchiveExtract( CString ExtractFolder )
{
	int nZipCount = m_zip.GetNoEntries();

	bool bErr = false;
	try
	{	
		for (int i = 0; i < nZipCount; i++)
		{
			m_zip.ExtractFile((WORD)i, ExtractFolder, true, nullptr);//, Callback, (void*) &p);
		}
	}
	catch (CException* e)
	{
		e->Delete();
		bErr = true;

	}
	catch(...) // thrown in the STL version
	{
		bErr = true;
	}
	if (bErr)
	{
		m_zip.CloseFile(nullptr, true);
		MessageBox(_T("Extract failed"), _T(""), MB_ICONSTOP);
		return false;
	}

	return true;
}

LRESULT CLauncherDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	switch(message)
    {
		case WM_SOCKETMSG:
		{
			switch(WSAGETSELECTEVENT(lParam))
			{
			case FD_CONNECT:
				TRACE("Socket connected..\n");
				break;
//			case FD_ACCEPT:
//				break;
			case FD_CLOSE:
				TRACE("Socket closed..\n");
				break;
			case FD_READ:
				{
					m_pSocket->Receive();

					while ( m_pSocket->m_qRecvPkt.size() > 0 )			// 패킷 리스트에 패킷이 있냐????
					{
						int iOffset = 0;
						DataPack* pDataPack = m_pSocket->m_qRecvPkt.front();	// 큐의 첫번째 것을 복사..
						this->PacketProcess(pDataPack->m_pData, iOffset);		// 패킷을 처리할 상황이 아니다.
						delete pDataPack;
						m_pSocket->m_qRecvPkt.pop();							// 패킷을 큐에서 꺼냄..
					}
				}
				break;
			default:
				ASSERT(0);
				break;
			}
		}
		break;
	}
	
	return CDialog::WindowProc(message, wParam, lParam);
}

// ===== END Launcher/LauncherDlg.cpp =====

// ===== BEGIN Launcher/LauncherDlg.h =====
#line 1 "Launcher/LauncherDlg.h"
﻿// LauncherDlg.h : header file
//

#if !defined(AFX_LAUNCHERDLG_H__325A6320_D329_4918_8850_89A24809D8CD__INCLUDED_)
#define AFX_LAUNCHERDLG_H__325A6320_D329_4918_8850_89A24809D8CD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <string>
#include <vector>

#include "afxinet.h"
#include "MacProgressCtrl.h"
#include "Resource.h"
#include "define.h"
#include <ZipArchive/ZipArchive.h>

//#include "DlgTransparent.h"


const int MAX_DOWNLOAD_FILE = 64;
/////////////////////////////////////////////////////////////////////////////
// CLauncherDlg dialog

class CLauncherDlg : public CDialog
{
public:
	struct __ServerInfo
	{
		std::string szIP;
		std::string szName;
		int			iUserCount;
	};

	std::vector<__ServerInfo>	m_InfoServers;
	CZipArchive					m_zip;

	HINTERNET m_hInetSession;
	HINTERNET m_hFtpConnection;
	class CAPISocket*			m_pSocket;

	int			m_nCurVersion;
	TCHAR		m_strServiceName[256];
	CString		m_szExeName;
	CString		m_szInstalledPath;
		
	int			m_nServerVersion;
	std::string m_szFtpUrl;
	std::string m_szFtpPath;

	int			m_nGetFileNum;
	std::string	m_szGetFileNames[MAX_DOWNLOAD_FILE];
	int			m_nVersionNum[MAX_DOWNLOAD_FILE];

	HKEY		m_hRegistryKey; // 레지스트리 키 핸들..

// Construction
public:
	void PacketSend_DownloadInfo();
	void PacketReceive_DownloadInfo(const BYTE* pBuf, int& iIndex);
	void PacketReceive_ServerList(const BYTE* pBuf, int& iIndex);
	void PacketReceive_Version(const BYTE* pBuf, int& iIndex);
	void PacketProcess( BYTE* pBuf, int size );

	void FTP_Close();
	BOOL IsFtpExistFile(const std::string& szFtpUrl, const std::string& szFileName);
	BOOL GetDownloadFile(const std::string& szFtpUrl, const std::string& szFileName);
	BOOL FTP_Open();
	void DownloadProcess();
	void StartGame();

	CLauncherDlg(CWnd* pParent = nullptr);	// standard constructor
	
	CString GetProgPath();
	void PacketSend_VersionReq();
	
	bool ArchiveClose();
	bool ArchiveOpen( CString OpenFileName );
	bool ArchiveExtract( CString ExtractFolder );

// Dialog Data
	//{{AFX_DATA(CLauncherDlg)
	enum { IDD = IDD_LAUNCHER_DIALOG };
	CStatic	m_Status;
	CMacProgressCtrl	m_progress;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLauncherDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLauncherDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LAUNCHERDLG_H__325A6320_D329_4918_8850_89A24809D8CD__INCLUDED_)

// ===== END Launcher/LauncherDlg.h =====

// ===== BEGIN Launcher/MacProgressCtrl.cpp =====
#line 1 "Launcher/MacProgressCtrl.cpp"
﻿// MacProgressCtrl.cpp : implementation file
//
//	CMacProgressCtrl class, version 1.0
//
//	Copyright (c) 1999 Paul M. Meidinger (pmmeidinger@yahoo.com)
//
// Feel free to modifiy and/or distribute this file, but
// do not remove this header.
//
// I would appreciate a notification of any bugs discovered or 
// improvements that could be made.
//
// This file is provided "as is" with no expressed or implied warranty.
//
//	History:
//		PMM	12/21/1999		Initial implementation.		


#include "stdafx.h"
#include "MacProgressCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define	IDT_INDETERMINATE		100
#define	IND_BAND_WIDTH			20

// Funtion prototypes.
COLORREF LightenColor(const COLORREF crColor, BYTE byIncreaseVal);
COLORREF DarkenColor(const COLORREF crColor, BYTE byReduceVal);

//-------------------------------------------------------------------
//
COLORREF LightenColor(const COLORREF crColor, BYTE byIncreaseVal)
//
// Return Value:	None.
//
// Parameters	:	crColor - References a COLORREF structure.
//						byReduceVal - The amount to reduce the RGB values by.
//
// Remarks		:	Lightens a color by increasing the RGB values by the given number.
//
{
	BYTE byRed = GetRValue(crColor);
	BYTE byGreen = GetGValue(crColor);
	BYTE byBlue = GetBValue(crColor);

	if ((byRed + byIncreaseVal) <= 255)
		byRed = BYTE(byRed + byIncreaseVal);
	if ((byGreen + byIncreaseVal)	<= 255)
		byGreen = BYTE(byGreen + byIncreaseVal);
	if ((byBlue + byIncreaseVal) <= 255)
		byBlue = BYTE(byBlue + byIncreaseVal);

	return RGB(byRed, byGreen, byBlue);
}	// LightenColorref

//-------------------------------------------------------------------
//
COLORREF DarkenColor(const COLORREF crColor, BYTE byReduceVal)
//
// Return Value:	None.
//
// Parameters	:	crColor - References a COLORREF structure.
//						byReduceVal - The amount to reduce the RGB values by.
//
// Remarks		:	Darkens a color by reducing the RGB values by the given number.
//
{
	BYTE byRed = GetRValue(crColor);
	BYTE byGreen = GetGValue(crColor);
	BYTE byBlue = GetBValue(crColor);

	if (byRed >= byReduceVal)
		byRed = BYTE(byRed - byReduceVal);
	if (byGreen >= byReduceVal)
		byGreen = BYTE(byGreen - byReduceVal);
	if (byBlue >= byReduceVal)
		byBlue = BYTE(byBlue - byReduceVal);

	return RGB(byRed, byGreen, byBlue);
}	// DarkenColorref

/////////////////////////////////////////////////////////////////////////////
// CMacProgressCtrl

//-------------------------------------------------------------------
//
CMacProgressCtrl::CMacProgressCtrl()
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	Standard constructor.
//
{
	m_bIndeterminate = FALSE;
	m_nIndOffset = 0;
	m_crColor = ::GetSysColor(COLOR_HIGHLIGHT);
	GetColors();
	CreatePens();
}	// CMacProgressCtrl

//-------------------------------------------------------------------
//
CMacProgressCtrl::~CMacProgressCtrl()
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	None.
//
{
	DeletePens();
}	// ~CMacProgressCtrl


BEGIN_MESSAGE_MAP(CMacProgressCtrl, CProgressCtrl)
	//{{AFX_MSG_MAP(CMacProgressCtrl)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMacProgressCtrl message handlers

//-------------------------------------------------------------------
//
void CMacProgressCtrl::OnPaint() 
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	The framework calls this member function when Windows 
//						or an application makes a request to repaint a portion 
//						of an application뭩 window.
//
{
	CPaintDC dcPaint(this); // device context for painting
	CRect rect, rectClient;
	GetClientRect(rectClient);
	rect = rectClient;
	BOOL bVertical = GetStyle() & PBS_VERTICAL;

	// Create a memory DC for drawing.
	CDC dc;
	dc.CreateCompatibleDC(&dcPaint);
 	int nSavedDC = dc.SaveDC();
	CBitmap bmp;
	bmp.CreateCompatibleBitmap(&dcPaint, rect.Width(), rect.Height());
	CBitmap *pOldBmp = dc.SelectObject(&bmp);
	
	CBrush br1(m_crColorLightest);
	CBrush br2(::GetSysColor(COLOR_3DFACE));
	dc.FillRect(rect, &br2);

	int nLower, nUpper;
	GetRange(nLower, nUpper);

	// Determine the size of the bar and draw it.
	if (bVertical)
	{
		if (!m_bIndeterminate)
			rect.top = rect.bottom - int(((float)rect.Height() * float(GetPos() - nLower)) / float(nUpper - nLower));
		dc.FillRect(rect, &br1);
		DrawVerticalBar(&dc, rect);
	}
	else
  	{
		if (!m_bIndeterminate)
			rect.right = int(((float)rect.Width() * float(GetPos() - nLower)) / float(nUpper - nLower));
		dc.FillRect(rect, &br1);
		DrawHorizontalBar(&dc, rect);
	}

	dcPaint.BitBlt(rectClient.left, rectClient.top, rectClient.Width(), rectClient.Height(), 
						&dc, rectClient.left, rectClient.top, SRCCOPY);

	dc.SelectObject(pOldBmp);
	dc.RestoreDC(nSavedDC);
	dc.DeleteDC();
}	// OnPaint	

//-------------------------------------------------------------------
//
void CMacProgressCtrl::DrawHorizontalBar(CDC *pDC, const CRect rect)
//
// Return Value:	None.
//
// Parameters	:	pDC - Specifies the device context object.
//						rect - Specifies the rectangle of the progess bar.
//
// Remarks		:	Draws a horizontal progress bar.
//
{
	if (!rect.Width())
		return;

	int nLeft = rect.left;
	int nTop = rect.top;
	int nBottom = rect.bottom;

	// Assume we're not drawing the indeterminate state.
	CPen *pOldPen = pDC->SelectObject(&m_penColorLight);

	if (m_bIndeterminate)
	{
		pOldPen = pDC->SelectObject(&m_penColor);
		int nNumBands = (rect.Width() / IND_BAND_WIDTH) + 2;
		int nHeight = rect.Height() + 1;

		int nAdjust = nLeft - IND_BAND_WIDTH + m_nIndOffset;
		int nXpos = 0;
		int nYpos1 = nTop + 1;
		int nYpos2 = nBottom - 2;

		for (int i = 0; i < nNumBands; i++)
		{
			nXpos = nAdjust + (i * IND_BAND_WIDTH);

			pDC->SelectObject(&m_penColorDarker);
			pDC->MoveTo(nXpos + 1, nTop);
			pDC->LineTo(nXpos + nHeight, nBottom);

			pDC->SelectObject(&m_penColorDark);
			pDC->MoveTo(nXpos + 2, nTop);
			pDC->LineTo(nXpos + nHeight + 1, nBottom);
			pDC->MoveTo(nXpos + 10, nTop);
			pDC->LineTo(nXpos + nHeight + 9, nBottom);

			pDC->SelectObject(&m_penColor);
			pDC->MoveTo(nXpos + 3, nTop);
			pDC->LineTo(nXpos + nHeight + 2, nBottom);
			pDC->MoveTo(nXpos + 9, nTop);
			pDC->LineTo(nXpos + nHeight + 8, nBottom);

			pDC->SelectObject(&m_penColorLight);
			pDC->MoveTo(nXpos + 4, nTop);
			pDC->LineTo(nXpos + nHeight + 3, nBottom);
			pDC->MoveTo(nXpos + 8, nTop);
			pDC->LineTo(nXpos + nHeight + 7, nBottom);

			pDC->SelectObject(&m_penColorLighter);
			pDC->MoveTo(nXpos + 5, nTop);
			pDC->LineTo(nXpos + nHeight + 4, nBottom);
			pDC->MoveTo(nXpos + 7, nTop);
			pDC->LineTo(nXpos + nHeight + 6, nBottom);
		}	// for the number of bands
	}	// if indeterminate
	else
	{
		int nRight = rect.right;
	
		pDC->MoveTo(nLeft + 2, nBottom - 4);
		pDC->LineTo(nRight - 2, nBottom - 4);
		pDC->MoveTo(nLeft + 2, nTop + 2);
		pDC->LineTo(nRight - 2, nTop + 2);
		pDC->SetPixel(nLeft + 1, nBottom - 3, m_crColorLight);
		pDC->SetPixel(nLeft + 1, nTop + 1, m_crColorLight);

		pDC->SelectObject(&m_penColorLighter);
		pDC->MoveTo(nLeft + 2, nBottom - 5);
		pDC->LineTo(nRight - 3, nBottom - 5);
		pDC->LineTo(nRight - 3, nTop + 3);
		pDC->LineTo(nLeft + 1, nTop + 3);
		pDC->SetPixel(nLeft + 1, nBottom - 4, m_crColorLighter);
		pDC->SetPixel(nLeft + 1, nTop + 2, m_crColorLighter);

		pDC->SelectObject(&m_penColor);
		pDC->MoveTo(nLeft, nBottom - 1);
		pDC->LineTo(nLeft, nTop);
		pDC->LineTo(nLeft + 2, nTop);
		pDC->SetPixel(nLeft + 1, nBottom - 2, m_crColor);
		pDC->MoveTo(nLeft + 2, nBottom - 3);
		pDC->LineTo(nRight - 2, nBottom - 3);
		pDC->MoveTo(nLeft + 2, nTop + 1);
		pDC->LineTo(nRight - 1, nTop + 1);
		
		pDC->SelectObject(&m_penColorDark);
		pDC->MoveTo(nLeft + 2, nBottom - 2);
		pDC->LineTo(nRight - 2, nBottom - 2);
		pDC->LineTo(nRight - 2, nTop + 1);
		pDC->MoveTo(nLeft + 2, nTop);
		pDC->LineTo(nRight, nTop);
		pDC->SetPixel(nLeft + 1, nBottom - 1, m_crColorDark);

		pDC->SelectObject(&m_penColorDarker);
		pDC->MoveTo(nLeft + 2, nBottom - 1);
		pDC->LineTo(nRight - 1, nBottom - 1);
		pDC->LineTo(nRight - 1, nTop);

		pDC->SelectObject(&m_penShadow);
		pDC->MoveTo(nRight, nTop);
 		pDC->LineTo(nRight, nBottom);

		pDC->SelectObject(&m_penLiteShadow);
 		pDC->MoveTo(nRight + 1, nTop);
		pDC->LineTo(nRight + 1, nBottom);
	}	// if not indeterminate

	pDC->SelectObject(pOldPen);
}	// DrawHorizontalBar

//-------------------------------------------------------------------
//
void CMacProgressCtrl::DrawVerticalBar(CDC *pDC, const CRect rect)
//
// Return Value:	None.
//
// Parameters	:	pDC - Specifies the device context object.
//						rect - Specifies the rectangle of the progess bar.
//
// Remarks		:	Draws a vertical progress bar.
//
{
	int nHeight = rect.Height();
	if (!nHeight)
		return;

	int nLeft = rect.left;
	int nTop = rect.top;
	int nRight = rect.right;
	int nBottom = rect.bottom;

	CPen *pOldPen = pDC->SelectObject(&m_penColor);

	if (m_bIndeterminate)
	{
		int nNumBands = (nHeight / IND_BAND_WIDTH) + 2;
		int nHeight = rect.Width() + 1;

		int nAdjust = nBottom - m_nIndOffset;
		int nXpos1 = nLeft;
		int nXpos2 = nRight + 1;
		int nYpos = nTop + 1;

		for (int i = 0; i < nNumBands; i++)
		{
			nYpos = nAdjust - (i * IND_BAND_WIDTH);

			pDC->SelectObject(&m_penColorDarker);
			pDC->MoveTo(nXpos1, nYpos);
			pDC->LineTo(nXpos2, nYpos + nHeight);

			pDC->SelectObject(&m_penColorDark);
			pDC->MoveTo(nXpos1, nYpos + 1);
			pDC->LineTo(nXpos2, nYpos + nHeight + 1);
			pDC->MoveTo(nXpos1, nYpos + 9);
			pDC->LineTo(nXpos2, nYpos + nHeight + 9);

			pDC->SelectObject(&m_penColor);
			pDC->MoveTo(nXpos1, nYpos + 2);
			pDC->LineTo(nXpos2, nYpos + nHeight + 2);
			pDC->MoveTo(nXpos1, nYpos + 8);
			pDC->LineTo(nXpos2, nYpos + nHeight + 8);

			pDC->SelectObject(&m_penColorLight);
			pDC->MoveTo(nXpos1, nYpos + 3);
			pDC->LineTo(nXpos2, nYpos + nHeight + 3);
			pDC->MoveTo(nXpos1, nYpos + 7);
			pDC->LineTo(nXpos2, nYpos + nHeight + 7);

			pDC->SelectObject(&m_penColorLighter);
			pDC->MoveTo(nXpos1, nYpos + 4);
			pDC->LineTo(nXpos2, nYpos + nHeight + 4);
			pDC->MoveTo(nXpos1, nYpos + 6);
			pDC->LineTo(nXpos2, nYpos + nHeight + 6);
		}	// for the number of bands
	}	// if indeterminate
	else
	{
		if (nHeight > 3)
		{
			pDC->MoveTo(nLeft, nTop + 1);
			pDC->LineTo(nLeft, nTop);
			pDC->LineTo(nRight, nTop);
			pDC->MoveTo(nLeft + 1, nBottom - 2);
			pDC->LineTo(nLeft + 1, nTop + 1);
			pDC->MoveTo(nRight - 3, nBottom - 3);
			pDC->LineTo(nRight - 3, nTop + 1);
			pDC->SetPixel(nRight - 2, nTop + 1, m_crColor);

			pDC->SelectObject(&m_penColorLight);
			pDC->MoveTo(nLeft + 2, nBottom - 3);
			pDC->LineTo(nLeft + 2, nTop + 1);
			pDC->MoveTo(nRight - 4, nBottom - 3);
			pDC->LineTo(nRight - 4, nTop + 1);
			pDC->SetPixel(nLeft + 1, nTop + 1, m_crColorLight);
			pDC->SetPixel(nRight - 3, nTop + 1, m_crColorLight);
			
			pDC->SelectObject(&m_penColorLighter);
			pDC->MoveTo(nLeft + 3, nBottom - 3);
			pDC->LineTo(nLeft + 3, nTop + 1);
			pDC->MoveTo(nRight - 5, nBottom - 3);
			pDC->LineTo(nRight - 5, nTop + 1);
			pDC->SetPixel(nLeft + 2, nTop + 1, m_crColorLighter);
			pDC->SetPixel(nRight - 4, nTop + 1, m_crColorLighter);

			pDC->SelectObject(&m_penColorDark);
			pDC->MoveTo(nLeft, nBottom - 1);
			pDC->LineTo(nLeft, nTop + 1);
			pDC->MoveTo(nLeft + 2, nBottom - 2);
			pDC->LineTo(nRight - 2, nBottom - 2);
			pDC->LineTo(nRight - 2, nTop + 1);
			pDC->SetPixel(nRight - 1, nTop + 1, m_crColorDark);

			pDC->SelectObject(&m_penColorDarker);
			pDC->MoveTo(nLeft + 1, nBottom - 1);
			pDC->LineTo(nRight - 1, nBottom - 1);
			pDC->LineTo(nRight - 1, nTop + 1);
		}
		else
		{
			CBrush br(m_crColor);
			CBrush *pOldBrush = pDC->SelectObject(&br);
			pDC->SelectObject(&m_penColorDark);
			pDC->Rectangle(rect);
			pDC->SelectObject(pOldBrush);
		}
	}	// if not indeterminate

	pDC->SelectObject(pOldPen);
}	// DrawVerticalBar

//-------------------------------------------------------------------
//
BOOL CMacProgressCtrl::OnEraseBkgnd(CDC* pDC) 
//
// Return Value:	Nonzero if it erases the background; otherwise 0.
//
// Parameters	:	pDC - Specifies the device-context object.
//
// Remarks		:	The framework calls this member function when the 
//						CWnd object background needs erasing (for example, 
//						when resized). It is called to prepare an invalidated 
//						region for painting.
//
{
		return TRUE;
}	// OnEraseBkgnd

//-------------------------------------------------------------------
//
void CMacProgressCtrl::GetColors()
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	Calculates the lighter and darker colors, as well as 
//						the shadow colors.
//
{
	m_crColorLight = LightenColor(m_crColor, 51);
	m_crColorLighter = LightenColor(m_crColorLight, 51);
	m_crColorLightest = LightenColor(m_crColorLighter, 51);
	m_crColorDark = DarkenColor(m_crColor, 51);
	m_crColorDarker = DarkenColor(m_crColorDark, 51);
	m_crDkShadow = ::GetSysColor(COLOR_3DDKSHADOW);
	m_crLiteShadow = ::GetSysColor(COLOR_3DSHADOW);

	// Get a color halfway between COLOR_3DDKSHADOW and COLOR_3DSHADOW
	BYTE byRed3DDkShadow = GetRValue(m_crDkShadow);
	BYTE byRed3DLiteShadow = GetRValue(m_crLiteShadow);
	BYTE byGreen3DDkShadow = GetGValue(m_crDkShadow);
	BYTE byGreen3DLiteShadow = GetGValue(m_crLiteShadow);
	BYTE byBlue3DDkShadow = GetBValue(m_crDkShadow);
	BYTE byBlue3DLiteShadow = GetBValue(m_crLiteShadow);

	m_crShadow = RGB(byRed3DLiteShadow + ((byRed3DDkShadow - byRed3DLiteShadow) >> 1),
						  byGreen3DLiteShadow + ((byGreen3DDkShadow - byGreen3DLiteShadow) >> 1),
						  byBlue3DLiteShadow + ((byBlue3DDkShadow - byBlue3DLiteShadow) >> 1));
}	// GetColors

//-------------------------------------------------------------------
//
void CMacProgressCtrl::SetColor(COLORREF crColor)
//
// Return Value:	None.
//
// Parameters	:	crColor - New color.
//
// Remarks		:	Sets the progress	bar control's color. The lighter
//						darker colors are recalculated, and the pens recreated.
//
{
	m_crColor = crColor;
	GetColors();
	CreatePens();
	RedrawWindow();
}	// SetColor

//-------------------------------------------------------------------
//
COLORREF CMacProgressCtrl::GetColor()
//
// Return Value:	The current color.
//
// Parameters	:	None.
//
// Remarks		:	Returns the progress bar control's current color.
//
{
	return m_crColor;
}	// GetColor

//-------------------------------------------------------------------
//
void CMacProgressCtrl::CreatePens()
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	Deletes the pen objects, if necessary, and creates them.
//
{
	DeletePens();

	m_penColorLight.CreatePen(PS_SOLID, 1, m_crColorLight);
	m_penColorLighter.CreatePen(PS_SOLID, 1, m_crColorLighter);
	m_penColor.CreatePen(PS_SOLID, 1, m_crColor);
	m_penColorDark.CreatePen(PS_SOLID, 1, m_crColorDark);
	m_penColorDarker.CreatePen(PS_SOLID, 1, m_crColorDarker);
	m_penDkShadow.CreatePen(PS_SOLID, 1, m_crDkShadow);
	m_penShadow.CreatePen(PS_SOLID, 1, m_crShadow);
	m_penLiteShadow.CreatePen(PS_SOLID, 1, m_crLiteShadow);
}	// CreatePens

//-------------------------------------------------------------------
//
void CMacProgressCtrl::DeletePens()
//
// Return Value:	None.
//
// Parameters	:	None.
//
// Remarks		:	Deletes the pen objects.
//
{
	if (m_penColorLight.m_hObject)
		m_penColorLight.DeleteObject();
	if (m_penColorLighter.m_hObject)
		m_penColorLighter.DeleteObject();
	if (m_penColor.m_hObject)
		m_penColor.DeleteObject();
	if (m_penColorDark.m_hObject)
		m_penColorDark.DeleteObject();
	if (m_penColorDarker.m_hObject)
		m_penColorDarker.DeleteObject();
	if (m_penDkShadow.m_hObject)
		m_penDkShadow.DeleteObject();
	if (m_penShadow.m_hObject)
		m_penShadow.DeleteObject();
	if (m_penLiteShadow.m_hObject)
		m_penLiteShadow.DeleteObject();
}	// DeletePens

//-------------------------------------------------------------------
//
void CMacProgressCtrl::SetIndeterminate(BOOL bIndeterminate)
//
// Return Value:	None.
//
// Parameters	:	bIndeterminate - Specifies the indeterminate state.
//
// Remarks		:	Sets the indeterminate flag.
//
{
	m_bIndeterminate = bIndeterminate;

	if (m_bIndeterminate)
	{
		CRect rect;
		GetClientRect(rect);
		m_nIndOffset = 0;

		RedrawWindow();
		SetTimer(IDT_INDETERMINATE, 25, nullptr);
	}
	else
	{
		KillTimer(IDT_INDETERMINATE);
		RedrawWindow();
	}
}	// SetIndeterminate

//-------------------------------------------------------------------
//
BOOL CMacProgressCtrl::GetIndeterminate()
//
// Return Value:	m_bIndeterminate.
//
// Parameters	:	None.
//
// Remarks		:	Returns m_bIndeterminate.
//
{
	return m_bIndeterminate;
}	// GetIndeterminate

//-------------------------------------------------------------------
//
void CMacProgressCtrl::OnTimer(UINT_PTR nIDEvent)
//
// Return Value:	None.
//
// Parameters	:	nIDEvent - Specifies the identifier of the timer.
//
// Remarks		:	The framework calls this member function after each 
//						interval specified in the SetTimer member function used 
//						to install a timer.
//
{
	// Increment the indeterminate bar offset and redraw the window.
	if (nIDEvent == IDT_INDETERMINATE)
	{
		KillTimer(nIDEvent);

		if (++m_nIndOffset > IND_BAND_WIDTH - 1)
			m_nIndOffset = 0;
		RedrawWindow();

		SetTimer(IDT_INDETERMINATE, 25, nullptr);
	}
}	// OnTimer

// ===== END Launcher/MacProgressCtrl.cpp =====

// ===== BEGIN Launcher/MacProgressCtrl.h =====
#line 1 "Launcher/MacProgressCtrl.h"
﻿#if !defined(AFX_MACPROGRESSCTRL_H__603BBF44_B19C_11D3_90FA_0020AFBC499D__INCLUDED_)
#define AFX_MACPROGRESSCTRL_H__603BBF44_B19C_11D3_90FA_0020AFBC499D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MacProgressCtrl.h : header file
//
//	CMacProgressCtrl class, version 1.0
//
//	Copyright (c) 1999 Paul M. Meidinger (pmmeidinger@yahoo.com)
//
// Feel free to modifiy and/or distribute this file, but
// do not remove this header.
//
// I would appreciate a notification of any bugs discovered or 
// improvements that could be made.
//
// This file is provided "as is" with no expressed or implied warranty.
//
//	History:
//		PMM	12/21/1999		Initial implementation.		

/////////////////////////////////////////////////////////////////////////////
// CMacProgressCtrl window

class CMacProgressCtrl : public CProgressCtrl
{
// Construction
public:
	CMacProgressCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMacProgressCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL GetIndeterminate();
	void SetIndeterminate(BOOL bIndeterminate = TRUE);
	COLORREF GetColor();
	void SetColor(COLORREF crColor);
	virtual ~CMacProgressCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMacProgressCtrl)
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
private:
	int m_nIndOffset;
	BOOL m_bIndeterminate;
	void DrawVerticalBar(CDC *pDC, const CRect rect);
	void DrawHorizontalBar(CDC *pDC, const CRect rect);
	void DeletePens();
	void CreatePens();
	CPen m_penColor;
	CPen m_penColorLight;
	CPen m_penColorLighter;
	CPen m_penColorDark;
	CPen m_penColorDarker;
	CPen m_penDkShadow;
	CPen m_penShadow;
	CPen m_penLiteShadow;
	void GetColors();
	COLORREF m_crColor;
	COLORREF m_crColorLight;
	COLORREF m_crColorLighter;
	COLORREF m_crColorLightest;
	COLORREF m_crColorDark;
	COLORREF m_crColorDarker;
	COLORREF m_crDkShadow;
	COLORREF m_crShadow;
	COLORREF m_crLiteShadow;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MACPROGRESSCTRL_H__603BBF44_B19C_11D3_90FA_0020AFBC499D__INCLUDED_)

// ===== END Launcher/MacProgressCtrl.h =====

// ===== BEGIN Launcher/PacketDef.h =====
#line 1 "Launcher/PacketDef.h"
﻿#ifndef __PACKET_DEF_H_
#define __PACKET_DEF_H_

///////////////////////////////////////////////////////////////
// Packet Define 
///////////////////////////////////////////////////////////////
#define VERSION_REQ				0x01	// Send 
#define DOWNLOAD_INFO_REQ		0x02	// Send - s1(현재버전) | Recv FTP
#define LOGIN_REQ				0x03	// Send - s1(ID길이) str1(ID문자열:20바이트이하) s1(PW길이) str1(PW문자열:12바이트이하) | Recv - b1(0:실패 1:성공 2:ID없음 3:PW틀림 4:서버점검중)
#define MGAME_LOGIN_REQ			0x04	// !!! LOGIN_REQ !!! 와 동일
#define SERVER_LIST				0x05	// Recv - b1(ServerCount) loop(	s1(IP길이), str1(IP문자열), s1(서버이름길이), str1(서버이름문자열), s1(서버접속인원) )
///////////////////////////////////////////////////////////////

#endif // end of #ifndef __PACKET_DEF_H_

// ===== END Launcher/PacketDef.h =====

// ===== BEGIN Launcher/ServerMesh.cpp =====
#line 1 "Launcher/ServerMesh.cpp"
﻿// ServerMesh.cpp: implementation of the CServerMesh class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "ServerMesh.h"
#include "N3Terrain.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static const int SGRID_SIZE = 64;
static const int SMAP_SIZE  = 4096;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServerMesh::CServerMesh()
{

}

CServerMesh::~CServerMesh()
{

}



void CServerMesh::Tick(CN3Terrain* pTerrain, const __Vector3& vPosPlayer)
{
	__Vector3 pos = vPosPlayer;
	int ixposL, ixposR, izposL, izposR, ixpos, izpos;
	float fHeightLB, fHeightRB, fHeightTop, fHeightBottom;	

	ixpos   = ((int)pos.x)/SGRID_SIZE; 
	ixpos *= SGRID_SIZE;
	izpos   = ((int)pos.z)/SGRID_SIZE; 
	izpos *= SGRID_SIZE;

	D3DCOLOR color = D3DCOLOR_RGBA(50,25,25,0);

	// 제일 왼쪽..	
	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos - SGRID_SIZE;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 0 );	

	// 왼쪽 두번째..

	ixposL = ixpos;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 6 );	

	// 왼쪽 세번째..

	ixposL = ixpos + SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 12 );	

	// 왼쪽에서 끝..

	ixposL = ixpos + SGRID_SIZE*2;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 18 );	

	// 밑에서 첫번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos - SGRID_SIZE;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 24 );	

	// 밑에서 두번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 30 );	
	
	// 밑에서 세번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos + SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 36 );	

	// 밑에서 끝번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos + SGRID_SIZE*2;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 42);
}


void CServerMesh::AutoConcMesh(D3DCOLOR color, float left, float right, float bottom, float top, float low, float high , int iStart)
{
	// left, right  : x
	// bottom, top  : z
	// low, high	: y

	switch(iStart)
	{
		case 0:
		case 6:
		case 12:
		case 18:
			m_vSMesh[iStart].Set( left, low, bottom);
			m_vSMesh[iStart+1].Set( left, high, bottom);
			m_vSMesh[iStart+2].Set( left, low, top);
			m_vSMesh[iStart+3].Set( left, high, top);
			m_vSMesh[iStart+4].Set( left, low, top);
			m_vSMesh[iStart+5].Set( left, high, bottom);
			break;

		case 24:
		case 30:
		case 36:
		case 42:
			m_vSMesh[iStart].Set( left, low, top);
			m_vSMesh[iStart+1].Set( left, high, top);
			m_vSMesh[iStart+2].Set( right, low, top);
			m_vSMesh[iStart+3].Set( right, high, top);
			m_vSMesh[iStart+4].Set( right, low, top);
			m_vSMesh[iStart+5].Set( left, high, top);
			break;
	}
}



void CServerMesh::Render()
{
    __Matrix44 mtxWorld;
	mtxWorld.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, &mtxWorld);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	
	DWORD dwFillPrev;
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwFillPrev);

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetTexture(0, NULL);

	s_lpD3DDev->SetVertexShader( D3DFVF_XYZ );
	s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 16, &m_vSMesh, sizeof(__Vector3));

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwFillPrev);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
/*
	__Matrix44 WorldMtx;
	WorldMtx.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, &WorldMtx);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	DWORD dwFillPrev;
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwFillPrev);
	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	DWORD dwUseLighting, dwAlpha, dwDestAlpha, dwSrcAlpha, dwUseColorVertex, dwDMS;
	
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,			D3DTOP_DISABLE);

    s_lpD3DDev->GetRenderState( D3DRS_LIGHTING,					&dwUseLighting );      
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE,			&dwAlpha);
	s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND,				&dwDestAlpha);
	s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND,					&dwSrcAlpha);
	s_lpD3DDev->GetRenderState( D3DRS_COLORVERTEX,				&dwUseColorVertex);
	s_lpD3DDev->GetRenderState( D3DRS_DIFFUSEMATERIALSOURCE,	&dwDMS);

	s_lpD3DDev->SetTexture( 0, NULL );		

    s_lpD3DDev->SetRenderState( D3DRS_LIGHTING,					FALSE );      
	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE,			FALSE);
//	s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,				D3DBLEND_ONE);
//	s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,					D3DBLEND_ONE);
	s_lpD3DDev->SetRenderState( D3DRS_COLORVERTEX,				TRUE);
	s_lpD3DDev->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE,	D3DMCS_COLOR1);

	s_lpD3DDev->SetVertexShader( FVF_XYZCOLOR );
	s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 16, &m_vSMesh, sizeof(__VertexXyzColor));

    s_lpD3DDev->SetRenderState( D3DRS_LIGHTING,					dwUseLighting );      
	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE,			dwAlpha);
	s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,				dwDestAlpha);
	s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,					dwSrcAlpha);
	s_lpD3DDev->SetRenderState( D3DRS_COLORVERTEX,				dwUseColorVertex);
	s_lpD3DDev->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE,	dwDMS);
	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwFillPrev);*/
}

// ===== END Launcher/ServerMesh.cpp =====

// ===== BEGIN Launcher/StdAfx.cpp =====
#line 1 "Launcher/StdAfx.cpp"
﻿// stdafx.cpp : source file that includes just the standard includes
//	Launcher.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"




// ===== END Launcher/StdAfx.cpp =====

// ===== BEGIN Launcher/StdAfx.h =====
#line 1 "Launcher/StdAfx.h"
﻿// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__ACA18BF8_042E_432F_B824_E89C2148F69C__INCLUDED_)
#define AFX_STDAFX_H__ACA18BF8_042E_432F_B824_E89C2148F69C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxsock.h>		// MFC socket extensions
#include <afxtempl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ACA18BF8_042E_432F_B824_E89C2148F69C__INCLUDED_)

// ===== END Launcher/StdAfx.h =====

// ===== BEGIN Launcher/resource.h =====
#line 1 "Launcher/resource.h"
﻿//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Launcher.rc
//
#define IDD_LAUNCHER_DIALOG             102
#define IDP_SOCKETS_INIT_FAILED         103
#define IDS_IP                          104
#define IDS_PRODUCT                     105
#define IDS_DNS                         106
#define IDS_JOIN_URL                    107
#define IDS_INFO_VERSION_CHECK          108
#define IDS_INFO_EXTRACTING             109
#define IDS_ERR_REGISTRY_OPEN           110
#define IDS_ERR_REGISTRY_READ_VERSION   111
#define IDS_ERR_REGISTRY_READ_PATH      112
#define IDS_ERR_REGISTRY_READ_EXE       113
#define IDS_ERR_REGISTRY_READ_SERVICE   114
#define IDS_FMT_FAILED_CONNECT_LOGIN_SERVER 115
#define IDS_ERR_INVALID_SERVER_COUNT    116
#define IDS_ERR_INVALID_VERSION         117
#define IDS_ERR_INVALID_DOWNLOAD_FILE_COUNT 118
#define IDS_ERR_INIT_INTERNET           119
#define IDS_ERR_CONNECT_FTP             120
#define IDS_ERR_PATCH                   121
#define IDS_ERR_DOWNLOAD_PATCH_FILE_AND_RETRY 122
#define IDS_ERR_DOWNLOAD_PATCH_FILE     123
#define IDR_MAINFRAME                   128
#define IDB_EDIT_ID                     130
#define IDB_BTN_CANCEL                  131
#define IDB_BTN_CONNECT                 132
#define IDB_BTN_EXIT                    133
#define IDB_BTN_JOIN                    134
#define IDB_BKG                         135
#define IDB_EDIT_PW                     136
#define IDI_ICON1                       138
#define IDB_BITMAP1                     139
#define IDC_PROGRESS                    1000
#define IDC_STATUS                      1001
#define IDC_LIST_SERVER                 1002
#define IDC_E_ID                        1003
#define IDC_E_PW                        1004
#define IDC_B_CONNECT                   1005
#define IDC_B_CONNECT_CANCEL            1006
#define IDC_STATIC_PICTURE              1007
#define IDC_B_JOIN                      1008
#define IDC_B_EXIT                      1009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif

// ===== END Launcher/resource.h =====

// ===== BEGIN N3Base/BitMapFile.cpp =====
#line 1 "N3Base/BitMapFile.cpp"
﻿// BitMapFile.cpp: implementation of the CBitMapFile class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "BitMapFile.h"

#include <FileIO/FileReader.h>
#include <FileIO/FileWriter.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CBitMapFile::CBitMapFile()
{
	m_pPixels = nullptr;
	Release();
}

CBitMapFile::~CBitMapFile()
{
	Release();
}

void CBitMapFile::Release()
{
	memset(&m_bmfHeader, 0, sizeof(m_bmfHeader));
	memset(&m_bmInfoHeader, 0, sizeof(m_bmInfoHeader));
	::GlobalFree(m_pPixels); // 실제 픽셀 데이터
	m_pPixels = nullptr;
}

bool CBitMapFile::Load(File& file)
{
	Release(); // 일단 다 해제하고..

	// 파일 헤더 읽기
	file.Read(&m_bmfHeader, sizeof(m_bmfHeader));

	// bmp 파일임을 나타내는 "BM"마커 확인
	if (m_bmfHeader.bfType != 0x4D42)
	{
		MessageBox(::GetActiveWindow(), "원본 파일이 bitmap파일이 아닙니다.", "error", MB_OK);
		return false;
	}

	// BITMAPINFOHEADER 얻기
	file.Read(&m_bmInfoHeader, sizeof(m_bmInfoHeader));

	// 픽셀당 비트 수 확인
	uint16_t wBitCount = m_bmInfoHeader.biBitCount;
	if (24 != wBitCount || m_bmInfoHeader.biWidth <= 0 || m_bmInfoHeader.biHeight <= 0)		// 24비트 bmp가 아니면 return해 버린다.
	{
		MessageBox(::GetActiveWindow(), "원본 bitmap이 너비, 높이에 이상이 있거나 24bit파일이 아닙니다.", "error", MB_OK);
		return false;
	}

	// 실제 이미지의 메모리상에 잡힌 가로 길이 (24bit)
	int iRealWidth = ((int)((m_bmInfoHeader.biWidth*3 + 3)/4))*4;	

	// 새로 만들 이미지 메모리 할당
	int iDIBSize = iRealWidth * m_bmInfoHeader.biHeight;

	if ((m_pPixels = ::GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, iDIBSize )) == nullptr )
	{
		MessageBox(::GetActiveWindow(), "메모리를 할당하지 못했습니다.", "error", MB_OK);
		return false;
	}

	// 픽셀을 읽는다..
	for(int y = m_bmInfoHeader.biHeight - 1; y >= 0; y--) // 비트맵은 위아래가 거꾸로 있다..
		file.Read((uint8_t*)m_pPixels + y * iRealWidth, iRealWidth);

	return true;
}

void* CBitMapFile::Pixels(int x, int y)
{
	if(24 != m_bmInfoHeader.biBitCount) return nullptr;

	int nPitch = this->Pitch();
	int nPixelSize = 3;
	return (char*)m_pPixels + y * nPitch + x * nPixelSize;
}

bool CBitMapFile::Save(File& file)
{
	// 파일 헤더 쓰기
	file.Write(&m_bmfHeader, sizeof(m_bmfHeader));

	// BITMAPINFOHEADER 쓰기
	file.Write(&m_bmInfoHeader, sizeof(m_bmInfoHeader));

	// 실제 이미지의 메모리상에 잡힌 가로 길이 (24bit)
	int iRealWidth = this->Pitch();

	// 픽셀을 저장한다...
	for(int y = m_bmInfoHeader.biHeight - 1; y >= 0; y--) // 비트맵은 위아래가 거꾸로 있다..
		file.Write((uint8_t*)m_pPixels + y * iRealWidth, iRealWidth);

	return true;
}

bool CBitMapFile::SaveRectToFile(const std::string& szFN, RECT rc)
{
	if (szFN.empty())
		return false;

	if (rc.right <= rc.left)
		return false;

	if (rc.bottom <= rc.top)
		return false;

	if (rc.left < 0)
		rc.left = 0;

	if (rc.top < 0)
		rc.top = 0;

	if (rc.right > m_bmInfoHeader.biWidth)
		rc.right = m_bmInfoHeader.biWidth;

	if (rc.bottom > m_bmInfoHeader.biHeight)
		rc.bottom = m_bmInfoHeader.biHeight;

	int nWidth = rc.right - rc.left;
	int nHeight = rc.bottom - rc.top;

	if (nWidth <= 0 || nHeight <= 0)
	{
		MessageBox(::GetActiveWindow(), "가로 세로가 0이하인 bitmap으로 저장할수 없습니다.", "error", MB_OK);
		return false;
	}

	FileWriter file;

	// 쓰기 모드로 파일 열기
	if (!file.Create(szFN))
	{
		MessageBox(::GetActiveWindow(), "원본 bitmap을 열 수 없습니다.", "error", MB_OK);
		return false;
	}

	// 실제 이미지의 메모리상에 잡힌 가로 길이 (24bit)
	int iRealWidthDest = ((int) ((nWidth * 3 + 3) / 4)) * 4;
	int iDestDIBSize = sizeof(BITMAPINFOHEADER) + iRealWidthDest * nHeight;

	// 새로 만들 이미지 file header 정보 채우기
	BITMAPFILEHEADER bmfHeaderDest = m_bmfHeader;
	bmfHeaderDest.bfType = 0x4D42; // "BM"
	bmfHeaderDest.bfSize = sizeof(bmfHeaderDest) + iDestDIBSize;
	bmfHeaderDest.bfOffBits = sizeof(bmfHeaderDest) + sizeof(BITMAPINFOHEADER);

	// 새로 만들 이미지 bitmap info header 정보 채우기
	BITMAPINFOHEADER bmInfoHeaderDest = m_bmInfoHeader;
	bmInfoHeaderDest.biSize = sizeof(bmInfoHeaderDest);
	bmInfoHeaderDest.biWidth = nWidth;
	bmInfoHeaderDest.biHeight = nHeight;
	bmInfoHeaderDest.biPlanes = 1;
	bmInfoHeaderDest.biSizeImage = iRealWidthDest * nHeight;

	// 파일 헤더 쓰기
	file.Write(&bmfHeaderDest, sizeof(bmfHeaderDest));

	// BITMAPINFOHEADER 쓰기
	file.Write(&bmInfoHeaderDest, sizeof(bmInfoHeaderDest));

	// 픽셀을 저장한다...
	int iRealWidth = ((int) ((m_bmInfoHeader.biWidth * 3 + 3) / 4)) * 4;
	for (int y = rc.bottom - 1; y >= rc.top; y--)
	{
		void* pPixelDest = ((uint8_t*) m_pPixels) + iRealWidth * y + (rc.left * 3);
		file.Write(pPixelDest, iRealWidthDest); // 라인 쓰기..
	}

	return true;
}

bool CBitMapFile::LoadFromFile(const char* pszFN)
{
	if (pszFN == nullptr || lstrlen(pszFN) <= 0)
		return false;

	FileReader file;
	if (!file.OpenExisting(pszFN))
		return false;

	return Load(file);
}

bool CBitMapFile::SaveToFile(const char* pszFN)
{
	if (pszFN == nullptr || lstrlen(pszFN) <= 0)
		return false;

	FileWriter file;
	if (!file.Create(pszFN))
		return false;

	return Save(file);
}

bool CBitMapFile::Create(int nWidth, int nHeight, int nBPP)
{
	if(nWidth <= 0 || nHeight <= 0) return false;
	this->Release(); // 일단 다 해제하고..

	if(24 != nBPP) return FALSE;

	int iRealWidth = ((nWidth*3 + 3)/4)*4; // 실제 이미지의 메모리상에 잡힌 가로 길이 (24bit)
	int iDIBSize = iRealWidth * nHeight; // 새로 만들 이미지 메모리 할당

	if ((m_pPixels = ::GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, iDIBSize )) == nullptr )
	{
		MessageBox(::GetActiveWindow(), "메모리를 할당하지 못했습니다.", "error", MB_OK);
		return false;
	}

	memset(m_pPixels, 0, iDIBSize);

	// 새로 만들 이미지 file header 정보 채우기
	m_bmfHeader.bfType = 0x4D42; // "BM"
	m_bmfHeader.bfSize = sizeof(m_bmfHeader) + iDIBSize;
	m_bmfHeader.bfOffBits = sizeof(m_bmfHeader) + sizeof(BITMAPINFOHEADER);

	// 새로 만들 이미지 bitmap info header 정보 채우기
	m_bmInfoHeader.biSize = sizeof(m_bmInfoHeader);
	m_bmInfoHeader.biWidth = nWidth;
	m_bmInfoHeader.biHeight = nHeight;
	m_bmInfoHeader.biBitCount = nBPP;
	m_bmInfoHeader.biPlanes = 1;
	m_bmInfoHeader.biSizeImage = iRealWidth * nHeight;

	return true;
}

// ===== END N3Base/BitMapFile.cpp =====

// ===== BEGIN N3Base/BitMapFile.h =====
#line 1 "N3Base/BitMapFile.h"
﻿// BitMapFile.h: interface for the CBitMapFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BITMAPFILE_H__F2C24227_F5AE_43B2_8616_2F2E057B59B8__INCLUDED_)
#define AFX_BITMAPFILE_H__F2C24227_F5AE_43B2_8616_2F2E057B59B8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <Windows.h>
#include <string>

class File;
class CBitMapFile
{
protected:
	BITMAPFILEHEADER m_bmfHeader;
	BITMAPINFOHEADER m_bmInfoHeader;

public:
	void* m_pPixels; // 실제 픽셀 데이터
	int Pitch() { return ((int)((m_bmInfoHeader.biWidth*3 + 3)/4))*4; } // 비트맵의 실제 너비(byte 단위)..
	bool Create(int nWidth, int nHeight, int nBPP = 24);
	bool SaveRectToFile(const std::string& szFN, RECT rc);
	void* Pixels(int x = 0, int y = 0);
	BITMAPINFOHEADER * GetBitmapInfoHeader() { return &m_bmInfoHeader;}
	BITMAPFILEHEADER * GetBitmapFileHeader() { return &m_bmfHeader;}
	bool Load(File& file);
	bool Save(File& file);
	bool LoadFromFile(const char* pszFN);
	bool SaveToFile(const char* pszFN);

	int Width() { return m_bmInfoHeader.biWidth; }
	int Height() { return m_bmInfoHeader.biHeight; }
	
	void Release();
	CBitMapFile();
	virtual ~CBitMapFile();

};

#endif // !defined(AFX_BITMAPFILE_H__F2C24227_F5AE_43B2_8616_2F2E057B59B8__INCLUDED_)

// ===== END N3Base/BitMapFile.h =====

// ===== BEGIN N3Base/DFont.cpp =====
#line 1 "N3Base/DFont.cpp"
﻿// DFont.cpp: implementation of the CDFont class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "DFont.h"

const int MAX_NUM_VERTICES = 50*6;
const float Z_DEFAULT = 0.9f;
const float RHW_DEFAULT = 1.0f;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
HDC CDFont::s_hDC = nullptr;
int CDFont::s_iInstanceCount = 0;
HFONT CDFont::s_hFontOld = nullptr;

CDFont::CDFont(const std::string& szFontName, uint32_t dwHeight, uint32_t dwFlags)
{
	if(0 == s_iInstanceCount)
	{
		s_hDC = CreateCompatibleDC(nullptr);
		// 임시 폰트를 만들고 s_hFontOld를 얻는다.
		HFONT hFont			= CreateFont( 0, 0, 0, 0, 0, FALSE,
							  FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
							  CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
							  VARIABLE_PITCH, "굴림");
		if(hFont)
		{
			s_hFontOld = (HFONT)(SelectObject( s_hDC, hFont ));
			SelectObject( s_hDC, s_hFontOld );
			DeleteObject(hFont);
		}
	}
	s_iInstanceCount++;

	__ASSERT(!szFontName.empty(), "??");

	m_szFontName		= szFontName;
    m_dwFontHeight		= dwHeight;
    m_dwFontFlags       = dwFlags;

    m_pd3dDevice		= nullptr;
    m_pTexture			= nullptr;
    m_pVB				= nullptr;

	m_iPrimitiveCount = 0;
	m_PrevLeftTop.x = m_PrevLeftTop.y = 0;

	m_hFont = nullptr;
	m_dwFontColor = 0xffffffff;
	m_Size.cx = 0; m_Size.cy = 0;
	m_Is2D = (dwFlags & D3DFONT_3D) ? FALSE : TRUE;
}

CDFont::~CDFont()
{
    InvalidateDeviceObjects();
    DeleteDeviceObjects();

	s_iInstanceCount--;
	if(s_iInstanceCount <= 0)
	{
		if (s_hFontOld) SelectObject(s_hDC, s_hFontOld);
		DeleteDC(s_hDC);
		s_hDC = nullptr;
	}
}

HRESULT CDFont::SetFont(const std::string& szFontName, uint32_t dwHeight, uint32_t dwFlags)
{
	__ASSERT(!szFontName.empty(), "");
	if(nullptr == s_hDC)
	{
		__ASSERT(0, "NULL DC Handle");
		return E_FAIL;
	}

	m_szFontName = szFontName;
    m_dwFontHeight         = dwHeight;
    m_dwFontFlags          = dwFlags;

	if (m_hFont)
	{
		if(s_hFontOld) SelectObject(s_hDC, s_hFontOld);
		DeleteObject(m_hFont);
		m_hFont = nullptr;
	}

    // Create a font.  By specifying ANTIALIASED_QUALITY, we might get an
    // antialiased font, but this is not guaranteed.
	INT nHeight    = -MulDiv( m_dwFontHeight, (INT)(GetDeviceCaps(s_hDC, LOGPIXELSY) * m_fTextScale), 72 );
	uint32_t dwBold	= (m_dwFontFlags&D3DFONT_BOLD)   ? FW_BOLD : FW_NORMAL;
	uint32_t dwItalic	= (m_dwFontFlags&D3DFONT_ITALIC) ? TRUE    : FALSE;
    m_hFont			= CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                          VARIABLE_PITCH, m_szFontName.c_str() );
    if( nullptr== m_hFont )
	{
		__ASSERT(0, "NULL Font Handle");
		return E_FAIL;
	}
	return S_OK;
}

HRESULT CDFont::InitDeviceObjects( LPDIRECT3DDEVICE9 pd3dDevice )
{
	// Keep a local copy of the device
	m_pd3dDevice = pd3dDevice;
	m_fTextScale = 1.0f; // Draw fonts into texture without scaling

	return S_OK;
}

HRESULT CDFont::RestoreDeviceObjects()
{
    HRESULT hr;

	m_iPrimitiveCount = 0;

//	__ASSERT(nullptr == s_hDC && nullptr == m_hFont, "??");
//	m_hDC = CreateCompatibleDC(nullptr);
	__ASSERT(nullptr == m_hFont, "??");

	if( nullptr==s_hDC )
	{
		__ASSERT(0, "Can't Create DC");
		return E_FAIL;
	}
	SetMapMode( s_hDC, MM_TEXT );

    // Create a font.  By specifying ANTIALIASED_QUALITY, we might get an
    // antialiased font, but this is not guaranteed.
    INT nHeight    = -MulDiv( m_dwFontHeight, 
        (INT)(GetDeviceCaps(s_hDC, LOGPIXELSY) * m_fTextScale), 72 );
	uint32_t dwBold	= (m_dwFontFlags&D3DFONT_BOLD)   ? FW_BOLD : FW_NORMAL;
	uint32_t dwItalic	= (m_dwFontFlags&D3DFONT_ITALIC) ? TRUE    : FALSE;
    m_hFont			= CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                          VARIABLE_PITCH, m_szFontName.c_str() );
    if( nullptr == m_hFont ) return E_FAIL;

    // Create vertex buffer for the letters
	__ASSERT(m_pVB == nullptr, "??");
	int iVBSize = 0;
	uint32_t dwFVF = 0;
	if (m_Is2D)
	{
		iVBSize = MAX_NUM_VERTICES*sizeof(__VertexTransformed);
		dwFVF = FVF_TRANSFORMED;
	}
	else
	{
		iVBSize = MAX_NUM_VERTICES*sizeof(__VertexXyzColorT1);
		dwFVF = FVF_XYZCOLORT1;
	}

//    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( iVBSize,
//                                                     D3DUSAGE_WRITEONLY, 0,
//                                                      D3DPOOL_MANAGED, &m_pVB ) ) )
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( iVBSize, 0, dwFVF, D3DPOOL_MANAGED, &m_pVB, nullptr ) ) )
    {
        return hr;
    }

    return S_OK;
}

HRESULT CDFont::InvalidateDeviceObjects()
{
    if (m_pVB) {m_pVB->Release(); m_pVB = nullptr;}

	if (m_hFont)
	{
		if(s_hDC && s_hFontOld) SelectObject(s_hDC, s_hFontOld);
		DeleteObject(m_hFont);
		m_hFont = nullptr;
	}
	return S_OK;
}

HRESULT CDFont::DeleteDeviceObjects()
{
	if (m_pTexture) {m_pTexture->Release(); m_pTexture = nullptr;}
	m_pd3dDevice = nullptr;

	return S_OK;
}

HRESULT CDFont::SetText(const std::string& szText, uint32_t dwFlags)
{
	if(nullptr == s_hDC || nullptr == m_hFont) return E_FAIL;

	if (szText.empty())
	{
		m_iPrimitiveCount = 0;
		if (m_pTexture) {m_pTexture->Release(); m_pTexture = nullptr;}
		return S_OK;
	}

	int iStrLen = static_cast<int>(szText.size());

	HRESULT hr;
	// \n을 빼고 한줄로 만들어서 글자 길이 계산하기
	int iCount=0;
	int iTempCount = 0;
	SIZE size;

	std::string szTemp(iStrLen, '?');
	while(iCount<iStrLen)
	{
		if ('\n' == szText[iCount])		// \n
		{
			++iCount;
		}
		else if (0x80 & szText[iCount])	// 2BYTE 문자
		{
			if((iCount + 2) > iStrLen) // 이상한 문자열이다..
			{
//				__ASSERT(0, "이상한 문자열이다.!!!");
				break;
			}
			else
			{
				memcpy(&(szTemp[iTempCount]), &(szText[iCount]), 2);
				iTempCount += 2; iCount += 2;
			}
		}
		else								// 1BYTE 문자
		{
			memcpy(&(szTemp[iTempCount]), &(szText[iCount]), 1);
			++iTempCount; ++iCount;
		}
		__ASSERT(iCount<=iStrLen, "??");	// 이상한 문자가 들어왔을 경우
	}

//	szTemp[iTempCount] = 0x00;

	// 텍스쳐 사이즈 결정하기
	SelectObject(s_hDC, m_hFont);
	GetTextExtentPoint32(s_hDC, szTemp.c_str(), static_cast<int>(szTemp.size()), &size);
	szTemp = "";

	if(size.cx <= 0 || size.cy <= 0)
	{
		__ASSERT(0, "Invalid Text Size - ?????");
		return E_FAIL;
	}
	int	iExtent = size.cx*size.cy;

	SIZE size2;	// 한글 반글자의 크기..
	GetTextExtentPoint32( s_hDC, "진", lstrlen("진"), &size2 );
	size2.cx = ((size2.cx/2) + (size2.cx%2));

	int iTexSizes[7] = {32, 64, 128, 256, 512, 1024, 2048};
	for (int i=0; i<7; ++i)
	{
		if (iExtent <= (iTexSizes[i] - size2.cx-size2.cy-1)*iTexSizes[i])
		{
			m_dwTexWidth = m_dwTexHeight = iTexSizes[i];
			break;
		}
	}

    // Establish the font and texture size
    m_fTextScale  = 1.0f; // Draw fonts into texture without scaling

    // If requested texture is too big, use a smaller texture and smaller font,
    // and scale up when rendering.
    D3DCAPS9 d3dCaps;
    m_pd3dDevice->GetDeviceCaps( &d3dCaps );

    if( m_dwTexWidth > d3dCaps.MaxTextureWidth )
    {
        m_fTextScale = (float)d3dCaps.MaxTextureWidth / (float)m_dwTexWidth;
        m_dwTexWidth = m_dwTexHeight = d3dCaps.MaxTextureWidth;
    }

	// 기존 텍스쳐 크기가 새로 만들 텍스쳐 크기와 다를 경우 다시 만든다.
	if (m_pTexture)
	{
		D3DSURFACE_DESC sd;
		ZeroMemory( &sd,  sizeof(sd) );
		m_pTexture->GetLevelDesc(0, &sd);
		if (sd.Width != m_dwTexWidth)
		{
			m_pTexture->Release();
			m_pTexture = nullptr;
		}
	}

    // Create a new texture for the font
	if (nullptr == m_pTexture)
	{
		int iMipMapCount = 1;
		if( dwFlags & D3DFONT_FILTERED ) iMipMapCount = 0; // 필터링 텍스트는 밉맵을 만든다..

		hr = m_pd3dDevice->CreateTexture( m_dwTexWidth, m_dwTexHeight, iMipMapCount,
										0, D3DFMT_A4R4G4B4,
										D3DPOOL_MANAGED, &m_pTexture, nullptr );
		if( FAILED(hr) )
			return hr;
	}

    // Prepare to create a bitmap
    uint32_t*      pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader,  sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)m_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)m_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a DC and a bitmap for the font
    HBITMAP hbmBitmap = CreateDIBSection( s_hDC, &bmi, DIB_RGB_COLORS, (VOID**)&pBitmapBits, nullptr, 0 );

	if (nullptr == hbmBitmap)
	{
		__ASSERT(0, "CreateDIBSection 실패");
		if (m_pTexture) {m_pTexture->Release(); m_pTexture = nullptr;}
		return E_FAIL;
	}

    HGDIOBJ hObjPrev = ::SelectObject( s_hDC, hbmBitmap );

    // Set text properties
    SetTextColor( s_hDC, RGB(255,255,255) );
    SetBkColor(   s_hDC, RGB(0,0,0) );
    SetTextAlign( s_hDC, TA_TOP );

    // Loop through all printable character and output them to the bitmap..
    // Meanwhile, keep track of the corresponding tex coords for each character.

// 글씨 찍기 및 글씨 찍을 판떼기 만들기
	if (m_Is2D)
	{
		Make2DVertex(size.cy, szText);
	}
	else
	{
		Make3DVertex(size.cy, szText, dwFlags);
	}

    // Lock the surface and write the alpha values for the set pixels
    D3DLOCKED_RECT d3dlr;
    m_pTexture->LockRect( 0, &d3dlr, 0, 0 );
    uint16_t* pDst16 = (uint16_t*)d3dlr.pBits;
    uint8_t bAlpha; // 4-bit measure of pixel intensity

	uint32_t x, y;
    for( y=0; y < m_dwTexHeight; y++ )
    {
        for( x=0; x < m_dwTexWidth; x++ )
        {
            bAlpha = (uint8_t)((pBitmapBits[m_dwTexWidth*y + x] & 0xff) >> 4);
            if (bAlpha > 0)
            {
                *pDst16++ = (bAlpha << 12) | 0x0fff;
            }
            else
            {
                *pDst16++ = 0x0000;
            }
        }
    }

    // Done updating texture, so clean up used objects
    m_pTexture->UnlockRect(0);
	
	::SelectObject(s_hDC, hObjPrev); // 반드시 전의걸 선택해야..
	DeleteObject( hbmBitmap ); // 제대로 지워진다..

	////////////////////////////////////////////////////////////
	// 필터링 텍스처는... MipMap 만든다..
	if( dwFlags & D3DFONT_FILTERED ) 
	{
		int iMMC = m_pTexture->GetLevelCount();
		for(int i = 1; i < iMMC; i++)
		{
			LPDIRECT3DSURFACE9 lpSurfSrc = nullptr;
			LPDIRECT3DSURFACE9 lpSurfDest = nullptr;
			m_pTexture->GetSurfaceLevel(i-1, &lpSurfSrc);
			m_pTexture->GetSurfaceLevel(i, &lpSurfDest);

			if(lpSurfSrc && lpSurfDest)
			{
				::D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, D3DX_FILTER_TRIANGLE, 0); // 서피스 복사
			}

			if(lpSurfSrc) lpSurfSrc->Release();
			if(lpSurfDest) lpSurfDest->Release();
		}
	}
	// 필터링 텍스처는... MipMap 만든다..
	////////////////////////////////////////////////////////////

	return S_OK;

}

void CDFont::Make2DVertex(const int iFontHeight, const std::string& szText)
{
	if (m_pVB == nullptr
		|| s_hDC == nullptr
		|| m_hFont == nullptr)
	{
		__ASSERT(0, "NULL Vertex Buffer or DC or Font Handle ");
		return;
	}

	if (szText.empty())
		return;

	int iStrLen = static_cast<int>(szText.size());

	// lock vertex buffer
	__VertexTransformed* pVertices = nullptr;
	uint32_t         dwNumTriangles = 0;
	if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
		return;

	uint32_t sx = 0;    // start x y
	uint32_t x = 0;    uint32_t y = 0;
	float vtx_sx = 0;    float vtx_sy = 0;		//	vertex start x y 
	int iCount = 0; int iTempCount = 0;

	char	szTempChar[3] = "";
	uint32_t dwColor = 0xffffffff;			// 폰트의 색
	m_dwFontColor = 0xffffffff;
	SIZE size;

	float fMaxX = 0.0f, fMaxY = 0.0f;	// 글씨가 찍히는 범위의 최대 최소값을 조사하기 위해서.

	while(iCount<iStrLen)
	{
		if ('\n' == szText[iCount])		// \n
		{
			++iCount;

			// vertex 만들기
			if (sx != x)
			{
				FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
				FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
				FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
				FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

				FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
				FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

				__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.
				if (dwNumTriangles+2 >= MAX_NUM_VERTICES) break;

				FLOAT fLeft = vtx_sx+0-0.5f;	FLOAT fRight  = vtx_sx+w-0.5f;
				FLOAT fTop  = vtx_sy+0-0.5f;	FLOAT fBottom = vtx_sy+h-0.5f;
				pVertices->Set(fLeft , fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty2 );	++pVertices;
				pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;
				pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fRight, fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty1 );	++pVertices;
				pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;

				dwNumTriangles += 2;

				if (fMaxX < fRight ) fMaxX = fRight;
				if (fMaxY < fBottom) fMaxY = fBottom;

			}
			// 화면의 다음 줄로 넘기기
			sx = x;
			vtx_sx = 0;	vtx_sy = vtx_sy + ((float)(iFontHeight)) / m_fTextScale;
			continue;
		}
		else if (0x80 & szText[iCount])	// 2BYTE 문자
		{
			memcpy(szTempChar, &(szText[iCount]), 2);
			iCount += 2;
			szTempChar[2] = 0x00;
		}
		else								// 1BYTE 문자
		{
			memcpy(szTempChar, &(szText[iCount]), 1);
			iCount += 1;
			szTempChar[1] = 0x00;
		}

		SelectObject(s_hDC, m_hFont);
		GetTextExtentPoint32( s_hDC, szTempChar, lstrlen(szTempChar), &size );
		if ( (x + size.cx) > m_dwTexWidth)	
		{	// vertex 만들고 다음 줄로 넘기기..
			// vertex 만들기
			if (sx != x)
			{
				FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
				FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
				FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
				FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

				FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
				FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

				__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.
				if (dwNumTriangles+2 >= MAX_NUM_VERTICES) break;

				FLOAT fLeft = vtx_sx+0-0.5f;	FLOAT fRight  = vtx_sx+w-0.5f;
				FLOAT fTop  = vtx_sy+0-0.5f;	FLOAT fBottom = vtx_sy+h-0.5f;
				pVertices->Set(fLeft , fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty2 );	++pVertices;
				pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;
				pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fRight, fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty1 );	++pVertices;
				pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;
				dwNumTriangles += 2;

				if (fMaxX < fRight ) fMaxX = fRight;
				if (fMaxY < fBottom) fMaxY = fBottom;

				// 텍스쳐의 다음 줄로 넘기기
				x = sx = 0;	y += iFontHeight;
				vtx_sx = vtx_sx+w;
			}
			else
			{
				x = sx = 0;	y += iFontHeight;
			}
		}
		
		// dc에 찍기
		SelectObject(s_hDC, m_hFont);
		ExtTextOut( s_hDC, x, y, ETO_OPAQUE, nullptr, szTempChar, lstrlen(szTempChar), nullptr );		
		x += size.cx;
	}

	// 마지막 남은 vertex 만들기
	if (sx != x)
	{
		FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
		FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
		FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
		FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

		FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
		FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

		__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.

		FLOAT fLeft = vtx_sx+0-0.5f;	FLOAT fRight  = vtx_sx+w-0.5f;
		FLOAT fTop  = vtx_sy+0-0.5f;	FLOAT fBottom = vtx_sy+h-0.5f;
		pVertices->Set(fLeft , fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty2 );	++pVertices;
		pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;
		pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
		pVertices->Set(fRight, fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty1 );	++pVertices;
		pVertices->Set(fRight, fBottom, Z_DEFAULT, RHW_DEFAULT, dwColor, tx2, ty2 );	++pVertices;
		pVertices->Set(fLeft , fTop   , Z_DEFAULT, RHW_DEFAULT, dwColor, tx1, ty1 );	++pVertices;
		dwNumTriangles += 2;

		if (fMaxX < fRight ) fMaxX = fRight;
		if (fMaxY < fBottom) fMaxY = fBottom;
	}

	// Unlock and render the vertex buffer
	m_pVB->Unlock();
	m_iPrimitiveCount = dwNumTriangles;
	m_PrevLeftTop.x = m_PrevLeftTop.y = 0;
	m_Size.cx = (long)fMaxX;	m_Size.cy = (long)fMaxY;
}

void CDFont::Make3DVertex(const int iFontHeight, const std::string& szText, uint32_t dwFlags)
{
	if (m_pVB == nullptr
		|| s_hDC == nullptr
		|| m_hFont == nullptr)
	{
		__ASSERT(0, "NULL Vertex Buffer or DC or Font Handle ");
		return;
	}

	int iStrLen = static_cast<int>(szText.size());

	// 임시 vertex buffer에 넣기
	__VertexXyzColorT1	TempVertices[MAX_NUM_VERTICES];
	__VertexXyzColorT1* pVertices = TempVertices;
	uint32_t         dwNumTriangles = 0;

	uint32_t sx = 0;    // start x y
	uint32_t x = 0;    uint32_t y = 0;
	float vtx_sx = 0;    float vtx_sy = 0;		//	vertex start x y 
	int iCount = 0; int iTempCount = 0;

	char	szTempChar[3] = "";
	SIZE size;

	float fMaxX = 0.0f, fMaxY = 0.0f;	// 글씨가 찍히는 범위의 최대 최소값을 조사하기 위해서.

	while(iCount<iStrLen)
	{
		if ('\n' == szText[iCount])		// \n
		{
			++iCount;

			// vertex 만들기
			if (sx != x)
			{
				FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
				FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
				FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
				FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

				FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
				FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

				__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.
				if (dwNumTriangles+2 >= MAX_NUM_VERTICES) break;

				FLOAT fLeft = vtx_sx+0;	FLOAT fRight  = vtx_sx+w;
				FLOAT fTop  = vtx_sy+0;	FLOAT fBottom = vtx_sy-h;
				pVertices->Set(fLeft ,fBottom, Z_DEFAULT, m_dwFontColor, tx1, ty2 );	++pVertices;
				pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;
				pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fRight,fTop   , Z_DEFAULT, m_dwFontColor, tx2, ty1 );	++pVertices;
				pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;

				dwNumTriangles += 2;
				if (fMaxX < fRight ) fMaxX = fRight;
				if (fMaxY < (-fBottom)) fMaxY = (-fBottom);
			}
			// 화면의 다음 줄로 넘기기
			sx = x;
			vtx_sx = 0;	vtx_sy = vtx_sy - ((float)(iFontHeight)) / m_fTextScale;
			continue;
		}
		else if (0x80 & szText[iCount])	// 2BYTE 문자
		{
			memcpy(szTempChar, &(szText[iCount]), 2);
			iCount += 2;
			szTempChar[2] = 0x00;
		}
		else								// 1BYTE 문자
		{
			memcpy(szTempChar, &(szText[iCount]), 1);
			iCount += 1;
			szTempChar[1] = 0x00;
		}

		SelectObject(s_hDC, m_hFont);
		GetTextExtentPoint32( s_hDC, szTempChar, lstrlen(szTempChar), &size );
		if ( (x + size.cx) > m_dwTexWidth)	
		{	// vertex 만들고 다음 줄로 넘기기..
			// vertex 만들기
			if (sx != x)
			{
				FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
				FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
				FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
				FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

				FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
				FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

				__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.
				if (dwNumTriangles+2 >= MAX_NUM_VERTICES) break;

				FLOAT fLeft = vtx_sx+0;	FLOAT fRight  = vtx_sx+w;
				FLOAT fTop  = vtx_sy+0;	FLOAT fBottom = vtx_sy-h;
				pVertices->Set(fLeft ,fBottom, Z_DEFAULT, m_dwFontColor, tx1, ty2 );	++pVertices;
				pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;
				pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fRight,fTop   , Z_DEFAULT, m_dwFontColor, tx2, ty1 );	++pVertices;
				pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
				pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;
				dwNumTriangles += 2;
				if (fMaxX < fRight ) fMaxX = fRight;
				if (fMaxY < (-fBottom)) fMaxY = (-fBottom);

				// 텍스쳐의 다음 줄로 넘기기
				x = sx = 0;	y += iFontHeight;
				vtx_sx = vtx_sx+w;
			}
			else
			{
				x = sx = 0;	y += iFontHeight;
			}
		}
		
		// dc에 찍기
		SelectObject(s_hDC, m_hFont);
		ExtTextOut( s_hDC, x, y, ETO_OPAQUE, nullptr, szTempChar, lstrlen(szTempChar), nullptr );		
		x += size.cx;
	}

	// 마지막 남은 vertex 만들기
	if (sx != x)
	{
		FLOAT tx1 = ((FLOAT)(sx))/m_dwTexWidth;
		FLOAT ty1 = ((FLOAT)(y))/m_dwTexHeight;
		FLOAT tx2 = ((FLOAT)(x))/m_dwTexWidth;
		FLOAT ty2 = ((FLOAT)(y+iFontHeight))/m_dwTexHeight;

		FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
		FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

		__ASSERT(dwNumTriangles+2 < MAX_NUM_VERTICES, "??");		// Vertex buffer가 모자란다.

		FLOAT fLeft = vtx_sx+0;	FLOAT fRight  = vtx_sx+w;
		FLOAT fTop  = vtx_sy+0;	FLOAT fBottom = vtx_sy-h;
		pVertices->Set(fLeft ,fBottom, Z_DEFAULT, m_dwFontColor, tx1, ty2 );	++pVertices;
		pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;
		pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
		pVertices->Set(fRight,fTop   , Z_DEFAULT, m_dwFontColor, tx2, ty1 );	++pVertices;
		pVertices->Set(fRight,fBottom, Z_DEFAULT, m_dwFontColor, tx2, ty2 );	++pVertices;
		pVertices->Set(fLeft ,fTop   , Z_DEFAULT, m_dwFontColor, tx1, ty1 );	++pVertices;
		dwNumTriangles += 2;
		if (fMaxX < fRight ) fMaxX = fRight;
		if (fMaxY < (-fBottom)) fMaxY = (-fBottom);
	}

	int i;
	if (dwFlags & D3DFONT_CENTERED)	// 가운데 정렬이면 vertex좌표를 가운데로 계산해서 고쳐넣기
	{
		// 제일 긴 줄 찾기..
		int iRectangleCount = dwNumTriangles/2;

		int iContinueCount = 1;

		float fCX = 0;
		float fCY = 0;
		iCount = 0;
		while (iCount < iRectangleCount)
		{
			iContinueCount = 1;
			fCX = TempVertices[iCount*6 + 3].x;
			fCY = TempVertices[iCount*6].y;

			while( iCount + iContinueCount < iRectangleCount)
			{
				if (TempVertices[(iCount + iContinueCount)*6].y == fCY)
				{	// 다음 사각형과 같은 줄이다.
					fCX = TempVertices[(iCount + iContinueCount)*6 + 3].x;
					++iContinueCount;
				}
				else
				{	// 다음 사각형과 다른 줄이다.
					break;
				}
			}
			__ASSERT(fCX>0.0f, "??");
			float fDiffX = -fCX/2.0f;
			for (i=iCount; i<iCount+iContinueCount; ++i)
			{
				for (int j=0; j<6; ++j)
					TempVertices[i*6+j].x += fDiffX;
			}
			iCount += iContinueCount;
		}
	}

	// Vertex buffer로 옮기기.
	// lock vertex buffer
	if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
		return;

	iCount = dwNumTriangles*3;
	for (i=0; i<iCount; ++i)
	{
		TempVertices[i].x /= ((float)m_dwFontHeight);			// 일정 크기로 줄이기
		TempVertices[i].y /= ((float)m_dwFontHeight);			// 일정 크기로 줄이기

		*pVertices++ = TempVertices[i];
	}

	// Unlock and render the vertex buffer
	m_pVB->Unlock();
	m_iPrimitiveCount = dwNumTriangles;
	m_PrevLeftTop.x = m_PrevLeftTop.y = 0;
	m_Size.cx = (long)(fMaxX/((float)m_dwFontHeight));
	m_Size.cy = (long)(fMaxY/((float)m_dwFontHeight));
}

HRESULT CDFont::DrawText( FLOAT sx, FLOAT sy, uint32_t dwColor, uint32_t dwFlags, FLOAT fZ )
{
	if(nullptr == m_pVB || nullptr == s_hDC || nullptr == m_hFont)
	{
		//__ASSERT(0, "NULL Vertex Buffer or DC or Font Handle ");
		return E_FAIL;
	}

	if (m_iPrimitiveCount <= 0) return S_OK;
    if( m_pd3dDevice == nullptr || !m_Is2D)
        return E_FAIL;

	// 위치 색 조정
	__Vector2 vDiff = __Vector2(sx, sy) - m_PrevLeftTop;
	if ( fabs(vDiff.x)>0.5f || fabs(vDiff.y)>0.5f || dwColor != m_dwFontColor)
	{
		// lock vertex buffer
		__VertexTransformed* pVertices;
		if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
			return E_FAIL;

		int i, iVC = m_iPrimitiveCount*3;
		if (fabs(vDiff.x)>0.5f)
		{
			m_PrevLeftTop.x = sx;
			for (i=0; i<iVC; ++i)
			{
				pVertices[i].x += vDiff.x;
			}
		}

		if (fabs(vDiff.y)>0.5f)
		{
			m_PrevLeftTop.y = sy;
			for (i=0; i<iVC; ++i)
			{
				pVertices[i].y += vDiff.y;
			}
		}

		if (dwColor != m_dwFontColor)
		{
			m_dwFontColor = dwColor;
			m_PrevLeftTop.y = sy;
			for (i=0; i<iVC; ++i)
			{
				pVertices[i].color = m_dwFontColor;
			}
		}

//		if (fZ != 1.0f) // Z값이 1.0f 가 들어오지 않으면 바꾸어준다.
//		{
//			for (i=0; i<iVC; ++i)
//			{
//				pVertices[i].z = fZ;
//			}
//		}

		// Unlock
		m_pVB->Unlock();
	}

	// back up render state
	DWORD dwAlphaBlend, dwSrcBlend, dwDestBlend, dwZEnable, dwFog;
	m_pd3dDevice->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaBlend );
	m_pd3dDevice->GetRenderState( D3DRS_SRCBLEND,   &dwSrcBlend );
	m_pd3dDevice->GetRenderState( D3DRS_DESTBLEND,  &dwDestBlend );
	m_pd3dDevice->GetRenderState( D3DRS_ZENABLE,    &dwZEnable );
	m_pd3dDevice->GetRenderState( D3DRS_FOGENABLE,  &dwFog );
	DWORD dwColorOp, dwColorArg1, dwColorArg2, dwAlphaOp, dwAlphaArg1, dwAlphaArg2, dwMinFilter, dwMagFilter;
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLOROP,   &dwColorOp );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLORARG1, &dwColorArg1 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLORARG2, &dwColorArg2 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAOP,   &dwAlphaOp );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAARG1, &dwAlphaArg1 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAARG2, &dwAlphaArg2 );
	m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MINFILTER, &dwMinFilter );
	m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MAGFILTER, &dwMagFilter );

    // Set up renderstate
	if (TRUE != dwAlphaBlend) m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
//	if (1.0f == fZ)
//	{
		if ( D3DZB_FALSE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
//	}
//	else if ( D3DZB_TRUE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE );	// fZ가 1.0이 아니면 z 버퍼 켜고 그린다.
	if ( FALSE != dwFog) m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
	if (D3DTOP_MODULATE != dwColorOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwColorArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwColorArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	if (D3DTOP_MODULATE != dwAlphaOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwAlphaArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwAlphaArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	if( dwFlags & D3DFONT_FILTERED )
	{
	    // Set filter states
		if (D3DTEXF_LINEAR != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
		if (D3DTEXF_LINEAR != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
	}
	else
	{
		if (D3DTEXF_POINT != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
		if (D3DTEXF_POINT != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
	}

	// render
	m_pd3dDevice->SetFVF(FVF_TRANSFORMED);
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexTransformed) );
	m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, m_iPrimitiveCount );

    // Restore the modified renderstates
	if (TRUE != dwAlphaBlend) m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlphaBlend );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, dwSrcBlend );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, dwDestBlend );
//	if (1.0f == fZ)
//	{
		if ( D3DZB_FALSE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, dwZEnable );
//	}
//	else if ( D3DZB_TRUE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, dwZEnable );
	if ( FALSE != dwFog) m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, dwFog );
	if (D3DTOP_MODULATE != dwColorOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   dwColorOp );
	if (D3DTA_TEXTURE != dwColorArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, dwColorArg1 );
	if (D3DTA_DIFFUSE != dwColorArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, dwColorArg2 );
	if (D3DTOP_MODULATE != dwAlphaOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   dwAlphaOp );
	if (D3DTA_TEXTURE != dwAlphaArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, dwAlphaArg1 );
	if (D3DTA_DIFFUSE != dwAlphaArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, dwAlphaArg2 );
	if( dwFlags & D3DFONT_FILTERED )
	{
		if (D3DTEXF_LINEAR != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, dwMinFilter );
		if (D3DTEXF_LINEAR != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, dwMagFilter );
	}
	else
	{
		if (D3DSAMP_MINFILTER != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, dwMinFilter );
		if (D3DSAMP_MAGFILTER != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, dwMagFilter );
	}

    return S_OK;
}

HRESULT CDFont::DrawText3D(uint32_t dwColor, uint32_t dwFlags )
{
	if(nullptr == m_pVB || nullptr == s_hDC || nullptr == m_hFont)
	{
		__ASSERT(0, "NULL Vertex Buffer or DC or Font Handle ");
		return E_FAIL;
	}

	if (m_iPrimitiveCount <= 0) return S_OK;
    if( m_pd3dDevice == nullptr || m_Is2D)
        return E_FAIL;


	if (dwColor != m_dwFontColor)
	{
		// lock vertex buffer
		__VertexXyzColorT1* pVertices;
		if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
			return E_FAIL;

		m_dwFontColor = dwColor;
		int i, iVC = m_iPrimitiveCount*3;
		for (i=0; i<iVC; ++i)
		{
			pVertices[i].color = m_dwFontColor;
		}

		m_pVB->Unlock();
	}

	// back up render state
	DWORD dwAlphaBlend, dwSrcBlend, dwDestBlend, dwZEnable, dwFog, dwCullMode, dwLgt;
	m_pd3dDevice->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaBlend );
	m_pd3dDevice->GetRenderState( D3DRS_SRCBLEND,   &dwSrcBlend );
	m_pd3dDevice->GetRenderState( D3DRS_DESTBLEND,  &dwDestBlend );
	m_pd3dDevice->GetRenderState( D3DRS_ZENABLE,    &dwZEnable );
	m_pd3dDevice->GetRenderState( D3DRS_FOGENABLE,  &dwFog );
	m_pd3dDevice->GetRenderState( D3DRS_LIGHTING,   &dwLgt );

	DWORD dwColorOp, dwColorArg1, dwColorArg2, dwAlphaOp, dwAlphaArg1, dwAlphaArg2, dwMinFilter, dwMagFilter;
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLOROP,   &dwColorOp );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLORARG1, &dwColorArg1 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_COLORARG2, &dwColorArg2 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAOP,   &dwAlphaOp );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAARG1, &dwAlphaArg1 );
	m_pd3dDevice->GetTextureStageState( 0, D3DTSS_ALPHAARG2, &dwAlphaArg2 );
	m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MINFILTER, &dwMinFilter );
	m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MAGFILTER, &dwMagFilter );
    if( dwFlags & D3DFONT_TWOSIDED )
	{
	    // Turn off culling for two-sided text
		m_pd3dDevice->GetRenderState( D3DRS_CULLMODE,  &dwCullMode);
		if (D3DCULL_NONE != dwCullMode) m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  D3DCULL_NONE);
	}

    // Set up renderstate
	if (TRUE != dwAlphaBlend) m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
	if ( D3DZB_FALSE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
	if ( FALSE != dwFog) m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
	if ( FALSE != dwLgt) m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,  FALSE );

	if (D3DTOP_MODULATE != dwColorOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwColorArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwColorArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	if (D3DTOP_MODULATE != dwAlphaOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwAlphaArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwAlphaArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	if( dwFlags & D3DFONT_FILTERED )
	{
	    // Set filter states
		if (D3DTEXF_LINEAR != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
		if (D3DTEXF_LINEAR != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
	}
	else
	{
		if (D3DTEXF_POINT != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
		if (D3DTEXF_POINT != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
	}


	// render
	m_pd3dDevice->SetFVF(FVF_XYZCOLORT1);
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexXyzColorT1) );
	m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, m_iPrimitiveCount );

    // Restore the modified renderstates
	if (TRUE != dwAlphaBlend) m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlphaBlend );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, dwSrcBlend );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, dwDestBlend );
	if ( D3DZB_FALSE != dwZEnable) m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, dwZEnable );
	if ( FALSE != dwFog) m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, dwFog );
	if ( FALSE != dwLgt) m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,  dwLgt );

	if (D3DTOP_MODULATE != dwColorOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   dwColorOp );
	if (D3DTA_TEXTURE != dwColorArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, dwColorArg1 );
	if (D3DTA_DIFFUSE != dwColorArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, dwColorArg2 );
	if (D3DTOP_MODULATE != dwAlphaOp) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   dwAlphaOp );
	if (D3DTA_TEXTURE != dwAlphaArg1) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, dwAlphaArg1 );
	if (D3DTA_DIFFUSE != dwAlphaArg2) m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, dwAlphaArg2 );
	if( dwFlags & D3DFONT_FILTERED )
	{
		if (D3DTEXF_LINEAR != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, dwMinFilter );
		if (D3DTEXF_LINEAR != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, dwMagFilter );
	}
	else
	{
		if (D3DSAMP_MINFILTER != dwMinFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, dwMinFilter );
		if (D3DSAMP_MAGFILTER != dwMagFilter) m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, dwMagFilter );
	}
    if( (dwFlags & D3DFONT_TWOSIDED) && D3DCULL_NONE != dwCullMode) m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  dwCullMode);

	return S_OK;
}

BOOL CDFont::GetTextExtent(const std::string& szString, int iStrLen, SIZE* pSize )
{
	if (nullptr == s_hDC) return FALSE;

	SelectObject(s_hDC, m_hFont);
	return ::GetTextExtentPoint32( s_hDC, szString.c_str(), iStrLen, pSize );
}

HRESULT	CDFont::SetFontColor(uint32_t dwColor)
{
	if (m_iPrimitiveCount <= 0 || nullptr == m_pVB) return E_FAIL;

	if (dwColor != m_dwFontColor)
	{
		// lock vertex buffer
		HRESULT hr;
		if(m_Is2D)
		{
			__VertexTransformed* pVertices;
			if (FAILED(hr = m_pVB->Lock( 0, 0, (void**)&pVertices, 0 ))) return hr;
			m_dwFontColor = dwColor;
			int i, iVC = m_iPrimitiveCount*3;
			for (i=0; i<iVC; ++i)
			{
				pVertices[i].color = m_dwFontColor;
			}
			m_pVB->Unlock();
		}
		else
		{
			__VertexXyzColorT1* pVertices;
			if (FAILED(hr = m_pVB->Lock( 0, 0, (void**)&pVertices, 0 ))) return hr;
			m_dwFontColor = dwColor;
			int i, iVC = m_iPrimitiveCount*3;
			for (i=0; i<iVC; ++i)
			{
				pVertices[i].color = m_dwFontColor;
			}
			m_pVB->Unlock();
		}
	}
	return S_OK;
}

void CDFont::AddToAlphaManager(uint32_t dwColor, float fDist, __Matrix44& mtxWorld, uint32_t dwFlags)
{
	if (nullptr == m_pVB || 0 >= m_iPrimitiveCount) return;
	SetFontColor(dwColor);
	
	__AlphaPrimitive* pAP = s_AlphaMgr.Add();
	if(nullptr == pAP) return;

	
	uint32_t dwFVF = FVF_XYZCOLORT1;
	uint32_t dwFVFSize = sizeof(__VertexXyzColorT1);
	if(m_Is2D)
	{
		dwFVF = FVF_TRANSFORMED;
		dwFVFSize = sizeof(__VertexTransformed);

		// 위치 색 조정
		__Vector2 vDiff = __Vector2(mtxWorld.m[3][0], mtxWorld.m[3][1]) - m_PrevLeftTop;
		if ( fabs(vDiff.x)>0.5f || fabs(vDiff.y)>0.5f || dwColor != m_dwFontColor)
		{
			// lock vertex buffer
			__VertexTransformed* pVertices;
			if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
				return;

			int i, iVC = m_iPrimitiveCount*3;
			if (fabs(vDiff.x)>0.5f)
			{
				m_PrevLeftTop.x = mtxWorld.m[3][0];
				for (i=0; i<iVC; ++i)
				{
					pVertices[i].x += vDiff.x;
				}
			}

			if (fabs(vDiff.y)>0.5f)
			{
				m_PrevLeftTop.y = mtxWorld.m[3][1];
				for (i=0; i<iVC; ++i)
				{
					pVertices[i].y += vDiff.y;
				}
			}

			if (dwColor != m_dwFontColor)
			{
				m_dwFontColor = dwColor;
				m_PrevLeftTop.y = mtxWorld.m[3][1];
				for (i=0; i<iVC; ++i)
				{
					pVertices[i].color = m_dwFontColor;
				}
			}

//			if (fZ != 1.0f) // Z값이 1.0f 가 들어오지 않으면 바꾸어준다.
//			{
//				for (i=0; i<iVC; ++i)
//				{
//					pVertices[i].z = fZ;
//				}
//			}

			// Unlock
			m_pVB->Unlock();
		}
	}

	pAP->bUseVB				= TRUE;
	pAP->dwBlendDest		= D3DBLEND_INVSRCALPHA;
	pAP->dwBlendSrc			= D3DBLEND_SRCALPHA;
	pAP->dwFVF				= dwFVF;
	pAP->nPrimitiveCount	= m_iPrimitiveCount;
	pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
	pAP->dwPrimitiveSize	= dwFVFSize;
	pAP->fCameraDistance	= fDist;
	pAP->lpTex				= m_pTexture;
	pAP->nRenderFlags		= RF_NOTZWRITE|RF_NOTUSELIGHT|RF_NOTUSEFOG;
	pAP->nVertexCount		= MAX_NUM_VERTICES;
	pAP->pVertices			= m_pVB;
	pAP->pwIndices			= nullptr;
	pAP->MtxWorld			= mtxWorld;

	if(!(dwFlags & D3DFONT_FILTERED)) pAP->nRenderFlags |= RF_POINTSAMPLING; // 필터링 텍스트를 쓰지 않는다.
}

// ===== END N3Base/DFont.cpp =====

// ===== BEGIN N3Base/DFont.h =====
#line 1 "N3Base/DFont.h"
﻿// DFont.h: interface for the CDFont class.
// 사용법 및 사용제한
// 1. SetText함수는 계산량이 많다.(글씨를 바꿀때만 부르자(중요))
// 2. DrawText 함수는 2d평면상에 그려준다.
// 3. DrawText3D 함수는 3d로 그릴때 사용한다.(SetText함수에서 3D라고 명시해줘야 한다.)
// 제한 : 판때기를 현재 50개밖에 생성하지 못한다.(이 이상 나오게 하려면 MAX_NUM_VERTICES 를 고쳐주면 된다.)
// 4. InvalidateDeviceObjects();를 호출한후 다시 글씨를 쓰려면 다시 SetText함수를 호출해줘야 한다.
// 5. 3D공간상에 글씨를 찍을때 가운데 정렬해서 찍고 싶으면 SetText함수에 두번째 파라미터에 (D3DFONT_3D|D3DFONT_CENTERED)를 넣어준다.
//////////////////////////////////////////////////////////////////////

#pragma warning(disable:4786)

#if !defined(AFX_DFONT_H__B1A14901_0027_40BC_8A6C_7FC78DE38686__INCLUDED_)
#define AFX_DFONT_H__B1A14901_0027_40BC_8A6C_7FC78DE38686__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"

// Font creation flags
#define D3DFONT_BOLD        0x0001
#define D3DFONT_ITALIC      0x0002
#define D3DFONT_3D		    0x0008		// 3D text

// set text flag
#define D3DFONT_CENTERED    0x0004		// 3D font에서만..

// Font rendering flags (drawtext or DrawText3D 함수에서 쓰는 flag)
#define D3DFONT_TWOSIDED    0x0010		// 3D font에서만..
#define D3DFONT_FILTERED    0x0020		// texture를 D3DTSS_MAGFILTER 로 찍기


class CDFont  : public CN3Base
{
public:
	CDFont(const std::string& szFontName, uint32_t dwHeight, uint32_t dwFlags=0L);
	virtual ~CDFont();

// Attributes
public:
	const std::string& GetFontName() { return m_szFontName; }
	uint32_t	GetFontHeight() const {return m_dwFontHeight;}
	int		GetFontHeightInLogicalUnit() const {return -MulDiv(m_dwFontHeight, GetDeviceCaps(s_hDC, LOGPIXELSY), 72);}
	uint32_t	GetFontFlags() const {return m_dwFontFlags;}
	SIZE	GetSize() const {return m_Size;}
	uint32_t	GetFontColor() const {return m_dwFontColor;}

protected:
	static HDC s_hDC;						// DC handle
	static int s_iInstanceCount;			// Class Instance Count
	static HFONT s_hFontOld;				// default font


	std::string	m_szFontName;				// Font properties
    uint32_t		m_dwFontHeight;					// Font Size
    uint32_t		m_dwFontFlags;

    LPDIRECT3DDEVICE9       m_pd3dDevice;	// A D3DDevice used for rendering
    LPDIRECT3DTEXTURE9      m_pTexture;		// The d3d texture for this font
    LPDIRECT3DVERTEXBUFFER9 m_pVB;			// VertexBuffer for rendering text
    uint32_t	m_dwTexWidth;					// Texture dimensions
    uint32_t	m_dwTexHeight;					// Texture dimensions
    FLOAT	m_fTextScale;					// 쓸 폰트가 너무 클경우 비디오 카드에
											// 따른 texture 크기 제한을 넘어버리기 때문에
											// 이런 경우 Scale을 이용하여 크게 늘려 찍는다.

//	HDC			m_hDC;							// DC handle
	HFONT		m_hFont;						// Font handle
	UINT		m_iPrimitiveCount;				// 글씨 찍을 판의 갯수
	__Vector2	m_PrevLeftTop;				// DrawText의 경우 찍는 곳의 위치가 변경되었을때를 위한 변수
	uint32_t	m_dwFontColor;				// 글씨 색
	BOOL		m_Is2D;						// 2D Text인가?
	SIZE		m_Size;						// 쓴 글씨들이 차지하는 크기(pixel단위, 가로 세로)

// Operations
public:
	bool	IsSetText() { if(m_pTexture) return true; return false; }
	void	AddToAlphaManager(uint32_t dwColor, float fDist, __Matrix44& mtxWorld, uint32_t dwFlags);
	HRESULT	SetFontColor(uint32_t dwColor);						// 글씨 색을 바꾼다.
	HRESULT InitDeviceObjects( LPDIRECT3DDEVICE9 pd3dDevice );	// d3d device를 정해주는 초기화 함수 (Init할때 호출)
	HRESULT RestoreDeviceObjects();								// resource를 메모리에 세팅하는 초기화 함수 (Init할때 호출)
	HRESULT InvalidateDeviceObjects();							// resource등을 무효화시키는 함수 (release할때 호출)
	HRESULT DeleteDeviceObjects();								// resource등을 메모리에서 해제 (release할때 호출)

	HRESULT SetText(const std::string& szText, uint32_t dwFlags = 0L);	// 출력할 글씨가 달라졌을때만 호출하는 것이 중요.
	HRESULT DrawText( FLOAT sx, FLOAT sy, uint32_t dwColor, uint32_t dwFlags, FLOAT fZ = 1.0f);	// 버퍼에 저장된 글씨를 그린다.(2d)
	HRESULT DrawText3D(uint32_t dwColor, uint32_t dwFlags );		// 버퍼에 저장된 글씨를 그린다.(3d)

	HRESULT	SetFont(const std::string& szFontName, uint32_t dwHeight, uint32_t dwFlags=0L);	// Font를 바꾸고 싶을때 호출한다. (dwHeight는 point size를 넣는다.)
	BOOL	GetTextExtent(const std::string& szString, int iStrLen, SIZE* pSize );
protected:
	void Make2DVertex(const int iFontHeight, const std::string& szText);					// 입력 받은 문자를 적절하게 배치된 2d 폴리곤으로 만든다.
	void Make3DVertex(const int iFontHeight, const std::string& szText, uint32_t dwFlags);	// 입력 받은 문자를 적절하게 배치된 3d 폴리곤을 만든다.

};

#endif // !defined(AFX_DFONT_H__B1A14901_0027_40BC_8A6C_7FC78DE38686__INCLUDED_)

// ===== END N3Base/DFont.h =====

// ===== BEGIN N3Base/DebugUtils.cpp =====
#line 1 "N3Base/DebugUtils.cpp"
﻿#include "StdAfxBase.h"
#include <stdarg.h>

void FormattedDebugString(const char* fmt, ...)
{
	char buf[4096], *p = buf;
	va_list args;
	int n;

	va_start(args, fmt);
	n = _vsnprintf(p, sizeof(buf) - 3, fmt, args); // allow for proper linefeed & null terminator
	va_end(args);
	p += (n < 0) ? sizeof(buf) - 3 : n;
	*p++ = '\r';
	*p++ = '\n';
	*p   = '\0';

#ifdef WIN32
	OutputDebugStringA(buf);
#else
	printf("%s", buf);
#endif
}

// ===== END N3Base/DebugUtils.cpp =====

// ===== BEGIN N3Base/DebugUtils.h =====
#line 1 "N3Base/DebugUtils.h"
﻿#pragma once

#if defined(_DEBUG) || defined(DEBUG)
void FormattedDebugString(const char* fmt, ...);

#	include <cassert>

#	define ASSERT assert
#	define TRACE FormattedDebugString

//	Ensure both typically used debug defines behave as intended
#	ifndef DEBUG
#		define DEBUG
#	endif

#	ifndef _DEBUG
#		define _DEBUG
#	endif

#else
#	define ASSERT(...)
#	define TRACE(...)
#endif

// ===== END N3Base/DebugUtils.h =====

// ===== BEGIN N3Base/LogWriter.cpp =====
#line 1 "N3Base/LogWriter.cpp"
﻿// LogWriter.cpp: implementation of the CLogWriter class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Base.h"
#include "LogWriter.h"

#include <FileIO/FileWriter.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

std::string CLogWriter::s_szFileName;

CLogWriter::CLogWriter()
{
}

CLogWriter::~CLogWriter()
{
}

void CLogWriter::Open(const std::string& szFN)
{
	if (szFN.empty())
		return;

	s_szFileName = szFN;

	FileWriter file;
	if (!file.OpenExisting(s_szFileName))
	{
		if (!file.Create(s_szFileName))
			return;
	}

	auto fileSize = file.Size();

	// 파일 사이즈가 너무 크면 지운다..
	if (fileSize > 256'000)
	{
		file.Close();

		std::error_code ec;
		std::filesystem::remove(s_szFileName, ec);

		if (!file.Create(s_szFileName))
			return;
	}

	file.Seek(0, SEEK_END); // 추가 하기 위해서 파일의 끝으로 옮기고..

	std::string buff;
	SYSTEMTIME time;
	GetLocalTime(&time);

	buff = "---------------------------------------------------------------------------\r\n";
	file.Write(buff.data(), buff.length());

	buff = fmt::format("// Begin writing log... [{:02}/{:02} {:02}:{:02}]\r\n",
		time.wMonth, time.wDay, time.wHour, time.wMinute);
	file.Write(buff.data(), buff.length());
}

void CLogWriter::Close()
{
	FileWriter file;
	if (!file.OpenExisting(s_szFileName))
	{
		if (!file.Create(s_szFileName))
			return;
	}

	file.Seek(0, SEEK_END); // 추가 하기 위해서 파일의 끝으로 옮기고..

	std::string buff;
	SYSTEMTIME time;
	GetLocalTime(&time);

	buff = fmt::format("// End writing log... [{:02}/{:02} {:02}:{:02}]\r\n",
		time.wMonth, time.wDay, time.wHour, time.wMinute);
	file.Write(buff.data(), buff.length());

	buff = "---------------------------------------------------------------------------\r\n";
	file.Write(buff.data(), buff.length());
}

void CLogWriter::Write(const std::string_view message)
{
	if (s_szFileName.empty()
		|| message.empty())
		return;

	FileWriter file;
	if (!file.OpenExisting(s_szFileName))
	{
		if (!file.Create(s_szFileName))
			return;
	}

	SYSTEMTIME time;
	GetLocalTime(&time);

	std::string outputMessage = fmt::format("    [{:02}:{:02}:{:02}] {}\r\n",
		time.wHour, time.wMinute, time.wSecond, message);

	file.Seek(0, SEEK_END); // 추가 하기 위해서 파일의 끝으로 옮기고..
	file.Write(outputMessage.data(), outputMessage.length());
}

// ===== END N3Base/LogWriter.cpp =====

// ===== BEGIN N3Base/LogWriter.h =====
#line 1 "N3Base/LogWriter.h"
﻿// LogWriter.h: interface for the CLogWriter class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGWRITER_H__3299921C_04C3_40D6_848B_52F0CE5C9352__INCLUDED_)
#define AFX_LOGWRITER_H__3299921C_04C3_40D6_848B_52F0CE5C9352__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <string>
#include <string_view>

#include <spdlog/fmt/bundled/format.h>

class CLogWriter  
{
protected:
//	static HANDLE s_hFile;
	static std::string s_szFileName;

public:
	static void Open(const std::string& szFN);
	static void Close();
	static void Write(const std::string_view message);

	template <typename... Args>
	static inline void Write(fmt::format_string<Args...> fmt, Args &&...args)
	{
		std::string message = fmt::format(fmt, std::forward<Args>(args)...);
		Write(message);
	}
	
	CLogWriter();
	virtual ~CLogWriter();

};

#endif // !defined(AFX_LOGWRITER_H__3299921C_04C3_40D6_848B_52F0CE5C9352__INCLUDED_)

// ===== END N3Base/LogWriter.h =====

// ===== BEGIN N3Base/My_3DStruct.cpp =====
#line 1 "N3Base/My_3DStruct.cpp"
﻿#include "StdAfxBase.h"
#include "My_3DStruct.h"

#include "ColorValue.inl"
#include "Material.inl"

D3DCOLOR _RGB_To_D3DCOLOR(COLORREF cr, uint32_t dwAlpha)
{
	D3DCOLOR cr2
		= (dwAlpha << 24)				// A
		| ((cr & 0x000000ff) << 16)		// R
		| (cr & 0x0000ff00)				// G
		| ((cr & 0x00ff0000) >> 16);	// B
	return cr2;
}

COLORREF _D3DCOLOR_To_RGB(D3DCOLOR cr)
{
	COLORREF cr2
		= ((cr & 0x00ff0000) >> 16)		// R
		| (cr & 0x0000ff00)				// G
		| ((cr & 0x000000ff) << 16);	// B
	return cr2;
}

COLORREF _D3DCOLORVALUE_To_RGB(const D3DCOLORVALUE& cr)
{
	COLORREF cr2
		= (((uint32_t) (cr.r * 255.0f)))		// R
		| (((uint32_t) (cr.g * 255.0f)) << 8)	// G
		| (((uint32_t) (cr.b * 255.0f)) << 16);	// B
	return cr2;
}

D3DCOLOR _D3DCOLORVALUE_To_D3DCOLOR(const D3DCOLORVALUE& cr)
{
	COLORREF cr2
		= (((uint32_t) (cr.a * 255.0f)) << 24)	// A
		| (((uint32_t) (cr.r * 255.0f)) << 16)	// R
		| (((uint32_t) (cr.g * 255.0f)) << 8)	// G
		| (((uint32_t) (cr.b * 255.0f)));		// B
	return cr2;
}

D3DCOLORVALUE _RGB_To_D3DCOLORVALUE(COLORREF cr, float fAlpha)
{
	D3DCOLORVALUE cr2;
	cr2.a = fAlpha; // Alpha
	cr2.r = (cr & 0x000000ff) / 255.0f;
	cr2.g = ((cr & 0x0000ff00) >> 8) / 255.0f;
	cr2.b = ((cr & 0x00ff0000) >> 16) / 255.0f;
	return cr2;
}

D3DCOLORVALUE _D3DCOLOR_To_D3DCOLORVALUE(D3DCOLOR cr)
{
	D3DCOLORVALUE cr2;
	cr2.a = ((cr & 0xff000000) >> 24) / 255.0f;
	cr2.r = ((cr & 0x00ff0000) >> 16) / 255.0f;
	cr2.g = ((cr & 0x0000ff00) >> 8) / 255.0f;
	cr2.b = (cr & 0x000000ff) / 255.0f; // Alpha
	return cr2;
}

int16_t _IsKeyDown(int iVirtualKey)
{
	return (GetAsyncKeyState(iVirtualKey) & 0xff00);
}

int16_t _IsKeyDowned(int iVirtualKey)
{
	return (GetAsyncKeyState(iVirtualKey) & 0x00ff);
}

// ===== END N3Base/My_3DStruct.cpp =====

// ===== BEGIN N3Base/My_3DStruct.h =====
#line 1 "N3Base/My_3DStruct.h"
﻿#ifndef __MY_3DSTRUCT_H_
#define __MY_3DSTRUCT_H_

#pragma once

#include <d3dx9.h>
#include <string>
#include <stdint.h>
#include <inttypes.h>
#include <cmath>

#if defined(_N3TOOL)
#include <afx.h>
#else
#include "DebugUtils.h"
#endif

#include <MathUtils/MathUtils.h>

const float FRAME_SELFPLAY = FLT_MIN;

struct __ColorValue : public _D3DCOLORVALUE
{
public:
	__ColorValue() = default;
	__ColorValue(D3DCOLOR cr);
	__ColorValue(float r2, float g2, float b2, float a2);

	void operator = (const D3DCOLORVALUE& cv);
	void operator = (D3DCOLOR cr);
	void Set(float r2, float g2, float b2, float a2);

	D3DCOLOR ToD3DCOLOR() const;

	void operator += (float fDelta);
	void operator -= (float fDelta);
	void operator *= (float fDelta);
	void operator /= (float fDelta);
	
	D3DCOLORVALUE operator + (float fDelta) const;
	D3DCOLORVALUE operator - (float fDelta) const;
	D3DCOLORVALUE operator * (float fDelta) const;
	D3DCOLORVALUE operator / (float fDelta) const;

	void operator += (const D3DCOLORVALUE& cv);
	void operator -= (const D3DCOLORVALUE& cv);
	void operator *= (const D3DCOLORVALUE& cv);
	void operator /= (const D3DCOLORVALUE& cv);
	
	D3DCOLORVALUE operator + (const D3DCOLORVALUE& cv) const;
	D3DCOLORVALUE operator - (const D3DCOLORVALUE& cv) const;
	D3DCOLORVALUE operator * (const D3DCOLORVALUE& cv) const;
	D3DCOLORVALUE operator / (const D3DCOLORVALUE& cv) const;
};

constexpr uint32_t FVF_VNT1 = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1;
constexpr uint32_t FVF_VNT2 = D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX2;
constexpr uint32_t FVF_CV = D3DFVF_XYZ | D3DFVF_DIFFUSE;
constexpr uint32_t FVF_CSV = D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
constexpr uint32_t FVF_TRANSFORMED = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1;
constexpr uint32_t FVF_TRANSFORMEDT2 = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX2;
constexpr uint32_t FVF_TRANSFORMEDCOLOR = D3DFVF_XYZRHW | D3DFVF_DIFFUSE;
constexpr uint32_t FVF_PARTICLE = D3DFVF_XYZ | D3DFVF_PSIZE | D3DFVF_DIFFUSE;

//..
constexpr uint32_t FVF_XYZT1				= D3DFVF_XYZ | D3DFVF_TEX1;
constexpr uint32_t FVF_XYZT2				= D3DFVF_XYZ | D3DFVF_TEX2;
constexpr uint32_t FVF_XYZNORMAL			= D3DFVF_XYZ | D3DFVF_NORMAL;
constexpr uint32_t FVF_XYZCOLORT1			= D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1;
constexpr uint32_t FVF_XYZCOLORT2			= D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX2;
constexpr uint32_t FVF_XYZCOLORSPECULART1	= D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_SPECULAR | D3DFVF_TEX1;
constexpr uint32_t FVF_XYZCOLOR				= D3DFVF_XYZ | D3DFVF_DIFFUSE;
constexpr uint32_t FVF_XYZNORMALCOLOR		= D3DFVF_XYZ | D3DFVF_NORMAL  | D3DFVF_DIFFUSE;
constexpr uint32_t FVF_XYZNORMALCOLORT1		= D3DFVF_XYZ | D3DFVF_NORMAL  | D3DFVF_DIFFUSE | D3DFVF_TEX1;

constexpr uint32_t RF_NOTHING			= 0x0;
constexpr uint32_t RF_ALPHABLENDING		= 0x1;		// Alpha blending
constexpr uint32_t RF_NOTUSEFOG			= 0x2;		// 안개 무시
constexpr uint32_t RF_DOUBLESIDED		= 0x4;		// 양면 - D3DCULL_NONE
constexpr uint32_t RF_BOARD_Y			= 0x8;		// Y 축으로 해서.. 카메라를 본다.
constexpr uint32_t RF_POINTSAMPLING		= 0x10;		// MipMap 에서.. PointSampling 으로 한다..
constexpr uint32_t RF_WINDY				= 0x20;		// 바람에 날린다.. 바람의 값은 CN3Base::s_vWindFactor 를 참조 한다..
constexpr uint32_t RF_NOTUSELIGHT		= 0x40;		// Light Off
constexpr uint32_t RF_DIFFUSEALPHA		= 0x80;		// Diffuse 값을 갖고 투명하게 Alpha blending
constexpr uint32_t RF_NOTZWRITE			= 0x100;	// ZBuffer 에 안쓴다.
constexpr uint32_t RF_UV_CLAMP			= 0x200;	// texture UV적용을 Clamp로 한다..default는 wrap이다..
constexpr uint32_t RF_NOTZBUFFER		= 0x400;	// ZBuffer 무시.

struct __Material : public _D3DMATERIAL9
{
public:
	uint32_t	dwColorOp, dwColorArg1, dwColorArg2;
	uint32_t	nRenderFlags; // 1-AlphaBlending | 2-안개랑 관계없음 | 4-Double Side | 8- ??
	uint32_t	dwSrcBlend; // 소스 블렌딩 방법
	uint32_t	dwDestBlend; // 데스트 블렌딩 방법

public:
	void Init(const _D3DCOLORVALUE& diffuseColor);
	void Init(); // 기본 흰색으로 만든다..
	void ColorSet(const _D3DCOLORVALUE& crDiffuse);
};

// This must match the layout of _D3DLIGHT9.
struct __D3DLight9
{
	_D3DLIGHT9* toD3D()
	{
		return reinterpret_cast<_D3DLIGHT9*>(this);
	}

	const _D3DLIGHT9* toD3D() const
	{
		return reinterpret_cast<const _D3DLIGHT9*>(this);
	}

	D3DLIGHTTYPE	Type;            /* Type of light source */
	__ColorValue	Diffuse;         /* Diffuse color of light */
	__ColorValue	Specular;        /* Specular color of light */
	__ColorValue	Ambient;         /* Ambient color of light */
	__Vector3		Position;         /* Position in world space */
	__Vector3		Direction;        /* Direction in world space */
	float			Range;            /* Cutoff range */
	float			Falloff;          /* Falloff */
	float			Attenuation0;     /* Constant attenuation */
	float			Attenuation1;     /* Linear attenuation */
	float			Attenuation2;     /* Quadratic attenuation */
	float			Theta;            /* Inner angle of spotlight cone */
	float			Phi;              /* Outer angle of spotlight cone */
};

struct __VertexColor : public __Vector3
{
public:
	D3DCOLOR color;

public:
	void Set(const __Vector3& p, D3DCOLOR sColor)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
	}

	void Set(float sx, float sy, float sz, D3DCOLOR sColor)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
	}

	const __VertexColor& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexColor() = default;

	__VertexColor(const __Vector3& p, D3DCOLOR sColor)
	{
		Set(p, sColor);
	}

	__VertexColor(float sx, float sy, float sz, D3DCOLOR sColor)
	{
		Set(sx, sy, sz, sColor);
	}
};

struct __VertexParticle : public __Vector3
{
public:
	float PointSize;
	D3DCOLOR color;

public:
	void Set(const __Vector3& p, float fPointSize, D3DCOLOR sColor)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
		PointSize = fPointSize;
	}

	void Set(float sx, float sy, float sz, float fPointSize, D3DCOLOR sColor)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
		PointSize = fPointSize;
	}

	__VertexParticle()
	{
		PointSize = 1.0f;
		color = 0xffffffff;
	}

	__VertexParticle(const __Vector3& p, float fPointSize, D3DCOLOR sColor)
	{
		Set(p, fPointSize, sColor);
	}

	__VertexParticle(float sx, float sy, float sz, float fPointSize, D3DCOLOR sColor)
	{
		Set(sx, sy, sz, fPointSize, sColor);
	}
};

struct __VertexTransformedColor : public __Vector3
{
public:
	float rhw;
	D3DCOLOR color;

public:
	void Set(float sx, float sy, float sz, float srhw, D3DCOLOR sColor)
	{
		x = sx;
		y = sy;
		z = sz;
		rhw = srhw;
		color = sColor;
	}

	__VertexTransformedColor() = default;

	__VertexTransformedColor(float sx, float sy, float sz, float srhw, D3DCOLOR sColor)
	{
		Set(sx, sy, sz, srhw, sColor);
	}
};

struct __VertexT1 : public __Vector3
{
public:
	__Vector3 n;
	float tu, tv;

public:
	void Set(const __Vector3& p, const __Vector3& sn, float u, float v)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		n = sn;
		tu = u;
		tv = v;
	}

	void Set(float sx, float sy, float sz, float snx, float sny, float snz, float stu, float stv)
	{
		x = sx;
		y = sy;
		z = sz;
		n.x = snx;
		n.y = sny;
		n.z = snz;
		tu = stu;
		tv = stv;
	}

	__VertexT1() = default;

	__VertexT1(const __Vector3& p, const __Vector3& n, float u, float v)
	{
		Set(p, n, u, v);
	}

	__VertexT1(float sx, float sy, float sz, float snx, float sny, float snz, float stu, float stv)
	{
		Set(sx, sy, sz, snx, sny, snz, stu, stv);
	}
};

struct __VertexT2 : public __VertexT1
{
public:
	float tu2, tv2;

public:
	void Set(const __Vector3& p, const __Vector3& sn, float u, float v, float u2, float v2)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		n = sn;
		tu = u;
		tv = v;
		tu2 = u2;
		tv2 = v2;
	}

	void Set(float sx, float sy, float sz, float snx, float sny, float snz, float stu, float stv, float stu2, float stv2)
	{
		x = sx;
		y = sy;
		z = sz;
		n.x = snx;
		n.y = sny;
		n.z = snz;
		tu = stu;
		tv = stv;
		tu2 = stu2;
		tv2 = stv2;
	}

	__VertexT2() = default;

	__VertexT2(const __Vector3& p, const __Vector3& n, float u, float v, float u2, float v2)
	{
		Set(p, n, u, v, u2, v2);
	}

	__VertexT2(float sx, float sy, float sz, float snx, float sny, float snz, float stu, float stv, float stu2, float stv2)
	{
		Set(sx, sy, sz, snx, sny, snz, stu, stv, stu2, stv2);
	}
};

struct __VertexTransformed : public __Vector3
{
public:
	float rhw;
	D3DCOLOR color; // 필요 없다..
	float tu, tv;

public:
	void Set(float sx, float sy, float sz, float srhw, D3DCOLOR sColor, float stu, float stv)
	{
		x = sx;
		y = sy;
		z = sz;
		rhw = srhw;
		color = sColor;
		tu = stu;
		tv = stv;
	}

	__VertexTransformed() = default;

	__VertexTransformed(float sx, float sy, float sz, float srhw, D3DCOLOR sColor, float stu, float stv)
	{
		Set(sx, sy, sz, srhw, sColor, stu, stv);
	}
};

struct __VertexTransformedT2 : public __VertexTransformed
{
public:
	float tu2, tv2;

public:
	void Set(float sx, float sy, float sz, float srhw, D3DCOLOR sColor, float stu, float stv, float stu2, float stv2)
	{
		x = sx;
		y = sy;
		z = sz;
		rhw = srhw;
		color = sColor;
		tu = stu;
		tv = stv;
		tu2 = stu2;
		tv2 = stv2;
	}

	__VertexTransformedT2() = default;

	__VertexTransformedT2(float sx, float sy, float sz, float srhw, D3DCOLOR sColor, float stu, float stv, float stu2, float stv2)
	{
		Set(sx, sy, sz, srhw, sColor, stu, stv, stu2, stv2);
	}
};

struct __VertexXyzT1 : public __Vector3
{
public:
	float tu, tv;	

public:
	void Set(const __Vector3& p, float u, float v)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		tu = u; tv = v;
	}

	void Set(float sx, float sy, float sz, float u, float v)
	{
		x = sx;
		y = sy;
		z = sz;
		tu = u;
		tv = v;
	}

	const __VertexXyzT1& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzT1() = default;

	__VertexXyzT1(const __Vector3& p, float u, float v)
	{
		Set(p, u, v);
	}

	__VertexXyzT1(float sx, float sy, float sz, float u, float v)
	{
		Set(sx, sy, sz, u, v);
	}
};

struct __VertexXyzT2 : public __VertexXyzT1
{
public:
	float tu2, tv2;

public:
	void Set(const __Vector3& p, float u, float v, float u2, float v2)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		tu = u;
		tv = v;
		tu2 = u2;
		tv2 = v2;
	}

	void Set(float sx, float sy, float sz, float u, float v, float u2, float v2)
	{
		x = sx;
		y = sy;
		z = sz;
		tu = u;
		tv = v;
		tu2 = u2;
		tv2 = v2;
	}

	const __VertexXyzT2& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzT2() = default;

	__VertexXyzT2(const __Vector3& p, float u, float v, float u2, float v2)
	{
		Set(p, u, v, u2, v2);
	}

	__VertexXyzT2(float sx, float sy, float sz, float u, float v, float u2, float v2)
	{
		Set(sx, sy, sz, u, v, u2, v2);
	}
};

struct __VertexXyzNormal : public __Vector3
{
public:
	__Vector3 n;

public:
	void Set(const __Vector3& p, const __Vector3& sn)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		n = sn;
	}

	void Set(float xx, float yy, float zz, float nxx, float nyy, float nzz)
	{
		x = xx;
		y = yy;
		z = zz;
		n.x = nxx;
		n.y = nyy;
		n.z = nzz;
	}

	const __VertexXyzNormal& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzNormal() = default;

	__VertexXyzNormal(const __Vector3& p, const __Vector3& n)
	{
		Set(p, n);
	}

	__VertexXyzNormal(float sx, float sy, float sz, float xx, float yy, float zz)
	{
		Set(sx, sy, sz, xx, yy, zz);
	}
};

struct __VertexXyzColorSpecularT1 : public __Vector3
{
public:
	D3DCOLOR color;
	D3DCOLOR specular;
	float tu, tv;

public:
	void Set(const __Vector3& p, D3DCOLOR sColor, D3DCOLOR sSpecular, float u, float v)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
		specular = sSpecular;
		tu = u;
		tv = v;
	}

	void Set(float sx, float sy, float sz, D3DCOLOR sColor, D3DCOLOR sSpecular, float u, float v)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
		specular = sSpecular;
		tu = u;
		tv = v;
	}

	__VertexXyzColorSpecularT1() = default;

	__VertexXyzColorSpecularT1(const __Vector3& p, D3DCOLOR sColor, D3DCOLOR sSpecular, float u, float v)
	{
		Set(p, sColor, sSpecular, u, v);
	}

	__VertexXyzColorSpecularT1(float sx, float sy, float sz, D3DCOLOR sColor, D3DCOLOR sSpecular, float u, float v)
	{
		Set(sx, sy, sz, sColor, sSpecular, u, v);
	}
};

struct __VertexXyzColorT1 : public __Vector3
{
public:
	D3DCOLOR color;
	float tu, tv;

public:
	void Set(const __Vector3& p, D3DCOLOR sColor, float u, float v)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
		tu = u;
		tv = v;
	}

	void Set(float sx, float sy, float sz, D3DCOLOR sColor, float u, float v)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
		tu = u;
		tv = v;
	}

	const __VertexXyzColorT1& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzColorT1() = default;

	__VertexXyzColorT1(const __Vector3& p, D3DCOLOR sColor, float u, float v)
	{
		Set(p, sColor, u, v);
	}

	__VertexXyzColorT1(float sx, float sy, float sz, D3DCOLOR sColor, float u, float v)
	{
		Set(sx, sy, sz, sColor, u, v);
	}
};

struct __VertexXyzColorT2 : public __VertexXyzColorT1
{
public:
	float tu2, tv2;
public:
	void Set(const __Vector3& p, D3DCOLOR sColor, float u, float v, float u2, float v2)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
		tu = u;
		tv = v;
		tu2 = u2;
		tv2 = v2;
	}

	void Set(float sx, float sy, float sz, D3DCOLOR sColor, float u, float v, float u2, float v2)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
		tu = u;
		tv = v;
		tu2 = u2;
		tv2 = v2;
	}

	const __VertexXyzColorT2& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzColorT2() = default;

	__VertexXyzColorT2(const __Vector3& p, D3DCOLOR sColor, float u, float v, float u2, float v2)
	{
		Set(p, sColor, u, v, u2, v2);
	}

	__VertexXyzColorT2(float sx, float sy, float sz, D3DCOLOR sColor, float u, float v, float u2, float v2)
	{
		Set(sx, sy, sz, sColor, u, v, u2, v2);
	}
};

struct __VertexXyzColor : public __Vector3
{
public:
	D3DCOLOR color;

public:
	void Set(const __Vector3& p, D3DCOLOR sColor)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		color = sColor;
	}

	void Set(float sx, float sy, float sz, D3DCOLOR sColor)
	{
		x = sx;
		y = sy;
		z = sz;
		color = sColor;
	}

	const __VertexXyzColor& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzColor() = default;

	__VertexXyzColor(const __Vector3& p, D3DCOLOR sColor)
	{
		Set(p, sColor);
	}
	__VertexXyzColor(float sx, float sy, float sz, D3DCOLOR sColor)
	{
		Set(sx, sy, sz, sColor);
	}
};

struct __VertexXyzNormalColor : public __Vector3
{
public:
	__Vector3 n;
	D3DCOLOR color;

public:
	void Set(const __Vector3& p, const __Vector3& sn, D3DCOLOR sColor)
	{
		x = p.x;
		y = p.y;
		z = p.z;
		n = sn;
		color = sColor;
	}

	void Set(float sx, float sy, float sz, float nxx, float nyy, float nzz, D3DCOLOR sColor)
	{
		x = sx;
		y = sy;
		z = sz;
		n.x = nxx;
		n.y = nyy;
		n.z = nzz;
		color = sColor;
	}

	const __VertexXyzNormalColor& operator = (const __Vector3& vec)
	{
		x = vec.x;
		y = vec.y;
		z = vec.z;
		return *this;
	}

	__VertexXyzNormalColor() = default;

	__VertexXyzNormalColor(const __Vector3& p, const __Vector3& n, D3DCOLOR sColor)
	{
		Set(p, n, sColor);
	}

	__VertexXyzNormalColor(float sx, float sy, float sz, float xx, float yy, float zz, D3DCOLOR sColor)
	{
		Set(sx, sy, sz, xx, yy, zz, sColor);
	}
};

constexpr int MAX_MIPMAP_COUNT = 10; // 1024 * 1024 단계까지 생성

constexpr uint32_t OBJ_UNKNOWN					= 0;
constexpr uint32_t OBJ_BASE						= 0x1;
constexpr uint32_t OBJ_BASE_FILEACCESS			= 0x2;
constexpr uint32_t OBJ_TEXTURE					= 0x4;
constexpr uint32_t OBJ_TRANSFORM 				= 0x8;
constexpr uint32_t OBJ_TRANSFORM_COLLISION		= 0x10;
constexpr uint32_t OBJ_SCENE					= 0x20;

constexpr uint32_t OBJ_CAMERA					= 0x100;
constexpr uint32_t OBJ_LIGHT					= 0x200;
constexpr uint32_t OBJ_SHAPE					= 0x400;
constexpr uint32_t OBJ_SHAPE_PART				= 0x800;
constexpr uint32_t OBJ_SHAPE_EXTRA				= 0x1000;
constexpr uint32_t OBJ_CHARACTER				= 0x2000;
constexpr uint32_t OBJ_CHARACTER_PART			= 0x4000;
constexpr uint32_t OBJ_CHARACTER_PLUG			= 0x8000;
constexpr uint32_t OBJ_BOARD					= 0x1000;
constexpr uint32_t OBJ_FX_PLUG					= 0x20000;
constexpr uint32_t OBJ_FX_PLUG_PART				= 0x40000;

constexpr uint32_t OBJ_MESH						= 0x100000;
constexpr uint32_t OBJ_MESH_PROGRESSIVE			= 0x200000;
constexpr uint32_t OBJ_MESH_INDEXED				= 0x400000;
constexpr uint32_t OBJ_MESH_VECTOR3				= 0x800000;
constexpr uint32_t OBJ_JOINT					= 0x1000000;
constexpr uint32_t OBJ_SKIN						= 0x2000000;
constexpr uint32_t OBJ_CHARACTER_PART_SKINS		= 0x4000000;

constexpr uint32_t OBJ_DUMMY					= 0x10000000;
constexpr uint32_t OBJ_EFFECT					= 0x20000000;
constexpr uint32_t OBJ_ANIM_CONTROL				= 0x40000000;

#ifndef _DEBUG
#define __ASSERT(expr, expMessage)
#else
#include "CrtDbg.h"

#define __ASSERT(expr, expMessage) \
if (!(expr)) \
{ \
	_CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, "N3 Custom Assert Function", expMessage); \
	char __szErr[512] = {}; \
	snprintf(__szErr, sizeof(__szErr), "%s(%d): %s\n", __FILE__, __LINE__, expMessage); \
	OutputDebugStringA(__szErr); \
	_CrtDbgBreak(); \
}
#endif

D3DCOLOR		_RGB_To_D3DCOLOR(COLORREF cr, uint32_t dwAlpha);
COLORREF		_D3DCOLOR_To_RGB(D3DCOLOR cr);
COLORREF		_D3DCOLORVALUE_To_RGB(const D3DCOLORVALUE& cr);
D3DCOLOR		_D3DCOLORVALUE_To_D3DCOLOR(const D3DCOLORVALUE& cr);
D3DCOLORVALUE	_RGB_To_D3DCOLORVALUE(COLORREF cr, float fAlpha);
D3DCOLORVALUE	_D3DCOLOR_To_D3DCOLORVALUE(D3DCOLOR cr);
int16_t			_IsKeyDown(int iVirtualKey);
int16_t			_IsKeyDowned(int iVirtualKey);

#endif // __MY_3DSTRUCT_H_

// ===== END N3Base/My_3DStruct.h =====

// ===== BEGIN N3Base/N3AlphaPrimitiveManager.cpp =====
#line 1 "N3Base/N3AlphaPrimitiveManager.cpp"
﻿// N3AlphaPrimitiveManager.cpp: implementation of the CN3AlphaPrimitiveManager class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3AlphaPrimitiveManager.h"
#include "N3Base.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3AlphaPrimitiveManager::CN3AlphaPrimitiveManager()
{
	m_nToDrawCount = 0;
}

CN3AlphaPrimitiveManager::~CN3AlphaPrimitiveManager()
{
}

void CN3AlphaPrimitiveManager::Render()
{
	__ASSERT(CN3Base::s_lpD3DDev, "3d device pointer is NULL!!!");
	if(m_nToDrawCount <= 0) return;
	
	static __AlphaPrimitive* pBuffs[MAX_ALPHAPRIMITIVE_BUFFER];
	for(int i = 0; i < m_nToDrawCount; i++) pBuffs[i] = &(m_Buffers[i]);
	qsort(pBuffs, m_nToDrawCount, sizeof(__AlphaPrimitive*), SortByCameraDistance); // 버퍼에 쌓인 프리미티브대로 정렬하고..

	struct __RenderState
	{
		DWORD dwAlpha, dwFog, dwCull, dwLgt, dwZWrite, dwAO, dwAA1, dwAA2, dwCO, dwCA1, dwCA2, dwPointSampling;
		DWORD dwAddressU, dwAddressV;
		DWORD dwSrcBlend, dwDestBlend;
		DWORD dwZEnable;
	};
	__RenderState RS_old;		// 이전 render state (나중에 되돌려놓기 위해)
	__RenderState RS_current;	// 현재 render state (현재 어떤 상태인가 판단하기 위해)

	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &RS_old.dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &RS_old.dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &RS_old.dwCull);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &RS_old.dwLgt);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &RS_old.dwZWrite);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &RS_old.dwZEnable);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND,  &RS_old.dwSrcBlend );
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &RS_old.dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAOP,   &RS_old.dwAO);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG1, &RS_old.dwAA1);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG2, &RS_old.dwAA2);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLOROP,   &RS_old.dwCO);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLORARG1, &RS_old.dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLORARG2, &RS_old.dwCA2);
	CN3Base::s_lpD3DDev->GetSamplerState( 0, D3DSAMP_MIPFILTER, &RS_old.dwPointSampling);
	CN3Base::s_lpD3DDev->GetSamplerState( 0, D3DSAMP_ADDRESSU, &RS_old.dwAddressU);
	CN3Base::s_lpD3DDev->GetSamplerState( 0, D3DSAMP_ADDRESSV, &RS_old.dwAddressV);

	RS_current = RS_old;

	if(TRUE != RS_current.dwAlpha) {RS_current.dwAlpha = TRUE; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);}
	static __Material mtl; mtl.Init();
	CN3Base::s_lpD3DDev->SetMaterial(&mtl);

	for(int i = 0; i < m_nToDrawCount; i++)
	{

		if(pBuffs[i]->nRenderFlags & RF_NOTUSEFOG) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, RS_old.dwFog);
		if(pBuffs[i]->nRenderFlags & RF_DOUBLESIDED) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, RS_old.dwCull);
		if(pBuffs[i]->nRenderFlags & RF_NOTUSELIGHT) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, RS_old.dwLgt);
		if(pBuffs[i]->nRenderFlags & RF_NOTZWRITE) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, RS_old.dwZWrite);
		if(pBuffs[i]->nRenderFlags & RF_NOTZBUFFER) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, RS_old.dwZEnable);
		if(pBuffs[i]->nRenderFlags & RF_DIFFUSEALPHA)
		{
			if(pBuffs[i]->lpTex)
			{
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE );
			}
			else
			{
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
			}
		}
		else
		{
			if(pBuffs[i]->lpTex)
			{
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   RS_old.dwAO );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, RS_old.dwAA1 );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, RS_old.dwAA2 );
			}
			else
			{
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   RS_old.dwAO );
				CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, RS_old.dwAA1 );
			}
		}
		if (pBuffs[i]->nRenderFlags & RF_POINTSAMPLING) CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_POINT);
		else CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, RS_old.dwPointSampling);
		if (pBuffs[i]->nRenderFlags & RF_UV_CLAMP)
		{
			CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
			CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
		}
		else
		{
			CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSU, RS_old.dwAddressU );
			CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSV, RS_old.dwAddressV );
		}
		
		if (pBuffs[i]->dwBlendSrc != RS_current.dwSrcBlend)	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   pBuffs[i]->dwBlendSrc);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   RS_old.dwSrcBlend);
		if (pBuffs[i]->dwBlendDest != RS_current.dwDestBlend) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  pBuffs[i]->dwBlendDest);
		else CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  RS_old.dwDestBlend);

		CN3Base::s_lpD3DDev->SetFVF(pBuffs[i]->dwFVF);
		CN3Base::s_lpD3DDev->SetTexture(0, pBuffs[i]->lpTex);
		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, pBuffs[i]->MtxWorld.toD3D()); // 월드 행렬 적용

		if(pBuffs[i]->lpTex)
		{
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
		}
		else
		{
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		}
	
		if(pBuffs[i]->pwIndices && pBuffs[i]->nPrimitiveCount > 0) // Index 가 있으면..
		{
			if (pBuffs[i]->bUseVB)
			{
				CN3Base::s_lpD3DDev->SetStreamSource( 0, (LPDIRECT3DVERTEXBUFFER9)pBuffs[i]->pVertices, 0, pBuffs[i]->dwPrimitiveSize );
				CN3Base::s_lpD3DDev->SetIndices((LPDIRECT3DINDEXBUFFER9)pBuffs[i]->pwIndices);
				CN3Base::s_lpD3DDev->DrawIndexedPrimitive(	pBuffs[i]->ePrimitiveType,
												0,
												0,
												pBuffs[i]->nVertexCount,
												0,
												pBuffs[i]->nPrimitiveCount );
			}
			else
			{
				CN3Base::s_lpD3DDev->DrawIndexedPrimitiveUP(	pBuffs[i]->ePrimitiveType, 
												0,
												pBuffs[i]->nVertexCount,
												pBuffs[i]->nPrimitiveCount,
												pBuffs[i]->pwIndices,
												D3DFMT_INDEX16,
												pBuffs[i]->pVertices,
												pBuffs[i]->dwPrimitiveSize );
			}
		}
		else if(pBuffs[i]->nPrimitiveCount > 0)
		{
			if (pBuffs[i]->bUseVB)
			{
				CN3Base::s_lpD3DDev->SetStreamSource( 0, (LPDIRECT3DVERTEXBUFFER9)pBuffs[i]->pVertices, 0, pBuffs[i]->dwPrimitiveSize );
				CN3Base::s_lpD3DDev->DrawPrimitive(	pBuffs[i]->ePrimitiveType,
										0,
										pBuffs[i]->nPrimitiveCount );
			}
			else
			{
				CN3Base::s_lpD3DDev->DrawPrimitiveUP(	pBuffs[i]->ePrimitiveType, 
										pBuffs[i]->nPrimitiveCount,
										pBuffs[i]->pVertices,
										pBuffs[i]->dwPrimitiveSize );
			}
		}

#ifdef _DEBUG
		CN3Base::s_RenderInfo.nAlpha_Polygon += pBuffs[i]->nPrimitiveCount / 3; // Rendering Information Update...
#endif
	}
		
	m_nToDrawCount = 0; // 다 그렸다...

	// restore
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, RS_old.dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, RS_old.dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, RS_old.dwCull);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, RS_old.dwLgt);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, RS_old.dwZWrite);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, RS_old.dwZEnable);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,  RS_old.dwSrcBlend );
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, RS_old.dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   RS_old.dwAO);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, RS_old.dwAA1);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, RS_old.dwAA2);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   RS_old.dwCO);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, RS_old.dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, RS_old.dwCA2);
	CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_MIPFILTER, RS_old.dwPointSampling);
	CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSU,  RS_old.dwAddressU);
	CN3Base::s_lpD3DDev->SetSamplerState( 0, D3DSAMP_ADDRESSV,  RS_old.dwAddressV);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
/*	
	__ASSERT(CN3Base::s_lpD3DDev, "3d device pointer is NULL!!!");
	if(m_nToDrawCount <= 0) return;
	
	static __AlphaPrimitive* pBuffs[MAX_ALPHAPRIMITIVE_BUFFER];
	for(int i = 0; i < m_nToDrawCount; i++) pBuffs[i] = &(m_Buffers[i]);
	qsort(pBuffs, m_nToDrawCount, sizeof(__AlphaPrimitive*), SortByCameraDistance); // 버퍼에 쌓인 프리미티브대로 정렬하고..

	struct __RenderState
	{
		uint32_t dwAlpha, dwFog, dwCull, dwLgt, dwZWrite, dwAO, dwAA1, dwAA2, dwCO, dwCA1, dwCA2, dwPointSampling;
		uint32_t dwSrcBlend, dwDestBlend;
	};
	__RenderState RS_old;		// 이전 render state (나중에 되돌려놓기 위해)
	__RenderState RS_current;	// 현재 render state (현재 어떤 상태인가 판단하기 위해)

	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &RS_old.dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &RS_old.dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &RS_old.dwCull);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &RS_old.dwLgt);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &RS_old.dwZWrite);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND,  &RS_old.dwSrcBlend );
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &RS_old.dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAOP,   &RS_old.dwAO);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG1, &RS_old.dwAA1);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG2, &RS_old.dwAA2);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLOROP,   &RS_old.dwCO);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLORARG1, &RS_old.dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_COLORARG2, &RS_old.dwCA2);
	CN3Base::s_lpD3DDev->GetTextureStageState( 0, D3DTSS_MIPFILTER, &RS_old.dwPointSampling);

	RS_current = RS_old;

	if(TRUE != RS_current.dwAlpha) {RS_current.dwAlpha = TRUE; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);}
	static __Material mtl; mtl.Init();
	CN3Base::s_lpD3DDev->SetMaterial(&mtl);

	for(i = 0; i < m_nToDrawCount; i++)
	{
		if(pBuffs[i]->nRenderFlags & RF_NOTUSEFOG)
		{
			if (FALSE != RS_current.dwFog) { RS_current.dwFog = FALSE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);}
		} // Fog 무시..
		else
		{
			if (TRUE != RS_current.dwFog) {	RS_current.dwFog = TRUE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, TRUE);	}
		}

		if(pBuffs[i]->nRenderFlags & RF_DOUBLESIDED)
		{
			if (D3DCULL_NONE != RS_current.dwCull) { RS_current.dwCull = D3DCULL_NONE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);}
		} // Render Flags - 
		else
		{
			if (D3DCULL_CCW != RS_current.dwCull) {	RS_current.dwCull = D3DCULL_CCW; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);}
		}

		if(pBuffs[i]->nRenderFlags & RF_NOTUSELIGHT)
		{
			if (FALSE != RS_current.dwLgt) { RS_current.dwLgt = FALSE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);	}
		} // Render Flags - 
		else
		{
			if (TRUE != RS_current.dwLgt) {	RS_current.dwLgt = TRUE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, TRUE);}
		}

		if(pBuffs[i]->nRenderFlags & RF_NOTZWRITE)
		{
			if (FALSE != RS_current.dwZWrite) {	RS_current.dwZWrite = FALSE; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);}
		}
		else
		{
			if (TRUE != RS_current.dwZWrite) {	RS_current.dwZWrite = TRUE;	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);}
		}

		if(pBuffs[i]->nRenderFlags & RF_DIFFUSEALPHA)
		{
			if(pBuffs[i]->lpTex)
			{
				if (D3DTOP_MODULATE != RS_current.dwAO)	{ RS_current.dwAO = D3DTOP_MODULATE; CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );	}
				if (D3DTA_DIFFUSE != RS_current.dwAA1)	{ RS_current.dwAA1 = D3DTA_DIFFUSE; CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);}
				if (D3DTA_TEXTURE != RS_current.dwAA2)	{ RS_current.dwAA2 = D3DTA_TEXTURE;	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);}
			}
			else
			{
				if (D3DTOP_SELECTARG1 != RS_current.dwAO) {	RS_current.dwAO = D3DTOP_SELECTARG1; CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );}
				if (D3DTA_DIFFUSE != RS_current.dwAA1) { RS_current.dwAA1 = D3DTA_DIFFUSE;	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);}
			}
		}
		if(pBuffs[i]->nRenderFlags & RF_POINTSAMPLING)
		{
			if ( D3DTEXF_POINT != RS_current.dwPointSampling) { RS_current.dwPointSampling = D3DTEXF_POINT;	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_POINT); }// Render Flags -
		}
		else
		{
			if ( D3DTEXF_NONE != RS_current.dwPointSampling) { RS_current.dwPointSampling = D3DTEXF_NONE; CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_NONE); }// Render Flags - 
		}
		
		if (pBuffs[i]->dwBlendSrc != RS_current.dwSrcBlend)	{ RS_current.dwSrcBlend = pBuffs[i]->dwBlendSrc; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   pBuffs[i]->dwBlendSrc);}
		if (pBuffs[i]->dwBlendDest != RS_current.dwDestBlend) {	RS_current.dwDestBlend = pBuffs[i]->dwBlendDest; CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  pBuffs[i]->dwBlendDest);}

		CN3Base::s_lpD3DDev->SetFVF(pBuffs[i]->dwFVF);
		CN3Base::s_lpD3DDev->SetTexture(0, pBuffs[i]->lpTex);
		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, &(pBuffs[i]->MtxWorld)); // 월드 행렬 적용

		if(pBuffs[i]->lpTex)
		{
			if (D3DTOP_MODULATE != RS_current.dwCO)	{ RS_current.dwCO = D3DTOP_MODULATE; CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);	}
			if (D3DTA_DIFFUSE != RS_current.dwCA1) { RS_current.dwCA1 = D3DTA_DIFFUSE; CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);}
			if (D3DTA_TEXTURE != RS_current.dwCA2) { RS_current.dwCA2 = D3DTA_TEXTURE; CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);}
		}
		else
		{
			if (D3DTOP_SELECTARG1 != RS_current.dwCO) {	RS_current.dwCO = D3DTOP_SELECTARG1; CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);}
			if (D3DTA_DIFFUSE != RS_current.dwCA1) { RS_current.dwCA1 = D3DTA_DIFFUSE;	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);}
		}
	
		if(pBuffs[i]->pwIndices && pBuffs[i]->nPrimitiveCount > 0) // Index 가 있으면..
		{
			if (pBuffs[i]->bUseVB)
			{
				CN3Base::s_lpD3DDev->SetStreamSource( 0, (LPDIRECT3DVERTEXBUFFER8)pBuffs[i]->pVertices, pBuffs[i]->dwPrimitiveSize );
				CN3Base::s_lpD3DDev->SetIndices((LPDIRECT3DINDEXBUFFER8)pBuffs[i]->pwIndices, 0);
				CN3Base::s_lpD3DDev->DrawIndexedPrimitive(	pBuffs[i]->ePrimitiveType,
												0,
												pBuffs[i]->nVertexCount,
												0,
												pBuffs[i]->nPrimitiveCount );
			}
			else
			{
				CN3Base::s_lpD3DDev->DrawIndexedPrimitiveUP(	pBuffs[i]->ePrimitiveType, 
												0,
												pBuffs[i]->nVertexCount,
												pBuffs[i]->nPrimitiveCount,
												pBuffs[i]->pwIndices,
												D3DFMT_INDEX16,
												pBuffs[i]->pVertices,
												pBuffs[i]->dwPrimitiveSize );
			}
		}
		else if(pBuffs[i]->nPrimitiveCount > 0)
		{
			if (pBuffs[i]->bUseVB)
			{
				CN3Base::s_lpD3DDev->SetStreamSource( 0, (LPDIRECT3DVERTEXBUFFER8)pBuffs[i]->pVertices, pBuffs[i]->dwPrimitiveSize );
				CN3Base::s_lpD3DDev->DrawPrimitive(	pBuffs[i]->ePrimitiveType,
										0,
										pBuffs[i]->nPrimitiveCount );
			}
			else
			{
				CN3Base::s_lpD3DDev->DrawPrimitiveUP(	pBuffs[i]->ePrimitiveType, 
										pBuffs[i]->nPrimitiveCount,
										pBuffs[i]->pVertices,
										pBuffs[i]->dwPrimitiveSize );
			}
		}

#ifdef _DEBUG
		CN3Base::s_RenderInfo.nAlpha_Polygon += pBuffs[i]->nPrimitiveCount / 3; // Rendering Information Update...
#endif
	}
		
	m_nToDrawCount = 0; // 다 그렸다...

	// restore
	if(RS_old.dwAlpha != RS_current.dwAlpha) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, RS_old.dwAlpha);
	if(RS_old.dwFog != RS_current.dwFog) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, RS_old.dwFog);
	if(RS_old.dwCull != RS_current.dwCull) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, RS_old.dwCull);
	if(RS_old.dwLgt != RS_current.dwLgt) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, RS_old.dwLgt);
	if(RS_old.dwZWrite != RS_current.dwZWrite) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, RS_old.dwZWrite);
	if(RS_old.dwSrcBlend != RS_current.dwSrcBlend) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,  RS_old.dwSrcBlend );
	if(RS_old.dwDestBlend != RS_current.dwDestBlend) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, RS_old.dwDestBlend);
	if(RS_old.dwAO != RS_current.dwAO) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   RS_old.dwAO);
	if(RS_old.dwAA1 != RS_current.dwAA1) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, RS_old.dwAA1);
	if(RS_old.dwAA2 != RS_current.dwAA2) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, RS_old.dwAA2);
	if(RS_old.dwCO != RS_current.dwCO) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   RS_old.dwCO);
	if(RS_old.dwCA1 != RS_current.dwCA1) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, RS_old.dwCA1);
	if(RS_old.dwCA2 != RS_current.dwCA2) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, RS_old.dwCA2);
	if(RS_old.dwPointSampling != RS_current.dwPointSampling) CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_MIPFILTER, RS_old.dwPointSampling);

*/

}

__AlphaPrimitive* CN3AlphaPrimitiveManager::Add()
{
//	__ASSERT(m_nToDrawCount < MAX_ALPHAPRIMITIVE_BUFFER, "Alpha Primitive Manager : Overflow Buffer.");
	if(m_nToDrawCount >= MAX_ALPHAPRIMITIVE_BUFFER) return nullptr;
	m_nToDrawCount++;
	return &(m_Buffers[m_nToDrawCount-1]);
}

/*
__AlphaPrimitive* CN3AlphaPrimitiveManager::Add(	__Vector3& vCamera, 
													uint32_t dwBlendSrc, 
													uint32_t dwBlendDest, 
													int	nRenderFlags, 
													LPDIRECT3DTEXTURE8 lpTex, 
													uint32_t dwFVF, 
													int nPrimitiveCount, 
													D3DPRIMITIVETYPE ePrimitiveType, 
													uint32_t dwPrimitiveSize, 
													BOOL bUseVB,
													const void* pwIndices, 
													int nVertexCount,
													const void* pVertices,
													const __Matrix44& MtxWorld )
{
	__ASSERT(m_nToDrawCount < MAX_ALPHAPRIMITIVE_BUFFER, "Alpha primnitive buffer is full");
	// 메인렌더링시 반드시 이 클래스의 Render() 를 한번 호출해주어야 버퍼를 비워준다..

	__Vector3 vPos = *((__Vector3*)pVertices);

	m_Buffers[m_nToDrawCount].fCameraDistance	= (vCamera - vPos).Magnitude();
	m_Buffers[m_nToDrawCount].dwBlendSrc		= dwBlendSrc;
	m_Buffers[m_nToDrawCount].dwBlendDest		= dwBlendDest;
	m_Buffers[m_nToDrawCount].nRenderFlags		= nRenderFlags;
	m_Buffers[m_nToDrawCount].lpTex				= lpTex;
	m_Buffers[m_nToDrawCount].dwFVF				= dwFVF;
	m_Buffers[m_nToDrawCount].nPrimitiveCount	= nPrimitiveCount;
	m_Buffers[m_nToDrawCount].ePrimitiveType	= ePrimitiveType;
	m_Buffers[m_nToDrawCount].dwPrimitiveSize	= dwPrimitiveSize;
	m_Buffers[m_nToDrawCount].bUseVB			= bUseVB;
	m_Buffers[m_nToDrawCount].pwIndices			= pwIndices;
	m_Buffers[m_nToDrawCount].nVertexCount		= nVertexCount;
	m_Buffers[m_nToDrawCount].pVertices			= pVertices;
	m_Buffers[m_nToDrawCount].MtxWorld			= MtxWorld;

	m_nToDrawCount++;
	return &(m_Buffers[m_nToDrawCount-1]);
}
*/

int CN3AlphaPrimitiveManager::SortByCameraDistance(const void *pArg1, const void *pArg2)
{
	__AlphaPrimitive *pObj1 = *((__AlphaPrimitive**)pArg1);
	__AlphaPrimitive *pObj2 = *((__AlphaPrimitive**)pArg2);

	if(pObj1->fCameraDistance > pObj2->fCameraDistance) return -1; // 거리가 먼것부터 소팅..
	else if(pObj1->fCameraDistance < pObj2->fCameraDistance) return 1;
	else return 0;
}

// ===== END N3Base/N3AlphaPrimitiveManager.cpp =====

// ===== BEGIN N3Base/N3AlphaPrimitiveManager.h =====
#line 1 "N3Base/N3AlphaPrimitiveManager.h"
﻿// N3AlphaPrimitiveManager.h: interface for the CN3AlphaPrimitiveManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3ALPHAPRIMITIVEMANAGER_H__616E318C_49E4_4468_9719_E62E384FC48D__INCLUDED_)
#define AFX_N3ALPHAPRIMITIVEMANAGER_H__616E318C_49E4_4468_9719_E62E384FC48D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "My_3DStruct.h"

//const uint32_t RF_NOTHING = 0;
//const uint32_t RF_ALPHABLENDING = 1;
//const uint32_t RF_NOTUSEFOG = 2;
//const uint32_t RF_DOUBLESIDED = 4;

struct __AlphaPrimitive
{
	float				fCameraDistance;	// 카메라와의 거리..
	uint32_t				dwBlendSrc;			
	uint32_t				dwBlendDest;
	int 				nRenderFlags;		// 렌더링 플래그.. RF_... 참조..
	LPDIRECT3DTEXTURE9	lpTex;				// Texture pointer
	uint32_t				dwFVF;				// flexible vertex format
	D3DPRIMITIVETYPE	ePrimitiveType;	// Primitive Type 
	int					nPrimitiveCount;	// PrimitiveCount
	uint32_t				dwPrimitiveSize;	// Primitive Size .. stream 0 stride
	BOOL				bUseVB;				// 버텍스 버퍼, 인덱스 버퍼를 사용할 것인가 아닌가
	const void*			pwIndices;			// 만약 Index 기반이면... nullptr 이 아닌것을 넣으면 된다.
	int					nVertexCount;
	const void*			pVertices;			// 삼각형.. 벡터 형이지만.. 강제 형변환을 통해 다양한 점형식이 들어오도록 써야 한다..
	__Matrix44			MtxWorld;			// Matrix
};

const int MAX_ALPHAPRIMITIVE_BUFFER = 1024;

class CN3AlphaPrimitiveManager
{
protected:
	int					m_nToDrawCount; // 그려야 할 버퍼 갯수 
	__AlphaPrimitive	m_Buffers[MAX_ALPHAPRIMITIVE_BUFFER]; // 프리미티브 버퍼..

public:
	int					ToDrawCount() { return m_nToDrawCount; }
	__AlphaPrimitive*	Add();

	void		Render();

	static int SortByCameraDistance(const void *pArg1, const void *pArg2); // 정렬 함수..
	
	CN3AlphaPrimitiveManager();
	virtual ~CN3AlphaPrimitiveManager();
};

#endif // !defined(AFX_N3ALPHAPRIMITIVEMANAGER_H__616E318C_49E4_4468_9719_E62E384FC48D__INCLUDED_)

// ===== END N3Base/N3AlphaPrimitiveManager.h =====

// ===== BEGIN N3Base/N3AnimControl.cpp =====
#line 1 "N3Base/N3AnimControl.cpp"
﻿// N3AnimControl.cpp: implementation of the CN3AnimControl class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3AnimControl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3AnimControl::CN3AnimControl()
{
	m_dwType |= OBJ_ANIM_CONTROL;
}

CN3AnimControl::~CN3AnimControl()
{
}

void CN3AnimControl::Release()
{
	m_Datas.clear(); // animation Data List

	CN3BaseFileAccess::Release();
}

bool CN3AnimControl::Load(File& file)
{
	if (!m_Datas.empty())
		Release();

	int nCount = 0;
	file.Read(&nCount, 4);

	m_Datas.clear(); // animation Data List
	for (int i = 0; i < nCount; i++)
	{
		__AnimData Data;
		Data.Load(file);
		m_Datas.push_back(Data);
	}

	return true;
}

#ifdef _N3TOOL
bool CN3AnimControl::Save(File& file)
{
	int nL = 0;
	int iSize = static_cast<int>(m_Datas.size());
	file.Write(&iSize, 4);

	for (int i = 0; i < iSize; i++)
		m_Datas[i].Save(file);

	return true;
}
#endif // endof #ifdef _N3TOOL

#ifdef _N3TOOL
__AnimData* CN3AnimControl::Add()
{
	__AnimData Data;
	Data.szName = "No Name";
	m_Datas.push_back(Data);

	return &(m_Datas[m_Datas.size() - 1]);
}
#endif // endof #ifdef _N3TOOL

#ifdef _N3TOOL
__AnimData* CN3AnimControl::Insert(int nIndex)
{
	if (nIndex < 0
		|| nIndex >= static_cast<int>(m_Datas.size()))
		return nullptr;
	
	it_Ani it = m_Datas.begin();
	for(int i = 0; i < nIndex; i++, it++);

	__AnimData Data;
	Data.szName = "No Name";
	it = m_Datas.insert(it, Data);

	return &(*it);
}
#endif // endof #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3AnimControl::Swap(int nAni1, int nAni2)
{
	if (nAni1 == nAni2)
		return;

	if (nAni1 < 0
		|| nAni1 >= static_cast<int>(m_Datas.size()))
		return;

	if (nAni2 < 0
		|| nAni2 >= static_cast<int>(m_Datas.size()))
		return;

	__AnimData Tmp = m_Datas[nAni2];
	m_Datas[nAni2] = m_Datas[nAni1];
	m_Datas[nAni1] = Tmp;
}
#endif // endof #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3AnimControl::Delete(int nIndex)
{
	if (nIndex < 0
		|| nIndex >= static_cast<int>(m_Datas.size()))
		return;

	it_Ani it = m_Datas.begin();
	for(int i = 0; i < nIndex; i++, it++);

	m_Datas.erase(it);
}
#endif // endof #ifdef _N3TOOL

// ===== END N3Base/N3AnimControl.cpp =====

// ===== BEGIN N3Base/N3AnimControl.h =====
#line 1 "N3Base/N3AnimControl.h"
﻿// N3AnimControl.h: interface for the CN3AnimControl class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3ANIMCONTROL_H__37E9A095_FF76_4DD5_95A2_4CA1ABC227B0__INCLUDED_)
#define AFX_N3ANIMCONTROL_H__37E9A095_FF76_4DD5_95A2_4CA1ABC227B0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"
#include <string>
#include <vector>

typedef struct __AnimData
{
	friend CN3AnimControl;
public:
	std::string	szName;

	float	fFrmStart; // 상체 시작
	float	fFrmEnd; // 상체 끝
	float	fFrmPerSec; // 초당 30프레임이 표준이다..

	float	fFrmPlugTraceStart;
	float	fFrmPlugTraceEnd;
	
	float	fFrmSound0;
	float	fFrmSound1;

	float	fTimeBlend; // 다른 동작과 연결시 블렌딩 시간
	int		iBlendFlags; // 블렌딩 플래그 0 이면 걍 블렌딩.. 1이면 루핑시 블렌딩 타임만큼 시간 지연
	
	float	fFrmStrike0;
	float	fFrmStrike1;
	
	__AnimData()
	{
		fFrmPerSec = 30.0f; // 초당 30프레임이 표준이다..

		fFrmStart = fFrmEnd = 0;
		fFrmPlugTraceStart = fFrmPlugTraceEnd = 0;
		fFrmSound0 = fFrmSound1 = 0;
		fTimeBlend = 0.25f; // 기본 블렌딩 시간..
		iBlendFlags = 0; // 블렌딩 플래그 0 이면 걍 블렌딩.. 1이면 루핑시 블렌딩 타임만큼 시간 지연
		fFrmStrike0 = fFrmStrike1 = 0;
	}
	
	void operator = (const __AnimData& other)
	{
		fFrmStart = other.fFrmStart;
		fFrmEnd = other.fFrmEnd;
		fFrmPerSec = other.fFrmPerSec;

		fFrmPlugTraceStart = other.fFrmPlugTraceStart;
		fFrmPlugTraceEnd = other.fFrmPlugTraceEnd;

		fFrmSound0 = other.fFrmSound0;
		fFrmSound1 = other.fFrmSound1;

		fTimeBlend = other.fTimeBlend;
		iBlendFlags = other.iBlendFlags; // 블렌딩 플래그 0 이면 걍 블렌딩.. 1이면 루핑시 블렌딩 타임만큼 시간 지연
		
		fFrmStrike0 = other.fFrmStrike0;
		fFrmStrike1 = other.fFrmStrike1;

		szName = other.szName;
	}

	void Load(File& file)
	{
		int nL = 0;
		file.Read(&nL, 4); // 원래는 문자열 포인터가 있던자리이다.. 호환성을 위헤서.. 걍...

		file.Read(&fFrmStart, 4); // 상체 시작
		file.Read(&fFrmEnd, 4); // 상체 끝
		file.Read(&fFrmPerSec, 4); // 초당 30프레임이 표준이다..

		file.Read(&fFrmPlugTraceStart, 4);
		file.Read(&fFrmPlugTraceEnd, 4);
		
		file.Read(&fFrmSound0, 4);
		file.Read(&fFrmSound1, 4);

		file.Read(&fTimeBlend, 4);
		file.Read(&iBlendFlags, 4); // 블렌딩 플래그 0 이면 걍 블렌딩.. 1이면 루핑시 블렌딩 타임만큼 시간 지연
		
		file.Read(&fFrmStrike0, 4);
		file.Read(&fFrmStrike1, 4);

		// 이름 읽기..
		file.Read(&nL, 4);
		if (nL > 0)
		{
			szName.assign(nL, '\0');
			file.Read(&szName[0], nL);
		}
		else
		{
			szName.clear();
		}
	}

	void Save(File& file)
	{
		int nL = 0;
		file.Write(&nL, 4); // 원래는 문자열 포인터가 있던자리이다.. 호환성을 위헤서.. 걍...

		file.Write(&fFrmStart, 4); // 상체 시작
		file.Write(&fFrmEnd, 4); // 상체 끝
		file.Write(&fFrmPerSec, 4); // 초당 30프레임이 표준이다..

		file.Write(&fFrmPlugTraceStart, 4);
		file.Write(&fFrmPlugTraceEnd, 4);
		
		file.Write(&fFrmSound0, 4);
		file.Write(&fFrmSound1, 4);

		file.Write(&fTimeBlend, 4);
		file.Write(&iBlendFlags, 4); // 블렌딩 플래그 0 이면 걍 블렌딩.. 1이면 루핑시 블렌딩 타임만큼 시간 지연
		
		file.Write(&fFrmStrike0, 4);
		file.Write(&fFrmStrike1, 4);

		// 이름 읽기..
		nL = static_cast<int>(szName.size());
		file.Write(&nL, 4);
		if (nL > 0)
			file.Write(szName.c_str(), nL);
	}

#ifdef _N3TOOL
	void Offset(float fFrmOffset)
	{
		if(fFrmStart != 0) fFrmStart += fFrmOffset;
		if(fFrmEnd != 0) fFrmEnd += fFrmOffset;

		if(fFrmPlugTraceStart != 0) fFrmPlugTraceStart += fFrmOffset;
		if(fFrmPlugTraceEnd != 0) fFrmPlugTraceEnd += fFrmOffset;

		if(fFrmSound0 != 0) fFrmSound0 += fFrmOffset;
		if(fFrmSound1 != 0) fFrmSound1 += fFrmOffset;

		if(fFrmStrike0 != 0) fFrmStrike0 += fFrmOffset;
		if(fFrmStrike1 != 0) fFrmStrike1 += fFrmOffset;
	}
#endif

} __AnimData;

typedef std::vector<__AnimData>::iterator it_Ani;

class CN3AnimControl : public CN3BaseFileAccess
{
protected:
	std::vector<__AnimData>		m_Datas; // animation Data List

public:
	__AnimData* DataGet(int index)
	{
		if (index < 0
			|| index >= static_cast<int>(m_Datas.size()))
			return nullptr;

		return &m_Datas[index];
	}

	bool Load(File& file) override;

	int Count() const
	{
		return static_cast<int>(m_Datas.size());
	}

#ifdef _N3TOOL
	__AnimData*		DataGet(const std::string& szName)
	{
		int iADC = static_cast<int>(m_Datas.size());
		for(int i = 0; i < iADC; i++)
		{
			if(szName == m_Datas[i].szName) return &(m_Datas[i]);
		}
		return nullptr;
	}
	void			Swap(int nAni1, int nAni2);
	void			Delete(int nIndex);
	__AnimData*		Add();
	__AnimData*		Insert(int nIndex);
	bool			Save(File& file) override;
#endif
	void Release() override;
	
	CN3AnimControl();
	~CN3AnimControl() override;

};

#endif // !defined(AFX_N3ANIMCONTROL_H__37E9A095_FF76_4DD5_95A2_4CA1ABC227B0__INCLUDED_)

// ===== END N3Base/N3AnimControl.h =====

// ===== BEGIN N3Base/N3AnimKey.cpp =====
#line 1 "N3Base/N3AnimKey.cpp"
﻿// N3AnimKey.cpp: implementation of the CN3AnimKey class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3AnimKey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3AnimKey::CN3AnimKey()
{
	m_eType = KEY_VECTOR3;

	m_nCount = 0; // 키 카운트
	m_fSamplingRate = 30.0;
	m_pDatas = nullptr;
}

CN3AnimKey::~CN3AnimKey()
{
	delete [] m_pDatas; m_pDatas = nullptr;
}

void CN3AnimKey::Release()
{
	m_nCount = 0; // 키 카운트
	m_fSamplingRate = 30.0;
	delete [] m_pDatas; m_pDatas = nullptr;

	CN3Base::Release();
}

void CN3AnimKey::Alloc(int nCount, float fSamplingRate, ANIMATION_KEY_TYPE eType)
{
	if(nCount <= 0) return;
	if(KEY_VECTOR3 != eType && KEY_QUATERNION != eType) return;
	if(fSamplingRate <= 0.0f)
	{
		__ASSERT(0, "Animation Sampling Rate 는 반드시 0 보다 커야 합니다.");
		return;
	}

	if(m_pDatas != nullptr)
	{
		delete [] m_pDatas; m_pDatas = nullptr;
		m_nCount = 0;
	}

	m_eType = eType;
	m_nCount = nCount;
	m_fSamplingRate = fSamplingRate;

	if(KEY_VECTOR3 == m_eType)
	{
		m_pDatas = new __Vector3[nCount+1]; // 한개 더 여유있게 할당.
		memset(m_pDatas, 0, sizeof(__Vector3) * (nCount+1));
	}
	else if(KEY_QUATERNION == m_eType)
	{
		m_pDatas = new __Quaternion[nCount+1]; // 한개 더 여유있게 할당.
		memset(m_pDatas, 0, sizeof(__Quaternion) * (nCount+1));
	}
}

bool CN3AnimKey::Load(File& file)
{
	if (m_nCount > 0)
		Release();

	file.Read(&m_nCount, 4); // 키가 몇개 있는지

	// 키값을 파일에서 읽기..
	if (m_nCount > 0)
	{
		file.Read(&m_eType, 4); // Key Type
		file.Read(&m_fSamplingRate, 4); // Sampling Rate

		Alloc(m_nCount, m_fSamplingRate, m_eType);

		if (KEY_VECTOR3 == m_eType)
		{
			file.Read(m_pDatas, sizeof(__Vector3) * m_nCount);
			__Vector3* pKeys = (__Vector3*) m_pDatas; // 끝에 하나더 복사해준다.
			pKeys[m_nCount] = pKeys[m_nCount - 1];
		}
		else if (KEY_QUATERNION == m_eType)
		{
			file.Read(m_pDatas, sizeof(__Quaternion) * m_nCount);
			__Quaternion* pKeys = (__Quaternion*) m_pDatas; // 끝에 하나더 복사해준다.
			pKeys[m_nCount] = pKeys[m_nCount - 1];
		}
	}

	return true;
}

#ifdef _N3TOOL
bool CN3AnimKey::Save(File& file)
{
	file.Write(&m_nCount, 4); // 키가 몇개 있는지

	if (m_nCount > 0)
	{
		file.Write(&m_eType, 4); // Key Type
		file.Write(&m_fSamplingRate, 4); // Sampling Rate

		if (KEY_VECTOR3 == m_eType)
			file.Write(m_pDatas, sizeof(__Vector3) * m_nCount);
		else if (KEY_QUATERNION == m_eType)
			file.Write(m_pDatas, sizeof(__Quaternion) * m_nCount);
	}

	return true;
}
#endif // end of #ifdef _N3TOOL

/*
void CN3AnimKey::Translate(int nIndexStart, int nIndexEnd, float fDelta, int nKFlags)
{
	if(nIndexStart < 0 || nIndexStart >= m_nCount) return;
	if(nIndexEnd < 0 || nIndexEnd >= m_nCount) return;

	for(int i = nIndexStart; i <= nIndexEnd; i++)
	{
		if(nKFlags & 1) m_pDatas[i].x += fDelta;
		if(nKFlags & 2) m_pDatas[i].y += fDelta;
		if(nKFlags & 4) m_pDatas[i].z += fDelta;
	}
}
*/
#ifdef _N3TOOL
void CN3AnimKey::Add(CN3AnimKey &AKSrc, int nIndexS, int nIndexE)
{
	if(AKSrc.Count() <= 0) return;
	if(nIndexE < nIndexS) return;
	if(this->Type() != AKSrc.Type()) return;

	int nAddCount = nIndexE - nIndexS + 1; // 추가할 갯수

	int nPrevCount = m_nCount;
	void* pVBackup = nullptr;
	if(nPrevCount > 0) // backup
	{
		if(KEY_VECTOR3 == m_eType)
		{
			pVBackup = new __Vector3[nPrevCount];
			memcpy(pVBackup, m_pDatas, sizeof(__Vector3) * nPrevCount);
		}
		else if(KEY_QUATERNION == m_eType)
		{
			pVBackup = new __Quaternion[nPrevCount];
			memcpy(pVBackup, m_pDatas, sizeof(__Quaternion) * nPrevCount);
		}
	}

	this->Alloc(nPrevCount + nAddCount, AKSrc.SamplingRate(), AKSrc.Type()); // 새로 할당.
	if(nPrevCount > 0)
	{
		if(KEY_VECTOR3 == m_eType)
		{
			memcpy(m_pDatas, pVBackup, sizeof(__Vector3) * nPrevCount); // 백업받은걸 restore
		}
		else if(KEY_QUATERNION == m_eType)
		{
			memcpy(m_pDatas, pVBackup, sizeof(__Quaternion) * nPrevCount); // 백업받은걸 restore
		}
	}

	if(KEY_VECTOR3 == m_eType)
	{
		for(int i = 0; i < nAddCount; i++) // 추가.
		{
			__Vector3* pvTmp = (__Vector3*)AKSrc.DataGet(nIndexS + i);
			if(pvTmp) ((__Vector3*)m_pDatas)[nPrevCount + i] = *pvTmp;
			else ((__Vector3*)m_pDatas)[nPrevCount + i].Zero();
		}
	}
	else if(KEY_QUATERNION == m_eType)
	{
		for(int i = 0; i < nAddCount; i++) // 추가.
		{
			__Quaternion* pvTmp = (__Quaternion*)AKSrc.DataGet(nIndexS + i);
			if(pvTmp) ((__Quaternion*)m_pDatas)[nPrevCount + i] = *pvTmp;
			else
			{
				((__Quaternion*)m_pDatas)[nPrevCount + i].x = 
				((__Quaternion*)m_pDatas)[nPrevCount + i].y = 
				((__Quaternion*)m_pDatas)[nPrevCount + i].z = 
				((__Quaternion*)m_pDatas)[nPrevCount + i].w = 0;
			}
		}
	}

	delete [] pVBackup; pVBackup = nullptr;
}
#endif // end of _N3TOOL

void CN3AnimKey::Duplicate(CN3AnimKey* pSrc)
{
	if(m_nCount > 0) this->Release();

	m_nCount = pSrc->Count();

	// 키값을 파일에서 읽기..
	if(m_nCount > 0)
	{
		m_eType = pSrc->Type();
		m_fSamplingRate = pSrc->SamplingRate();

		this->Alloc(m_nCount, m_fSamplingRate, m_eType);

		if(KEY_VECTOR3 == m_eType)
		{
			char* pData = (char*)pSrc->GetDatas();
			memcpy(m_pDatas, pData, sizeof(__Vector3)*m_nCount);
		}
		else if(KEY_QUATERNION == m_eType)
		{
			char* pData = (char*)pSrc->GetDatas();
			memcpy(m_pDatas, pData, sizeof(__Quaternion)*m_nCount);
		}
	}	
}

void CN3AnimKey::MultiplyDataVector(__Vector3 vM)
{
	if(KEY_VECTOR3 != m_eType) return;

	for(int i=0;i<m_nCount;i++)
	{
		__Vector3 vT = ((__Vector3*)m_pDatas)[i];
		vT*=vM;
		((__Vector3*)m_pDatas)[i] = vT;
	}
}

// ===== END N3Base/N3AnimKey.cpp =====

// ===== BEGIN N3Base/N3AnimKey.h =====
#line 1 "N3Base/N3AnimKey.h"
﻿// AniKeyPos.h: interface for the CAniKeyPos class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3AnimKey_h__INCLUDED_)
#define AFX_N3AnimKey_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"

enum ANIMATION_KEY_TYPE { 
	KEY_VECTOR3 = 0,
	KEY_QUATERNION = 1,
	KEY_UNKNOWN = 0xffffffff
}; 

class CN3AnimKey : CN3Base
{
	friend class CN3Joint;
protected:
	ANIMATION_KEY_TYPE m_eType; // Key Type - Position Rotation Scale
	int		m_nCount; // 키 카운트
	float	m_fSamplingRate; // Sampling Rate - 표준은 30 Frame Per Sec 이다..
	void*	m_pDatas;

public:
	ANIMATION_KEY_TYPE Type() { return m_eType; } // 키 형태, 벡터워 쿼터니언 형태가 있다..
	void	Add(CN3AnimKey& AKSrc, int nIndexS, int nIndexE);
//	void	Translate(int nIndexStart, int nIndexEnd, float fDelta, int nKFlags);
	bool DataGet(float fFrm, __Vector3& v)
	{
		if(KEY_VECTOR3 != m_eType) return false;
		if(m_nCount <= 0) return false;
		
		float fD = 30.0f / m_fSamplingRate;
		
		int nIndex = (int)(fFrm * (m_fSamplingRate / 30.0f));
		if(nIndex < 0 || nIndex > m_nCount) return false;
		
		float fDelta = 0;
		if(nIndex == m_nCount) { nIndex = m_nCount - 1; fDelta = 0; }
		else fDelta = (fFrm - nIndex * fD)/fD;
		
		if(0.0f != fDelta) { v = (((__Vector3*)m_pDatas)[nIndex] * (1.0f - fDelta)) + (((__Vector3*)m_pDatas)[nIndex+1] * fDelta); }
		else v = ((__Vector3*)m_pDatas)[nIndex];
		return true;
	}
	bool DataGet(float fFrm, __Quaternion& q)
	{
		if(KEY_QUATERNION != m_eType) return false;
		if(m_nCount <= 0) return false;

		float fD = 30.0f / m_fSamplingRate;

		int nIndex = (int)(fFrm * (m_fSamplingRate / 30.0f));
		if(nIndex < 0 || nIndex > m_nCount) return false;

		float fDelta = 0;
		if(nIndex == m_nCount) { nIndex = m_nCount - 1; fDelta = 0; }
		else fDelta = (fFrm - nIndex * fD)/fD;

		if(0.0f != fDelta) q.Slerp(((__Quaternion*)m_pDatas)[nIndex], ((__Quaternion*)m_pDatas)[nIndex+1], fDelta);
		else q = ((__Quaternion*)m_pDatas)[nIndex];
		return true;
	}
	
	bool Load(File& file);

#ifdef _N3TOOL
	void*	DataGet(int index) 
	{
		if(index < 0 || index >= m_nCount) return nullptr;
		else if(KEY_VECTOR3 == m_eType) return &(((__Vector3*)m_pDatas)[index]);
		else if(KEY_QUATERNION == m_eType) return &(((__Quaternion*)m_pDatas)[index]);
		else return nullptr;
	}
	bool Save(File& file);
#endif // end of
	
	int Count() { return m_nCount; }
	float SamplingRate() { return m_fSamplingRate; }
	void Release();
	void Alloc(int nCount, float fSamplingRate = 30.0f, ANIMATION_KEY_TYPE eType = KEY_VECTOR3);
	
	void Duplicate(CN3AnimKey* pSrc);
	void*	GetDatas() { return m_pDatas; }
	void MultiplyDataVector(__Vector3 vM);
	
	CN3AnimKey();
	virtual ~CN3AnimKey();
};

#endif // !defined(AFX_N3AnimKey_h__INCLUDED_)

// ===== END N3Base/N3AnimKey.h =====

// ===== BEGIN N3Base/N3Base.cpp =====
#line 1 "N3Base/N3Base.cpp"
﻿// N3Base.cpp: implementation of the CN3Base class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Mesh.h"
#include "N3VMesh.h"
#include "N3PMesh.h"
#include "N3FXPMesh.h"
#include "N3FXShape.h"
#include "N3Chr.h"
#include "N3Base.h"
#include "mmsystem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
LPDIRECT3DDEVICE9 CN3Base::s_lpD3DDev	= nullptr;			// 참조 포인터.. 멋대로 해제하면 안된다..
uint32_t CN3Base::s_dwTextureCaps		= 0;			// Texture 호환성..
float CN3Base::s_fFrmPerSec				= 30.0f;		// Frame Per Second
float CN3Base::s_fSecPerFrm				= 1.0f/30.0f;	// Second per Frame
HWND CN3Base::s_hWndBase				= nullptr;			// Init 할때 쓴 Window Handle
HWND CN3Base::s_hWndPresent				= nullptr;			// 최근에 Present 한 Window Handle

D3DPRESENT_PARAMETERS CN3Base::s_DevParam;	// Device 생성 Present Parameter
D3DCAPS9 CN3Base::s_DevCaps;				// Device 호환성...
std::string CN3Base::s_szPath;

__CameraData CN3Base::s_CameraData;			// Camera Data
__ResrcInfo CN3Base::s_ResrcInfo;			// Rendering Information
__Options CN3Base::s_Options;	// 각종 옵션등...
#ifdef _DEBUG
__RenderInfo CN3Base::s_RenderInfo;			// Rendering Information
#endif

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
CN3SndMgr CN3Base::s_SndMgr;	//사운드 메니저.
#endif
#ifdef _N3TOOL	// ui 에디터일때는 필요하다.
CN3SndMgr CN3Base::s_SndMgr;	//사운드 메니저.
#endif

CN3Mng<CN3Texture>		CN3Base::s_MngTex; // Texture Manager
CN3Mng<CN3Mesh>			CN3Base::s_MngMesh; // Mesh Manager
CN3Mng<CN3VMesh>		CN3Base::s_MngVMesh; // 단순히 폴리곤만 갖고 있는 메시 - 주로 충돌 체크에 쓴다..
CN3Mng<CN3PMesh>		CN3Base::s_MngPMesh; // Progressive Mesh Manager
CN3Mng<CN3Joint>		CN3Base::s_MngJoint; // Joint Manager
CN3Mng<CN3CPartSkins>	CN3Base::s_MngSkins; // Character Part Skins Manager
CN3Mng<CN3AnimControl>	CN3Base::s_MngAniCtrl; // Animation Manager
CN3Mng<CN3FXPMesh>		CN3Base::s_MngFXPMesh; // FX에서 쓰는 PMesh - 파일은 일반 PMesh를 쓰지만 속은 다르다.
CN3Mng<CN3FXShape>		CN3Base::s_MngFXShape; // FX에서 쓰는 Shape - 파일은 일반 shape를 쓰지만 속은 다르다.	

CN3AlphaPrimitiveManager	CN3Base::s_AlphaMgr;  // Alpha blend 할 폴리곤들을 관리.. 추가했다가.. 카메라 거리에 ?上?정렬하고 한꺼번에 그린다..

#ifdef _N3GAME
CLogWriter g_Log; // 로그 남기기...
#endif

CN3Base::CN3Base()
{
	m_dwType = OBJ_BASE; // "MESH", "CAMERA", "SCENE", "???" .... 등등등...
	m_szName = "";
}

CN3Base::~CN3Base()
{
}

void CN3Base::Release()
{
	m_szName = "";
}

void CN3Base::ReleaseResrc()
{
	s_MngTex.Release();
	s_MngMesh.Release();
	s_MngPMesh.Release();
	s_MngVMesh.Release();
	
	s_MngJoint.Release();
	s_MngSkins.Release();
	s_MngAniCtrl.Release();

	s_MngFXPMesh.Release();
	s_MngFXShape.Release();
}

#ifdef _N3TOOL
void CN3Base::SaveResrc()
{
	s_MngTex.SaveToFiles();
	s_MngMesh.SaveToFiles();
	s_MngPMesh.SaveToFiles();
	s_MngVMesh.SaveToFiles();
	
	s_MngJoint.SaveToFiles();
	s_MngSkins.SaveToFiles();
	s_MngAniCtrl.SaveToFiles();

	s_MngFXPMesh.SaveToFiles();
	s_MngFXShape.SaveToFiles();
}
#endif // end of _N3TOOL

//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
float CN3Base::TimerProcess( TIMER_COMMAND command )
{
    static BOOL     m_bTimerInitialized = FALSE;
    static BOOL     m_bUsingQPF         = FALSE;
    static LONGLONG m_llQPFTicksPerSec  = 0;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
        // not supported, we will timeGetTime() which returns milliseconds.
        LARGE_INTEGER qwTicksPerSec;
        m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );
        if( m_bUsingQPF )
            m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
    }

    if( m_bUsingQPF )
    {
        static LONGLONG m_llStopTime        = 0;
        static LONGLONG m_llLastElapsedTime = 0;
        static LONGLONG m_llBaseTime        = 0;
        double fTime;
        double fElapsedTime;
        LARGE_INTEGER qwTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            qwTime.QuadPart = m_llStopTime;
        else
            QueryPerformanceCounter( &qwTime );

        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {
            fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;
            m_llLastElapsedTime = qwTime.QuadPart;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;
            return (FLOAT) fAppTime;
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_llBaseTime        = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            m_llBaseTime += qwTime.QuadPart - m_llStopTime;
            m_llStopTime = 0;
            m_llLastElapsedTime = qwTime.QuadPart;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_llStopTime = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_llStopTime += m_llQPFTicksPerSec/10;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
    else
    {
        // Get the time using timeGetTime()
        static double m_fLastElapsedTime  = 0.0;
        static double m_fBaseTime         = 0.0;
        static double m_fStopTime         = 0.0;
        double fTime;
        double fElapsedTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            fTime = m_fStopTime;
        else
            fTime = timeGetTime() * 0.001;
    
        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {   
            fElapsedTime = (double) (fTime - m_fLastElapsedTime);
            m_fLastElapsedTime = fTime;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            return (FLOAT) (fTime - m_fBaseTime);
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_fBaseTime         = fTime;
            m_fLastElapsedTime  = fTime;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            m_fBaseTime += fTime - m_fStopTime;
            m_fStopTime = 0.0f;
            m_fLastElapsedTime  = fTime;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_fStopTime = fTime;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_fStopTime += 0.1f;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
}

void CN3Base::PathSet(const std::string& szPath)
{
	s_szPath = szPath;
	if(s_szPath.size() <= 0) return;

	// NOTE: this puts the entire string into lowercase characters
	CharLower(&(s_szPath[0])); // make sure to give lowercase
	if(s_szPath.size() > 1)
	{
		// NOTE: this checks if the last character is '\'; if not it will add it
		if(s_szPath[s_szPath.size()-1] != '\\') s_szPath += '\\';
	}
}

void CN3Base::RenderLines(const __Vector3 *pvLines, int nCount, D3DCOLOR color)
{
	DWORD dwAlpha, dwFog, dwLight;
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	
	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
	
	static __Material smtl;
	static bool bInit = false;
	if(false == bInit)
	{
		smtl.Init();
		bInit = true;
	}

	s_lpD3DDev->SetTexture(0, nullptr);

	static __VertexColor svLines[512];

	s_lpD3DDev->SetFVF(FVF_CV);

	int nRepeat = nCount/512;
	for(int i = 0; i < nRepeat; i++)
	{
		for(int j = 0; j < 512; j++) svLines[j].Set(pvLines[i*512+j].x, pvLines[i*512+j].y, pvLines[i*512+j].z, color);
		
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 511, svLines, sizeof(__VertexColor));
	}
	int nPC = nCount%512;
	for(int j = 0; j < nPC+1; j++) svLines[j].Set(pvLines[nRepeat*512+j].x, pvLines[nRepeat*512+j].y, pvLines[nRepeat*512+j].z, color);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, nPC, svLines, sizeof(__VertexColor)); // Y

	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
}

void CN3Base::RenderLines(const RECT& rc, D3DCOLOR color)
{
	static __VertexTransformedColor vLines[5];
	
	vLines[0].Set((float)rc.left, (float)rc.top, 0.9f, 1.0f, color);
	vLines[1].Set((float)rc.right, (float)rc.top, 0.9f, 1.0f, color);
	vLines[2].Set((float)rc.right, (float)rc.bottom, 0.9f, 1.0f, color);
	vLines[3].Set((float)rc.left, (float)rc.bottom, 0.9f, 1.0f, color);
	vLines[4] = vLines[0];

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, vLines, sizeof(__VertexTransformedColor));
	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

float CN3Base::TimeGet()
{
	static bool bInit = false;
	static bool bUseHWTimer = FALSE;
	static LARGE_INTEGER nTime, nFrequency;
	
	if(bInit == false)
	{
		if(TRUE == ::QueryPerformanceCounter(&nTime))
		{
			::QueryPerformanceFrequency(&nFrequency);
			bUseHWTimer = TRUE;
		}
		else 
		{
			bUseHWTimer = FALSE;
		}

		bInit = true;
	}

	if(bUseHWTimer)
	{
		::QueryPerformanceCounter(&nTime);
		return (float)((double)(nTime.QuadPart)/(double)nFrequency.QuadPart);
	}

	return (float)timeGetTime();
}

// ===== END N3Base/N3Base.cpp =====

// ===== BEGIN N3Base/N3Base.h =====
#line 1 "N3Base/N3Base.h"
﻿// N3Base.h: interface for the CN3Base class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Base_h__INCLUDED_)
#define AFX_N3Base_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "My_3DStruct.h"
#include "N3Mng.h"
#include "N3AlphaPrimitiveManager.h"
#ifdef _N3GAME
#include "LogWriter.h"
#endif

#include <string>

#if defined(_N3GAME) || defined(_N3TOOL)
#include "N3SndMgr.h"
#endif

const uint32_t TEX_CAPS_DXT1 =			0x00000001;
const uint32_t TEX_CAPS_DXT2 =			0x00000002;
const uint32_t TEX_CAPS_DXT3 =			0x00000004;
const uint32_t TEX_CAPS_DXT4 =			0x00000008;
const uint32_t TEX_CAPS_DXT5 =			0x00000010;
const uint32_t TEX_CAPS_SQUAREONLY =	0x00000020;
const uint32_t TEX_CAPS_MIPMAP =		0x00000040;
const uint32_t TEX_CAPS_POW2 =			0x00000080;

const float CAMERA_RADIUS_UNIT = 2.0f;
const int MAX_CAMERA_RADIUS = 512; // 2미터 단위로 128 개의 도트 프로덕트 미리 계산해 놓는다..

enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, TIMER_ADVANCE,
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME, TIMER_GETELAPSEDTIME };

struct __CameraData
{
	__CameraData()
	{
		vEye = {};
		vAt = {};
		vUp = {};

		fFOV = 0.0f;
		fAspect = 0.0f;
		fNP = 0.0f;
		fFP = 0.0f;

		vp = {};

		mtxView.Identity();
		mtxViewInverse.Identity();
		mtxProjection.Identity();

		memset(&fFrustum, 0, sizeof(fFrustum));
	}

	void Release()
	{
		*this = {};

		mtxView.Identity();
		mtxViewInverse.Identity();
		mtxProjection.Identity();
	}

	__Vector3		vEye; // Camera Position Vector
	__Vector3		vAt; // Camera At Vector
	__Vector3		vUp; // Camera Up Vector

	float			fFOV; // 카메라 렌즈 각 : Field Of View
//	float			fInverse_SineHalfOfFOV;
	float			fAspect; // 종횡비
	float			fNP; // NearPlane
	float			fFP; // FarPlane
	D3DVIEWPORT9	vp; // ViewPort;
	__Matrix44		mtxView;
	__Matrix44		mtxViewInverse;
	__Matrix44		mtxProjection;

	float			fFrustum [6][4];

	// fRadius - 물체의 반지름보다 약간 더 여유 있게 잡고 넣으면 그만큼 클리핑을 여유있게 한다..
	BOOL IsOutOfFrustum(const __Vector3& vPosition, float fRadius) 
		// 미리 계산된 카메라 평면의 도트 프로덕트 값을 기준으로 카메라 사면체 밖에 있으면  참을 돌려준다.
	{
		if((vEye - vPosition).Magnitude() > fFP + fRadius) 
			return TRUE; // Far Plane 거리체크

		int p;
		for( p = 0; p < 6; p++ )
		{
			if( fFrustum[p][0] * vPosition.x + fFrustum[p][1] * vPosition.y +
				fFrustum[p][2] * vPosition.z + fFrustum[p][3] <= -fRadius )
				return TRUE;
		}
		return FALSE;
	}
};

struct __RenderInfo
{
	int nShape;
	int nShape_Part;
	int nShape_Polygon; // 단순 폴리곤
	
	int nChr;
	int nChr_Part;
	int nChr_Polygon; // 캐릭터 폴리곤
	int nChr_Plug; // 캐릭터에 붙은 무기등..
	int	nChr_Plug_Polygon; // 캐릭터에 붙은 무기등의 폴리곤..

	int nTerrain_Polygon; // 타일 적용된 지형 폴리곤..
	int nTerrain_Tile_Polygon; // 타일 적용된 지형 폴리곤..

	int nAlpha_Polygon;
	
	int nTexture_32X32; // 32 X 32 Texture
	int nTexture_64X64; // 64 X 64 Texture
	int nTexture_128X128; // 128 X 128 Texture
	int nTexture_256X256; // 256 X 256 Texture
	int nTexture_512X512; // 512 X 512 Texture
	int nTexture_Huge; // 512 X 512 이상 size
	int nTexture_OtherSize; // Other size
};

struct __ResrcInfo
{
	int nTexture_Loaded_32X32; // 32 X 32 Texture
	int nTexture_Loaded_64X64; // 64 X 64 Texture
	int nTexture_Loaded_128X128; // 128 X 128 Texture
	int nTexture_Loaded_256X256; // 256 X 256 Texture
	int nTexture_Loaded_512X512; // 512 X 512 Texture
	int nTexture_Loaded_Huge; // 512 X 512 이상 size
	int nTexture_Loaded_OtherSize; // Other size
};

struct __Options
{
	int iUseShadow;
	int iTexLOD_Chr;			// 0 - 원래 크기.. 1 - 한단계 작게. 2 - 두단계 작게..
	int iTexLOD_Shape;			// 0 - 원래 크기.. 1 - 한단계 작게. 2 - 두단계 작게..
	int iTexLOD_Terrain;		// 0 - 원래 크기.. 1 - 한단계 작게. 2 - 두단계 작게..
	int iViewWidth;
	int iViewHeight;
	int iViewColorDepth;
	int iViewDist;
	int iEffectSndDist;			// 이펙트 사운드 거리

	bool bSndEnable;
	bool bSndBgmEnable;
	bool bSndEffectEnable;
	bool bSndDuplicated;	// 중복된 음원 사용

	bool bWindowCursor;		// 0 - 게임에서 그려주는 커서 1 - 윈도우 커서 사용
	bool bWindowMode;

	bool bVSyncEnabled;

	void InitDefault()        // Default options for client window
	{
		iUseShadow = true;
		iTexLOD_Chr = 0;
		iTexLOD_Shape = 0;
		iTexLOD_Terrain = 0;
		iViewColorDepth = 16;
		iViewWidth = 1024;
		iViewHeight = 768;
		iViewDist = 512;
		iEffectSndDist = 48;
		bSndEnable = false;
		bSndBgmEnable = false;
		bSndEffectEnable = false;
		bSndDuplicated = false;
		bWindowCursor = true;
		bWindowMode = false;
		bVSyncEnabled = true;
	}

	__Options()
	{
		InitDefault();
	}
};

class CN3Base
{
public:
	static LPDIRECT3DDEVICE9		s_lpD3DDev; // Device 참조 포인터.. 멋대로 해제하면 안된다..
	static D3DPRESENT_PARAMETERS	s_DevParam; // Device 생성 Present Parameter
	static D3DCAPS9					s_DevCaps; // Device 호환성...
	static uint32_t					s_dwTextureCaps; // Texture 지원.. DXT1 ~ DXT5, Square Only
	static HWND						s_hWndBase; // Init 할때 쓴 Window Handle
	static HWND						s_hWndPresent; // 최근에 Present 한 Window Handle

	static __CameraData				s_CameraData; // 카메라 데이터 정적 변수..
	static __ResrcInfo				s_ResrcInfo; // Rendering Information..
	static __Options				s_Options;	// 각종 옵션등...
#ifdef _DEBUG
	static __RenderInfo				s_RenderInfo; // Rendering Information..
#endif
	static float					s_fFrmPerSec; // Frame Per Second
	static float					s_fSecPerFrm; // Second Per Frame = 1.0f/s_fFrmPerSec (Dino가 추가)
	
#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	static CN3SndMgr				s_SndMgr;
#endif
#ifdef _N3TOOL	// ui 에디터일때는 필요하다.
	static CN3SndMgr				s_SndMgr;
#endif

	static CN3AlphaPrimitiveManager	s_AlphaMgr; // Alpha blend 할 폴리곤들을 관리.. 추가했다가.. 카메라 거리에 ?上?정렬하고 한꺼번에 그린다..

	static CN3Mng<class CN3Texture>		s_MngTex; // Texture Manager
	static CN3Mng<class CN3Mesh>		s_MngMesh; // Normal Mesh Manager
	static CN3Mng<class CN3VMesh>		s_MngVMesh; // 단순히 폴리곤만 갖고 있는 메시 - 주로 충돌 체크에 쓴다..
	static CN3Mng<class CN3PMesh>		s_MngPMesh; // Progressive Mesh Manager
	static CN3Mng<class CN3Joint>		s_MngJoint; // Joint Manager
	static CN3Mng<class CN3CPartSkins>	s_MngSkins; // Character Part Skin Manager
	static CN3Mng<class CN3AnimControl>	s_MngAniCtrl; // Animation Manager
	static CN3Mng<class CN3FXPMesh>		s_MngFXPMesh; // FX에서 쓰는 PMesh - 파일은 일반 PMesh를 쓰지만 속은 다르다.
	static CN3Mng<class CN3FXShape>		s_MngFXShape; // FX에서 쓰는 Shape - 파일은 일반 shape를 쓰지만 속은 다르다.
	

protected:
	static std::string 				s_szPath; // 프로그램이 실행된 경로.. 

protected:
	uint32_t							m_dwType; // "MESH", "CAMERA", "SCENE", "???" .... 등등등...

public:
	std::string 					m_szName;

public:
	static float		TimeGet();
	static const std::string& 	PathGet() { return s_szPath; }
	static void			PathSet(const std::string& szPath);
	
	static void			RenderLines(const __Vector3 *pvLines, int nCount, D3DCOLOR color);
	static void			RenderLines(const RECT& rc, D3DCOLOR color); 
	
	static float		TimerProcess( TIMER_COMMAND command );

	uint32_t				Type() { return m_dwType; } // 객체 종류..

	void				ReleaseResrc();
//#ifdef _N3TOOL
	void				SaveResrc();
//#endif // end of _N3TOOL
	virtual void Release();
	CN3Base();
	virtual ~CN3Base();
};

#endif // !defined(AFX_N3Base_h__INCLUDED_)

// ===== END N3Base/N3Base.h =====

// ===== BEGIN N3Base/N3BaseFileAccess.cpp =====
#line 1 "N3Base/N3BaseFileAccess.cpp"
﻿// N3BaseFileAccess.cpp: implementation of the CN3BaseFileAccess class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3BaseFileAccess.h"

#include <FileIO/FileReader.h>
#include <FileIO/FileWriter.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3BaseFileAccess::CN3BaseFileAccess()
{
	m_iFileFormatVersion = N3FORMAT_VER_UNKN;

	m_dwType |= OBJ_BASE_FILEACCESS;
	m_iLOD = 0; // 로딩할때 쓸 LOD
}

CN3BaseFileAccess::~CN3BaseFileAccess()
{
}

void CN3BaseFileAccess::Release()
{
	m_szFileName.clear();
	m_iLOD = 0; // 로딩할때 쓸 LOD
	CN3Base::Release();
}

void CN3BaseFileAccess::FileNameSet(const std::string& szFileName)
{
	std::string szTmpFN = szFileName;

	if (!szTmpFN.empty())
		CharLower(&szTmpFN[0]); // 모두 소문자로 만든다..

	size_t pos = szTmpFN.find(s_szPath); // 문자열에 Base Path 와 일치하는 이름이 있는지 본다.
	if (pos != std::string::npos)
		m_szFileName = szTmpFN.substr(s_szPath.size()); // 경로가 일치하면.. 긴경로는 짤라준다..
	else
		m_szFileName = szTmpFN;
}

bool CN3BaseFileAccess::Load(File& file)
{
	int nL = 0;
	file.Read(&nL, 4);
	if (nL > 0)
	{
		m_szName.assign(nL, '\0');
		file.Read(&m_szName[0], nL);
	}
	else
	{
		m_szName.clear();
	}

	return true;
}

bool CN3BaseFileAccess::LoadFromFile()
{
	if (m_szFileName.empty())
	{
#ifdef _N3GAME
		CLogWriter::Write("Can't open file (read)");
#endif
		return false;
	}

	std::string szFullPath;

	// 문자열에 ':', '\\', '//' 이 들어 있으면 전체 경로이다..
	if (m_szFileName.find(':') != std::string::npos
		|| m_szFileName.find("\\\\") != std::string::npos
		|| m_szFileName.find("//") != std::string::npos)
	{
		szFullPath = m_szFileName;
	}
	else
	{
		if (!s_szPath.empty())
			szFullPath = s_szPath;

		szFullPath += m_szFileName;
	}

	FileReader file;
	if (!file.OpenExisting(szFullPath))
	{
		std::string szErr = szFullPath + " - Can't open file (read)";
#ifdef _N3TOOL
		MessageBox(s_hWndBase, szErr.c_str(), "File Handle error", MB_OK);
#endif
#ifdef _N3GAME 
		CLogWriter::Write(szErr);
#endif
		return false;
	}

	return Load(file);
}

bool CN3BaseFileAccess::LoadFromFile(const std::string& szFileName, uint32_t iVer)
{
	m_iFileFormatVersion = iVer;

	FileNameSet(szFileName);
	return LoadFromFile();
}

bool CN3BaseFileAccess::SaveToFile()
{
	if (m_szFileName.empty())
	{
		std::string szErr = m_szName + " Can't open file (write) - NULL String";
		MessageBox(s_hWndBase, szErr.c_str(), "File Open Error", MB_OK);
		return false;
	}

	std::string szFullPath;

	// 문자열에 ':', '\\', '//' 이 들어 있으면 전체 경로이다..
	if (m_szFileName.find(':') != std::string::npos
		|| m_szFileName.find("\\\\") != std::string::npos
		|| m_szFileName.find("//") != std::string::npos)
	{
		szFullPath = m_szFileName;
	}
	else
	{
		if (!s_szPath.empty())
			szFullPath = s_szPath;

		szFullPath += m_szFileName;
	}

	FileWriter file;
	if (!file.Create(szFullPath))
	{
		std::string szErr = szFullPath + " - Can't open file(write)";
		MessageBox(s_hWndBase, szErr.c_str(), "File Handle error", MB_OK);
		return false;
	}

	Save(file);
	return true;
}

bool CN3BaseFileAccess::SaveToFile(const std::string& szFileName)
{
	FileNameSet(szFileName);
	return SaveToFile();
}

bool CN3BaseFileAccess::Save(File& file)
{
	int nL = static_cast<int>(m_szName.size());
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_szName.c_str(), nL);

	return true;
}

// ===== END N3Base/N3BaseFileAccess.cpp =====

// ===== BEGIN N3Base/N3BaseFileAccess.h =====
#line 1 "N3Base/N3BaseFileAccess.h"
﻿// N3BaseFileAccess.h: interface for the CN3BaseFileAccess class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3BASEFILEACCESS_H__C99953BD_12BE_4B37_823F_4F4B2379FF74__INCLUDED_)
#define AFX_N3BASEFILEACCESS_H__C99953BD_12BE_4B37_823F_4F4B2379FF74__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include <string>

#include <FileIO/File.h>

//-----------------------------------------------------------------------------
#define N3FORMAT_VER_UNKN 0x00000000
#define N3FORMAT_VER_1068 0x00000001 // (1<<0)
#define N3FORMAT_VER_1264 0x00000002 // (1<<1)
#define N3FORMAT_VER_1298 0x00000004 // (1<<2)
#define N3FORMAT_VER_2062 0x00000008 // (1<<3)
#define N3FORMAT_VER_CURR 0x40000000 // NOTE: not even going to attempting this right now
#define N3FORMAT_VER_HERO 0x80000000 // NOTE: Hero Online formatting

static constexpr int N3FORMAT_VER_DEFAULT = N3FORMAT_VER_1264;//N3FORMAT_VER_1068;

//-----------------------------------------------------------------------------
class CN3BaseFileAccess : public CN3Base
{
protected:
	std::string		m_szFileName; // Base Path 를 제외한 로컬 경로 + 파일 이름

public:
	uint32_t m_iFileFormatVersion;
	int m_iLOD; // 로딩할때 쓸 LOD

public:
	const std::string& FileName() const { return m_szFileName; } // Full Path
	void FileNameSet(const std::string& szFileName);

	bool LoadFromFile(); // 파일에서 읽어오기.
	virtual bool LoadFromFile(const std::string& szFileName, uint32_t iVer = N3FORMAT_VER_DEFAULT); // 파일에서 읽어오기.
	virtual bool Load(File& file); // 핸들에서 읽어오기..

	virtual bool SaveToFile(); // 현재 파일 이름대로 저장.
	virtual bool SaveToFile(const std::string& szFileName); // 새이름으로 저장.
	virtual bool Save(File& file); // 핸들을 통해 저장..

public:
	void Release();

	CN3BaseFileAccess();
	virtual ~CN3BaseFileAccess();
};

#endif // !defined(AFX_N3BASEFILEACCESS_H__C99953BD_12BE_4B37_823F_4F4B2379FF74__INCLUDED_)

// ===== END N3Base/N3BaseFileAccess.h =====

// ===== BEGIN N3Base/N3Board.h =====
#line 1 "N3Base/N3Board.h"
﻿// N3Board.h: interface for the CN3Board class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3BOARD_H__A6E96276_7491_4722_82C9_EA06561D1D41__INCLUDED_)
#define AFX_N3BOARD_H__A6E96276_7491_4722_82C9_EA06561D1D41__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Transform.h"
#include <vector>
#include <string>

const uint32_t BOARD_X				= 0;
const uint32_t BOARD_Y				= 1;
const uint32_t BOARD_Z				= 2;
const uint32_t BOARD_XYZ			= 3;

class CN3Board : public CN3Transform
{
protected:
	__VertexT1 m_vRects[4];
	float		m_fTexIndex;
	std::vector<CN3Texture*> m_TexRefs; // 텍스처 포인터 리스트..

public:
	uint32_t	m_dwBoardType; // Board Type
	float		m_fTexFPS; // Frame Per Second
	__Material	m_Mtl; // 재질..

public:
	int TexCount() const
	{
		return static_cast<int>(m_TexRefs.size());
	}

	void		TexSet(int index, const std::string& szFN);
	void		TexAlloc(int nCount);
	CN3Texture* Tex(int index) { if(m_TexRefs.empty() || index < 0 || index >= m_TexRefs.size()) return nullptr; return m_TexRefs[index]; }

	void		Init(__Vector3 vPos, uint32_t dwBoardType, float fW, float fH);
	void		Tick(float fFrm) override;
	void		Render();

	bool		Load(File& file) override;
	void		LoadFromText(const std::string& szFName);
	
#ifdef _N3TOOL
	bool		Save(File& file) override;
#endif // end of #ifdef _N3TOOL

	void Release() override;

	CN3Board();
	~CN3Board() override;
};

#endif // !defined(AFX_N3BOARD_H__A6E96276_7491_4722_82C9_EA06561D1D41__INCLUDED_)

// ===== END N3Base/N3Board.h =====

// ===== BEGIN N3Base/N3Camera.cpp =====
#line 1 "N3Base/N3Camera.cpp"
﻿// N3Camera.cpp: implementation of the CN3Camera class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Camera.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CN3Camera::CN3Camera()
{
	m_dwType |= OBJ_CAMERA;

	m_Data.Release();
	m_Data.vEye = m_vPos = __Vector3(15,5,-15);
	m_Data.vAt = m_vAt = __Vector3(0,0,0);
	m_Data.vUp = m_vScale = __Vector3(0,1,0);

	m_Data.fFOV = DegreesToRadians(55.0f); // 기본값 55 도
	m_Data.fNP = 0.7f;
	m_Data.fFP = 512.0f;

	m_bFogUse = TRUE;
	m_FogColor = D3DCOLOR_ARGB(255,255,255,255);
//	m_fFogDensity = 1.0 / m_Data.fFP;
//	m_fFogStart = m_Data.fFP * 0.75f;
//	m_fFogEnd = m_Data.fFP;

	m_fRadianX = 0.0f;
	m_bOrtho = false;
}

CN3Camera::~CN3Camera()
{
}

void CN3Camera::Release()
{
	m_Data.Release();
	m_Data.vEye = m_vPos = __Vector3(15,5,-15);
	m_Data.vAt = m_vAt = __Vector3(0,0,0);
	m_Data.vUp = m_vScale = __Vector3(0,1,0);

	m_Data.fFOV = DegreesToRadians(55.0f); // 기본값 55 도
	m_Data.fNP = 0.7f;
	m_Data.fFP = 512.0f;

	m_bFogUse = FALSE;
	m_FogColor = D3DCOLOR_ARGB(255,255,255,255);
//	m_fFogDensity = 1.0f / m_Data.fFP;
//	m_fFogStart = m_Data.fFP * 0.75f;
//	m_fFogEnd = m_Data.fFP;

	m_fRadianX = 0.0f;

	CN3Transform::Release();
}

bool CN3Camera::Load(File& file)
{
	CN3Transform::Load(file);

	file.Read(&m_vAt, sizeof(__Vector3)); // At position
	file.Read(&m_Data, sizeof(__CameraData)); // CameraData
	file.Read(&m_bFogUse, 4);
	file.Read(&m_FogColor, 4);
//	file.Read(&m_fFogDensity, 4);
//	file.Read(&m_fFogStart, 4);
//	file.Read(&m_fFogEnd, 4);

	return true;
}

#ifdef _N3TOOL
BOOL CN3Camera::MoveByWindowMessage(MSG* pMsg)
{
//	static int iButtonDownCount = 0;
	if (pMsg->message == WM_MOUSEWHEEL)
	{
		//int16_t zDelta = GET_WHEEL_DELTA_WPARAM(wParam);
		int16_t zDelta = (int16_t)((pMsg->wParam>>16)&0x0000ffff);
		float fD = (m_vPos - m_vAt).Magnitude();
		float fzD = fD * zDelta * 0.001f;
		bool bSmall = false;
#ifdef _N3INDOOR
		if (0.0f < fzD && fzD < 0.6f)
		{
			fzD = 0.6f;
			bSmall = true;
		}
		if (0.0f > fzD && fzD > -0.6f)
		{
			fzD = -0.6f;
			bSmall = true;
		}
#endif 
		this->MoveStraight(fzD, bSmall);
		this->Apply();
		return TRUE;
	}
	else if (pMsg->message == WM_KEYDOWN)
	{
		switch(pMsg->wParam)
		{
		case VK_UP: { __Vector3 vDir = m_vAt - m_vPos; vDir.Normalize(); this->Move(vDir*10.0f); this->Apply(); return TRUE; }
			break;
		case VK_DOWN: { __Vector3 vDir = m_vAt - m_vPos; vDir.Normalize(); this->Move(vDir*-10.0f); this->Apply(); return TRUE; }
			break;
		case VK_RIGHT: { this->Rotate(0, -0.1f); this->Apply(); return TRUE; }
			break;
		case VK_LEFT: { this->Rotate(0, 0.1f); this->Apply(); return TRUE; }
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
				static __Vector3 vEyes[10] = { m_vPos, m_vPos, m_vPos, m_vPos, m_vPos, m_vPos, m_vPos, m_vPos, m_vPos, m_vPos };
				static __Vector3 vAts[10] = { m_vAt, m_vAt, m_vAt, m_vAt, m_vAt, m_vAt, m_vAt, m_vAt, m_vAt, m_vAt};
				static __Vector3 vUps[10] = { m_vScale, m_vScale, m_vScale, m_vScale, m_vScale, m_vScale, m_vScale, m_vScale, m_vScale, m_vScale };
				
				int nCamIndex = static_cast<int>(pMsg->wParam) - '0';

				if (::_IsKeyDown(VK_CONTROL))
				{
					vEyes[nCamIndex] = m_vPos;
					vAts[nCamIndex] = m_vAt;
					vUps[nCamIndex] = m_vScale;
					return FALSE;
				}
				else
				{
					this->EyePosSet(vEyes[nCamIndex]);
					this->AtPosSet(vAts[nCamIndex]);
					this->UpVectorSet(vUps[nCamIndex]);
					this->Apply();
					return TRUE;
				}
			}
			break;
		}
	}
	else if(::_IsKeyDown(VK_MENU))
	{
		static POINT ptPrev;
	
		POINT point = { (int16_t)LOWORD(pMsg->lParam), (int16_t)HIWORD(pMsg->lParam) };
		POINT ptDelta = { point.x - ptPrev.x, point.y - ptPrev.y };

		switch(pMsg->message)
		{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
			{
//				iButtonDownCount++;
//				::SetCapture(pMsg->hwnd);
				ptPrev.x = int16_t(LOWORD(pMsg->lParam));
				ptPrev.y = int16_t(HIWORD(pMsg->lParam));
				return TRUE;
			}
			break;
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		case WM_MBUTTONUP:
			{
//				iButtonDownCount--;
//				if (iButtonDownCount <= 0) 
//					ReleaseCapture();
				return TRUE;
			}
			break;
		case WM_MOUSEMOVE:
			{
				UINT_PTR nFlags = pMsg->wParam;
				ptPrev = point;

				if(	(nFlags & MK_LBUTTON) && (nFlags & MK_MBUTTON) ) // Alt + LB + MB
				{
					float fZoom = (float)(ptDelta.x)/500.0f;
					this->Zoom(fZoom);
					this->Apply();
					return TRUE;
				}
				else if((nFlags & MK_LBUTTON) ) // Alt + LB
				{
					float fRX = (float)(ptDelta.y)/200.0f;
					float fRY = -(float)(ptDelta.x)/200.0f;
					this->LookAround(fRX, -fRY);
					this->Apply();
					return TRUE;
				}
				else if((nFlags & MK_RBUTTON) ) // Alt + RB
				{
					float fRX = (float)(ptDelta.y)/200.0f;
					float fRY = (float)(ptDelta.x)/200.0f;
					this->Rotate(fRX, -fRY);
					this->Apply();
					return TRUE;
				}
				else if((nFlags & MK_MBUTTON) ) // Alt + MB
				{
					__Vector3 vDelta = m_vPos - m_vAt;
					float fDelta = vDelta.Magnitude() * 0.002f / m_Data.fFOV;
					__Vector3 vD1;
					vD1.Set(-(float)(ptDelta.x), (float)(ptDelta.y), 0 );

					vD1 *= fDelta;

					this->MovePlane(vD1.x, -vD1.y);
					this->Apply();
					return TRUE;
				}
			}
		default:	// 마우스 메세지가 아닐경우 카메라 움직임이 아니다.
			return FALSE;
		}
	}

	return FALSE;
}
#endif // end of #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3Camera::Zoom(float fDelta)
{
	__Vector3 vD = m_vAt - m_vPos;

	float fD2 = sqrtf(vD.Magnitude());
	fDelta *= fD2 / 5.0f;

	__Vector3 vPos = m_vPos + vD * fDelta;
	float fDist = (vPos - m_Data.vAt).Magnitude();
#ifndef _N3INDOOR
	if(fDist < 0.3f) return; // 너무 가까우면 적용하지 않는다..
	else if(fDist > m_Data.fFP * 2.0f) return; // 너무 멀면 적용하지 않는다.
#endif

	m_vPos = vPos;
#ifdef _N3INDOOR
	if (fDist <6.6f)
		m_vAt = m_vAt + vD * fDelta;
#endif	
}
#endif // end of #ifdef _N3TOOL

void CN3Camera::Rotate(float fRadianX, float fRadianY)
{
	//static __Matrix44 mtx;
	__Matrix44 mtx;		//by lynus...
	mtx.RotationY(fRadianY);

	__Vector3 v1 = m_vAt - m_vPos, v2; // Rotation 은 LookAt Position 처럼, Scale 은 UpVector 처럼 쓴다..
	v1 *= mtx;
	m_vScale *= mtx;

	v2.Cross(v1, m_vScale);
	__Quaternion qt;
	qt.RotationAxis(v2, fRadianX);
	mtx = qt;

	v1 *= mtx;
	m_vScale *= mtx;	//by lynus...
/*
#ifndef _N3_CLIENT_
	m_vScale *= mtx;
#endif
*/
	m_vAt = m_vPos + v1;
}

#ifdef _N3TOOL
void CN3Camera::LookAround(float fRadianX, float fRadianY)		//At Postion을 중심으로 카메라가 돈다..고로 위치가 바뀐다..
{
	//static __Matrix44 mtx;
	//static __Vector3 v1, v2;
	//static __Quaternion qt;
	
	__Matrix44 mtx;		//by lynus...
	__Vector3 v1, v2;
	__Quaternion qt;

	v1 = m_vPos - m_vAt;
	mtx.RotationY(fRadianY);
	v1 *= mtx;
	m_vScale *= mtx;

	v2.Cross(v1, m_vScale);
	qt.RotationAxis(v2, fRadianX);
	mtx = qt;
	
	v1 *= mtx;
	m_vScale *= mtx;	//by lynus...
/*
#ifdef _N3_CLIENT_
	m_vScale *= mtx;
#endif
*/
	m_vPos = m_vAt + v1; // Rotation 은 LookAt Position 처럼, Scale 은 UpVector 처럼 쓴다..
}
#endif // end of #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3Camera::Move(const __Vector3& vDelta)
{
	m_vPos += vDelta;
	m_vAt += vDelta;
}
#endif // end of #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3Camera::MoveStraight(float fDistance, bool bSmall)
{
	__Vector3 vDelta = m_vAt - m_vPos;
	vDelta.Normalize();
	m_vPos += vDelta * fDistance;
#ifdef _N3INDOOR
	if (bSmall)
		m_vAt += vDelta * fDistance;
#endif 
}
#endif // end of #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3Camera::MovePlane(float fX, float fY)
{
	__Vector3 vDir = m_vAt - m_vPos; // Rotation 은 LookAt Position 처럼, Scale 은 UpVector 처럼 쓴다..
	vDir.Normalize();

	__Vector3 vHoriz;
	vHoriz.Cross(m_vScale, vDir);
	vHoriz.Normalize();
	
	__Vector3 vDown;
	vDown.Cross(vHoriz, vDir);
	vDown.Normalize();
	m_vScale = vDown*(-1);

	__Vector3 vMove = (vHoriz*fX) + (vDown*fY);
	
	m_vPos += vMove;
	m_vAt += vMove; // Rotation 은 LookAt Position 처럼, Scale 은 UpVector 처럼 쓴다..
}
#endif // end of #ifdef _N3TOOL

#ifdef _N3TOOL
bool CN3Camera::Save(File& file)
{
	CN3Transform::Save(file);

	file.Write(&m_vAt, sizeof(__Vector3)); // At position
	file.Write(&m_Data, sizeof(__CameraData)); // CameraData
	file.Write(&m_bFogUse, 4);
	file.Write(&m_FogColor, 4);
//	file.Write(&m_fFogStart, 4);
//	file.Write(&m_fFogEnd, 4);
//	file.Write(&m_fFogDensity, 4);

	return true;
}
#endif // end of #ifdef _N3TOOL

void CN3Camera::Apply()
{
	s_lpD3DDev->SetTransform(D3DTS_VIEW, m_Data.mtxView.toD3D());
	s_lpD3DDev->SetTransform(D3DTS_PROJECTION, m_Data.mtxProjection.toD3D()); // Projection Matrix Setting
	memcpy(&(CN3Base::s_CameraData), &m_Data, sizeof(__CameraData)); // Static Data Update...

	// 안개 색깔 맞추기..
	s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, m_bFogUse);
	s_lpD3DDev->SetRenderState( D3DRS_FOGCOLOR,  m_FogColor);

	s_lpD3DDev->SetRenderState( D3DRS_FOGVERTEXMODE,  D3DFOG_EXP2);
	s_lpD3DDev->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_EXP2);
//	s_lpD3DDev->SetRenderState( D3DRS_FOGTABLEMODE,   D3DFOG_NONE);
//	s_lpD3DDev->SetRenderState( D3DRS_FOGVERTEXMODE,  D3DFOG_LINEAR);

	s_lpD3DDev->SetRenderState( D3DRS_RANGEFOGENABLE, TRUE);

	// Range Fog : 장점 - 거리기반으로 fog가 적용된다. 단점 - poligon단위로 같은 fog값이 적용된다.(큰 폴리곤이 있을경우 어색한 fog가 될 수 있다.)
	// range fog = FALSE로 했을때는 depth버퍼 기반으로 fog가 계산되어 적용된다.

	// vertex fog 와 pixel fog(table fog)의 차이 - Dino씀..
	// vertex fog : vertex의 depth값을 기반으로 vertex사이의 보간으로 계산되는 것 같다.
	//				따라서 카메라를 돌리다보면 vertex주위를 중심으로 fog가 변하는것이 관찰된다.
	// pixel fog : pixel의 depth값을 기반으로 fog를 계산하는것 같다.

	// 위의 모든 fog의 차이를 보려면 큰판을 하나 그려서 fog를 넣어보면 쉽게 관찰할 수 있다.

//	s_lpD3DDev->SetRenderState( D3DRS_FOGSTART,   *(uint32_t*)&m_fFogStart);
//	s_lpD3DDev->SetRenderState( D3DRS_FOGEND,     *(uint32_t*)&m_fFogEnd);
//	s_lpD3DDev->SetRenderState( D3DRS_FOGDENSITY, *(uint32_t*)&m_fFogDensity);



	float fFogDensity = 1.0f / (0.37f*m_Data.fFP);//0.33f/23.0f;
	float fFogStart = m_Data.fFP * 0.75f;
	float fFogEnd = m_Data.fFP;

	s_lpD3DDev->SetRenderState( D3DRS_FOGSTART,   *(uint32_t*)&fFogStart);
	s_lpD3DDev->SetRenderState( D3DRS_FOGEND,     *(uint32_t*)&fFogEnd);
	s_lpD3DDev->SetRenderState( D3DRS_FOGDENSITY, *(uint32_t*)&fFogDensity);
}

void CN3Camera::Render(float fUnitSize)
{
}

void CN3Camera::Tick(float fFrm)
{
	CN3Transform::Tick(fFrm);

	////////////////////////////////////////////////////////////////////////
	// View Matrix 및 Projection Matrix Setting
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// 	__Vector3 m_vEye, m_vUp ->> m_vPos, m_vScale 로 대신한다.. 중요!!
	m_Data.vEye = m_vPos;
	m_Data.vAt  = m_vAt;
	m_Data.vUp  = m_vScale; // Up Vector 처럼 쓴다.
	/////////////////////////////////////////////////////////////////////////////////////////////////////////

//	m_Data.fInverse_SineHalfOfFOV = 1.0f/sinf(m_Data.fFOV*0.5f);

	m_Data.mtxView.LookAtLH(m_Data.vEye, m_Data.vAt, m_Data.vUp); // Look At 적용
	m_Data.mtxViewInverse = m_Data.mtxView.Inverse(); // View Inverse 행렬 구하기..
	CN3Base::s_lpD3DDev->GetViewport(&m_Data.vp); // View port 가져오기...
	
	m_Data.fAspect = (float)m_Data.vp.Width / (float)m_Data.vp.Height; // 종횡비
	if(m_bOrtho)
	{
		float fL = (m_Data.vAt - m_Data.vEye).Magnitude() / 2.0f;
		m_Data.mtxProjection.OrthoLH(fL, fL / m_Data.fAspect, m_Data.fNP * (1.0f + fL / 1000.0f), m_Data.fFP);  // Projection Matrix Setting
//		m_Data.mtxProjection.OrthoLH(2.0f, 2.0f, m_Data.fNP, m_Data.fFP);  // Projection Matrix Setting
	}
	else
	{
		m_Data.mtxProjection.PerspectiveFovLH(m_Data.fFOV, m_Data.fAspect, m_Data.fNP, m_Data.fFP); // Projection Matrix Setting
	}

	__Matrix44 mtx = m_Data.mtxView * m_Data.mtxProjection;
	float frustum [6][4];
	frustum[0][0] = mtx.m[0][3] - mtx.m[0][0];
	frustum[0][1] = mtx.m[1][3] - mtx.m[1][0];
	frustum[0][2] = mtx.m[2][3] - mtx.m[2][0];
	frustum[0][3] = mtx.m[3][3] - mtx.m[3][0];

	// Normalize the result 
	float t = sqrt( frustum[0][0] * frustum[0][0] + frustum[0][1] * frustum[0][1] + frustum[0][2] * frustum[0][2] );
	frustum[0][0] /= t;
	frustum[0][1] /= t;
	frustum[0][2] /= t;
	frustum[0][3] /= t;

	// Extract the numbers for the LEFT plane 
	frustum[1][0] = mtx.m[0][3] + mtx.m[0][0];
	frustum[1][1] = mtx.m[1][3] + mtx.m[1][0];
	frustum[1][2] = mtx.m[2][3] + mtx.m[2][0];
	frustum[1][3] = mtx.m[3][3] + mtx.m[3][0];

	// Normalize the result 
	t = sqrt( frustum[1][0] * frustum[1][0] + frustum[1][1] * frustum[1][1] + frustum[1][2] * frustum[1][2] );
	frustum[1][0] /= t;
	frustum[1][1] /= t;
	frustum[1][2] /= t;
	frustum[1][3] /= t;

	// Extract the BOTTOM plane 
	frustum[2][0] = mtx.m[0][3] + mtx.m[0][1];
	frustum[2][1] = mtx.m[1][3] + mtx.m[1][1];
	frustum[2][2] = mtx.m[2][3] + mtx.m[2][1];
	frustum[2][3] = mtx.m[3][3] + mtx.m[3][1];

	// Normalize the result 
	t = sqrt( frustum[2][0] * frustum[2][0] + frustum[2][1] * frustum[2][1] + frustum[2][2] * frustum[2][2] );
	frustum[2][0] /= t;
	frustum[2][1] /= t;
	frustum[2][2] /= t;
	frustum[2][3] /= t;

	// Extract the TOP plane 
	frustum[3][0] = mtx.m[0][3] - mtx.m[0][1];
	frustum[3][1] = mtx.m[1][3] - mtx.m[1][1];
	frustum[3][2] = mtx.m[2][3] - mtx.m[2][1];
	frustum[3][3] = mtx.m[3][3] - mtx.m[3][1];

	// Normalize the result 
	t = sqrt( frustum[3][0] * frustum[3][0] + frustum[3][1] * frustum[3][1] + frustum[3][2] * frustum[3][2] );
	frustum[3][0] /= t;
	frustum[3][1] /= t;
	frustum[3][2] /= t;
	frustum[3][3] /= t;

	// Extract the FAR plane
	frustum[4][0] = mtx.m[0][3] - mtx.m[0][2];
	frustum[4][1] = mtx.m[1][3] - mtx.m[1][2];
	frustum[4][2] = mtx.m[2][3] - mtx.m[2][2];
	frustum[4][3] = mtx.m[3][3] - mtx.m[3][2];

	// Normalize the result 
	t = sqrt( frustum[4][0] * frustum[4][0] + frustum[4][1] * frustum[4][1] + frustum[4][2] * frustum[4][2] );
	frustum[4][0] /= t;
	frustum[4][1] /= t;
	frustum[4][2] /= t;
	frustum[4][3] /= t;

	// Extract the NEAR plane
	frustum[5][0] = mtx.m[0][3] + mtx.m[0][2];
	frustum[5][1] = mtx.m[1][3] + mtx.m[1][2];
	frustum[5][2] = mtx.m[2][3] + mtx.m[2][2];
	frustum[5][3] = mtx.m[3][3] + mtx.m[3][2];

	// Normalize the result 
	t = sqrt( frustum[5][0] * frustum[5][0] + frustum[5][1] * frustum[5][1] + frustum[5][2] * frustum[5][2] );
	frustum[5][0] /= t;
	frustum[5][1] /= t;
	frustum[5][2] /= t;
	frustum[5][3] /= t;

	memcpy(m_Data.fFrustum, frustum, sizeof(float)*6*4);
}

void CN3Camera::LookAt(const __Vector3& vEye, const __Vector3& vAt, const __Vector3& vUp)
{
	m_vPos = vEye;
	m_vAt = vAt;
	m_vScale = vUp;
}

// ===== END N3Base/N3Camera.cpp =====

// ===== BEGIN N3Base/N3Camera.h =====
#line 1 "N3Base/N3Camera.h"
﻿// N3Camera.h: interface for the CN3Camera class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Camera_h__INCLUDED_)
#define AFX_N3Camera_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Transform.h"

class CN3Camera : public CN3Transform
{
public:
	__Vector3			m_vAt;
	__CameraData		m_Data;
	BOOL				m_bFogUse;
	D3DCOLOR			m_FogColor;
//	float				m_fFogStart;
//	float				m_fFogEnd;
//	float				m_fFogDensity;
	float				m_fRadianX;
	bool				m_bOrtho;

public:
	void		Rotate(float fRadianX, float fRadianY);
	void		LookAt(const __Vector3& vEye, const __Vector3& vAt, const __Vector3& vUp);
	__Vector3	EyePos() { return m_vPos; }
	__Vector3	AtPos() { return m_vAt; }
	__Vector3	UpVector() { return m_vScale; } // Rotation 은 LookAt Position 처럼, Scale 은 UpVector 처럼 쓴다..
	__Vector3	Dir() {__Vector3 vDir = m_vAt - m_vPos; vDir.Normalize(); return vDir;} // 방향을 되돌린다.

	void		EyePosSet(const __Vector3& v) { m_vPos = v; }
	void		EyePosSet(float x, float y, float z) { m_vPos.Set(x, y, z); }
	void		AtPosSet(const __Vector3& v) { m_vAt = v; } 
	void		AtPosSet(float x, float y, float z) { m_vAt.Set(x, y, z); }
	void		UpVectorSet(const __Vector3& v) { m_vScale = v; } // Scale 은 UpVector 처럼 쓴다..
	void		UpVectorSet(float x, float y, float z) { m_vScale.Set(x, y, z); } // Scale 은 UpVector 처럼 쓴다..

	bool		Load(File& file) override;

#ifdef _N3TOOL
	BOOL		MoveByWindowMessage(MSG* pMsg);
	void		Move(const __Vector3& vDelta);
	void		MovePlane(float fX, float fY);
	void		MoveStraight(float fDistance, bool bSmall = false);
	void		LookAround(float fRadianX, float fRadianY);
	void		Zoom(float fDelta);
	bool		Save(File& file) override;
#endif // end of #ifdef _N3TOOL
	void		Release() override;
	CN3Camera();
	~CN3Camera() override;

	void		Tick(float fFrm = FRAME_SELFPLAY) override; // 카메라값만 단순히 세팅하기만 한다..
	void		Render(float fUnitSize = 1.0f);
	void		Apply(); // 세팅된 카메라값을 실제 D3DDevice 에 적용
};

#endif // !defined(AFX_N3Camera_h__INCLUDED_)

// ===== END N3Base/N3Camera.h =====

// ===== BEGIN N3Base/N3Chr.cpp =====
#line 1 "N3Base/N3Chr.cpp"
﻿// N3Chr.cpp: implementation of the CN3Chr class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3SndObj.h"
#include "N3Chr.h"
#include "N3SkyMng.h"
#include "N3Sun.h"
#include "N3FXBundle.h"
#include "N3FXPartBase.h"
#include "N3FXPartBillBoard.h"
#include "N3FXPlug.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

const float CHR_LOD_CALCULATION_VALUES[MAX_CHR_LOD_DELTA][MAX_CHR_LOD] =
{
//	{ 6.0f, 18.0f, 32.0f, 128.0f },
//	{ 4.0f, 12.0f, 21.0f, 85.0f },
//	{ 2.66f, 8.0f, 14.21f, 56.8f },
//	{ 1.77f, 5.33f, 9.48f, 37.9f }
	{ 8.0f, 16.0f, 48.0f, 128.0f },
	{ 4.0f, 8.0f, 24.0f, 64.0f },
	{ 2.0f, 4.0f, 12.0f, 32.0f },
	{ 1.0f, 3.0f, 5.0f, 7.0f }
//	{ 1.0f, 2.0f, 6.0f, 16.0f }
};

CN3CPartSkins::CN3CPartSkins()
{
	m_dwType |= OBJ_CHARACTER_PART_SKINS;
}

CN3CPartSkins::~CN3CPartSkins()
{
}

void CN3CPartSkins::Release()
{
	for(int i = 0; i < MAX_CHR_LOD; i++)
	{
		m_Skins[i].Release();
	}
}

bool CN3CPartSkins::Load(File& file)
{
	CN3BaseFileAccess::Load(file);
	for(int i = 0; i < MAX_CHR_LOD; i++)
	{
		m_Skins[i].m_iFileFormatVersion = m_iFileFormatVersion;
		m_Skins[i].Load(file);
	}

	return true;
}

#ifdef _N3TOOL
bool CN3CPartSkins::Save(File& file)
{
	CN3BaseFileAccess::Save(file);
	for(int i = 0; i < MAX_CHR_LOD; i++)
	{
		m_Skins[i].Save(file);
	}

	return true;
}
#endif // end of _N3TOOL

////////////////////////////////
// Part, Plug....
CN3CPart::CN3CPart()
{
	m_dwType |= OBJ_CHARACTER_PART;
	m_pTexRef = nullptr;
	m_pTexOverlapRef = nullptr;
	m_pSkinsRef = nullptr;

	m_bVisible = true;
	m_dwReserved = 0;
	m_Mtl.Init();
	m_MtlOrg.Init();
};

CN3CPart::~CN3CPart()
{
	s_MngTex.Delete(&m_pTexRef);
	s_MngTex.Delete(&m_pTexOverlapRef);
	s_MngSkins.Delete(&m_pSkinsRef);
};

void CN3CPart::Release()
{
	m_bVisible = true;
	m_dwReserved = 0;
	m_Mtl.Init();
	m_MtlOrg.Init();

	s_MngTex.Delete(&m_pTexRef);
	s_MngTex.Delete(&m_pTexOverlapRef);
	m_pTexRef = nullptr;
	m_pTexOverlapRef = nullptr;
	s_MngSkins.Delete(&m_pSkinsRef);

	CN3BaseFileAccess::Release();
}

CN3CPartSkins* CN3CPart::SkinsSet(const std::string& szFN)
{
	s_MngSkins.Delete(&m_pSkinsRef);
	m_pSkinsRef = s_MngSkins.Get(szFN, TRUE);

	return m_pSkinsRef;
}

bool CN3CPart::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	int nL = 0;
	char szFN[256] = "";

	file.Read(&m_dwReserved, 4);
	file.Read(&m_MtlOrg, sizeof(__Material));
	m_Mtl = m_MtlOrg;

	file.Read(&nL, 4);
	if (nL > 0)
	{
		file.Read(szFN, nL);
		szFN[nL] = '\0';
		TexSet(szFN);
	}

	file.Read(&nL, 4);
	if (nL > 0)
	{
		file.Read(szFN, nL);
		szFN[nL] = '\0';
		s_MngSkins.Delete(&m_pSkinsRef);
		m_pSkinsRef = s_MngSkins.Get(szFN);
	}

	return true;
}

#ifdef _N3TOOL
bool CN3CPart::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	int nL = 0;

	file.Write(&m_dwReserved, 4);
	file.Write(&m_Mtl, sizeof(__Material));

	if (m_pTexRef != nullptr)
		nL = static_cast<int>(m_pTexRef->FileName().size());
	else
		nL = 0;
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_pTexRef->FileName().c_str(), nL);

	if (m_pSkinsRef != nullptr)
		nL = static_cast<int>(m_pSkinsRef->FileName().size());
	else
		nL = 0;
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_pSkinsRef->FileName().c_str(), nL);

	return true;
}
#endif // end of _N3TOOL

void CN3CPart::Render(int nLOD)
{
	if(false == m_bVisible) return;
	if(nLOD < 0 || nLOD > MAX_CHR_LOD) return;
	if(nullptr == m_pSkinsRef || m_pSkinsRef->m_Skins[nLOD].VertexCount() <= 0) return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nChr_Part++; // Rendering Information Update...
	CN3Base::s_RenderInfo.nChr_Polygon += m_pSkinsRef->m_Skins[nLOD].FaceCount();
#endif

	DWORD dwAlpha, dwFog, dwCull;
	if(m_Mtl.nRenderFlags & RF_ALPHABLENDING) // Alpha 사용
	{
		s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
		if(TRUE != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   m_Mtl.dwSrcBlend);
		s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  m_Mtl.dwDestBlend);
	}
	if(m_Mtl.nRenderFlags & RF_NOTUSEFOG) // Fog 무시..
	{
		s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
		if(TRUE == dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	}
	if(m_Mtl.nRenderFlags & RF_DOUBLESIDED) // Render Flags - 
	{
		s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	}

	s_lpD3DDev->SetMaterial(&m_Mtl);
	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	bool bUseTwoUV = false;
	if(m_pTexRef) lpTex = m_pTexRef->Get();
	if(lpTex)
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
		s_lpD3DDev->SetTexture(0, lpTex);
		
		m_pTexRef->UpdateRenderInfo();

		if(m_pTexOverlapRef && m_pTexOverlapRef->Get())
		{
			bUseTwoUV = true;
			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATE);
			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);
			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);
			s_lpD3DDev->SetTexture(1, m_pTexOverlapRef->Get());

			m_pTexOverlapRef->UpdateRenderInfo();
		}
	}
	else
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		s_lpD3DDev->SetTexture(0, nullptr);
	}

	m_pSkinsRef->m_Skins[nLOD].Render(bUseTwoUV);

	if(bUseTwoUV)
	{
		s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
		s_lpD3DDev->SetTexture(1, nullptr);
	}

	if((m_Mtl.nRenderFlags & RF_ALPHABLENDING) && FALSE == dwAlpha)		s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if((m_Mtl.nRenderFlags & RF_NOTUSEFOG) && TRUE == dwFog) 			s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, TRUE); // 안개 사용하지 않는다..
	if((m_Mtl.nRenderFlags & RF_DOUBLESIDED) && D3DCULL_NONE != dwCull) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);
}

CN3Texture* CN3CPart::TexOverlapSet(const std::string& szFN)
{
	if(	m_pTexOverlapRef && 0 == lstrcmpi(m_pTexOverlapRef->FileName().c_str(), szFN.c_str()))
		return m_pTexOverlapRef;

	s_MngTex.Delete(&m_pTexOverlapRef);
	m_pTexOverlapRef = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Chr);
	return m_pTexOverlapRef;
}

void CN3CPart::TexOverlapSet(CN3Texture* pTex)
{
	if(pTex == m_pTexOverlapRef) return;
	
	s_MngTex.Delete(&m_pTexOverlapRef);
	m_pTexOverlapRef = pTex;
}


#ifdef _N3TOOL
void CN3CPart::RenderSelected(int nLOD)
{
	if(nLOD < 0 || nLOD > MAX_CHR_LOD) return;
	if(nullptr == m_pSkinsRef) return;

	m_pSkinsRef->m_Skins[nLOD].RenderSelected();
}
#endif // end of _N3TOOL

CN3CPlugBase::CN3CPlugBase()
{
	m_dwType |= OBJ_CHARACTER_PLUG;

	m_ePlugType = PLUGTYPE_NORMAL;
	m_nJointIndex = 0;

	m_pTexRef = nullptr;
	m_pTexOverlapRef = nullptr;

	m_bVisible = true;
	m_Mtl.Init();
	m_vPosition.Zero();
	m_MtxRot.Identity();
	m_vScale.Set(1,1,1);
	m_Matrix.Identity();	
};

CN3CPlugBase::~CN3CPlugBase()
{
	s_MngTex.Delete(&m_pTexRef);
	s_MngTex.Delete(&m_pTexOverlapRef);
}

void CN3CPlugBase::Release()
{
	m_ePlugType = PLUGTYPE_NORMAL;
	m_nJointIndex = 0;
	m_PMeshInst.Release();

	s_MngTex.Delete(&m_pTexRef);
	s_MngTex.Delete(&m_pTexOverlapRef);

	m_Mtl.Init();
	m_vPosition.Zero();
	m_MtxRot.Identity();
	m_vScale.Set(1,1,1);
	m_Matrix.Identity();	

	CN3BaseFileAccess::Release();
}

void CN3CPlugBase::ReCalcMatrix()
{
	m_Matrix.Scale(m_vScale);
	m_Matrix *= m_MtxRot;
	m_Matrix.PosSet(m_vPosition * m_vScale);

//	m_Matrix *= m_MtxRot;
//	m_Matrix.PosSet(m_vPosition);
//
//	__Matrix44 mtxScale; // 일부러 스케일 값을 나중에 적용하도록 바꾸었다...
//	mtxScale.Scale(m_vScale);
//	m_Matrix *= mtxScale;
}

void CN3CPlugBase::PMeshSet(const std::string& szFN)
{
	m_PMeshInst.Create(szFN);
}

void CN3CPlugBase::Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint)
{
	if(false == m_bVisible) return;
	if(m_PMeshInst.GetNumVertices() <= 0) return;
	
#ifdef _DEBUG
	CN3Base::s_RenderInfo.nChr_Plug++; // Rendering Information Update...
	CN3Base::s_RenderInfo.nChr_Plug_Polygon += m_PMeshInst.GetNumIndices() / 3; // Rendering Information Update...
#endif

	DWORD dwAlpha = 0, dwFog = 0, dwCull = 0;
	if(m_Mtl.nRenderFlags & RF_ALPHABLENDING) // Alpha 사용
	{
		s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
		if(TRUE != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   m_Mtl.dwSrcBlend);
		s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  m_Mtl.dwDestBlend);
	}
	if(m_Mtl.nRenderFlags & RF_NOTUSEFOG) // Fog 무시..
	{
		s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
		if(TRUE == dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	}
	if(m_Mtl.nRenderFlags & RF_DOUBLESIDED) // Render Flags - 
	{
		s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	}

	static __Matrix44 mtx;
	mtx = m_Matrix;
	mtx *= mtxJoint;
	mtx *= mtxParent;
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());

	s_lpD3DDev->SetMaterial(&m_Mtl);
	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	bool bUseTwoUV = false;
	if(m_pTexRef) lpTex = m_pTexRef->Get();
	if(lpTex)
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
		s_lpD3DDev->SetTexture(0, lpTex);
		m_pTexRef->UpdateRenderInfo();

		if(m_pTexOverlapRef && m_pTexOverlapRef->Get())
		{
			bUseTwoUV = true;

			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_MODULATE);
			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
			s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);
			s_lpD3DDev->SetTexture(1, m_pTexOverlapRef->Get());
			m_pTexOverlapRef->UpdateRenderInfo();
		}
	}
	else
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		s_lpD3DDev->SetTexture(0, nullptr);
	}

	if((m_Mtl.nRenderFlags & RF_ALPHABLENDING) && FALSE == dwAlpha)	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if((m_Mtl.nRenderFlags & RF_NOTUSEFOG) && TRUE == dwFog) 		s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, TRUE); // 안개 사용하지 않는다..
	if((m_Mtl.nRenderFlags & RF_DOUBLESIDED) && D3DCULL_NONE != dwCull) 		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);

	if(bUseTwoUV) m_PMeshInst.RenderTwoUV();
	else m_PMeshInst.Render();

	if(bUseTwoUV) // 텍스처 스테이지 두개로 렌더링한다...!!
	{
		s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);
		s_lpD3DDev->SetTexture(1, nullptr);
	}
}

CN3Texture* CN3CPlugBase::TexOverlapSet(const std::string& szFN)
{
//	if(m_pTexOverlapRef && m_pTexOverlapRef->FileName() == szFN) return m_pTexOverlapRef;
	if(	m_pTexOverlapRef && 0 == lstrcmpi(m_pTexOverlapRef->FileName().c_str(), szFN.c_str()))
		return m_pTexOverlapRef;

	s_MngTex.Delete(&m_pTexOverlapRef);
	m_pTexOverlapRef = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Chr);
	return m_pTexOverlapRef;
}

void CN3CPlugBase::TexOverlapSet(CN3Texture* pTex)
{
	if(pTex == m_pTexOverlapRef) return;
	
	s_MngTex.Delete(&m_pTexOverlapRef);
	m_pTexOverlapRef = pTex;
}

bool CN3CPlugBase::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	int nL = 0;
	char szFN[512] = "";

	file.Read(&m_ePlugType, 4); // Plug Type
//#ifdef _N3TOOL
	if (m_ePlugType > PLUGTYPE_MAX)
	{
		m_ePlugType = PLUGTYPE_NORMAL;
	}
//#endif
	file.Read(&m_nJointIndex, 4); // Plug Joint Index

	file.Read(&m_vPosition, sizeof(m_vPosition));
	file.Read(&m_MtxRot, sizeof(m_MtxRot));
	file.Read(&m_vScale, sizeof(m_vScale));

	file.Read(&m_Mtl, sizeof(__Material)); // 재질

	file.Read(&nL, 4);
	if (nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0';
		PMeshSet(szFN);
	}

	file.Read(&nL, 4);
	if (nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0';
		TexSet(szFN);
	}

	ReCalcMatrix(); // 행렬 계산...

	return true;
}

#ifdef _N3TOOL
bool CN3CPlugBase::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	int nL = 0;

	file.Write(&m_ePlugType, 4); // Plug Type
	file.Write(&m_nJointIndex, 4); // Plug Joint Index

	file.Write(&m_vPosition, sizeof(m_vPosition));
	file.Write(&m_MtxRot, sizeof(m_MtxRot));
	file.Write(&m_vScale, sizeof(m_vScale));

	file.Write(&m_Mtl, sizeof(__Material)); // 재질

	nL = 0;
	CN3PMesh* pPMesh = m_PMeshInst.GetMesh();
	if (pPMesh != nullptr)
		nL = static_cast<int>(pPMesh->FileName().size());
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(pPMesh->FileName().c_str(), nL);

	nL = 0;
	if (m_pTexRef != nullptr)
		nL = static_cast<int>(m_pTexRef->FileName().size());
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_pTexRef->FileName().c_str(), nL);

	return 0;
}
#endif // end of _N3TOOL

e_PlugType CN3CPlugBase::GetPlugTypeByFileName(const std::string& szFN)
{
	if (szFN.empty())
		return PLUGTYPE_UNDEFINED;

	// berserk
	// 일단 확장자로 구분한다. 별로 좋은 방법 같지는 않지만.. N3CPlug, N3CPlug_Cloak
	int nL = static_cast<int>(szFN.size());
	if (szFN[nL-2] == 'u' && szFN[nL-1] == 'g')
	{	// PLUGTYPE_NORMAL
		return PLUGTYPE_NORMAL;
	}
	else if (szFN[nL-2] == 'a' && szFN[nL-1] == 'k')
	{
		return PLUGTYPE_CLOAK;
	}
	else
	{
		return PLUGTYPE_UNDEFINED;
	}
}


CN3CPlug::CN3CPlug()
{
	m_ePlugType = PLUGTYPE_NORMAL;

	m_bRenderTrace = false;
	m_nTraceStep = 0; // 궤적 소멸 시간..
	m_crTrace = 0xfffffff; // 궤적 색깔.. 검은색이면 없다..
	m_fTrace0 = 0; // 궤적 위치..
	m_fTrace1 = 0; // 궤적 위치..

	m_pFXMainBundle = nullptr;
	m_pFXPart = nullptr;

	for(int i=0;i<MAX_FXTAIL;i++) m_pFXTailBundle[i] = nullptr;

//	m_strFXName[PLUGATTR_FIRE] = "fx//fire_sword0_1.fxb";
//	m_strFXName[PLUGATTR_ICE] = "fx//ice_sword0_1.fxb";
//	m_strFXName[PLUGATTR_LIGHTENNING] = "fx//poison_sword0_1.fxb";
//	m_strFXName[PLUGATTR_POISON] = "fx//fire_sword0_1.fxb";
}

CN3CPlug::~CN3CPlug()
{
	if(m_pFXMainBundle) { delete m_pFXMainBundle; m_pFXMainBundle = nullptr; }

	for(int i=0;i<MAX_FXTAIL;i++)
	{
		if(m_pFXTailBundle[i]) { delete m_pFXTailBundle[i]; m_pFXTailBundle[i] = nullptr; }
	}
}

void CN3CPlug::Release()
{
	CN3CPlugBase::Release();

	m_bRenderTrace = false;
	m_nTraceStep = 0; // 궤적 소멸 시간..
	m_crTrace = 0xffffffff; // 궤적 색깔.. 검은색이면 없다..
	m_fTrace0 = 0; // 궤적 위치..
	m_fTrace1 = 0; // 궤적 위치..

	m_PMeshInstFX.Release(); // FX 에 쓸 PMesh Instance

	if(m_pFXMainBundle) { delete m_pFXMainBundle; m_pFXMainBundle = nullptr; }

	for(int i=0;i<MAX_FXTAIL;i++)
	{
		if(m_pFXTailBundle[i]) { delete m_pFXTailBundle[i]; m_pFXTailBundle[i] = nullptr; }
	}
}

bool CN3CPlug::Load(File& file)
{
	CN3CPlugBase::Load(file);

	file.Read(&m_nTraceStep, 4); // 궤적 갯수..

	if (m_nTraceStep > 0)
	{
		file.Read(&m_crTrace, 4); // 궤적 색깔.. 검은색이면 없다..
		file.Read(&m_fTrace0, 4); // 궤적 위치..
		file.Read(&m_fTrace1, 4); // 궤적 위치..
	}
	else
	{
		m_nTraceStep = 0;
	}

	int iUseVMesh = 0;
	file.Read(&iUseVMesh, 4); // 메시를 쓰는가??

	if (iUseVMesh != 0)
	{
		CN3PMesh* pPMesh = new CN3PMesh();
		pPMesh->m_iFileFormatVersion = m_iFileFormatVersion; // NOTE: Setting the version for further components
		pPMesh->Load(file);

		static int iSN = 0;
		std::string szFNTmp = fmt::format("Temp_Plug_{}.N3PMesh", iSN++);
		pPMesh->FileNameSet(szFNTmp);

		s_MngPMesh.Add(pPMesh);
		m_PMeshInstFX.Create(pPMesh); // FX 에 쓸 PMesh Instance
	}

	m_strFXMainName.clear();
	m_strFXTailName.clear();
	InitFX(m_strFXMainName, m_strFXTailName, 0xffffffff);

	return true;
}

void CN3CPlug::InitFX(std::string& szFXMain, std::string& szFXTail, D3DCOLOR TraceCR)
{
	if(szFXMain.empty())
	{
		if(m_pFXMainBundle) delete m_pFXMainBundle;
		m_pFXMainBundle = nullptr;
		m_strFXMainName = szFXMain;
	}
	else if(!m_pFXMainBundle || szFXMain!=m_pFXMainBundle->FileName())
	{
		m_strFXMainName = szFXMain;
		if(m_pFXMainBundle) delete m_pFXMainBundle;
		m_pFXMainBundle = new CN3FXBundle;
		if(!m_pFXMainBundle->LoadFromFile(m_strFXMainName.c_str()))
		{
			delete m_pFXMainBundle;
			m_pFXMainBundle = nullptr;
			m_strFXMainName = "";

			m_crTrace = 0xffffffff;
		}
		else
		{
			m_pFXMainBundle->Trigger(0, -1, -1);
			m_pFXPart = (CN3FXPartBillBoard*)m_pFXMainBundle->GetPart(0);
			m_pFXPart->m_fCurrLife = (float)(rand() % 1000) / 100.0f;

			m_crTrace = TraceCR;
		}
	}

	if(szFXTail.empty())
	{
		m_strFXTailName = szFXTail;
		for(int i=0;i<MAX_FXTAIL;i++)
		{
			if(m_pFXTailBundle[i]) delete m_pFXTailBundle[i];
			m_pFXTailBundle[i] = nullptr;
		}
	}
	else if(!m_pFXTailBundle[0] || szFXTail!=m_pFXTailBundle[0]->FileName())
	{
		m_strFXTailName = szFXTail;
		if(m_pFXTailBundle[0]) delete m_pFXTailBundle[0];
		m_pFXTailBundle[0] = new CN3FXBundle;
		if(!m_pFXTailBundle[0]->LoadFromFile(m_strFXTailName.c_str()))
		{
			delete m_pFXTailBundle[0];
			m_pFXTailBundle[0] = nullptr;
			m_strFXTailName = "";
			return;			
		}
		else
		{
			CN3PMesh* pMesh = m_PMeshInstFX.GetMesh();
			__Vector3 vInterval(1.0f,1.0f,1.0f);
			if(pMesh) vInterval = m_PMeshInstFX.GetMesh()->Max() - m_PMeshInstFX.GetMesh()->Min();
			m_pFXTailBundle[0]->Trigger(0, -1, -1);
			for(int i=1;i<MAX_FXTAIL;i++)
			{
				if(m_pFXTailBundle[i]) delete m_pFXTailBundle[i];
				m_pFXTailBundle[i] = new CN3FXBundle;
				m_pFXTailBundle[0]->Duplicate(m_pFXTailBundle[i]);
				m_pFXTailBundle[i]->Trigger(0, -1, -1);
				m_pFXTailBundle[i]->m_fTargetScale = (vInterval.z + vInterval.y) * 0.7f;
			}
		}
	}
}

#ifdef _N3TOOL
bool CN3CPlug::Save(File& file)
{
	CN3CPlugBase::Save(file);

	file.Write(&m_nTraceStep, 4); // 궤적 갯수..
	if(m_nTraceStep > 0 && m_nTraceStep <= MAX_PLUG_TRACE_VERTEX/2 - 1)
	{
		file.Write(&m_crTrace, 4); // 궤적 색깔.. 검은색이면 없다..
		file.Write(&m_fTrace0, 4); // 궤적 위치..
		file.Write(&m_fTrace1, 4); // 궤적 위치..
	}
	else m_nTraceStep = 0;
	
	int iUseVMesh = (m_PMeshInstFX.GetMesh()) ? true : false; // 메쉬.. FX에 쓴다..
	file.Write(&iUseVMesh, 4); // 위치 정보 메시를 쓰는가??
	if(iUseVMesh) m_PMeshInstFX.GetMesh()->Save(file);

	return 0;
}
#endif

#ifdef _N3TOOL
void CN3CPlug::ImportPMesh(const std::string& szFileName)
{
	if(szFileName.empty()) return;
	m_PMeshInstFX.Release();
	m_PMeshInstFX.Create(szFileName);
}
#endif

#ifdef _N3TOOL
void CN3CPlug::RenderFXLines(const __Matrix44& mtxParent, const __Matrix44& mtxJoint) // FX 들어갈 곳에 선을 그려준다.
{
	static __Matrix44 mtx;
	mtx = m_Matrix;
	mtx *= mtxJoint;
	mtx *= mtxParent;
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());

	DWORD dwCull;
	s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	m_PMeshInstFX.SetLOD((s_CameraData.vEye - mtx.Pos()).Magnitude() * s_CameraData.fFOV);
	m_PMeshInstFX.Render();
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);
}
#endif

void CN3CPlug::Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint)
{
	if(false == m_bVisible) return;

	CN3CPlugBase::Render(mtxParent, mtxJoint);

	//fx render....
	RenderFX(mtxParent, mtxJoint);
}

void CN3CPlug::RenderFX(const __Matrix44& mtxParent, const __Matrix44& mtxJoint)
{
	if(!m_pFXMainBundle || !m_pFXPart) return;
	if(!m_PMeshInstFX.GetVertices()) return;
	__VertexT1* pvAxis = m_PMeshInstFX.GetVertices();
	//if(m_pFXMainBundle->FileName() != m_strFXMainName) InitFX(m_strFXMainName, m_strFXTailName);

	m_pFXMainBundle->Tick();

	static __Matrix44 mtx;
	//mtx = m_Matrix;
	//mtx *= mtxJoint;
	//mtx *= mtxParent;

	//tail...
	/////////////////////////////////////////////////////////////////////
	//
	__Vector3 vMax = m_PMeshInstFX.GetMesh()->Max();
	__Vector3 vMin = m_PMeshInstFX.GetMesh()->Min();
	__Vector3 vInterval = vMax - vMin;
	__Vector3 vTmp;
	float fHeight = vMax.y - vMin.y;
	if(m_pFXTailBundle[0])
	{
		mtx.Identity();
		mtx *= m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		for(int i=1;i<MAX_FXTAIL;i++)
		{
			if(m_pFXTailBundle[i])
			{
				vTmp.Set( vMin.x + (vInterval.x * 0.25f) + (vInterval.x * (float)(rand()%50) / 100.0f),
					vMin.y + (vInterval.y * 0.25f) + (vInterval.y * (float)(rand()%50) / 100.0f),
					vMin.z + (vInterval.z * 0.25f) + (vInterval.z * (float)(rand()%50) / 100.0f));
				
				m_pFXTailBundle[i]->m_vPos = vTmp * mtx;
				m_pFXTailBundle[i]->Tick();
				m_pFXTailBundle[i]->Render();
			}
		}
	}
	//
	/////////////////////////////////////////////////////////////////////

	//main...
	/////////////////////////////////////////////////////////////////////
	///
	if(m_pFXPart->m_dwRenderFlag & RF_ALPHABLENDING) // Alpha 사용
	{
		int iTexIdx = m_pFXPart->m_iTexIdx;
		mtx = m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		float fCameraDist = (s_CameraData.vEye - mtx.Pos()).Magnitude();

		m_PMeshInstFX.SetLOD(fCameraDist*s_CameraData.fFOV);
		
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_pFXPart->m_dwDestBlend;
			pAP->dwBlendSrc			= m_pFXPart->m_dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= fCameraDist + fHeight;

			pAP->lpTex				= nullptr;
			if(m_pFXPart->m_ppRefTex[iTexIdx])
				pAP->lpTex = m_pFXPart->m_ppRefTex[iTexIdx]->Get();
			
			pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMeshInstFX.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_pFXPart->m_dwRenderFlag;
			pAP->nVertexCount		= m_PMeshInstFX.GetNumVertices();
			pAP->MtxWorld			= mtx;
			pAP->pVertices			= m_PMeshInstFX.GetVertices();
			pAP->pwIndices			= m_PMeshInstFX.GetIndices();
		}

		float fArg1 = m_pFXMainBundle->m_fLife * 1.2f;
		float fArg2 = (0.07f * (fArg1 - (int)fArg1)) - 0.035f;
		__Vector3 vArg2 = pvAxis[0].n * fArg2;

		mtx.Identity();
		mtx.RotationY(-__PI / 36.0f);
		mtx += vArg2;
		mtx *= m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_pFXPart->m_dwDestBlend;
			pAP->dwBlendSrc			= m_pFXPart->m_dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - mtx.Pos()).Magnitude() + fHeight;

			pAP->lpTex				= nullptr;
			iTexIdx = (iTexIdx+1) % m_pFXPart->m_iNumTex;
			if(m_pFXPart->m_ppRefTex[iTexIdx])
				pAP->lpTex = m_pFXPart->m_ppRefTex[iTexIdx]->Get();
			
			pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMeshInstFX.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_pFXPart->m_dwRenderFlag;
			pAP->nVertexCount		= m_PMeshInstFX.GetNumVertices();
			pAP->MtxWorld			= mtx;
			pAP->pVertices			= m_PMeshInstFX.GetVertices();
			pAP->pwIndices			= m_PMeshInstFX.GetIndices();
		}

		mtx.Identity();
		mtx.RotationY(__PI / 36.0f);
		mtx -= vArg2;
		mtx *= m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB			= FALSE;
			pAP->dwBlendDest		= m_pFXPart->m_dwDestBlend;
			pAP->dwBlendSrc		= m_pFXPart->m_dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - mtx.Pos()).Magnitude() + fHeight;

			pAP->lpTex				= nullptr;
			iTexIdx = (iTexIdx+1) % m_pFXPart->m_iNumTex;
			if(m_pFXPart->m_ppRefTex[iTexIdx])
				pAP->lpTex = m_pFXPart->m_ppRefTex[iTexIdx]->Get();
			
			pAP->ePrimitiveType	= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMeshInstFX.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_pFXPart->m_dwRenderFlag;
			pAP->nVertexCount		= m_PMeshInstFX.GetNumVertices();
			pAP->MtxWorld			= mtx;
			pAP->pVertices			= m_PMeshInstFX.GetVertices();
			pAP->pwIndices			= m_PMeshInstFX.GetIndices();
		}
		/*
		fArg1 = m_pFXMainBundle->m_fLife * 1.2f;
		fArg2 = (0.07f * (fArg1 - (int)fArg1)) - 0.035f;
		vArg2 = pvAxis[0].n * fArg2;

		mtx.Identity();
		mtx.RotationY(-__PI / 72.0f);
		mtx.Scale(0.5f, 0.5f, 0.5f);
		mtx.PosSet(0.0f, m_PMeshInstFX.GetMesh()->Max().y * 0.6f, 0.0f);
		mtx += vArg2;
		mtx *= m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB			= FALSE;
			pAP->dwBlendDest		= m_pFXPart->m_dwDestBlend;
			pAP->dwBlendSrc		= m_pFXPart->m_dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - mtx.Pos()).Magnitude() + fHeight;

			pAP->lpTex				= nullptr;
			iTexIdx = (iTexIdx+1) % m_pFXPart->m_iNumTex;
			if(m_pFXPart->m_ppRefTex[iTexIdx])
				pAP->lpTex = m_pFXPart->m_ppRefTex[iTexIdx]->Get();
			
			pAP->ePrimitiveType	= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMeshInstFX.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_pFXPart->m_dwRenderFlag;
			pAP->nVertexCount		= m_PMeshInstFX.GetNumVertices();
			pAP->MtxWorld			= mtx;
			pAP->pVertices			= m_PMeshInstFX.GetVertices();
			pAP->pwIndices			= m_PMeshInstFX.GetIndices();
		}

		mtx.Identity();
		mtx.RotationY(__PI / 72.0f);
		mtx.Scale(0.5f, 0.5f, 0.5f);
		mtx.PosSet(0.0f, m_PMeshInstFX.GetMesh()->Max().y * 0.5f, 0.0f);
		mtx -= vArg2;
		mtx *= m_Matrix;
		mtx *= mtxJoint;
		mtx *= mtxParent;

		pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB			= FALSE;
			pAP->dwBlendDest		= m_pFXPart->m_dwDestBlend;
			pAP->dwBlendSrc		= m_pFXPart->m_dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - mtx.Pos()).Magnitude() + fHeight;

			pAP->lpTex				= nullptr;
			iTexIdx = (iTexIdx+1) % m_pFXPart->m_iNumTex;
			if(m_pFXPart->m_ppRefTex[iTexIdx])
				pAP->lpTex = m_pFXPart->m_ppRefTex[iTexIdx]->Get();
			
			pAP->ePrimitiveType	= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMeshInstFX.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_pFXPart->m_dwRenderFlag;
			pAP->nVertexCount		= m_PMeshInstFX.GetNumVertices();
			pAP->MtxWorld			= mtx;
			pAP->pVertices			= m_PMeshInstFX.GetVertices();
			pAP->pwIndices			= m_PMeshInstFX.GetIndices();
		}
		*/
	}
	///
	////////////////////////////////////////////////////////////////////////
	return;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CN3cPlug_Cloak Codes Start here
CN3CPlug_Cloak::CN3CPlug_Cloak()
{
	CN3CPlugBase::CN3CPlugBase();
}

CN3CPlug_Cloak::~CN3CPlug_Cloak()
{
	Release();
}

void CN3CPlug_Cloak::Release()
{
	CN3CPlugBase::Release();
}

bool CN3CPlug_Cloak::Load(File& file)
{
	CN3CPlugBase::Load(file);
#ifdef _N3GAME
	m_Cloak.Init(this);
#endif
	return 0;
}

#ifdef _N3TOOL
bool CN3CPlug_Cloak::Save(File& file)
{
	CN3CPlugBase::Save(file);
	return 0;
}
#endif
void CN3CPlug_Cloak::Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint)
{
#ifdef _N3TOOL
	CN3CPlugBase::Render(mtxParent, mtxJoint);
#endif
#ifdef _N3GAME
	static __Matrix44 mtx;
	mtx = m_Matrix;
	mtx *= mtxJoint;
	mtx *= mtxParent;
	m_Cloak.Render(mtx);
#endif
}

void CN3CPlug_Cloak::SetLOD(int nLOD)
{
#ifdef _N3GAME
	m_Cloak.SetLOD(nLOD);
#endif
}
// CN3cPlug_Cloak Codes End here
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// Part, Plug....
////////////////////////////////
int CN3Chr::s_iLODDelta = 0; // LOD 계산에 필요한 인덱스..

CN3Chr::CN3Chr()
{
	m_dwType |= OBJ_CHARACTER;

	m_pRootJointRef = nullptr;
	m_pRootJointRef = nullptr;

	m_pAniCtrlRef = nullptr;
	m_pMeshCollision = nullptr;
	m_pFXPlug = nullptr;

//	m_pSkinCollision = nullptr;
	m_fAniSpeedDelta = 1.0f;			// 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..

	this->Release();
}

CN3Chr::~CN3Chr()
{
	s_MngJoint.Delete(&m_pRootJointRef);

	for (auto itr = m_Parts.begin(); itr != m_Parts.end(); ++itr)
		delete *itr;
	m_Parts.clear();

	for (auto itr = m_Plugs.begin(); itr != m_Plugs.end(); ++itr)
		delete *itr;
	m_Plugs.clear();

	for (auto itr = m_vTraces.begin(); itr != m_vTraces.end(); ++itr)
		delete *itr;
	m_vTraces.clear();

	// Animation Control
	s_MngAniCtrl.Delete(&m_pAniCtrlRef);

	// 충돌 메시는 캐릭터에서는 지운다..
	delete m_pMeshCollision; m_pMeshCollision = nullptr;

	delete m_pFXPlug;
}

void CN3Chr::Release()
{
	m_nLOD = 0;

	s_MngJoint.Delete(&m_pRootJointRef);

	m_JointRefs.clear();
	m_MtxJoints.clear();
	m_MtxInverses.clear();

	for (auto itr = m_Parts.begin(); itr != m_Parts.end(); ++itr)
		delete *itr;
	m_Parts.clear();

	for (auto itr = m_Plugs.begin(); itr != m_Plugs.end(); ++itr)
		delete *itr;
	m_Plugs.clear();

	for (auto itr = m_vTraces.begin(); itr != m_vTraces.end(); ++itr)
		delete *itr;
	m_vTraces.clear();

//	s_MngSkin.Delete(m_pSkinCollision);
//	m_pSkinCollision = nullptr;

	// Animation Control
	s_MngAniCtrl.Delete(&m_pAniCtrlRef);

	for(int i = 0; i < MAX_CHR_ANI_PART; i++)
	{
		m_nJointPartStarts[i] = -1; // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 시작 번호
		m_nJointPartEnds[i] = -1; // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 끝 번호

		m_FrmCtrl.Init();
		m_FrmCtrlUpper.Init();
	}

	m_fAniSpeedDelta = 1.0f;			// 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..

	// 충돌 메시는 캐릭터에서는 지운다..
	delete m_pMeshCollision; m_pMeshCollision = nullptr;

	if (m_pFXPlug) {delete m_pFXPlug; m_pFXPlug = nullptr;}

	CN3TransformCollision::Release();
}

bool CN3Chr::Load(File& file)
{
	if (m_pRootJointRef != nullptr)
		Release();

	CN3TransformCollision::Load(file);
	
	int nL = 0;
	char szFN[512] = "";

	file.Read(&nL, 4);
	file.Read(szFN, nL); szFN[nL] = '\0';
	this->JointSet(szFN); // 뼈대 세팅..

	// Part Allocation, Loading .. 
	int iPC = 0;
	file.Read(&iPC, 4);
	this->PartAlloc(iPC);
	for(int i = 0; i < iPC; i++)
	{
		nL = 0;
		file.Read(&nL, 4);
		if(nL > 0)
		{
			file.Read(szFN, nL); szFN[nL] = '\0';
			m_Parts[i]->LoadFromFile(szFN);
		}
	}
	
	// Plug Allocation, Loading .. 
	m_Plugs.clear();
	file.Read(&iPC, 4);
	this->PlugAlloc(iPC);
	for(int i = 0; i < iPC; i++)
	{
		nL = 0;
		file.Read(&nL, 4);
		if(nL > 0)
		{
			file.Read(szFN, nL); szFN[nL] = '\0';
			m_Plugs[i]->LoadFromFile(szFN);

//			CN3CPlugBase* pPlug = nullptr;
//			e_PlugType eType = CN3CPlugBase::GetPlugTypeByFileName(szFN);
//			if (eType == PLUGTYPE_NORMAL)			
//			{	// PLUGTYPE_NORMAL
//				pPlug = (CN3CPlugBase*) new CN3CPlug();
//				if(false == pPlug->LoadFromFile(szFN))
//				{
//					delete pPlug;
//					continue;
//				}
//			}
//			else if (eType == PLUGTYPE_CLOAK)
//			{	// PLUGTYPE_CLOAK
//				pPlug = (CN3CPlugBase*) new CN3CPlug_Cloak();
//				if(false == pPlug->LoadFromFile(szFN))
//				{
//					delete pPlug;
//					continue;
//				}
//			}
//			else
//			{
//				__ASSERT(0, "Undefined plug type");
//			}
//			m_Plugs.push_back(pPlug);
		}
	}

	// Animation Control..
	nL = 0;
	file.Read(&nL, 4);
	if(nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0';
		this->AniCtrlSet(szFN);
	}

	for (int i = 0; i < 2; i++)
		file.Read(&m_nJointPartStarts[i], sizeof(int)); // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 시작 번호

	for (int i = 0; i < 2; i++)
		file.Read(&m_nJointPartEnds[i], sizeof(int)); // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 끝 번호

//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-10 오후 2:33:07 )
//	FXPlug
	nL = 0;
	file.Read(&nL, sizeof(nL));
	if (nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0';
		FXPlugSet(szFN);
	}
//	End Of Code (By Dino On 2002-10-10 오후 2:33:07 )
//////////////////////////////////////////////////
	

	this->Init(); // 에니메이션, 조인트, 플러그등.... 초기화 작업 수행..

	return 0;
}

__AnimData* CN3Chr::AniDataCur()
{
	if(nullptr == m_pAniCtrlRef) return nullptr;
	return m_pAniCtrlRef->DataGet(m_FrmCtrl.iAni);
}

#ifdef _N3TOOL
__AnimData* CN3Chr::AniDataUpper()
{
	if(nullptr == m_pAniCtrlRef) return nullptr;
	return m_pAniCtrlRef->DataGet(m_FrmCtrlUpper.iAni);
}

bool CN3Chr::Save(File& file)
{
	CN3TransformCollision::Save(file);

	int nL = 0;

	// 관절 파일 이름 써주기..
	if (m_pRootJointRef != nullptr)
		nL = static_cast<int>(m_pRootJointRef->FileName().size());
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_pRootJointRef->FileName().c_str(), nL);

	// 내용이 없는 Part Data는 걸러낸다..
	std::vector<CN3CPart*> PartsTmp = m_Parts;
	m_Parts.clear();
	m_Parts.reserve(64);

	it_CPart it = PartsTmp.begin(), itEnd = PartsTmp.end();
	CN3CPart* pPart = nullptr;
	for (; it != itEnd; it++)
	{
		pPart = *it;

		bool bHaveData = false;
		if (pPart->m_pSkinsRef)
		{
			for (int j = 0; j < MAX_CHR_LOD; j++)
			{
				if (pPart->m_pSkinsRef->m_Skins[j].VertexCount() > 0)
				{
					bHaveData = true;
					break;
				}
			}
		}

		if (bHaveData) // 실제 데이터가 있으면..
		{
			m_Parts.push_back(pPart);
		}
		else // 없으면..
		{
			delete pPart; // 지운다..
			*it = nullptr;
		}
	}

	// 실제 저장..
	int iPC = static_cast<int>(m_Parts.size());
	file.Write(&iPC, 4);

	for (int i = 0; i < iPC; i++)
	{
		nL = static_cast<int>(m_Parts[i]->FileName().size());
		if (nL <= 0)
		{
			std::string szFNTmp = fmt::format("{}_Default{}.N3CPart", m_szName, i);
			m_Parts[i]->FileNameSet(szFNTmp);
		}

		nL = static_cast<int>(m_Parts[i]->FileName().size());
		file.Write(&nL, 4);
		file.Write(m_Parts[i]->FileName().c_str(), nL);
		m_Parts[i]->SaveToFile();
	}

	iPC = static_cast<int>(m_Plugs.size());
	file.Write(&iPC, 4);
	for (int i = 0; i < iPC; i++)
	{
		nL = static_cast<int>(m_Plugs[i]->FileName().size());
		if (nL <= 0)
		{
			std::string szFNTmp = fmt::format("{}_Default{}.N3CPlug", m_szName, i);
			m_Plugs[i]->FileNameSet(szFNTmp);
			i++;
		}

		nL = static_cast<int>(m_Plugs[i]->FileName().size());
		file.Write(&nL, 4);
		file.Write(m_Plugs[i]->FileName().c_str(), nL);
		m_Plugs[i]->SaveToFile();
	}

//	nL = 0;
//	if(m_pSkinCollision) nL = m_pSkinCollision->m_szName.size();
//	file.Write(&nL, 4);
//	if(nL > 0) file.Write(m_pSkinCollision->m_szName.c_str(), nL);

	// Animation Control..
	nL = 0;
	if (m_pAniCtrlRef != nullptr)
		nL = static_cast<int>(m_pAniCtrlRef->FileName().size());
	file.Write(&nL, 4);
	if (nL > 0)
		file.Write(m_pAniCtrlRef->FileName().c_str(), nL);

	for (int i = 0; i < 2; i++)
		file.Write(&m_nJointPartStarts[i], sizeof(int)); // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 시작 번호

	for (int i = 0; i < 2; i++)
		file.Write(&m_nJointPartEnds[i], sizeof(int)); // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 끝 번호

//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-11 오후 2:19:11 )
//	FXPlug
	nL = 0;
	if (m_pFXPlug != nullptr)
		nL = static_cast<int>(m_pFXPlug->FileName().size());
	file.Write(&nL, sizeof(nL));
	if (nL > 0)
	{
		file.Write(m_pFXPlug->FileName().c_str(), nL);
		m_pFXPlug->SaveToFile();
	}
//	End Of Code (By Dino On 2002-10-11 오후 2:19:11 )
//////////////////////////////////////////////////

	return true;
}
#endif // end of _N3TOOL

void CN3Chr::Tick(float fFrm)
{
	if(nullptr == m_pRootJointRef)
	{
		m_nLOD = -1;
		return;
	}

	// 카메라와 멀리 떨어지면 지나간다..
	float fDist = (m_vPos - s_CameraData.vEye).Magnitude();
	if(fDist > s_CameraData.fFP + m_fRadius * 2.0f)
	{
		m_nLOD = -1;
		return;
	}

	// LOD 결정...
	m_nLOD = MAX_CHR_LOD;
	float fLOD = fDist * s_CameraData.fFOV / (m_fRadius * m_vScale.x); // 덩치에 비례하게 한다..
	for(int i = 0; i < MAX_CHR_LOD; i++)
	{
		if(fLOD < CHR_LOD_CALCULATION_VALUES[0][i]) // 일단 가장 큰값을 기준으로 하고 LOD 값을 정한 다음..... Render 에서 변경한다....
		{
			m_nLOD = i;
			break;
		}
	}
	if(m_nLOD < 0 && m_nLOD >= MAX_CHR_LOD) return; // LOD 밖이면 나간다.

	static __Vector3 vPos2;
	vPos2 = m_vPos;
	vPos2.y += 1.8f;
	float fOffset = m_fRadius * 3.0f + 2.0f;
	if(	s_CameraData.IsOutOfFrustum(m_vPos, fOffset) &&
		s_CameraData.IsOutOfFrustum(vPos2, fOffset) ) // 카메라 사면체 바깥이면 지나간다.. 현 지점과 머리 끝점을 조사..
	{
		m_nLOD = -1;
		return;
	}

	m_FrmCtrl.fFrmPrev = m_FrmCtrl.fFrmCur; // 마지막 에니메이션 프레임을 기억해 놓고..
	m_FrmCtrlUpper.fFrmPrev = m_FrmCtrlUpper.fFrmCur;

	if (fFrm == FRAME_SELFPLAY)
	{
		TickAnimationFrame();
	}
	else
	{
		// 걍 단순히 조인트만 Tick 해주고 나간다..
		for (size_t i = 0; i < m_JointRefs.size(); i++)
		{
			m_JointRefs[i]->TickAnimationKey(fFrm);
			m_JointRefs[i]->ReCalcMatrix();
			m_MtxJoints[i] = m_JointRefs[i]->m_Matrix;
		}

		m_FrmCtrl.fFrmCur = fFrm;
		m_FrmCtrl.fBlendFrm = fFrm;
		m_FrmCtrl.fBlendTime = 0;
	}

	if(!m_Plugs.empty()) this->TickPlugs(fLOD); // 붙은 무기 Tick

//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-11 오전 11:21:21 )
//	FXPlug
	if (m_pFXPlug) m_pFXPlug->Tick(this);
//	End Of Code (By Dino On 2002-10-11 오전 11:21:21 )
//////////////////////////////////////////////////

}

void CN3Chr::TickAnimationFrame()
{
	if(nullptr == m_FrmCtrl.pAniData) return; // 에니메이션 데이터 가 없다!!

	// 루핑중이고 지연시간이 있으면..
	if(	(m_FrmCtrl.pAniData->iBlendFlags & 1) &&
		m_FrmCtrl.iAniLoop > 0 && 
		m_FrmCtrl.bProcessingDelayNow && 
		m_FrmCtrl.fBlendTime == 0)
	{
		m_FrmCtrl.fBlendTime = m_FrmCtrl.pAniData->fTimeBlend;
		m_FrmCtrl.fBlendTimeCur = 0.0f;
		m_FrmCtrl.fBlendFrm = m_FrmCtrl.pAniData->fFrmEnd;
		m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmStart;
		m_FrmCtrl.iAniLoop = 0;
	}

	float fDelta = s_fSecPerFrm * m_fAniSpeedDelta;			// 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..

	if(0.0f != m_FrmCtrl.fBlendTime) // Blending 할 에니메이션이 있으면..
	{
		m_FrmCtrl.fBlendTimeCur += fDelta;
		if(m_FrmCtrl.fBlendTimeCur > m_FrmCtrl.fBlendTime) // Blending 이 끝났다.
		{
			m_FrmCtrl.fBlendTime = 0.0f;
			m_FrmCtrl.fBlendTimeCur = 0.0f;
			m_FrmCtrl.bProcessingDelayNow = false; // 지연처리 끝..
		}
	}
	else // 블렌딩 할게 없으면..
	{
		m_FrmCtrl.fFrmCur += m_FrmCtrl.pAniData->fFrmPerSec * fDelta; // Frame Tick
		if(m_FrmCtrl.fFrmCur < m_FrmCtrl.pAniData->fFrmStart) m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmStart;
		if(m_FrmCtrl.fFrmCur > m_FrmCtrl.pAniData->fFrmEnd) // 에니메이션이 한번 순환하면..
		{
			if(m_FrmCtrl.fFreezeTime > 0) // 멈춰야 된다면..
			{
				m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmEnd; // 에니메이션 데이터의 마지막 프레임으로 하고..
				m_FrmCtrl.fFreezeTime -= fDelta; // 멈출 시간..
				if(m_FrmCtrl.fFreezeTime < 0)
				{
					m_FrmCtrl.fFreezeTime = 0; // 멈추는 시간 다시 세팅..
					m_FrmCtrl.iAniLoop++; // 에니메이션 한번 했다~
				}
			}
			else
			{
				m_FrmCtrl.fFreezeTime = 0;
				m_FrmCtrl.iAniLoop++;

				if(m_FrmCtrl.bOnceAndFreeze) m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmEnd; // 한번 에니메이션 하고 멈춰야 한다면.. 걍 멈춰 있는다..
				else if(m_FrmCtrl.pAniData->iBlendFlags & 1) // 루핑 지연시간이 있으면..
				{
					m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmEnd;
					m_FrmCtrl.bProcessingDelayNow = true; // 지연 처리.. 시작..
				}
				else
				{
					float fFrmDiff = m_FrmCtrl.pAniData->fFrmEnd - m_FrmCtrl.pAniData->fFrmStart;
					if(fFrmDiff > 0) m_FrmCtrl.fFrmCur -= m_FrmCtrl.pAniData->fFrmEnd - m_FrmCtrl.pAniData->fFrmStart;
					else m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmStart;
				}
			}
		}
	} // end of else // 블렌딩 할게 없으면..

	if(m_FrmCtrlUpper.pAniData) // 상하체를 분리해야 하면.. // 따로 처리해야 한다면..
	{
		if(0.0f != m_FrmCtrlUpper.fBlendTime) // Blending 할 에니메이션이 있으면..
		{
			m_FrmCtrlUpper.fBlendTimeCur += fDelta;
			if(	m_FrmCtrlUpper.fBlendTimeCur > m_FrmCtrlUpper.fBlendTime) // Blending 이 끝났다.
			{
				if( m_FrmCtrlUpper.iAniLoop > 0) // 블렌딩 끝.. 이젠 하체로만 에니메이션 맞춘다.
					m_FrmCtrlUpper.Init(); // 상체 에니메이션 끝!!				
				else
					m_FrmCtrlUpper.fBlendTime = 0;
			}
		}
		else // 블렌딩 할게 없으면..
		{
			m_FrmCtrlUpper.fFrmCur += m_FrmCtrlUpper.pAniData->fFrmPerSec * fDelta; // Frame Tick
			if(m_FrmCtrlUpper.fFrmCur < m_FrmCtrlUpper.pAniData->fFrmStart) m_FrmCtrlUpper.fFrmCur = m_FrmCtrlUpper.pAniData->fFrmStart;
			if(m_FrmCtrlUpper.fFrmCur > m_FrmCtrlUpper.pAniData->fFrmEnd) // 에니메이션이 한번 순환하면..
			{
				if(m_FrmCtrlUpper.fFreezeTime > 0) // 멈춰야 된다면..
				{
					m_FrmCtrlUpper.fFrmCur = m_FrmCtrlUpper.pAniData->fFrmEnd; // 에니메이션 데이터의 마지막 프레임으로 하고..

					m_FrmCtrlUpper.fFreezeTime -= fDelta; // 멈출 시간..
					if(m_FrmCtrlUpper.fFreezeTime < 0) m_FrmCtrlUpper.fFreezeTime = 0;
				}
				else // 멈출거 없음.. 하체 에니메이션으로 블렌딩을 한다.
				{
					m_FrmCtrlUpper.iAniLoop++; // 이렇게 에니메이션이 끝나면.. 하체 에니메이션으로 블렌딩이 된다.
					m_FrmCtrlUpper.fBlendFrm = m_FrmCtrlUpper.pAniData->fFrmEnd;
					m_FrmCtrlUpper.fBlendTime = m_FrmCtrlUpper.pAniData->fTimeBlend;
					m_FrmCtrlUpper.fBlendTimeCur = 0;
				}
			}
		} // end of else // 블렌딩 할게 없으면..
	}
}

void CN3Chr::TickJoints()
{
	// 상하체 통째로 처리..
	if (m_FrmCtrlUpper.pAniData == nullptr)
	{
		for (size_t i = 0; i < m_JointRefs.size(); i++)
		{
			if (m_FrmCtrl.fBlendTime > 0)
			{
				float fBlendFactor = m_FrmCtrl.fBlendTimeCur / m_FrmCtrl.fBlendTime;
				m_JointRefs[i]->ReCalcMatrixBlended(m_FrmCtrl.fFrmCur, m_FrmCtrl.fBlendFrm, fBlendFactor); // Joint Animation Blending...
			}
			else
			{
				m_JointRefs[i]->TickAnimationKey(m_FrmCtrl.fFrmCur);
				m_JointRefs[i]->ReCalcMatrix();
			}
			m_MtxJoints[i] = m_JointRefs[i]->m_Matrix;
		}
	}
	// 상하체 따로 처리해야 한다면..
	else
	{
		__FrmCtrl* pFrmCtrls[2] = { &m_FrmCtrl, &m_FrmCtrlUpper };
		for (int i = 0; i < MAX_CHR_ANI_PART; i++)
		{
			// 하체일경우 루트 조인트 작동...
			if (0 == i)
			{
				if (pFrmCtrls[i]->fBlendTime > 0) // Motion Blending 이 필요하면...
				{
					float fBlendFactor = pFrmCtrls[i]->fBlendTimeCur / pFrmCtrls[i]->fBlendTime;
					m_pRootJointRef->ReCalcMatrixBlended(pFrmCtrls[i]->fFrmCur, pFrmCtrls[i]->fBlendFrm, fBlendFactor); // Joint Animation Blending...// 하체 일경우
				}
				else
				{
					m_pRootJointRef->TickAnimationKey(pFrmCtrls[i]->fFrmCur);
					m_pRootJointRef->ReCalcMatrix();
				}
				m_MtxJoints[i] = m_pRootJointRef->m_Matrix;
			}

			if (m_nJointPartStarts[i] > 0)
			{
				float fBlendFactor = pFrmCtrls[i]->fBlendTimeCur / pFrmCtrls[i]->fBlendTime;
				for (int j = m_nJointPartStarts[i]; j <= m_nJointPartEnds[i]; j++)
				{
					if (pFrmCtrls[i]->fBlendTime > 0)
						m_JointRefs[j]->ReCalcMatrixBlended(pFrmCtrls[i]->fFrmCur, pFrmCtrls[i]->fBlendFrm, fBlendFactor); // Joint Animation Blending...
					else
					{
						m_JointRefs[j]->TickAnimationKey(pFrmCtrls[i]->fFrmCur); // 
						m_JointRefs[j]->ReCalcMatrix();
					}

					m_MtxJoints[j] = m_JointRefs[j]->m_Matrix;
				}
			}
		}
	}
}

void CN3Chr::TickPlugs(float fLOD)
{
	if(nullptr == this->m_pRootJointRef) return;
	
	float fFrmCur = m_FrmCtrl.fFrmCur;
//	if(m_FrmCtrlUpper.pAniData) fFrmCur = m_FrmCtrlUpper.fFrmCur; // 상체 에니메이션이 있으면...

	for (size_t i = 0; i < m_Plugs.size(); i++)
	{
		CN3CPlug* pPlug = m_Plugs[i];

		pPlug->m_PMeshInst.SetLOD(fLOD);
		if (pPlug->m_ePlugType== PLUGTYPE_NORMAL)
		{
			__AnimData* pAniData = m_FrmCtrlUpper.pAniData;
			if(nullptr == pAniData) pAniData = m_FrmCtrl.pAniData;
			if(nullptr == pAniData) continue;
			if(pPlug->m_nTraceStep <= 0) continue;
			
			pPlug->m_bRenderTrace = false;
			if(!(pAniData->fFrmPlugTraceEnd - pAniData->fFrmPlugTraceStart)) continue; // 궤적 프레임의 시작과 끝이 차이가 없으면..
			
			if(	pPlug->m_nTraceStep > 0 && 
				fFrmCur >= pAniData->fFrmPlugTraceStart &&
				fFrmCur <= pAniData->fFrmPlugTraceEnd) // 궤적 프레임의 안에 있으면..
			{
				pPlug->m_bRenderTrace = true;

				int iJTmp = 0;
				float fFrmTmp = fFrmCur;
				__Vector3	vTrace0, vTrace1;
				D3DCOLOR crTraceU = pPlug->m_crTrace;
				D3DCOLOR crTraceL = pPlug->m_crTrace;

				for(int j = 0, k = pPlug->m_nTraceStep; j < pPlug->m_nTraceStep; j++, k--) // 폴리곤을 만든다..
				{
					fFrmTmp = fFrmCur - (j*0.2f);
					iJTmp = 0;
					if(fFrmTmp < pAniData->fFrmStart) fFrmTmp = pAniData->fFrmStart;
					
					m_pRootJointRef->Tick(fFrmTmp);

					vTrace0.Set(0,pPlug->m_fTrace0, 0);
					vTrace1.Set(0,pPlug->m_fTrace1, 0);

					vTrace0 *= pPlug->m_Matrix;
					vTrace0 *= m_JointRefs[pPlug->m_nJointIndex]->m_Matrix;
					vTrace1 *= pPlug->m_Matrix;
					vTrace1 *= m_JointRefs[pPlug->m_nJointIndex]->m_Matrix;

					crTraceU =	(pPlug->m_crTrace & 0xff000000) |
								((((pPlug->m_crTrace & 0x00ff0000) >> 16) * k / pPlug->m_nTraceStep) << 16) |
								((((pPlug->m_crTrace & 0x0000ff00) >> 8) * k / pPlug->m_nTraceStep) << 8) |
								((pPlug->m_crTrace & 0x000000ff) * k / pPlug->m_nTraceStep);
					crTraceL =	(crTraceU & 0xff000000) | ((crTraceU & 0x00fcfcfc) >> 2);

					m_vTraces[i][j*2+0].Set(vTrace0, crTraceL);
					m_vTraces[i][j*2+1].Set(vTrace1, crTraceU);
				}
			}
		}
		else if (pPlug->m_ePlugType == PLUGTYPE_CLOAK)
		{	// PLUGTYPE_CLOAK
//#ifdef _N3GAME
//			CN3CPlug_Cloak* pPlugCloak = (CN3CPlug_Cloak*)pPlug;
//			pPlugCloak->GetCloak()->Tick(m_nLOD, yaw, move state);
//#endif
		}		
	}
}

void CN3Chr::RemakePlugTracePolygons()
{
	for (auto itr = m_vTraces.begin(); itr != m_vTraces.end(); ++itr)
		delete *itr;
	m_vTraces.clear();

	if (m_Plugs.empty())
		return;

	size_t iPC = m_Plugs.size();
	m_vTraces.assign(iPC, nullptr);
	for(size_t i = 0; i < iPC; i++)
	{
		int iTS = m_Plugs[i]->m_nTraceStep;
		if(iTS <= 0) continue;

		m_vTraces[i] = new __VertexColor[iTS * 2];
	}
}

void CN3Chr::Render()
{
	if(nullptr == m_pRootJointRef) return;
	if(m_nLOD < 0 || m_nLOD >= MAX_CHR_LOD) return;


#ifdef _DEBUG
	CN3Base::s_RenderInfo.nChr++; // Rendering Information Update...
#endif



	// LOD 최종 결정...
	if(s_iLODDelta > 0)
	{
		m_nLOD = MAX_CHR_LOD;
		float fDist = (m_vPos - s_CameraData.vEye).Magnitude();
		float fLOD = fDist * s_CameraData.fFOV / (m_fRadius * m_vScale.x); // 덩치에 비례하게 한다..
		for(int i = 0; i < MAX_CHR_LOD; i++)
		{
			if(fLOD < CHR_LOD_CALCULATION_VALUES[s_iLODDelta][i]) // 일단 가장 큰값을 기준으로 하고 LOD 값을 정한 다음..... Render 에서 변경한다....
			{
				m_nLOD = i;
				break;
			}
		}
		if(m_nLOD >= MAX_CHR_LOD) m_nLOD = MAX_CHR_LOD - 1; // LOD 밖이면 ... 
	}

	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	TickJoints(); // 조인트 행렬들 계산...
	BuildMesh(); // 행렬에 따라 점위치 계산..

	for (CN3CPart* pPart : m_Parts)
		pPart->Render(m_nLOD);

	// Plug - 붙이는 부분 Rendering
	for (size_t i = 0; i < m_Plugs.size(); i++)
	{
		CN3CPlug* pPlug = m_Plugs[i];
		if (!pPlug->m_bVisible)
			continue;

		if (pPlug->m_nJointIndex < 0)
			continue;

		pPlug->Render(m_Matrix, m_MtxJoints[pPlug->m_nJointIndex]);

		////////////////////////////////////////////////////
		// 검기 그리기...
		if (pPlug->m_ePlugType == PLUGTYPE_NORMAL)
		{
			if(pPlug->m_nTraceStep <= 1) continue;
			if(false == pPlug->m_bRenderTrace) continue;

			__AlphaPrimitive* pAP = s_AlphaMgr.Add();
			if(pAP)
			{
				pAP->bUseVB				= FALSE;
				pAP->dwBlendDest		= D3DBLEND_ONE;
#ifdef _REPENT
				pAP->dwBlendSrc			= D3DBLEND_ONE;
#else
				pAP->dwBlendSrc			= D3DBLEND_SRCCOLOR;
#endif
				pAP->dwFVF				= FVF_CV;
				pAP->dwPrimitiveSize	= sizeof(__VertexColor);
				pAP->fCameraDistance	= (s_CameraData.vEye - m_Matrix.Pos()).Magnitude();
				pAP->lpTex				= nullptr;
				pAP->ePrimitiveType		= D3DPT_TRIANGLESTRIP;
				pAP->nPrimitiveCount	= (pPlug->m_nTraceStep-1)*2;
				pAP->nRenderFlags		= RF_DOUBLESIDED | RF_DIFFUSEALPHA | RF_NOTUSELIGHT | RF_NOTZWRITE;
				pAP->nVertexCount		= (pPlug->m_nTraceStep)*2;
				pAP->MtxWorld			= m_Matrix;
				pAP->pVertices			= m_vTraces[i];
				pAP->pwIndices			= nullptr;
			}
		}
		else if (pPlug->m_ePlugType == PLUGTYPE_CLOAK)
		{
		}
		// 검기 그리기...
		////////////////////////////////////////////////////
	}

//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-11 오전 11:20:19 )
//	FXPlug
	if (m_pFXPlug) m_pFXPlug->Render();
//	End Of Code (By Dino On 2002-10-11 오전 11:20:19 )
//////////////////////////////////////////////////
}


void CN3Chr::BuildMesh()
{
	if(m_nLOD < 0 || m_nLOD >= MAX_CHR_LOD) return;
	if(m_MtxJoints.empty() || m_MtxInverses.empty()) return;
	__ASSERT(m_pRootJointRef, "Joint pointer is NULL!");

	float fWeight = 0;
	int nJIndex = 0, nAffect = 0;

	__Matrix44* pMtxJs = &(m_MtxJoints[0]);
	__Matrix44* pMtxJIs = &(m_MtxInverses[0]);

	for (CN3CPart* pPart : m_Parts)
	{
		CN3Skin* pSkin = pPart->Skin(m_nLOD);
		if (pSkin == nullptr)
			continue;

		__VertexXyzNormal* pVDest = pSkin->Vertices();
		__VertexSkinned* pVSrc = pSkin->SkinVertices();
		if (pVDest == nullptr || pVSrc == nullptr)
			continue;

		int nVC = pSkin->VertexCount();
		__Vector3 vFinal;
		int nAffect = 0;
		float* pfWeights = nullptr;
		for (int j = 0; j < nVC; j++) // j < m_nBoneVertices 와 같다..
		{
			nAffect = pVSrc[j].nAffect;
			if (1 == nAffect)
			{
				// 단일 뼈대...
				nJIndex = pVSrc[j].pnJoints[0];
				pVDest[j] = (pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex];
			}
			else if (nAffect > 1)
			{
				vFinal.Zero();
				pfWeights = pVSrc[j].pfWeights;
				for (int k = 0; k < nAffect; k++)
				{
					nJIndex = pVSrc[j].pnJoints[k];
					vFinal += ((pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex]) * pfWeights[k];
				}
				pVDest[j] = vFinal;
			}
		}
	}

/*	if(m_pMeshCollision && m_pSkinCollision)
	{
		__ASSERT(m_pMeshCollision->IndexCount() > 0, "Indices count is less than 0");

		__Vector3* pVDest = m_pMeshCollision->Vertices();
		__VertexSkinned* pVSrc = m_pSkinCollision->Vertices();

		nVC = m_pMeshCollision->VertexCount();
		int nSVC = m_pSkinCollision->VertexCount();
		if(nSVC != nVC)
		{
			__ASSERT(0, "Mesh Vertices count is different to Skin vertices count");
		}
		else
		{
			int nAffect = 0;
			float* pfWeights = nullptr;
			for(j = 0; j < nVC; j++) // j < m_nBoneVertices 와 같다..
			{
				nAffect = pVSrc[j].nAffect;
				if(1 == nAffect)
				{
					// 단일 뼈대...
					nJIndex = pVSrc[j].pnJoints[0];
					pVDest[j] = (pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex];
				}
				else if(nAffect > 1) 
				{
					pVDest[j].Zero();
					pfWeights = pVSrc[j].pfWeights;
					for(k = 0; k < nAffect; k++)
					{
						if(pfWeights[k] <= 0) continue;

						nJIndex = pVSrc[j].pnJoints[k];
						pVDest[j] += ((pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex]) * pfWeights[k];
					}
				}
			}
		}
	}
*/

}

void CN3Chr::BuildMesh(int nLOD)
{
	if(nLOD < 0 || nLOD >= MAX_CHR_LOD) return;
	if(m_MtxJoints.empty() || m_MtxInverses.empty()) return;
	__ASSERT(m_pRootJointRef, "Joint pointer is NULL!");

	float fWeight = 0;
	int nJIndex = 0, nAffect = 0;

	CN3IMesh* pIMesh = nullptr;

	__Matrix44* pMtxJs = &m_MtxJoints[0];
	__Matrix44* pMtxJIs = &m_MtxInverses[0];

	for (CN3CPart* pPart : m_Parts)
	{
		CN3Skin* pSkin = pPart->Skin(nLOD);
		if (pSkin == nullptr)
			continue;

		__VertexXyzNormal* pVDest = pSkin->Vertices();
		__VertexSkinned* pVSrc = pSkin->SkinVertices();
		if (pVDest == nullptr || pVSrc == nullptr)
			continue;

		int nVC = pSkin->VertexCount();
		__Vector3 vFinal;
		int nAffect = 0;
		float* pfWeights = nullptr;
		for (int j = 0; j < nVC; j++) // j < m_nBoneVertices 와 같다..
		{
			nAffect = pVSrc[j].nAffect;
			if (1 == nAffect)
			{
				// 단일 뼈대...
				nJIndex = pVSrc[j].pnJoints[0];
				pVDest[j] = (pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex];
			}
			else if (nAffect > 1)
			{
				vFinal.Zero();
				pfWeights = pVSrc[j].pfWeights;
				for (int k = 0; k < nAffect; k++)
				{
					nJIndex = pVSrc[j].pnJoints[k];
					vFinal += ((pVSrc[j].vOrigin * pMtxJIs[nJIndex]) * pMtxJs[nJIndex]) * pfWeights[k];
				}

				pVDest[j] = vFinal;
			}
		}
	}
}

void CN3Chr::Init()
{
	if(nullptr == m_pRootJointRef) return;

	// 관절이 몇개 있는지 계산하고.. 포인터 할당..

	int iJC = 0;
	__Matrix44 mtxTmp; mtxTmp.Identity();
	m_pRootJointRef->NodeCount(iJC);
	m_JointRefs.assign(iJC, nullptr);
	m_MtxJoints.assign(iJC, mtxTmp);
	m_MtxInverses.assign(iJC, mtxTmp);
	
	int nJI = 0;
	m_pRootJointRef->Tick(0); // 초기에 관절 위치 계산..
	for(int i = 0; i < iJC; i++) // 관절 갯수 만큼 각 관절의 참조 포인터와 역행렬을 얻어놓는다..
	{
		m_JointRefs[i] = nullptr;
		m_pRootJointRef->FindPointerByID(i, m_JointRefs[i]);
		m_MtxInverses[i] = m_JointRefs[i]->m_Matrix.Inverse(); // 로컬 축에 대한 역행렬을 구한다..
		m_MtxJoints[i] = m_JointRefs[i]->m_Matrix;
	}

	this->RemakePlugTracePolygons();
	
	// 충돌 체크를 위한 폴리곤.. 크기에 맞게 변환..
	if (m_pMeshCollision == nullptr)
		m_pMeshCollision = new CN3VMesh();

	RegenerateCollisionMesh();
}

void CN3Chr::RegenerateCollisionMesh()
{
	FindMinMax();

	if (m_pMeshCollision != nullptr)
		m_pMeshCollision->CreateCube(m_vMin, m_vMax);
}

void CN3Chr::JointSet(const std::string& szFN)
{
	bool bNeedInit = false;
	if(nullptr == m_pRootJointRef) bNeedInit = true;
	else if(m_pRootJointRef && m_pRootJointRef->FileName() != szFN) bNeedInit = true;// 파일 이름이 달라야 지우고 새로 한다..

	if(bNeedInit)
	{
		s_MngJoint.Delete(&m_pRootJointRef);
		m_pRootJointRef = s_MngJoint.Get(szFN);
		this->Init(); // 초기화...
	}
}

void CN3Chr::PartAlloc(int iCount)
{
	for (CN3CPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();

	if (iCount > 0)
	{
		m_Parts.assign(iCount, nullptr);
		for (int i = 0; i < iCount; i++)
			m_Parts[i] = new CN3CPart();
	}
}

void CN3Chr::PartDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Parts.size()))
		return;

	auto it = m_Parts.begin();
	std::advance(it, iIndex);

	delete *it;
	m_Parts.erase(it);
}

CN3CPart* CN3Chr::PartSet(int iIndex, const std::string& szFN)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Parts.size()))
		return nullptr;

	if (m_Parts[iIndex]->FileName() == szFN) return m_Parts[iIndex];

	if (szFN.empty()) m_Parts[iIndex]->Release();
	else m_Parts[iIndex]->LoadFromFile(szFN);
	
	return m_Parts[iIndex];
}

void CN3Chr::PlugDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Plugs.size()))
		return;

	auto it = m_Plugs.begin();
	std::advance(it, iIndex);

	delete *it;
	m_Plugs.erase(it);
}

CN3CPlug* CN3Chr::PlugSet(int iIndex, const std::string& szFN)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Plugs.size()))
		return nullptr;
		
	if (m_Plugs[iIndex]->FileName() == szFN)
		return m_Plugs[iIndex];

	if (szFN.empty())
		m_Plugs[iIndex]->Release();
	else
		m_Plugs[iIndex]->LoadFromFile(szFN);

	RemakePlugTracePolygons();

	return m_Plugs[iIndex];
}

void CN3Chr::PlugAlloc(int iCount)
{
	for (auto itr = m_Plugs.begin(); itr != m_Plugs.end(); ++itr)
		delete *itr;
	m_Plugs.clear();
		
	if(iCount > 0) 
	{
		m_Plugs.assign(iCount, nullptr);
		for(int i = 0; i < iCount; i++) m_Plugs[i] = new CN3CPlug();
	}
}

/*
void CN3Chr::CollisionSkinSet(const std::string& szFN)
{
	s_MngSkin.Delete(m_pSkinCollision);
	m_pSkinCollision = s_MngSkin.Get(szFN);
}
*/

void CN3Chr::AniCtrlSet(const std::string& szFN)
{
	s_MngAniCtrl.Delete(&m_pAniCtrlRef);
	m_pAniCtrlRef = s_MngAniCtrl.Get(szFN);
	
	m_FrmCtrl.iAni = -1;
	m_FrmCtrl.bOnceAndFreeze = false;	// 한번만 하고 멈춰야 되는가??
	m_FrmCtrl.fFrmCur = 0;
	m_FrmCtrl.fFrmPrev = 0;				// 최근 프레임
	m_FrmCtrl.iAniLoop = 0;
	m_FrmCtrl.pAniData = nullptr;
}

int	CN3Chr::AniCurSet(	int iAni,					// Animation 번호,
						bool bOnceAndFreeze,		// 한번만 돌고 멈추어야 하는가??
						float fBlendTime,			// 블렌딩하는 시간(초단위), 
						float fFreezeTime,			// 멈출시간...
						bool bStopUpperAnimation)	// 상체 에니메이션이 있으면.. 멈추도록
{
	if(nullptr == m_pAniCtrlRef) return -1;
	if(iAni == m_FrmCtrl.iAni) return -1; // 같은 에니메이션이면 돌아간다.
//	if(iAni == m_FrmCtrl.iAni) { m_FrmCtrl.iAniLoop = 0; return -1; } // 같은 에니메이션이면 루핑 참조 카운트만 초기화하고 돌아간다.
	if(iAni < 0 || iAni >= m_pAniCtrlRef->Count()) return -1;

	int iAniPrev = m_FrmCtrl.iAni; // 전의 걸 기억하고..
	float fFrmPrev = m_FrmCtrl.fFrmCur; // 최근의 프레임..

	if(bStopUpperAnimation)
		m_FrmCtrlUpper.Init(); // 상체 에니메이션 강제 종료 !!
	m_FrmCtrl.Init();

	m_FrmCtrl.iAni = iAni;
	m_FrmCtrl.bOnceAndFreeze = bOnceAndFreeze; // 한번만 하고 멈추어야 하는가....
	m_FrmCtrl.fFreezeTime = fFreezeTime;
	m_FrmCtrl.pAniData = m_pAniCtrlRef->DataGet(iAni);

	m_FrmCtrl.fFrmCur = m_FrmCtrl.pAniData->fFrmStart; // 프레임을 처음으로 세팅..
	m_FrmCtrl.fFrmPrev = m_FrmCtrl.pAniData->fFrmEnd;
	if(FLT_MIN != fBlendTime) m_FrmCtrl.fBlendTime = fBlendTime; // 모션 Blending 값 설정..
	else m_FrmCtrl.fBlendTime = m_FrmCtrl.pAniData->fTimeBlend;
	if(m_FrmCtrl.fBlendTime > 0) m_FrmCtrl.fBlendFrm = fFrmPrev; // Blending 할 에니메이션 Frame..
	else m_FrmCtrl.fBlendFrm = m_FrmCtrl.fFrmCur; // Blending 할 에니메이션 은 없다!!

	return iAniPrev;
}

void CN3Chr::AniFixToLastFrame( int iAni ) // 마지막 프레임으로 고정 시켜 버린다.
{
	if(nullptr == m_pAniCtrlRef) return;
	if(iAni == m_FrmCtrl.iAni) return; // 같은 에니메이션이면 돌아간다.
	if(iAni < 0 || iAni >= m_pAniCtrlRef->Count()) return;

	__AnimData* pAniData = m_pAniCtrlRef->DataGet(iAni);
	if(nullptr == pAniData) return;

	m_FrmCtrl.Init();
	m_FrmCtrl.iAni = iAni;
	m_FrmCtrl.bOnceAndFreeze = true; // 한번만 하고 멈추어야 하는가....
	m_FrmCtrl.pAniData = m_pAniCtrlRef->DataGet(iAni);
	m_FrmCtrl.fBlendTime = 0; // 모션 Blending 값 설정..
	m_FrmCtrl.fBlendFrm = pAniData->fFrmEnd; // Blending 할 에니메이션 Frame..
	m_FrmCtrl.fFreezeTime = 1000.0f; // 멈출 시간..
	m_FrmCtrl.fFrmCur = pAniData->fFrmEnd; // 프레임을 처음으로 세팅..
	m_FrmCtrl.fFrmPrev = pAniData->fFrmEnd;

	return;
}

void CN3Chr::AniUpperSet(int iAni, float fFreezeTime)
{
	if(nullptr == m_pAniCtrlRef) return;
	if(iAni < 0 || iAni >= m_pAniCtrlRef->Count()) return;
	if(iAni == m_FrmCtrlUpper.iAni) return; // 전의 것과 같으면 넘어간다..

	m_FrmCtrlUpper.Init();

	m_FrmCtrlUpper.iAni = iAni;
	m_FrmCtrlUpper.bOnceAndFreeze = false;
	m_FrmCtrlUpper.pAniData = m_pAniCtrlRef->DataGet(iAni);

	// 모션 Blending 값 설정..
	m_FrmCtrlUpper.fBlendTime = m_FrmCtrlUpper.pAniData->fTimeBlend;
	m_FrmCtrlUpper.fBlendTimeCur = 0;
	m_FrmCtrlUpper.fBlendFrm = m_FrmCtrl.fFrmCur; // 하체 프레임과 Blending 할 에니메이션 Frame..
	m_FrmCtrlUpper.fFreezeTime = fFreezeTime; // 멈출 시간..

	m_FrmCtrlUpper.fFrmCur = m_FrmCtrlUpper.pAniData->fFrmStart; // 프레임을 처음으로 세팅..
	m_FrmCtrlUpper.fFrmPrev = m_FrmCtrlUpper.pAniData->fFrmEnd;
}

#ifdef _N3TOOL
void CN3Chr::AniDefaultSet()
{
	s_MngAniCtrl.Delete(&m_pAniCtrlRef);
	s_MngAniCtrl.Release();

	// 기본적인 Animation Control 만들기..
	CN3AnimControl* pAniCtrlDefault = new CN3AnimControl();
	pAniCtrlDefault->m_szName = "Default";
	pAniCtrlDefault->FileNameSet("Chr\\Default.N3Anim");
	s_MngAniCtrl.Add(pAniCtrlDefault);
	
	m_pAniCtrlRef = pAniCtrlDefault;
}
#endif // #ifdef _N3_TOOL


void CN3Chr::JointPartSet(int nAniPart, int nJS, int nJE)
{
	if (nAniPart < 0 || nAniPart >= MAX_CHR_ANI_PART)
		return;

	if (m_JointRefs.empty())
		return;

	int iJC = static_cast<int>(m_JointRefs.size());
	if (nJE - nJS < 0 || nJS >= iJC || nJE >= iJC)
		return;

	m_nJointPartStarts[nAniPart] = nJS;
	m_nJointPartEnds[nAniPart] = nJE;
}

void CN3Chr::FindMinMax()
{
	m_vMin.Zero();
	m_vMax.Zero();
	m_fRadius = 0;

	if (m_JointRefs.empty())
		return;

	TickAnimationKey(m_FrmCtrl.fFrmCur);
	TickJoints();

	__Vector3 vTmp;
	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);

	// 관절 갯수 만큼 각 관절의 참조 포인터와 역행렬을 얻어놓는다..
	for (CN3Joint* pJoint : m_JointRefs)
	{
		// 각 조인트의 관절 위치 값에 대해 최대 최소값을 찾는다.
		vTmp = pJoint->m_Matrix.Pos();
		if (vTmp.x < m_vMin.x) m_vMin.x = vTmp.x;
		if (vTmp.y < m_vMin.y) m_vMin.y = vTmp.y;
		if (vTmp.z < m_vMin.z) m_vMin.z = vTmp.z;
		if (vTmp.x > m_vMax.x) m_vMax.x = vTmp.x;
		if (vTmp.y > m_vMax.y) m_vMax.y = vTmp.y;
		if (vTmp.z > m_vMax.z) m_vMax.z = vTmp.z;
	}

	// 너무 작으면 늘려준다..
	if(m_vMax.x - m_vMin.x < 0.5f) { m_vMax.x += 0.25f; m_vMin.x -= 0.25f; }
	if(m_vMax.y - m_vMin.y < 0.5f) { m_vMax.y += 0.25f; m_vMin.y -= 0.25f; }
	if(m_vMax.z - m_vMin.z < 0.5f) { m_vMax.z += 0.25f; m_vMin.z -= 0.25f; }

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

int CN3Chr::CheckCollisionPrecisely(int ixScreen, int iyScreen, __Vector3* pvPick)
{
	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	__Matrix44 mtxWI, mtxWIRot;
	mtxWI = m_Matrix.Inverse(); // World Matrix Inverse
	mtxWIRot = mtxWI;
	mtxWIRot.PosSet(0,0,0);
	__Vector3 vPos2 = vPos * mtxWI;
	__Vector3 vDir2 = vDir * mtxWIRot;

	CN3VMesh* pvMesh = nullptr;
	__Matrix44 Mtx = m_Matrix;
	pvMesh = CollisionMesh();

	if(nullptr == pvMesh) 
		return -1;

	if(!pvMesh->Pick(Mtx, vPos, vDir, pvPick))
		return -1;

	// 멀리 있는 캐릭터는 박스로만 체크하고 가까이 있는건 디테일하게 충돌체크를 한다...
	if(m_nLOD >= 3)
		return 1;

	return this->CheckCollisionPrecisely(vPos2, vDir2, pvPick);

}

int CN3Chr::CheckCollisionPrecisely(const __Vector3 &vPos, const __Vector3 &vDir, __Vector3* pvPick)
{
	TickJoints(); // 조인트 행렬들 계산...
	BuildMesh(m_nLOD);

	__Vector3 vPos2 = vPos, vDir2 = vDir;
	int iPC = static_cast<int>(m_Parts.size());
	for (int i = 0; i < iPC; i++)
	{
		CN3Skin* pSkin = m_Parts[i]->Skin(m_nLOD);
		if (pSkin == nullptr)
			continue;

		if (pSkin->CheckCollisionPrecisely(vPos2, vDir2, pvPick))
		{
			if (pvPick) (*pvPick) *= m_Matrix;
			return i;
		}
	}

	return -1;
}

//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-10 오후 2:36:28 )
//	FXPlug

// FXPlugSet : FXPlug 파일을 지정해주는 함수
CN3FXPlug* CN3Chr::FXPlugSet(const std::string& strFN)
{
	if (m_pFXPlug) m_pFXPlug->Release();
	else m_pFXPlug = new CN3FXPlug();
	if (false == m_pFXPlug->LoadFromFile(strFN)) return nullptr;
	return m_pFXPlug;
}

CN3FXPlug*	CN3Chr::FXPlugCreate()
{
	if (m_pFXPlug) m_pFXPlug->Release();
	else
	{
		m_pFXPlug = new CN3FXPlug();
		
		if (m_szName.size()>0)
		{
			std::string szFN = fmt::format("Chr\\{}.N3FXPlug", m_szName);	// 캐릭터의 이름을 붙인다.
			m_pFXPlug->FileNameSet(szFN);
		}
		else m_pFXPlug->FileNameSet("Chr\\Default.N3FXPlug");	// 그냥 default이름을 붙인다.
	}
	return m_pFXPlug;
}

void	CN3Chr::FXPlugDelete()
{
	if (m_pFXPlug) delete m_pFXPlug;
	m_pFXPlug = nullptr;
}
//	End Of Code (By Dino On 2002-10-10 오후 2:36:28 )
//////////////////////////////////////////////////

// ===== END N3Base/N3Chr.cpp =====

// ===== BEGIN N3Base/N3Chr.h =====
#line 1 "N3Base/N3Chr.h"
﻿// N3Chr.h: interface for the CN3Chr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Chr_h__INCLUDED_)
#define AFX_N3Chr_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

#include "N3TransformCollision.h"
#include "N3AnimControl.h"
#include "N3Skin.h"
#include "N3Cloak.h"
#include "N3PMeshInstance.h"
#include "N3Texture.h"
#include "N3Joint.h"
#include <list>
#include <vector>

const int MAX_CHR_JOINT = 256;
const int MAX_CHR_LOD = 4; // 4 단계 Level Of Detail
const int MAX_CHR_LOD_DELTA = 4;

class CN3CPartSkins : public CN3BaseFileAccess
{
	friend class CN3Chr;
	friend class CN3CPart;
protected:
	CN3Skin			m_Skins[MAX_CHR_LOD];

public:
	bool			Load(File& file) override;
#ifdef _N3TOOL
	bool			Save(File& file) override;
#endif // end of _N3TOOL

	void Release() override;
	CN3CPartSkins();
	~CN3CPartSkins() override;
};

class CN3CPart : public CN3BaseFileAccess
{
	friend class CN3Chr;
public:
	__Material			m_Mtl;
	__Material			m_MtlOrg;
	uint32_t				m_dwReserved;


	bool				m_bVisible;
protected:
	CN3Texture*			m_pTexRef;
	CN3Texture*			m_pTexOverlapRef; // 위에 덧칠할 텍스처
//	std::vector<class CN3AnimatedTexture*> m_AnimatedTextures;
	CN3CPartSkins*		m_pSkinsRef;
public:
	bool			Load(File& file) override;
	void			Render(int nLOD);

	CN3Texture*		Tex() { return m_pTexRef; }
	CN3Texture*		TexSet(const std::string& szFN) { s_MngTex.Delete(&m_pTexRef); m_pTexRef = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Chr); return m_pTexRef; }
	void			TexSet(CN3Texture* pTex) { s_MngTex.Delete(&m_pTexRef); m_pTexRef = pTex; }
	
	CN3Texture*		TexOverlap() { return m_pTexOverlapRef; }  // 위에 덧칠할 텍스처
	CN3Texture*		TexOverlapSet(const std::string& szFN);
	void			TexOverlapSet(CN3Texture* pTex);
	
	CN3Skin*		Skin(int nLOD)
	{
		if(m_pSkinsRef && nLOD >= 0 && nLOD < MAX_CHR_LOD)
			return &(m_pSkinsRef->m_Skins[nLOD]);
		else
			return nullptr;
	}
	CN3CPartSkins*	Skins() { return m_pSkinsRef; }
	CN3CPartSkins*	SkinsSet(const std::string& szFN);

#ifdef _N3TOOL
	void			RenderSelected(int nLOD);
	bool			Save(File& file) override;
#endif // end of _N3TOOL

	void Release() override;
	
	CN3CPart();
	~CN3CPart() override;
};

enum e_PlugType{PLUGTYPE_NORMAL=0, PLUGTYPE_CLOAK, PLUGTYPE_MAX=10, PLUGTYPE_UNDEFINED=0xffffffff};
class CN3CPlugBase : public CN3BaseFileAccess
{
	friend class CN3Chr;
public:
	e_PlugType			m_ePlugType;
	bool				m_bVisible;
	int					m_nJointIndex; // 붙는 Mesh 의 Joint Index.. 어느 조인트에 붙느냐.. 그것이 문제로다...
	__Vector3			m_vPosition; // 붙는 Mesh 의 Offset Vector.
	__Vector3			m_vScale; // 붙는 Mesh 의 스케일.
	__Material			m_Mtl;
	__Matrix44			m_Matrix;	

protected:
	CN3PMeshInstance	m_PMeshInst; // Progressive Mesh Instance
	CN3Texture*			m_pTexRef; // Texture Reference Pointer
	CN3Texture*			m_pTexOverlapRef; // 위에 덧칠할 Texture Reference Pointer
//		__Vector3 m_vRotation; // 붙는 Mesh 의 Rotation일.
	__Matrix44			m_MtxRot; // Rotation Matrix;

public:
	CN3CPlugBase();
	~CN3CPlugBase() override;
	static e_PlugType	GetPlugTypeByFileName(const std::string& szFN);

	bool	Load(File& file) override;
#ifdef _N3TOOL
	bool	Save(File& file) override;
#endif // end of _N3TOOL

	virtual void Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint);
	void Release() override;

	void ReCalcMatrix();

	__Vector3& Position() { return m_vPosition; }
	__Matrix44& Rotation() { return m_MtxRot; }
	__Vector3& Scale() { return m_vScale; }

	void PositionSet(const __Vector3& vPos) { m_vPosition = vPos; this->ReCalcMatrix(); }
	void RotationSet(const __Matrix44& mtx) { m_MtxRot = mtx; this->ReCalcMatrix(); }
	void ScaleSet(const __Vector3& vScale2) { m_vScale = vScale2; this->ReCalcMatrix(); }
	
	CN3Texture* Tex() { return m_pTexRef; }
	CN3Texture* TexSet(const std::string& szFN) { s_MngTex.Delete(&m_pTexRef); m_pTexRef = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Chr); return m_pTexRef; }
	void		TexSet(CN3Texture* pTex) { s_MngTex.Delete(&m_pTexRef); m_pTexRef = pTex; }

	CN3Texture* TexOverlap() { return m_pTexOverlapRef; }  // 위에 덧칠할 텍스처
	CN3Texture* TexOverlapSet(const std::string& szFN);
	void		TexOverlapSet(CN3Texture* pTex);
	
	CN3PMesh* PMesh() { return m_PMeshInst.GetMesh(); }
	CN3PMeshInstance* PMeshInst() { return &m_PMeshInst; }
	void PMeshSet(const std::string& szFN);
};

const int MAX_PLUG_FX_POSITION = 5;
const int MAX_FXTAIL = 3;
enum e_PlugAttr{PLUGATTR_FIRE=0, PLUGATTR_ICE, PLUGATTR_LIGHTENNING, PLUGATTR_POISON, PLUGATTR_TOTAL};
class CN3CPlug: public CN3CPlugBase
{
public:
	bool			m_bRenderTrace;
	int 			m_nTraceStep; // 궤적의 길이..
	D3DCOLOR		m_crTrace; // 궤적 색깔.. 검은색이면 없다..
	float			m_fTrace0; // 궤적 위치..
	float			m_fTrace1; // 궤적 위치..

	//fx.......
	CN3PMeshInstance			m_PMeshInstFX; // FX 에 쓸 PMesh Instance
	class CN3FXBundle*			m_pFXMainBundle;
	class CN3FXBundle*			m_pFXTailBundle[MAX_FXTAIL];
	class CN3FXPartBillBoard*	m_pFXPart;
	std::string					m_strFXMainName;
	std::string					m_strFXTailName;
	
public:
	bool Load(File& file) override;
#ifdef _N3TOOL
	bool Save(File& file) override;
	void ImportPMesh(const std::string& szFileName);
	void RenderFXLines(const __Matrix44& mtxParent, const __Matrix44& mtxJoint); // FX 들어갈 곳에 선을 그려준다.
#endif // end of _N3TOOL
	void Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint) override;
	void Release() override;

	void RenderFX(const __Matrix44& mtxParent, const __Matrix44& mtxJoint);
	void InitFX(std::string& szFXMain, std::string& szFXTail, D3DCOLOR TraceCR = 0xffffffff);

public:
	CN3CPlug();
	~CN3CPlug() override;
};

class CN3CPlug_Cloak : public CN3CPlugBase
{
public:
	CN3CPlug_Cloak();
	~CN3CPlug_Cloak() override;

public:
	bool Load(File& file) override;
#ifdef _N3TOOL
	bool Save(File& file) override;
#endif // end of _N3TOOL
	void Render(const __Matrix44& mtxParent, const __Matrix44& mtxJoint) override;
	void Release() override;

	void SetLOD(int nLOD);
#ifdef _N3GAME
	CN3Cloak*	GetCloak(){return &m_Cloak;}
#endif
protected:
#ifdef _N3GAME
	CN3Cloak		m_Cloak;
#endif
};

const int MAX_CHR_ANI_PART = 2; // 0 - 상체, 1 - 하체 ::: 관절들을 나누어서 나누어서 에니메이션 설정..
const int MAX_PLUG_TRACE = 2; // 최대 두개의 무기 궤적을 남긴다..
const int MAX_PLUG_TRACE_VERTEX = 64; // 무기 궤적 점의 수.. 점 8 개로는 잔상이 3단계로 남는다..

typedef std::vector<CN3CPart*>::iterator	it_CPart;
typedef std::vector<CN3CPlug*>::iterator	it_CPlug;

class CN3Chr : public CN3TransformCollision
{
	friend class CPlayerBase;
	friend class CPlayerMySelf;

public:
	int							m_nLOD; // Level Of Detail - 강제로 세팅할수 있도록 한다..
	int							m_nLOD_0; // Level Of Detail - 0가장 디테일한 값으로 계산된 LOD 강제로 세팅할수 있도록 한다..

protected:
	static int s_iLODDelta; // LOD 계산에 필요한 인덱스..

	CN3Joint*					m_pRootJointRef; // 한개의 뼈대만을 쓴다..
	
	std::vector<CN3Joint*>		m_JointRefs; // 각 조인트에 참조 포인터
	std::vector<__Matrix44>		m_MtxJoints; // 각 조인트의 행렬.. 포인터로 두지 않은 이유는 각 캐릭터마다 따로 에니메이션이 되기 위함이다..
	std::vector<__Matrix44>		m_MtxInverses; // 조인트에 대한 역행렬

	std::vector<CN3CPart*>		m_Parts; // 각 캐릭터의 부분별 Data Pointer List
	std::vector<CN3CPlug*>		m_Plugs; // 이 캐릭터에 붙이는 무기등의 Data Pointer List
	std::vector<__VertexColor*>	m_vTraces; // Plug Trace Polygon
	class CN3FXPlug*			m_pFXPlug;	// 캐릭터에 FX를 붙이는 것.

	int							m_nJointPartStarts[MAX_CHR_ANI_PART]; // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 시작 번호
	int							m_nJointPartEnds[MAX_CHR_ANI_PART]; // 조인트의 일부분이 따로 에니메이션 되야 한다면.. 조인트 인덱스 끝 번호
	
//	CN3Skin*	m_pSkinCollision;
	
	CN3AnimControl*				m_pAniCtrlRef; // Animation Control Reference Pointer

	struct __FrmCtrl
	{
		__AnimData*		pAniData;	// 현재 에니메이션 데이터 포인터..

		int		iAni;					// 현재 에니메이션
		bool	bOnceAndFreeze;			// 한번만 하고 멈춰야 하는가??
		bool	bProcessingDelayNow;	// 지금 지연시간을 처리하는가??
		float	fFrmCur;				// 현재 프레임
		float	fFrmPrev;				// 최근 프레임
		int		iAniLoop;				// 에니메이션이 끝났나??
		float	fBlendFrm;				// 현재 에니메이션의 시작프레임과 블렌딩할 프레임
		float	fBlendTimeCur;			// 현재 블렌딩 시간..
		float	fBlendTime;				// 블렌딩할 시간. (초단위)
		float	fFreezeTime;			// 멈출 시간..

		void Init()
		{
			pAniData = nullptr;
			iAni = -1;						// 현재 에니메이션
			bOnceAndFreeze = false;			// 돌아갈 에니메이션..
			bProcessingDelayNow = false;	// 지금 지연시간을 처리하는가??

			fFrmCur = 0;
			fFrmPrev = 0;					// 최근 프레임
			iAniLoop = 0;					// 에니메이션이 끝났는가?
			fBlendFrm = 0;					// 블렌딩할 에니메이션 데이터 포인터..
			fBlendTimeCur = 0;				// 현재 블렌딩 시간..
			fBlendTime = 0;					// 블렌딩할 시간. (초단위)
		}
		__FrmCtrl()
		{
			__FrmCtrl::Init();
		}
	};
	__FrmCtrl		m_FrmCtrl;
	__FrmCtrl		m_FrmCtrlUpper;	// 상체용...
	float			m_fAniSpeedDelta; // 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..

public:
	int				CheckCollisionPrecisely(const __Vector3& vPos, const __Vector3& vDir, __Vector3* pvPick = nullptr);
	int				CheckCollisionPrecisely(int ixScreen, int iyScreen, __Vector3* pvPick = nullptr);
	static void		LODDeltaSet(int iLODDelta) { if(s_iLODDelta >= 0 && iLODDelta <= 3) s_iLODDelta = iLODDelta; }
	static int 		LODDelta() { return s_iLODDelta; }

	void			FindMinMax(); // 최대 최소값을 찾는다.
	int				JointPartStart(int nAniPart) { if(nAniPart < 0 || nAniPart >= MAX_CHR_ANI_PART) return -1; return m_nJointPartStarts[nAniPart]; }
	int				JointPartEnd(int nAniPart) { if(nAniPart < 0 || nAniPart >= MAX_CHR_ANI_PART) return -1; return m_nJointPartEnds[nAniPart]; }
	void			JointPartSet(int nAniPart, int nJS, int nJE);

	const __Matrix44* MatrixGet(int nJointIndex) const
	{
		if (nJointIndex < 0
			|| nJointIndex >= static_cast<int>(m_MtxJoints.size()))
			return nullptr;

		return &m_MtxJoints[nJointIndex];
	}

//	void		CollisionSkinSet(const std::string& szFN);
//	CN3Skin*	CollisionSkin() { return m_pSkinCollision; }

	int PartCount() const
	{
		return static_cast<int>(m_Parts.size());
	}

	void		PartDelete(int iIndex);
	void		PartAlloc(int nCount);
	CN3CPart*	PartSet(int iIndex, const std::string& szFN);
	CN3CPart*  	PartAdd() { CN3CPart* pPart = new CN3CPart(); m_Parts.push_back(pPart); return pPart; }

	CN3CPart*	Part(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Parts.size()))
			return nullptr;

		return m_Parts[iIndex];
	}

	int PlugCount() const
	{
		return static_cast<int>(m_Plugs.size());
	}

	void		PlugDelete(int iIndex);
	void		PlugAlloc(int nCount);
	CN3CPlug*	PlugSet(int iIndex, const std::string& szFN);
	CN3CPlug*	PlugAdd(e_PlugType eType=PLUGTYPE_NORMAL) { CN3CPlug* pPlug = new CN3CPlug(); m_Plugs.push_back(pPlug); return pPlug; }
	CN3CPlug*	Plug(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Plugs.size()))
			return nullptr;

		return m_Plugs[iIndex];
	}

	void		Tick(float fFrm = FRAME_SELFPLAY);
	void		TickAnimationFrame();
	void		TickJoints();
	void		TickPlugs(float fLOD);
	void		RemakePlugTracePolygons();

	float		Height() { return m_vMax.y * m_vScale.y; } // 스케일을 적용한 키 ...
	float		Radius() { return m_fRadius * m_vScale.y; } // 스케일을 적용한 너비...

	CN3Joint*	Joint() { return m_pRootJointRef; }
	void		JointSet(const std::string& szFN);

	// Animation 관련 함수
#ifdef _N3TOOL
	void		AniDefaultSet();
#endif // #ifdef _N3TOOL
	CN3AnimControl* AniCtrl() { return m_pAniCtrlRef; }
	void		AniCtrlSet(const std::string& szFN);
	int			AniIndexCur() { return m_FrmCtrl.iAni; }
	int			AniCurSet(	int iAni,							// Animation 번호,
							bool bOnceAndFreeze = false,		// 한번만 돌고 멈추어야 하는가??
							float fBlendTime = FLT_MIN,			// 블렌딩하는 시간(초단위), 
							float fFreezeTime = 0, 				// 멈출시간...
							bool bStopUpperAnimation = true);	// 상체 에니메이션이 있으면.. 멈추도록
	void		AniUpperSet(int nAni, float fFreezeTime = 0);
	void		AniFixToLastFrame( int iAni ); // 마지막 프레임으로 고정 시켜 버린다.

	bool		IsAnimEnd(); // 한번 하고 멈추는 에니메이션 일경우 .. 끝났는지?? 혹은 한번하고 전의 동작으로 돌아가는 에니메이션일 경우 돌아갔는지?

	float		FrmCur() { return m_FrmCtrl.fFrmCur; }
	float		FrmPrev() { return m_FrmCtrl.fFrmPrev; }
	float		AniBlendDelta();
	float		AniSpeedDelta() { return m_fAniSpeedDelta; } // 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..
	void		AniSpeedDeltaSet(float fDelta) { if(fDelta > 0.1f && fDelta < 10.0f) m_fAniSpeedDelta = fDelta; } // 에니메이션 속도 조정 변수 1 이보통, 더 크면 빨라진다..

	// Sound Player 관련 함수
	bool		NeedPlaySound0();
	bool		NeedPlaySound1();

	// 가짜 타격을 위한 함수..
	bool		NeedStrike0();
	bool		NeedStrike1();

	// 루핑이 다시 시작되는 타이밍인가?
	bool		IsLoopingAgain();
	
//////////////////////////////////////////////////
//	Coded (By Dino On 2002-10-10 오후 2:35:32 )
//	FXPlug
	class CN3FXPlug*	FXPlugSet(const std::string& strFN);
	class CN3FXPlug*	FXPlugCreate();
	class CN3FXPlug*	FXPlugGet() {return m_pFXPlug;}
	void				FXPlugDelete();
//	End Of Code (By Dino On 2002-10-10 오후 2:35:32 )
//////////////////////////////////////////////////

	void		Init();
	void		RegenerateCollisionMesh();
	void		BuildMesh();
	void		BuildMesh(int nLOD);
	void		Render();

	__AnimData* AniDataCur();
#ifdef _N3TOOL	
	__AnimData* AniDataUpper();
	bool		Save(File& file) override;
#endif // end of _N3TOOL
	bool		Load(File& file) override;

	void		Release() override;
	
	CN3Chr();
	~CN3Chr() override;
};

inline bool CN3Chr::IsAnimEnd() // 한번 하고 멈추는 에니메이션 일경우 .. 끝났는지?? 혹은 한번하고 전의 동작으로 돌아가는 에니메이션일 경우 돌아갔는지?
{
	if(m_FrmCtrlUpper.pAniData)
	{
		if(m_FrmCtrlUpper.iAniLoop > 0)	return true;
		return false;
	}
	else
	{
		if(m_FrmCtrl.iAniLoop > 0) return true;
		return false;
	}
}

inline float CN3Chr::AniBlendDelta()
{
	if(m_FrmCtrl.fBlendTime == 0) return 0.0f;
	return m_FrmCtrl.fBlendTimeCur / m_FrmCtrl.fBlendTime;
}

// Sound Player 관련 함수
inline bool	CN3Chr::NeedPlaySound0()
{
	if(nullptr == m_FrmCtrl.pAniData) return false;
	
	if(	m_FrmCtrlUpper.pAniData)
	{
		if(m_FrmCtrlUpper.pAniData->fFrmSound0 <= 0) return false;
		if(	m_FrmCtrlUpper.fFrmPrev < m_FrmCtrlUpper.pAniData->fFrmSound0 &&
			m_FrmCtrlUpper.fFrmCur >= m_FrmCtrlUpper.pAniData->fFrmSound0 ) return true;
		return false;
	}

	if(m_FrmCtrl.pAniData->fFrmSound0 <= 0) return false;
	if(	m_FrmCtrl.fFrmPrev < m_FrmCtrl.pAniData->fFrmSound0 &&
		m_FrmCtrl.fFrmCur >= m_FrmCtrl.pAniData->fFrmSound0 ) return true;

	return false;
}

inline bool CN3Chr::IsLoopingAgain()	// 루핑이 다시 시작되는 타이밍인가?
{
	if(nullptr == m_FrmCtrl.pAniData) return false;

	if(	m_FrmCtrlUpper.pAniData)
	{
		if (m_FrmCtrlUpper.iAniLoop <= 0) return false;
		if(	m_FrmCtrlUpper.fFrmPrev > m_FrmCtrlUpper.fFrmCur) return true;
	}

	if(m_FrmCtrl.iAniLoop <= 0) return false;	// 루핑이 아니다.
	if(	m_FrmCtrl.fFrmPrev > m_FrmCtrl.fFrmCur) return true;

	return false;
}

inline bool CN3Chr::NeedPlaySound1()
{
	if(nullptr == m_FrmCtrl.pAniData) return false;

	if(	m_FrmCtrlUpper.pAniData)
	{
		if(m_FrmCtrlUpper.pAniData->fFrmSound1 <= 0) return false;
		if(	m_FrmCtrlUpper.fFrmPrev < m_FrmCtrlUpper.pAniData->fFrmSound1 &&
			m_FrmCtrlUpper.fFrmCur >= m_FrmCtrlUpper.pAniData->fFrmSound1 ) return true;
		return false;
	}

	if(m_FrmCtrl.pAniData->fFrmSound1 <= 0) return false;
	if(	m_FrmCtrl.fFrmPrev < m_FrmCtrl.pAniData->fFrmSound1 &&
		m_FrmCtrl.fFrmCur >= m_FrmCtrl.pAniData->fFrmSound1 ) return true;

	return false;
}

inline bool	CN3Chr::NeedStrike0()
{
	if(nullptr == m_FrmCtrl.pAniData) return false;

	if(	m_FrmCtrlUpper.pAniData)
	{
		if(m_FrmCtrlUpper.pAniData->fFrmStrike0 <= 0) return false;
		if(	m_FrmCtrlUpper.fFrmPrev < m_FrmCtrlUpper.pAniData->fFrmStrike0 &&
			m_FrmCtrlUpper.fFrmCur >= m_FrmCtrlUpper.pAniData->fFrmStrike0 ) return true;
		return false;
	}

	if(m_FrmCtrl.pAniData->fFrmStrike0 <= 0) return false;
	if(	m_FrmCtrl.fFrmPrev < m_FrmCtrl.pAniData->fFrmStrike0 &&
		m_FrmCtrl.fFrmCur >= m_FrmCtrl.pAniData->fFrmStrike0 ) return true;

	return false;
}

inline bool	CN3Chr::NeedStrike1()
{
	if(nullptr == m_FrmCtrl.pAniData) return false;

	if(	m_FrmCtrlUpper.pAniData)
	{
		if(m_FrmCtrlUpper.pAniData->fFrmStrike1 <= 0) return false;
		if(	m_FrmCtrlUpper.fFrmPrev < m_FrmCtrlUpper.pAniData->fFrmStrike1 &&
			m_FrmCtrlUpper.fFrmCur >= m_FrmCtrlUpper.pAniData->fFrmStrike1 ) return true;
		return false;
	}

	if(m_FrmCtrl.pAniData->fFrmStrike1 <= 0) return false;
	if(	m_FrmCtrl.fFrmPrev < m_FrmCtrl.pAniData->fFrmStrike1 &&
		m_FrmCtrl.fFrmCur >= m_FrmCtrl.pAniData->fFrmStrike1 ) return true;

	return false;
}

#endif // !defined(AFX_N3Chr_h__INCLUDED_)

// ===== END N3Base/N3Chr.h =====

// ===== BEGIN N3Base/N3Cloak.cpp =====
#line 1 "N3Base/N3Cloak.cpp"
﻿// N3Cloak.cpp: implementation of the CN3Cloak class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Cloak.h"
#include "N3Texture.h"
#include "N3PMeshInstance.h"
#include "N3Chr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CN3Cloak::CN3Cloak()
{
//	m_pPMesh = nullptr;
	m_pTex = nullptr;
	m_pParticle = nullptr;
	m_nLOD = -1;
	m_pPMesh = nullptr;
	m_pIndex = nullptr;
	m_pVertex = nullptr;
	m_fOffsetRecoveryTime = 0.0f;
	m_fPrevYaw = 0.0f;
	m_eAnchorPattern = AMP_NONE;
	m_fAnchorPreserveTime = 0.0f;
}

CN3Cloak::~CN3Cloak()
{
	delete[] m_pParticle;
	delete[] m_pIndex;
	delete[] m_pVertex;
}

void CN3Cloak::Release()
{
	delete[] m_pParticle;
	m_pParticle = nullptr;

	delete[] m_pIndex;
	m_pIndex = nullptr;

	delete[] m_pVertex;
	m_pVertex = nullptr;
}

void CN3Cloak::Init(CN3CPlug_Cloak *pPlugCloak)
{
	m_pTex = pPlugCloak->Tex();
	m_pPMesh = pPlugCloak->PMesh();
	__ASSERT(m_pPMesh && m_pTex, "IN CN3Cloak, PMesh or m_pTex is null");

	SetLOD(0);

	//
	m_GravityForce.x = 0.0f;
	m_GravityForce.z = 0.0005f;
	//m_GravityForce.y = -0.0025f;
	m_GravityForce.y = -0.0005f;

	m_Force.x = m_Force.y = m_Force.z = 0.0f;
}

void CN3Cloak::Tick(int nLOD, float fYaw, e_CloakMove eCloakMove)
{
	//SetLOD(nLOD);	

	//
//	static float fForceDelay = 0.0f;
//	static float fForceDelayLimit = 4.0f;
//	fForceDelay += s_fSecPerFrm;
//	if (fForceDelay > fForceDelayLimit)
//	{
		//float x = (rand()%30)*0.0001f;
		//float z = (rand()%60)*0.0001f;
		//SetForce(dif.x, dif.y, dif.z);
//		m_Force.x = dif.x;
//		m_Force.y = dif.y;
//		m_Force.z = dif.z;
//		fForceDelay = 0.0f;
//		fForceDelayLimit = 2.0f + rand()%10;
//	}
	m_fAnchorPreserveTime -= s_fSecPerFrm;
	if (m_eAnchorPattern != AMP_NONE)
	{
		if (m_fAnchorPreserveTime < 0.0f)		
		{
			RestoreAnchorLine();
		}
	}

	TickByPlayerMotion(eCloakMove);
	TickYaw(fYaw);
	

	UpdateLocalForce();
	ApplyForce();

	m_Force.x = m_Force.y = m_Force.z = 0.0f;
}

void CN3Cloak::Render(__Matrix44 &mtx)
{
	if (m_nLOD < 0)	return;

	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());
	DWORD dwCull, dwLight;
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
	
	// 
	//s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE);
	if (dwCull != D3DCULL_NONE)
		s_lpD3DDev->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

	s_lpD3DDev->SetTexture(0, m_pTex->Get());
	s_lpD3DDev->SetTexture(1, nullptr);
	
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
//	s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
//	s_lpD3DDev->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
//	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);


	s_lpD3DDev->SetFVF(FVF_VNT1);
	s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_nVertexCount, m_nIndexCount/3, m_pIndex, D3DFMT_INDEX16 ,m_pVertex, sizeof(__VertexT1));

	//
	__VertexXyzColor	Vtx[2];
/*
	__VertexT1 *pTemp = m_pVertex;
	Vtx[0].Set(pTemp->x, pTemp->y, pTemp->z, 0xffffffff);
	Vtx[1].Set(1.0f, 1.0f, 1.0f, 0xffffffff);
	s_lpD3DDev->SetVertexShader(FVF_CV);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, Vtx, sizeof(__VertexXyzColor));
	pTemp++;
	Vtx[0].Set(pTemp->x, pTemp->y, pTemp->z, 0xffff0000);
	Vtx[1].Set(1.0f, 1.0f, 1.0f, 0xffffffff);
	s_lpD3DDev->SetVertexShader(FVF_CV);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, Vtx, sizeof(__VertexXyzColor));
*/

	for (int i = 0 ; i< m_nGridH;i++)
	{
		for (int j=0;j<m_nGridW-1;j++)
		{
			// Horizontal
			int nIndex = i*m_nGridW+j;
			Vtx[0].Set(m_pParticle[nIndex].x, m_pParticle[nIndex].y, m_pParticle[nIndex].z, 0xffffffff);
			nIndex++;
			Vtx[1].Set(m_pParticle[nIndex].x, m_pParticle[nIndex].y, m_pParticle[nIndex].z, 0xffffffff);
			s_lpD3DDev->SetFVF(FVF_CV);
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, Vtx, sizeof(__VertexXyzColor));
		}
	}
	for (int i = 0 ; i< m_nGridH-1;i++)
	{
		for (int j=0;j<m_nGridW;j++)
		{
			// Vertical
			int nIndex = i*m_nGridW+j;
			Vtx[0].Set(m_pParticle[nIndex].x, m_pParticle[nIndex].y, m_pParticle[nIndex].z, 0xffffffff);
			nIndex+=m_nGridW;
			Vtx[1].Set(m_pParticle[nIndex].x, m_pParticle[nIndex].y, m_pParticle[nIndex].z, 0xffffffff);
			s_lpD3DDev->SetFVF(FVF_CV);
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, Vtx, sizeof(__VertexXyzColor));
		}
	}

	// restore renderstate.
	if (dwCull != D3DCULL_NONE)
		s_lpD3DDev->SetRenderState( D3DRS_CULLMODE, dwCull);
}


#define SPRING_TOLERANCE	0.000001f
#define SPRING_COEFFICIENT		0.3f
void CN3Cloak::UpdateLocalForce()
{
	float length;

	int i, j, index, idx;
	__Vector3 up, down, left, right;
	const float nSub = 0.2f;

	for ( i = 0; i < m_nGridH; i ++ )
	{
		for ( j = 0; j < m_nGridW; j ++ )
		{
			index = i*m_nGridW + j;			
			
			up.x = down.x = left.x = right.x = 0; 
			up.y = down.y = left.y = right.y = 0; 
			up.z = down.z = left.z = right.z = 0; 
			
			if ( j-1 >= 0 )
			{
				idx = i*m_nGridW + (j-1);
				up.x = m_pParticle[idx].x - m_pParticle[index].x; 
				up.y = m_pParticle[idx].y - m_pParticle[index].y; 
				up.z = m_pParticle[idx].z - m_pParticle[index].z;
				
				length = sqrt(up.x * up.x + up.y * up.y + up.z * up.z);

				if (length > SPRING_TOLERANCE)
				{
					length = 1.0f-nSub/length;

					up.x = (length ) * up.x;
					up.y = (length ) * up.y;
					up.z = (length ) * up.z;
				}
			}
			if ( j+1 < m_nGridW)
			{
				idx = i * m_nGridW + j+1;
				down.x = m_pParticle[idx].x - m_pParticle[index].x; 
				down.y = m_pParticle[idx].y - m_pParticle[index].y; 
				down.z = m_pParticle[idx].z - m_pParticle[index].z; 

				length = sqrt(down.x * down.x + down.y * down.y + down.z * down.z);
				if (length > SPRING_TOLERANCE)
				{				
					length = 1.0f-nSub/length;
					down.x = (length ) * down.x ;
					down.y = (length ) * down.y ;
					down.z = (length ) * down.z ;
				}
			}
			if ( i-1 >= 0 )
			{
				idx = (i-1) * m_nGridW + j;
				left.x = m_pParticle[idx].x - m_pParticle[index].x; 
				left.y = m_pParticle[idx].y - m_pParticle[index].y; 
				left.z = m_pParticle[idx].z - m_pParticle[index].z; 

				length = sqrt(left.x * left.x + left.y * left.y + left.z * left.z);
				if (length > SPRING_TOLERANCE)
				{
					length = 1.0f-nSub/length;					
					left.x = (length ) * left.x ;
					left.y = (length ) * left.y ;
					left.z = (length ) * left.z ;
				}
			}
			if ( i+1 < m_nGridH )
			{
				idx = (i+1) * m_nGridW + j;
				right.x = m_pParticle[idx].x - m_pParticle[index].x; 
				right.y = m_pParticle[idx].y - m_pParticle[index].y; 
				right.z = m_pParticle[idx].z - m_pParticle[index].z; 

				length = sqrt(right.x * right.x + right.y * right.y + right.z * right.z);
				if (length > SPRING_TOLERANCE)
				{
					length = 1.0f-nSub/length;
					right.x = (length ) * right.x ;
					right.y = (length ) * right.y ;
					right.z = (length ) * right.z ;
				}
			}
			
			m_pParticle[index].LocalForce.x = (up.x + down.x + left.x + right.x)*SPRING_COEFFICIENT;
			m_pParticle[index].LocalForce.y = (up.y + down.y + left.y + right.y)*SPRING_COEFFICIENT;
			m_pParticle[index].LocalForce.z = (up.z + down.z + left.z + right.z)*SPRING_COEFFICIENT;
		}
	}
}

void CN3Cloak::ApplyForce()
{
	const float energy_loss = 0.99f;
	__Particle *pParticle = m_pParticle;
	__VertexT1	*pVtx;
	for (int i=m_nGridW;i<m_nGridH*m_nGridW;i++)
	{
		pParticle = m_pParticle+i;
		pVtx = m_pVertex+i+m_nGridW*CLOAK_SKIP_LINE;	// 'm_nGridW*CLOAK_SKIP_LINE' means non-movable points..
		{
			// Old.

			pParticle->vx += (m_GravityForce.x + m_Force.x + pParticle->LocalForce.x) ;
			pParticle->vy += (m_GravityForce.y + m_Force.y + pParticle->LocalForce.y) ;
			pParticle->vz += (m_GravityForce.z + m_Force.z + pParticle->LocalForce.z) ;

			pParticle->x += pParticle->vx ;
			pParticle->y += pParticle->vy ;
			pParticle->z += pParticle->vz ;

			pVtx->x += pParticle->vx;
			pVtx->y += pParticle->vy;
			pVtx->z += pParticle->vz;

			// loss process
			pParticle->vx *= energy_loss;
			pParticle->vy *= energy_loss;;
			pParticle->vz *= energy_loss;			
		}
	}
}

void CN3Cloak::SetLOD(int nLevel)
{
	if (nLevel == m_nLOD)	return;

	if (m_pIndex)
		delete[] m_pIndex, m_pIndex = nullptr;

	memset(m_vOffset, 0, sizeof(__Vector3)*CLOAK_MAX_WIDTH);

	switch(nLevel)
	{
	case 0:
		{
			m_nGridW = 7;
			m_nGridH = 5;

			int nVertexCount = m_pPMesh->GetMaxNumVertices();
			int nIndexCount = m_pPMesh->GetMaxNumIndices();
			m_pVertex = new __VertexT1[nVertexCount];
			memcpy(m_pVertex, m_pPMesh->GetVertices(), sizeof(__VertexT1)*nVertexCount);
			m_pIndex = new uint16_t[nIndexCount];
			memcpy(m_pIndex, m_pPMesh->GetIndices(), sizeof(uint16_t)*nIndexCount);
			m_nVertexCount = nVertexCount;
			m_nIndexCount = nIndexCount;
			//
		}
		break;
	case 1:
		{
/*
			m_nGridW = 5;
			m_nGridH = 4;

			int nVertexCount = 25;
			int nIndexCount = 96;
			m_pVertex = new __VertexT1[nVertexCount];
			m_pIndex = new uint16_t[nIndexCount];
			__VertexT1 *pVtx0 = m_pPMesh->GetVertices();
			memcpy(m_pVertex, pVtx0, sizeof(__VertexT1)*5);
			memcpy(m_pVertex+5, pVtx0+6, sizeof(__VertexT1)*5);
			memcpy(m_pVertex+10, pVtx0+12, sizeof(__VertexT1)*5);
			memcpy(m_pVertex+15, pVtx0+18, sizeof(__VertexT1)*5);
			memcpy(m_pVertex+20, pVtx0+24, sizeof(__VertexT1)*5);			

			uint16_t *pIndex = m_pIndex;
			int x,y;
			for (y=0;y<4;y++)
			{
				for(x=0;x<4;x++)
				{
					*(pIndex)   = x   + y*5;
					*(pIndex+1) = x+1 + y*5;
					*(pIndex+2) = x   + (y+1)*5;

					*(pIndex+3) = *(pIndex+2);
					*(pIndex+4) = *(pIndex+1);
					*(pIndex+5) = x+1 + (y+1)*5;
					pIndex+=6;
				}
			}
			m_nVertexCount = nVertexCount;
			m_nIndexCount = nIndexCount;
*/
		}
		break;
	case 2:
		break;
	case 3:
		break;
	}	

	if (m_pParticle)
		delete[] m_pParticle;
	
	m_pParticle = new __Particle[m_nGridW*m_nGridH];
	__Particle *pParticle = m_pParticle;
	int i,j;
	for (i=0;i<m_nGridH;i++)
	{
		for (j=0;j<m_nGridW;j++)
		{
			pParticle->Set(0.5f, 2.0f-j*.2f, 2.0f-i*.2f, 0.0f, 0.0f, 0.0f, 0.0f);
			pParticle++;
		}
	}

	m_nLOD = nLevel;
	//TRACE ("CN3Cloak Set LOD lvl %d\n", nLevel);
}

void CN3Cloak::ApplyOffset(__Vector3& vDif)
{	
/*
	if (m_fOffsetRecoveryTime == 0.0f)
	{
		static int Weight[] = {-3, -2, -1, 1, 2, 3};

		for (int i=0;i<m_nGridW;i++)
		{
			m_pParticle[i].x += vDif.x*Weight[i];
			m_pParticle[i].y += vDif.y*Weight[i];
			m_pParticle[i].z += vDif.z*Weight[i];
			m_vOffset[i].x = vDif.x*Weight[i];
			m_vOffset[i].y = vDif.y*Weight[i];
			m_vOffset[i].z = vDif.z*Weight[i];
		}
		m_fOffsetRecoveryTime = 1.4f;
	}
	else
	{	// offset 이 적용되어 있는 상태.
		m_fOffsetRecoveryTime -= s_fSecPerFrm;
		if (m_fOffsetRecoveryTime < 0.0f)
		{	// Recovery process
			for (int i=0;i<m_nGridW;i++)
			{
				m_pParticle[i].x -= m_vOffset[i].x;
				m_pParticle[i].y -= m_vOffset[i].y;
				m_pParticle[i].z -= m_vOffset[i].z;
				m_vOffset[i].x = 0.0f;
				m_vOffset[i].y = 0.0f;
				m_vOffset[i].z = 0.0f;
			}
			m_fOffsetRecoveryTime = 0.0f;				
		}
	}
*/	
}

void CN3Cloak::TickYaw(float fYaw)
{
	// 회전이 있었다.
	if (fYaw != m_fPrevYaw)
	{
		if (fYaw - m_fPrevYaw > 0.0f)
		{
			if (m_eAnchorPattern == AMP_NONE && m_fAnchorPreserveTime < 0.0f)
				MoveAnchorLine(AMP_YAWCCW, 2.0f);
		}
		else
		{
			if (m_eAnchorPattern == AMP_NONE && m_fAnchorPreserveTime < 0.0f)
				MoveAnchorLine(AMP_YAWCW, 2.0f);				
		}		
	}
	m_fPrevYaw = fYaw;
}

void CN3Cloak::TickByPlayerMotion(e_CloakMove eCurMove)
{
	static float	fTriggerTick = 0.0f;
	static bool		bForceApply = false;
	fTriggerTick += s_fSecPerFrm;

	switch(eCurMove)
	{
	case CLOAK_MOVE_STOP:
		m_GravityForce.y = -0.0015f;
		break;
	case CLOAK_MOVE_WALK:
		m_Force.z = 0.0005f;
		m_GravityForce.y = -0.0025f;
		if (m_eAnchorPattern == AMP_NONE && m_fAnchorPreserveTime < 0.0f)
			MoveAnchorLine(AMP_MOVEXZ, 2.0f);
		//m_GravityForce.y = (rand()%2+1)*-0.0015f;
		//TRACE("Apply force %f\n", m_Force.z);
		break;
	case CLOAK_MOVE_RUN:
		m_Force.z = 0.0009f;
		m_GravityForce.y = -0.0025f;
		if (m_eAnchorPattern == AMP_NONE && m_fAnchorPreserveTime < 0.0f)
			MoveAnchorLine(AMP_MOVEXZ2, 2.0f);
		//m_GravityForce.y = (rand()%2+1)*-0.0015f;
		//TRACE("Apply force %f\n", m_Force.z);
		break;
	case CLOAK_MOVE_WALK_BACKWARD:
		break;
	default:
		break;
	}
}

void CN3Cloak::MoveAnchorLine(e_Cloak_AnchorMovePattern eType, float fPreserveTime)
{
	if (m_eAnchorPattern != AMP_NONE)	return;

	static float Weight[CLOAK_MAX_WIDTH] = {-0.03f, -0.02f, -0.01f, 0.0f, 0.01f, 0.02f, 0.03f};

	switch(eType)
	{
	case AMP_MOVEXZ:
		{
			float x_Offset = (rand()%2-1)*0.01f;
			float z_Offset = 0.03f;

			for(int i=0;i<m_nGridW;i++)
			{
				m_pParticle[i].x += x_Offset;
				m_pParticle[i].z += z_Offset;
				m_vOffset[i].x = x_Offset;
				m_vOffset[i].z = z_Offset;
			}
			//TRACE ("AMP_MOVEXZ Applyed \n");
		}
		break;
	case AMP_MOVEXZ2:
		{
			float x_Offset = (rand()%2-1)*0.02f;
			float z_Offset = 0.04f;

			for(int i=0;i<m_nGridW;i++)
			{
				m_pParticle[i].x += x_Offset;
				m_pParticle[i].z += z_Offset;
				m_vOffset[i].x = x_Offset;
				m_vOffset[i].z = z_Offset;
//				m_pParticle[i].y += x_Offset;
//				m_vOffset[i].y = x_Offset;
			}
			//TRACE ("AMP_MOVEXZ2 Applyed \n");
		}
		break;
	case AMP_YAWCCW:
		{
			for (int i=0;i<m_nGridW;i++)
			{
				m_pParticle[i].z += Weight[i];
				m_vOffset[i].z = Weight[i];
			}
			//TRACE ("AMP_YAWCCW Applyed \n");
		}
		break;
	case AMP_YAWCW:
		{
			for (int i=0;i<m_nGridW;i++)
			{
				m_pParticle[i].z += Weight[i];
				m_vOffset[i].z = Weight[i];
			}
			//TRACE ("AMP_YAWCW Applyed \n");
		}	
		break;
	default:
		break;
	}

	m_fAnchorPreserveTime = fPreserveTime;
	m_eAnchorPattern = eType;
}

void CN3Cloak::RestoreAnchorLine()
{
	__ASSERT(m_eAnchorPattern != AMP_NONE, "call berserk");
	if (m_eAnchorPattern == AMP_NONE)	return;

	__Particle *pParticle = m_pParticle;
	for (int i=0;i<m_nGridW;i++)
	{	
		pParticle->x -= m_vOffset[i].x;
		pParticle->y -= m_vOffset[i].y;
		pParticle->z -= m_vOffset[i].z;
		m_vOffset[i].x = m_vOffset[i].y = m_vOffset[i].z = 0.0f;
		pParticle++;
	}

	m_eAnchorPattern = AMP_NONE;
	m_fAnchorPreserveTime = 1.0f;
	//TRACE ("Anchor Line restored \n");
}

// ===== END N3Base/N3Cloak.cpp =====

// ===== BEGIN N3Base/N3Cloak.h =====
#line 1 "N3Base/N3Cloak.h"
﻿// N3Cloak.h: interface for the CN3Cloak class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3CLOAK_H__3ED1C9F5_2F40_47B7_8CEC_6881E0D9FAEE__INCLUDED_)
#define AFX_N3CLOAK_H__3ED1C9F5_2F40_47B7_8CEC_6881E0D9FAEE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"

#define CLOAK_MAX_WIDTH		7
#define CLOAK_MAX_HEIGHT	7
#define CLOAK_SKIP_LINE		2	// 망토에서 장식용 버텍스가 들어가 있는 라인수. 이부분은 이동이 없다. ok?

enum e_Cloak_AnchorMovePattern {AMP_NONE=0, AMP_YAWCCW, AMP_YAWCW, AMP_MOVEX, AMP_MOVEY, AMP_MOVEZ, AMP_MOVEXZ, AMP_MOVEXZ2};

enum e_CloakMove
{
	CLOAK_MOVE_STOP = 0,
	CLOAK_MOVE_WALK,
	CLOAK_MOVE_RUN,
	CLOAK_MOVE_WALK_BACKWARD,
};

class CPlayerBase;
class CN3Chr;
class CN3CPlug_Cloak;
class CN3Cloak : public CN3Base  
{
public:
	CN3Cloak();
	virtual ~CN3Cloak();

	class __Particle
	{
	public:
		__Particle()
		{
			x = y = z = 0.0f;
			vx = vy = vz = 0.0f;
			LocalForce = {};
			mass = 0.0f;
		}

		~__Particle(){}

		float			x, y, z;
		float			vx, vy, vz;
		__Vector3		LocalForce;
		float			mass;
		void Set(float mass1, float x1, float y1, float z1, float vx1, float vy1, float vz1)
		{
			mass = mass1;
			x = x1, y = y1, z=z1;
			vx = vx1, vy = vy1, vz = vz1;
		}
	};

	void				Init(CN3CPlug_Cloak* pPlugCloak);
	void				SetLOD(int nLevel);
	void				ApplyOffset(__Vector3& vDif);
protected:
	//	Anchor
	e_Cloak_AnchorMovePattern	m_eAnchorPattern;
	float				m_fAnchorPreserveTime;
	__Vector3			m_vOffset[CLOAK_MAX_WIDTH];

	void				RestoreAnchorLine();
	void				MoveAnchorLine(e_Cloak_AnchorMovePattern eType, float fPreserveTime);

	//
	CN3Texture*			m_pTex;
	__VertexT1*			m_pVertex;
	uint16_t*			m_pIndex;
	int					m_nVertexCount, m_nIndexCount;

	int					m_nGridW, m_nGridH;
	int					m_nLOD;

	CN3PMesh*			m_pPMesh;
	float				m_fOffsetRecoveryTime;
	float				m_fPrevYaw;


	__Particle*			m_pParticle;
	__Vector3			m_GravityForce;		// 중력(.y)가 항상있어야 변형이 일어나지 않는다..
	__Vector3			m_Force;			// 외부에서 가해지는 힘.


	void				UpdateLocalForce();	
	void				ApplyForce();
	void				TickYaw(float fYaw);
	void				TickByPlayerMotion(e_CloakMove eCurMove);
public:
	virtual void Tick(int nLOD, float fYaw, e_CloakMove eCurMove);
	virtual void Render(__Matrix44 &mtx);
	virtual void Release();
};

#endif // !defined(AFX_N3CLOAK_H__3ED1C9F5_2F40_47B7_8CEC_6881E0D9FAEE__INCLUDED_)

// ===== END N3Base/N3Cloak.h =====

// ===== BEGIN N3Base/N3Cloud.cpp =====
#line 1 "N3Base/N3Cloud.cpp"
﻿// N3Cloud.cpp: implementation of the CN3Cloud class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Cloud.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Cloud::CN3Cloud()
{
	for(int i = 0; i < NUM_CLOUD; i++) 
	{
		m_pTextures[i] = nullptr;
		m_szTextures[i] = "";
	}

	m_Color1.ChangeColor(0xffffffff);
	m_Color2.ChangeColor(0xffffffff);
	m_Alpha.ChangeColor(0xffffffff);
	m_eCloud1 = CLOUD_WISPS;
	m_eCloud2 = CLOUD_PUFFS;
	m_eCloud3 = CLOUD_NONE;

	m_fCloudTexTime = 0.0f;
	m_eBackupCloud = CLOUD_NONE;
	m_fBackupTime = 0.0f;
}

CN3Cloud::~CN3Cloud()
{
	int i;
	for (i=0; i<NUM_CLOUD; ++i)
	{
		s_MngTex.Delete(&m_pTextures[i]);
	}
}

void CN3Cloud::Release()
{
	CN3Base::Release();
	int i;
	for (i=0; i<NUM_CLOUD; ++i)
	{
		if (m_pTextures[i])
		{
			s_MngTex.Delete(&m_pTextures[i]);
			m_szTextures[i] = "";
		}
	}
	m_Color1.ChangeColor(0xffffffff);
	m_Color2.ChangeColor(0xffffffff);
	m_Alpha.ChangeColor(0xffffffff);
	m_eCloud1 = CLOUD_WISPS;
	m_eCloud2 = CLOUD_PUFFS;
	m_eCloud3 = CLOUD_NONE;

	m_fCloudTexTime = 0.0f;
	m_eBackupCloud = CLOUD_NONE;
	m_fBackupTime = 0.0f;
}
void CN3Cloud::Tick()
{
	int i;
	static float fCloudLayer = 0.0f;
	fCloudLayer += s_fSecPerFrm;

	// 구름층 움직이기
	if (fCloudLayer>=0.05)
	{
//		float du = 0.001*fCloudLayer;
//		float dv = 0.003*fCloudLayer;
//		float du2 = 0.003*fCloudLayer;
//		float dv2 = 0.005*fCloudLayer;
		float du = 0.005f*fCloudLayer;
		float dv = 0.015f*fCloudLayer;
		float du2 = 0.015f*fCloudLayer;
		float dv2 = 0.025f*fCloudLayer;

		for (i=0; i<NUM_CLOUD_VERTEX; ++i)
		{
			m_pVertices[i].tu += du;
			m_pVertices[i].tv += dv;
			m_pVertices[i].tu2 += du2;
			m_pVertices[i].tv2 += dv2;
		}

		fCloudLayer = 0.0f;

		if (m_pVertices[0].tu > 10.0f)
		{
			for (i=0; i<NUM_CLOUD_VERTEX; ++i)	m_pVertices[i].tu -= 10.0f;
		}
		if (m_pVertices[0].tv > 10.0f)
		{
			for (i=0; i<NUM_CLOUD_VERTEX; ++i)	m_pVertices[i].tv -= 10.0f;
		}
	}

	// 색 변화하기
	m_Color1.Tick();
	m_Color2.Tick();

	// 구름 교체
	if (CLOUD_NONE != m_eCloud3)
	{
		m_Alpha.Tick();
		m_fCloudTexTime -= s_fSecPerFrm;
		if (m_fCloudTexTime < 0.0f)	// 구름 교체가 끝났으면
		{
			m_fCloudTexTime = 0.0f;
			m_eCloud2 = m_eCloud3;
			m_eCloud3 = CLOUD_NONE;
			m_Alpha.ChangeColor(0xffffffff);

			if (CLOUD_NONE != m_eBackupCloud)	// 구름 바꿔야 할 것이 있으면
			{
				e_CLOUDTEX eTmp = m_eCloud1;
				m_eCloud1 = m_eCloud2;
				m_eCloud2 = eTmp;

				m_eCloud3 = m_eBackupCloud;
				m_fCloudTexTime = m_fBackupTime;
				m_eBackupCloud = CLOUD_NONE;
				m_fBackupTime = 0.0f;
				m_Alpha.ChangeColor(0x00ffffff, m_fCloudTexTime);

				// uv 좌표도 바꾸기
				for (i=0; i<NUM_CLOUD_VERTEX; ++i)
				{
					float fTempUV = m_pVertices[i].tu;
					m_pVertices[i].tu = m_pVertices[i].tu2;
					m_pVertices[i].tu2 = fTempUV;
					fTempUV = m_pVertices[i].tv;
					m_pVertices[i].tv = m_pVertices[i].tv2;
					m_pVertices[i].tv2 = fTempUV;
				}
			}
		}
	}
}

void CN3Cloud::Render()
{
	__Matrix44 matWorld; matWorld.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());

	static uint16_t CloudIndex[30] = {0,1,4,1,2,5,2,3,6,3,0,7,5,4,1,6,5,2,7,6,3,4,7,0,4,5,7,5,6,7};
	//static uint16_t CloudIndex[54] = {0,1,4,1,2,5,2,3,6,3,0,7,5,4,1,6,5,2,7,6,3,4,7,0,
	///							4,5,8,5,6,9,6,7,10,7,4,11,9,8,5,10,9,6,11,10,7,8,11,4,
	//							8,9,11,9,10,11};

	// backup state
	DWORD dwAlphaOp, dwAlphaArg1, dwAlphaArg2;
	s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAOP,   &dwAlphaOp );
	s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG1, &dwAlphaArg1);
	s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ALPHAARG2, &dwAlphaArg2);
	// set state
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	if (D3DTOP_MODULATE != dwAlphaOp) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwAlphaArg1) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwAlphaArg2) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetFVF(FVF_XYZCOLORT2);

	D3DCOLOR color1 = m_Color1.GetCurColor();
	D3DCOLOR color2 = m_Color2.GetCurColor();
	__ASSERT(CLOUD_NONE != m_eCloud1 && CLOUD_NONE != m_eCloud2, "no cloud texture type");
	// render cloud 1
	int i;
	for (i=0; i<4; ++i) m_pVertices[i].color = color1&0x00ffffff;
	for (i=4; i<NUM_CLOUD_VERTEX; ++i) m_pVertices[i].color = color1;
	s_lpD3DDev->SetTexture(0, GetTex(m_eCloud1));
	s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 8, 10,
						CloudIndex, D3DFMT_INDEX16, m_pVertices, sizeof(__VertexXyzColorT2));

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX , 1);
	if (CLOUD_NONE != m_eCloud3)
	{
		D3DCOLOR Alpha = m_Alpha.GetCurColor();
		if (Alpha<color2) color2 = (Alpha&0xff000000) | (color2&0x00ffffff);	// 기존 색 변화의 alpha값이 구름 교체alpha값보다 큰 경우 구름 교체 alpha값으로 대체
		// render cloud 2
		for (i=0; i<4; ++i) m_pVertices[i].color = color2&0x00ffffff;
		for (i=4; i<NUM_CLOUD_VERTEX; ++i) m_pVertices[i].color = color2;
		s_lpD3DDev->SetTexture(0, GetTex(m_eCloud2));
		s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 8, 10,
							CloudIndex, D3DFMT_INDEX16, m_pVertices, sizeof(__VertexXyzColorT2));
		// render cloud 3
		D3DCOLOR color3 = ((0xff-(color2>>24))<<24) | (color2&0x00ffffff);	// color2의 alpha값을 0xff에서 뺀 값으로 바꿈
		for (i=4; i<NUM_CLOUD_VERTEX; ++i) m_pVertices[i].color = color3;			
		s_lpD3DDev->SetTexture(0, GetTex(m_eCloud3));
		s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 8, 10,
							CloudIndex, D3DFMT_INDEX16, m_pVertices, sizeof(__VertexXyzColorT2));
	}
	else
	{
		// render cloud 2
		for (i=0; i<4; ++i) m_pVertices[i].color = color2&0x00ffffff;
		for (i=4; i<NUM_CLOUD_VERTEX; ++i) m_pVertices[i].color = color2;
		s_lpD3DDev->SetTexture(0, GetTex(m_eCloud2));
		s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 8, 10,
							CloudIndex, D3DFMT_INDEX16, m_pVertices, sizeof(__VertexXyzColorT2));
	}
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX , 0);

	// restore state
	if (D3DTOP_MODULATE != dwAlphaOp) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	if (D3DTA_TEXTURE != dwAlphaArg1) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	if (D3DTA_DIFFUSE != dwAlphaArg2) s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

}

LPDIRECT3DTEXTURE9	CN3Cloud::GetTex(e_CLOUDTEX tex)
{
	if (nullptr == m_pTextures[tex])
	{
		m_pTextures[tex] = s_MngTex.Get(m_szTextures[tex]);
		if (nullptr == m_pTextures[tex]) return nullptr;
	}

	return m_pTextures[tex]->Get();
}

void	CN3Cloud::Init(	const std::string* pszFNs)
{
	Release();

	for(int i = 0; i < NUM_CLOUD; i++) m_szTextures[i] = pszFNs[i];

//	3단일때
/*	const float fSqrt3 = 1.0f/sqrtf(3.0f);
	const float fOffset = 3.0f;
	const float fSmallLength = 5.0f;
	const float fMediumLength = fSmallLength + fOffset;
	const float fBigLenth = fMediumLength + fOffset*fSqrt3;
	const float fBigHeight = 0.0f;
	const float fMediumHeight = fBigHeight + fOffset;
	const float fSmallHeight = fMediumHeight + fOffset*fSqrt3;

	D3DCOLOR BigColor = 0x00ffffff;
	D3DCOLOR MediumColor = 0xffffffff;
	D3DCOLOR SmallColor = 0xffffffff;

	float fTmp1, fTmp2;
	fTmp1 = fBigLenth-fMediumLength;
	fTmp2 = fMediumHeight - fBigHeight;
	const float fBig = sqrtf(fTmp1*fTmp1 + fTmp2*fTmp2);	// 젤큰 사각형과 중간사각형간의 거리
	fTmp1 = fMediumLength - fSmallLength;
	fTmp2 = fSmallHeight - fMediumHeight;
	const float fMedium = sqrtf(fTmp1*fTmp1 + fTmp2*fTmp2);	// 중간 사각형과 작은사각형간의 거리
	const float fSmall = fSmallLength;						// 작은 사각형이 0에서 떨어진 거리
	const float fTotal = fBig + fMedium + fSmall;

	float fTexUVLeft = 0.0f, fTexUVTop = 0.0f, fTexUVRight = 3.0f, fTexUVBottom = 3.0f;	// 텍스쳐 구름으로 표시할 영역 좌표(텍스쳐의 전체가 될수도 있고 일부분이 될 수도 있기 때문에)
//	const float fTexOffsetU_M = (fBig/fTotal)*(fTexUVRight-fTexUVLeft)/2;
//	const float fTexOffsetV_M = (fBig/fTotal)*(fTexUVBottom-fTexUVTop)/2;
//	const float fTexOffsetU_S = ((fBig+fMedium)/fTotal)*(fTexUVRight-fTexUVLeft)/2;
//	const float fTexOffsetV_S = ((fBig+fMedium)/fTotal)*(fTexUVBottom-fTexUVTop)/2;

	const float fTexOffsetU_M = (1.0f - fMediumLength/fBigLenth)*(fTexUVRight-fTexUVLeft)/2;
	const float fTexOffsetV_M = (1.0f - fMediumLength/fBigLenth)*(fTexUVBottom-fTexUVTop)/2;
	const float fTexOffsetU_S = (1.0f - fSmallLength/fBigLenth)*(fTexUVRight-fTexUVLeft)/2;
	const float fTexOffsetV_S = (1.0f - fSmallLength/fBigLenth)*(fTexUVBottom-fTexUVTop)/2;

	// big
	m_pVertices[0].Set(-fBigLenth, fBigHeight,-fBigLenth, BigColor, fTexUVLeft,	fTexUVTop,		fTexUVLeft,		fTexUVTop);
	m_pVertices[1].Set( fBigLenth, fBigHeight,-fBigLenth, BigColor, fTexUVRight,	fTexUVTop,		fTexUVRight,	fTexUVTop);
	m_pVertices[2].Set( fBigLenth, fBigHeight, fBigLenth, BigColor, fTexUVRight,	fTexUVBottom,	fTexUVRight,	fTexUVBottom);
	m_pVertices[3].Set(-fBigLenth, fBigHeight, fBigLenth, BigColor, fTexUVLeft,	fTexUVBottom,	fTexUVLeft,		fTexUVBottom);
	// medium
	m_pVertices[4].Set(-fMediumLength, fMediumHeight,-fMediumLength, MediumColor, fTexUVLeft+fTexOffsetU_M,	fTexUVTop+fTexOffsetV_M,		fTexUVLeft+fTexOffsetU_M,	fTexUVTop+fTexOffsetV_M);
	m_pVertices[5].Set( fMediumLength, fMediumHeight,-fMediumLength, MediumColor, fTexUVRight-fTexOffsetU_M, fTexUVTop+fTexOffsetV_M,		fTexUVRight-fTexOffsetU_M, fTexUVTop+fTexOffsetV_M);
	m_pVertices[6].Set( fMediumLength, fMediumHeight, fMediumLength, MediumColor, fTexUVRight-fTexOffsetU_M, fTexUVBottom-fTexOffsetV_M,	fTexUVRight-fTexOffsetU_M, fTexUVBottom-fTexOffsetV_M);
	m_pVertices[7].Set(-fMediumLength, fMediumHeight, fMediumLength, MediumColor, fTexUVLeft+fTexOffsetU_M,	fTexUVBottom-fTexOffsetV_M,	fTexUVLeft+fTexOffsetU_M,	fTexUVBottom-fTexOffsetV_M);

	// small
	m_pVertices[8].Set( -fSmallLength, fSmallHeight,-fSmallLength, SmallColor, fTexUVLeft+fTexOffsetU_S,	fTexUVTop+fTexOffsetV_S,		fTexUVLeft+fTexOffsetU_S,	fTexUVTop+fTexOffsetV_S);
	m_pVertices[9].Set(  fSmallLength, fSmallHeight,-fSmallLength, SmallColor, fTexUVRight-fTexOffsetU_S, fTexUVTop+fTexOffsetV_S,		fTexUVRight-fTexOffsetU_S, fTexUVTop+fTexOffsetV_S);
	m_pVertices[10].Set( fSmallLength, fSmallHeight, fSmallLength, SmallColor, fTexUVRight-fTexOffsetU_S, fTexUVBottom-fTexOffsetV_S,	fTexUVRight-fTexOffsetU_S, fTexUVBottom-fTexOffsetV_S);
	m_pVertices[11].Set(-fSmallLength, fSmallHeight, fSmallLength, SmallColor, fTexUVLeft+fTexOffsetU_S,	fTexUVBottom-fTexOffsetV_S,	fTexUVLeft+fTexOffsetU_S,	fTexUVBottom-fTexOffsetV_S);
*/ 
// 2단일때
	const float fSqrt3 = 1.0f/sqrtf(3.0f);
	float fBigLenth = 16.0f;				// 구름 절두면체의 아래 큰 사각형 길이
	const float fSmallLength = 8.0f;		// 구름 절두면체의 위 작은 사각형 길이
	const float fBigHeight = 5.0f;			// 구름 사각절두면체의 아래 높이(지평선 0.0f 기준)
	const float fSmallHeight = fBigHeight + (fBigLenth-fSmallLength)*fSqrt3;	// 구름 절두면체의 위 높이(지평선 0.0f 기준)

	fBigLenth = 24.0f;	//위에 코드는 최적화 각도, 이것은 큰 사격형만 다시 늘림

	D3DCOLOR BigColor = 0x00ffffff;
	D3DCOLOR SmallColor = 0xffffffff;

	float fTexUVLeft = 0.0f, fTexUVTop = 0.0f, fTexUVRight = 4.0f, fTexUVBottom = 4.0f;	// 텍스쳐 구름으로 표시할 영역 좌표(텍스쳐의 전체가 될수도 있고 일부분이 될 수도 있기 때문에)
	float fTmp1 = fBigLenth - fSmallLength;
	float fTmp2 = fSmallHeight - fBigHeight;
//	const float fBig = sqrtf(fTmp1*fTmp1 + fTmp2*fTmp2);
//	const float fSmall = fSmallLength;
//	const float fTotal = fBig + fSmall;
//	const float fTexOffsetU = (fSmall/fTotal)*(fTexUVRight-fTexUVLeft)/2;
//	const float fTexOffsetV = (fSmall/fTotal)*(fTexUVBottom-fTexUVTop)/2;
	const float fTexOffsetU = (1.0f - fSmallLength/fBigLenth)*(fTexUVRight-fTexUVLeft)/2;
	const float fTexOffsetV = (1.0f - fSmallLength/fBigLenth)*(fTexUVBottom-fTexUVTop)/2;
	// big
	m_pVertices[0].Set(-fBigLenth, fBigHeight,-fBigLenth, BigColor, fTexUVLeft,		fTexUVTop,		fTexUVLeft,		fTexUVTop);
	m_pVertices[1].Set( fBigLenth, fBigHeight,-fBigLenth, BigColor, fTexUVRight,	fTexUVTop,		fTexUVRight,	fTexUVTop);
	m_pVertices[2].Set( fBigLenth, fBigHeight, fBigLenth, BigColor, fTexUVRight,	fTexUVBottom,	fTexUVRight,	fTexUVBottom);
	m_pVertices[3].Set(-fBigLenth, fBigHeight, fBigLenth, BigColor, fTexUVLeft,		fTexUVBottom,	fTexUVLeft,		fTexUVBottom);
	// small
	m_pVertices[4].Set(-fSmallLength, fSmallHeight,-fSmallLength, SmallColor, fTexUVLeft+fTexOffsetU,	fTexUVTop+fTexOffsetV,		fTexUVLeft+fTexOffsetU,	fTexUVTop+fTexOffsetV);
	m_pVertices[5].Set( fSmallLength, fSmallHeight,-fSmallLength, SmallColor, fTexUVRight-fTexOffsetU, fTexUVTop+fTexOffsetV,		fTexUVRight-fTexOffsetU, fTexUVTop+fTexOffsetV);
	m_pVertices[6].Set( fSmallLength, fSmallHeight, fSmallLength, SmallColor, fTexUVRight-fTexOffsetU, fTexUVBottom-fTexOffsetV,	fTexUVRight-fTexOffsetU, fTexUVBottom-fTexOffsetV);
	m_pVertices[7].Set(-fSmallLength, fSmallHeight, fSmallLength, SmallColor, fTexUVLeft+fTexOffsetU,	fTexUVBottom-fTexOffsetV,	fTexUVLeft+fTexOffsetU,	fTexUVBottom-fTexOffsetV);
}


void CN3Cloud::SetCloud(e_CLOUDTEX eCloud1, e_CLOUDTEX eCloud2, float fSec)
{
	if (CLOUD_NONE == eCloud1 || CLOUD_NONE == eCloud2) return;

	// 변수 초기화
	m_Alpha.ChangeColor(0xffffffff);
	m_fCloudTexTime = 0.0f;
	m_eCloud3 = CLOUD_NONE;
	m_eBackupCloud = CLOUD_NONE;
	m_fBackupTime = 0.0f;

	// 바꿀 구름 판단
	int iSameCount = 0;
	if (eCloud1 == m_eCloud1) ++iSameCount;
	else if (eCloud1 == m_eCloud2) ++iSameCount;
	if (eCloud2 == m_eCloud1) ++iSameCount;
	else if (eCloud2 == m_eCloud2) ++iSameCount;

	if (2 == iSameCount)		// 같은 구름이므로 바꿀 필요가 없다
	{
		return;
	}

	if (1 == iSameCount)		// 하나만 교체하면 된다.
	{
		if (m_eCloud1 == eCloud1)
		{
			m_eCloud3 = eCloud2;
		}
		else if (m_eCloud1 == eCloud2)
		{
			m_eCloud3 = eCloud1;
		}
		else if (m_eCloud2 == eCloud1)
		{
			m_eCloud2 = m_eCloud1;
			m_eCloud1 = eCloud1;
			m_eCloud3 = eCloud2;
		}
		else
		{
			m_eCloud2 = m_eCloud1;
			m_eCloud1 = eCloud2;
			m_eCloud3 = eCloud1;
		}
		if (0.0f == fSec)
		{
			m_eCloud2 = m_eCloud3;
			m_eCloud3 = CLOUD_NONE;
		}
		else
		{
			m_Alpha.ChangeColor(0x00ffffff, fSec);
			m_fCloudTexTime = fSec;
		}
		return;
	}

	// 두개 모두 교체
	if (0.0f == fSec)
	{
		m_eCloud1 = eCloud1;
		m_eCloud2 = eCloud2;
		m_eCloud3 = CLOUD_NONE;
		return;
	}
	m_eCloud3 = eCloud1;
	m_eBackupCloud = eCloud2;
	m_fCloudTexTime = fSec*0.5f;
	m_fBackupTime = m_fCloudTexTime;
	m_Alpha.ChangeColor(0x00ffffff, m_fCloudTexTime);
}


// ===== END N3Base/N3Cloud.cpp =====

// ===== BEGIN N3Base/N3Cloud.h =====
#line 1 "N3Base/N3Cloud.h"
﻿// N3Cloud.h: interface for the CN3Cloud class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3CLOUD_H__0C780CD3_38F2_48CD_B36E_E7C64C7893EB__INCLUDED_)
#define AFX_N3CLOUD_H__0C780CD3_38F2_48CD_B36E_E7C64C7893EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include "N3ColorChange.h"
#include <string>

const int NUM_CLOUD_VERTEX = 8;
//const int NUM_CLOUD_VERTEX = 12;

enum	e_CLOUDTEX {CLOUD_NONE=-1,CLOUD_WISPS=0, CLOUD_PUFFS, CLOUD_TATTERS, CLOUD_STREAKS,
	CLOUD_DENSE, CLOUD_OVERCAST, NUM_CLOUD};





class CN3Cloud : public CN3Base  
{
	friend class CN3SkyMng;
public:
	CN3Cloud();
	virtual ~CN3Cloud();

protected:
	__VertexXyzColorT2	m_pVertices[NUM_CLOUD_VERTEX]; // 구름층의 버텍스
	CN3Texture*		m_pTextures[NUM_CLOUD];				// 텍스쳐들..
	std::string		m_szTextures[NUM_CLOUD];			// 텍스처 파일 이름들...

	CN3ColorChange	m_Color1;							// 구름 색1
	CN3ColorChange	m_Color2;							// 구름 색2
	CN3ColorChange	m_Alpha;							// 구름 바뀔때 alpha값
	e_CLOUDTEX		m_eCloud1;							// 구름 텍스쳐1
	e_CLOUDTEX		m_eCloud2;							// 구름 텍스쳐2
	e_CLOUDTEX		m_eCloud3;							// 구름 텍스쳐3

	float			m_fCloudTexTime;					// 구름 변경 남은 시간
	e_CLOUDTEX		m_eBackupCloud;						// 2번째 구름 변경해야 할 texture종류 저장
	float			m_fBackupTime;						// 2번째 구름 변경해야 할 시간 저장

// Operations
public:
	void			ChangeColor1(D3DCOLOR color, float fSec) {m_Color1.ChangeColor(color, fSec);}
	void			ChangeColor2(D3DCOLOR color, float fSec) {m_Color2.ChangeColor(color, fSec);}
	void			SetCloud(e_CLOUDTEX eCloud1, e_CLOUDTEX eCloud2, float fSec);
	void			Init(const std::string* pszFNs);
	virtual void	Release();
	virtual void	Render();
	virtual void	Tick();
protected:
	LPDIRECT3DTEXTURE9	GetTex(e_CLOUDTEX tex);

};

#endif // !defined(AFX_N3CLOUD_H__0C780CD3_38F2_48CD_B36E_E7C64C7893EB__INCLUDED_)

// ===== END N3Base/N3Cloud.h =====

// ===== BEGIN N3Base/N3ColorChange.cpp =====
#line 1 "N3Base/N3ColorChange.cpp"
﻿// N3ColorChange.cpp: implementation of the CN3ColorChange class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3ColorChange.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3ColorChange::CN3ColorChange()
{
	m_CurColor = m_PrevColor = m_NextColor = 0xffffffff;
	m_fPercentage = 0.0f;
	m_fRate = 0.0f;
	m_fTempSec = 0.0f;
}

CN3ColorChange::~CN3ColorChange()
{
}

void CN3ColorChange::ChangeColor(D3DCOLOR color, float fSec)
{
	if (color == m_CurColor || 0.0f >= fSec)	// 즉시 변화
	{
		m_CurColor = m_PrevColor = m_NextColor = color;
		m_fRate = m_fPercentage = m_fTempSec = 0.0f;
		return;
	}

	m_PrevColor = m_CurColor;
	m_NextColor = color;
	m_fPercentage = 0.0f;
	m_fRate = 1.0f/fSec;
}

void CN3ColorChange::Tick()
{
	if (0.0f == m_fRate) return;
	m_fTempSec += s_fSecPerFrm;
	if (m_fTempSec>0.1f)
	{
		m_fPercentage += (m_fRate * m_fTempSec);
		m_fTempSec = 0.0f;
	}
	if (m_fPercentage > 1.0f)
	{
		m_PrevColor = m_CurColor = m_NextColor;
		m_fPercentage = m_fRate = 0.0f;
		return;
	}
	int iPrevA = (m_PrevColor & 0xff000000)>>24;
	int iPrevR = (m_PrevColor & 0x00ff0000)>>16;
	int iPrevG = (m_PrevColor & 0x0000ff00)>>8;
	int iPrevB = (m_PrevColor & 0x000000ff);
	int iNextA = (m_NextColor & 0xff000000)>>24;
	int iNextR = (m_NextColor & 0x00ff0000)>>16;
	int iNextG = (m_NextColor & 0x0000ff00)>>8;
	int iNextB = (m_NextColor & 0x000000ff);
	uint32_t dwCurA = ((iPrevA + int((iNextA-iPrevA)*m_fPercentage))&0xff) << 24;
	uint32_t dwCurR = ((iPrevR + int((iNextR-iPrevR)*m_fPercentage))&0xff) << 16;
	uint32_t dwCurG = ((iPrevG + int((iNextG-iPrevG)*m_fPercentage))&0xff) << 8;
	uint32_t dwCurB = ((iPrevB + int((iNextB-iPrevB)*m_fPercentage))&0xff);

	m_CurColor = dwCurA|dwCurR|dwCurG|dwCurB;
}

void CN3ColorChange::SetPercentage(float fPercentage)
{
	if (0.0f>fPercentage || 1.0f<fPercentage) return;
	if (1.0f == fPercentage)
	{	// 1.0f이면 바로 색 바꾸기
		m_PrevColor = m_CurColor = m_NextColor;
		m_fPercentage = m_fRate = 0.0f;
		return;
	}
	m_fPercentage = fPercentage;
	m_fTempSec = 0.0f;
}


















CN3DeltaChange::CN3DeltaChange()
{
	m_fCurDelta = m_fPrevDelta = m_fNextDelta = 0.0f;
	m_fPercentage = 0.0f;
	m_fRate = 0.0f;
	m_fTempSec = 0.0f;
}

CN3DeltaChange::~CN3DeltaChange()
{
}

void CN3DeltaChange::ChangeDelta(float fDelta, float fSec)
{
	if (fDelta == m_fCurDelta || 0.0f >= fSec)	// 즉시 변화
	{
		m_fCurDelta = m_fPrevDelta = m_fNextDelta = fDelta;
		m_fRate = m_fPercentage = m_fTempSec = 0.0f;
		return;
	}

	m_fPrevDelta = m_fCurDelta;
	m_fNextDelta = fDelta;
	m_fPercentage = 0.0f;
	m_fRate = 1.0f/fSec;
}

void CN3DeltaChange::Tick()
{
	if (0.0f == m_fRate) return;
	m_fTempSec += s_fSecPerFrm;
	if (m_fTempSec>0.1f)
	{
		m_fPercentage += (m_fRate * m_fTempSec);
		m_fTempSec = 0.0f;
	}
	if (m_fPercentage > 1.0f)
	{
		m_fPrevDelta = m_fCurDelta = m_fNextDelta;
		m_fPercentage = m_fRate = 0.0f;
		return;
	}
	
	m_fCurDelta = m_fPrevDelta + (m_fNextDelta - m_fPrevDelta) * m_fPercentage;
}

void CN3DeltaChange::SetPercentage(float fPercentage)
{
	if (0.0f>fPercentage || 1.0f<fPercentage) return;
	if (1.0f == fPercentage)
	{	// 1.0f이면 바로 색 바꾸기
		m_fPrevDelta = m_fCurDelta = m_fNextDelta;
		m_fPercentage = m_fRate = 0.0f;
		return;
	}
	m_fPercentage = fPercentage;
	m_fTempSec = 0.0f;
}

// ===== END N3Base/N3ColorChange.cpp =====

// ===== BEGIN N3Base/N3ColorChange.h =====
#line 1 "N3Base/N3ColorChange.h"
﻿// N3ColorChange.h: interface for the CN3ColorChange class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3COLORCHANGE_H__6A4576D3_1880_40A4_AED9_39B306508D0C__INCLUDED_)
#define AFX_N3COLORCHANGE_H__6A4576D3_1880_40A4_AED9_39B306508D0C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "N3Base.h"

class CN3ColorChange  : public CN3Base
{
public:
	CN3ColorChange();
	virtual ~CN3ColorChange();

public:
	D3DCOLOR	GetCurColor() const {return m_CurColor;}
	D3DCOLOR	GetNextColor() const {return m_NextColor;}
	void		ChangeColor(D3DCOLOR color, float fSec = 0.0f);
	void		Tick();
	void		SetPercentage(float fPercentage);
protected:
	D3DCOLOR	m_CurColor;	// 현재 색.
	D3DCOLOR	m_PrevColor;	// 변화하기 전 색.
	D3DCOLOR	m_NextColor;	// 최종적으로 변화할 색.
	float		m_fPercentage;	// 현재 변화된 정도(0.0 ~ 1.0)
	float		m_fRate;		// 초당 변화율
	float		m_fTempSec;		// 임시 시간 저장 변수
};

class CN3DeltaChange  : public CN3Base
{
public:
	CN3DeltaChange();
	virtual ~CN3DeltaChange();

public:
	float		GetCurDelta() const {return m_fCurDelta;}
	float		GetNextDelta() const {return m_fNextDelta;}
	void		ChangeDelta(float fDelta, float fSec = 0.0f);
	void		Tick();
	void		SetPercentage(float fPercentage);
protected:
	float		m_fCurDelta;	// 현재 색.
	float		m_fPrevDelta;	// 변화하기 전 색.
	float		m_fNextDelta;	// 최종적으로 변화할 색.

	float		m_fPercentage;	// 현재 변화된 정도(0.0 ~ 1.0)
	float		m_fRate;		// 초당 변화율
	float		m_fTempSec;		// 임시 시간 저장 변수
};

#endif // !defined(AFX_N3COLORCHANGE_H__6A4576D3_1880_40A4_AED9_39B306508D0C__INCLUDED_)

// ===== END N3Base/N3ColorChange.h =====

// ===== BEGIN N3Base/N3Eng.cpp =====
#line 1 "N3Base/N3Eng.cpp"
﻿#include "StdAfxBase.h"
#include "N3Eng.h"
#include "N3Light.h"
#include "LogWriter.h"

CN3Eng::CN3Eng()
{
	m_lpDD          = nullptr;
	m_lpD3D         = nullptr;
	s_lpD3DDev      = nullptr;
	m_nModeActive   = -1;
	m_nAdapterCount =  1;

	memset(&m_DeviceInfo, 0x00, sizeof(__D3DDEV_INFO));

	delete [] m_DeviceInfo.pModes;
	memset(&m_DeviceInfo, 0x00, sizeof(m_DeviceInfo));

#ifdef _N3GAME
	CLogWriter::Open("Log.txt");
#endif

	m_lpD3D = Direct3DCreate9(D3D_SDK_VERSION);

	if(m_lpD3D == nullptr)
	{
#ifdef _N3GAME
		CLogWriter::Write("Direct3D9 is not installed or lower version");
#endif
		Release();
		exit(-1);
	}

	// 프로그램이 실행된 경로..
	if (s_szPath.empty())
	{
		char szPath[_MAX_PATH] = {};
		char szDrive[_MAX_DRIVE] = {}, szDir[_MAX_DIR] = {};
		::GetModuleFileName(nullptr, szPath, _MAX_PATH);
		_splitpath(szPath, szDrive, szDir, nullptr, nullptr);
		strcat(szPath, szDrive);
		strcat(szPath, szDir);
		PathSet(szPath); // 경로 설정..	
	}
}

CN3Eng::~CN3Eng()
{
	CN3Base::ReleaseResrc();
	delete [] m_DeviceInfo.pModes;

	if(s_lpD3DDev)
	{
		int nRefCount = s_lpD3DDev->Release();

		if (nRefCount == 0) {
			s_lpD3DDev = nullptr;
		} else {
#ifdef _N3GAME
			CLogWriter::Write("CNEng::~CN3Eng - Device reference count is bigger than 0");
#endif
		}
	}

	if(m_lpD3D) if(m_lpD3D->Release() == 0) m_lpD3D = nullptr;
	if(m_lpDD) m_lpDD->Release(); m_lpDD = nullptr;

#ifdef _N3GAME
	CLogWriter::Close();
#endif
}

void CN3Eng::Release()
{
	m_nModeActive   = -1;
	m_nAdapterCount =  1;

	delete [] m_DeviceInfo.pModes;
	memset(&m_DeviceInfo, 0, sizeof(m_DeviceInfo));

	if(s_lpD3DDev)
	{
		int nRefCount = s_lpD3DDev->Release();

		if (nRefCount == 0) {
			s_lpD3DDev = nullptr;
		} else {
#ifdef _N3GAME
			CLogWriter::Write("CNEng::Release Device reference count is bigger than 0");
#endif
		}
	}

	if(m_lpDD) m_lpDD->Release(); m_lpDD = nullptr;
}

//-----------------------------------------------------------------------------
void CN3Eng::SetViewPort(RECT& rc)
{
	if (s_lpD3DDev == nullptr) return;

	D3DVIEWPORT9 vp;
	vp.X      = rc.left;
	vp.Y      = rc.top;
	vp.Width  = rc.right  - rc.left;
	vp.Height = rc.bottom - rc.top;
	vp.MinZ   = 0.0f;
	vp.MaxZ   = 1.0f;

	s_lpD3DDev->SetViewport(&vp);
	memcpy(&s_CameraData.vp, &vp, sizeof(D3DVIEWPORT9));
}

void CN3Eng::SetDefaultEnvironment()
{
	__Matrix44 matWorld;
	matWorld.Identity();

	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());
	s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, TRUE);

	s_lpD3DDev->SetRenderState(D3DRS_DITHERENABLE, TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

	s_lpD3DDev->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

	float fMipMapLODBias = -1.0f;

	for (int i = 0; i < 8; ++i)
	{
		s_lpD3DDev->SetTexture(i, nullptr);
		s_lpD3DDev->SetSamplerState(i, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
		s_lpD3DDev->SetSamplerState(i, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
		s_lpD3DDev->SetSamplerState(i, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);
		s_lpD3DDev->SetSamplerState(i, D3DSAMP_MIPMAPLODBIAS, *((LPDWORD) (&fMipMapLODBias)));
	}

	// 기본 라이트 정보 지정..
	for (int i = 0; i < 8; i++)
	{
		CN3Light::__Light Lgt;
		__ColorValue LgtColor = { 1.0f, 1.0f, 1.0f, 1.0f };
		Lgt.InitPoint(i, { 0, 0, 0 }, LgtColor);
		s_lpD3DDev->SetLight(i, Lgt.toD3D());
	}

	D3DCLIPSTATUS9 cs;
	cs.ClipUnion = cs.ClipIntersection = D3DCS_ALL;

	s_lpD3DDev->SetClipStatus(&cs);
}

/*!
Used to set the view matrix for DirectX
*/
void CN3Eng::LookAt(const __Vector3& vEye, const __Vector3& vAt, const __Vector3& vUp)
{
	__Matrix44 matView;
	matView.LookAtLH(vEye, vAt, vUp);
	s_lpD3DDev->SetTransform(D3DTS_VIEW, matView.toD3D());
}

//-----------------------------------------------------------------------------
bool CN3Eng::Reset(bool bWindowed, uint32_t dwWidth, uint32_t dwHeight, uint32_t dwBPP)
{
	if (s_lpD3DDev == nullptr) return false;
	if (dwWidth <= 0 || dwHeight <= 0) return false;

	if (dwWidth == s_DevParam.BackBufferWidth && dwHeight == s_DevParam.BackBufferHeight)
	{
		if (0 == dwBPP) return false;
		if (16 == dwBPP && D3DFMT_R5G6B5 == s_DevParam.BackBufferFormat) return false;
		if (24 == dwBPP && D3DFMT_R8G8B8 == s_DevParam.BackBufferFormat) return false;
		if (32 == dwBPP && D3DFMT_X8R8G8B8 == s_DevParam.BackBufferFormat) return false;
	}

	D3DPRESENT_PARAMETERS DevParamBackUp;
	memcpy(&DevParamBackUp, &s_DevParam, sizeof(D3DPRESENT_PARAMETERS));

	D3DFORMAT BBFormat = D3DFMT_UNKNOWN;

	if (bWindowed)
	{
		D3DDISPLAYMODE dm;
		m_lpD3D->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dm);

		BBFormat = dm.Format;

	} else
	{
		if (16 == dwBPP) BBFormat = D3DFMT_R5G6B5;
		else if (24 == dwBPP) BBFormat = D3DFMT_R8G8B8;
		else if (32 == dwBPP) BBFormat = D3DFMT_X8R8G8B8;
	}

	s_DevParam.Windowed         = bWindowed;
	s_DevParam.BackBufferWidth  = dwWidth;
	s_DevParam.BackBufferHeight = dwHeight;
	s_DevParam.BackBufferFormat = BBFormat;

	int nMC = m_DeviceInfo.nModeCount;
	for (int i = 0; i < nMC; i++)
	{
		if (m_DeviceInfo.pModes[i].Format == s_DevParam.BackBufferFormat)
		{
			FindDepthStencilFormat(
				0, m_DeviceInfo.DevType, m_DeviceInfo.pModes[i].Format,
				&s_DevParam.AutoDepthStencilFormat
			);

			m_nModeActive = i;

			break;
		}
	}

	if (D3D_OK != s_lpD3DDev->Reset(&s_DevParam))
	{
#ifdef _N3GAME
		CLogWriter::Write("CNEng::Reset - Insufficient video memory");
#endif
		memcpy(&s_DevParam, &DevParamBackUp, sizeof(D3DPRESENT_PARAMETERS));

		if (D3D_OK != s_lpD3DDev->Reset(&s_DevParam))
		{
#ifdef _N3GAME
			CLogWriter::Write("CNEng::Reset - Insufficient video memory");
#endif
		}

		return false;
	}

	RECT rcView = {
		0, 0, (int)dwWidth, (int)dwHeight
	};

	SetViewPort(rcView);
	SetDefaultEnvironment();

	return true;
}

//-----------------------------------------------------------------------------
/*!
Set the projection matrix for DirectX
*/
void CN3Eng::SetProjection(float fNear, float fFar, float fLens, float fAspect)
{
	__Matrix44 matProjection;
	matProjection.PerspectiveFovLH(fLens, fAspect, fNear, fFar);
	s_lpD3DDev->SetTransform(D3DTS_PROJECTION, matProjection.toD3D());
}

bool CN3Eng::Init(
	BOOL bWindowed,
	HWND hWnd,
	uint32_t dwWidth,
	uint32_t dwHeight,
	uint32_t dwBPP,
	BOOL bUseHW)
{
	memset(&s_ResrcInfo, 0, sizeof(__ResrcInfo)); // Rendering Information 초기화..

	s_hWndBase = hWnd;

	// FIX (srmeier): I really have no idea what the second arguement here should be
	int nModesX8R8G8B8 = m_lpD3D->GetAdapterModeCount(0, D3DFMT_X8R8G8B8);
	int nModesR8G8B8 = m_lpD3D->GetAdapterModeCount(0, D3DFMT_R8G8B8);
	int nModesR5G6B5 = m_lpD3D->GetAdapterModeCount(0, D3DFMT_R5G6B5);

	// 디스플레이 모드 카운트
	int nAMC = nModesX8R8G8B8 + nModesR8G8B8 + nModesR5G6B5;
	if(nAMC <= 0)
	{
		//MessageBox(hWnd, "Can't create D3D - Invalid display mode property.", "initialization", MB_OK);
//		{ for(int iii = 0; iii < 2; iii++) Beep(2000, 200); Sleep(300); } // 여러번 삑~
#ifdef _N3GAME
		CLogWriter::Write("Can't create D3D - Invalid display mode property.");
#endif
		this->Release();
		return false;
	}

	m_DeviceInfo.nAdapter = 0;
	m_DeviceInfo.DevType = D3DDEVTYPE_HAL;
	m_DeviceInfo.nDevice = 0;
	m_DeviceInfo.nModeCount = nAMC;

	delete [] m_DeviceInfo.pModes;
	m_DeviceInfo.pModes = new D3DDISPLAYMODE[nAMC];

	// 디스플레이 모드 가져오기..
	int nModeOffset = 0;
	for (int i = 0; i < nModesX8R8G8B8; i++)
		m_lpD3D->EnumAdapterModes(0, D3DFMT_X8R8G8B8, i, &m_DeviceInfo.pModes[nModeOffset++]);

	for (int i = 0; i < nModesR8G8B8; i++)
		m_lpD3D->EnumAdapterModes(0, D3DFMT_R8G8B8, i, &m_DeviceInfo.pModes[nModeOffset++]);

	for (int i = 0; i < nModesR5G6B5; i++)
		m_lpD3D->EnumAdapterModes(0, D3DFMT_R5G6B5, i, &m_DeviceInfo.pModes[nModeOffset++]);

	D3DDEVTYPE DevType = D3DDEVTYPE_REF;
	if(TRUE == bUseHW) DevType = D3DDEVTYPE_HAL;

	memset(&s_DevParam, 0, sizeof(s_DevParam));
	s_DevParam.Windowed = bWindowed;
	s_DevParam.EnableAutoDepthStencil = TRUE;
	s_DevParam.SwapEffect = D3DSWAPEFFECT_DISCARD;
	s_DevParam.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;

	s_DevParam.PresentationInterval = s_Options.bVSyncEnabled
		? D3DPRESENT_INTERVAL_ONE
		: D3DPRESENT_INTERVAL_IMMEDIATE;

	D3DFORMAT BBFormat = D3DFMT_UNKNOWN;
	if (bWindowed) // 윈도우 모드일 경우
	{
		D3DDISPLAYMODE dm;
		m_lpD3D->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dm);
		s_DevParam.BackBufferCount = 1;

		if (dwWidth <= 0)
			dwWidth = dm.Width;

		if (dwHeight <= 0)
			dwHeight = dm.Height;

		BBFormat = dm.Format;
		s_DevParam.hDeviceWindow = s_hWndBase;
	}
	else
	{
		s_DevParam.BackBufferCount = 1;
		s_DevParam.AutoDepthStencilFormat = D3DFMT_D16; // 자동 생성이면 무시된다.

		if (16 == dwBPP)
			BBFormat = D3DFMT_R5G6B5;
		else if (24 == dwBPP)
			BBFormat = D3DFMT_R8G8B8;
		else if (32 == dwBPP)
			BBFormat = D3DFMT_X8R8G8B8;

		s_DevParam.hDeviceWindow = s_hWndBase;
	}

	s_DevParam.BackBufferWidth = dwWidth;
	s_DevParam.BackBufferHeight = dwHeight;
	s_DevParam.BackBufferFormat = BBFormat;
	s_DevParam.MultiSampleType = D3DMULTISAMPLE_NONE; // Swap Effect 가 Discard 형태가 아니면 반드시 이런 식이어야 한다.
	s_DevParam.Flags = 0;
//#ifdef _N3TOOL
	s_DevParam.Flags = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
//#endif // end of _N3TOOL

	int nMC = m_DeviceInfo.nModeCount;
	for(int i = 0; i < nMC; i++)
	{
//		if(	m_DeviceInfo.pModes[i].Width == dwWidth && 
//			m_DeviceInfo.pModes[i].Height == dwHeight && 
		if(	m_DeviceInfo.pModes[i].Format == BBFormat) // 모드가 일치하면
		{
			this->FindDepthStencilFormat(0, m_DeviceInfo.DevType, m_DeviceInfo.pModes[i].Format, &s_DevParam.AutoDepthStencilFormat); // 깊이와 스텐실 버퍼를 찾는다.
			m_nModeActive = i;
			break;
		}
	}

	HRESULT rval = m_lpD3D->CreateDevice(0, DevType, s_hWndBase, D3DCREATE_HARDWARE_VERTEXPROCESSING, &s_DevParam, &s_lpD3DDev);
	if(rval != D3D_OK)
	{
		rval = m_lpD3D->CreateDevice(0, DevType, s_hWndBase, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &s_DevParam, &s_lpD3DDev);
		if(rval != D3D_OK)
		{
			MessageBox(s_hWndBase, "Can't create D3D Device - please, check DirectX or display card driver", "initialization", MB_OK);
#ifdef _N3GAME
			CLogWriter::Write("Can't create D3D Device - please, check DirectX or display card driver");
			CLogWriter::Write(DXGetErrorStringA(rval));
#endif
//			{ for(int iii = 0; iii < 3; iii++) Beep(2000, 200); Sleep(300); } // 여러번 삑~

			this->Release();
			return false;
		}
#ifdef _N3GAME
		CLogWriter::Write("CNEng::Init - Not supported HardWare TnL");
#endif
	}


	// Device 지원 항목은??
	// DXT 지원 여부..
	s_dwTextureCaps = 0;
	s_DevCaps.DeviceType = DevType;

	s_lpD3DDev->GetDeviceCaps(&s_DevCaps);
	if(s_DevCaps.MaxTextureWidth < 256 || s_DevCaps.MaxTextureHeight < 256) // 텍스처 지원 크기가 256 이하면.. 아예 포기..
	{
		MessageBox(s_hWndBase, "Can't support this graphic card : Texture size is too small", "Initialization error", MB_OK);
#ifdef _N3GAME
		CLogWriter::Write("Can't support this graphic card : Texture size is too small");
#endif
//		{ for(int iii = 0; iii < 4; iii++) Beep(2000, 200); Sleep(300); } // 여러번 삑~

		this->Release();
		return false;
	}

	if(D3D_OK == m_lpD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, DevType, BBFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT1)) s_dwTextureCaps |= TEX_CAPS_DXT1;
	if(D3D_OK == m_lpD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, DevType, BBFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT2)) s_dwTextureCaps |= TEX_CAPS_DXT2;
	if(D3D_OK == m_lpD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, DevType, BBFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT3)) s_dwTextureCaps |= TEX_CAPS_DXT3;
	if(D3D_OK == m_lpD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, DevType, BBFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT4)) s_dwTextureCaps |= TEX_CAPS_DXT4;
	if(D3D_OK == m_lpD3D->CheckDeviceFormat(D3DADAPTER_DEFAULT, DevType, BBFormat, 0, D3DRTYPE_TEXTURE, D3DFMT_DXT5)) s_dwTextureCaps |= TEX_CAPS_DXT5;
	if(s_DevCaps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY) s_dwTextureCaps |= TEX_CAPS_SQUAREONLY;
	if(s_DevCaps.TextureCaps & D3DPTEXTURECAPS_MIPMAP) s_dwTextureCaps |= TEX_CAPS_MIPMAP;
	if(s_DevCaps.TextureCaps & D3DPTEXTURECAPS_POW2) s_dwTextureCaps |= TEX_CAPS_POW2;

	// 기본 뷰와 프로젝션 설정.
	this->LookAt(__Vector3(5,5,-10), __Vector3(0,0,0), __Vector3(0,1,0));
	this->SetProjection(0.1f, 256.0f, DegreesToRadians(45.0f), (float)dwHeight/dwWidth);
	
	RECT rcView = { 0, 0, (int)dwWidth, (int)dwHeight };
	this->SetViewPort(rcView);
	this->SetDefaultEnvironment(); // 기본 상태로 설정..

	return true;
}


/*
LRESULT WINAPI CN3Eng::MsgProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
        case WM_DESTROY:
//          PostQuitMessage( 0 );
            return 0;

        case WM_PAINT:
//          Render();
//          ValidateRect( hWnd, nullptr );
            return 0;
    }

    return DefWindowProc( hWnd, msg, wParam, lParam );
}
*/

BOOL CN3Eng::FindDepthStencilFormat(UINT iAdapter, D3DDEVTYPE DeviceType, D3DFORMAT TargetFormat, D3DFORMAT* pDepthStencilFormat)
{
	int nDSC = 6;
	D3DFORMAT DepthFmts[] = { D3DFMT_D32, D3DFMT_D24S8, D3DFMT_D24X4S4, D3DFMT_D24X8, D3DFMT_D16, D3DFMT_D15S1};

	HRESULT rval = 0;
	for(int i = 0; i < nDSC; i++)
	{
		rval = m_lpD3D->CheckDeviceFormat(iAdapter, DeviceType, TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, DepthFmts[i]);
		if(D3D_OK == rval)
		{
			rval = m_lpD3D->CheckDepthStencilMatch(iAdapter, DeviceType, TargetFormat, TargetFormat, DepthFmts[i]);
			if(D3D_OK == rval)
			{
				*pDepthStencilFormat = DepthFmts[i];
				return TRUE;
			}
		}
	}

    return FALSE;
}


#ifndef _N3TOOL
void CN3Eng::Present(HWND hWnd, RECT* pRC)
{
	RECT rc;
	if (s_DevParam.Windowed) // 윈도우 모드면...
	{
		GetClientRect(s_hWndBase, &rc);
		pRC = &rc;
	}

	HRESULT rval = s_lpD3DDev->Present(pRC, pRC, hWnd, nullptr);
	if (D3D_OK == rval)
	{
		s_hWndPresent = hWnd; // Present window handle 을 저장해 놓는다.
	}
	else if (D3DERR_DEVICELOST == rval
		|| D3DERR_DEVICENOTRESET == rval)
	{
		rval = s_lpD3DDev->Reset(&s_DevParam);

		if (D3D_OK != rval)
		{
#ifdef _N3GAME
			const char* szErr = DXGetErrorStringA(rval);

			// NOTE: Officially it's ErrCode(%d) but this is horrendously useless
			CLogWriter::Write("Device Present ErrCode({:X}) : {}", rval, szErr);
#endif

			WaitForDeviceRestoration();
		}

		rval = s_lpD3DDev->Present(pRC, pRC, hWnd, nullptr);
	}
	else
	{
#ifdef _N3GAME
//		CLogWriter::Write("CNEng::Present - device present failed ({})", DXGetErrorStringA(rval));
//		Beep(2000, 50);
#endif
	}

	////////////////////////////////////////////////////////////////////////////////
	// 프레임 율 측정...
	s_fSecPerFrm = CN3Base::TimerProcess(TIMER_GETELAPSEDTIME);

	// 너무 안나오면 기본 값인 30 프레임으로 맞춘다..
	if (s_fSecPerFrm <= 0.001f
		|| s_fSecPerFrm >= 1.0f)
		s_fSecPerFrm = 0.033333f;

	s_fFrmPerSec = 1.0f / s_fSecPerFrm; // 초당 프레임 수 측정..

//	fTimePrev = fTime;
	// 프레임 율 측정...
	////////////////////////////////////////////////////////////////////////////////
}
#else // _N3TOOL
void CN3Eng::Present(HWND hWnd, RECT* pRC)
{
	RECT rc;
	if(s_DevParam.Windowed)
	{
		GetClientRect(hWnd, &rc);
		pRC = &rc;
	}

	HRESULT rval = s_lpD3DDev->Present(pRC, pRC, hWnd, nullptr);
	if (D3D_OK == rval)
	{
		s_hWndPresent = hWnd; // Present window handle 을 저장해 놓는다.
	}
	else if (D3DERR_DEVICELOST == rval
		|| D3DERR_DEVICENOTRESET == rval)
	{
		rval = s_lpD3DDev->Reset(&s_DevParam);
		if (D3D_OK != rval)
			WaitForDeviceRestoration();

		rval = s_lpD3DDev->Present(pRC, pRC, hWnd, nullptr);
	}

	s_fSecPerFrm = CN3Base::TimerProcess(TIMER_GETELAPSEDTIME);

	// 너무 안나오면 기본 값인 30 프레임으로 맞춘다..
	if (s_fSecPerFrm <= 0.001f
		|| s_fSecPerFrm >= 1.0f)
		s_fSecPerFrm = 0.033333f;

	s_fFrmPerSec = 1.0f / s_fSecPerFrm; // 초당 프레임 수 측정..
}
#endif

void CN3Eng::WaitForDeviceRestoration()
{
	while (true)
	{
		HRESULT rval = s_lpD3DDev->TestCooperativeLevel();

		if (D3DERR_DEVICENOTRESET == rval
			|| D3D_OK == rval)
		{
			if (D3D_OK == s_lpD3DDev->Reset(&s_DevParam))
			{
#ifdef _N3GAME
				const char* szErr = DXGetErrorStringA(rval);

				// NOTE: Officially it's ErrCode(%d) but this is horrendously useless
				CLogWriter::Write("Device Reset Success ErrCode({:X}) : {}", rval, szErr);
#endif
				SetDefaultEnvironment();
				break;
			}

#ifdef _N3GAME
			const char* szErr = DXGetErrorStringA(rval);

			// NOTE: Officially it's ErrCode(%d) but this is horrendously useless
			CLogWriter::Write("Device Reset Failed - ErrCode(:X) : {}", rval, szErr);
#endif
		}

		MSG msg = {};
		while (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		Sleep(2000);
	}
}

void CN3Eng::Clear(D3DCOLOR crFill, RECT* pRC)
{
	RECT rc;
	if (pRC == nullptr
		&& s_DevParam.Windowed) // 윈도우 모드면...
	{
		GetClientRect(s_hWndBase, &rc);
		pRC = &rc;
	}

	if (pRC != nullptr)
	{
		_D3DRECT rc3D = { pRC->left, pRC->top, pRC->right, pRC->bottom };
		s_lpD3DDev->Clear(1, &rc3D, D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET, crFill, 1.0f, 0);
	}
	else
	{
		s_lpD3DDev->Clear(0, nullptr, D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET, crFill, 1.0f, 0);
	}

#ifdef _DEBUG
	memset(&s_RenderInfo, 0, sizeof(__RenderInfo));
#endif
}

void CN3Eng::ClearAuto(RECT* pRC)
{
	DWORD dwFillColor = D3DCOLOR_ARGB(255,192,192,192); // 기본색
	DWORD dwUseFog = FALSE;
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwUseFog); // 안개를 쓰면 바탕색을 안개색을 깔아준다..
	if(dwUseFog != 0) s_lpD3DDev->GetRenderState(D3DRS_FOGCOLOR, &dwFillColor);
	else
	{
		CN3Light::__Light Lgt;

		BOOL bEnable;
		s_lpD3DDev->GetLightEnable(0, &bEnable);
		if(bEnable)
		{
			s_lpD3DDev->GetLight(0, Lgt.toD3D());
			dwFillColor = D3DCOLOR_ARGB((uint8_t)(Lgt.Diffuse.a * 255.0f), (uint8_t)(Lgt.Diffuse.r * 255.0f), (uint8_t)(Lgt.Diffuse.g * 255.0f), (uint8_t)(Lgt.Diffuse.b * 255.0f));
		}
	}

	CN3Eng::Clear(dwFillColor, pRC);
}

void CN3Eng::ClearZBuffer(const RECT* pRC)
{
	RECT rc;
	if (pRC == nullptr
		&& s_DevParam.Windowed) // 윈도우 모드면...
	{
		GetClientRect(s_hWndBase, &rc);
		pRC = &rc;
	}

	if (pRC != nullptr) 
	{
		D3DRECT rc3D = { pRC->left, pRC->top, pRC->right, pRC->bottom };
		s_lpD3DDev->Clear(1, &rc3D, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
	}
	else
	{
		s_lpD3DDev->Clear(0, nullptr, D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
	}
}

// ===== END N3Base/N3Eng.cpp =====

// ===== BEGIN N3Base/N3Eng.h =====
#line 1 "N3Base/N3Eng.h"
﻿#ifndef __N3ENG_H_
#define __N3ENG_H_

#include "ddraw.h"
#include "N3Base.h"
#include "N3BaseFileAccess.h"

//-----------------------------------------------------------------------------
/*!
This class is used for initializing and configuring DirectX
*/
class CN3Eng : public CN3Base
{
public:
	typedef struct __D3DDEV_INFO
	{
		char szDeviceName[128];
		char szDeviceDesc[128];
		int  nAdapter;
		int  nDevice;
		
		D3DDEVTYPE      DevType;
		int             nModeCount;
		D3DDISPLAYMODE* pModes;
	} __D3DDevInfo;

protected:
	int           m_nModeActive;
	int           m_nAdapterCount;
	__D3DDEV_INFO m_DeviceInfo;

public:
	LPDIRECT3D9  m_lpD3D;
	LPDIRECTDRAW m_lpDD;

public:
	void Release();
	void SetViewPort(RECT& pRC);
	static void SetDefaultEnvironment();
	void LookAt(const __Vector3& vEye, const __Vector3& vAt, const __Vector3& vUp);
	bool Reset(bool bWindowed, uint32_t dwWidth, uint32_t dwHeight, uint32_t dwBPP);
	void SetProjection(float fNear, float fFar, float fLens, float fAspect);

	static void ClearAuto(RECT* pRC = nullptr);
	static void ClearZBuffer(const RECT* pRC = nullptr);
	static void Clear(D3DCOLOR crFill, RECT* pRC = nullptr);
	static void Present(HWND hWnd, RECT* pRC = nullptr);
	static void WaitForDeviceRestoration();

	bool Init(
		BOOL bWindowed,
		HWND hWnd,
		uint32_t dwWidth,
		uint32_t dwHeight,
		uint32_t dwBPP,
		BOOL bUseHW);

	BOOL FindDepthStencilFormat(
		UINT iAdapter,
		D3DDEVTYPE DeviceType,
		D3DFORMAT TargetFormat,
		D3DFORMAT* pDepthStencilFormat);

public:
	CN3Eng(void);
	virtual ~CN3Eng(void);
};

#endif

// ===== END N3Base/N3Eng.h =====

// ===== BEGIN N3Base/N3EngTool.cpp =====
#line 1 "N3Base/N3EngTool.cpp"
﻿// N3EngTool.cpp: implementation of the CN3EngTool class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Light.h"
#include "N3EngTool.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3EngTool::CN3EngTool()
{
	// ½ÊÀÚ¼± »ý¼º..
	int i = 0;
	for(i = -10; i < 10; i++)
	{
		m_VAxis[ 0 + i + 10].Set(i * 500.0f, 0, 0, 0xffff0000); // X
		m_VAxis[20 + i + 10].Set(0, i * 500.0f, 0, 0xff00ff00); // Y
		m_VAxis[40 + i + 10].Set(0, 0, i * 500.0f, 0xff0000ff); // Z
	}

	m_VDir[0].Set(10, 0, 0, 0xffff0000);
	m_VDir[1].Set(7, 3, 0, 0xffff0000);

	m_VDir[2].Set(0, 10, 0, 0xff00ff00);
	m_VDir[3].Set(0, 7, -3, 0xff00ff00);

	m_VDir[4].Set(0, 0, 10, 0xff0000ff);
	m_VDir[5].Set(0, 3, 7, 0xff0000ff);
	
	m_pVGrids = nullptr;
	m_nGridLineCount = 0;
	
//	m_lpD3DDevExtra = nullptr;
}

CN3EngTool::~CN3EngTool()
{
	delete [] m_pVGrids; m_pVGrids = nullptr;
//	if(m_lpD3DDevExtra) m_lpD3DDevExtra->Release();
//	m_lpD3DDevExtra = nullptr;
}

// ¿ùµå Ãà ±×¸®±â..
void CN3EngTool::RenderGrid(const __Matrix44& mtxWorld)
{
	DWORD dwAlpha, dwFog, dwLight;
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	
	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	
	static __Material smtl;
	static bool bInit = false;
	if(false == bInit)
	{
		smtl.Init();
		bInit = true;
	}

	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D());
	s_lpD3DDev->SetTexture(0, nullptr);

	s_lpD3DDev->SetFVF(FVF_CV); //s_lpD3DDev->SetVertexShader(FVF_CV);

	if(m_pVGrids) // ±×¸®µå ±×¸®±â..
	{
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, m_nGridLineCount, m_pVGrids, sizeof(__VertexColor)); // X
	}

	// Ãà ±×¸®±â..
//	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[0], sizeof(__VertexColor)); // X
//	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[20], sizeof(__VertexColor)); // Y
//	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[40], sizeof(__VertexColor)); // Z

	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
}

void CN3EngTool::RenderAxis(bool bShowDir)
{
	DWORD dwAlpha, dwFog, dwLight;
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	
	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	
	static __Matrix44 stm;
	static __Material smtl;
	static bool bInit = false;
	if(false == bInit)
	{
		stm.Identity();
		smtl.Init();
		bInit = true;
	}

	s_lpD3DDev->SetTransform(D3DTS_WORLD, stm.toD3D());
	s_lpD3DDev->SetTexture(0, nullptr);

	s_lpD3DDev->SetFVF(FVF_CV); //s_lpD3DDev->SetVertexShader(FVF_CV);

	// Ãà ±×¸®±â..
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[0], sizeof(__VertexColor)); // X
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[20], sizeof(__VertexColor)); // Y
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 19, &m_VAxis[40], sizeof(__VertexColor)); // Z

	if(bShowDir) s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 3, &m_VDir[0], sizeof(__VertexColor)); // Z

	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
}


//
// pTex==NULLÀÏ¶§ °ËÁ¤»öÀ» Âï±â À§ÇØ ¼öÁ¤ÇßÀ½...by lynus 2001. 12. 7.
//
void CN3EngTool::RenderTexturePreview(CN3Texture *pTex, HWND hWndDiffuse, RECT* pRCSrc)
{
	//if(pTex == nullptr) return;
	if(hWndDiffuse == nullptr) return;
	
	if(pTex == nullptr)
	{
		RECT rcPreview;
		::GetClientRect(hWndDiffuse, &rcPreview);

		int nW = rcPreview.right - rcPreview.left;
		int nH = rcPreview.bottom - rcPreview.top;

		D3DRECT rcClear = { rcPreview.left, rcPreview.top, rcPreview.right, rcPreview.bottom };
		s_lpD3DDev->Clear(1, &rcClear, D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET, D3DCOLOR_ARGB(255,64,64,64), 1.0f, 0);

		RECT rcTex = rcPreview;
		float fRatioDest = (float)nW / (float)nH;
		
		if(fRatioDest > 1.0f) // °¡·Î°¡ ±ä°æ¿ì
		{
			int nDec = (nW - nH) / 2;
			rcTex.left += nDec;
			rcTex.right -= nDec;
		}
		else if(fRatioDest < 1.0f) // ¼¼·Î°¡ ±ä°æ¿ì
		{
			int nDec = (nH - nW) / 2;
			rcTex.top += nDec;
			rcTex.bottom -= nDec;
		}

		float fU_Left = 0.0f, fV_Top = 0.0f, fU_Right = 1.0f, fV_Bottom = 1.0f; // ±âº» UV ÁÂÇ¥
	
		s_lpD3DDev->BeginScene();

		m_VPreview[0].Set((float)rcTex.left, (float)rcTex.top, 0.5f, 1.0f, 0xff000000, fU_Left, fV_Top);
		m_VPreview[1].Set((float)rcTex.right, (float)rcTex.top, 0.5f, 1.0f, 0xff000000, fU_Right, fV_Top);
		m_VPreview[2].Set((float)rcTex.right, (float)rcTex.bottom, 0.5f, 1.0f, 0xff000000, fU_Right, fV_Bottom);
		m_VPreview[3] = m_VPreview[0];
		m_VPreview[4] = m_VPreview[2];
		m_VPreview[5].Set((float)rcTex.left, (float)rcTex.bottom, 0.5f, 1.0f, 0xff000000, fU_Left, fV_Bottom);

		s_lpD3DDev->SetTexture(0, nullptr);
		DWORD ColorOP;
		s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &ColorOP);

		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);		

		s_lpD3DDev->SetFVF(FVF_TRANSFORMED); //s_lpD3DDev->SetVertexShader(FVF_TRANSFORMED);
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 2, &m_VPreview, sizeof(__VertexTransformed));

		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, ColorOP);

		s_lpD3DDev->EndScene();
		s_lpD3DDev->Present(&rcPreview, &rcPreview, hWndDiffuse, nullptr);
		return;
	}
	
//	if(hWndDiffuse != nullptr)
	{
		// ÅØ½ºÃ³ ÇÁ¸®ºä
		RECT rcPreview;
		HRESULT hr;
		::GetClientRect(hWndDiffuse, &rcPreview);

		int nW = rcPreview.right - rcPreview.left;
		int nH = rcPreview.bottom - rcPreview.top;

		D3DRECT rcClear = { rcPreview.left, rcPreview.top, rcPreview.right, rcPreview.bottom };
		hr = s_lpD3DDev->Clear(1, &rcClear, D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET, D3DCOLOR_ARGB(255,64,64,64), 1.0f, 0);

		if(pTex->Get() != nullptr)
		{
			RECT rcTex = rcPreview;
			float fRatioDest = (float)nW / (float)nH;
			float fRatioSrc = (float)(pTex->Width()) / (float)(pTex->Height());

			if(fRatioDest > 1.0f) // °¡·Î°¡ ±ä°æ¿ì
			{
				int nDec = (nW - nH) / 2;
				rcTex.left += nDec;
				rcTex.right -= nDec;
			}
			else if(fRatioDest < 1.0f) // ¼¼·Î°¡ ±ä°æ¿ì
			{
				int nDec = (nH - nW) / 2;
				rcTex.top += nDec;
				rcTex.bottom -= nDec;
			}


			float fU_Left = 0.0f, fV_Top = 0.0f, fU_Right = 1.0f, fV_Bottom = 1.0f; // ±âº» UV ÁÂÇ¥
			// ¸¸¾à Rect °¡ ÀÖÀ¸¸é..
			if(pRCSrc)
			{
				float fW = (float)(pTex->Width());
				float fH = (float)(pTex->Height());

				fU_Left = pRCSrc->left / fW;
				fV_Top = pRCSrc->top / fH;
				fU_Right = pRCSrc->right / fW;
				fV_Bottom = pRCSrc->bottom / fH;
			}


			s_lpD3DDev->BeginScene();

			m_VPreview[0].Set((float)rcTex.left, (float)rcTex.top, 0.5f, 1.0f, 0xffffffff, fU_Left, fV_Top);
			m_VPreview[1].Set((float)rcTex.right, (float)rcTex.top, 0.5f, 1.0f, 0xffffffff, fU_Right, fV_Top);
			m_VPreview[2].Set((float)rcTex.right, (float)rcTex.bottom, 0.5f, 1.0f, 0xffffffff, fU_Right, fV_Bottom);
			m_VPreview[3] = m_VPreview[0];
			m_VPreview[4] = m_VPreview[2];
			m_VPreview[5].Set((float)rcTex.left, (float)rcTex.bottom, 0.5f, 1.0f, 0xffffffff, fU_Left, fV_Bottom);

			DWORD dwAlpha, dwFog, dwLight;
			s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
			s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
			s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);

			if(	pTex->PixelFormat() != D3DFMT_DXT1 && 
				pTex->PixelFormat() != D3DFMT_X8R8G8B8 )
			{
				hr = s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
				hr = s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA);
				hr = s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA);
			}
			hr = s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
			hr = s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);

			hr = s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			hr = s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
			hr = s_lpD3DDev->SetTexture(0, pTex->Get());

			hr = s_lpD3DDev->SetFVF(FVF_TRANSFORMED);//s_lpD3DDev->SetVertexShader(FVF_TRANSFORMED);
			hr = s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 2, &m_VPreview, sizeof(__VertexTransformed));

			hr = s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
			hr = s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
			hr = s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
			
			hr = s_lpD3DDev->EndScene();
		}
		
		hr = s_lpD3DDev->Present(&rcPreview, &rcPreview, hWndDiffuse, nullptr);
	}
}


void CN3EngTool::GridCreate(int nWidth, int nHeight)
{
	if(nWidth <= 0 || nHeight <= 0) return;

	delete [] m_pVGrids;
	m_nGridLineCount = (nWidth+1) + (nHeight+1);
	m_pVGrids = new __VertexColor[m_nGridLineCount * 2];

	// ±×¸®µå »ý¼º..
	D3DCOLOR GridColor = 0xff808080;
	int xx = nWidth/2, zz = nHeight/2;
	int nSeq = 0;
	for(int x = -xx; x <= xx; x++)
	{
		m_pVGrids[nSeq++].Set((float)x, 0, (float) zz, GridColor);
		m_pVGrids[nSeq++].Set((float)x, 0, (float)-zz, GridColor);
	}
	for(int z = -zz; z <= zz; z++)
	{
		m_pVGrids[nSeq++].Set((float) xx, 0, (float)z, GridColor);
		m_pVGrids[nSeq++].Set((float)-xx, 0, (float)z, GridColor);
	}
}

// ===== END N3Base/N3EngTool.cpp =====

// ===== BEGIN N3Base/N3EngTool.h =====
#line 1 "N3Base/N3EngTool.h"
﻿// N3EngTool.h: interface for the CN3EngTool class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_D3DENGINETEST_H__4DE7DD27_A9BC_43C5_9D67_E99031ED38B5__INCLUDED_)
#define AFX_D3DENGINETEST_H__4DE7DD27_A9BC_43C5_9D67_E99031ED38B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Eng.h"

struct __EXPORT_OPTION
{
	char szID[8];		// ID "N3Scene1"
	char szRemark[64];	// 설명..
	
	int nNodeCount; // 전체 노드 카운트
	
	BOOL	bAnimationKey; 
	int		nFrmStart;	// 에니메이션 시작 프레임 
	int		nFrmEnd;	// 에니메이션 끝 프레임
	float	fSamplingRate; // Key Sampling - 30.0f 가 표준..

	D3DCOLORVALUE dcvBackground;	// 배경 색
	D3DCOLORVALUE dcvAmbientLight;	// 기본 조명 색

//	int nCameraCount;	// scene 내의 카메라 갯수
//	int nMaterialCount;	// scene 내의 재질 갯수
//	int nTextureCount;	// scene 내의 텍스처 갯수
//	int nLightCount;	// scene 내의 조명 갯수

	BOOL bExportCamera;	// 카메라 데이터를 갖고 있다.
	BOOL bExportLight;		// 라이트 데이터를 갖고 있다.
	BOOL bExportGeometry;	// 지오메트리 데이터를 갖고 있다.
	BOOL bExportDummy;	// 도우미 오브젝트(??? - 실제 겜에서는 필요없고 개발시에만 필요한 오브젝트를 말한다)데이터를 갖고 있다. 
	BOOL bExportCharacter;	// 도우미 오브젝트(??? - 실제 겜에서는 필요없고 개발시에만 필요한 오브젝트를 말한다)데이터를 갖고 있다. 
	
	BOOL bExportSelectedOnly; // 선택된 것만 ???

	BOOL bGenerateFileName; // 파일 이름을 0_0000_00_0 포맷으로 바꾼다..??
	BOOL bGenerateSmoothNormal; // 부드럽게 보이도록 법선 벡터들을 재 계산한다.
//	BOOL bGenerateProgressiveMesh; // Progressive Mesh 생성
	BOOL bGenerateHalfSizeTexture; // 텍스처 파일을 자동으로 최적화 시켜서 생성 Direct3D 의 포맷에 맞게 2의 제곱수 단위로 맞추어서 "OBM" 비트맵 파일로 저장.
	BOOL bGenerateCompressedTexture; // Texture 압축 사용

	char szSubDir[_MAX_DIR];		// export 할때 저장하는 sub폴더를 지정해준다.
};

class CN3EngTool : public CN3Eng  
{
public:
	int					m_nGridLineCount; // 그리드 라인 카운트..
	__VertexColor*		m_pVGrids; // 그리드 렌더링 용

	__VertexColor		m_VAxis[60]; // 축 렌더링 용
	__VertexColor		m_VDir[6]; // 방향 표시 용
	__VertexTransformed m_VPreview[6];	// 텍스처 프리뷰 용



//	LPDIRECT3DDEVICE8	m_lpD3DDevExtra;

public:
//	bool CreateExtraDevice(int nWidth, int nHeight);
	void GridCreate(int nWidth, int nHeight);
	void RenderTexturePreview(CN3Texture* pTex, HWND hDlgWndDiffuse, RECT* pRCSrc = nullptr);
	void RenderGrid(const __Matrix44& mtxWorld);
	void RenderAxis(bool bShowDir = false);

	CN3EngTool();
	virtual ~CN3EngTool();

};

#endif // !defined(AFX_D3DENGINETEST_H__4DE7DD27_A9BC_43C5_9D67_E99031ED38B5__INCLUDED_)

// ===== END N3Base/N3EngTool.h =====

// ===== BEGIN N3Base/N3FXBundle.cpp =====
#line 1 "N3Base/N3FXBundle.cpp"
﻿// N3FXBundle.cpp: implementation of the CN3FXBundle class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXBundle.h"
#include "N3FXPartParticles.h"
#include "N3FXPartBillBoard.h"
#include "N3FXPartMesh.h"
#include "N3FXPartBottomBoard.h"

#include "N3SndMgr.h"
#include "N3SndObj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

float CN3FXBundle::m_fEffectSndDist = 48.0f;

CN3FXBundle::CN3FXBundle()
{
	m_iVersion = SUPPORTED_BUNDLE_VERSION;
	m_strName.erase();
	for(int i=0;i<MAX_FX_PART;i++) m_pPart[i] = nullptr;
	m_fLife0 = 0.0f;
	
	m_dwState = FX_BUNDLE_STATE_DEAD;
	m_fLife = 0.0f;

	m_vPos.Set(0.0f, 0.0f, 0.0f);
	m_vDir.Set(0.0f, 0.0f, 1.0f);
	m_vDestPos.Set(0.0f, 0.0f, 0.0f);

	m_iMoveType = FX_BUNDLE_MOVE_NONE;
	m_fVelocity = 0.0f;
	
	m_iSourceID = 0;
	m_iTargetID = 0;
	m_iTargetJoint = 0;
	m_iSourceJoint = 0;

	m_bDependScale = false;

	//m_vTargetScale.Set(1,1,1);
	m_fTargetScale = 1.0f;

	m_bStatic = false;

	m_pSndObj = nullptr;
}

CN3FXBundle::~CN3FXBundle()
{
	m_strName.erase();

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i])
		{
			if(m_pPart[i]->pPart) { delete m_pPart[i]->pPart; m_pPart[i]->pPart = nullptr; }
			delete m_pPart[i];
			m_pPart[i] = nullptr;
		}
	}	

#ifdef _N3GAME
	if(m_pSndObj) CN3Base::s_SndMgr.ReleaseObj(&m_pSndObj);
#endif
}


//
//	decode script file..
//	스크립트 파일 읽고 해석시킴...
//
#ifdef _N3TOOL
bool CN3FXBundle::DecodeScriptFile(const char* lpPathName)
{
	FILE* stream = fopen(lpPathName, "r");
	if (stream == nullptr)
		return false;

	char szGamePathName[_MAX_PATH];
	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
	_splitpath(lpPathName, szDrive, szDir, szFName, szExt);
	_makepath(szGamePathName, szDrive, szDir, szFName, "fxb");

	CN3BaseFileAccess::FileNameSet(szGamePathName);

	char szLine[512] = "", szCommand[80] = "", szBuf[4][80] = { "", "", "", "" };
	char* pResult = fgets(szLine, 512, stream);
	int argsScanned = sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
	if (argsScanned <= 0)
	{
		fclose(stream);
		return false;
	}

	if (lstrcmpi(szCommand, "<n3fxbundle>"))
	{
		fclose(stream);
		return false;
	}

	while (!feof(stream))
	{
		char* pResult = fgets(szLine, 512, stream);
		if (pResult == nullptr)
			continue;

		ZeroMemory(szCommand, 80);
		ZeroMemory(szBuf[0], 80);
		ZeroMemory(szBuf[1], 80);
		ZeroMemory(szBuf[2], 80);
		ZeroMemory(szBuf[3], 80);

		argsScanned = sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
		if (argsScanned <= 0)
			continue;

		if (lstrcmpi(szCommand, "<name>") == 0)
		{
			m_strName = szBuf[0];
			continue;
		}

		if (lstrcmpi(szCommand, "<part>") == 0)
		{
			//full path 만들기..	
			std::string szFullPath = fmt::format("{}{}", CN3Base::PathGet(), szBuf[0]);

			FXPARTWITHSTARTTIME* pPart = new FXPARTWITHSTARTTIME;
			pPart->fStartTime = static_cast<float>(atof(szBuf[1]));

			pPart->pPart = SetPart(szFullPath.c_str());

			if (pPart->pPart == nullptr)
			{
				delete pPart;
				continue;
			}

			for (int i = 0; i < MAX_FX_PART; i++)
			{
				if (m_pPart[i] == nullptr)
				{
					m_pPart[i] = pPart;
					break;
				}
			}

			continue;
		}

		if (lstrcmpi(szCommand, "<velocity>") == 0)
		{
			m_fVelocity = static_cast<float>(atof(szBuf[0]));
			continue;
		}

		if (lstrcmpi(szCommand, "<depend_scale>") == 0)
		{
			if (lstrcmpi(szBuf[0], "true") == 0)
				m_bDependScale = true;
			else
				m_bDependScale = false;

			continue;
		}

		if (lstrcmpi(szCommand, "<Static_Pos>") == 0)
		{
			if (lstrcmpi(szBuf[0], "true") == 0)
				m_bStatic = true;
			else
				m_bStatic = false;

			continue;
		}
	}

	fclose(stream);

	Init();

	return true;
}
#endif // end of _N3TOOL


//
//	GetPartType...
//	파트의 파일이름으로 타입을 알아내자..
//
#ifdef _N3TOOL
CN3FXPartBase* CN3FXBundle::SetPart(const char* pFileName)
{
	int PartType = FX_PART_TYPE_NONE;

	FILE* stream = fopen(pFileName, "r");
	if(!stream) return nullptr;
	
	char szLine[512] = "", szCommand[80] = "", szBuf[4][80] = { "", "", "", ""};
	char* pResult = fgets(szLine, 512, stream);
	sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
	
	if(lstrcmpi(szCommand, "<n3fxPart>"))
	{
		fclose(stream);
		return nullptr;
	}

	while(!feof(stream))
	{
		char* pResult = fgets(szLine, 512, stream);
		if(pResult == nullptr) continue;

		ZeroMemory(szCommand,80);
		ZeroMemory(szBuf[0],80);
		ZeroMemory(szBuf[1],80);
		ZeroMemory(szBuf[2],80);
		ZeroMemory(szBuf[3],80);
		sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);

		if(lstrcmpi(szCommand, "<type>")==0)
		{
			if(lstrcmpi(szBuf[0], "particle")==0) PartType = FX_PART_TYPE_PARTICLE;
			else if(lstrcmpi(szBuf[0], "board")==0) PartType = FX_PART_TYPE_BOARD;
			else if(lstrcmpi(szBuf[0], "mesh")==0) PartType = FX_PART_TYPE_MESH;
			else if(lstrcmpi(szBuf[0], "ground")==0) PartType = FX_PART_TYPE_BOTTOMBOARD;
			//^^v 더 넣을꺼 있으면 넣어라..
		}		
	}
	fclose(stream);

	CN3FXPartBase* pPart;
	if(PartType == FX_PART_TYPE_PARTICLE)
	{
		pPart = new CN3FXPartParticles;
		pPart->m_pRefBundle = this;
		pPart->m_pRefPrevPart = nullptr;						
		pPart->DecodeScriptFile(pFileName);
		return pPart;
	}
	else if(PartType == FX_PART_TYPE_BOARD)
	{
		pPart = new CN3FXPartBillBoard;
		pPart->m_pRefBundle = this;
		pPart->m_pRefPrevPart = nullptr;
		pPart->DecodeScriptFile(pFileName);
		return pPart;
	}
	else if(PartType == FX_PART_TYPE_MESH)
	{
		pPart = new CN3FXPartMesh;
		pPart->m_pRefBundle = this;
		pPart->m_pRefPrevPart = nullptr;
		pPart->DecodeScriptFile(pFileName);
		return pPart;
	}
	else if(PartType == FX_PART_TYPE_BOTTOMBOARD)
	{
		pPart = new CN3FXPartBottomBoard;
		pPart->m_pRefBundle = this;
		pPart->m_pRefPrevPart = nullptr;
		pPart->DecodeScriptFile(pFileName);
		return pPart;
	}
	return nullptr;
}
#endif // end of _N3TOOL


//
//	Init..
//
void CN3FXBundle::Init()
{
	m_fLife = 0.0f;
	m_dwState = FX_BUNDLE_STATE_DEAD;
	
	m_vPos.Set(0.0f, 0.0f, 0.0f);
	m_vDir.Set(0.0f, 0.0f, 1.0f);

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart)
		{
			m_pPart[i]->pPart->Init();
		}
	}
}

int CN3FXBundle::GetPartCountForVersion() const
{
	if (m_iVersion < 0)
		return 0;

	if (m_iVersion == 0)
		return MAX_FX_PART_V0;
	
	return MAX_FX_PART_V1;
}

//
//
//
bool CN3FXBundle::Load(File& file)
{
	file.Read(&m_iVersion, sizeof(int));

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iVersion > SUPPORTED_BUNDLE_VERSION)
	{
		TRACE("!!! WARNING: CN3FXBundle::Load(%s) encountered bundle version %d. Needs support!",
			FileName().c_str(), m_iVersion);
	}
#endif

	file.Read(&m_fLife0, sizeof(float));
	if (m_fLife0 > 10.0f)
		m_fLife0 = 10.0f;

	file.Read(&m_fVelocity, sizeof(float));
	file.Read(&m_bDependScale, sizeof(bool));

	const int iPartCount = GetPartCountForVersion();
	for (int i = 0; i < MAX_FX_PART; i++)
	{
		int iType = FX_PART_TYPE_NONE;
		file.Read(&iType, sizeof(int));

		if (iType == FX_PART_TYPE_NONE)
			continue;

		CN3FXPartBase* part = AllocatePart(iType);
		if (part == nullptr)
		{
			TRACE("!!! WARNING: CN3FXBundle::Load(%s) encountered invalid part type %d at index %d. Ending parsing here.",
				FileName().c_str(), iType, i);
			break;
		}

		float fStartTime = 0.0f;
		file.Read(&fStartTime, sizeof(float));

		m_pPart[i] = new FXPARTWITHSTARTTIME;
		m_pPart[i]->fStartTime = fStartTime;
		m_pPart[i]->pPart = part;
		m_pPart[i]->pPart->m_pRefBundle = this;
		m_pPart[i]->pPart->m_pRefPrevPart = nullptr;
		m_pPart[i]->pPart->m_iType = iType;
		m_pPart[i]->pPart->Load(file);
	}

	if (m_iVersion >= 2)
		file.Read(&m_bStatic, sizeof(bool));

	return true;
}

CN3FXPartBase* CN3FXBundle::AllocatePart(int iPartType) const
{
	switch (iPartType)
	{
		case FX_PART_TYPE_PARTICLE:
			return new CN3FXPartParticles();

		case FX_PART_TYPE_BOARD:
			return new CN3FXPartBillBoard();

		case FX_PART_TYPE_MESH:
			return new CN3FXPartMesh();

		case FX_PART_TYPE_BOTTOMBOARD:
			return new CN3FXPartBottomBoard();

		default:
			return nullptr;
	}
}

//
//
//
bool CN3FXBundle::Save(File& file)
{
	file.Write(&m_iVersion, sizeof(int));
	file.Write(&m_fLife0, sizeof(float));
	file.Write(&m_fVelocity, sizeof(float));

	file.Write(&m_bDependScale, sizeof(bool));

	for (int i = 0; i < MAX_FX_PART; i++)
	{
		if (m_pPart[i] != nullptr
			&& m_pPart[i]->pPart != nullptr)
		{
			file.Write(&m_pPart[i]->pPart->m_iType, sizeof(int));
			file.Write(&m_pPart[i]->fStartTime, sizeof(float));
			m_pPart[i]->pPart->Save(file);
		}
		else
		{
			int Type = FX_PART_TYPE_NONE;
			file.Write(&Type, sizeof(int));
		}
	}

	file.Write(&m_bStatic, sizeof(bool));

	return true;
}


//
//	Tick...
//
bool CN3FXBundle::Tick()
{
	if(m_dwState==FX_BUNDLE_STATE_DEAD) return false;

	m_fLife += CN3Base::s_fSecPerFrm;

	if(m_dwState==FX_BUNDLE_STATE_DYING || m_dwState==FX_BUNDLE_STATE_LIVE)
	{
		if(CheckAllPartsDead() || (m_fLife0 !=0.0f && m_fLife > m_fLife0) )
		{
			m_dwState = FX_BUNDLE_STATE_DEAD;
			Init();
			return false;
		}
	}

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart)
		{
			if(m_pPart[i]->fStartTime <= m_fLife && m_pPart[i]->pPart->m_dwState==FX_PART_STATE_READY)
			{
				m_pPart[i]->pPart->Start();
			}
			m_pPart[i]->pPart->Tick();

		}
	}
	return true;
}

//
//	Render...
//
void CN3FXBundle::Render()
{
	if(m_dwState==FX_BUNDLE_STATE_DEAD) return;

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart &&
			(m_pPart[i]->pPart->m_dwState!=FX_PART_STATE_DEAD) &&
			(m_pPart[i]->pPart->m_dwState!=FX_PART_STATE_READY) )
		{
			m_pPart[i]->pPart->Render();
		}
	}
}

//
//	Trigger...
//
void CN3FXBundle::Trigger(int iSourceID, int iTargetID, int iTargetJoint, int iSndID)
{
	m_dwState = FX_BUNDLE_STATE_LIVE;
	
	m_iSourceID = iSourceID;
	m_iTargetID = iTargetID;
	m_iTargetJoint = iTargetJoint;

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart)
		{
			m_pPart[i]->pPart->m_dwState = FX_PART_STATE_READY;
		}
	}

#ifdef _N3GAME
	if(iSndID>=0)
	{
		float fDist = (s_CameraData.vEye - m_vPos).Magnitude();
//		if(fDist < 48.0f)
		if(fDist < m_fEffectSndDist) //this_Snd
			CN3Base::s_SndMgr.PlayOnceAndRelease(iSndID, &m_vPos);
	}

//	if(iSndID >= 0 && nullptr == m_pSndObj)
//		m_pSndObj = CN3Base::s_SndMgr.CreateObj(iSndID);
//	if(m_pSndObj) m_pSndObj->Play(&m_vPos);

#endif
}


//
//	Stop...
//	멈추는 단계를 시작한다..
//	정말 멈추는 기능은 tick에서 모든 파트가 다 죽었다고 판단될때 tick에서 수행한다.
//
void CN3FXBundle::Stop(bool immediately)
{
	if(m_dwState == FX_BUNDLE_STATE_DEAD) return;

	if(!immediately)
	{
		m_dwState = FX_BUNDLE_STATE_DYING;
		for(int i=0;i<MAX_FX_PART;i++)
		{
			if(m_pPart[i] && m_pPart[i]->pPart)
			{
				m_pPart[i]->pPart->Stop();
			}
		}
	}
	else
	{
		m_dwState = FX_BUNDLE_STATE_DYING;
		Init();
	}
}


//
//	check all parts are dead..
//	if dead return true..
//
bool CN3FXBundle::CheckAllPartsDead()
{
	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart)
		{
			if(m_pPart[i]->pPart->m_dwState != FX_PART_STATE_DEAD) return false;
		}
	}
	return true;
}

CN3FXPartBase* CN3FXBundle::GetPart(int i)
{
	if(i<0 || i>=MAX_FX_PART) return nullptr;

	if(m_pPart[i]) return m_pPart[i]->pPart;

	return nullptr;
}

float CN3FXBundle::GetPartSTime(int i)
{
	if(i<0 || i>=MAX_FX_PART) return -1.0f;

	if(m_pPart[i]) return m_pPart[i]->fStartTime;

	return -1.0f;
}

void CN3FXBundle::SetPartSTime(int i, float time)
{
	if(i<0 || i>=MAX_FX_PART) return;

	if(m_pPart[i]) m_pPart[i]->fStartTime = time;
	return;
}

void CN3FXBundle::Duplicate(CN3FXBundle* pDestBundle)
{
	pDestBundle->FileNameSet(this->FileName());

	pDestBundle->m_iVersion = m_iVersion;
	pDestBundle->m_fLife0 = m_fLife0;
	
	pDestBundle->m_fVelocity = m_fVelocity;
	pDestBundle->m_bDependScale = m_bDependScale;
	pDestBundle->m_bStatic = pDestBundle->m_bStatic;

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i])
		{
			if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_PARTICLE)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartParticles;
				CN3FXPartParticles* pPart = (CN3FXPartParticles*)pDestBundle->m_pPart[i]->pPart;

				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_PARTICLE;

				pPart->Duplicate((CN3FXPartParticles*)m_pPart[i]->pPart);
			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_BOARD)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;				

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartBillBoard;
				CN3FXPartBillBoard* pPart = (CN3FXPartBillBoard*)pDestBundle->m_pPart[i]->pPart;

				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_BOARD;

				pPart->Duplicate((CN3FXPartBillBoard*)m_pPart[i]->pPart);
			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_MESH)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartMesh;
				CN3FXPartMesh* pPart = (CN3FXPartMesh*)pDestBundle->m_pPart[i]->pPart;
				
				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_MESH;

				pPart->Duplicate((CN3FXPartMesh*)m_pPart[i]->pPart);

			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_BOTTOMBOARD)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartBottomBoard;
				CN3FXPartBottomBoard* pPart = (CN3FXPartBottomBoard*)pDestBundle->m_pPart[i]->pPart;
				
				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_BOTTOMBOARD;

				pPart->Duplicate((CN3FXPartBottomBoard*)m_pPart[i]->pPart);
			}
		}
	}
}

// ===== END N3Base/N3FXBundle.cpp =====

// ===== BEGIN N3Base/N3FXBundle.h =====
#line 1 "N3Base/N3FXBundle.h"
﻿// N3FXBundle.h: interface for the CN3FXPartParticles class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXBUNDLE_H__
#define __N3FXBUNDLE_H__

#include "N3BaseFileAccess.h"
#include "N3FXDef.h"
#include "N3FXPartBase.h"

class CN3FXBundle : public CN3BaseFileAccess  
{
public:
	static constexpr int SUPPORTED_BUNDLE_VERSION = 2;

	// 기본 정보들...
	
	int					m_iVersion;		//번들버전
	std::string			m_strName;		//번들이름
	int					m_iMoveType;	//움직이는 형태..
	float				m_fVelocity;
	bool				m_bStatic;		//위치를 고정시킬것인가....

	float				m_fLife0;		//번들의 수명..

	FXPARTWITHSTARTTIME*	m_pPart[MAX_FX_PART];
	
	// 변하는 정보들...
	float				m_fLife;		//현재 나이..
	uint32_t				m_dwState;		//현재 번들의 상태

	__Vector3			m_vPos;			//현재 번들의 위치.
	__Vector3			m_vPrePos;		//로딩 또는 Duplicate 하기전에 임시로 위치 지정
	__Vector3			m_vDestPos;		//현재 번들의 목표위치. 
	__Vector3			m_vDir;			//현재 번들의 방향.
	
	int					m_iSourceID;	//이 효과를 쓰는 주체의 아이디..(게임에서..)
	int					m_iTargetID;	//이 효과를 받는 대상의 아이디..(게임에서..)
	int					m_iTargetJoint;	//이 효과를 받는 대상의 부위..(게임에서..)
	int					m_iSourceJoint;

	bool				m_bDependScale;
	//__Vector3			m_vTargetScale;
	float				m_fTargetScale;

//	int					m_iNumStep;		//몇단계나 존재하는지...^^
//	int					m_iCurrStep;	//현재 진행중인 시퀀스
	static float		m_fEffectSndDist;

	class CN3SndObj*	m_pSndObj;

protected:
	bool	CheckAllPartsDead();		//모든 파트들이 죽었는지 검사..

public:
	inline uint32_t GetState() const
	{
		return m_dwState;
	}

//기본적으로 필요한 함수들...
	virtual void	Trigger(int iSourceID=0, int iTargetID = 0, int iTargetJoint = 0, int iSndID = -1);
	virtual bool	Tick();
	virtual void	Duplicate(CN3FXBundle* pDestBundle);

	void	Init();
	void	Stop(bool immediately=false);
	
	void	Render();

	int		GetPartCountForVersion() const;

	bool	Load(File& file) override; // 핸들에서 읽어오기..
	virtual CN3FXPartBase* AllocatePart(int iPartType) const;

	bool	Save(File& file) override;	// 저장하기..

//	int				GetPartCount() { return m_pPartList.size(); }
	CN3FXPartBase*	GetPart(int i);
	float			GetPartSTime(int i);
	void			SetPartSTime(int i, float time);
	static void		SetEffectSndDistance(float fDist) { m_fEffectSndDist = fDist; }
	static float	GetEffectSndDistance() { return m_fEffectSndDist; }

//생성자 소멸자..
	CN3FXBundle();	
	virtual ~CN3FXBundle();

#ifdef _N3TOOL	//툴에서만 쓰는 함수들...
public:
	CN3FXPartBase*	SetPart(const char* pFileName);
	bool	DecodeScriptFile(const char* lpPathName);
#endif // end of _N3TOOL
};

#endif // #ifndef __N3FXBUNDLE_H__

// ===== END N3Base/N3FXBundle.h =====

// ===== BEGIN N3Base/N3FXDef.h =====
#line 1 "N3Base/N3FXDef.h"
﻿//////////////////////////////////////////////////////////////////////////////////////
//
//	N3FXDef.h
//	Effect에서 쓰이는 상수들이나 자료형들 정의...
//
//////////////////////////////////////////////////////////////////////////////////////

#ifndef __N3FXDEF_H__
#define __N3FXDEF_H__

#include "N3Base.h"
#include "My_3DStruct.h"

constexpr int MAX_FX_PART_V0		= 8;	// V0
constexpr int MAX_FX_PART_V1_ORIG	= 16;	// V1 originally, before they changed it
constexpr int MAX_FX_PART_V1		= 26;	// V1(+) after it was changed - no version change to identify this change

// TODO: Fix this. The UI is just hardcoded for 16 (which got later updated to 26 without a version change).
constexpr int MAX_FX_PART_TOOL		= MAX_FX_PART_V1_ORIG;

// 한 인스턴스가 동시에 표현할수 있는 갯수..
constexpr int MAX_FX_PART			= MAX_FX_PART_V1;

constexpr int NUM_VERTEX_PARTICLE = 4;	// 파티클 하나에 들어가는 점수..
constexpr int NUM_VERTEX_BOTTOM = 10;	//
constexpr int NUM_KEY_COLOR = 100;

enum e_FXPartType	// 이펙트 스타일...매쉬를 이용한 건지, 파티클을 이용한 건지..등등..
{
	FX_PART_TYPE_NONE = 0,
	FX_PART_TYPE_PARTICLE = 1,		//'particle'
	FX_PART_TYPE_BOARD = 2,			//'board'
	FX_PART_TYPE_MESH = 3,			//'mesh'
	FX_PART_TYPE_BOTTOMBOARD = 4	//'bottomboard'
};

enum e_FXPartState	//파트의 상태..
{
	FX_PART_STATE_DEAD = 0,
	FX_PART_STATE_DYING = 1,
	FX_PART_STATE_LIVE = 2,
	FX_PART_STATE_READY = 3
};

enum e_FXBundleState	//번들의 상태..
{
	FX_BUNDLE_STATE_DEAD = 0,
	FX_BUNDLE_STATE_DYING = 1,
	FX_BUNDLE_STATE_LIVE = 2	
};

enum e_FXBundleAct	//번들이 어케 동작하는지..
{
	FX_BUNDLE_MOVE_DIR_FIXEDTARGET = 0,
	FX_BUNDLE_MOVE_DIR_FLEXABLETARGET = 1,
	FX_BUNDLE_MOVE_DIR_FLEXABLETARGET_RATIO = 2,
	FX_BUNDLE_MOVE_CURVE_FIXEDTARGET = 3,	
	FX_BUNDLE_MOVE_DIR_SLOW = 4,
	FX_BUNDLE_REGION_POISON = 5,
	FX_BUNDLE_MOVE_NONE = 0xffffffff	
};

//
enum e_FXPartParticleEmitType	// 이펙트 파트가 어떤 모양으로 전개되는지...
{
	FX_PART_PARTICLE_EMIT_TYPE_NORMAL = 0,	//'normal'
	FX_PART_PARTICLE_EMIT_TYPE_SPREAD = 1,	//'spread'
	FX_PART_PARTICLE_EMIT_TYPE_GATHER = 2,	//'gather'	
};

//
/////////////////////////////////////////////////////////////////
//structures.....

/*
typedef struct __TABLE_FX	// FX 리소스 레코드...
{
	uint32_t		dwID;		// 고유 ID
	std::string	szFN;		// file name
	uint32_t		dwSoundID;	// 효과에 쓰는 사운드 아디.
} TABLE_FX;
*/

typedef struct Point3D
{
	float x;
	float y;
	float z;
} POINT3D;

typedef union __ParticleEmitCondition	//파티클 분사시 필요정보..
{
	POINT3D	vGatherPoint;	//EmitType이 gather일때 모아지는 점..
	float	fEmitAngle;		//EmitType이 spread일때 뿌려지는 각..
} PARTICLEEMITCONDITION;

typedef struct __FXPartWithStartTime	// 번들에서 파트들 관리할때..
{
	class CN3FXPartBase*	pPart;
	float					fStartTime;
	
	__FXPartWithStartTime()
	{
		pPart = nullptr;
		fStartTime = 0.0f;
	}
} FXPARTWITHSTARTTIME, *LPFXPARTWITHSTARTTIME;

typedef struct __FXBInfo
{
	char	FXBName[MAX_PATH];
	int		joint;
	BOOL	IsLooping;

	__FXBInfo()
	{
		ZeroMemory(FXBName, MAX_PATH);
		joint = -1;
		IsLooping = FALSE;
	}	
} FXBINFO, *LPFXBINFO;

#endif // #ifndef __N3FXDEF_H__

// ===== END N3Base/N3FXDef.h =====

// ===== BEGIN N3Base/N3FXGroup.cpp =====
#line 1 "N3Base/N3FXGroup.cpp"
﻿// N3FXGroup.cpp: implementation of the CN3FXGroup class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXBundle.h"
#include "N3FXGroup.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXGroup::CN3FXGroup()
{
	m_iVersion = 1;

	FXBList.clear();
}

CN3FXGroup::~CN3FXGroup()
{
	std::list<__FXBInfo*>::iterator it, ite;
	ite = FXBList.end();
	it = FXBList.begin();

	while(it!=ite)
	{
		__FXBInfo* pFXB = (*it);
		delete pFXB;
		it++;
	}

	FXBList.clear();
}

///////////////////////////////////////////////////////////////////////

bool CN3FXGroup::Load(File& file)
{
	file.Read(&m_iVersion, sizeof(int));

	int count;
	file.Read(&count, sizeof(int));

	for (int i = 0; i < count; i++)
	{
		__FXBInfo* pFXB = new __FXBInfo;
		file.Read(pFXB, sizeof(__FXBInfo));
		FXBList.push_back(pFXB);
	}
	return true;
}

bool CN3FXGroup::Save(File& file)
{
	file.Write(&m_iVersion, sizeof(int));

	int count = GetCount();
	file.Write(&count, sizeof(int));

	for (__FXBInfo* pFXB : FXBList)
		file.Write(pFXB, sizeof(__FXBInfo));

	return true;
}

//
//	decode script file..
//	스크립트 파일 읽고 해석시킴...
//
#ifdef _N3TOOL
bool CN3FXGroup::DecodeScriptFile(const char* lpPathName)
{
	FILE* stream = fopen(lpPathName, "r");
	if(!stream) return false;

	char szGamePathName[_MAX_PATH];
	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
	_splitpath(lpPathName, szDrive, szDir, szFName, szExt);
	_makepath(szGamePathName, szDrive, szDir, szFName, "fxg");

	CN3BaseFileAccess::FileNameSet(szGamePathName);

	char szLine[512] = "", szCommand[80] = "", szBuf[4][80] = { "", "", "", ""};
	char* pResult = fgets(szLine, 512, stream);
	sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);

	if(lstrcmpi(szCommand, "<n3fxgroup>"))
	{
		fclose(stream);
		return false;
	}

	while(!feof(stream))
	{
		char* pResult = fgets(szLine, 512, stream);
		if(pResult == nullptr) continue;

		ZeroMemory(szCommand,80);
		ZeroMemory(szBuf[0],80);
		ZeroMemory(szBuf[1],80);
		ZeroMemory(szBuf[2],80);
		ZeroMemory(szBuf[3],80);

		sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);

		if(lstrcmpi(szCommand, "<fxb>")==0)
		{
			__FXBInfo* pFXB = new __FXBInfo;
			strcpy(pFXB->FXBName, szBuf[0]);
			pFXB->joint = atoi(szBuf[1]);
			if(lstrcmpi(szBuf[2], "TRUE")==0) pFXB->IsLooping = TRUE;

			FXBList.push_back(pFXB);
			continue;
		}		
	}
	fclose(stream);

	return true;
}
#endif // end of _N3TOOL

__FXBInfo* CN3FXGroup::GetFXBInfo(int idx)
{
	if (idx < 0
		|| idx >= static_cast<int>(FXBList.size()))
		return nullptr;

	std::list<__FXBInfo*>::iterator it;
	it = FXBList.begin();

	for(int i=0;i<idx;i++) it++;
	return (*it);
}

// ===== END N3Base/N3FXGroup.cpp =====

// ===== BEGIN N3Base/N3FXGroup.h =====
#line 1 "N3Base/N3FXGroup.h"
﻿// N3FXGroup.h: interface for the CN3FXGroup class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXGROUP_H__
#define __N3FXGROUP_H__

#include "N3BaseFileAccess.h"
#include "N3FXDef.h"

#include <list>

class CN3FXGroup : public CN3BaseFileAccess  
{
public:
	int			m_iVersion;
	std::list<__FXBInfo*> FXBList;
	
public:
	int	GetCount() const
	{
		return static_cast<int>(FXBList.size());
	}

	__FXBInfo* GetFXBInfo(int idx);

	bool Load(File& file) override; // 핸들에서 읽어오기..
	bool Save(File& file) override;	// 저장하기..
	
	CN3FXGroup();	
	~CN3FXGroup() override;

#ifdef _N3TOOL	//툴에서만 쓰는 함수들...
public:
	bool	DecodeScriptFile(const char* lpPathName);
#endif // end of _N3TOOL
};

#endif // #ifndef __N3FXGROUP_H__

// ===== END N3Base/N3FXGroup.h =====

// ===== BEGIN N3Base/N3FXPMesh.cpp =====
#line 1 "N3Base/N3FXPMesh.cpp"
﻿// N3FXPMesh.cpp: implementation of the CN3FXPMesh class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPMesh.h"
#include "N3PMesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPMesh::CN3FXPMesh()
{
	m_fRadius = 0.0f;
	m_pColorVertices = nullptr;
	m_pVertices = nullptr;
	m_pVertices2 = nullptr;
	m_pIndices = nullptr;
}

CN3FXPMesh::~CN3FXPMesh()
{
	Release();
}

HRESULT CN3FXPMesh::Create(int iNumVertices, int iNumIndices)
{
	m_iMaxNumVertices = iNumVertices;
	m_iMaxNumIndices = iNumIndices;

	if (m_pVertices) {delete m_pVertices; m_pVertices = nullptr;}
	if (m_pIndices) {delete m_pIndices; m_pIndices = nullptr;}
	if (m_pColorVertices) {delete m_pColorVertices; m_pColorVertices = nullptr;}

	if (m_iMaxNumVertices>0)
	{
		m_pVertices = new __VertexT1[m_iMaxNumVertices];
	}
	if (m_iMaxNumIndices>0)
	{
		m_pIndices = new uint16_t[m_iMaxNumIndices];
	}
	if (m_iMaxNumVertices>0)
	{
		m_pColorVertices = new __VertexXyzColorT1[m_iMaxNumVertices];
	}

	return S_OK;
}

void CN3FXPMesh::operator=(const CN3FXPMesh& fxPMesh)
{
	if (this == &fxPMesh)
		return;

	Release();

	FileNameSet(fxPMesh.FileName());

	m_iMaxNumVertices	= fxPMesh.m_iMaxNumVertices;
	m_iMaxNumIndices	= fxPMesh.m_iMaxNumIndices;
	m_iMinNumVertices	= fxPMesh.m_iMinNumVertices;
	m_iMinNumIndices	= fxPMesh.m_iMinNumIndices;
	m_iNumCollapses		= fxPMesh.m_iNumCollapses;

	m_fRadius			= fxPMesh.m_fRadius;
	m_vMax				= fxPMesh.m_vMax;
	m_vMin				= fxPMesh.m_vMin;

	m_iLODCtrlValueCount = fxPMesh.m_iLODCtrlValueCount;
	m_iTotalIndexChanges = fxPMesh.m_iTotalIndexChanges;

	Create(m_iMaxNumVertices ,m_iMaxNumIndices);

	memcpy(m_pColorVertices, fxPMesh.m_pColorVertices, sizeof(__VertexXyzColorT1)*m_iMaxNumVertices);
	memcpy(m_pIndices, fxPMesh.m_pIndices, sizeof(uint16_t)*m_iMaxNumIndices);

	if (m_iNumCollapses>0)
	{
		m_pCollapses = new __EdgeCollapse[m_iNumCollapses+1];	// +1을 한 이유 : PMeshInstance::SplitOne() 함수에서 부득이하게 포인터가 경계선을 가르키게 해야 하는 경우가 있어서.
		memcpy(m_pCollapses, fxPMesh.m_pCollapses, sizeof(__EdgeCollapse)*(m_iMaxNumIndices+1));
	}

	m_pLODCtrlValues = new __LODCtrlValue[m_iLODCtrlValueCount];
	memcpy(m_pLODCtrlValues, fxPMesh.m_pLODCtrlValues, sizeof(__LODCtrlValue)*m_iLODCtrlValueCount);

	m_pAllIndexChanges = new int[m_iTotalIndexChanges];
	memcpy(m_pAllIndexChanges, fxPMesh.m_pAllIndexChanges, sizeof(int)*m_iTotalIndexChanges);
}

bool CN3FXPMesh::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	file.Read(&m_iNumCollapses, sizeof(m_iNumCollapses));
	file.Read(&m_iTotalIndexChanges, sizeof(m_iTotalIndexChanges));

	file.Read(&m_iMaxNumVertices, sizeof(int));
	file.Read(&m_iMaxNumIndices , sizeof(int));
	file.Read(&m_iMinNumVertices, sizeof(int));
	file.Read(&m_iMinNumIndices , sizeof(int));

	HRESULT hr = Create(m_iMaxNumVertices, m_iMaxNumIndices);
	__ASSERT(SUCCEEDED(hr), "Failed to create progressive mesh");

	if (m_iMaxNumVertices>0)
	{
		file.Read(m_pVertices, m_iMaxNumVertices*sizeof(__VertexT1));
		for(int i=0;i<m_iMaxNumVertices;i++)
		{
			m_pColorVertices[i].x = m_pVertices[i].x;
			m_pColorVertices[i].y = m_pVertices[i].y;
			m_pColorVertices[i].z = m_pVertices[i].z;
			m_pColorVertices[i].color = 0xffffffff;
			m_pColorVertices[i].tu = m_pVertices[i].tu;
			m_pColorVertices[i].tv = m_pVertices[i].tv;			
		}

		delete[] m_pVertices;
		m_pVertices = nullptr;
	}

	if (m_iMaxNumIndices>0)
		file.Read(m_pIndices, m_iMaxNumIndices*sizeof(uint16_t));

	if (m_iNumCollapses>0)
	{
		m_pCollapses = new __EdgeCollapse[m_iNumCollapses+1];	// +1을 한 이유 : PMeshInstance::SplitOne() 함수에서 부득이하게 포인터가 경계선을 가르키게 해야 하는 경우가 있어서.
		file.Read(m_pCollapses, m_iNumCollapses*sizeof(__EdgeCollapse));
		ZeroMemory(m_pCollapses + m_iNumCollapses, sizeof(__EdgeCollapse));	// 위의 +1을 한이유와 같음. 만약을 대비해 마지막 데이타를 초기화 해둠

		bool bFixed = false;
		for(int i = 0; i < m_iNumCollapses; i++)
		{
			if(m_pCollapses[i].iIndexChanges < 0)
			{
				m_pCollapses[i].iIndexChanges = 0;
				bFixed = true;
			}
		}
#ifdef _DEBUG
		if(bFixed)
			::MessageBox(s_hWndBase, "잘못된 Progressive Mesh 수정", m_szName.c_str(), MB_OK);
#endif
	}
	if (m_iTotalIndexChanges>0)
	{
		m_pAllIndexChanges = new int[m_iTotalIndexChanges];
		file.Read(m_pAllIndexChanges, m_iTotalIndexChanges*sizeof(int));
	}

	__ASSERT(m_pLODCtrlValues == nullptr && m_iLODCtrlValueCount == 0, "Invalid Level of detail control value");
	file.Read(&m_iLODCtrlValueCount, sizeof(m_iLODCtrlValueCount));
	if (m_iLODCtrlValueCount>0)
	{
		m_pLODCtrlValues = new __LODCtrlValue[m_iLODCtrlValueCount];
		file.Read(m_pLODCtrlValues, m_iLODCtrlValueCount*sizeof(__LODCtrlValue));
	}

	FindMinMax();

	return true;
}

void CN3FXPMesh::Release()
{
	CN3PMesh::Release();

	if (m_pVertices) {delete m_pVertices; m_pVertices = nullptr;}
	if (m_pIndices) {delete m_pIndices; m_pIndices = nullptr;}
	if (m_pColorVertices) {delete m_pColorVertices; m_pColorVertices = nullptr;}
}


void CN3FXPMesh::Render()
{
	s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

	const int iPCToRender = 1000;	// primitive count to render
	if(m_iMaxNumIndices > 3)
	{
		int iPC = m_iMaxNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iMaxNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pColorVertices, sizeof(__VertexXyzColorT1));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iMaxNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pColorVertices, sizeof(__VertexXyzColorT1));
	}
}

void CN3FXPMesh::FindMinMax()
{
	if(m_iMaxNumVertices <= 0)
	{
		m_vMin.Zero();
		m_vMax.Zero();
		m_fRadius = 0;
		return;
	}

	// 최소, 최대 점을 찾는다.
	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);

	for(int i = 0; i < m_iMaxNumVertices; i++)
	{
		if(m_pColorVertices[i].x < m_vMin.x) m_vMin.x = m_pColorVertices[i].x;
		if(m_pColorVertices[i].y < m_vMin.y) m_vMin.y = m_pColorVertices[i].y;
		if(m_pColorVertices[i].z < m_vMin.z) m_vMin.z = m_pColorVertices[i].z;

		if(m_pColorVertices[i].x > m_vMax.x) m_vMax.x = m_pColorVertices[i].x;
		if(m_pColorVertices[i].y > m_vMax.y) m_vMax.y = m_pColorVertices[i].y;
		if(m_pColorVertices[i].z > m_vMax.z) m_vMax.z = m_pColorVertices[i].z;
	}

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

void CN3FXPMesh::SetColor(uint32_t dwColor)
{
	if (m_pColorVertices == nullptr)	return;
	if (m_iMaxNumVertices <= 0)		return;

	for(int i=0;i<m_iMaxNumVertices;i++)
	{
		m_pColorVertices[i].color = dwColor;
	}
}

// ===== END N3Base/N3FXPMesh.cpp =====

// ===== BEGIN N3Base/N3FXPMesh.h =====
#line 1 "N3Base/N3FXPMesh.h"
﻿// N3FXPMesh.h: interface for the CN3FXPMesh class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3FXPMESH_H__18E8E609_322F_4F0F_839B_0411986DA76E__INCLUDED_)
#define AFX_N3FXPMESH_H__18E8E609_322F_4F0F_839B_0411986DA76E__INCLUDED_

#include "N3BaseFileAccess.h"
#include "N3PMesh.h"

class CN3FXPMesh : public CN3PMesh
{
friend class CN3FXPMeshInstance;

private:
	__VertexXyzColorT1*		m_pColorVertices;

public:
	void					Render();
	void					Release() override;
	void					FindMinMax();
	bool					Load(File& file) override;
	void					SetColor(uint32_t dwColor = 0xffffffff);
	HRESULT					Create(int iNumVertices, int iNumIndices);
	void					operator=(const CN3FXPMesh& fxPMesh);
	__VertexXyzColorT1*		GetColorVertices() { return m_pColorVertices; }

public:
	CN3FXPMesh();
	~CN3FXPMesh() override;
};

#endif

// ===== END N3Base/N3FXPMesh.h =====

// ===== BEGIN N3Base/N3FXPMeshInstance.cpp =====
#line 1 "N3Base/N3FXPMeshInstance.cpp"
﻿// N3FXPMeshInstance.cpp: implementation of the CN3FXPMeshInstance class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPMeshInstance.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPMeshInstance::CN3FXPMeshInstance()
{
	m_pFXPMesh			= nullptr;
	m_pIndices			= nullptr;
	m_pColorVertices	= nullptr;
	m_iNumVertices		= 0;
	m_iNumIndices		= 0;
	m_pCollapseUpTo		= nullptr;
}

CN3FXPMeshInstance::CN3FXPMeshInstance(CN3FXPMesh* pN3FXPMesh)
{
	m_pFXPMesh			= nullptr;
	m_pIndices			= nullptr;
	m_pColorVertices	= nullptr;
	m_iNumVertices		= 0;
	m_iNumIndices		= 0;
	m_pCollapseUpTo		= nullptr;

	CN3FXPMeshInstance::Create(pN3FXPMesh);
}

CN3FXPMeshInstance::CN3FXPMeshInstance(const std::string& szFN)
{
	m_pFXPMesh			= nullptr;
	m_pIndices			= nullptr;
	m_pColorVertices	= nullptr;
	m_iNumVertices		= 0;
	m_iNumIndices		= 0;
	m_pCollapseUpTo		= nullptr;

	this->Create(szFN);
}

CN3FXPMeshInstance::~CN3FXPMeshInstance()
{
	if (m_pColorVertices)	{ delete[] m_pColorVertices;m_pColorVertices = nullptr;}
	if (m_pIndices)			{ delete[] m_pIndices;m_pIndices = nullptr;}

	s_MngFXPMesh.Delete(&m_pFXPMesh);				//레퍼런스 카운트를 줄이기 위해
}

void CN3FXPMeshInstance::Release()
{
	if (m_pColorVertices)	{ delete[] m_pColorVertices;m_pColorVertices = nullptr;}
	if (m_pIndices)			{ delete[] m_pIndices;m_pIndices = nullptr;}

	s_MngFXPMesh.Delete(&m_pFXPMesh);				//레퍼런스 카운트를 줄이기 위해

	m_pCollapseUpTo = nullptr;
	m_iNumVertices = 0;
	m_iNumIndices = 0;
}

bool CN3FXPMeshInstance::Create(CN3FXPMesh* pN3FXPMesh)
{
	if(pN3FXPMesh == nullptr)
	{
		CN3FXPMeshInstance::Release();
		return false;
	}

	m_pFXPMesh = pN3FXPMesh;
	if(m_pFXPMesh == nullptr)
	{
		__ASSERT(m_pFXPMesh, "Failed new CN3FXPMesh");
		return false;
	}

	m_szName = pN3FXPMesh->m_szName;

	int iMaxNumVertices = m_pFXPMesh->GetMaxNumVertices();
	if (iMaxNumVertices>0)
	{
		if(m_pColorVertices) { delete[] m_pColorVertices;m_pColorVertices = nullptr;}
		m_pColorVertices = new __VertexXyzColorT1[iMaxNumVertices];
		__ASSERT(m_pColorVertices, "Failed to create Vertex buffer");
		CopyMemory(m_pColorVertices, m_pFXPMesh->m_pColorVertices, iMaxNumVertices * sizeof(__VertexXyzColorT1));
	}

	// And setup my instance-specific data.
	// We start with the lowest level of detail.
	int iMaxNumIndices = m_pFXPMesh->GetMaxNumIndices();
	if (iMaxNumIndices>0)
	{
		if(m_pIndices) { delete[] m_pIndices;m_pIndices = nullptr;}
		m_pIndices = new uint16_t[m_pFXPMesh->m_iMaxNumIndices];
		__ASSERT(m_pIndices, "Failed to create index buffer");
		CopyMemory(m_pIndices, m_pFXPMesh->m_pIndices, m_pFXPMesh->m_iMaxNumIndices * sizeof(uint16_t));
	}

	// lowest level of detail right now.
	m_iNumVertices = m_pFXPMesh->GetMinNumVertices();
	m_iNumIndices  = m_pFXPMesh->GetMinNumIndices();

	// So far, we're at the last collapse
	m_pCollapseUpTo = m_pFXPMesh->m_pCollapses;

	return true;
}

bool CN3FXPMeshInstance::Create(const std::string& szFN)
{
	if (m_pFXPMesh && m_pFXPMesh->FileName() == szFN) return true;	// 파일 이름이 같으면 새로 만들지 않고 리턴하자
	this->Release();

	CN3FXPMesh* pN3FXPMesh = s_MngFXPMesh.Get(szFN);
	return this->Create(pN3FXPMesh);
}

void CN3FXPMeshInstance::SetLODByNumVertices(int iNumVertices)
{
	if(m_pCollapseUpTo == nullptr) return;

	int iDiff = iNumVertices - m_iNumVertices;

	if(iDiff == 0)
	{
		return;
	}
	else if (iDiff > 0)
	{
		while(iNumVertices > m_iNumVertices)
		{
			if (m_pCollapseUpTo->NumVerticesToLose + m_iNumVertices > iNumVertices) break;		// 깜박임 방지 코드..
			if (SplitOne() == false) break;
		}
	}
	else if (iDiff < 0)
	{
		iDiff = -iDiff;
		while(iNumVertices < m_iNumVertices)
		{
			if (CollapseOne() == false) break;
		}
	}

	while(m_pCollapseUpTo->bShouldCollapse)
	{
		if (SplitOne() == false) break;
	}
}

void CN3FXPMeshInstance::SetLOD(float value)
{
#define _USE_LODCONTROL_VALUE
#ifdef _USE_LODCONTROL_VALUE
	// value는 distance * FOV이다.
	if (m_pFXPMesh == nullptr ) return;

	if (m_pFXPMesh->m_iLODCtrlValueCount == 0)
	{	// LODCtrlValue가 없으면 모두 그린다.
		SetLODByNumVertices(0x7fffffff);
		return;
	}
	
	__ASSERT(m_pFXPMesh->m_pLODCtrlValues, "LOD control value is NULL!");

	CN3PMesh::__LODCtrlValue* pTmpLODCV = m_pFXPMesh->m_pLODCtrlValues + m_pFXPMesh->m_iLODCtrlValueCount-1;

	if (value < m_pFXPMesh->m_pLODCtrlValues[0].fDist)
	{		// 최소 기준치보다 가까우므로 가장 많은 면으로 그린다.
		SetLODByNumVertices(m_pFXPMesh->m_pLODCtrlValues[0].iNumVertices);
	}
	else if ( pTmpLODCV->fDist < value)
	{		// 최대 기준치보다 멀리 있으므로 가장 적은 면으로 그린다.
		SetLODByNumVertices(pTmpLODCV->iNumVertices);
	}
	else
	{		// 중간 값에 맞게 조정된 면 수로 그린다.
		for (int i=1; i< m_pFXPMesh->m_iLODCtrlValueCount; ++i)
		{
			if (value < m_pFXPMesh->m_pLODCtrlValues[i].fDist)
			{
				CN3PMesh::__LODCtrlValue* pHiValue = m_pFXPMesh->m_pLODCtrlValues + i;
				CN3PMesh::__LODCtrlValue* pLowValue = pHiValue - 1;
				float fVertices = (pHiValue->iNumVertices - pLowValue->iNumVertices)*
									(value - pLowValue->fDist)/(pHiValue->fDist - pLowValue->fDist);
				SetLODByNumVertices(pLowValue->iNumVertices + (int)fVertices);
				break;
			}
		}
	}
#else
	// value는 distance * FOV이다.
	if (m_pCollapseUpTo == nullptr || m_pFXPMesh == nullptr) return;

	const int iLODCtrlValueCount = 5;
	__PMLODCtrlValue LODCtrlValues[iLODCtrlValueCount];
	__PMLODCtrlValue* pTmpLODCV = &(LODCtrlValues[iLODCtrlValueCount-1]);

	int iMaxNumVertices = m_pFXPMesh->GetMaxNumVertices();
	int iMinNumVertices = m_pFXPMesh->GetMinNumVertices();
	int iDiff = iMaxNumVertices - iMinNumVertices;
	
	float fVolume = m_pFXPMesh->GetVolume();
	float fD = (sqrtf(fVolume)*3.0f) / (value * 1.0f);
	fD = 1.0f;
//	float fD = fVolume/(value*13.0f) * (400.0f/(float)iMaxNumVertices);
	if(fD > 1.0f) SetLODByNumVertices(iMaxNumVertices);
	else if(fD < 0.1f) SetLODByNumVertices(iMinNumVertices);
	else SetLODByNumVertices(iMinNumVertices + (int)(iDiff * fD));

#endif
}

bool CN3FXPMeshInstance::CollapseOne()
{
	if (m_pCollapseUpTo <= m_pFXPMesh->m_pCollapses) return false;

	m_pCollapseUpTo--;

	m_iNumIndices -= m_pCollapseUpTo->NumIndicesToLose;
	
	for (	int *i = m_pFXPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges;
			i < m_pFXPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges + m_pCollapseUpTo->NumIndicesToChange;
			i++)
	{
		m_pIndices[*i] = m_pCollapseUpTo->CollapseTo;
	}

	m_iNumVertices -= m_pCollapseUpTo->NumVerticesToLose;

	return true;
}

bool CN3FXPMeshInstance::SplitOne()
{
	if (m_pCollapseUpTo >= m_pFXPMesh->m_pCollapses + m_pFXPMesh->m_iNumCollapses) return false; // 이렇게 하면 포인터 하나가 삐져 나오게 된다..
	// 하지만 이렇게 다시 하는 이유는 아래 코드로 하면 마지막 폴리곤이 절대 그려지지 않는다.
	// 이렇게 해도 괜찮을 수 있도록 방어코드를 넣었다. m_pFXPMesh->m_pCollapses 를 할당할때 1개 더 할당하고 마지막 데이터를 초기값으로 넣었다.
//	if (m_pCollapseUpTo >= m_pFXPMesh->m_pCollapses + m_pFXPMesh->m_iNumCollapses - 1) return false; // 이게 정상이다..

	m_iNumIndices  += m_pCollapseUpTo->NumIndicesToLose;
	m_iNumVertices += m_pCollapseUpTo->NumVerticesToLose;

	if(m_pFXPMesh->m_pAllIndexChanges)
	{
		for (	int *i = m_pFXPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges;
				i < m_pFXPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges + m_pCollapseUpTo->NumIndicesToChange;
				i++)
		{
			m_pIndices[*i] = m_iNumVertices - 1;
		}
	}

	m_pCollapseUpTo++;
	return true;
}

void CN3FXPMeshInstance::Render()
{
	if (m_pFXPMesh == nullptr) return;
	s_lpD3DDev->SetFVF(FVF_VNT1);

	const int iPCToRender = 1000;	// primitive count to render
	if(m_iNumIndices > 3)
	{
		int iPC = m_iNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pColorVertices, sizeof(__VertexXyzColorT1));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pColorVertices, sizeof(__VertexXyzColorT1));
	}
}

void CN3FXPMeshInstance::RenderTwoUV()
{
	if(nullptr == m_pFXPMesh) return;
	if(nullptr == m_pFXPMesh->GetVertices2())
	{
		m_pFXPMesh->GenerateSecondUV(); // 두번째 UV 가 없음 새로 만든다..
	}
	if(nullptr == m_pFXPMesh->GetVertices2()) return;
	
	s_lpD3DDev->SetFVF(FVF_VNT2);

	const int iPCToRender = 1000;	// primitive count to render
	if(m_iNumIndices > 3)
	{
		int iPC = m_iNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pFXPMesh->m_pVertices2, sizeof(__VertexT2));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pFXPMesh->m_pVertices2, sizeof(__VertexT2));
	}
}

__VertexXyzColorT1*	CN3FXPMeshInstance::GetVertices() const
{
	return m_pColorVertices;
}

void CN3FXPMeshInstance::SetColor(uint32_t dwColor)
{
	if (m_pColorVertices == nullptr)	return;
	if (m_iNumVertices <= 0)		return;

	for(int i=0;i<m_iNumVertices;i++)
	{
		m_pColorVertices[i].color = dwColor;
	}
}

// ===== END N3Base/N3FXPMeshInstance.cpp =====

// ===== BEGIN N3Base/N3FXPMeshInstance.h =====
#line 1 "N3Base/N3FXPMeshInstance.h"
﻿// N3FXPMeshInstance.h: interface for the CN3FXPMeshInstance class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3FXPMESHINSTANCE_H__19060ED0_7DDA_4279_A558_B586319324F0__INCLUDED_)
#define AFX_N3FXPMESHINSTANCE_H__19060ED0_7DDA_4279_A558_B586319324F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include "N3PMesh.h"
#include "N3FXPMesh.h"

#include <string>

class CN3FXPMeshInstance   : public CN3Base
{
public:
	CN3FXPMeshInstance();
	CN3FXPMeshInstance(CN3FXPMesh *pN3FXPMesh);
	CN3FXPMeshInstance(const std::string& szFN);
	virtual ~CN3FXPMeshInstance();

protected:
	__VertexXyzColorT1* m_pColorVertices;
	uint16_t*				m_pIndices;

	// number of triangles/vertices to use at this moment.
	int					m_iNumIndices;
	int					m_iNumVertices; 

	CN3PMesh::__EdgeCollapse*	m_pCollapseUpTo;	// 참조 포인터

	// A pointer to the original mesh. This is where you'll find the vertex data (which
	// is invariant between PMRInstance's)
	CN3FXPMesh*	m_pFXPMesh;

public:
	void		SetColor(uint32_t dwColor = 0xffffffff);
	BOOL		IsLOD() { if(nullptr == m_pCollapseUpTo) return FALSE; return TRUE; }
	bool		Create(CN3FXPMesh* pN3FXPMesh);
	bool		Create(const std::string& szFN);
	void		Release();
	void		Render();
	void		RenderTwoUV();
	// The value you pass into this could be based on distance from camera, frame rate, etc
	void		SetLOD(float value); // value = Camera Distance / Camera FOV;

	// Or you can choose to collapse/split one step at a time. These return false if there was
	// no more collapsing/splitting to do.
	bool		CollapseOne();
	bool		SplitOne();

	void		SetLODByNumVertices(int iNumVertices);
	int			GetNumVertices() const {return m_iNumVertices;};
	int			GetNumIndices() const {return m_iNumIndices;};
	CN3FXPMesh*	GetMesh() {return m_pFXPMesh;};

	__VertexXyzColorT1*	GetVertices() const;
	uint16_t*				GetIndices() const { return m_pIndices;};
};

#endif // !defined(AFX_N3FXPMESHINSTANCE_H__19060ED0_7DDA_4279_A558_B586319324F0__INCLUDED_)

// ===== END N3Base/N3FXPMeshInstance.h =====

// ===== BEGIN N3Base/N3FXPartBase.cpp =====
#line 1 "N3Base/N3FXPartBase.cpp"
﻿// N3FXPartBase.cpp: implementation of the CN3EffectPartBase class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPartBase.h"
#include "N3FXBundle.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartBase::CN3FXPartBase()
{
	m_iVersion = 0;
	m_iBaseVersion = SUPPORTED_PART_BASE_VERSION;

	m_pRefBundle = nullptr;
	m_pRefPrevPart = nullptr;

	m_iType = FX_PART_TYPE_NONE;

	m_fLife = m_fCurrLife = 0.0f;

	m_strName.erase();

	m_vVelocity.Set(0,0,0);
	m_vAcceleration.Set(0,0,0);
	m_vRotVelocity.Set(0,0,0);
	m_vCurrVelocity = m_vVelocity;

	m_dwState = FX_PART_STATE_READY;
	m_vPos.Set(0,0,0);
	m_vCurrPos = m_vPos;

	m_ppRefTex = nullptr;
	m_iNumTex = 0;
	m_fTexFPS = 30.0f;

	m_dwSrcBlend = D3DBLEND_ONE;
	m_dwDestBlend = D3DBLEND_ONE;
	m_bAlpha = TRUE;

	m_fFadeOut = 0.0f;
	m_fFadeIn = 0.0f;

	ZeroMemory(m_pTexName, MAX_PATH);

	m_bOnGround = false;

	m_dwRenderFlag = RF_ALPHABLENDING | RF_NOTUSEFOG | RF_DIFFUSEALPHA | RF_NOTUSELIGHT | RF_DOUBLESIDED;
	
	m_dwZEnable = D3DZB_TRUE;
	m_dwZWrite = TRUE;
	m_dwLight = FALSE;
	m_dwDoubleSide = D3DCULL_NONE;
/*
const uint32_t RF_NOTHING			= 0x0;
const uint32_t RF_ALPHABLENDING	= 0x1;		// Alpha blending
const uint32_t RF_NOTUSEFOG		= 0x2;		// 안개 무시
const uint32_t RF_DOUBLESIDED		= 0x4;		// 양면 - D3DCULL_NONE
const uint32_t RF_BOARD_Y			= 0x8;		// Y 축으로 해서.. 카메라를 본다.
const uint32_t RF_POINTSAMPLING	= 0x10;		// MipMap 에서.. PointSampling 으로 한다..
const uint32_t RF_WINDY			= 0x20;		// 바람에 날린다.. 바람의 값은 CN3Base::s_vWindFactor 를 참조 한다..
const uint32_t RF_NOTUSELIGHT		= 0x40;		// Light Off
const uint32_t RF_DIFFUSEALPHA		= 0x80;		// Diffuse 값을 갖고 투명하게 Alpha blending
const uint32_t RF_NOTZWRITE		= 0x100;	// ZBuffer 에 안쓴다.
const uint32_t RF_UV_CLAMP			= 0x200;	// texture UV적용을 Clamp로 한다..default는 wrap이다..
const uint32_t RF_NOTZBUFFER		= 0x400;	// ZBuffer 무시.
*/
}

CN3FXPartBase::~CN3FXPartBase()
{
	if(m_ppRefTex)
	{
		for(int i=0; i<m_iNumTex;i++) CN3Base::s_MngTex.Delete(&m_ppRefTex[i]);
		delete[] m_ppRefTex;
		m_ppRefTex = nullptr;
	}
}


//
//	parse script...
//	스크립트 해서 & 셋팅.
//
#ifdef _N3TOOL
bool CN3FXPartBase::ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3)
{
	//	이름.
	if (lstrcmpi(szCommand, "<name>") == 0)
	{
		m_strName = szBuff0;
		return true;
	}

	//	타입..
	if (lstrcmpi(szCommand, "<type>") == 0)
	{
		if (lstrcmpi(szBuff0, "particle") == 0)
			m_iType = FX_PART_TYPE_PARTICLE;
		else if (lstrcmpi(szBuff0, "board") == 0)
			m_iType = FX_PART_TYPE_BOARD;
		else if (lstrcmpi(szBuff0, "mesh") == 0)
			m_iType = FX_PART_TYPE_MESH;
		else if (lstrcmpi(szBuff0, "ground") == 0)
			m_iType = FX_PART_TYPE_BOTTOMBOARD;

		//^^v 더 넣을꺼 있으면 넣어라..
		return true;
	}

	//	지속시간.(0이면 무한대...)
	if (lstrcmpi(szCommand, "<life>") == 0)
	{
		m_fLife = static_cast<float>(atof(szBuff0));
		return true;
	}

	//	texture 이름과 개수 읽기.
	if (lstrcmpi(szCommand, "<texture>") == 0)
	{
		m_iNumTex = atoi(szBuff1);
		m_ppRefTex = new CN3Texture* [m_iNumTex];

		char szPathName[_MAX_PATH] = {},
			szDir[_MAX_DIR] = {},
			szFileName[_MAX_PATH] = {},
			szExt[_MAX_EXT] = {};

		strcpy(szPathName, szBuff0);
		_splitpath(szPathName, nullptr, szDir, szFileName, szExt);

		memset(m_pTexName, 0, sizeof(m_pTexName));
		strcat(m_pTexName, szDir);
		strcat(m_pTexName, szFileName);

		std::string FileName = m_pTexName;
		for (int i = 0; i < m_iNumTex; i++)
		{
			FileName = fmt::format("{}{:04}{}", m_pTexName, i, szExt);
			m_ppRefTex[i] = CN3Base::s_MngTex.Get(FileName);
		}
		return true;
	}

	//	texture animation speed 설정..
	if (lstrcmpi(szCommand, "<texture_animation_speed>") == 0)
	{
		m_fTexFPS = static_cast<float>(atof(szBuff0));
		return true;
	}

	//	상대위치...
	if (lstrcmpi(szCommand, "<position0>") == 0)
	{
		m_vPos.x = static_cast<float>(atof(szBuff0));
		m_vPos.y = static_cast<float>(atof(szBuff1));
		m_vPos.z = static_cast<float>(atof(szBuff2));
		return true;
	}

	//	속도..
	if (lstrcmpi(szCommand, "<velocity>") == 0)
	{
		m_vVelocity.x = static_cast<float>(atof(szBuff0));
		m_vVelocity.y = static_cast<float>(atof(szBuff1));
		m_vVelocity.z = static_cast<float>(atof(szBuff2));
		return true;
	}

	//	가속도..
	if (lstrcmpi(szCommand, "<acceleration>") == 0)
	{
		m_vAcceleration.x = static_cast<float>(atof(szBuff0));
		m_vAcceleration.y = static_cast<float>(atof(szBuff1));
		m_vAcceleration.z = static_cast<float>(atof(szBuff2));
		return true;
	}

	//	회전 각속도..
	if (lstrcmpi(szCommand, "<rot_velocity>") == 0)
	{
		m_vRotVelocity.x = static_cast<float>(atof(szBuff0));
		m_vRotVelocity.y = static_cast<float>(atof(szBuff1));
		m_vRotVelocity.z = static_cast<float>(atof(szBuff2));
		return true;
	}

	//	SRCBLEND..
	if (lstrcmpi(szCommand, "<src_blend>") == 0)
	{
		if (lstrcmpi(szBuff0, "ONE") == 0)
			m_dwSrcBlend = D3DBLEND_ONE;
		else if (lstrcmpi(szBuff0, "ZERO") == 0)
			m_dwSrcBlend = D3DBLEND_ZERO;
		else if (lstrcmpi(szBuff0, "SRCCOLOR") == 0)
			m_dwSrcBlend = D3DBLEND_SRCCOLOR;
		else if (lstrcmpi(szBuff0, "INVSRCCOLOR") == 0)
			m_dwSrcBlend = D3DBLEND_INVSRCCOLOR;
		else if (lstrcmpi(szBuff0, "SRCALPHA") == 0)
			m_dwSrcBlend = D3DBLEND_SRCALPHA;
		else if (lstrcmpi(szBuff0, "INVSRCALPHA") == 0)
			m_dwSrcBlend = D3DBLEND_INVSRCALPHA;

		return true;
	}

	//	SRCBLEND..
	if (lstrcmpi(szCommand, "<dest_blend>") == 0)
	{
		if (lstrcmpi(szBuff0, "ONE") == 0)
			m_dwDestBlend = D3DBLEND_ONE;
		else if (lstrcmpi(szBuff0, "ZERO") == 0)
			m_dwDestBlend = D3DBLEND_ZERO;
		else if (lstrcmpi(szBuff0, "SRCCOLOR") == 0)
			m_dwDestBlend = D3DBLEND_SRCCOLOR;
		else if (lstrcmpi(szBuff0, "INVSRCCOLOR") == 0)
			m_dwDestBlend = D3DBLEND_INVSRCCOLOR;
		else if (lstrcmpi(szBuff0, "SRCALPHA") == 0)
			m_dwDestBlend = D3DBLEND_SRCALPHA;
		else if (lstrcmpi(szBuff0, "INVSRCALPHA") == 0)
			m_dwDestBlend = D3DBLEND_INVSRCALPHA;

		return true;
	}

	if (lstrcmpi(szCommand, "<alpha>") == 0)
	{
		m_dwRenderFlag |= RF_ALPHABLENDING;

		if (lstrcmpi(szBuff0, "TRUE") == 0)
		{
			m_bAlpha = TRUE;
		}
		else if (lstrcmpi(szBuff0, "FALSE") == 0)
		{
			m_bAlpha = FALSE;
			m_dwRenderFlag ^= RF_ALPHABLENDING;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<fadeout>") == 0)
	{
		m_fFadeOut = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<fadein>") == 0)
	{
		m_fFadeIn = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<on_ground>") == 0)
	{
		if (lstrcmpi(szBuff0, "TRUE") == 0)
			m_bOnGround = true;
		else if (lstrcmpi(szBuff0, "FALSE") == 0)
			m_bOnGround = false;

		return true;
	}

	if (lstrcmpi(szCommand, "<doubleside>") == 0)
	{
		m_dwRenderFlag |= RF_DOUBLESIDED;

		if (lstrcmpi(szBuff0, "true") == 0)
		{
			m_dwDoubleSide = D3DCULL_NONE;
		}
		else if (lstrcmpi(szBuff0, "false") == 0)
		{
			m_dwDoubleSide = D3DCULL_CCW;
			m_dwRenderFlag ^= RF_DOUBLESIDED;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<light>") == 0)
	{
		m_dwRenderFlag |= RF_NOTUSELIGHT;

		if (lstrcmpi(szBuff0, "true") == 0)
		{
			m_dwLight = TRUE;
			m_dwRenderFlag ^= RF_NOTUSELIGHT;
		}
		else if (lstrcmpi(szBuff0, "false") == 0)
		{
			m_dwLight = FALSE;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<zbuffer>") == 0)
	{
		m_dwRenderFlag |= RF_NOTZBUFFER;

		if (lstrcmpi(szBuff0, "true") == 0)
		{
			m_dwZEnable = D3DZB_TRUE;
			m_dwRenderFlag ^= RF_NOTZBUFFER;
		}
		else if (lstrcmpi(szBuff0, "false") == 0)
		{
			m_dwZEnable = D3DZB_FALSE;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<zwrite>") == 0)
	{
		m_dwRenderFlag |= RF_NOTZWRITE;

		if (lstrcmpi(szBuff0, "true") == 0)
		{
			m_dwZWrite = TRUE;
			m_dwRenderFlag ^= RF_NOTZWRITE;
		}
		else if (lstrcmpi(szBuff0, "false") == 0)
		{
			m_dwZWrite = FALSE;
		}

		return true;
	}

	return false;
}
#endif // end of _N3TOOL


//
//	Decode Script File
//	스크립트 파일 읽고 해석.(call parse script..)
//
#ifdef _N3TOOL
bool CN3FXPartBase::DecodeScriptFile(const char* lpPathName)
{
//	char szGamePathName[_MAX_PATH];
//	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
//	_splitpath(lpPathName, szDrive, szDir, szFName, szExt);
//	_makepath(szGamePathName, szDrive, szDir, szFName, "fxp");
//	CN3BaseFileAccess::FileNameSet(szGamePathName);
	CN3BaseFileAccess::FileNameSet(lpPathName);
		
	FILE* stream = fopen(lpPathName, "r");
	if (stream == nullptr)
		return false;

	char szLine[512] = "", szCommand[80] = "", szBuf[4][80] = { "", "", "", ""};
	char* pResult = fgets(szLine, 512, stream);
	int argsScanned = sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
	if (argsScanned <= 0)
	{
		fclose(stream);
		return false;
	}

	if (lstrcmpi(szCommand, "<n3fxpart>") != 0)
	{
		fclose(stream);
		return false;
	}

	while (!feof(stream))
	{
		char* pResult = fgets(szLine, 512, stream);
		if (pResult == nullptr)
			continue;

		ZeroMemory(szCommand, 80);
		ZeroMemory(szBuf[0], 80);
		ZeroMemory(szBuf[1], 80);
		ZeroMemory(szBuf[2], 80);
		ZeroMemory(szBuf[3], 80);

		argsScanned = sscanf(szLine, "%s %s %s %s %s", szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
		if (argsScanned > 0)
			ParseScript(szCommand, szBuf[0], szBuf[1], szBuf[2], szBuf[3]);
	}

	fclose(stream);
	Init();

	return true;
}
#endif // end of _N3TOOL


//
//	init...변수 초기화..
//
void CN3FXPartBase::Init()
{
	m_fCurrLife = 0.0f;
	m_vCurrVelocity = m_vVelocity;
	m_vCurrPos = m_vPos;
}


//
//	start...파트 구동 시작...	
//
void CN3FXPartBase::Start()
{
	m_dwState = FX_PART_STATE_LIVE;
}


//
//	stop..
//	파트 멈춤시도...
//	이함수 호출한다고 파트가 바로 끝나는건 아니다..끝내는 과정을 시작하는 거다..
//	실질적인 끝맺음은 tick에서 할껄...^^
//
void CN3FXPartBase::Stop()
{
	m_dwState = FX_PART_STATE_DYING;
	m_fCurrLife = m_fLife + m_fFadeIn;
}


//
//	Tick...
//
bool CN3FXPartBase::Tick()
{
	if(m_dwState==FX_PART_STATE_DEAD || m_dwState==FX_PART_STATE_READY) return false;

	m_fCurrLife += CN3Base::s_fSecPerFrm;
	if(m_fLife > 0.0f && m_dwState==FX_PART_STATE_LIVE)
	{
		if(m_fCurrLife >= (m_fLife+m_fFadeIn)) Stop();
	}
	if(m_dwState==FX_PART_STATE_DYING)
	{
		if(IsDead())
		{
			m_dwState = FX_PART_STATE_DEAD;
			Init();
			return false;
		}		
	}
	return true;
}


//
//
//
bool CN3FXPartBase::IsDead()
{
	return true;
}


//
//	Render..
//
void CN3FXPartBase::Render()
{
}


//
//	load...
//
bool CN3FXPartBase::Load(File& file)
{
#if defined(_DEBUG)
	int iType = m_iType;
#endif

	uint8_t	cTmp;

	file.Read(&cTmp, sizeof(uint8_t));
	m_iVersion = (int) cTmp;

	file.Read(&cTmp, sizeof(uint8_t));
	m_iBaseVersion = (int) cTmp;

	file.Read(&m_fLife, sizeof(float));
	if (m_fLife > 10.0f)
		m_fLife = 10.0f;

	if (m_iBaseVersion >= 3)
	{
		int iIDK0, iIDK1;
		file.Read(&iIDK0, sizeof(int));
		file.Read(&iIDK1, sizeof(int));
	}

	file.Read(&cTmp, sizeof(uint8_t));
	m_iType = (int) cTmp;

	file.Read(&m_vVelocity, sizeof(__Vector3));
	file.Read(&m_vAcceleration, sizeof(__Vector3));
	file.Read(&m_vRotVelocity, sizeof(__Vector3));

	file.Read(&m_bOnGround, sizeof(bool));

	file.Read(&m_vPos, sizeof(__Vector3));

	file.Read(&m_iNumTex, sizeof(int));
	file.Read(&m_fTexFPS, sizeof(float));
	file.Read(&m_pTexName, MAX_PATH);

	if (m_iBaseVersion < 2)
	{
		file.Read(&m_bAlpha, sizeof(BOOL));
		file.Read(&m_dwSrcBlend, sizeof(uint32_t));
		file.Read(&m_dwDestBlend, sizeof(uint32_t));

		file.Read(&m_fFadeOut, sizeof(float));
		file.Read(&m_fFadeIn, sizeof(float));
	}
	else // if (m_iBaseVersion >= 2)
	{
		file.Read(&m_dwSrcBlend, sizeof(uint32_t));
		file.Read(&m_dwDestBlend, sizeof(uint32_t));

		file.Read(&m_fFadeOut, sizeof(float));
		file.Read(&m_fFadeIn, sizeof(float));

		file.Read(&m_dwRenderFlag, sizeof(uint32_t));

		if (m_dwRenderFlag & RF_NOTZBUFFER) m_dwZEnable = D3DZB_FALSE;
		else m_dwZEnable = D3DZB_TRUE;
		if (m_dwRenderFlag & RF_NOTZWRITE) m_dwZWrite = FALSE;
		else m_dwZWrite = TRUE;
		if (m_dwRenderFlag & RF_DOUBLESIDED) m_dwDoubleSide = D3DCULL_NONE;
		else m_dwDoubleSide = D3DCULL_CCW;
		if (m_dwRenderFlag & RF_NOTUSELIGHT) m_dwLight = FALSE;
		else m_dwLight = TRUE;
		if (m_dwRenderFlag & RF_ALPHABLENDING) m_bAlpha = TRUE;
		else m_bAlpha = FALSE;
	}

	// TODO: implement shape_hdrname
	if (m_iBaseVersion >= 4)
		file.Seek(MAX_PATH, SEEK_CUR);

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iBaseVersion > SUPPORTED_PART_BASE_VERSION)
	{

		TRACE(
			"!!! WARNING: CN3FXPartBase::Load(%s [type=%d]) encountered base version %d (part version %d). Needs support!",
			m_pRefBundle != nullptr ? m_pRefBundle->FileName().c_str() : "<unknown>",
			iType,
			m_iBaseVersion,
			m_iVersion);
	}
#endif

	m_ppRefTex = new CN3Texture* [m_iNumTex];

	std::string FileName;
	for (int i = 0; i < m_iNumTex; i++)
	{
		FileName = fmt::format("{}{:04}.dxt", m_pTexName, i);
		m_ppRefTex[i] = CN3Base::s_MngTex.Get(FileName);
	}

	return true;
}


//
//
//
bool CN3FXPartBase::Save(File& file)
{
	uint8_t	cTmp;
	
	cTmp = (uint8_t)m_iVersion;
	file.Write(&cTmp, sizeof(uint8_t));

	cTmp = (uint8_t)m_iBaseVersion;
	file.Write(&cTmp, sizeof(uint8_t));

	file.Write(&m_fLife, sizeof(float));

	cTmp = (uint8_t)m_iType;
	file.Write(&cTmp, sizeof(uint8_t));

	file.Write(&m_vVelocity, sizeof(__Vector3));
	file.Write(&m_vAcceleration, sizeof(__Vector3));
	file.Write(&m_vRotVelocity, sizeof(__Vector3));

	file.Write(&m_bOnGround, sizeof(bool));

	file.Write(&m_vPos, sizeof(__Vector3));

	file.Write(&m_iNumTex, sizeof(int));

	file.Write(&m_fTexFPS, sizeof(float));

	file.Write(&m_pTexName, MAX_PATH);

	/* 
	if(m_iBaseVersion<2)
	{
		file.Write(&m_bAlpha, sizeof(BOOL));
		file.Write(&m_dwSrcBlend, sizeof(uint32_t));
		file.Write(&m_dwDestBlend, sizeof(uint32_t));

		file.Write(&m_fFadeOut, sizeof(float));
		file.Write(&m_fFadeIn, sizeof(float));
	}
	//*/

	// m_iBaseVersion >= 2 
	//
	file.Write(&m_dwSrcBlend, sizeof(uint32_t));
	file.Write(&m_dwDestBlend, sizeof(uint32_t));

	file.Write(&m_fFadeOut, sizeof(float));
	file.Write(&m_fFadeIn, sizeof(float));
	
	m_dwRenderFlag = RF_ALPHABLENDING | RF_NOTUSEFOG | RF_DIFFUSEALPHA | RF_NOTUSELIGHT | RF_DOUBLESIDED | RF_NOTZWRITE | RF_NOTZBUFFER; 
	if(m_dwZEnable == D3DZB_TRUE) m_dwRenderFlag ^= RF_NOTZBUFFER;
	if(m_dwZWrite == TRUE) m_dwRenderFlag ^= RF_NOTZWRITE;
	if(m_dwDoubleSide != D3DCULL_NONE) m_dwRenderFlag ^= RF_DOUBLESIDED;
	if(m_dwLight == TRUE) m_dwRenderFlag ^= RF_NOTUSELIGHT;
	if(m_bAlpha != TRUE) m_dwRenderFlag ^= RF_ALPHABLENDING;
	
	file.Write(&m_dwRenderFlag, sizeof(uint32_t));

	return true;
}

void CN3FXPartBase::Duplicate(CN3FXPartBase* pSrc)
{
	m_iVersion = pSrc->m_iVersion;
	m_fLife = pSrc->m_fLife;
	m_iType = pSrc->m_iType;

	m_vVelocity = pSrc->m_vVelocity;
	m_vAcceleration = pSrc->m_vAcceleration;
	m_vRotVelocity = pSrc->m_vRotVelocity;

	m_bOnGround = pSrc->m_bOnGround;

	m_vPos = pSrc->m_vPos;
	m_iNumTex = pSrc->m_iNumTex;
	m_fTexFPS = pSrc->m_fTexFPS;
	memcpy(m_pTexName, pSrc->m_pTexName, sizeof(m_pTexName));

	m_dwZEnable = pSrc->m_dwZEnable;
	m_dwZWrite = pSrc->m_dwZWrite;
	m_dwLight = pSrc->m_dwLight;
	m_dwDoubleSide = pSrc->m_dwDoubleSide;
	
	m_bAlpha = pSrc->m_bAlpha;
	m_dwSrcBlend = pSrc->m_dwSrcBlend;
	m_dwDestBlend = pSrc->m_dwDestBlend;

	m_fFadeOut = pSrc->m_fFadeOut;
	m_fFadeIn = pSrc->m_fFadeIn;

	m_ppRefTex = new CN3Texture* [m_iNumTex];

	std::string FileName;
	for (int i = 0; i < m_iNumTex; i++)
	{
		FileName = fmt::format("{}{:04}.dxt", m_pTexName, i);
		m_ppRefTex[i] = CN3Base::s_MngTex.Get(FileName);
	}
}

// ===== END N3Base/N3FXPartBase.cpp =====

// ===== BEGIN N3Base/N3FXPartBase.h =====
#line 1 "N3Base/N3FXPartBase.h"
﻿// N3FXPartBase.h: interface for the CN3FXPartBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3EFFECTPARTBASE_H__E11B5E1E_C4FF_4186_9645_E05DB129747B__INCLUDED_)
#define AFX_N3EFFECTPARTBASE_H__E11B5E1E_C4FF_4186_9645_E05DB129747B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"
#include "N3FXDef.h"
#include "N3Texture.h"

class CN3FXBundle;
class CN3FXPartBase : public CN3BaseFileAccess  
{
public:
	static constexpr int SUPPORTED_PART_BASE_VERSION = 4; // supported as far as reading only

//멤버 변수들..
	int				m_iVersion;			//	자료의 버전..
	int				m_iBaseVersion;

	CN3FXBundle*	m_pRefBundle;		//	내가 속한 번들의 포인터.
	CN3FXPartBase*	m_pRefPrevPart;		//	내 앞의 파트..

	int				m_iType;			//	형식타입(particle, mesh, board...)
	float			m_fLife;			//	플레이시간..

	std::string		m_strName;			//	파트이름..

	__Vector3		m_vVelocity;		//	초당 움직이는 속도..(초속도)
	__Vector3		m_vAcceleration;	//	가속도...(중력가속도를 넣고 싶으면 y = -9.8..^^
	__Vector3		m_vRotVelocity;		//	초당 회전할 수 있는 각속도..

	float			m_fCurrLife;			
	__Vector3		m_vCurrVelocity;
	__Vector3		m_vCurrPos;

	uint32_t		m_dwState;			//	현재 파트의 상태..
	__Vector3		m_vPos;				//	번들에서 파트의 위치.

	bool			m_bOnGround;		//바닥에 붙어서 갈 것인가...

	//texture..
	char			m_pTexName[MAX_PATH];
	CN3Texture**	m_ppRefTex;
	int				m_iNumTex;
	float			m_fTexFPS;

	float			m_fFadeOut;
	float			m_fFadeIn;

	uint32_t		m_dwRenderFlag;

	uint32_t		m_dwSrcBlend;
	uint32_t		m_dwDestBlend;
	BOOL			m_bAlpha;

	uint32_t		m_dwZEnable;
	uint32_t		m_dwZWrite;
	uint32_t		m_dwLight;
	uint32_t		m_dwDoubleSide;
		
protected:
	virtual bool	IsDead();

public:
	virtual float	GetGroundHeight(float x, float z) { return 0.01f; }

	virtual void Init();			// 각종 변수들을 처음 로딩한 상태로 초기화...
	virtual void Start();			// 파트 구동 시작.
	virtual void Stop();			// 파트 구동 멈춤..
	virtual bool Tick();			// ticktick...
	virtual void Render();			// 화면에 뿌리기..
	bool Load(File& file) override;	// 게임파일 불러오기.
	bool Save(File& file) override;	// 게임파일 저장하기.
	void Duplicate(CN3FXPartBase* pSrc);

#ifdef _N3TOOL
protected:
	virtual bool	ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3);	//실질적인 스크립트 해석 함수..
	
public:
	bool	DecodeScriptFile(const char* lpPathName);
#endif // end of _N3TOOL

public:
//생성자 소멸자..
	CN3FXPartBase();
	~CN3FXPartBase() override;
};

#endif // !defined(AFX_N3EFFECTPARTBASE_H__E11B5E1E_C4FF_4186_9645_E05DB129747B__INCLUDED_)

// ===== END N3Base/N3FXPartBase.h =====

// ===== BEGIN N3Base/N3FXPartBillBoard.cpp =====
#line 1 "N3Base/N3FXPartBillBoard.cpp"
﻿// N3FXPartBillBoard.cpp: implementation of the CN3FXPartBillBoard class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPartBillBoard.h"
#include "N3FXBundle.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartBillBoard::CN3FXPartBillBoard()
{
	m_iVersion = SUPPORTED_PART_VERSION;

	m_iNum = 1;
	m_fSizeX = m_fSizeY = 1.0f;

	m_iTexIdx = 0;
	m_dwCurrColor = 0xffffffff;
	
	m_pVB = nullptr;
	m_fRadius = 0.0f;

	m_bTexLoop = false;

	m_bRoateOnlyY = false;

	m_fScaleVelX = 0;
	m_fScaleVelY = 0;
	m_fScaleAccelX = 0;
	m_fScaleAccelY = 0;

	m_mtxRot.Identity();

	CreateVB();
}

CN3FXPartBillBoard::~CN3FXPartBillBoard()
{
	if(m_pVB)
	{
		delete[] m_pVB;
		m_pVB = nullptr;
	}
}


//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////


//
//
//
#ifdef _N3TOOL
bool CN3FXPartBillBoard::ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3)
{
	if (CN3FXPartBase::ParseScript(szCommand, szBuff0, szBuff1, szBuff2, szBuff3))
		return true;

	//	보드 갯수.
	if (lstrcmpi(szCommand, "<billboard_count>") == 0)
	{
		m_iNum = atoi(szBuff0);
		if (m_iNum > 0)
			CreateVB();
		return true;
	}

	//	보드 크기.
	if (lstrcmpi(szCommand, "<billboard_size>") == 0)
	{
		m_fSizeX = static_cast<float>(atof(szBuff0));
		m_fSizeY = static_cast<float>(atof(szBuff1));

		m_fCurrSizeX = m_fSizeX;
		m_fCurrSizeY = m_fSizeY;
		return true;
	}

	if (lstrcmpi(szCommand, "<tex_loop>") == 0)
	{
		if (lstrcmpi(szBuff0, "true") == 0)
			m_bTexLoop = true;
		else if (lstrcmpi(szBuff0, "false") == 0)
			m_bTexLoop = false;

		return true;
	}

	if (lstrcmpi(szCommand, "<distance>") == 0)
	{
		m_fRadius = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<Rotate_only_y>") == 0)
	{
		if (lstrcmpi(szBuff0, "true") == 0)
			m_bRoateOnlyY = true;
		else if (lstrcmpi(szBuff0, "false") == 0)
			m_bRoateOnlyY = false;
		return true;
	}

	if (lstrcmpi(szCommand, "<billboard_scale_velocity>") == 0)
	{
		m_fScaleVelX = static_cast<float>(atof(szBuff0));
		m_fScaleVelY = static_cast<float>(atof(szBuff1));

		m_fCurrScaleVelX = m_fScaleVelX;
		m_fCurrScaleVelY = m_fScaleVelY;
		return true;
	}

	if (lstrcmpi(szCommand, "<billboard_scale_acceleration>") == 0)
	{
		m_fScaleAccelX = static_cast<float>(atof(szBuff0));
		m_fScaleAccelY = static_cast<float>(atof(szBuff1));
		return true;
	}

	if (lstrcmpi(szCommand, "<billboard_Rotation>") == 0)
	{
		m_fRotBillBoardX = static_cast<float>(atof(szBuff0));
		m_fRotBillBoardY = static_cast<float>(atof(szBuff1));
		m_fRotBillBoardZ = static_cast<float>(atof(szBuff2));
		m_mtxRot.Identity();
		m_mtxRot.Rotation(
			DegreesToRadians(m_fRotBillBoardX),
			DegreesToRadians(m_fRotBillBoardY),
			DegreesToRadians(m_fRotBillBoardZ));
		//m_mtxRot.PosSet(0,0,0);
		return true;
	}

	return false;
}
#endif // end of _N3TOOL


//
//
//
void CN3FXPartBillBoard::CreateVB()
{
	if(m_pVB) delete[] m_pVB;
	m_pVB = new	__VertexXyzColorT1[m_iNum*4];

	m_vUnit[0].Set(-0.5f, 0.5f, 0.0f);
	m_vUnit[1].Set(0.5f, 0.5f, 0.0f);
	m_vUnit[2].Set(0.5f, -0.5f, 0.0f);
	m_vUnit[3].Set(-0.5f, -0.5f, 0.0f);
	
	for(int i=0;i<m_iNum;i++)
	{
		int idx = i*4;
		m_pVB[idx].Set(-0.5f, 0.5f, 0.0f, m_dwCurrColor, 0.0f, 0.0f);
		m_pVB[idx+1].Set(0.5f, 0.5f, 0.0f, m_dwCurrColor, 1.0f, 0.0f);
		m_pVB[idx+2].Set(0.5f, -0.5f, 0.0f, m_dwCurrColor, 1.0f, 1.0f);
		m_pVB[idx+3].Set(-0.5f, -0.5f, 0.0f, m_dwCurrColor, 0.0f, 1.0f);
	}
}


//
//	init...
//
void CN3FXPartBillBoard::Init()
{
	CN3FXPartBase::Init();

	m_iTexIdx = 0;
	m_dwCurrColor = 0xffffffff;

	m_vCurrPos = m_vPos;
	m_vCurrVelocity = m_vVelocity;

	m_fCurrScaleVelX = m_fScaleVelX;
	m_fCurrScaleVelY = m_fScaleVelY;

	m_fCurrSizeX = m_fSizeX;
	m_fCurrSizeY = m_fSizeY;
}


//
//
//
bool CN3FXPartBillBoard::Load(File& file)
{
	if (!CN3FXPartBase::Load(file))
		return false;

	file.Read(&m_iNum, sizeof(int));
	file.Read(&m_fSizeX, sizeof(float));
	file.Read(&m_fSizeY, sizeof(float));

	file.Read(&m_bTexLoop, sizeof(bool));
	file.Read(&m_fRadius, sizeof(float));

	if (m_iVersion >= 3)
		file.Read(&m_bRoateOnlyY, sizeof(bool));

	if (m_iVersion >= 4)
	{
		file.Read(&m_fScaleVelX, sizeof(float));
		file.Read(&m_fScaleVelY, sizeof(float));
		file.Read(&m_fScaleAccelX, sizeof(float));
		file.Read(&m_fScaleAccelY, sizeof(float));
	}

	if (m_iVersion >= 5)
		file.Read(&m_mtxRot, sizeof(m_mtxRot));

	// TODO: implement m_bOnScreen
	if (m_iVersion >= 6)
		file.Read(&m_bOnScreen, sizeof(bool));

	// TODO: implement m_bRotationRate
	if (m_iVersion >= 7)
		file.Read(&m_bRotationRate, sizeof(bool));

	if (m_iVersion >= 8)
		file.Seek(13, SEEK_CUR);

	if (m_iVersion >= 9)
		file.Seek(12, SEEK_CUR);

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iVersion > SUPPORTED_PART_VERSION)
	{
		TRACE(
			"!!! WARNING: CN3FXPartBillBoard::Load(%s) encountered version %d (base version %d). Needs support!",
			m_pRefBundle != nullptr ? m_pRefBundle->FileName().c_str() : "<unknown>",
			m_iVersion,
			m_iBaseVersion);
	}
#endif

	CreateVB();
	Init();

	return true;
}


//
//
//
bool CN3FXPartBillBoard::Save(File& file)
{
	if (!CN3FXPartBase::Save(file))
		return false;

	file.Write(&m_iNum, sizeof(int));
	file.Write(&m_fSizeX, sizeof(float));
	file.Write(&m_fSizeY, sizeof(float));

	file.Write(&m_bTexLoop, sizeof(bool));
	file.Write(&m_fRadius, sizeof(float));

	if(m_iVersion>=3) file.Write(&m_bRoateOnlyY, sizeof(bool));
	
	file.Write(&m_fScaleVelX, sizeof(float));
	file.Write(&m_fScaleVelY, sizeof(float));
	file.Write(&m_fScaleAccelX, sizeof(float));
	file.Write(&m_fScaleAccelY, sizeof(float));

	if(m_iVersion>=5) file.Write(&m_mtxRot, sizeof(m_mtxRot));

	return true;
}


//
//
//
void CN3FXPartBillBoard::Start()
{
	CN3FXPartBase::Start();

}


//
//
//
void CN3FXPartBillBoard::Stop()
{
	CN3FXPartBase::Stop();
}


//
//
//
bool CN3FXPartBillBoard::Tick()
{
	if(!CN3FXPartBase::Tick()) return false;

	if(m_bTexLoop)	m_iTexIdx = (int)(m_fCurrLife * m_fTexFPS) % m_iNumTex;
	else m_iTexIdx = (int)(m_fCurrLife * m_fTexFPS);

	if(m_fCurrLife<=m_fFadeIn)
	{
		uint32_t Alpha = (uint32_t)(255.0f * m_fCurrLife / m_fFadeIn);
		m_dwCurrColor = (Alpha<<24) + 0x00ffffff;		
	}
	else m_dwCurrColor = 0xffffffff;

	if(m_dwState==FX_PART_STATE_DYING)
	{
		float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
		if(m_fCurrLife >= TotalLife)
		{
			m_dwCurrColor = 0x00ffffff;
		}
		else
		{
			uint32_t Alpha = (uint32_t)(255.0f * (TotalLife - m_fCurrLife) / m_fFadeOut);
			m_dwCurrColor = (Alpha<<24) + 0x00ffffff;
		}
	}

	//위치에 관한 틱틱...m_vCurrPos
	m_vCurrVelocity += m_vAcceleration*CN3Base::s_fSecPerFrm;
	m_vCurrPos += m_vCurrVelocity*CN3Base::s_fSecPerFrm;

	m_fCurrScaleVelX += m_fScaleAccelX * CN3Base::s_fSecPerFrm;
	m_fCurrScaleVelY += m_fScaleAccelY * CN3Base::s_fSecPerFrm;

	m_fCurrSizeX += m_fCurrScaleVelX * CN3Base::s_fSecPerFrm;
	m_fCurrSizeY += m_fCurrScaleVelY * CN3Base::s_fSecPerFrm;

	//	m_vUnit[0].Set(-0.5f, 0.5f, 0.0f);
	//m_vUnit[1].Set(0.5f, 0.5f, 0.0f);
	//m_vUnit[2].Set(0.5f, -0.5f, 0.0f);
	//m_vUnit[3].Set(-0.5f, -0.5f, 0.0f);

	m_vUnit[0].x = (-0.5f) * m_fCurrSizeX;
	m_vUnit[1].x = (0.5f) * m_fCurrSizeX;
	m_vUnit[2].x = (0.5f) * m_fCurrSizeX;
	m_vUnit[3].x = (-0.5f) * m_fCurrSizeX;

	m_vUnit[0].y = (0.5f) * m_fCurrSizeY;
	m_vUnit[1].y = (0.5f) * m_fCurrSizeY;
	m_vUnit[2].y = (-0.5f) * m_fCurrSizeY;
	m_vUnit[3].y = (-0.5f) * m_fCurrSizeY;
	
	m_vUnit[0].z = 0.0f;
	m_vUnit[1].z = 0.0f;
	m_vUnit[2].z = 0.0f;
	m_vUnit[3].z = 0.0f;

	m_vUnit[0] *= m_mtxRot;
	m_vUnit[1] *= m_mtxRot;
	m_vUnit[2] *= m_mtxRot;
	m_vUnit[3] *= m_mtxRot;

	return true;
}


//
//
//
bool CN3FXPartBillBoard::IsDead()
{
	float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
	if(m_fCurrLife >= TotalLife) return true;
	return false;
}


//
//	render...
//	일단은 파티클 하나씩 그리고....
//	나중에는 같은 텍스쳐 쓰는 것들끼리 묶어서 그리자...
//
void CN3FXPartBillBoard::Render()
{
	if(m_iTexIdx >= m_iNumTex) return;

	//회전...
	__Matrix44 mtxRotZ;
	mtxRotZ.Identity();
	mtxRotZ.RotationZ(m_fCurrLife*m_vRotVelocity.x);

	if(!m_bRoateOnlyY)
	{
		//위치지정 & 나를 바라보게 셋팅..
		__Matrix44 mtxVI;
		mtxVI = s_CameraData.mtxViewInverse;
		__Vector3 vpp;
		vpp = mtxVI.Pos();
		mtxVI.PosSet(0,0,0);
	
		__Vector3 AbsoluteCurrPos = Rotate2AbsolutePos(m_vCurrPos);

		__Vector3 vRadiusPos = s_CameraData.vEye - (AbsoluteCurrPos + m_pRefBundle->m_vPos);
		if(vRadiusPos.Magnitude() <= m_fRadius)
		{
			vRadiusPos += (s_CameraData.vAt-s_CameraData.vEye) * (s_CameraData.fNP+0.1f);
		}
		else
		{
			vRadiusPos.Normalize();
			vRadiusPos *= m_fRadius;
		}
		
		__Vector3 vCalPos = AbsoluteCurrPos + m_pRefBundle->m_vPos + vRadiusPos;

		if(m_pRefBundle->m_bDependScale)
		{
			__Vector3 vUnit[4];
			for(int i=0;i<4;i++)
			{
				vUnit[i].x = m_vUnit[i].x * m_pRefBundle->m_fTargetScale;
				vUnit[i].y = m_vUnit[i].y * m_pRefBundle->m_fTargetScale;
				vUnit[i].z = 0.0f;
				vUnit[i] *= mtxRotZ;
			}

			for(int i=0;i<m_iNum;i++)
			{
				int idx = i*4;
				
				m_pVB[idx] = (vUnit[0] * mtxVI) + vCalPos;
				m_pVB[idx+1] = (vUnit[1] * mtxVI) + vCalPos;
				m_pVB[idx+2] = (vUnit[2] * mtxVI) + vCalPos;
				m_pVB[idx+3] = (vUnit[3] * mtxVI) + vCalPos;

				if(m_bOnGround)
				{
					float GroundHeight = GetGroundHeight(vCalPos.x, vCalPos.z);
					float NewY = GroundHeight - (vCalPos.y - vRadiusPos.y) + vUnit[0].y;


					m_pVB[idx].y = m_pVB[idx].y + NewY;
					m_pVB[idx+1].y = m_pVB[idx+1].y + NewY;
					m_pVB[idx+2].y = m_pVB[idx+2].y + NewY;
					m_pVB[idx+3].y = m_pVB[idx+3].y + NewY;
				}

				m_pVB[idx].color = m_dwCurrColor;
				m_pVB[idx+1].color = m_dwCurrColor;
				m_pVB[idx+2].color = m_dwCurrColor;
				m_pVB[idx+3].color = m_dwCurrColor;
			}
		}
		else
		{
			for(int i=0;i<m_iNum;i++)
			{
				int idx = i*4;

				m_pVB[idx] = (m_vUnit[0] * mtxRotZ * mtxVI) + vCalPos;
				m_pVB[idx+1] = (m_vUnit[1] * mtxRotZ * mtxVI) + vCalPos;
				m_pVB[idx+2] = (m_vUnit[2] * mtxRotZ * mtxVI) + vCalPos;
				m_pVB[idx+3] = (m_vUnit[3] * mtxRotZ * mtxVI) + vCalPos;

				if(m_bOnGround)
				{
					float GroundHeight = GetGroundHeight(vCalPos.x, vCalPos.z);
					float NewY = GroundHeight - (vCalPos.y - vRadiusPos.y) + m_vUnit[0].y;

					m_pVB[idx].y = m_pVB[idx].y + NewY;
					m_pVB[idx+1].y = m_pVB[idx+1].y + NewY;
					m_pVB[idx+2].y = m_pVB[idx+2].y + NewY;
					m_pVB[idx+3].y = m_pVB[idx+3].y + NewY;
				}

				m_pVB[idx].color = m_dwCurrColor;
				m_pVB[idx+1].color = m_dwCurrColor;
				m_pVB[idx+2].color = m_dwCurrColor;
				m_pVB[idx+3].color = m_dwCurrColor;
			}
		}
	}
	else
	{
		//위치지정 & 나를 바라보게 셋팅..
		__Vector3 AbsoluteCurrPos = Rotate2AbsolutePos(m_vCurrPos);
		__Vector3 vRadiusPos = s_CameraData.vEye - (AbsoluteCurrPos + m_pRefBundle->m_vPos);

		float ang;
		if(vRadiusPos.z==0.0f && vRadiusPos.x >= 0) ang =  __PI*(-0.5f);
		else if(vRadiusPos.z==0.0f && vRadiusPos.x < 0) ang =  __PI*(0.5f);
		else ang = -atan2(vRadiusPos.x, -vRadiusPos.z);

		__Matrix44 mtxRot;
		mtxRot.Identity();
		mtxRot.RotationY(ang);
		
		if(vRadiusPos.Magnitude() <= m_fRadius)
		{
			vRadiusPos += (s_CameraData.vAt-s_CameraData.vEye) * (s_CameraData.fNP+0.1f);
			vRadiusPos.y = 0;
		}
		else
		{
			vRadiusPos.Normalize();
			vRadiusPos *= m_fRadius;
			vRadiusPos.y = 0;
		}

		__Vector3 vCalPos = AbsoluteCurrPos + m_pRefBundle->m_vPos + vRadiusPos;

		if(m_pRefBundle->m_bDependScale)
		{
			__Vector3 vUnit[4];
			for(int i=0;i<4;i++)
			{
				//vUnit[i].x = m_vUnit[i].x * m_pRefBundle->m_vTargetScale.x;
				//vUnit[i].y = m_vUnit[i].y * m_pRefBundle->m_vTargetScale.y;
				vUnit[i].x = m_vUnit[i].x * m_pRefBundle->m_fTargetScale;
				vUnit[i].y = m_vUnit[i].y * m_pRefBundle->m_fTargetScale;
				vUnit[i].z = 0.0f;
				vUnit[i] *= mtxRotZ;
			}

			for(int i=0;i<m_iNum;i++)
			{
				int idx = i*4;

				m_pVB[idx] = (vUnit[0] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+1] = (vUnit[1] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+2] = (vUnit[2] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+3] = (vUnit[3] * mtxRotZ * mtxRot) + vCalPos;

				if(m_bOnGround)
				{
					float GroundHeight = GetGroundHeight(vCalPos.x, vCalPos.z);
				
					m_pVB[idx].y = m_pVB[idx].y - m_pVB[idx+3].y + GroundHeight;
					m_pVB[idx+1].y = m_pVB[idx+1].y - m_pVB[idx+2].y + GroundHeight;					
					m_pVB[idx+2].y = GroundHeight;
					m_pVB[idx+3].y = GroundHeight;					
				}
				
				m_pVB[idx].color = m_dwCurrColor;
				m_pVB[idx+1].color = m_dwCurrColor;
				m_pVB[idx+2].color = m_dwCurrColor;
				m_pVB[idx+3].color = m_dwCurrColor;
			}
		}
		else
		{
			for(int i=0;i<m_iNum;i++)
			{
				int idx = i*4;

				m_pVB[idx] = (m_vUnit[0] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+1] = (m_vUnit[1] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+2] = (m_vUnit[2] * mtxRotZ * mtxRot) + vCalPos;
				m_pVB[idx+3] = (m_vUnit[3] * mtxRotZ * mtxRot) + vCalPos;

				if(m_bOnGround)
				{
					float GroundHeight = GetGroundHeight(vCalPos.x, vCalPos.z);

					m_pVB[idx].y = m_pVB[idx].y - m_pVB[idx+3].y + GroundHeight;
					m_pVB[idx+1].y = m_pVB[idx+1].y - m_pVB[idx+2].y + GroundHeight;					
					m_pVB[idx+2].y = GroundHeight;
					m_pVB[idx+3].y = GroundHeight;					
				}

				
				m_pVB[idx].color = m_dwCurrColor;
				m_pVB[idx+1].color = m_dwCurrColor;
				m_pVB[idx+2].color = m_dwCurrColor;
				m_pVB[idx+3].color = m_dwCurrColor;
			}
		}
	}

	if(m_bAlpha) // Alpha 사용
	{
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_dwDestBlend;
			pAP->dwBlendSrc			= m_dwSrcBlend;
			pAP->dwFVF				= FVF_XYZCOLORT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexXyzColorT1);
			pAP->fCameraDistance	= CameraDist();

			if(m_ppRefTex[m_iTexIdx]) 
				pAP->lpTex = m_ppRefTex[m_iTexIdx]->Get();
			else pAP->lpTex = nullptr;

			__Matrix44 mtxWorld;
			mtxWorld.Identity();
			pAP->MtxWorld = mtxWorld;
			pAP->nRenderFlags = m_dwRenderFlag;
			pAP->ePrimitiveType		= D3DPT_TRIANGLEFAN;
			pAP->nPrimitiveCount	= m_iNum*2;
			pAP->nVertexCount		= m_iNum*4;
			pAP->pVertices			= &(m_pVB[0]);
			pAP->pwIndices			= nullptr;
		}

		return; // 렌더링 안하지롱.
	}
	else 
	{
		CN3Base::s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

		if(m_ppRefTex[m_iTexIdx]) 
			CN3Base::s_lpD3DDev->SetTexture(0, m_ppRefTex[m_iTexIdx]->Get());
		else CN3Base::s_lpD3DDev->SetTexture(0, nullptr);

		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );		
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

		DWORD dwCullMode, dwZWriteEnable, dwZBufferEnable, dwLight, dwAlpha;
		s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlpha);
		s_lpD3DDev->GetRenderState( D3DRS_ZWRITEENABLE, &dwZWriteEnable);
		s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZBufferEnable );
		s_lpD3DDev->GetRenderState( D3DRS_CULLMODE, &dwCullMode );
		s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLight );

		if(m_bAlpha != dwAlpha)
		{
			s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha);
			s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
			s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );
		}
		if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, m_dwZEnable);
		if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, m_dwZWrite);
		if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, m_dwLight);
		if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, m_dwDoubleSide);

		for(int i=0;i<m_iNum;i++)
			HRESULT hr = CN3Base::s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLEFAN, 2, &(m_pVB[i*4]), sizeof(__VertexXyzColorT1));

		if(m_bAlpha != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
		if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZBufferEnable);
		if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);
		if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
		if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCullMode);
	}
}


float CN3FXPartBillBoard::CameraDist()
{
	__Vector3 vA = m_pVB[1] - m_pVB[0];
	__Vector3 vB = m_pVB[3] - m_pVB[0];
	__Vector3 vN;
	vN.Cross(vA, vB);
	vN.Normalize();

	float D = -(vN.x*m_pVB[0].x + vN.y*m_pVB[0].y + vN.z*m_pVB[0].z);

	return (vN.x*s_CameraData.vEye.x + vN.y*s_CameraData.vEye.y + vN.z*s_CameraData.vEye.z + D);
}

__Vector3 CN3FXPartBillBoard::Rotate2AbsolutePos(__Vector3 vRelativePos)
{
	__Vector3 vAbsolutePos(0,0,1);
	__Vector3 vAxisZ(0,0,1);
	__Vector3 vDirAxis;

	__Quaternion qtRot;

	vDirAxis.Cross(vAxisZ, m_pRefBundle->m_vDir);
	int tmp;
	tmp = (int)(vDirAxis.x*10000.0f);
	vDirAxis.x = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.y*10000.0f);
	vDirAxis.y = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.z*10000.0f);
	vDirAxis.z = (float)(tmp)/10000.0f;

	if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) vDirAxis.Set(0,1,0);

	float fDirAng = acos(vAxisZ.Dot(m_pRefBundle->m_vDir));

	qtRot.RotationAxis(vDirAxis, fDirAng);

	__Matrix44 RotMtx = qtRot;

	vAbsolutePos = vRelativePos * RotMtx;

	return vAbsolutePos;
}

void CN3FXPartBillBoard::Duplicate(CN3FXPartBillBoard* pSrc)
{
	if(!pSrc) return;

	CN3FXPartBase::Duplicate(pSrc);

	m_iNum = pSrc->m_iNum;
	m_fSizeX = pSrc->m_fSizeX;
	m_fSizeY = pSrc->m_fSizeY;

	m_fCurrSizeX = m_fSizeX;
	m_fCurrSizeY = m_fSizeY;

	m_bTexLoop = pSrc->m_bTexLoop;
	m_fRadius = pSrc->m_fRadius;
	m_bRoateOnlyY = pSrc->m_bRoateOnlyY;

	m_fScaleVelX = pSrc->m_fScaleVelX;
	m_fScaleVelY = pSrc->m_fScaleVelY;
	m_fScaleAccelX = pSrc->m_fScaleAccelX;
	m_fScaleAccelY = pSrc->m_fScaleAccelY;

	m_fCurrScaleVelX = m_fScaleVelX;
	m_fCurrScaleVelY = m_fScaleVelY;
	m_mtxRot = pSrc->m_mtxRot;
	
	CreateVB();
	Init();

	return;
}

// ===== END N3Base/N3FXPartBillBoard.cpp =====

// ===== BEGIN N3Base/N3FXPartBillBoard.h =====
#line 1 "N3Base/N3FXPartBillBoard.h"
﻿// N3FXPartBillBoard.h: interface for the CN3FXPartBillBoard class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTBILLBOARD_H__
#define __N3FXPARTBILLBOARD_H__

#include "N3FXPartBase.h"

class CN3FXPartBillBoard : public CN3FXPartBase  
{
public:
	static constexpr int SUPPORTED_PART_VERSION = 9; // supported as far as reading only

	int					m_iNum;				//	보드의 갯수.
	float				m_fSizeX;			//	보드의 크기
	float				m_fSizeY;
	bool				m_bTexLoop;
	
	int					m_iTexIdx;
	uint32_t				m_dwCurrColor;

	float				m_fRadius;

	__VertexXyzColorT1*	m_pVB;

	bool				m_bRoateOnlyY;

	float				m_fScaleVelX;
	float				m_fScaleVelY;
	float				m_fScaleAccelX;
	float				m_fScaleAccelY;

	float				m_fCurrScaleVelX;
	float				m_fCurrScaleVelY;

	float				m_fCurrSizeX;			//	보드의 크기
	float				m_fCurrSizeY;

	__Matrix44			m_mtxRot;
	float				m_fRotBillBoardX;
	float				m_fRotBillBoardY;
	float				m_fRotBillBoardZ;

	// N3FXPartBillBoard needs implementation of these methods
	bool				m_bRotationRate;	//	회전 속도 적용 여부
	bool				m_bOnScreen;		//	화면에 보이는지 여부, true면 화면에 보이는 것, false면 화면에 보이지 않는 것
	// N3FXPartBillBoard needs implementation of these methods

protected:
	__Vector3			m_vUnit[4];

protected:
	void CreateVB();
	bool IsDead() override;
	__Vector3 Rotate2AbsolutePos(__Vector3 vRelativePos);
	float CameraDist();

public:
	void Init() override;			// 각종 변수들을 처음 로딩한 상태로 초기화...
	void Start() override;			// 파트 구동 시작.
	void Stop() override;			// 파트 구동 멈춤..
	bool Tick() override;			// ticktick...
	void Render() override;			// 화면에 뿌리기..
	bool Load(File& file) override;	// 게임파일 불러오기.
	bool Save(File& file) override;	// 게임파일 저장오기.
	void Duplicate(CN3FXPartBillBoard* pSrc);

	void SetScale(float size) { m_fSizeX = m_fCurrSizeX = size; m_fSizeY = m_fCurrSizeY = size; }
	void SetRadius(float rad) { m_fRadius = rad; }
	
public:
	CN3FXPartBillBoard();
	~CN3FXPartBillBoard() override;

#ifdef _N3TOOL
	bool	ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3);
#endif // end of _N3TOOL
};

#endif // !defined(AFX_N3FXPARTBILLBOARD_H__3449DE4C_B687_459A_BF2C_A1FB98895B17__INCLUDED_)

// ===== END N3Base/N3FXPartBillBoard.h =====

// ===== BEGIN N3Base/N3FXPartBottomBoard.cpp =====
#line 1 "N3Base/N3FXPartBottomBoard.cpp"
﻿// N3FXPartBottomBoard.cpp: implementation of the CN3FXPartBillBoard class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPartBottomBoard.h"
#include "N3FXBundle.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartBottomBoard::CN3FXPartBottomBoard()
{
	m_iVersion = SUPPORTED_PART_VERSION;
	m_fSizeX = m_fSizeZ = 1.0f;

	m_iTexIdx = 0;
	m_dwCurrColor = 0xffffffff;

	m_bTexLoop = false;

	m_pVB = nullptr;
	m_vUnit = nullptr;

	m_fScaleVelX = 0.0f;
	m_fScaleVelZ = 0.0f;
	m_fScaleAccelX = 0.0f;
	m_fScaleAccelZ = 0.0f;
	CreateVB();

	m_fGap = 0.0f;
}

CN3FXPartBottomBoard::~CN3FXPartBottomBoard()
{
	if(m_pVB)
	{
		delete[] m_pVB;
		m_pVB = nullptr;
	}

	if(m_vUnit)
	{
		delete[] m_vUnit;
		m_vUnit = nullptr;
	}
}


//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////


//
//
//
#ifdef _N3TOOL
bool CN3FXPartBottomBoard::ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3)
{
	if (CN3FXPartBase::ParseScript(szCommand, szBuff0, szBuff1, szBuff2, szBuff3))
		return true;

	//	보드 크기.
	if (lstrcmpi(szCommand, "<ground_size>") == 0)
	{
		m_fCurrSizeX = m_fSizeX = static_cast<float>(atof(szBuff0));
		m_fCurrSizeZ = m_fSizeZ = static_cast<float>(atof(szBuff1));
/*
		for(int i=0;i<NUM_VERTEX_BOTTOM;i++)
		{
			m_vUnit[i].x *= m_fSizeX;
			m_vUnit[i].z *= m_fSizeZ;
		}
*/
		return true;
	}

	if (lstrcmpi(szCommand, "<tex_loop>") == 0)
	{
		if (lstrcmpi(szBuff0, "true") == 0) m_bTexLoop = true;
		else if (lstrcmpi(szBuff0, "false") == 0) m_bTexLoop = false;
		return true;
	}

	if (lstrcmpi(szCommand, "<ground_scale_velocity>") == 0)
	{
		m_fScaleVelX = static_cast<float>(atof(szBuff0));
		m_fScaleVelZ = static_cast<float>(atof(szBuff1));
		return true;
	}

	if (lstrcmpi(szCommand, "<ground_scale_acceleration>") == 0)
	{
		m_fScaleAccelX = static_cast<float>(atof(szBuff0));
		m_fScaleAccelZ = static_cast<float>(atof(szBuff1));
		return true;
	}

	if (lstrcmpi(szCommand, "<ground_gap>") == 0)
	{
		m_fGap = static_cast<float>(atof(szBuff0));
		return true;
	}

	return false;
}
#endif // end of _N3TOOL


//
//
//
void CN3FXPartBottomBoard::CreateVB()
{
	if(m_vUnit)
	{
		delete[] m_vUnit;
		m_vUnit = nullptr;
	}
	m_vUnit = new __Vector3[NUM_VERTEX_BOTTOM];

	m_vUnit[0].Set(0.0f, 0.1f, 0.0f);
	m_vUnit[9].Set(-0.5f, 0.1f, -0.5f);
	m_vUnit[8].Set(0.0f, 0.1f, -0.5f);
	m_vUnit[7].Set(0.5f, 0.1f, -0.5f);
	m_vUnit[6].Set(0.5f, 0.1f, 0.0f);
	m_vUnit[5].Set(0.5f, 0.1f, 0.5f);
	m_vUnit[4].Set(0.0f, 0.1f, 0.5f);
	m_vUnit[3].Set(-0.5f, 0.1f, 0.5f);
	m_vUnit[2].Set(-0.5f, 0.1f, 0.0f);
	m_vUnit[1] = m_vUnit[9];
	
	if(m_pVB)
	{
		delete[] m_pVB;
		m_pVB = nullptr;
	}
	m_pVB = new	__VertexXyzColorT1[NUM_VERTEX_BOTTOM];
	
	m_pVB[0].Set(-1.0f, 0.1f, -1.0f, m_dwCurrColor, 0.5f, 0.5f);
	m_pVB[9].Set(-1.5f, 0.1f, -1.5f, m_dwCurrColor, 0.0f, 1.0f);
	m_pVB[8].Set(-1.0f, 0.1f, -1.5f, m_dwCurrColor, 0.5f, 1.0f);
	m_pVB[7].Set(-1.5f, 0.1f, -1.5f, m_dwCurrColor, 1.0f, 1.0f);
	m_pVB[6].Set(-1.5f, 0.1f, -1.0f, m_dwCurrColor, 1.0f, 0.5f);
	m_pVB[5].Set(-1.5f, 0.1f, -1.5f, m_dwCurrColor, 1.0f, 0.0f);
	m_pVB[4].Set(-1.0f, 0.1f, -1.5f, m_dwCurrColor, 0.5f, 0.0f);
	m_pVB[3].Set(-1.5f, 0.1f, -1.5f, m_dwCurrColor, 0.0f, 0.0f);
	m_pVB[2].Set(-1.5f, 0.1f, -1.0f, m_dwCurrColor, 0.0f, 0.5f);
	m_pVB[1] = m_pVB[9];

	for(int i=0;i<NUM_VERTEX_BOTTOM;i++)
	{
		m_vUnit[i].y = GetGroundHeight(m_vUnit[i].x, m_vUnit[i].z);
		m_pVB[i].y = GetGroundHeight(m_pVB[i].x, m_pVB[i].z);
	}
}


//
//	init...
//
void CN3FXPartBottomBoard::Init()
{
	CN3FXPartBase::Init();

	m_iTexIdx = 0;
	m_dwCurrColor = 0xffffffff;
	m_vCurrPos = m_vPos;
	m_vCurrVelocity = m_vVelocity;

	m_fCurrScaleVelX = m_fScaleVelX;
	m_fCurrScaleVelZ = m_fScaleVelZ;

	m_fCurrSizeX = m_fSizeX;
	m_fCurrSizeZ = m_fSizeZ;
}


//
//
//
bool CN3FXPartBottomBoard::Load(File& file)
{
	if (!CN3FXPartBase::Load(file))
		return false;

	file.Read(&m_fSizeX, sizeof(float));
	file.Read(&m_fSizeZ, sizeof(float));

	file.Read(&m_fScaleVelX, sizeof(float));
	file.Read(&m_fScaleVelZ, sizeof(float));

	file.Read(&m_bTexLoop, sizeof(bool));

	if (m_iVersion >= 1)
		file.Read(&m_fGap, sizeof(float));

	// TODO: implement m_bNew_Uv
	if (m_iVersion >= 2)
		file.Read(&m_bNew_Uv, sizeof(bool));

	// TODO: implement m_bHdr_uv
	if (m_iVersion >= 3)
		file.Read(&m_bHdr_uv, sizeof(bool));

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iVersion > SUPPORTED_PART_VERSION)
	{
		TRACE(
			"!!! WARNING: CN3FXPartBottomBoard::Load(%s) encountered version %d (base version %d). Needs support!",
			m_pRefBundle != nullptr ? m_pRefBundle->FileName().c_str() : "<unknown>",
			m_iVersion,
			m_iBaseVersion);
	}
#endif

	CreateVB();
	Init();

	return true;
}


//
//
//
bool CN3FXPartBottomBoard::Save(File& file)
{
	if (!CN3FXPartBase::Save(file))
		return false;

	file.Write(&m_fSizeX, sizeof(float));
	file.Write(&m_fSizeZ, sizeof(float));

	file.Write(&m_fScaleVelX, sizeof(float));
	file.Write(&m_fScaleVelZ, sizeof(float));

	file.Write(&m_bTexLoop, sizeof(bool));	
	
	//version 1....
	file.Write(&m_fGap, sizeof(float));	
	return true;
}


//
//
//
void CN3FXPartBottomBoard::Start()
{
	CN3FXPartBase::Start();
}


//
//
//
void CN3FXPartBottomBoard::Stop()
{
	CN3FXPartBase::Stop();
}


//
//
//
bool CN3FXPartBottomBoard::Tick()
{
	if(!CN3FXPartBase::Tick()) return false;

	if(m_bTexLoop)	m_iTexIdx = (int)(m_fCurrLife * m_fTexFPS) % m_iNumTex;
	else m_iTexIdx = (int)(m_fCurrLife * m_fTexFPS);

	if(m_fCurrLife<=m_fFadeIn)
	{
		uint32_t Alpha = (uint32_t)(255.0f * m_fCurrLife / m_fFadeIn);
		m_dwCurrColor = (Alpha<<24) + 0x00ffffff;		
	}
	else m_dwCurrColor = 0xffffffff;

	if(m_dwState==FX_PART_STATE_DYING)
	{
		float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
		if(m_fCurrLife >= TotalLife)
		{
			m_dwCurrColor = 0x00ffffff;
		}
		else
		{
			uint32_t Alpha = (uint32_t)(255.0f * (TotalLife - m_fCurrLife) / m_fFadeOut);
			m_dwCurrColor = (Alpha<<24) + 0x00ffffff;
		}
	}

	//위치이동..
	m_vCurrVelocity += m_vAcceleration*CN3Base::s_fSecPerFrm;
	m_vCurrPos += m_vCurrVelocity*CN3Base::s_fSecPerFrm;

	//회전...
	__Matrix44 mtxRot;
	mtxRot.Identity();
	mtxRot.RotationY(m_fCurrLife*m_vRotVelocity.y);

	//스케일변환..
	m_fCurrScaleVelX += m_fScaleAccelX*CN3Base::s_fSecPerFrm;
	m_fCurrScaleVelZ += m_fScaleAccelZ*CN3Base::s_fSecPerFrm;
	m_fCurrSizeX += m_fCurrScaleVelX*CN3Base::s_fSecPerFrm;
	m_fCurrSizeZ += m_fCurrScaleVelZ*CN3Base::s_fSecPerFrm;

	if(m_fCurrSizeX < 0.0f) m_fCurrSizeX = 0.0f;
	if(m_fCurrSizeZ < 0.0f) m_fCurrSizeZ = 0.0f;

	__Vector3 vTmp;
	if(m_pRefBundle->m_bDependScale)
	{
		for(int i=0;i<NUM_VERTEX_BOTTOM;i++)
		{
			vTmp = m_pVB[i];
			m_pVB[i].x = m_vUnit[i].x * m_fCurrSizeX * m_pRefBundle->m_fTargetScale;
			m_pVB[i].z = m_vUnit[i].z * m_fCurrSizeZ * m_pRefBundle->m_fTargetScale;
			m_pVB[i] *= mtxRot;
			m_pVB[i].x += m_pRefBundle->m_vPos.x + m_vCurrPos.x;
			m_pVB[i].z += m_pRefBundle->m_vPos.z + m_vCurrPos.z;

			if(vTmp.x != m_pVB[i].x || vTmp.z != m_pVB[i].z) m_pVB[i].y = GetGroundHeight(m_pVB[i].x, m_pVB[i].z) + m_fGap;
			else m_pVB[i].y = vTmp.y;

			m_pVB[i].color = m_dwCurrColor;
		}
	}
	else
	{
		for(int i=0;i<NUM_VERTEX_BOTTOM;i++)
		{
			vTmp = m_pVB[i];
			m_pVB[i].x = m_vUnit[i].x * m_fCurrSizeX;
			m_pVB[i].z = m_vUnit[i].z * m_fCurrSizeZ;
			m_pVB[i] *= mtxRot;
			m_pVB[i].x += m_pRefBundle->m_vPos.x + m_vCurrPos.x;
			m_pVB[i].z += m_pRefBundle->m_vPos.z + m_vCurrPos.z;
			
			if(vTmp.x != m_pVB[i].x || vTmp.z != m_pVB[i].z) m_pVB[i].y = GetGroundHeight(m_pVB[i].x, m_pVB[i].z) + m_fGap;
			else m_pVB[i].y = vTmp.y;

			m_pVB[i].color = m_dwCurrColor;
		}
	}
	return true;
}


//
//
//
bool CN3FXPartBottomBoard::IsDead()
{
	float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
	if(m_fCurrLife >= TotalLife) return true;
	return false;
}


//
//	render...
//	일단은 파티클 하나씩 그리고....
//	나중에는 같은 텍스쳐 쓰는 것들끼리 묶어서 그리자...
//
void CN3FXPartBottomBoard::Render()
{
	if(m_iTexIdx >= m_iNumTex) return;

	if(m_bAlpha) // Alpha 사용
	{
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_dwDestBlend;
			pAP->dwBlendSrc			= m_dwSrcBlend;
			pAP->dwFVF				= FVF_XYZCOLORT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexXyzColorT1);
			pAP->fCameraDistance	= (m_pVB[0] - s_CameraData.vEye).Magnitude();
			
			if(m_ppRefTex[m_iTexIdx]) pAP->lpTex = m_ppRefTex[m_iTexIdx]->Get();
			else pAP->lpTex = nullptr;

			__Matrix44 mtxWorld;
			mtxWorld.Identity();
			pAP->MtxWorld = mtxWorld;
			pAP->nRenderFlags = m_dwRenderFlag;
			pAP->ePrimitiveType		= D3DPT_TRIANGLEFAN;
			pAP->nPrimitiveCount	= 8;
			pAP->nVertexCount		= NUM_VERTEX_BOTTOM;
			pAP->pVertices			= &(m_pVB[0]);
			pAP->pwIndices			= nullptr;
		}

		return; // 렌더링 안하지롱.
	}
	else 
	{
		CN3Base::s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

		if(m_ppRefTex[m_iTexIdx]) 
			CN3Base::s_lpD3DDev->SetTexture(0, m_ppRefTex[m_iTexIdx]->Get());
		else CN3Base::s_lpD3DDev->SetTexture(0, nullptr);

		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );		
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

		DWORD dwCullMode, dwZWriteEnable, dwZBufferEnable, dwLight, dwAlpha;
		s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlpha);
		s_lpD3DDev->GetRenderState( D3DRS_ZWRITEENABLE, &dwZWriteEnable);
		s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZBufferEnable );
		s_lpD3DDev->GetRenderState( D3DRS_CULLMODE, &dwCullMode );
		s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLight );

		if(m_bAlpha != dwAlpha)
		{
			s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha);
			s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
			s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );
		}
		if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, m_dwZEnable);
		if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, m_dwZWrite);
		if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, m_dwLight);
		if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, m_dwDoubleSide);

		HRESULT hr = CN3Base::s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLEFAN, 8, m_pVB, sizeof(__VertexXyzColorT1));

		if(m_bAlpha != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
		if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZBufferEnable);
		if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);
		if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
		if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCullMode);
	}
}

void CN3FXPartBottomBoard::Duplicate(CN3FXPartBottomBoard* pSrc)
{
	CN3FXPartBase::Duplicate(pSrc);

	m_fSizeX = pSrc->m_fSizeX;
	m_fSizeZ = pSrc->m_fSizeZ;

	m_fScaleVelX = pSrc->m_fScaleVelX;
	m_fScaleVelZ = pSrc->m_fScaleVelZ;

	m_fScaleAccelX = pSrc->m_fScaleAccelX;
	m_fScaleAccelZ = pSrc->m_fScaleAccelZ;

	m_bTexLoop = pSrc->m_bTexLoop;

	m_fGap = pSrc->m_fGap;
	
	CreateVB();
	Init();
	return;
}

// ===== END N3Base/N3FXPartBottomBoard.cpp =====

// ===== BEGIN N3Base/N3FXPartBottomBoard.h =====
#line 1 "N3Base/N3FXPartBottomBoard.h"
﻿// N3FXPartBottomBoard.h: interface for the CN3FXPartBottomBoard class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTBOTTOMBOARD_H__
#define __N3FXPARTBOTTOMBOARD_H__

#include "N3BaseFileAccess.h"
#include "N3FXDef.h"
#include "N3FXPartBase.h"

//
//	바닥에 그리는 판때기..
//	triangle fan으로 그리고 삼각형 여덟개로 그린다..
//

class CN3FXPartBottomBoard : public CN3FXPartBase  
{
public:
	static constexpr int SUPPORTED_PART_VERSION = 3; // supported as far as reading only

	float				m_fSizeX;			//	보드의 크기
	float				m_fSizeZ;

	bool				m_bTexLoop;
	int					m_iTexIdx;

	uint32_t				m_dwCurrColor;

	__VertexXyzColorT1*	m_pVB;

	float				m_fScaleVelX;
	float				m_fScaleVelZ;
	float				m_fScaleAccelX;
	float				m_fScaleAccelZ;

	float				m_fCurrScaleVelX;
	float				m_fCurrScaleVelZ;

	float				m_fCurrSizeX;			//	보드의 크기
	float				m_fCurrSizeZ;

	float				m_fGap;
	// N3FXPartBottomBoard needs implementation of these methods
	bool				m_bNew_Uv;
	bool				m_bHdr_uv;
	// N3FXPartBottomBoard needs implementation of these methods

protected:
	__Vector3*			m_vUnit;

protected:
	void CreateVB();
	bool IsDead() override;

public:
	void Init() override;			// 각종 변수들을 처음 로딩한 상태로 초기화...
	void Start() override;			// 파트 구동 시작.
	void Stop() override;			// 파트 구동 멈춤..
	bool Tick() override;			// ticktick...
	void Render() override;			// 화면에 뿌리기..
	bool Load(File& file) override;	// 게임파일 불러오기.
	bool Save(File& file) override;	// 게임파일 저장오기.
	void Duplicate(CN3FXPartBottomBoard* pSrc);

public:
	CN3FXPartBottomBoard();
	~CN3FXPartBottomBoard() override;

#ifdef _N3TOOL
	bool ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3);
#endif // end of _N3TOOL
};

#endif // #ifndef __N3FXPARTBOTTOMBOARD_H__

// ===== END N3Base/N3FXPartBottomBoard.h =====

// ===== BEGIN N3Base/N3FXPartMesh.cpp =====
#line 1 "N3Base/N3FXPartMesh.cpp"
﻿// N3FXPartMesh.cpp: implementation of the CN3FXPartMesh class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXBundle.h"
#include "N3FXShape.h"
#include "N3FXPartMesh.h"
#include "N3AnimKey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartMesh::CN3FXPartMesh()
{
	m_iVersion = SUPPORTED_PART_VERSION;

	m_pShape = nullptr;
	m_pRefShape = nullptr;

	m_dwCurrColor = 0xffffffff;

	m_cTextureMoveDir = 0;
	m_fv = 0.0f;
	m_fu = 0.0f;

	m_vScaleVel.Set(0,0,0);
	m_vDir.Set(0,0,1);
	m_vUnitScale.Set(1,1,1);
	m_vCurrScaleVel.Set(0,0,0);
	m_vScaleAccel.Set(0,0,0);

	m_bTexLoop = false;
	m_fMeshFPS = 30.0f;
}

CN3FXPartMesh::~CN3FXPartMesh()
{
	CN3Base::s_MngFXShape.Delete(&m_pRefShape);
	if(m_pShape)
	{
		m_pShape->Release();
		delete m_pShape;
		m_pShape = nullptr;
	}
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////


//
//
//
#ifdef _N3TOOL
bool CN3FXPartMesh::ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3)
{
	if (CN3FXPartBase::ParseScript(szCommand, szBuff0, szBuff1, szBuff2, szBuff3))
		return true;

	if (lstrcmpi(szCommand, "<shape_name>") == 0)
	{
		char szPath[MAX_PATH] = {};
		strcpy(szPath, szBuff0);

		m_pShape = new CN3FXShape();
		m_pRefShape = s_MngFXShape.Get(szPath);
		m_pShape->Duplicate(m_pRefShape);

		__Vector3 vScale;
		if (m_pShape->m_KeyScale.DataGet(0, vScale))
			m_vUnitScale = vScale;
		else
			m_vUnitScale = m_pShape->Scale();

		return true;
	}

	if (lstrcmpi(szCommand, "<texture_move>") == 0)
	{
		if (lstrcmpi(szBuff0, "up") == 0)
			m_cTextureMoveDir = 1;
		else if (lstrcmpi(szBuff0, "down") == 0)
			m_cTextureMoveDir = 2;
		else if (lstrcmpi(szBuff0, "left") == 0)
			m_cTextureMoveDir = 3;
		else if (lstrcmpi(szBuff0, "right") == 0)
			m_cTextureMoveDir = 4;

		float uv = static_cast<float>(atof(szBuff1));

		if (m_cTextureMoveDir == 1)
		{
			m_fu = 0.0f;
			m_fv = uv;
		}
		else if (m_cTextureMoveDir == 2)
		{
			m_fu = 0.0f;
			m_fv = -uv;
		}
		else if (m_cTextureMoveDir == 3)
		{
			m_fu = uv;
			m_fv = 0.0f;
		}
		else if (m_cTextureMoveDir == 4)
		{
			m_fu = -uv;
			m_fv = 0.0f;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<scale_velocity>") == 0)
	{
		m_vScaleVel.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		m_vCurrScaleVel = m_vScaleVel;
		return true;
	}

	if (lstrcmpi(szCommand, "<scale_accelerate>") == 0)
	{
		m_vScaleAccel.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		return true;
	}

	if (lstrcmpi(szCommand, "<scale>") == 0)
	{
		m_vUnitScale.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		return true;
	}

	if (lstrcmpi(szCommand, "<tex_fps>") == 0)
	{
		m_fTexFPS = static_cast<float>(atof(szBuff0));
		if (m_pShape == nullptr)
			return false;

		for (int i = 0; i < m_pShape->PartCount(); i++)
		{
			CN3FXSPart* part = m_pShape->Part(i);
			if (part != nullptr)
				part->m_fTexFPS = m_fTexFPS;
		}
		return true;
	}

	if (lstrcmpi(szCommand, "<tex_loop>") == 0)
	{
		m_bTexLoop = true;
		if (lstrcmpi(szBuff0, "false") == 0)
			m_bTexLoop = false;

		if (m_pShape == nullptr)
			return false;

		for (int i = 0; i < m_pShape->PartCount(); i++)
		{
			CN3FXSPart* part = m_pShape->Part(i);
			if (part != nullptr)
				part->m_bTexLoop = m_bTexLoop;
		}

		return true;
	}

	if (lstrcmpi(szCommand, "<mesh_fps>") == 0)
	{
		m_fMeshFPS = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<end>") == 0)
	{
		Init();
		return true;
	}

	return false;
}
#endif // end of _N3TOOL


//
//	init...
//
void CN3FXPartMesh::Init()
{
	CN3FXPartBase::Init();
	
	m_dwCurrColor = 0xffffffff;
	m_vCurrVelocity = m_vVelocity;
	m_vCurrPos = m_vPos;
	m_vCurrScaleVel = m_vScaleVel;
	
	m_vDir.Set(0,0,1);

	if(m_pRefBundle)
	{
		if(m_pShape) m_pShape->PosSet(m_vPos+m_pRefBundle->m_vPos);		
	}
	else if(m_pShape) m_pShape->PosSet(m_vPos);

	if(m_pShape) m_pShape->SetPartsMtl(m_bAlpha, m_dwSrcBlend, m_dwDestBlend, m_dwZEnable, m_dwZWrite, m_dwLight, m_dwDoubleSide);
}


//
//
//
bool CN3FXPartMesh::Load(File& file)
{
	if (!CN3FXPartBase::Load(file))
		return false;

	char szShapeFileName[_MAX_PATH] = {};
	file.Read(szShapeFileName, _MAX_PATH);

	delete m_pShape;
	m_pShape = new CN3FXShape();

	m_pRefShape = s_MngFXShape.Get(szShapeFileName);
	m_pShape->Duplicate(m_pRefShape);
	m_pShape->SetPartsMtl(m_bAlpha, m_dwSrcBlend, m_dwDestBlend, m_dwZEnable, m_dwZWrite, m_dwLight, m_dwDoubleSide);
	//m_pShape->LoadFromFile(szShapeFileName);
	__Vector3 vScale;
	if (m_pShape->m_KeyScale.DataGet(0, vScale))
		m_vUnitScale = vScale;
	else
		m_vUnitScale = m_pShape->Scale();

	file.Read(&m_cTextureMoveDir, sizeof(char));
	file.Read(&m_fu, sizeof(float));
	file.Read(&m_fv, sizeof(float));
	file.Read(&m_vScaleVel, sizeof(__Vector3));
	m_vCurrScaleVel = m_vScaleVel;

	if (m_iVersion >= 2)
		file.Read(&m_bTexLoop, sizeof(bool));

	if (m_iVersion >= 3)
		file.Read(&m_vScaleAccel, sizeof(__Vector3));

	if (m_iVersion >= 4)
		file.Read(&m_fMeshFPS, sizeof(float));

	if (m_iVersion >= 5)
		file.Read(&m_vUnitScale, sizeof(__Vector3));

	// TODO: implement m_bShapeLoop
	if (m_iVersion >= 6)
		file.Read(&m_bShapeLoop, sizeof(bool));

	// TODO: implement m_bViewFix
	if (m_iVersion >= 7)
		file.Read(&m_bViewFix, sizeof(bool));

	// TODO: implement m_bUseFadeShowLife
	if (m_iVersion >= 8)
		file.Read(&m_bUseFadeShowLife, sizeof(bool));

	if (m_iVersion >= 9)
		file.Seek(MAX_PATH, SEEK_CUR);

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iVersion > SUPPORTED_PART_VERSION)
	{
		TRACE(
			"!!! WARNING: CN3FXPartMesh::Load(%s) encountered version %d (base version %d). Needs support!",
			m_pRefBundle != nullptr ? m_pRefBundle->FileName().c_str() : "<unknown>",
			m_iVersion,
			m_iBaseVersion);
	}
#endif

	if (m_pShape != nullptr)
	{
		for (int i = 0; i < m_pShape->PartCount(); i++)
		{
			CN3FXSPart* part = m_pShape->Part(i);
			if (part == nullptr)
				continue;

			part->m_fTexFPS = m_fTexFPS;
			part->m_bTexLoop = m_bTexLoop;
		}
	}

	Init();

	return true;
}


//
//
//
bool CN3FXPartMesh::Save(File& file)
{
	if (!CN3FXPartBase::Save(file))
		return false;

	char szShapeFileName[_MAX_PATH] = {};
	strcpy(szShapeFileName, m_pShape->FileName().c_str());

	file.Write(szShapeFileName, _MAX_PATH);

	file.Write(&m_cTextureMoveDir, sizeof(char));
	file.Write(&m_fu, sizeof(float));
	file.Write(&m_fv, sizeof(float));

	file.Write(&m_vScaleVel, sizeof(__Vector3));

	if (m_iVersion >= 2)
		file.Write(&m_bTexLoop, sizeof(bool));

	if (m_iVersion >= 3)
		file.Write(&m_vScaleAccel, sizeof(__Vector3));

	if (m_iVersion >= 4)
		file.Write(&m_fMeshFPS, sizeof(float));

	if (m_iVersion >= 5)
		file.Write(&m_vUnitScale, sizeof(__Vector3));

	return true;
}


//
//
//
void CN3FXPartMesh::Start()
{
	m_dwCurrColor = 0xffffffff;
	if(!m_pShape) return;

	int PartCount = m_pShape->PartCount();
	for(int i=0;i<PartCount;i++)
	{
		CN3FXSPart* pPart = m_pShape->Part(i);

		pPart->m_Mtl.dwSrcBlend = m_dwSrcBlend;
		pPart->m_Mtl.dwDestBlend = m_dwDestBlend;

		if((pPart->m_Mtl.nRenderFlags & RF_ALPHABLENDING) && !m_bAlpha)
		{
			pPart->m_Mtl.nRenderFlags -= RF_ALPHABLENDING;
		}
		else if(!(pPart->m_Mtl.nRenderFlags & RF_ALPHABLENDING) && m_bAlpha)
		{
			pPart->m_Mtl.nRenderFlags += RF_ALPHABLENDING;
		}

		__VertexXyzColorT1* pVertices;
		pVertices = pPart->GetColorVertices();
		if(pVertices)
		{
			for(int j=0;j<pPart->Mesh()->GetMaxNumVertices();j++)
			{
				pVertices[j].color = m_dwCurrColor;
			}
		}
	}

	CN3FXPartBase::Start();	
}


//
//
//
void CN3FXPartMesh::Stop()
{
	CN3FXPartBase::Stop();	
}


//
//
//
bool CN3FXPartMesh::Tick()
{
	if(!CN3FXPartBase::Tick()) return false;

	if(!m_pShape) return false;

	if(m_fCurrLife<=m_fFadeIn)
	{
		uint32_t Alpha = (uint32_t)(255.0f * m_fCurrLife / m_fFadeIn);
		m_dwCurrColor = (Alpha<<24) + 0x00ffffff;
		
		int PartCount = m_pShape->PartCount();
		for(int i=0;i<PartCount;i++)
		{
			CN3FXSPart* pPart = m_pShape->Part(i);
			if(pPart) pPart->SetColor(m_dwCurrColor);
		}
	}
	else if(m_dwCurrColor!=0xffffffff && m_fCurrLife < (m_fFadeIn+m_fLife))
	{
		m_dwCurrColor = 0xffffffff;

		int PartCount = m_pShape->PartCount();
		for(int i=0;i<PartCount;i++)
		{
			CN3FXSPart* pPart = m_pShape->Part(i);
			if(pPart) pPart->SetColor(m_dwCurrColor);
		}
	}

	if(m_dwState==FX_PART_STATE_DYING)
	{
		float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
		if(m_fCurrLife >= TotalLife)
		{
			m_dwCurrColor = 0x00ffffff;
		}
		else
		{
			uint32_t Alpha = (uint32_t)(255.0f * (TotalLife - m_fCurrLife) / m_fFadeOut);
			m_dwCurrColor = (Alpha<<24) + 0x00ffffff;
		}

		int PartCount = m_pShape->PartCount();
		for(int i=0;i<PartCount;i++)
		{
			CN3FXSPart* pPart = m_pShape->Part(i);
			if(pPart) pPart->SetColor(m_dwCurrColor);
		}
	}

	float fFrm = m_fCurrLife * m_fMeshFPS;
	if(fFrm>m_pShape->GetWholeFrm()-1.0f)
		fFrm = m_pShape->GetWholeFrm()-1.0f;

	m_pShape->SetCurrFrm(fFrm);

	if(m_cTextureMoveDir>0) MoveTexUV();

	Rotate();
	Scaling();
	Move();	

	m_pShape->Tick();

	return true;

/*	
	//회전과 이동..
	__Matrix44 mtx;
	mtx.Identity();]
	mtx.Rotation(m_fCurrLife*m_vRotVelocity);
	__Quaternion qtLocalRot(mtx);
	
	//mesh방향과 bundle방향을 맞춰라...
	__Quaternion qtBundle;
	__Vector3 vDirAxis;
	float fDirAng;
	
	vDirAxis.Cross(m_vDir, m_pRefBundle->m_vDir);
	int tmp;
	tmp = vDirAxis.x*10000.0f;
	vDirAxis.x = (float)(tmp)/10000.0f;
	tmp = vDirAxis.y*10000.0f;
	vDirAxis.y = (float)(tmp)/10000.0f;
	tmp = vDirAxis.z*10000.0f;
	vDirAxis.z = (float)(tmp)/10000.0f;

	if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) vDirAxis.Set(0,1,0);

	fDirAng = acos((double)m_vDir.Dot(m_pRefBundle->m_vDir));
	
	qtBundle.RotationAxis(vDirAxis, fDirAng);

	__Quaternion qt = qtLocalRot * qtBundle;
	m_pShape->RotSet(qt);
			
	m_vCurrVelocity += m_vAcceleration*CN3Base::s_fSecPerFrm;
	m_vCurrPos += m_vCurrVelocity*CN3Base::s_fSecPerFrm;
	m_pShape->PosSet(m_vCurrPos+m_pRefBundle->m_vPos);

	
	m_vCurrScaleVel += m_vScaleAccel*m_fCurrLife;
	
	__Vector3 vScale = m_vCurrScaleVel*m_fCurrLife;
	vScale += m_vUnitScale;
	if(m_pRefBundle->m_bDependScale)
	{
		vScale.x *= m_pRefBundle->m_vTargetScale.x;
		vScale.y *= m_pRefBundle->m_vTargetScale.y;
		vScale.z *= m_pRefBundle->m_vTargetScale.z;
	}
	if(vScale.x < 0) vScale.x = 0;
	if(vScale.y < 0) vScale.y = 0;
	if(vScale.z < 0) vScale.z = 0;

	//m_pShape->ScaleSet(m_vUnitScale.x+vScale.x, m_vUnitScale.y+vScale.y, m_vUnitScale.z+vScale.z);
	m_pShape->ScaleSet(vScale.x, vScale.y, vScale.z);

	//텍스쳐 이동..
	if(m_cTextureMoveDir>0)
	{
		int cnt = m_pShape->PartCount();
		for(int i=0;i<cnt;i++)
		{
			int VertexCount = m_pShape->Part(i)->Mesh()->GetNumVertices();

			LPDIRECT3DVERTEXBUFFER8 pVB = m_pShape->Part(i)->Mesh()->GetVertexBuffer();
			
			__VertexXyzColorT1* pVertex;
			HRESULT hr = pVB->Lock(0, 0, (uint8_t**)&pVertex, 0);
			if (FAILED(hr)) continue;

			for(int j=0;j<VertexCount;j++)
			{
				pVertex[j].tu += m_fu*CN3Base::s_fSecPerFrm;
				pVertex[j].tv += m_fv*CN3Base::s_fSecPerFrm;
			}
			pVB->Unlock();
		}
	}
	m_pShape->Tick(fFrm);
	return true;
*/	
}


//
//
//
void CN3FXPartMesh::Rotate()
{
	__Matrix44 mtx;
	mtx.Identity();
	//mtx.Rotation(m_fCurrLife*m_vRotVelocity);
	//__Quaternion qtLocalRot(mtx);

	m_pShape->m_mtxParent.Rotation(m_vRotVelocity * m_fCurrLife);
		
	//mesh방향과 bundle방향을 맞춰라...
	__Quaternion qtBundle;
	__Vector3 vDirAxis;
	float fDirAng;
	
	vDirAxis.Cross(m_vDir, m_pRefBundle->m_vDir);
	int tmp;
	tmp = (int)(vDirAxis.x*10000.0f);
	vDirAxis.x = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.y*10000.0f);
	vDirAxis.y = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.z*10000.0f);
	vDirAxis.z = (float)(tmp)/10000.0f;

	if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) vDirAxis.Set(0,1,0);
	fDirAng = acos(m_vDir.Dot(m_pRefBundle->m_vDir));
	qtBundle.RotationAxis(vDirAxis, fDirAng);
	mtx = qtBundle;

	m_pShape->m_mtxParent *= mtx;
}


//
//
//
void CN3FXPartMesh::Move()
{
	m_vCurrVelocity += m_vAcceleration*CN3Base::s_fSecPerFrm;
	m_vCurrPos += m_vCurrVelocity*CN3Base::s_fSecPerFrm;

	__Quaternion qtBundle;
	__Vector3 vDirAxis;
	float fDirAng;
	
	vDirAxis.Cross(m_vDir, m_pRefBundle->m_vDir);
	int tmp;
	tmp = (int)(vDirAxis.x*10000.0f);
	vDirAxis.x = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.y*10000.0f);
	vDirAxis.y = (float)(tmp)/10000.0f;
	tmp = (int)(vDirAxis.z*10000.0f);
	vDirAxis.z = (float)(tmp)/10000.0f;

	if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) vDirAxis.Set(0,1,0);

	fDirAng = acos(m_vDir.Dot(m_pRefBundle->m_vDir));
	qtBundle.RotationAxis(vDirAxis, fDirAng);

	__Matrix44 mtx = qtBundle;
	__Vector3 vRealPos = m_vCurrPos * mtx;

	//__Vector3 vPos = m_vCurrPos+m_pRefBundle->m_vPos;
	__Vector3 vPos = vRealPos + m_pRefBundle->m_vPos;

	m_pShape->m_mtxParent.PosSet(vPos);
}


//
//
//
void CN3FXPartMesh::Scaling()
{
	m_vCurrScaleVel += m_vScaleAccel*m_fCurrLife;
	__Vector3 vScale = m_vCurrScaleVel*m_fCurrLife;
	vScale += m_vUnitScale;

	if(m_pRefBundle->m_bDependScale) vScale *= m_pRefBundle->m_fTargetScale;

	if(vScale.x < 0.0f) vScale.x = 0.0f;
	if(vScale.y < 0.0f) vScale.y = 0.0f;
	if(vScale.z < 0.0f) vScale.z = 0.0f;

	__Matrix44 mtx;
	mtx.Identity();
	mtx.Scale(vScale);
	m_pShape->m_mtxParent *= mtx;
	//m_pShape->m_mtxParent.Scale(vScale);
}


//
//
//
void CN3FXPartMesh::MoveTexUV()
{
	int cnt = m_pShape->PartCount();
	for(int i=0;i<cnt;i++)
	{
		CN3FXSPart* pPart = m_pShape->Part(i);
		if(!pPart) continue;

		__VertexXyzColorT1* pVertices;
		pVertices = pPart->GetColorVertices();
		if(pVertices)
		{
			for(int j=0;j<pPart->Mesh()->GetMaxNumVertices();j++)
			{
				pVertices[j].tu += m_fu*CN3Base::s_fSecPerFrm;
				pVertices[j].tv += m_fv*CN3Base::s_fSecPerFrm;
			}
		}
	}
}


//
//
//
int	CN3FXPartMesh::NumPart()
{
	if(!m_pShape) return 0;
	
	return m_pShape->PartCount();
}


//
//
//
int CN3FXPartMesh::NumVertices(int Part)
{
	if(!m_pShape) return 0;
//	return m_pShape->Part(Part)->Mesh()->GetNumVertices(); //this_fx
	return m_pShape->Part(Part)->Mesh()->GetMaxNumVertices();
}


//
//
//
LPDIRECT3DVERTEXBUFFER9 CN3FXPartMesh::GetVB(int Part)
{
	if(!m_pShape) return nullptr;
	return nullptr;
//	return m_pShape->Part(Part)->Mesh()->GetVertexBuffer();	//this_fx
}


//
//
//
bool CN3FXPartMesh::IsDead()
{
	float TotalLife = m_fFadeIn + m_fLife + m_fFadeOut;
	if(m_fCurrLife >= TotalLife) return true;
	return false;
}


//
//	render...
//	일단은 파티클 하나씩 그리고....
//	나중에는 같은 텍스쳐 쓰는 것들끼리 묶어서 그리자...
//
void CN3FXPartMesh::Render()
{
	// render state 세팅
	if(!m_pShape) return;

	DWORD dwAlpha;
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlpha);

	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha );
	if(m_dwState == FX_PART_STATE_DYING || m_fCurrLife < m_fFadeIn) s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

	s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
	s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );

	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

	m_pShape->Render();

	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlpha);
}

void CN3FXPartMesh::Duplicate(CN3FXPartMesh* pSrc)
{
	if(!pSrc) return;

	CN3FXPartBase::Duplicate(pSrc);
	if(m_pShape) 
	{
		delete m_pShape;
		m_pShape = nullptr;
	}

	m_pShape = new CN3FXShape;

	m_pRefShape = s_MngFXShape.Get(pSrc->m_pRefShape->FileName());
	m_pShape->Duplicate(m_pRefShape);
	m_pShape->SetPartsMtl(m_bAlpha, m_dwSrcBlend, m_dwDestBlend, m_dwZEnable, m_dwZWrite, m_dwLight, m_dwDoubleSide);
	
	m_cTextureMoveDir = pSrc->m_cTextureMoveDir;
	m_fu = pSrc->m_fu;
	m_fv = pSrc->m_fv;
	m_vScaleVel = pSrc->m_vScaleVel;
	m_vScaleAccel = pSrc->m_vScaleAccel;
	m_fMeshFPS = pSrc->m_fMeshFPS;
	m_bTexLoop = pSrc->m_bTexLoop;
	m_vUnitScale = pSrc->m_vUnitScale;
		
	if (m_pShape != nullptr)
	{
		for (int i = 0; i < m_pShape->PartCount(); i++)
		{
			CN3FXSPart* part = m_pShape->Part(i);
			if (part == nullptr)
				continue;

			part->m_fTexFPS = m_fTexFPS;
			part->m_bTexLoop = m_bTexLoop;
		}
	}

	Init();
	return;
}

// ===== END N3Base/N3FXPartMesh.cpp =====

// ===== BEGIN N3Base/N3FXPartMesh.h =====
#line 1 "N3Base/N3FXPartMesh.h"
﻿// N3FXPartMesh.h: interface for the CN3FXPartMesh class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTMESH_H__
#define __N3FXPARTMESH_H__

#include "N3FXPartBase.h"

class CN3FXShape;
class CN3FXPartMesh : public CN3FXPartBase
{
public:
	static constexpr int SUPPORTED_PART_VERSION = 9; // supported as far as reading only

	CN3FXShape*	m_pShape;
	CN3FXShape*	m_pRefShape;

	uint32_t		m_dwCurrColor;	//
	
	char		m_cTextureMoveDir;	//텍스쳐 이동 방향..1:up 2:down, 3:left, 4:right
	float		m_fu;				//텍스쳐 이동 속도
	float		m_fv;				//텍스쳐 이동 속도

	__Vector3	m_vUnitScale;
	__Vector3	m_vScaleVel;
	__Vector3	m_vCurrScaleVel;
	__Vector3	m_vScaleAccel;
	__Vector3	m_vDir;

	bool		m_bTexLoop;
	float		m_fMeshFPS;

	// N3FXPartMesh needs implementation of these methods
	bool m_bShapeLoop;
	bool m_bViewFix;
	bool m_bUseFadeShowLife;
	// N3FXPartMesh needs implementation of these methods

protected:
	bool IsDead() override;

public:
	void Init() override;			// 각종 변수들을 처음 로딩한 상태로 초기화...
	void Start() override;			// 파트 구동 시작.
	void Stop() override;			// 파트 구동 멈춤..
	bool Tick() override;			// ticktick...
	void Render() override;			// 화면에 뿌리기..
	bool Load(File& file) override;	// 게임파일 불러오기.
	bool Save(File& file) override;	// 게임파일 저장오기.
	void Duplicate(CN3FXPartMesh* pSrc);
		
public:
	void Rotate();
	void Move();
	void Scaling();
	void MoveTexUV();
		    
	int NumPart();
	int NumVertices(int Part);
	LPDIRECT3DVERTEXBUFFER9 GetVB(int Part);

	CN3FXPartMesh();
	~CN3FXPartMesh() override;

#ifdef _N3TOOL
	bool ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3);
#endif // end of _N3TOOL

};

#endif // #ifndef __N3FXPARTMESH_H__

// ===== END N3Base/N3FXPartMesh.h =====

// ===== BEGIN N3Base/N3FXPartParticles.cpp =====
#line 1 "N3Base/N3FXPartParticles.cpp"
﻿// N3FXPartBase.cpp: implementation of the CN3FXPartBase class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPartParticles.h"
#include "N3FXBundle.h"
#include "N3FXParticle.h"
#include "N3FXDef.h"
#include "N3FXShape.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartParticles::CN3FXPartParticles()
{
	m_iVersion = SUPPORTED_PART_VERSION;	//3이하는 다 무시해버려..

	m_iNumParticle		= 0;
	m_iNumLodParticle	= 0;
	m_pair_fParticleSize.first = 0.0f;
	m_pair_fParticleSize.second = 0.0f;
	m_pair_fParticleLife.first = 0.0f;
	m_pair_fParticleLife.second = 0.0f;
	
	m_pVBList_Alive.clear();
	m_pVBList_Dead.clear();

	m_CurrCreateDelay = 0.0f;
	m_fCreateDelay = 0.01f;
	
	m_iNumCreate = 1;

	m_MinCreateRange.Set(0,0,0);
	m_MaxCreateRange.Set(0,0,0);
	
	//m_vUnit[0].Set(-0.5f, 1.5f, 0.0f, 0xffffffff, 0.0f, -1.0f);
	//m_vUnit[1].Set(1.5f, -0.5f, 0.0f, 0xffffffff, 2.0f, 1.0f);
	//m_vUnit[2].Set(-0.5f, -0.5f, 0.0f, 0xffffffff, 0.0f, 1.0f);
	
	m_vUnit[0].Set(-0.5f, 0.5f, 0.0f, 0xffffffff, 0.0f, 0.0f);
	m_vUnit[1].Set(0.5f, 0.5f, 0.0f, 0xffffffff, 1.0f, 0.0f);
	m_vUnit[2].Set(0.5f, -0.5f, 0.0f, 0xffffffff, 1.0f, 1.0f);
	m_vUnit[3].Set(-0.5f, -0.5f, 0.0f, 0xffffffff, 0.0f, 1.0f);

	//m_wUnitIB[0] = 0;	m_wUnitIB[1] = 1;	m_wUnitIB[2] = 3;
	//m_wUnitIB[3] = 3;	m_wUnitIB[4] = 1;	m_wUnitIB[5] = 2;
	
	//emitter...
	m_dwEmitType = FX_PART_PARTICLE_EMIT_TYPE_NORMAL;
	ZeroMemory(&m_uEmitCon, sizeof(m_uEmitCon));
	
	//particle..
	m_vPtEmitDir.Set(0.0f, 0.0f, -1.0f);
	m_fPtVelocity = m_fPtAccel = m_fPtRotVelocity = m_fPtGravity = 0.0f;

	int i;
	for(i=0;i<NUM_KEY_COLOR;i++) m_dwChangeColor[i] = 0xffffffff;
	m_bChangeColor = false;

	m_pRefShape = m_pShape = nullptr;
	m_fMeshFPS = 30.0f;

	m_vPrevShapePos.Set(0.0f, 0.0f, 0.0f);

	m_bAnimKey = false;

	m_pVB = nullptr;
	//m_pIB = nullptr;

	m_fTexRotateVelocity = 0.0f;
	m_fScaleVelX = m_fScaleVelY = 0.0f;

#ifdef _N3TOOL
	for(i=0;i<NUM_KEY_COLOR;i++)
	{
		m_bChangeColorKey[i] = false;
		m_bChangeAlphaKey[i] = false;
	}
#endif // end of _N3TOOL
}

CN3FXPartParticles::~CN3FXPartParticles()
{
	CN3FXPartBase::~CN3FXPartBase();

	std::list<CN3FXParticle*>::iterator it;

	for (auto itr = m_pVBList_Alive.begin(); itr != m_pVBList_Alive.end(); ++itr)
	{
		CN3FXParticle* pParticle = (*itr);
		if (pParticle) delete pParticle;
	}
	m_pVBList_Alive.clear();

	for (auto itr = m_pVBList_Dead.begin(); itr != m_pVBList_Dead.end(); ++itr)
	{
		CN3FXParticle* pParticle = (*itr);
		if (pParticle) delete pParticle;
	}
	m_pVBList_Dead.clear();
	
	CN3Base::s_MngFXShape.Delete(&m_pRefShape);
	if(m_pShape)
	{
		m_pShape->Release();
		delete m_pShape;
		m_pShape = nullptr;
	}

	if(m_pVB) 
	{
		delete[] m_pVB;
		m_pVB = nullptr;
	}
	//if(m_pIB)
	//{
	//	delete[] m_pIB;
	//	m_pIB = nullptr;
	//}
}


//
//
//
#ifdef _N3TOOL
bool CN3FXPartParticles::ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3)
{
	if (CN3FXPartBase::ParseScript(szCommand, szBuff0, szBuff1, szBuff2, szBuff3))
		return true;

	//	파티클 수.
	if (lstrcmpi(szCommand, "<particle_count>") == 0)
	{
		m_iNumParticle = atoi(szBuff0);
		if (m_iNumParticle > 0)
			InitVB();
		return true;
	}

	//	파티클 크기.
	if (lstrcmpi(szCommand, "<particle_size>") == 0)
	{
		m_pair_fParticleSize.first = m_pair_fParticleSize.second = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_size_range>") == 0)
	{
		m_pair_fParticleSize.first = static_cast<float>(atof(szBuff0));
		m_pair_fParticleSize.second = static_cast<float>(atof(szBuff1));
		return true;
	}

	//	파티클 생명.
	if (lstrcmpi(szCommand, "<particle_life>") == 0)
	{
		m_pair_fParticleLife.first = static_cast<float>(atof(szBuff0));
		m_pair_fParticleLife.second = static_cast<float>(atof(szBuff1));
		return true;
	}

	//	파티클 시작오차..min
	if (lstrcmpi(szCommand, "<start_range_min>") == 0)
	{
		m_MinCreateRange.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		return true;
	}

	//	파티클 시작오차..max
	if (lstrcmpi(szCommand, "<start_range_max>") == 0)
	{
		m_MaxCreateRange.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		return true;
	}

	//	파티클 한번에 생성 갯수
	if (lstrcmpi(szCommand, "<create_count>") == 0)
	{
		m_iNumCreate = atoi(szBuff0);
		return true;
	}

	//	파티클 한번에 생성 시간 범위
	if (lstrcmpi(szCommand, "<create_delay>") == 0)
	{
		m_CurrCreateDelay = m_fCreateDelay = static_cast<float>(atof(szBuff0));
		return true;
	}

	//	시작하는 방법.
	if (lstrcmpi(szCommand, "<emit_type>") == 0)
	{
		if (lstrcmpi(szBuff0, "spread") == 0)
		{
			m_dwEmitType = FX_PART_PARTICLE_EMIT_TYPE_SPREAD;
			m_uEmitCon.fEmitAngle = static_cast<float>(atof(szBuff1));
		}
		else if (lstrcmpi(szBuff0, "gather") == 0)
		{
			m_dwEmitType = FX_PART_PARTICLE_EMIT_TYPE_GATHER;
			m_uEmitCon.vGatherPoint.x = static_cast<float>(atof(szBuff1));
			m_uEmitCon.vGatherPoint.y = static_cast<float>(atof(szBuff2));
			m_uEmitCon.vGatherPoint.z = static_cast<float>(atof(szBuff3));
		}
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_direction>") == 0)
	{
		m_vPtEmitDir.Set(
			static_cast<float>(atof(szBuff0)),
			static_cast<float>(atof(szBuff1)),
			static_cast<float>(atof(szBuff2)));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_velocity>") == 0)
	{
		m_fPtVelocity = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_acceleration>") == 0)
	{
		m_fPtAccel = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_rotation_velocity>") == 0)
	{
		float Degree = static_cast<float>(atof(szBuff0));
		m_fPtRotVelocity = DegreesToRadians(Degree);
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_gravity>") == 0)
	{
		m_fPtGravity = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_color>") == 0)
	{
		int seq = atoi(szBuff0);
		uint32_t color = atoi(szBuff1);
		if (seq >= 0 && seq < NUM_KEY_COLOR)
			m_dwChangeColor[seq] = color;
		return true;
	}

	if (lstrcmpi(szCommand, "<change_color>") == 0)
	{
		if (lstrcmpi(szBuff0, "true") == 0)
			m_bChangeColor = true;
		else if (lstrcmpi(szBuff0, "false") == 0)
			m_bChangeColor = false;
		return true;
	}

	if (lstrcmpi(szCommand, "<color_key>") == 0)
	{
		int seq = atoi(szBuff0);
		if (seq >= 0 && seq < NUM_KEY_COLOR)
			m_bChangeColorKey[seq] = true;
		return true;
	}

	if (lstrcmpi(szCommand, "<alpha_key>") == 0)
	{
		int seq = atoi(szBuff0);
		if (seq >= 0 && seq < NUM_KEY_COLOR)
			m_bChangeAlphaKey[seq] = true;
		return true;
	}

	if (lstrcmpi(szCommand, "<shape_name>") == 0)
	{
		if (lstrcmpi(szBuff0, "") == 0)
			return false;

		char szPath[MAX_PATH] = {};
		strcpy(szPath, szBuff0);

		m_pShape = new CN3FXShape();
		m_pRefShape = s_MngFXShape.Get(szPath);
		m_pShape->Duplicate(m_pRefShape);
		m_vCurrPos = m_pShape->CenterPos();
		return true;
	}

	if (lstrcmpi(szCommand, "<shape_fps>") == 0)
	{
		m_fMeshFPS = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<shape_apply>") == 0)
	{
		if (lstrcmpi(szBuff0, "true") == 0)
			m_bAnimKey = true;
		else if (lstrcmpi(szBuff0, "false") == 0)
			m_bAnimKey = false;

		return true;
	}

	if (lstrcmpi(szCommand, "<texture_rotation_speed>") == 0)
	{
		m_fTexRotateVelocity = static_cast<float>(atof(szBuff0));
		return true;
	}

	if (lstrcmpi(szCommand, "<particle_scale_velocity>") == 0)
	{
		m_fScaleVelX = static_cast<float>(atof(szBuff0));
		m_fScaleVelY = static_cast<float>(atof(szBuff1));
		return true;
	}

	return false;
}
#endif // end of _N3TOOL


//
//	init...
//
void CN3FXPartParticles::Init()
{
	CN3FXPartBase::Init();
	if(m_pShape)
	{
		m_vShapePos = m_vPos;
		m_vPrevShapePos = m_vCurrPos = m_vShapePos + m_pShape->CenterPos();
	}
	else m_vCurrPos = m_vPos; 

	if(m_iVersion<3 && m_pShape)
	{
		m_bAnimKey = true;
	}

	for (auto itr = m_pVBList_Alive.begin(); itr != m_pVBList_Alive.end(); ++itr)
		m_pVBList_Dead.push_back(*itr);

	m_pVBList_Alive.clear();

	m_CurrCreateDelay = m_fCreateDelay;

	int i = 0;
	for (auto itr = m_pVBList_Dead.begin(); itr != m_pVBList_Dead.end(); ++itr)
	{
		CN3FXParticle* pParticle = *itr;

		pParticle->m_iID = i++ * NUM_VERTEX_PARTICLE;
		pParticle->m_dwColor = 0xffffffff;
		pParticle->m_fCurrLife = 0.0f;
		pParticle->m_fDropVel = 0.0f;
		pParticle->m_fDropY = 0.0f;
		pParticle->m_fLife = m_pair_fParticleLife.first + ((m_pair_fParticleLife.second - m_pair_fParticleLife.first) * (float)(rand()%100) / 100.0f);
		pParticle->m_fSize = m_pair_fParticleSize.first + ((m_pair_fParticleSize.second - m_pair_fParticleSize.first) * (float)(rand()%100) / 100.0f);
		pParticle->m_iNumTex = m_iNumTex;
		pParticle->m_pRefParent = this;
		pParticle->m_iTexIdx = 0;
	}
}


//
//
//
bool CN3FXPartParticles::Load(File& file)
{
	if (!CN3FXPartBase::Load(file))
		return false;

	if (m_iVersion < 3)
		return false;

	file.Read(&m_iNumParticle, sizeof(int));
	if (m_iNumParticle > 0)
		InitVB();

	if (m_iVersion < 4)
	{
		float ParticleSize;
		file.Read(&ParticleSize, sizeof(float));
		m_pair_fParticleSize.first = m_pair_fParticleSize.second = ParticleSize;
	}
	else
	{
		file.Read(&m_pair_fParticleSize.first, sizeof(float));
		file.Read(&m_pair_fParticleSize.second, sizeof(float));
	}

	file.Read(&(m_pair_fParticleLife.first), sizeof(float));
	file.Read(&(m_pair_fParticleLife.second), sizeof(float));

	file.Read(&m_MinCreateRange, sizeof(__Vector3));
	file.Read(&m_MaxCreateRange, sizeof(__Vector3));

	file.Read(&m_fCreateDelay, sizeof(float));
	file.Read(&m_iNumCreate, sizeof(int));

	file.Read(&m_dwEmitType, sizeof(uint32_t));

	if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_SPREAD)
	{
		file.Read(&m_uEmitCon.fEmitAngle, sizeof(float));
	}
	else if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_GATHER)
	{
		file.Read(&m_uEmitCon.vGatherPoint.x, sizeof(float));
		file.Read(&m_uEmitCon.vGatherPoint.y, sizeof(float));
		file.Read(&m_uEmitCon.vGatherPoint.z, sizeof(float));
	}

	file.Read(&m_vPtEmitDir, sizeof(__Vector3));
	file.Read(&m_fPtVelocity, sizeof(float));
	file.Read(&m_fPtAccel, sizeof(float));
	file.Read(&m_fPtRotVelocity, sizeof(float));
	file.Read(&m_fPtGravity, sizeof(float));

	file.Read(&m_bChangeColor, sizeof(bool));
	if (m_bChangeColor)
	{
		int iNumKeyColor = 0;
		file.Read(&iNumKeyColor, sizeof(int));
		file.Read(&m_dwChangeColor, sizeof(uint32_t) * iNumKeyColor);
	}

	file.Read(&m_bAnimKey, sizeof(bool));
	if (m_bAnimKey)
	{
		file.Read(&m_fMeshFPS, sizeof(float));

		char szShapeFileName[_MAX_PATH] = {};
		file.Read(szShapeFileName, _MAX_PATH);

		delete m_pShape;
		m_pShape = new CN3FXShape();

		m_pRefShape = s_MngFXShape.Get(szShapeFileName);
		m_pShape->Duplicate(m_pRefShape);
	}

	if (m_iVersion >= 5)
	{
		file.Read(&m_fTexRotateVelocity, sizeof(float));
		file.Read(&m_fScaleVelX, sizeof(float));
		file.Read(&m_fScaleVelY, sizeof(float));
	}

	// TODO: implement m_bDistanceNumFix
	if (m_iVersion >= 6)
		file.Read(&m_bDistanceNumFix, sizeof(bool));

	// TODO: implement m_bParticleYAxisFix
	if (m_iVersion >= 7)
		file.Read(&m_bParticleYAxisFix, sizeof(bool));

	// TODO: implement m_bParticle_Not_Rot, m_vParticle_Not_Rotate_Axis
	if (m_iVersion >= 8)
	{
		file.Read(&m_bParticle_Not_Rotate, sizeof(bool));
		file.Read(&m_vParticle_Not_Rotate_Axis, sizeof(__Vector3));
	}

	// TODO: implement m_fPtRangeMin, m_fPtRangeMax
	if (m_iVersion >= 9)
	{
		file.Read(&m_fPtRangeMin, sizeof(float));
		file.Read(&m_fPtRangeMax, sizeof(float));
	}

	if (m_iVersion >= 10)
		file.Seek(5, SEEK_CUR);

	if (m_iVersion >= 11)
		file.Seek(12, SEEK_CUR);

	// NOTE: This should ideally just be an assertion, but we'll continue to allow it to run
	// and otherwise be broken for now.
#if defined(_DEBUG)
	if (m_iVersion > SUPPORTED_PART_VERSION)
	{
		TRACE(
			"!!! WARNING: CN3FXPartParticles::Load(%s) encountered version %d (base version %d). Needs support!",
			m_pRefBundle != nullptr ? m_pRefBundle->FileName().c_str() : "<unknown>",
			m_iVersion,
			m_iBaseVersion);
	}
#endif

	Init();

	return true;
}


//
//
//
bool CN3FXPartParticles::Save(File& file)
{
	if (!CN3FXPartBase::Save(file))
		return false;

	file.Write(&m_iNumParticle, sizeof(int));

	file.Write(&(m_pair_fParticleSize.first), sizeof(float));
	file.Write(&(m_pair_fParticleSize.second), sizeof(float));

	file.Write(&(m_pair_fParticleLife.first), sizeof(float));
	file.Write(&(m_pair_fParticleLife.second), sizeof(float));

	file.Write(&m_MinCreateRange, sizeof(__Vector3));
	file.Write(&m_MaxCreateRange, sizeof(__Vector3));

	file.Write(&m_fCreateDelay, sizeof(float));
	file.Write(&m_iNumCreate, sizeof(int));

	file.Write(&m_dwEmitType, sizeof(uint32_t));

	if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_SPREAD)
	{
		file.Write(&(m_uEmitCon.fEmitAngle), sizeof(float));
	}
	else if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_GATHER)
	{
		file.Write(&(m_uEmitCon.vGatherPoint.x), sizeof(float));
		file.Write(&(m_uEmitCon.vGatherPoint.y), sizeof(float));
		file.Write(&(m_uEmitCon.vGatherPoint.z), sizeof(float));
	}

	file.Write(&m_vPtEmitDir, sizeof(__Vector3));
	file.Write(&m_fPtVelocity, sizeof(float));
	file.Write(&m_fPtAccel, sizeof(float));
	file.Write(&m_fPtRotVelocity, sizeof(float));
	file.Write(&m_fPtGravity, sizeof(float));

	file.Write(&m_bChangeColor, sizeof(bool));
	if (m_bChangeColor)
	{
		int iNumKeyColor = NUM_KEY_COLOR;
		file.Write(&iNumKeyColor, sizeof(int));
		file.Write(&m_dwChangeColor, sizeof(uint32_t) * NUM_KEY_COLOR);
	}

	file.Write(&m_bAnimKey, sizeof(bool));
	if (m_bAnimKey)
	{
		file.Write(&m_fMeshFPS, sizeof(float));

		char szShapeFileName[_MAX_PATH];
		strcpy(szShapeFileName, m_pRefShape->FileName().c_str());
		file.Write(szShapeFileName, _MAX_PATH);
	}

	file.Write(&m_fTexRotateVelocity, sizeof(float));
	file.Write(&m_fScaleVelX, sizeof(float));
	file.Write(&m_fScaleVelY, sizeof(float));

	return true;
}


//
//
//
void CN3FXPartParticles::Start()
{
	CN3FXPartBase::Start();

}


//
//
//
void CN3FXPartParticles::Stop()
{
	CN3FXPartBase::Stop();

}


//
//
//
bool CN3FXPartParticles::Tick()
{
	if(!CN3FXPartBase::Tick()) return false;

#ifndef _N3TOOL
	float fDist = (s_CameraData.vEye - m_pRefBundle->m_vPos).Magnitude();

	if(fDist > 30.0f)
		m_iNumLodParticle = (int)(m_iNumParticle / 3.0f);
	else
	{
		m_iNumLodParticle = (int)(m_iNumParticle * 1 / 3.0f + (m_iNumParticle * 2 / 3.0f) * ((30.0f - fDist) / 30.0f));
	}
#else
	m_iNumLodParticle = m_iNumParticle;
#endif

	m_mtxVI = s_CameraData.mtxViewInverse;
	m_mtxVI.PosSet(0,0,0);

	m_CurrCreateDelay += CN3Base::s_fSecPerFrm;

	if(m_bAnimKey && m_pShape)
	{
		//frm 계산..
		float fFrm = m_fCurrLife * m_fMeshFPS;
		int share = (int) (fFrm / m_pShape->GetWholeFrm());
		fFrm -= ((float) share * m_pShape->GetWholeFrm());
		m_pShape->SetCurrFrm(fFrm);
		//TRACE("Frm: %3.2f life: %3.2f\n", fFrm, m_fCurrLife);

		m_pShape->m_mtxParent.Identity();
		Rotate();		
		Scaling();
		Move();
		m_pShape->Tick();
		
		m_vCurrPos = m_pShape->CenterPos();
		m_vEmitterDir = m_vCurrPos - m_vPrevShapePos;
		m_vEmitterDir.Normalize();
		m_vPrevShapePos = m_vCurrPos;
	}
	else
	{
		// tick emitter...
		m_vCurrVelocity += m_vAcceleration * CN3Base::s_fSecPerFrm;
		m_vCurrPos += m_vCurrVelocity * CN3Base::s_fSecPerFrm;
		if(m_vCurrVelocity.Magnitude()!=0.0f)
		{
			m_vEmitterDir = m_vCurrVelocity;
			m_vEmitterDir.Normalize();
		}
		else m_vEmitterDir.Set(0,0,1);
		
	}
	
	// make particles...
	if(m_CurrCreateDelay >= m_fCreateDelay && m_dwState==FX_PART_STATE_LIVE)	//파티클 생성...
	{
		m_CurrCreateDelay = 0.0f;
		CreateParticles();		
	}

	std::list<CN3FXParticle*>::iterator it;
	it = m_pVBList_Alive.begin();
	while(it!=m_pVBList_Alive.end())
	{
		CN3FXParticle* pParticle = (*it);
		if(pParticle && pParticle->Tick()==false)
		{
			it = DestroyParticle(it);
		}
		else it++;
	}
	return true;
}


//
//
//
void CN3FXPartParticles::Rotate()
{
	m_pShape->m_mtxParent.Rotation(m_vRotVelocity * m_fCurrLife);
}


//
//
//
void CN3FXPartParticles::Move()
{
	m_vCurrVelocity += m_vAcceleration*CN3Base::s_fSecPerFrm;
	m_vShapePos += m_vCurrVelocity*CN3Base::s_fSecPerFrm;
	m_pShape->m_mtxParent.PosSet(m_vShapePos);
}


//
//
//
void CN3FXPartParticles::Scaling()
{
	__Vector3 vScale;
	vScale.Set(1.0f, 1.0f, 1.0f);
	
	if(m_pRefBundle->m_bDependScale) vScale *= m_pRefBundle->m_fTargetScale;

	if(vScale.x < 0) vScale.x = 0;
	if(vScale.y < 0) vScale.y = 0;
	if(vScale.z < 0) vScale.z = 0;

	__Matrix44 mtx;
	mtx.Scale(vScale);	
	m_pShape->m_mtxParent *= mtx;
}


//
//	render...
//	일단은 파티클 하나씩 그리고....
//	나중에는 같은 텍스쳐 쓰는 것들끼리 묶어서 그리자...
//
void CN3FXPartParticles::Render()
{
	if(m_pVBList_Alive.size()==0) return;

	if(m_bAlpha) // Alpha 사용
	{
		std::list<CN3FXParticle*>::iterator it;
		it = m_pVBList_Alive.begin();
		for(;it!=m_pVBList_Alive.end();it++)
		{
			CN3FXParticle* pParticle = (*it);
			if(pParticle->m_iTexIdx>=m_iNumTex) continue;

			__AlphaPrimitive* pAP = s_AlphaMgr.Add();
			if(pAP)
			{
				//for(int i=0;i<6;i++) m_pIB[i] = m_wUnitIB[i];

				pAP->bUseVB				= FALSE;
				pAP->dwBlendDest		= m_dwDestBlend;
				pAP->dwBlendSrc			= m_dwSrcBlend;
				pAP->dwFVF				= FVF_XYZCOLORT1;
				pAP->dwPrimitiveSize	= sizeof(__VertexXyzColorT1);
				pAP->fCameraDistance	= CameraDist(pParticle->m_pVB[0], pParticle->m_pVB[1], pParticle->m_pVB[2]);

				if(m_ppRefTex[pParticle->m_iTexIdx]) pAP->lpTex = m_ppRefTex[pParticle->m_iTexIdx]->Get();
				else pAP->lpTex = nullptr;

				__Matrix44 mtxWorld;
				mtxWorld.Identity();
				pAP->MtxWorld = mtxWorld;
				pAP->nRenderFlags = m_dwRenderFlag;// | RF_UV_CLAMP;
				pAP->ePrimitiveType		= D3DPT_TRIANGLEFAN;
				pAP->nPrimitiveCount	= 2;
				pAP->nVertexCount		= NUM_VERTEX_PARTICLE;
				pAP->pVertices			= pParticle->m_pVB;
				pAP->pwIndices			= nullptr;
			}
		}		

		return; // 렌더링 안하지롱.
	}
		
	CN3Base::s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

	//s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha );
	//s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
    //s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );

	//uint32_t dwTAddrU, dwTAddrV;
	//s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSU, &dwTAddrU );
	//s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSV, &dwTAddrV );

	//s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
	//s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );		
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );		
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

	DWORD dwCullMode, dwZWriteEnable, dwZBufferEnable, dwLight, dwAlpha;
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlpha);
	s_lpD3DDev->GetRenderState( D3DRS_ZWRITEENABLE, &dwZWriteEnable);
	s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZBufferEnable );
	s_lpD3DDev->GetRenderState( D3DRS_CULLMODE, &dwCullMode );
	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLight );

	if(m_bAlpha != dwAlpha)
	{
		s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha);
		s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
		s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );
	}
	if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, m_dwZEnable);
	if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, m_dwZWrite);
	if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, m_dwLight);
	if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, m_dwDoubleSide);

	std::list<CN3FXParticle*>::iterator it;
	it = m_pVBList_Alive.begin();
	for(;it!=m_pVBList_Alive.end();it++)
	{
		CN3FXParticle* pParticle = (*it);
		if(pParticle->m_iTexIdx<m_iNumTex) 
			CN3Base::s_lpD3DDev->SetTexture(0, m_ppRefTex[pParticle->m_iTexIdx]->Get());
		else continue;

		//for(int i=0;i<6;i++) m_pIB[i] = pParticle->m_iID + m_wUnitIB[i];

		HRESULT hr;
		hr = CN3Base::s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLEFAN, 2, pParticle->m_pVB, sizeof(__VertexXyzColorT1));
		//hr = CN3Base::s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, m_pIB, D3DFMT_INDEX16, m_pVB, sizeof(__VertexXyzColorT1));
	}

	if(m_bAlpha != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZBufferEnable);
	if(m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);
	if(m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
	if(m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCullMode);

	//CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, dwTAddrU );
	//CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, dwTAddrV );
}

float CN3FXPartParticles::CameraDist(__Vector3 v1, __Vector3 v2, __Vector3 v3)
{
	__Vector3 vA = v1 - v3;
	__Vector3 vB = v2 - v3;
	__Vector3 vN;
	vN.Cross(vA, vB);
	vN.Normalize();

	float D = -(vN.x*v1.x + vN.y*v1.y + vN.z*v1.z);

	return (vN.x*s_CameraData.vEye.x + vN.y*s_CameraData.vEye.y + vN.z*s_CameraData.vEye.z + D);
}

/*
void CN3FXPartParticles::Render()
{
	if(m_pVBList_Alive.size()==0) return;

	m_mtxVI = s_CameraData.mtxViewInverse;
	m_mtxVI.PosSet(0,0,0);

	CN3Base::s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

	//uint32_t dwZWriteEnable;
	//CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &dwZWriteEnable);
	//s_lpD3DDev->SetRenderState( D3DRS_ZWRITEENABLE, FALSE);

	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, m_bAlpha );
	s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, m_dwSrcBlend );
    s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, m_dwDestBlend );

	uint32_t dwTAddrU, dwTAddrV;
	s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSU, &dwTAddrU );
	s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSV, &dwTAddrV );

	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
	
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );		
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );		
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

	if(!m_pNumTex)
	{
		m_pNumTex = new int[m_iNumTex];
		for(int i=0;i<m_iNumTex;i++) m_pNumTex[i] = 0;
	}
	
	//
	////////////////////////////////////////////////////////////////////////////////////
	//ParticleGreater pg;
	//m_pVBList_Alive.sort(pg);
	// 이거이 안되서 안에 있는 루틴 그대로 베껴서 PSort()함수 만들었엉...ㅠ.ㅠ;;
	PSort();

	std::list<CN3FXParticle*>::iterator it;
	it = m_pVBList_Alive.begin();
	int idx = 0;
	int VBIdx;
	for(;it!=m_pVBList_Alive.end();it++,idx++)
	{
		VBIdx = idx*NUM_VERTEX_PARTICLE;
		CN3FXParticle* pParticle = (*it);

		m_pVB[VBIdx] = ((m_vUnit[0] * pParticle->m_fSize) * m_mtxVI) + pParticle->m_vWdPos;
		m_pVB[VBIdx].color = pParticle->m_dwColor;
		m_pVB[VBIdx+1] = ((m_vUnit[1] * pParticle->m_fSize) * m_mtxVI) + pParticle->m_vWdPos;
		m_pVB[VBIdx+1].color = pParticle->m_dwColor;
		m_pVB[VBIdx+2] = ((m_vUnit[2] * pParticle->m_fSize) * m_mtxVI) + pParticle->m_vWdPos;
		m_pVB[VBIdx+2].color = pParticle->m_dwColor;
				
		m_pNumTex[pParticle->m_iTexIdx]++;		
	}
	/////////////////////////////////////////////////////////////////////////////////////////
	//

	VBIdx = 0;
	for(int TexIdx=0;TexIdx<m_iNumTex;TexIdx++)
	{
		if(m_pNumTex[TexIdx]==0) continue;

		if(m_ppRefTex[TexIdx]) CN3Base::s_lpD3DDev->SetTexture(0, m_ppRefTex[TexIdx]->Get());
		else
			CN3Base::s_lpD3DDev->SetTexture(0, nullptr);

		HRESULT hr;
		hr = CN3Base::s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLELIST, m_pNumTex[TexIdx], &(m_pVB[VBIdx]), sizeof(__VertexXyzColorT1));
		VBIdx += (m_pNumTex[TexIdx]*NUM_VERTEX_PARTICLE);
		m_pNumTex[TexIdx] = 0;
	}

	//CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);

	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, dwTAddrU );
	CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, dwTAddrV );
}
*/

//
//
//
void CN3FXPartParticles::InitVB()
{
	for (auto itr = m_pVBList_Alive.begin(); itr != m_pVBList_Alive.end(); ++itr)
		delete *itr;
	m_pVBList_Alive.clear();

	for (auto itr = m_pVBList_Dead.begin(); itr != m_pVBList_Dead.end(); ++itr)
		delete *itr;
	m_pVBList_Dead.clear();

	for(int i=0;i<m_iNumParticle;i++)
	{
		CN3FXParticle* pParticle = new CN3FXParticle;
		pParticle->m_iID = i * NUM_VERTEX_PARTICLE;
		m_pVBList_Dead.push_back(pParticle);
	}

	if(m_pVB) delete[] m_pVB;
	m_pVB = new __VertexXyzColorT1[m_iNumParticle*NUM_VERTEX_PARTICLE];

	//if(m_pIB) delete[] m_pIB;
	//m_pIB = new uint16_t[m_iNumParticle*6];
}


//
//
//
std::list<CN3FXParticle*>::iterator CN3FXPartParticles::DestroyParticle(std::list<CN3FXParticle*>::iterator it)
{
	CN3FXParticle* pParticle = (*it);

	it = m_pVBList_Alive.erase(it);
	m_pVBList_Dead.push_back(pParticle);

	pParticle->m_dwColor = 0xffffffff;
	pParticle->m_fCurrLife = 0.0f;
	pParticle->m_fDropVel = 0.0f;
	pParticle->m_fDropY = 0.0f;
	pParticle->m_fLife = m_pair_fParticleLife.first + ((m_pair_fParticleLife.second - m_pair_fParticleLife.first) * (float)(rand()%100) / 100.0f);
	pParticle->m_fSize = m_pair_fParticleSize.first + ((m_pair_fParticleSize.second - m_pair_fParticleSize.first) * (float)(rand()%100) / 100.0f);
	pParticle->m_iNumTex = m_iNumTex;
	pParticle->m_iTexIdx = 0;
	pParticle->m_vLcPos.Set(0.0f, 0.0f, 0.0f);
	return it;
}


//
//
//
void CN3FXPartParticles::CreateParticles_Spread()
{
	std::list<CN3FXParticle*>::iterator it;

	for(int i=0; i<m_iNumCreate; i++)
	{
		it = m_pVBList_Dead.begin();
		if(it==m_pVBList_Dead.end()) break;

		CN3FXParticle* pParticle = (*it);

		__Vector3 vDir;
		__Matrix44 RotMtx;

		float fUnitAngleXZ;
		if(m_uEmitCon.fEmitAngle!=0) fUnitAngleXZ = (float)(rand()%(int)m_uEmitCon.fEmitAngle) - (m_uEmitCon.fEmitAngle/2.0f);
		else fUnitAngleXZ = 0.0f;

		float fUnitAxisZ = (float)(rand()%360);

		vDir.Set(sin(DegreesToRadians(fUnitAngleXZ)), 0, cos(DegreesToRadians(fUnitAngleXZ)));
		
		RotMtx.RotationZ(fUnitAxisZ);
		vDir *= RotMtx;
		vDir.Normalize();

		__Vector3 vDirPart, vDirEmit;
		__Vector3 v(0.0f, 0.0f, 1.0f);
		vDirPart = m_vEmitterDir;
		vDirEmit = m_vPtEmitDir;

		__Quaternion Qt;

		//bundle의 방향 적용..
		if(m_pRefBundle)
		{			
			if(RotateQuaternion(v, m_pRefBundle->m_vDir, &Qt))
			{
				RotMtx = Qt;
				//vDir *= RotMtx;
				vDirPart *= RotMtx;
				//vDirEmit *=  RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				//vDir *= -1.0f;
				vDirPart *= -1.0f;
				//vDirEmit *= -1.0f;
			}
		}

		//part(emiiter)의 방향 적용
		//if(m_vEmitterDir.Magnitude()!=0)
		if(vDirPart.Magnitude()!=0)
		{
			//if(RotateQuaternion(v, m_vEmitterDir, &Qt))
			if(RotateQuaternion(v, vDirPart, &Qt))
			{
				RotMtx = Qt;
				//vDir *= RotMtx;
				//vDirPart *= RotMtx;
				vDirEmit *=  RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				//vDir *= -1.0f;
				//vDirPart *= -1.0f;
				vDirEmit *= -1.0f;
			}
		}

		//뿌려지는 방향 적용..
		//if(RotateQuaternion(v, m_vPtEmitDir, &Qt))
		if(RotateQuaternion(v, vDirEmit, &Qt))
		{
			RotMtx = Qt;
			vDir *= RotMtx;
			//vDirPart *= RotMtx;
			//vDirEmit *=  RotMtx;
		}
		else if(Qt.w!=1.0f)
		{
			vDir *= -1.0f;
			//vDirPart *= -1.0f;
			//vDirEmit *= -1.0f;
		}

		pParticle->m_vAxis = vDirEmit;		
		pParticle->m_vVelocity = vDir * m_fPtVelocity;

		if(m_pRefBundle && m_pRefBundle->m_bDependScale)
		{
			pParticle->m_fSize *= m_pRefBundle->m_fTargetScale;
					
			//pParticle->m_vVelocity.x *= m_pRefBundle->m_vTargetScale.x;
			//pParticle->m_vVelocity.y *= m_pRefBundle->m_vTargetScale.y;
			//pParticle->m_vVelocity.z *= m_pRefBundle->m_vTargetScale.z;
			pParticle->m_vVelocity *= m_pRefBundle->m_fTargetScale;

			__Vector3 MaxCreate, MinCreate;
			if(m_bAnimKey && m_pShape)
			{
				__Vector3 Scale = m_pShape->Scale();
				MaxCreate.x = m_MaxCreateRange.x * Scale.x;
				MaxCreate.y = m_MaxCreateRange.y * Scale.y;
				MaxCreate.z = m_MaxCreateRange.z * Scale.z;

				MinCreate.x = m_MinCreateRange.x * Scale.x;
				MinCreate.y = m_MinCreateRange.y * Scale.y;
				MinCreate.z = m_MinCreateRange.z * Scale.z;
			}
			else
			{
				//MaxCreate.x = m_MaxCreateRange.x * m_pRefBundle->m_vTargetScale.x;
				//MaxCreate.y = m_MaxCreateRange.y * m_pRefBundle->m_vTargetScale.y;
				//MaxCreate.z = m_MaxCreateRange.z * m_pRefBundle->m_vTargetScale.z;
				MaxCreate = m_MaxCreateRange * m_pRefBundle->m_fTargetScale;

				//MinCreate.x = m_MinCreateRange.x * m_pRefBundle->m_vTargetScale.x;
				//MinCreate.y = m_MinCreateRange.y * m_pRefBundle->m_vTargetScale.y;
				//MinCreate.z = m_MinCreateRange.z * m_pRefBundle->m_vTargetScale.z;
				MinCreate = m_MinCreateRange * m_pRefBundle->m_fTargetScale;
			}
			
			__Vector3 vCreatePos;
			vCreatePos.Set( MinCreate.x + ((MaxCreate.x - MinCreate.x) * ((float)(rand()%100) / 100.0f)),
							MinCreate.y + ((MaxCreate.y - MinCreate.y) * ((float)(rand()%100) / 100.0f)),
							MinCreate.z + ((MaxCreate.z - MinCreate.z) * ((float)(rand()%100) / 100.0f)));

			if(RotateQuaternion(__Vector3(0.0f, 0.0f, 1.0f), pParticle->m_vAxis, &Qt))
			{
				RotMtx = Qt;
				vCreatePos *= RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				vCreatePos *= -1.0f;
			}

			pParticle->m_vCreatePoint = m_pRefBundle->m_vPos + m_vCurrPos;
			pParticle->m_vLcPos = vCreatePos;			
		}
		else
		{
			__Vector3 MaxCreate, MinCreate;
			MaxCreate = m_MaxCreateRange;
			MinCreate = m_MinCreateRange;
			if(m_bAnimKey && m_pShape)
			{
				__Vector3 Scale = m_pShape->Scale();
				MaxCreate.x *= Scale.x;
				MaxCreate.y *= Scale.y;
				MaxCreate.z *= Scale.z;

				MinCreate.x *= Scale.x;
				MinCreate.y *= Scale.y;
				MinCreate.z *= Scale.z;
			}

			__Vector3 vCreatePos;
			vCreatePos.Set( MinCreate.x + ((MaxCreate.x - MinCreate.x) * ((float)(rand()%100) / 100.0f)),
							MinCreate.y + ((MaxCreate.y - MinCreate.y) * ((float)(rand()%100) / 100.0f)),
							MinCreate.z + ((MaxCreate.z - MinCreate.z) * ((float)(rand()%100) / 100.0f)));

			if(RotateQuaternion(__Vector3(0.0f, 0.0f, 1.0f), pParticle->m_vAxis, &Qt))
			{
				RotMtx = Qt;
				vCreatePos *= RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				vCreatePos *= -1.0f;
			}

			pParticle->m_vCreatePoint = m_pRefBundle->m_vPos + m_vCurrPos;
			pParticle->m_vLcPos = vCreatePos;
		}

		m_pVBList_Alive.push_back((*it));
		m_pVBList_Dead.erase(it);					
	}
}


//
//
//
void CN3FXPartParticles::CreateParticles_Gather()
{
	std::list<CN3FXParticle*>::iterator it;

	for(int i=0; i<m_iNumCreate; i++)
	{
		it = m_pVBList_Dead.begin();
		if(it==m_pVBList_Dead.end()) break;

		CN3FXParticle* pParticle = (*it);

		__Vector3 vDir;
		__Matrix44 RotMtx;
		
		vDir.Set(m_uEmitCon.vGatherPoint.x, m_uEmitCon.vGatherPoint.y, m_uEmitCon.vGatherPoint.z); 
		//	vDir.Normalize();
		
		__Vector3 vDirPart, vDirEmit;
		__Vector3 v(0.0f, 0.0f, 1.0f);
		vDirPart = m_vEmitterDir;
		vDirEmit = m_vPtEmitDir;

		__Quaternion Qt;

		//bundle의 방향 적용..
		if(m_pRefBundle)
		{			
			if(RotateQuaternion(v, m_pRefBundle->m_vDir, &Qt))
			{
				RotMtx = Qt;
				//vDir *= RotMtx;
				vDirPart *= RotMtx;
				//vDirEmit *=  RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				//vDir *= -1.0f;
				vDirPart *= -1.0f;
				//vDirEmit *= -1.0f;
			}
		}

		//part(emiiter)의 방향 적용
		if(vDirPart.Magnitude()!=0)
		{
			if(RotateQuaternion(v, vDirPart, &Qt))
			{
				RotMtx = Qt;
				//vDir *= RotMtx;
				//vDirPart *= RotMtx;
				vDirEmit *=  RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				//vDir *= -1.0f;
				//vDirPart *= -1.0f;
				vDirEmit *= -1.0f;
			}
		}
		//뿌려지는 방향 적용..
		//if(RotateQuaternion(v, m_vPtEmitDir, &Qt))
		if(RotateQuaternion(v, vDirEmit, &Qt))
		{
			RotMtx = Qt;
			vDir *= RotMtx;
			//vDirPart *= RotMtx;
			//vDirEmit *=  RotMtx;
		}
		else if(Qt.w!=1.0f)
		{
			vDir *= -1.0f;
			//vDirPart *= -1.0f;
			//vDirEmit *= -1.0f;
		}

		pParticle->m_vAxis = vDirEmit;		
		
		if(m_pRefBundle && m_pRefBundle->m_bDependScale)
		{
			//pParticle->m_fSize *= m_pRefBundle->m_vTargetScale.x;
			pParticle->m_fSize *= m_pRefBundle->m_fTargetScale;
					
			//pParticle->m_vVelocity.x *= m_pRefBundle->m_vTargetScale.x;
			//pParticle->m_vVelocity.y *= m_pRefBundle->m_vTargetScale.y;
			//pParticle->m_vVelocity.z *= m_pRefBundle->m_vTargetScale.z;
			pParticle->m_vVelocity *= m_pRefBundle->m_fTargetScale;

			__Vector3 MaxCreate, MinCreate;
			if(m_bAnimKey && m_pShape)
			{
				__Vector3 Scale = m_pShape->Scale();
				MaxCreate.x = m_MaxCreateRange.x * Scale.x;
				MaxCreate.y = m_MaxCreateRange.y * Scale.y;
				MaxCreate.z = m_MaxCreateRange.z * Scale.z;

				MinCreate.x = m_MinCreateRange.x * Scale.x;
				MinCreate.y = m_MinCreateRange.y * Scale.y;
				MinCreate.z = m_MinCreateRange.z * Scale.z;
			}
			else
			{
				//MaxCreate.x = m_MaxCreateRange.x * m_pRefBundle->m_vTargetScale.x;
				//MaxCreate.y = m_MaxCreateRange.y * m_pRefBundle->m_vTargetScale.y;
				//MaxCreate.z = m_MaxCreateRange.z * m_pRefBundle->m_vTargetScale.z;
				MaxCreate = m_MaxCreateRange * m_pRefBundle->m_fTargetScale;

				//MinCreate.x = m_MinCreateRange.x * m_pRefBundle->m_vTargetScale.x;
				//MinCreate.y = m_MinCreateRange.y * m_pRefBundle->m_vTargetScale.y;
				//MinCreate.z = m_MinCreateRange.z * m_pRefBundle->m_vTargetScale.z;
				MinCreate = m_MinCreateRange * m_pRefBundle->m_fTargetScale;
			}

			__Vector3 vCreatePos;
			vCreatePos.Set( MinCreate.x + ((MaxCreate.x - MinCreate.x) * ((float)(rand()%100) / 100.0f)),
							MinCreate.y + ((MaxCreate.y - MinCreate.y) * ((float)(rand()%100) / 100.0f)),
							MinCreate.z + ((MaxCreate.z - MinCreate.z) * ((float)(rand()%100) / 100.0f)));

			if(RotateQuaternion(__Vector3(0.0f, 0.0f, 1.0f), pParticle->m_vAxis, &Qt))
			{
				RotMtx = Qt;
				vCreatePos *= RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				vCreatePos *= -1.0f;
			}

			pParticle->m_vCreatePoint = m_pRefBundle->m_vPos + m_vCurrPos;
			pParticle->m_vLcPos = vCreatePos;
			vDir -= vCreatePos;
			vDir.Normalize();
			pParticle->m_vVelocity = vDir * m_fPtVelocity;
		}
		else
		{
			__Vector3 MaxCreate, MinCreate;
			MaxCreate = m_MaxCreateRange;
			MinCreate = m_MinCreateRange;
			if(m_bAnimKey && m_pShape)
			{
				__Vector3 Scale = m_pShape->Scale();
				MaxCreate.x *= Scale.x;
				MaxCreate.y *= Scale.y;
				MaxCreate.z *= Scale.z;

				MinCreate.x *= Scale.x;
				MinCreate.y *= Scale.y;
				MinCreate.z *= Scale.z;
			}

			__Vector3 vCreatePos;
			vCreatePos.Set( MinCreate.x + ((MaxCreate.x - MinCreate.x) * ((float)(rand()%100) / 100.0f)),
							MinCreate.y + ((MaxCreate.y - MinCreate.y) * ((float)(rand()%100) / 100.0f)),
							MinCreate.z + ((MaxCreate.z - MinCreate.z) * ((float)(rand()%100) / 100.0f)));

			if(RotateQuaternion(__Vector3(0.0f, 0.0f, 1.0f), pParticle->m_vAxis, &Qt))
			{
				RotMtx = Qt;
				vCreatePos *= RotMtx;
			}
			else if(Qt.w!=1.0f)
			{
				vCreatePos *= -1.0f;
			}

			pParticle->m_vCreatePoint = m_pRefBundle->m_vPos + m_vCurrPos;
			pParticle->m_vLcPos = vCreatePos;
			vDir -= vCreatePos;
			vDir.Normalize();
			pParticle->m_vVelocity = vDir * m_fPtVelocity;
		}

		m_pVBList_Alive.push_back((*it));
		m_pVBList_Dead.erase(it);					
	}
}


//
//
//
void CN3FXPartParticles::CreateParticles()
{
	int iNumLiveParticle = static_cast<int>(m_pVBList_Alive.size());
	if (iNumLiveParticle > m_iNumLodParticle)
		return;

	if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_SPREAD)
		CreateParticles_Spread();
	else if (m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_GATHER)
		CreateParticles_Gather();
}

//
//
//
bool CN3FXPartParticles::IsDead()
{
	if(m_pVBList_Alive.size()==0) return true;

	return false;
}

void CN3FXPartParticles::Duplicate(CN3FXPartParticles* pSrc)
{
	if(!pSrc) return;

	CN3FXPartBase::Duplicate(pSrc);

	m_iNumParticle = pSrc->m_iNumParticle;
	if(m_iNumParticle>0) InitVB();

	m_pair_fParticleSize.first = pSrc->m_pair_fParticleSize.first;
	m_pair_fParticleSize.second = pSrc->m_pair_fParticleSize.second;

	m_pair_fParticleLife.first = pSrc->m_pair_fParticleLife.first;
	m_pair_fParticleLife.second = pSrc->m_pair_fParticleLife.second;

	m_MinCreateRange = pSrc->m_MinCreateRange;
	m_MaxCreateRange = pSrc->m_MaxCreateRange;

	m_fCreateDelay = pSrc->m_fCreateDelay;
	m_iNumCreate = pSrc->m_iNumCreate;

	m_dwEmitType = pSrc->m_dwEmitType;
	if(	m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_SPREAD )
	{
		m_uEmitCon.fEmitAngle = pSrc->m_uEmitCon.fEmitAngle;
	}
	else if( m_dwEmitType == FX_PART_PARTICLE_EMIT_TYPE_GATHER )
	{
		m_uEmitCon.vGatherPoint = pSrc->m_uEmitCon.vGatherPoint;
	}

	m_vPtEmitDir = pSrc->m_vPtEmitDir;
	m_fPtVelocity = pSrc->m_fPtVelocity;
	m_fPtAccel = pSrc->m_fPtAccel;
	m_fPtRotVelocity = pSrc->m_fPtRotVelocity;
	m_fPtGravity = pSrc->m_fPtGravity;

	m_bChangeColor = pSrc->m_bChangeColor;
	if(m_bChangeColor)
	{
		memcpy((char*)&(m_dwChangeColor[0]), (char*)pSrc->m_dwChangeColor, sizeof(uint32_t)*NUM_KEY_COLOR);
	}

	m_bAnimKey = pSrc->m_bAnimKey;
	if(m_bAnimKey)
	{
		m_fMeshFPS = pSrc->m_fMeshFPS;

		if(m_pShape)
		{
			delete m_pShape;
			m_pShape = nullptr;
		}

		m_pShape = new CN3FXShape;

		m_pRefShape = s_MngFXShape.Get(pSrc->m_pRefShape->FileName());
		m_pShape->Duplicate(m_pRefShape);
	}

	m_fTexRotateVelocity = pSrc->m_fTexRotateVelocity;
	m_fScaleVelX = pSrc->m_fScaleVelX;
	m_fScaleVelY = pSrc->m_fScaleVelY;

	Init();

	return;	
}


//
//
//
bool CN3FXPartParticles::GetColor(int key, uint32_t& color)
{
	if(key<0 || key>=NUM_KEY_COLOR) return false;
	
	color = m_dwChangeColor[key];
	return true;
}


//
// 두 방향 벡터가 있을때 하나의 방향벡터에서 다른 하나의 방향벡터로 회전하는 mtx구하기..
//
bool CN3FXPartParticles::RotateQuaternion(__Vector3 vSrcDir, __Vector3 vDestDir, __Quaternion* pQt)
{
	vSrcDir.Normalize();
	vDestDir.Normalize();

	__Vector3 vDirAxis;
	float fDirAng; 

	vDirAxis.Cross(vSrcDir, vDestDir);

	fDirAng = acos(vSrcDir.Dot(vDestDir));

	pQt->RotationAxis(vDirAxis, fDirAng);

	if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) return false;
	
	return true;
}



//
///////////////////////////////////////////////////////////////////////////////////////////////
// related sort list...
// list의 sort함수 베꼈당..-.-
// 제대로 동작 안하더라..ㅠ.ㅠ
//

void CN3FXPartParticles::PSort()
{
	if (2 <= m_pVBList_Alive.size())
	{
		const size_t _MAXN = 15;
		std::list<CN3FXParticle*> _X, _A[_MAXN + 1];
		size_t _N = 0;
		while (!m_pVBList_Alive.empty())
		{
			_X.splice(_X.begin(), m_pVBList_Alive, m_pVBList_Alive.begin());
			size_t _I;
			for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
			{
				PMerge(_A[_I], _X);//_A[_I].merge(_X, _Pr);
				_A[_I].swap(_X);
			}
			if (_I == _MAXN) PMerge(_A[_I], _X); // _A[_I].merge(_X, _Pr);
			else
			{
				_A[_I].swap(_X);
				if (_I == _N) ++_N;
			}
		}
		while (0 < _N) PMerge(m_pVBList_Alive, _A[--_N]);//m_pVBList_Alive.merge(_A[--_N], _Pr); 
	}
}

void CN3FXPartParticles::PMerge(std::list<CN3FXParticle*>& l1, std::list<CN3FXParticle*>& l2)
{
	if (&l1 != &l2)
	{
		std::list<CN3FXParticle*>::iterator _F1 = l1.begin(), _L1 = l1.end();
		std::list<CN3FXParticle*>::iterator _F2 = l2.begin(), _L2 = l2.end();
		while (_F1 != _L1 && _F2 != _L2)
			if (PComp(*_F2, *_F1))
			{
				std::list<CN3FXParticle*>::iterator _Mid2 = _F2;
				l1.splice(_F1, l2, _F2, ++_Mid2);
				_F2 = _Mid2;
			}
			else ++_F1;
			if (_F2 != _L2) l1.splice(_L1, l2, _F2, _L2);			
	}
}

bool CN3FXPartParticles::PComp(CN3FXParticle* pP1, CN3FXParticle* pP2)
{
	if(pP1->m_iTexIdx < pP2->m_iTexIdx) return true;
	return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//



// ===== END N3Base/N3FXPartParticles.cpp =====

// ===== BEGIN N3Base/N3FXPartParticles.h =====
#line 1 "N3Base/N3FXPartParticles.h"
﻿// N3FXParticle.h: interface for the CN3FXParticle class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTPARTICLES_H__
#define __N3FXPARTPARTICLES_H__

#pragma warning(disable : 4786)

#include <list>
#include "N3FXPartBase.h"

class CN3FXParticle;
class CN3FXShape;
class CN3FXPartParticles : public CN3FXPartBase  
{
public:
	static constexpr int SUPPORTED_PART_VERSION = 11; // supported as far as reading only

	//related whole particle system...
	__VertexXyzColorT1			m_vUnit[NUM_VERTEX_PARTICLE];
	//uint16_t					m_wUnitIB[6];

	__VertexXyzColorT1*			m_pVB;
	//uint16_t*					m_pIB;

	__Matrix44					m_mtxVI;				//	inverse view mtx..

	int							m_iNumParticle;			//	파티클의 총 수..(maximum)
	int							m_iNumLodParticle;		//	거리에 따른 파티클 갯수
	//float						m_fParticleSize;		//	파티클의 크기
	std::pair<float, float>		m_pair_fParticleSize;	//	파티클 크기의 범위
	std::pair<float, float>		m_pair_fParticleLife;	//	파티클 생명의 범위
	
	std::list<CN3FXParticle*>	m_pVBList_Alive;		//	살아있는 파티클을 담고 있는 버퍼..
	std::list<CN3FXParticle*>	m_pVBList_Dead;			//	죽은 파티클을 담고 있는 버퍼..

	float						m_fCreateDelay;			//	파티클 생성 시간 간격.
	float						m_CurrCreateDelay;		//	현재 까지 create delay time..
	int							m_iNumCreate;			//	한번 생성시 만들어지는 파티클 수.

	__Vector3					m_MinCreateRange;		//	파티클 생성 자유도 범위..min..
	__Vector3					m_MaxCreateRange;		//	파티클 생성 자유도 범위..max..

	//emitter...
	uint32_t					m_dwEmitType;			//	발사형태..(spread, gather)..
	PARTICLEEMITCONDITION		m_uEmitCon;				//	발사형태에 따른 필요 데이타..
	__Vector3					m_vEmitterDir;
	__Vector3					m_vPrevShapePos;
	__Vector3					m_vShapePos;

	//particle..
	__Vector3	m_vPtEmitDir;		//emitter에서 파티클 분사방향..
	float		m_fPtVelocity;		//파티클 분사속도..
	float		m_fPtAccel;			//분사 가속도..
	float		m_fPtRotVelocity;	//파티클 회전 속도..
	float		m_fPtGravity;		//중력가속도..

	//related particle color....
	uint32_t	m_dwChangeColor[NUM_KEY_COLOR];
	bool		m_bChangeColor;

	//related animation key
	CN3FXShape*	m_pShape;
	CN3FXShape*	m_pRefShape;
	float		m_fMeshFPS;
	bool		m_bAnimKey;

	//particle local rotate......2002.10.21.
	float		m_fTexRotateVelocity;		//	파티클 텍스쳐를 로컬 Z축으로 회전시켜서 빙글빙글 도는 것처럼 보이게...(속도)
	float		m_fScaleVelX;
	float		m_fScaleVelY;

	// N3FXParticle needs implementation of these methods
	bool m_bDistanceNumFix;
	bool m_bParticleYAxisFix;
	bool m_bParticle_Not_Rotate;
	__Vector3 m_vParticle_Not_Rotate_Axis; // 파티클이 회전하지 않도록 하는 축
	float m_fPtRangeMin;
	float m_fPtRangeMax;
	// N3FXParticle needs implementation of these methods

protected:
	void Rotate();
	void Scaling();
	void Move();
		    
	void InitVB();
	void CreateParticles();
	void CreateParticles_Spread();
	void CreateParticles_Gather();

	std::list<CN3FXParticle*>::iterator	DestroyParticle(std::list<CN3FXParticle*>::iterator it);

	bool IsDead() override;

	bool RotateQuaternion(__Vector3 vSrcDir, __Vector3 vDestDir, __Quaternion* pQt);
	float CameraDist(__Vector3 v1, __Vector3 v2, __Vector3 v3);

	//////////////////////////////////////////////
	//m_pVBList_Alive를 소트하기위함이야..
	void PSort();
	void PMerge(std::list<CN3FXParticle*>& l1, std::list<CN3FXParticle*>& l2);
	bool PComp(CN3FXParticle* pP1, CN3FXParticle* pP2);
	//
	//////////////////////////////////////////////
	
public:
	void Init() override;			// 각종 변수들을 처음 로딩한 상태로 초기화...
	void Start() override;			// 파트 구동 시작.
	void Stop() override;			// 파트 구동 멈춤..
	bool Tick() override;			// ticktick...
	void Render() override;			// 화면에 뿌리기..
	bool Load(File& file) override;	// 게임파일 불러오기.
	bool Save(File& file) override;	// 게임파일 저장오기.
	void Duplicate(CN3FXPartParticles* pSrc);

	bool GetColor(int key, uint32_t& color);

	CN3FXPartParticles();	
	~CN3FXPartParticles() override;

#ifdef _N3TOOL
	bool ParseScript(char* szCommand, char* szBuff0, char* szBuff1, char* szBuff2, char* szBuff3);

	bool m_bChangeColorKey[NUM_KEY_COLOR];
	bool m_bChangeAlphaKey[NUM_KEY_COLOR];
#endif // end of _N3TOOL
};

#endif // #ifndef __N3FXPARTPARTICLES_H__



// ===== END N3Base/N3FXPartParticles.h =====

// ===== BEGIN N3Base/N3FXParticle.cpp =====
#line 1 "N3Base/N3FXParticle.cpp"
﻿// N3FXParticle.cpp: implementation of the CN3FXParticle class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXParticle.h"
#include "N3FXPartParticles.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXParticle::CN3FXParticle()
{
	m_fLife = 0.0f;
	m_fCurrLife = 0.0f;
	m_iTexIdx = 0;

	m_pRefParent = nullptr;

	m_vCreatePoint.Set(0.0f, 0.0f, 0.0f);
	m_vAxis.Set(0.0f, 0.0f, 1.0f);

	m_vLcPos.Set(0.0f, 0.0f, 0.0f);
	m_vWdPos - m_vLcPos;
	m_dwColor = 0xffffffff;

	m_vVelocity.Set(0.0f, 0.0f, 0.0f);
	m_vAccel.Set(0.0f, 0.0f, 0.0f);

	m_fRot = 0.0f;
	m_fSize = 0.0f;
	//m_fCurrSize = 0.0f;

	m_fDropY = m_fDropVel = 0.0f;

	m_pVB = nullptr;
	/*
	m_pVB = new __VertexXyzColorT1[NUM_VERTEX_PARTICLE];
	m_pVB[0].Set(0,0,0,0xffffffff, 0.0f, -1.0f);
	m_pVB[1].Set(0,0,0,0xffffffff, 2.0f, 1.0f);
	m_pVB[2].Set(0,0,0,0xffffffff, 0.0f, 1.0f);	
	*/
}


CN3FXParticle::~CN3FXParticle()
{
	//delete[] m_pVB;
	m_pVB = nullptr;
}

bool CN3FXParticle::Tick()
{
	if(!m_pRefParent) return false;
	if(m_pRefParent->m_bChangeColor && m_fCurrLife >= m_fLife) return false;
	if(!m_pRefParent->m_bChangeColor && m_fCurrLife >= (m_pRefParent->m_fFadeIn + m_fLife + m_pRefParent->m_fFadeOut)) return false;

	///////////////////////////////////////////////
	//현재처리..
	__Quaternion qt;
	qt.RotationAxis(m_vAxis, m_fRot);

	__Matrix44 mtxRot;
	mtxRot = qt;

	m_vWdPos = m_vCreatePoint + (m_vLcPos*mtxRot);
	m_vWdPos.y -= m_fDropY;

	__Matrix44 mtxVI = m_pRefParent->m_mtxVI;

	m_pVB = &(m_pRefParent->m_pVB[m_iID]);

	__Matrix44 mtxRotateTex;
	mtxRotateTex.Identity();
	mtxRotateTex.RotationZ(m_pRefParent->m_fTexRotateVelocity * m_fCurrLife);
	__Vector3 vScale;
	vScale.Set(m_fSize + m_pRefParent->m_fScaleVelX * m_fCurrLife,
				m_fSize + m_pRefParent->m_fScaleVelY * m_fCurrLife, m_fSize);
	if(vScale.x < 0.0f) vScale.x = 0.0f;
	if(vScale.y < 0.0f) vScale.y = 0.0f;
	if(vScale.z < 0.0f) vScale.z = 0.0f;

	for(int i=0;i<NUM_VERTEX_PARTICLE;i++)
	{
		m_pVB[i] = ((m_pRefParent->m_vUnit[i] * vScale) * mtxRotateTex * mtxVI) + m_vWdPos;

		m_pVB[i].tu = m_pRefParent->m_vUnit[i].tu;
		m_pVB[i].tv = m_pRefParent->m_vUnit[i].tv;
	}
	
	///////////////////////////////////////////////
	//다음준비..
	m_vLcPos += m_vVelocity * CN3Base::s_fSecPerFrm;

	if(m_pRefParent->m_bChangeColor)
	{
		int idx = (int)(m_fCurrLife * (float)NUM_KEY_COLOR / m_fLife);
		if(idx>=NUM_KEY_COLOR) idx = NUM_KEY_COLOR - 1;
		m_dwColor = m_pRefParent->m_dwChangeColor[idx];
	}
	else
	{
		if(m_fCurrLife <= m_pRefParent->m_fFadeIn)
		{
			uint32_t Alpha = (uint32_t)(255.0f * m_fCurrLife / m_pRefParent->m_fFadeIn);
			Alpha = (Alpha<<24);
			m_dwColor = Alpha + 0x00ffffff;
		}
		else if(m_fCurrLife < (m_pRefParent->m_fFadeIn + m_fLife)) m_dwColor = 0xffffffff;
		else if(m_fCurrLife < (m_pRefParent->m_fFadeIn + m_fLife + m_pRefParent->m_fFadeOut))
		{
			uint32_t Alpha = (uint32_t)(255.0f * ((m_pRefParent->m_fFadeIn + m_fLife + m_pRefParent->m_fFadeOut)-m_fCurrLife) / m_pRefParent->m_fFadeOut);
			Alpha = (Alpha<<24);
			m_dwColor = Alpha + 0x00ffffff;
			//m_fSize = m_pRefParent->m_fParticleSize * AlphaRatio;		
		}
		else m_dwColor = 0x00ffffff;
	}

	for(int i=0;i<NUM_VERTEX_PARTICLE;i++) m_pVB[i].color = m_dwColor;

	m_vVelocity += m_vAccel * CN3Base::s_fSecPerFrm;
	m_fRot += CN3Base::s_fSecPerFrm*m_pRefParent->m_fPtRotVelocity;

	m_fDropVel += m_pRefParent->m_fPtGravity * CN3Base::s_fSecPerFrm;
	m_fDropY += m_fDropVel * CN3Base::s_fSecPerFrm;

	m_fCurrLife += CN3Base::s_fSecPerFrm;

	m_iTexIdx = (int)(m_fCurrLife * m_pRefParent->m_fTexFPS) % m_iNumTex;

	return true;
}
// ===== END N3Base/N3FXParticle.cpp =====

// ===== BEGIN N3Base/N3FXParticle.h =====
#line 1 "N3Base/N3FXParticle.h"
﻿// N3FXPartParticles.h: interface for the CN3FXPartParticles class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTICLE_H__
#define __N3FXPARTICLE_H__

#include "N3Base.h"
//#include "N3FXDef.h"
class CN3FXPartParticles;

class CN3FXParticle : public CN3Base  
{
public:
	CN3FXPartParticles*	m_pRefParent;
	__VertexXyzColorT1*	m_pVB;

	int			m_iID;
	float		m_fLife;
	float		m_fCurrLife;
	
	int			m_iNumTex;
	int			m_iTexIdx;
	
	__Vector3	m_vCreatePoint;	//생성기준위치..
	__Vector3	m_vAxis;		//기준방향..(회전축)
	__Vector3	m_vVelocity;	//진행방향..
	__Vector3	m_vAccel;		//

	float		m_fDropVel;		//
	float		m_fDropY;		//
	float		m_fRot;			//
	__Vector3	m_vLcPos;		//로컬...
	__Vector3	m_vWdPos;		//	
	uint32_t		m_dwColor;		//
	float		m_fSize;		//원래크기
	//float		m_fCurrSize;	//현재

public:
	bool Tick();
	
//생성자 소멸자..
	CN3FXParticle();	
	virtual ~CN3FXParticle();
};

#endif // #ifndef __N3FXPARTICLE_H__
// ===== END N3Base/N3FXParticle.h =====

// ===== BEGIN N3Base/N3FXPlug.cpp =====
#line 1 "N3Base/N3FXPlug.cpp"
﻿// N3FXPlug.cpp: implementation of the CN3FXPlug class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXPlug.h"
#include "N3FXBundle.h"
#include "N3Chr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

////////////////////////////////////////////////////////////////////////////////////
// CN3FXPlugPart
CN3FXPlugPart::CN3FXPlugPart()
	: m_vOffsetPos(0, 0, 0), m_vOffsetDir(0, 0, 1)
{
	m_dwType |= OBJ_FX_PLUG_PART;
	m_pFXB = nullptr;
	m_nRefIndex = -1;
}

CN3FXPlugPart::~CN3FXPlugPart()
{
	delete m_pFXB;
}

void CN3FXPlugPart::Release()
{
	CN3BaseFileAccess::Release();

	delete m_pFXB; m_pFXB = nullptr;
	m_nRefIndex = -1;
	m_vOffsetPos.Set(0,0,0); m_vOffsetDir.Set(0,0,1);
}

bool CN3FXPlugPart::Load(File& file)
{
	if (!CN3BaseFileAccess::Load(file))
		return false;

	__ASSERT(nullptr == m_pFXB, "must null");

	int nStrLen;
	file.Read(&nStrLen, sizeof(nStrLen));
	if (nStrLen > 0)
	{
		char szFN[_MAX_PATH];
		file.Read(szFN, nStrLen);
		szFN[nStrLen] = '\0';

		m_pFXB = new CN3FXBundle();
		if (!m_pFXB->LoadFromFile(szFN))
		{
			delete m_pFXB;
			m_pFXB = nullptr;
		}
		else
		{
			m_pFXB->Init();
			m_pFXB->Trigger();
		}
	}

	file.Read(&m_nRefIndex, sizeof(m_nRefIndex));
	file.Read(&m_vOffsetPos, sizeof(m_vOffsetPos));
	file.Read(&m_vOffsetDir, sizeof(m_vOffsetDir));

	return true;
}

#ifdef _N3TOOL
bool CN3FXPlugPart::Save(File& file)
{
	if (!CN3BaseFileAccess::Save(file))
		return false;

	__ASSERT(m_pFXB, "no FXB");

	int nStrLen = static_cast<int>(m_pFXB->FileName().size());
	file.Write(&nStrLen, sizeof(nStrLen));
	file.Write(m_pFXB->FileName().c_str(), nStrLen);
	file.Write(&m_nRefIndex, sizeof(m_nRefIndex));
	file.Write(&m_vOffsetPos, sizeof(m_vOffsetPos));
	file.Write(&m_vOffsetDir, sizeof(m_vOffsetDir));

	return true;
}
#endif

void CN3FXPlugPart::Tick(const __Matrix44& mtxParent)
{
	if (m_pFXB)
	{
		// 위치
		m_pFXB->m_vPos = m_vOffsetPos*mtxParent;

		// 회전
		static __Matrix44 mtxRot;
		mtxRot = mtxParent; mtxRot.PosSet(0,0,0);
		m_pFXB->m_vDir = m_vOffsetDir*mtxRot;

		m_pFXB->Tick();
	}
}

void CN3FXPlugPart::Tick(const CN3Chr* pChr)
{
	__ASSERT(pChr, "no chr");
	if (m_pFXB)
	{
		// 위치
		const __Matrix44* pMtxJoint = pChr->MatrixGet(m_nRefIndex);
		if (nullptr == pMtxJoint) return;

		static __Matrix44 mtx;
		mtx = *(pMtxJoint);
		mtx *= pChr->m_Matrix;
		m_pFXB->m_vPos = m_vOffsetPos*mtx;
		
		// 회전
		mtx.PosSet(0,0,0);
		m_pFXB->m_vDir = m_vOffsetDir*mtx;

		m_pFXB->Tick();
	}
}

void CN3FXPlugPart::Render()
{
	if (m_pFXB) m_pFXB->Render();
}

void CN3FXPlugPart::SetFXB(const std::string& strFN)
{
	if (nullptr == m_pFXB) m_pFXB = new CN3FXBundle();
	else m_pFXB->Release();
	m_pFXB->LoadFromFile(strFN);

	m_vOffsetPos = m_pFXB->m_vPos;	//일단 FXB에 설정되어 있는 vPos와 vDir값을 가져와서 적용.
	m_vOffsetDir = m_pFXB->m_vDir;

	m_pFXB->Init();					// FX 나오게 하기
	m_pFXB->Trigger();
}

void CN3FXPlugPart::StopFXB(bool bImmediately)
{
	if (m_pFXB) m_pFXB->Stop(bImmediately);
}

void CN3FXPlugPart::TriggerFXB()
{
	if (m_pFXB) m_pFXB->Trigger();
}

////////////////////////////////////////////////////////////////////////////////////
// CN3FXPlug
CN3FXPlug::CN3FXPlug()
{
	m_dwType |= OBJ_FX_PLUG;
}

CN3FXPlug::~CN3FXPlug()
{
	for (CN3FXPlugPart* pPart : m_FXPParts)
		delete pPart;
	m_FXPParts.clear();
}

void CN3FXPlug::Release()
{
	CN3BaseFileAccess::Release();

	for (CN3FXPlugPart* pPart : m_FXPParts)
		delete pPart;
	m_FXPParts.clear();
}

bool CN3FXPlug::Load(File& file)
{
	if (!CN3BaseFileAccess::Load(file))
		return false;

	__ASSERT(0 == m_FXPParts.size(), "must 0");

	int nCount;
	file.Read(&nCount, sizeof(nCount));		// Part의 갯수

	if (nCount > 0)
		m_FXPParts.assign(nCount, nullptr);

	for (int i = 0; i < nCount; ++i)
	{
		m_FXPParts[i] = new CN3FXPlugPart();
		m_FXPParts[i]->Load(file);
	}
	return true;
}

void CN3FXPlug::Tick(const CN3Chr* pChr)
{
	if (pChr == nullptr)
		return;

	for (CN3FXPlugPart* pPart : m_FXPParts)
		pPart->Tick(pChr);
}

void CN3FXPlug::Render()
{
	for (CN3FXPlugPart* pPart : m_FXPParts)
		pPart->Render();
}

void CN3FXPlug::StopAll(bool bImmediately)
{
	for (CN3FXPlugPart* pPart : m_FXPParts)
		pPart->StopFXB(bImmediately);
}

void CN3FXPlug::TriggerAll()
{
	for (CN3FXPlugPart* pPart : m_FXPParts)
		pPart->TriggerFXB();
}

#ifdef _N3TOOL
bool CN3FXPlug::Save(File& file)
{
	if (!CN3BaseFileAccess::Save(file))
		return false;

	RemoveFXPParts_HaveNoBundle();	// 번들 없는 파트들 지우기

	int nCount = static_cast<int>(m_FXPParts.size());
	file.Write(&nCount, sizeof(nCount));		// Part의 갯수

	for (CN3FXPlugPart* pPart : m_FXPParts)
		pPart->Save(file);

	return true;
}

void CN3FXPlug::RemoveFXPParts_HaveNoBundle()	// 번들 없는 Part들 제거하기
{
	for (auto itr = m_FXPParts.begin(); itr != m_FXPParts.end();)
	{
		CN3FXPlugPart* pPart = *itr;
		if (pPart == nullptr)
		{
			itr = m_FXPParts.erase(itr);
		}
		else if (pPart->GetFXB() == nullptr)
		{
			delete pPart;								// FXB가 없으면 이 파트는 지운다.
			itr = m_FXPParts.erase(itr);
		}
		else
		{
			++itr;
		}
	}
}

CN3FXPlugPart* CN3FXPlug::FXPPartAdd()
{
	CN3FXPlugPart* pPart = new CN3FXPlugPart();
	m_FXPParts.push_back(pPart);
	return pPart;
}

void CN3FXPlug::FXPPartDelete(int nIndex)
{
	if (nIndex < 0
		|| nIndex >= static_cast<int>(m_FXPParts.size()))
		return;

	std::vector<CN3FXPlugPart*>::iterator itor = m_FXPParts.begin();
	for (int i=0; i<nIndex; ++i) ++itor;
	delete (*itor);
	m_FXPParts.erase(itor);
}

#endif


// ===== END N3Base/N3FXPlug.cpp =====

// ===== BEGIN N3Base/N3FXPlug.h =====
#line 1 "N3Base/N3FXPlug.h"
﻿// N3FXPlug.h: interface for the CN3FXPlug class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3FXPLUG_H__32183758_2BF2_456F_B6AA_CBE9C248CDDE__INCLUDED_)
#define AFX_N3FXPLUG_H__32183758_2BF2_456F_B6AA_CBE9C248CDDE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////////////////////
// CN3FXPlugPart
#include "N3BaseFileAccess.h"

#include <vector>

class CN3FXPlugPart : public CN3BaseFileAccess  
{
#ifdef _N3TOOL
	friend class CFormViewProperty;
	friend class CN3CEView;
#endif

public:
	CN3FXPlugPart();
	~CN3FXPlugPart() override;

// Attributes
public:
protected:
	class CN3FXBundle*	m_pFXB;
	int					m_nRefIndex;	// referance index (캐릭터 : joint index)

	__Vector3			m_vOffsetPos;	// Joint와 떨어진 정도
	__Vector3			m_vOffsetDir;	// Joint와 떨어진 방향

// Operations
public:
	void				Tick(const __Matrix44& mtxParent);
	void				Tick(const class CN3Chr* pChr);
	void				Render();
	void				Release() override;
	bool				Load(File& file) override;

	const CN3FXBundle*	GetFXB() const {return m_pFXB;}
	void				SetFXB(const std::string& strFN);
	int					GetRefIndex() const {return m_nRefIndex;}
	void				SetRefIdx(int nRefIndex) {m_nRefIndex = nRefIndex;}
	void				StopFXB(bool bImmediately);
	void				TriggerFXB();
#ifdef _N3TOOL
	bool				Save(File& file) override;
#endif
protected:
};

////////////////////////////////////////////////////////////////////////////////////
// CN3FXPlug
class CN3FXPlug : public CN3BaseFileAccess  
{
#ifdef _N3TOOL
	friend class CFormViewProperty;
#endif

public:
	CN3FXPlug();
	~CN3FXPlug() override;

// Attributes
public:
protected:
	std::vector<class CN3FXPlugPart*> m_FXPParts;

// Operations
public:
	void			Tick(const CN3Chr* pChr);
	void			Render();
	void			Release() override;
	bool			Load(File& file) override;

	void			StopAll(bool bImmediately = false);	// FX Stop
	void			TriggerAll();						// FX 시작

#ifdef _N3TOOL
	bool			Save(File& file) override;
	void			RemoveFXPParts_HaveNoBundle();		// 번들 없는 Part들 제거하기

	CN3FXPlugPart*	FXPPartAdd();
	void			FXPPartDelete(int nIndex);
#endif
protected:
};

#endif // !defined(AFX_N3FXPLUG_H__32183758_2BF2_456F_B6AA_CBE9C248CDDE__INCLUDED_)

// ===== END N3Base/N3FXPlug.h =====

// ===== BEGIN N3Base/N3FXShape.cpp =====
#line 1 "N3Base/N3FXShape.cpp"
﻿// N3FXShape.cpp: implementation of the CN3FXShape class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3FXShape.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
//	CN3FXSPart class.....
//////////////////////////////////////////////////////////////////////

CN3FXSPart::CN3FXSPart()
{
	m_vPivot.Set(0,0,0);
	m_WorldMtx.Identity();

	m_bOutOfCameraRange = TRUE;

	m_fTexFPS = 10.0f;
	m_fTexIndex = 0;
	m_TexRefs.clear();

	m_bTexLoop = true;
	
	m_Mtl.Init();

//	m_pPM = nullptr;

	m_pRefShape = nullptr;
}

CN3FXSPart::~CN3FXSPart()
{
	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);

//	if(m_pPM) { m_pPM->Release(); delete m_pPM; m_pPM = nullptr; }
}

void CN3FXSPart::Release()
{
	m_vPivot.Set(0,0,0); // Local 축
	m_WorldMtx.Identity(); // World Matrix.. Shape Loading 때 미리 계산해야 좋다..		
	m_bOutOfCameraRange = TRUE; // Camera 범위 바깥에 있음...

	m_fTexFPS = 10.0f; // Texture Animation Interval;
	m_fTexIndex = 0; // Current Texture Index.. Animation 시킬때 필요한 인덱스이다..

	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);
	m_TexRefs.clear();

//	if(m_pPM) { m_pPM->Release(); delete m_pPM; m_pPM = nullptr; }
	m_FXPMInst.Release();

}

////////////////////////////////// tex ///////////////////////////////////////////

void CN3FXSPart::TexAlloc(int nCount)
{
	if (nCount <= 0)
		return;

	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);
	m_TexRefs.clear();

	m_TexRefs.assign(nCount, nullptr);
}

CN3Texture* CN3FXSPart::Tex(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_TexRefs.size()))
		return nullptr;

	return m_TexRefs[iIndex];
}

CN3Texture* CN3FXSPart::TexSet(int iIndex, const std::string& szFN)
{
	if (iIndex >= static_cast<int>(m_TexRefs.size()))
		return nullptr;

	s_MngTex.Delete(&m_TexRefs[iIndex]);
	m_TexRefs[iIndex] = s_MngTex.Get(szFN);
	return m_TexRefs[iIndex];
}

void CN3FXSPart::TexSet(int iIndex, CN3Texture* pTex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_TexRefs.size()))
		return;

	s_MngTex.Delete(&m_TexRefs[iIndex]);
}

// timeGetTime 으로 얻은 값을 넣으면 Texture Animation 을 컨트롤 한다..
void CN3FXSPart::Tick(const __Matrix44& mtxParent) 
{
	CN3FXPMesh* pFXPMesh = m_FXPMInst.GetMesh();
	if(nullptr == pFXPMesh) return;

	m_bOutOfCameraRange = FALSE;

	m_WorldMtx.Identity();
	m_WorldMtx.PosSet(m_vPivot);
	m_WorldMtx *= mtxParent;

	////////////////////////////////////////////////////////////////////////////
	// 카메라와 멀리 떨어지면 지나간다..
	float fDist = (m_WorldMtx.Pos() - s_CameraData.vEye).Magnitude();
	float fRadius = Radius();
	if(s_CameraData.IsOutOfFrustum(this->m_WorldMtx.Pos(), fRadius * 3.0f)) // 카메라 사면체 바깥이면 지나간다..
	{
		m_bOutOfCameraRange = TRUE;
		return;
	}
	//
	//////////////////////////////////////////////////////////////////////////////////

	// 카메라 거리에 따라 LOD 수준을 조절한다.
	float fLOD = fDist * s_CameraData.fFOV;
	m_FXPMInst.SetLOD(fLOD);

	if (m_TexRefs.size() > 1)
		m_fTexIndex += CN3Base::s_fSecPerFrm * m_fTexFPS;
}

void CN3FXSPart::Render()
{
	if(m_bOutOfCameraRange) return;
	if(m_bOutOfCameraRange || m_FXPMInst.GetNumVertices() <= 0) return;
	
#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Part++; // Rendering Information Update...
#endif
	
	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	int iTC = static_cast<int>(m_TexRefs.size());
	if (iTC > 0)
	{
		int iTexIndex = (int) m_fTexIndex;
		if (m_bTexLoop)
			iTexIndex = (int) m_fTexIndex % iTC;

		if (iTexIndex >= 0 && iTexIndex < iTC && m_TexRefs[iTexIndex] != nullptr)
			lpTex = m_TexRefs[iTexIndex]->Get();
		else
			return;
	}

	if(m_Mtl.nRenderFlags & RF_ALPHABLENDING) // Alpha 사용
	{
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_Mtl.dwDestBlend;
			pAP->dwBlendSrc			= m_Mtl.dwSrcBlend;
			pAP->dwFVF				= FVF_XYZCOLORT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexXyzColorT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - (this->Min() + (this->Max()-this->Min())*0.5f)).Magnitude();
			pAP->lpTex				= lpTex;
			pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_FXPMInst.GetNumIndices() / 3;
			//pAP->nRenderFlags		= RF_ALPHABLENDING | RF_NOTUSEFOG | RF_DIFFUSEALPHA | RF_NOTUSELIGHT | RF_DOUBLESIDED;
			pAP->nRenderFlags		= m_Mtl.nRenderFlags;
			pAP->nVertexCount		= m_FXPMInst.GetNumVertices();
			pAP->MtxWorld			= m_WorldMtx;
			pAP->pVertices			= m_FXPMInst.GetVertices();
			pAP->pwIndices			= m_FXPMInst.GetIndices();
		}
		return; // 렌더링 안하지롱.
	}

	s_lpD3DDev->SetMaterial(&m_Mtl); // 재질 설정..
	s_lpD3DDev->SetTexture(0, lpTex);
	if(nullptr != lpTex)
	{
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );		
		s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );		
	}
	else
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	}

	__Matrix44 mtx;
	s_lpD3DDev->GetTransform(D3DTS_WORLD, mtx.toD3D());
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_WorldMtx.toD3D());

	DWORD dwCullMode, dwZWriteEnable, dwZBufferEnable, dwLight;
	s_lpD3DDev->GetRenderState( D3DRS_ZWRITEENABLE, &dwZWriteEnable );
	s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZBufferEnable );
	s_lpD3DDev->GetRenderState( D3DRS_CULLMODE, &dwCullMode );
	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLight );

	if(m_pRefShape->m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, m_pRefShape->m_dwZEnable);
	if(m_pRefShape->m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, m_pRefShape->m_dwZWrite);
	if(m_pRefShape->m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, m_pRefShape->m_dwLight);
	if(m_pRefShape->m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, m_pRefShape->m_dwDoubleSide);
	
	m_FXPMInst.Render();

	if(m_pRefShape->m_dwZEnable != dwZBufferEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZBufferEnable);
	if(m_pRefShape->m_dwZWrite != dwZWriteEnable) s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);
	if(m_pRefShape->m_dwLight != dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
	if(m_pRefShape->m_dwDoubleSide != dwCullMode) s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCullMode);

	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());
}

bool CN3FXSPart::Load(File& file)
{
	int nL = 0;
	char szFN[256];

	file.Read(&m_vPivot, sizeof(__Vector3));

	file.Read(&nL, 4); // Mesh FileName
	file.Read(szFN, nL); szFN[nL] = '\0'; // 메시 파일 이름..

	//m_pRefShape의 경로와 읽어들인 파일명을 합쳐라...
	char szPath[_MAX_PATH];
	char szFName[_MAX_FNAME], szExt[_MAX_EXT];
	char szDir[_MAX_DIR];
	_splitpath(m_pRefShape->FileName().c_str(), nullptr, szDir, nullptr, nullptr);
	_splitpath(szFN, nullptr, nullptr, szFName, szExt);
	_makepath(szPath, nullptr, szDir, szFName, szExt);

	if(!this->MeshSet(szPath)) return false;

	file.Read(&m_Mtl, sizeof(__Material)); // 재질

	int iTC = 0;
	file.Read(&iTC, 4);
	file.Read(&m_fTexFPS, 4);
	m_TexRefs.clear();
	this->TexAlloc(iTC); // Texture Pointer Pointer 할당..
	for(int j = 0; j < iTC; j++) // Texture Count 만큼 파일 이름 읽어서 텍스처 부르기..
	{
		file.Read(&nL, 4);
		if(nL > 0)
		{
			file.Read(szFN, nL); szFN[nL] = '\0'; // 텍스처 파일 이름..
			
			_splitpath(szFN, nullptr, nullptr, szFName, szExt);
			_makepath(szPath, nullptr, szDir, szFName, szExt);
			m_TexRefs[j] = s_MngTex.Get(szPath);
		}
	}

	return true;
}

void CN3FXSPart::Duplicate(CN3FXSPart* pSrc)
{
	m_vPivot = pSrc->m_vPivot;
	if(pSrc->Mesh()) MeshSet(pSrc->Mesh()->FileName());
	
	m_Mtl = pSrc->m_Mtl;
	
	int iTC = 0;
	iTC = pSrc->TexCount();
	m_fTexFPS = m_fTexFPS;

	m_TexRefs.clear();	
	this->TexAlloc(iTC); // Texture Pointer Pointer 할당..
	for(int j = 0; j < iTC; j++) // Texture Count 만큼 파일 이름 읽어서 텍스처 부르기..
	{
		if(pSrc->Tex(j))
			m_TexRefs[j] = s_MngTex.Get(pSrc->Tex(j)->FileName());
	}
	return;
}

bool CN3FXSPart::Save(File& file)
{	
	return true;
}

bool CN3FXSPart::MeshSet(const std::string& szFN)
{
	m_FXPMInst.Create(szFN);
	return true;
}

//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//

///////////////////////////////////
// CN3Shape
CN3FXShape::CN3FXShape()
{
	m_dwType |= OBJ_SHAPE;
	m_mtxParent.Identity();
	m_mtxFinalTransform.Identity();

	m_dwSrcBlend = D3DBLEND_ONE;
	m_dwDestBlend = D3DBLEND_ONE;
	m_bAlpha = TRUE;

	m_dwZEnable = D3DZB_TRUE;
	m_dwZWrite = TRUE;
	m_dwLight = FALSE;
	m_dwDoubleSide = D3DCULL_NONE;
}

CN3FXShape::~CN3FXShape()
{
	for (CN3FXSPart* pPart : m_Parts)
	{
		pPart->Release();
		delete pPart;
	}
	m_Parts.clear();
}

void CN3FXShape::Release()
{
	for (CN3FXSPart* pPart : m_Parts)
	{
		pPart->Release();
		delete pPart;
	}
	m_Parts.clear();
	
	CN3TransformCollision::Release();
}

void CN3FXShape::Tick(float fFrm)
{
	CN3TransformCollision::Tick(m_fFrmCur);
	m_mtxFinalTransform = CN3Transform::m_Matrix * m_mtxParent;

	for (CN3FXSPart* pPart : m_Parts)
		pPart->Tick(m_mtxFinalTransform);
}

// 카메라 위치, 카메라 평면(관찰 절두체 평면) -> 12개의 벡터 배열로 되어 있다.
// [0][1]:카메라 위치와 벡터, [2][3]:카메라 범위 위치와 방향 벡터, [4][5] ~ [10][11]:상하좌우평면벡터
void CN3FXShape::Render()
{
	for (CN3FXSPart* pPart : m_Parts)
		pPart->Render();
}

bool CN3FXShape::Load(File& file)
{
	CN3TransformCollision::Load(file); // 기본정보 읽기...

	for (CN3FXSPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();

	int iPC = 0;
	file.Read(&iPC, 4); // Part Count
	if (iPC > 0)
	{
		m_Parts.assign(iPC, nullptr);
		for (int i = 0; i < iPC; i++)
		{
			m_Parts[i] = new CN3FXSPart();
			m_Parts[i]->m_pRefShape = this;
			if (!m_Parts[i]->Load(file))
				return false;

			//m_Parts[i]->ReCalcMatrix(m_Matrix); // Part Matrix 계산
		}
	}

	uint32_t dwTmp;		
	file.Read(&dwTmp, 4); // 소속
	file.Read(&dwTmp, 4); // 속성 0
	file.Read(&dwTmp, 4); // 속성 1
	file.Read(&dwTmp, 4); // 속성 2
	file.Read(&dwTmp, 4); // 속성 3

	this->FindMinMax();

	return true;
}

bool CN3FXShape::Save(File& file)
{
	/*
	CN3TransformCollision::Save(file); // 기본정보 읽기...
	
	int nL = 0;
	
	CN3SPart* pPD = nullptr;
	int iPC = m_Parts.size();
	file.Write(&iPC, 4); // Mesh FileName
	for(int i = 0; i < iPC; i++)
	{
		m_Parts[i]->Save(file);
	}

	file.Write(&m_iBelong, 4); // 소속
	file.Write(&m_iAttr0, 4); // 속성 0
	file.Write(&m_iAttr1, 4); // 속성 1
	file.Write(&m_iAttr2, 4); // 속성 2
	file.Write(&m_iAttr3, 4); // 속성 3
	*/
	return true;
}

void CN3FXShape::PartDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Parts.size()))
		return;

	auto it = m_Parts.begin();
	std::advance(it, iIndex);

	delete *it;
	m_Parts.erase(it);
}

__Vector3 CN3FXShape::CenterPos()
{
	FindMinMax();
	return (m_vMin + (m_vMax - m_vMin) * 0.5f);
}

void CN3FXShape::FindMinMax()
{
	__Vector3 vMin(FLT_MAX, FLT_MAX, FLT_MAX);
	__Vector3 vMax(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	__Vector3 vMinTmp(0,0,0);
	__Vector3 vMaxTmp(0,0,0);

	// 가장 큰 지점찾기..
	__Matrix44 mtxWI = m_mtxFinalTransform.Inverse(); // World Matrix Inverse
	for (CN3FXSPart* pPart : m_Parts)
	{
		//pPart->ReCalcMatrix(m_mtxFinalTransform);
		vMinTmp = pPart->Min() * mtxWI; // 월드 상의 최소값을 로컬 좌표로 바꾸어준다..
		vMaxTmp = pPart->Max() * mtxWI; // 월드 상의 최대값을 로컬 좌표로 바꾸어준다..

		if (vMinTmp.x < vMin.x) vMin.x = vMinTmp.x;
		if (vMinTmp.y < vMin.y) vMin.y = vMinTmp.y;
		if (vMinTmp.z < vMin.z) vMin.z = vMinTmp.z;
		if (vMaxTmp.x > vMax.x) vMax.x = vMaxTmp.x;
		if (vMaxTmp.y > vMax.y) vMax.y = vMaxTmp.y;
		if (vMaxTmp.z > vMax.z) vMax.z = vMaxTmp.z;
	}

	// 최대 최소값을 저장
	m_vMin = vMin * m_mtxFinalTransform;
	m_vMax = vMax * m_mtxFinalTransform;

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

void CN3FXShape::Duplicate(CN3FXShape* pSrc)
{
	if(!pSrc) return;

	m_dwSrcBlend = pSrc->m_dwSrcBlend;
	m_dwDestBlend = pSrc->m_dwDestBlend;
	m_bAlpha = pSrc->m_bAlpha;

	m_dwZEnable = pSrc->m_dwZEnable;
	m_dwZWrite = pSrc->m_dwZWrite;
	m_dwLight = pSrc->m_dwLight;
	m_dwDoubleSide = pSrc->m_dwDoubleSide;
		
	//CN3TransformCollision::Load(file); // 기본정보 읽기...
	//transform collision...
	SetRadius(pSrc->Radius());
	SetMin(pSrc->Min());
	SetMax(pSrc->Max());

	if(pSrc->CollisionMesh()) SetMeshCollision(pSrc->CollisionMesh()->FileName());
	if(pSrc->ClimbMesh()) SetMeshClimb(pSrc->ClimbMesh()->FileName());

	//transform....
	ScaleSet(pSrc->Scale());
	PosSet(pSrc->m_vPos);
	RotSet(pSrc->Rot());

	//basefileaccess		
	FileNameSet(pSrc->FileName());

	m_Matrix = pSrc->m_Matrix;
	//
	//
	m_KeyPos.Duplicate(&(pSrc->m_KeyPos));
	m_KeyRot.Duplicate(&(pSrc->m_KeyRot));
	m_KeyScale.Duplicate(&(pSrc->m_KeyScale));

	m_fFrmWhole = pSrc->m_fFrmWhole;
	m_fFrmCur = 0.0f;

	for (CN3FXSPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();

	size_t partCount = pSrc->m_Parts.size();
	if (partCount > 0)
	{
		m_Parts.assign(partCount, nullptr);
		for (size_t i = 0; i < partCount; i++)
		{
			m_Parts[i] = new CN3FXSPart();
			m_Parts[i]->m_pRefShape = this;
			m_Parts[i]->Duplicate(pSrc->m_Parts[i]);
			//m_Parts[i]->ReCalcMatrix(m_Matrix); // Part Matrix 계산
		}
	}

	return;
}

void CN3FXShape::SetCurrFrm(float fFrm)
{
	if(FRAME_SELFPLAY == fFrm)
	{
		m_fFrmCur += s_fSecPerFrm;
		if(m_fFrmCur < 0) m_fFrmCur = 0.0f;
		if(m_fFrmCur >= m_fFrmWhole) m_fFrmCur = 0.0f;		
	}
	else m_fFrmCur = fFrm;
}

float CN3FXShape::GetCurrFrm()
{
	return m_fFrmCur;
}

void CN3FXShape::SetPartsMtl(BOOL bAlpha, uint32_t dwSrcBlend, uint32_t dwDestBlend, uint32_t dwZEnable, uint32_t dwZWrite, uint32_t dwLight, uint32_t dwDoubleSide)
{
	m_dwSrcBlend = dwSrcBlend;
	m_dwDestBlend = dwDestBlend;
	m_bAlpha = bAlpha;

	m_dwZEnable = dwZEnable;
	m_dwZWrite = dwZWrite;
	m_dwLight = dwLight;
	m_dwDoubleSide = dwDoubleSide;

	uint32_t dwRenderFlag = RF_ALPHABLENDING | RF_NOTUSEFOG | RF_DIFFUSEALPHA | RF_NOTUSELIGHT | RF_DOUBLESIDED | RF_NOTZWRITE | RF_NOTZBUFFER;

	if (m_dwZEnable == D3DZB_TRUE)
		dwRenderFlag ^= RF_NOTZBUFFER;

	if (m_dwZWrite == TRUE)
		dwRenderFlag ^= RF_NOTZWRITE;

	if (m_dwDoubleSide != D3DCULL_NONE)
		dwRenderFlag ^= RF_DOUBLESIDED;

	if (m_dwLight == TRUE)
		dwRenderFlag ^= RF_NOTUSELIGHT;

	if (m_bAlpha != TRUE)
		dwRenderFlag ^= RF_ALPHABLENDING;

	for (CN3FXSPart* pPart : m_Parts)
		pPart->m_Mtl.nRenderFlags = dwRenderFlag;
}

void CN3FXShape::SetMaxLOD()
{
	for (CN3FXSPart* pPart : m_Parts)
	{
		pPart->m_bOutOfCameraRange = FALSE;
		pPart->m_FXPMInst.SetLOD(0);
	}
}

// ===== END N3Base/N3FXShape.cpp =====

// ===== BEGIN N3Base/N3FXShape.h =====
#line 1 "N3Base/N3FXShape.h"
﻿// N3FXShape.h: interface for the CN3FXShape class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXSHAPE_H__
#define __N3FXSHAPE_H__

#pragma warning(disable : 4786)

#include "N3TransformCollision.h"
#include "N3Texture.h"
#include "N3FXPMesh.h"
#include "N3FXPMeshInstance.h"

#include <vector>

class CN3FXSPart : public CN3BaseFileAccess
{
	friend class CN3FXShape;

public:
	__Material	m_Mtl;					// Material
	__Vector3	m_vPivot;				// Local 축
	__Matrix44	m_WorldMtx;				// World Matrix.. Shape Loading 때 미리 계산해야 좋다..		
	BOOL		m_bOutOfCameraRange;	// Camera 범위 바깥에 있음...

	float		m_fTexFPS;				// Texture Animation Interval;
	bool		m_bTexLoop;

	CN3FXShape*	m_pRefShape;

protected:
	std::vector<CN3Texture*>	m_TexRefs;		// Texture Reference Pointers
	CN3FXPMeshInstance			m_FXPMInst;		// Progressive Mesh Instance

	float						m_fTexIndex;	// Current Texture Index.. Animation 시킬때 필요한 인덱스이다.. float 로 해서 텍스처 에니메이션 제어한다.

public:
	bool Load(File& file) override;
	bool Save(File& file) override;
	void Duplicate(CN3FXSPart* pSrc);
		
	int TexCount() const
	{
		return static_cast<int>(m_TexRefs.size());
	}

	CN3Texture* Tex(int iIndex);
	void		TexAlloc(int nCount);
	CN3Texture* TexSet(int iIndex, const std::string& szFN);
	void		TexSet(int iIndex, CN3Texture* pTex);

	__Vector3 Min() { if(m_FXPMInst.GetMesh()) return m_FXPMInst.GetMesh()->Min() * m_WorldMtx; else return __Vector3(0,0,0); } // 월드 상의 최소값
	__Vector3 Max() { if(m_FXPMInst.GetMesh()) return m_FXPMInst.GetMesh()->Max() * m_WorldMtx; else return __Vector3(0,0,0); } // 월드 상의 최대값
	float	Radius() { if(m_FXPMInst.GetMesh()) return m_FXPMInst.GetMesh()->Radius(); else return 0.0f; }


	CN3FXPMesh*	Mesh() { return m_FXPMInst.GetMesh(); }
	__VertexXyzColorT1* GetColorVertices() { return m_FXPMInst.GetVertices(); }
	void	SetColor(uint32_t dwColor = 0xffffffff) { m_FXPMInst.SetColor(dwColor); }
	bool	MeshSet(const std::string& szFN);
	void	Tick(const __Matrix44& mtxParent);
	void	Render();
	void	Release() override;
	
	CN3FXSPart();
	~CN3FXSPart() override;
};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	CN3FXShape
//
class CN3FXShape : public CN3TransformCollision
{
public:
	std::vector<CN3FXSPart*>	m_Parts; // Part Data Pointer Linked List

	__Matrix44		m_mtxParent;
	__Matrix44		m_mtxFinalTransform;

	uint32_t		m_dwSrcBlend;
	uint32_t		m_dwDestBlend;
	BOOL			m_bAlpha;

	uint32_t		m_dwZEnable;
	uint32_t		m_dwZWrite;
	uint32_t		m_dwLight;
	uint32_t		m_dwDoubleSide;
	
public:
	void			SetPartsMtl(BOOL bAlpha, uint32_t dwSrcBlend, uint32_t dwDestBlend, uint32_t dwZEnable, uint32_t dwZWrite, uint32_t dwLight, uint32_t dwDoubleSide);
	__Vector3		CenterPos();

	void			SetCurrFrm(float fFrm);
	float			GetCurrFrm();
	float			GetWholeFrm() { return m_fFrmWhole; }

	void			FindMinMax() override;

	int PartCount() const
	{
		return static_cast<int>(m_Parts.size());
	}

	CN3FXSPart* Part(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Parts.size()))
			return nullptr;

		return m_Parts[iIndex];
	}

	CN3FXSPart* PartAdd()
	{
		CN3FXSPart* pPart = new CN3FXSPart();
		m_Parts.push_back(pPart);
		return pPart;
	}

	void	PartDelete(int iIndex);
	
	bool	Load(File& file) override;
	bool	Save(File& file) override;
	void	Duplicate(CN3FXShape* pSrc);

	void	Tick(float fFrm = FRAME_SELFPLAY) override;
	void	Render();
	void	Release() override;

public:
	void SetMaxLOD();
	CN3FXShape();
	~CN3FXShape() override;
};

#endif // !defined(AFX_N3Shape_h__INCLUDED_)

// ===== END N3Base/N3FXShape.h =====

// ===== BEGIN N3Base/N3GERain.cpp =====
#line 1 "N3Base/N3GERain.cpp"
﻿// N3GERain.cpp: implementation of the CN3GERain class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3GERain.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3GERain::CN3GERain()
{
	m_dwEffectType = GETYPE_RAIN;
	CN3GERain::Release();
}

CN3GERain::~CN3GERain()
{
	CN3GERain::Release();
}

void CN3GERain::Release()
{
	m_fWidth = m_fHeight = m_fRainLength = 0.0f;
	m_vVelocity.Set(0,0,0);
	CN3GlobalEffect::Release();
}

void CN3GERain::Tick()
{
	if (m_bActive == FALSE || m_iVC <= 0 || m_pVB == nullptr) return;

	CN3GlobalEffect::Tick();

	int iCount = m_iVC/2;
	int iActiveCount = iCount;
	if(m_iFadeMode > 0) // 차차 많아지게 한다..
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * m_fFadeTimeCur / m_fFadeTime);
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	else if(m_iFadeMode < 0)
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * (1.0f - m_fFadeTimeCur / m_fFadeTime));
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	if(iActiveCount <= 0) return;

	int i;

	__VertexXyzColor* pVertices;
	HRESULT hr = m_pVB->Lock(0, 0, (void**)&pVertices, D3DLOCK_NOSYSLOCK);
	if (FAILED(hr))
		return;

	__Vector3 vN = m_vVelocity;	vN.Normalize();
	__Vector3 vAdd = m_vVelocity*s_fSecPerFrm;
	__Vector3 vAddLength = vN*m_fRainLength;

	const float fHalfWidth = m_fWidth/2.0f;
	const float fHalfHeight = m_fHeight/2.0f;
	const float fCurY = s_CameraData.vEye.y;

	for (i=0; i<iActiveCount; ++i)
	{
		// tail 위치 결정하기
		__VertexXyzColor* pVTail = pVertices+i*2+0;
		__VertexXyzColor* pVHead = pVertices+i*2+1;
		pVTail->x += vAdd.x;	pVTail->y += vAdd.y;	pVTail->z += vAdd.z;

		float fDiff = pVTail->y - (fCurY-fHalfHeight);
		if (fDiff < 0)	// 높이 범위를 벗어났을 경우
		{
			pVTail->y -= (((int)(fDiff/m_fHeight)-1)*m_fHeight);
			pVTail->x = m_fWidth*(rand()%10000-5000)/10000.f;
			pVTail->z = m_fWidth*(rand()%10000-5000)/10000.f;
		}
		else
		{
			fDiff = pVTail->y - (fCurY+fHalfHeight);
			if (fDiff > 0)	// 높이 범위를 반대로 벗어났을경우
				pVTail->y -= ((int)(fDiff/m_fHeight)+1)*m_fHeight;
			// x 너비 범위를 벗어났을 경우
			fDiff = pVTail->x - fHalfWidth;
			if (fDiff > 0) pVTail->x -= ((int)(fDiff/m_fWidth)+1)*m_fWidth;
			fDiff = pVTail->x + fHalfWidth;
			if (fDiff < 0) pVTail->x -= ((int)(fDiff/m_fWidth)-1)*m_fWidth;
			// z 너비 범위를 벗어났을 경우
			fDiff = pVTail->z - fHalfWidth;
			if (fDiff >  0) pVTail->z -= ((int)(fDiff/m_fWidth)+1)*m_fWidth;
			fDiff = pVTail->z + fHalfWidth;
			if (fDiff < 0) pVTail->z -= ((int)(fDiff/m_fWidth)-1)*m_fWidth;
		}
		// Head의 위치를 Tail의 위치로부터 일정 거리에 떨어진 곳에 위치시킨다.
		pVHead->x = pVTail->x + vAddLength.x;
		pVHead->y = pVTail->y + vAddLength.y;
		pVHead->z = pVTail->z + vAddLength.z;
	}
	m_pVB->Unlock();
}

void CN3GERain::Render(__Vector3& vPos)
{
	if (m_bActive == FALSE || m_iVC <= 0 || m_pVB == nullptr) return;
	
	CN3GlobalEffect::Render(vPos);
	
	int iCount = m_iVC / 2;
	
	int iActiveCount = iCount;
	if(m_iFadeMode > 0) // 차차 많아지게 한다..
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * m_fFadeTimeCur / m_fFadeTime);
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	else if(m_iFadeMode < 0)
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * (1.0f - m_fFadeTimeCur / m_fFadeTime));
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	if(iActiveCount <= 0) return;

	// 이전 render state 저장
	DWORD dwColorVertex, dwLighting, dwAlphaBlend, dwSrcAlpha, dwDestAlpha;
	s_lpD3DDev->GetRenderState( D3DRS_COLORVERTEX , &dwColorVertex );
	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLighting );
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaBlend );
	s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwSrcAlpha );
	s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwDestAlpha );

	// set render state
	s_lpD3DDev->SetRenderState( D3DRS_COLORVERTEX , TRUE );
	s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE );
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA);

	// set transform
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	// set texture 
	s_lpD3DDev->SetTexture(0, nullptr);

	// render
	s_lpD3DDev->SetFVF(FVF_XYZCOLOR);
	s_lpD3DDev->SetStreamSource(0, m_pVB, 0, sizeof(__VertexXyzColor)); // 버텍스 버퍼 지정
	s_lpD3DDev->DrawPrimitive(D3DPT_LINELIST, 0, iActiveCount);

	// restore
	s_lpD3DDev->SetRenderState( D3DRS_COLORVERTEX , dwColorVertex );
	s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLighting );
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   dwSrcAlpha);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  dwDestAlpha);
}

void CN3GERain::Create(float fDensity, 
					   float fWidth,
					   float fHeight, 
					   float fRainLength, 
					   const __Vector3& vVelocity,
					   float fTimeToFade)
// fDensity : 1 (세제곱미터) 당 빗방울의 갯수
// fWidth : 비오는 범위 X,Z 길이
// fHeight : 비오는 범위의 높이
// fRainLength : 빗줄기의 길이
// vVelocity : 빗줄기의 속도
{
	if(nullptr == s_lpD3DDev) return;

	Release();

	CN3GlobalEffect::FadeSet(fTimeToFade, true);

	m_fFadeTime = fTimeToFade;
	m_fFadeTimeCur = 0;

	float fVolume = fWidth*fWidth*fHeight;
	__ASSERT(fVolume > 0, "Rain volume is less than 0");
	if(fVolume <= 0) return;

	m_fWidth = fWidth;	m_fHeight = fHeight;	m_fRainLength = fRainLength;
	m_vVelocity = vVelocity;
	int iRainCount = (int)(fVolume*fDensity);

	// m_pVB, m_pIB 만들기
	m_iVC = iRainCount*2;
	HRESULT hr = s_lpD3DDev->CreateVertexBuffer(m_iVC*sizeof(__VertexXyzColor), 0, FVF_XYZCOLOR, D3DPOOL_MANAGED, &m_pVB, nullptr);

	if (FAILED(hr)) return;
	__VertexXyzColor* pVertices;
	hr = m_pVB->Lock(0, iRainCount*2*sizeof(__VertexXyzColor), (void**)&pVertices, D3DLOCK_NOSYSLOCK);
	if (FAILED(hr)) return;

	const uint32_t dwColorA = 0x00bfbfbf,	// 꼬리
				dwColorB = 0x80bfbfbf;	// 머리
	int i;
	__Vector3 vN = vVelocity; vN.Normalize();
	__Vector3 vAdd = vN*fRainLength;
	for (i=0; i<iRainCount; ++i)
	{
		pVertices[i*2+0].Set(	fWidth*(rand()%10000-5000)/10000.f,
								fHeight*(rand()%10000-5000)/10000.f,
								fWidth*(rand()%10000-5000)/10000.f,
								dwColorA);
		pVertices[i*2+1].Set(	pVertices[i*2+0].x + vAdd.x, pVertices[i*2+0].y + vAdd.y, pVertices[i*2+0].z + vAdd.z,
								dwColorB);
	}
	m_pVB->Unlock();
}


// ===== END N3Base/N3GERain.cpp =====

// ===== BEGIN N3Base/N3GERain.h =====
#line 1 "N3Base/N3GERain.h"
﻿// N3GERain.h: interface for the CN3GERain class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3GERAIN_H__FCA2D0E1_3364_4A9D_870E_5B3FC13CD6DD__INCLUDED_)
#define AFX_N3GERAIN_H__FCA2D0E1_3364_4A9D_870E_5B3FC13CD6DD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3GlobalEffect.h"

class CN3GERain : public CN3GlobalEffect  
{
public:
	CN3GERain();
	virtual ~CN3GERain();

// Attributes
public:
	void SetRainLength(float fLen) {m_fRainLength = fLen;}
	void SetVelocity(__Vector3& v) {m_vVelocity = v;}
protected:
	float		m_fWidth;
	float		m_fHeight;
	float		m_fRainLength;
	__Vector3	m_vVelocity;

// Operations
public:
	void Release();
	void Tick();
	void Render(__Vector3& vPos);

	void Create(float fDensity, float fWidth, float fHeight, float fRainLength, const __Vector3& vVelocity, float fTimeToFade = 3.0f);
protected:

};

#endif // !defined(AFX_N3GERAIN_H__FCA2D0E1_3364_4A9D_870E_5B3FC13CD6DD__INCLUDED_)

// ===== END N3Base/N3GERain.h =====

// ===== BEGIN N3Base/N3GESnow.cpp =====
#line 1 "N3Base/N3GESnow.cpp"
﻿// N3GESnow.cpp: implementation of the CN3GESnow class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3GESnow.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3GESnow::CN3GESnow()
{
	m_pTex = nullptr;
	m_pSnowParticle = nullptr;
	CN3GESnow::Release();
}

CN3GESnow::~CN3GESnow()
{
	CN3GESnow::Release();
}

void CN3GESnow::Release()
{
	m_fWidth = m_fHeight = 0.0f;
	m_vVelocity.Set(0,0,0);
	s_MngTex.Delete(&m_pTex);
	if (m_pSnowParticle) {delete [] m_pSnowParticle; m_pSnowParticle = nullptr;}
	CN3GlobalEffect::Release();
}

void CN3GESnow::Tick()
{
	if (m_bActive == FALSE || m_iVC <= 0 || m_pVB == nullptr) return;
	CN3GlobalEffect::Tick();

	int iCount = m_iVC/3;
	int iActiveCount = iCount;
	if(m_iFadeMode > 0) // 차차 많아지게 한다..
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * m_fFadeTimeCur / m_fFadeTime);
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	else if(m_iFadeMode < 0)
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * (1.0f - m_fFadeTimeCur / m_fFadeTime));
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	if(iActiveCount <= 0) return;

	int i;
	__VertexXyzT1* pVertices;
	HRESULT hr = m_pVB->Lock(0, 0, (void**)&pVertices, D3DLOCK_NOSYSLOCK);
	if (FAILED(hr))
		return;

	__Vector3	vN = m_vVelocity;	vN.Normalize();
	__Vector3	vAdd = m_vVelocity*s_fSecPerFrm;
	float		fAddRadian = __PI*s_fSecPerFrm*0.1f;

	const float fHalfWidth = m_fWidth/2.0f;
	const float fHalfHeight = m_fHeight/2.0f;
	const float fCurY = s_CameraData.vEye.y;

	static const float sqrt3 = sqrtf(3.0f);

	for (i=0; i<iActiveCount; ++i)
	{
		// 위치 결정하기
		__VertexXyzT1* pV1 = pVertices+i*3+0;
		__VertexXyzT1* pV2 = pVertices+i*3+1;
		__VertexXyzT1* pV3 = pVertices+i*3+2;
//		__Vector3 vOffset2 = __Vector3(pV2->v) - __Vector3(pV1->v);
//		__Vector3 vOffset3 = __Vector3(pV3->v) - __Vector3(pV1->v);

		__SnowParticle* pParticle = m_pSnowParticle + i;
		pParticle->vPos += vAdd;
//		pV1->x += vAdd.x;	pV1->y += vAdd.y;	pV1->z += vAdd.z;

		float fDiff = pParticle->vPos.y - (fCurY-fHalfHeight);
		if (fDiff < 0)	// 높이 범위를 벗어났을 경우
		{
			pParticle->vPos.y -= (((int)(fDiff/m_fHeight)-1)*m_fHeight);
			pParticle->vPos.x = m_fWidth*(rand()%10000-5000)/10000.f;
			pParticle->vPos.z = m_fWidth*(rand()%10000-5000)/10000.f;

			pParticle->fRadius = (rand()%10000)/10000.f;
			pParticle->fRadian = 2*__PI*((rand()%10000)/10000.f);

			float		fRadian = __PI*((rand()%10000)/10000.f);
			pParticle->vOffset1.Set(0, sqrt3*m_fSnowSize/3.f, 0);
			pParticle->vOffset2.Set(cosf(fRadian)*m_fSnowSize/2, -sqrt3*m_fSnowSize/6.f, sinf(fRadian)*m_fSnowSize/2);
			pParticle->vOffset3.Set(-cosf(fRadian)*m_fSnowSize/2, -sqrt3*m_fSnowSize/6.f, -sinf(fRadian)*m_fSnowSize/2);
		}
		else
		{
			fDiff = pParticle->vPos.y - (fCurY+fHalfHeight);
			if (fDiff > 0)	// 높이 범위를 반대로 벗어났을경우
				pParticle->vPos.y -= ((int)(fDiff/m_fHeight)+1)*m_fHeight;
			// x 너비 범위를 벗어났을 경우
			fDiff = pParticle->vPos.x - fHalfWidth;
			if (fDiff > 0) pParticle->vPos.x -= ((int)(fDiff/m_fWidth)+1)*m_fWidth;
			fDiff = pParticle->vPos.x + fHalfWidth;
			if (fDiff < 0) pParticle->vPos.x -= ((int)(fDiff/m_fWidth)-1)*m_fWidth;
			// z 너비 범위를 벗어났을 경우
			fDiff = pParticle->vPos.z - fHalfWidth;
			if (fDiff >  0) pParticle->vPos.z -= ((int)(fDiff/m_fWidth)+1)*m_fWidth;
			fDiff = pParticle->vPos.z + fHalfWidth;
			if (fDiff < 0) pParticle->vPos.z -= ((int)(fDiff/m_fWidth)-1)*m_fWidth;
		}
		// 중심축을 주위로 회전한 위치 계산
		pParticle->fRadian += fAddRadian;
		__Vector3 vPos;	vPos.Set(cosf(pParticle->fRadian), 0, sinf(pParticle->fRadian));
		vPos += pParticle->vPos;
		
		// 버텍스 버퍼의 점 다시 세팅하기
		pV1->x = vPos.x + pParticle->vOffset1.x;	pV1->y = vPos.y + pParticle->vOffset1.y;	pV1->z = vPos.z + pParticle->vOffset1.z;
		pV2->x = vPos.x + pParticle->vOffset2.x;	pV2->y = vPos.y + pParticle->vOffset2.y;	pV2->z = vPos.z + pParticle->vOffset2.z;
		pV3->x = vPos.x + pParticle->vOffset3.x;	pV3->y = vPos.y + pParticle->vOffset3.y;	pV3->z = vPos.z + pParticle->vOffset3.z;
	}
	m_pVB->Unlock();
}

void CN3GESnow::Render(__Vector3& vPos)
{
	if (m_bActive == FALSE || m_iVC <= 0 || m_pVB == nullptr) return;
	
	CN3GlobalEffect::Render(vPos);

	int iCount = m_iVC / 3;
	int iActiveCount = iCount;
	if(m_iFadeMode > 0) // 차차 많아지게 한다..
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * m_fFadeTimeCur / m_fFadeTime);
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	else if(m_iFadeMode < 0)
	{
		if(m_fFadeTime > 0 && m_fFadeTimeCur < m_fFadeTime) // Fade시간땜에 건너뛰고 찍을 양 결정..
		{
			iActiveCount = (int)(iCount * (1.0f - m_fFadeTimeCur / m_fFadeTime));
			if(iActiveCount > iCount) iActiveCount = iCount;
			else if(iActiveCount < 0) iActiveCount = 0;
		}
	}
	if(iActiveCount <= 0) return;

	// 이전 render state 저장
	DWORD dwAlphaBlend, dwSrcAlpha, dwDestAlpha, dwCullMode, dwLight;
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaBlend );
	s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwSrcAlpha );
	s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwDestAlpha );
	s_lpD3DDev->GetRenderState( D3DRS_CULLMODE, &dwCullMode );
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);

	DWORD dwAddressU, dwAddressV;
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_ADDRESSU, &dwAddressU);
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_ADDRESSV, &dwAddressV);

	// set render state
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE,   D3DCULL_NONE);
	s_lpD3DDev->SetRenderState(D3DRS_LIGHTING,	 FALSE);

	// set transform
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	// set texture 
	__ASSERT(m_pTex, "Texture pointer is NULL!");
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_BORDERCOLOR, 0xffff0000);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);
	s_lpD3DDev->SetTexture(0, m_pTex->Get());

	// render
	s_lpD3DDev->SetFVF(FVF_XYZT1);
	s_lpD3DDev->SetStreamSource(0, m_pVB, 0, sizeof(__VertexXyzT1)); // 버텍스 버퍼 지정
	s_lpD3DDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, iActiveCount);

	// restore
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   dwSrcAlpha);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  dwDestAlpha);
	s_lpD3DDev->SetRenderState( D3DRS_CULLMODE, dwCullMode );
	s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, dwAddressU);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, dwAddressV);
}

void CN3GESnow::Create(float fDensity, float fWidth, float fHeight, float fSnowSize, const __Vector3& vVelocity, float fTimeToFade)
{
	if(nullptr == s_lpD3DDev) return;

	Release();

	CN3GlobalEffect::FadeSet(fTimeToFade, true);

	m_fWidth = fWidth;	m_fHeight = fHeight;	m_fSnowSize = fSnowSize;
	m_vVelocity = vVelocity;
	float fVolume = m_fWidth*m_fWidth*fHeight;
	__ASSERT(fVolume>0, "Snow volume is less than 0");
	int iSnowCount = (int)(fVolume*fDensity);

	// m_pVB, m_pIB 만들기
	__ASSERT(s_lpD3DDev, "D3D Device pointer is NULL!");
	m_iVC = iSnowCount*3;
	HRESULT hr = s_lpD3DDev->CreateVertexBuffer(m_iVC*sizeof(__VertexXyzT1), D3DUSAGE_DYNAMIC, FVF_XYZT1, D3DPOOL_DEFAULT, &m_pVB, nullptr);
	if (FAILED(hr)) return;
	__VertexXyzT1* pVertices;
	hr = m_pVB->Lock(0, iSnowCount*3*sizeof(__VertexXyzT1), (void**)&pVertices, D3DLOCK_NOSYSLOCK);
	if (FAILED(hr)) return;

	// __SnowParticle 정보 채워 넣기
	m_pSnowParticle = new __SnowParticle[iSnowCount];

	const float sqrt3 = sqrtf(3.0f);
	int i;
	for (i=0; i<iSnowCount; ++i)
	{
		m_pSnowParticle[i].vPos.Set(fWidth*(rand()%10000-5000)/10000.f,
									fHeight*(rand()%10000-5000)/10000.f,
									fWidth*(rand()%10000-5000)/10000.f);
		m_pSnowParticle[i].fRadius = (rand()%10000)/10000.f;
		m_pSnowParticle[i].fRadian = 2*__PI*((rand()%10000)/10000.f);

		float		fRadian = __PI*((rand()%10000)/10000.f);
//		정삼각형(한변의 길이가 fSnowSize)
//		m_pSnowParticle[i].vOffset1.Set(0, sqrt3*fSnowSize/3.f, 0);
//		m_pSnowParticle[i].vOffset2.Set(cosf(fRadian)*fSnowSize/2, -sqrt3*fSnowSize/6.f, sinf(fRadian)*fSnowSize/2);
//		m_pSnowParticle[i].vOffset3.Set(-cosf(fRadian)*fSnowSize/2, -sqrt3*fSnowSize/6.f, -sinf(fRadian)*fSnowSize/2);

//		이등변 삼각형(밑변의 길이 fSnowSize, 높이 fSnowSize)
		m_pSnowParticle[i].vOffset1.Set(0, fSnowSize/2.f, 0);
		m_pSnowParticle[i].vOffset2.Set(cosf(fRadian)*fSnowSize/2.f, -fSnowSize/2.f, sinf(fRadian)*fSnowSize/2.f);
		m_pSnowParticle[i].vOffset3.Set(-cosf(fRadian)*fSnowSize/2.f, -fSnowSize/2.f, -sinf(fRadian)*fSnowSize/2.f);

		// uv좌표 넣기
		__VertexXyzT1* pV1 = pVertices + i*3,	*pV2 = pVertices + i*3+1,	*pV3 = pVertices + i*3+2;
// 정삼각형에 눈 동그라미가 삼각형에 꽉 차게 UV좌표 배치 (geforce2카드에서 border color가 제대로 되지 않아서..)
//		pV1->tu = 0.5f;	pV1->tv = 0.5f - sqrt3/2.f;
//		pV2->tu = 0.5f + sqrt3/2.f;	pV2->tv = 1.0f;
//		pV3->tu = 0.5f - sqrt3/2.f;	pV3->tv = 1.0f;

		// 이등변 삼각형에 UV좌표 넣기
		pV1->tu = 0.5f;	pV1->tv = 0.0f;
		pV2->tu = 1.0f;	pV2->tv = 1.0f;
		pV3->tu = 0.0f;	pV3->tv = 1.0f;

		// 이 방식은 눈텍스쳐 사각형에 삼각형을 넣는 방식(따라서 눈 텍스쳐를 삼각형에 맞게 그려주자)

	}

	m_pVB->Unlock();
	m_pTex = s_MngTex.Get("Misc\\Snow.DXT", TRUE);
}

// ===== END N3Base/N3GESnow.cpp =====

// ===== BEGIN N3Base/N3GESnow.h =====
#line 1 "N3Base/N3GESnow.h"
﻿// N3GESnow.h: interface for the CN3GESnow class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3GESNOW_H__F7097F94_15E3_42B8_95DB_9EEC3CFD2E9C__INCLUDED_)
#define AFX_N3GESNOW_H__F7097F94_15E3_42B8_95DB_9EEC3CFD2E9C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3GlobalEffect.h"

class CN3GESnow : public CN3GlobalEffect  
{
// Structures
protected:
	struct __SnowParticle
	{
		__Vector3	vPos;							// 회전 반경의 줌심
		__Vector3	vOffset1, vOffset2, vOffset3;	// 점 1 2 3이 파티클 중점에서 떨어진 정도
		float		fRadius;						// 회전 반경
		float		fRadian;						// 현재 회전된 각도
		//float		fRVel							// 회전각속도 (우선 일정하다고 가정)
		// __Vector3 vVelocity						// 떨어지는 속도(우선 모두 같다고 가정)
	};

// Attributes
public:
	void SetVelocity(__Vector3& v) {m_vVelocity = v;}
protected:
	float		m_fWidth;		// 눈이 떨어지는 공간의 너비
	float		m_fHeight;		// 눈이 떨어지는 공간의 높이
	float		m_fSnowSize;	// 눈 하나의 크기
	__Vector3	m_vVelocity;	// 전체적으로 떨어지는 방향과 속도
	CN3Texture*	m_pTex;			// 눈 텍스쳐
	__SnowParticle*	m_pSnowParticle;	// 눈송이 정보

// Operations
public:
	void Release();
	void Tick();
	void Render(__Vector3& vPos);
	void Create(float fDensity, float fWidth, float fHeight, float fSnowSize, const __Vector3& vVelocity, float fTimeToFade = 3.0f);

	CN3GESnow();
	virtual ~CN3GESnow();

};

#endif // !defined(AFX_N3GESNOW_H__F7097F94_15E3_42B8_95DB_9EEC3CFD2E9C__INCLUDED_)

// ===== END N3Base/N3GESnow.h =====

// ===== BEGIN N3Base/N3GlobalEffect.cpp =====
#line 1 "N3Base/N3GlobalEffect.cpp"
﻿// N3GlobalEffect.cpp: implementation of the CN3GlobalEffect class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3GlobalEffect.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3GlobalEffect::CN3GlobalEffect()
{
	m_pVB = nullptr;
	m_pIB = nullptr;
	m_bActive = FALSE;
	m_iVC = 0;
	m_iIC = 0;
	m_fFadeTime = 0.0f; // 이시간 동안 차차 목표한 양만큼 파티클의 수가 늘어난다..
	m_fFadeTimeCur = 0.0f; // 지난시간..
	m_iFadeMode = 0;
}

CN3GlobalEffect::~CN3GlobalEffect()
{
	if (m_pVB) { m_pVB->Release(); m_pVB = nullptr;}
	if (m_pIB) { m_pIB->Release(); m_pIB = nullptr;}
}

void CN3GlobalEffect::Release()
{
	if (m_pVB) { m_pVB->Release(); m_pVB = nullptr;}
	if (m_pIB) { m_pIB->Release(); m_pIB = nullptr;}
	m_bActive = FALSE;
	m_iVC = 0;
	m_iIC = 0;
	m_fFadeTime = 0.0f; // 이시간 동안 차차 목표한 양만큼 파티클의 수가 늘어난다..
	m_fFadeTimeCur = 0.0f; // 지난시간..
	m_iFadeMode = 0;

	CN3Transform::Release();
}

void CN3GlobalEffect::Tick()
{
	CN3Transform::Tick(-1);

	if(m_iFadeMode && m_fFadeTime > 0) // 시간을 지나게 한다..
	{
		m_fFadeTimeCur += s_fSecPerFrm;
		if(m_fFadeTimeCur > m_fFadeTime) m_fFadeTimeCur = m_fFadeTime;
	}
}

void CN3GlobalEffect::Render(__Vector3& vPos)
{
	PosSet(vPos);
}


void CN3GlobalEffect::FadeSet(float fTimeToFade, bool bFadeIn)
{
	m_fFadeTime = fTimeToFade;
	m_fFadeTimeCur = 0;
	if(bFadeIn) m_iFadeMode = 1;
	else m_iFadeMode = -1;
}

// ===== END N3Base/N3GlobalEffect.cpp =====

// ===== BEGIN N3Base/N3GlobalEffect.h =====
#line 1 "N3Base/N3GlobalEffect.h"
﻿// N3GlobalEffect.h: interface for the CN3GlobalEffect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3GLOBALEFFECT_H__01468E41_4EE1_4893_8886_E57EE2491007__INCLUDED_)
#define AFX_N3GLOBALEFFECT_H__01468E41_4EE1_4893_8886_E57EE2491007__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Transform.h"
const uint32_t GETYPE_RAIN = 0x00000001;
const uint32_t GETYPE_SNOW = 0x00000002;

class CN3GlobalEffect : public CN3Transform  
{
public:
	CN3GlobalEffect();
	virtual ~CN3GlobalEffect();

// Attributes
public:
	void						SetActive(BOOL bActive) {m_bActive = bActive;}
protected:
	int							m_iVC;
	int							m_iIC;
	LPDIRECT3DVERTEXBUFFER9		m_pVB;
	LPDIRECT3DINDEXBUFFER9		m_pIB;
	uint32_t						m_dwEffectType;
	BOOL						m_bActive;
	float						m_fFadeTime; // 이시간 동안 차차 목표한 양만큼 파티클의 수가 늘어난다..
	float						m_fFadeTimeCur; // 지난시간..
	int							m_iFadeMode; // 1 - FadeIn 0... -1 FadeOut

// Operations
public:
	virtual bool	NeedDelete() { if(m_iFadeMode < 0 && m_fFadeTimeCur >= m_fFadeTime) return true; return false; }
	virtual void	FadeSet(float fTimeToFade, bool bFadeIn);
	virtual void	Release();
	virtual void	Tick();
	virtual void	Render(__Vector3& vPos);
protected:

};

#endif // !defined(AFX_N3GLOBALEFFECT_H__01468E41_4EE1_4893_8886_E57EE2491007__INCLUDED_)

// ===== END N3Base/N3GlobalEffect.h =====

// ===== BEGIN N3Base/N3GlobalEffectMng.cpp =====
#line 1 "N3Base/N3GlobalEffectMng.cpp"
﻿// N3GlobalEffectMng.cpp: implementation of the CN3GlobalEffectMng class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3GlobalEffectMng.h"
#include "N3GERain.h"
#include "N3GESnow.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3GlobalEffectMng::CN3GlobalEffectMng()
{
	m_pGERain = nullptr;
	m_pGESnow = nullptr;
	CN3GlobalEffectMng::Release();
}

CN3GlobalEffectMng::~CN3GlobalEffectMng()
{
	CN3GlobalEffectMng::Release();
}

void CN3GlobalEffectMng::Release()
{
	CN3Base::Release();
	m_fCellSize = 0.0f;
	m_CurCellPos.x = m_CurCellPos.y = -1;

	if (m_pGERain) {delete m_pGERain; m_pGERain = nullptr;}
	if (m_pGESnow) {delete m_pGESnow; m_pGESnow = nullptr;}
}

void CN3GlobalEffectMng::Tick()
{
	if (m_fCellSize<=0.0f) return;

	POINT NewCellPos;	
	NewCellPos.x = int(s_CameraData.vEye.x/m_fCellSize);
	NewCellPos.y = int(s_CameraData.vEye.z/m_fCellSize);
	if (NewCellPos.x != m_CurCellPos.x || NewCellPos.y != m_CurCellPos.y)
	{
		m_CurCellPos = NewCellPos;
		int i, j;
		for(i=0; i<3; ++i)
			for(j=0; j<3; ++j)
				m_vPos[j*3+i].Set( (m_CurCellPos.x+i-0.5f)*m_fCellSize, 0, (m_CurCellPos.y+j-0.5f)*m_fCellSize);
	}

	if (m_pGERain)
	{
		m_pGERain->Tick();
		if(m_pGERain->NeedDelete()) { delete m_pGERain; m_pGERain = nullptr; }
	}
	if (m_pGESnow)
	{
		m_pGESnow->Tick();
		if(m_pGESnow->NeedDelete()) { delete m_pGESnow; m_pGESnow = nullptr; }
	}

}

void CN3GlobalEffectMng::Render()
{
	int i, j;
	for (i=0; i<3; ++i)
	{
		for(j=0; j<3; ++j)
		{
			if (m_pGERain)
			{
				m_pGERain->Render(m_vPos[j*3+i]);
			}
			if (m_pGESnow)
			{
				m_pGESnow->Render(m_vPos[j*3+i]);
			}
		}
	}
}
/*
void CN3GlobalEffectMng::SetWeather(int iWeather)
{
	const float fHeight = 20.0f;
	BOOL	bRainy;
	float fDensity;
	__Vector3 vVelocity;
	float fRainLength;
	float fSnowSize;

	switch(iWeather)
	{
	case GEW_CLEAR:
		if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
		if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
		return;
		break;
	case GEW_DRIZZLE_RAIN:
		bRainy = TRUE;
		fDensity = 0.03f;
		vVelocity.Set(0.3f, -7.0f, 0);
		fRainLength = 0.1f;
		break;
	case GEW_RAINY:
		bRainy = TRUE;
		fDensity = 0.08f;
		vVelocity.Set(0, -10.0f, 1);
		fRainLength= 0.2f;
		break;
	case GEW_HEAVY_RAIN:
		bRainy = TRUE;
		fDensity = 0.12f;
		vVelocity.Set(0.3f, -10.0f, -1.5f);
		fRainLength= 0.25f;
		break;
	case GEW_SNOW1:
		bRainy = FALSE;
		fDensity = 0.08f;
		vVelocity.Set(0.0f, -0.7f, 0.0f);
		fSnowSize = 0.05f;
		break;
	case GEW_SNOW2:
		bRainy = FALSE;
		fDensity = 0.12f;
		vVelocity.Set(0.5f, -1.0f, 0.0f);
		fSnowSize = 0.08f;
		break;
	case GEW_HEAVY_SNOW:
		bRainy = FALSE;
		fDensity = 0.2f;
		vVelocity.Set(-9.0f, -3.0f, 0.0f);
		fSnowSize = 0.1f;
		break;
	default:
		return;
	}
	
	if (bRainy)
	{
		if (m_pGERain == nullptr) m_pGERain = new CN3GERain;

		m_fCellSize = 20.0f;
		m_pGERain->Create(fDensity, m_fCellSize, fHeight, fRainLength, vVelocity);	// 비
		m_pGERain->SetActive(TRUE);
		if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
	}
	else
	{
		if (m_pGESnow == nullptr) m_pGESnow = new CN3GESnow;

		m_fCellSize = 10.0f;
		m_pGESnow->Create(fDensity, m_fCellSize, fHeight, fSnowSize, vVelocity);	// 눈
		m_pGESnow->SetActive(TRUE);
		if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
	}
}
*/
void CN3GlobalEffectMng::WeatherSetClean()
{
	if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
	if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
}

void CN3GlobalEffectMng::WeatherSetRainy(int iPercent)
{
	if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
	if (m_pGERain == nullptr) m_pGERain = new CN3GERain;

	float fHeight = 20.0f;
	float fPercent = iPercent / 100.0f;
	float fDensity = fPercent * 0.1f;
	__Vector3 vVelocity(3.0f * ((50-rand()%100) / 50.0f), -(10.0f + 8.0f * fPercent), 0);
	float fRainLength = 0.4f + 0.6f * fPercent;

	m_fCellSize = 20.0f;
	m_pGERain->Create(fDensity, m_fCellSize, fHeight, fRainLength, vVelocity, 10.0f);	// 비
	m_pGERain->SetActive(TRUE);
}

void CN3GlobalEffectMng::WeatherSetSnow(int iPercent)
{
	if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
	if (m_pGESnow == nullptr) m_pGESnow = new CN3GESnow;

	float fHeight = 20.0f;
	float fPercent = iPercent / 100.0f;
	float fDensity = fPercent * 0.1f;
	float fHorz = (3.0f * fPercent) + (3.0f * ((50-rand()%100) / 50.0f));
	__Vector3 vVelocity(fHorz, -(2.0f + 2.0f * fPercent), 0);
	float fSnowSize = 0.1f + 0.1f * fPercent;

	m_fCellSize = 20.0f;
	m_pGESnow->Create(fDensity, m_fCellSize, fHeight, fSnowSize, vVelocity, 10.0f);	// 비
	m_pGESnow->SetActive(TRUE);
}
// ===== END N3Base/N3GlobalEffectMng.cpp =====

// ===== BEGIN N3Base/N3GlobalEffectMng.h =====
#line 1 "N3Base/N3GlobalEffectMng.h"
﻿// N3GlobalEffectMng.h: interface for the CN3GlobalEffectMng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3GLOBALEFFECTMNG_H__E95C3268_DD68_45AE_AA24_DC64B11A1B08__INCLUDED_)
#define AFX_N3GLOBALEFFECTMNG_H__E95C3268_DD68_45AE_AA24_DC64B11A1B08__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"

enum {	GEW_CLEAR=0,			// 맑음
		GEW_DRIZZLE_RAIN=1,		// 가랑비
		GEW_RAINY=2,			// 적당량의 비
		GEW_HEAVY_RAIN=3,		// 폭우
		GEW_SNOW1=11,			// 포근한 눈
		GEW_SNOW2=12,			// 적당한 눈
		GEW_HEAVY_SNOW=13		// 폭설
};

class CN3GERain;
class CN3GESnow;
class CN3GlobalEffectMng : public CN3Base  
{
public:
	CN3GlobalEffectMng();
	virtual ~CN3GlobalEffectMng();

// Attributes
public:
protected:
	float			m_fCellSize;	// 내부 셀 크기
	POINT			m_CurCellPos;	// 현재 내부셀 좌표
	__Vector3		m_vPos[9];		// 주변 셀 9칸의 중심좌표들

	// 효과들..
	CN3GERain*		m_pGERain;		// 비
	CN3GESnow*		m_pGESnow;		// 눈

// Operations
public:
	virtual void	Release();
	void			Tick();
	void			Render();
//	void			SetWeather(int iWeather);	// 날씨 지정하기
	void			WeatherSetRainy(int iPercent);
	void			WeatherSetSnow(int iPercent);
	void			WeatherSetClean();

protected:

};

#endif // !defined(AFX_N3GLOBALEFFECTMNG_H__E95C3268_DD68_45AE_AA24_DC64B11A1B08__INCLUDED_)

// ===== END N3Base/N3GlobalEffectMng.h =====

// ===== BEGIN N3Base/N3IME.h =====
#line 1 "N3Base/N3IME.h"
﻿// N3IME.h: interface for the CN3IME class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3IME_H__87E26E3B_B5EB_403B_8126_2884169AFEE9__INCLUDED_)
#define AFX_N3IME_H__87E26E3B_B5EB_403B_8126_2884169AFEE9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <imm.h>
#include <string>
using namespace std;

const uint32_t IME_IN_COMPOSITION	= 0x00000001;
const uint32_t IME_IN_CHOSECAND	= 0x00000002;

#define MAX_LISTCAND 32
#define MAX_CHARS_PER_LINE		10
#define MAX_COMP_STRING_LEN		10
#define DEFAULT_CAND_NUM_PER_PAGE 5

//char	CANDWND_CLASS[] = "HanjaCandidate";

class CN3IME  
{
public:
	CN3IME();
	virtual ~CN3IME();

// Attributes
public:
protected:
	HWND			m_hWnd;
	HIMC			m_hIMC;
	HKL				m_hKeyLayout;
	uint32_t			m_dwProperty;
	uint32_t			m_dwState;

// Operations
public:
	BOOL			InitIME(HWND hwnd);
	LRESULT			IMEMessageProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
protected:
	inline BOOL Enter() {
		if(m_hWnd != nullptr) return (BOOL)(m_hIMC = ImmGetContext(m_hWnd));
		else return FALSE;
	};
	inline void Leave() {
		ImmReleaseContext(m_hWnd, m_hIMC);
	};
	inline BOOL Check() {
		return (!(m_dwProperty & IME_PROP_SPECIAL_UI) && (m_dwProperty & IME_PROP_AT_CARET));
	}

	// for Message 
	LRESULT OnInputLangChange(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMESetContext(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMEStartComposition(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMEComposition(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMEEndComposition(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMECompositionFull(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMENotify(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnIMEControl(WPARAM dwCommand, LPARAM dwData);
	LRESULT OnChar(WPARAM wParam);
	LRESULT OnKeyDown(WPARAM wParam);

	BOOL OpenCandidate(int32_t lParam);
	BOOL CloseCandidate(int32_t CandList);
	BOOL ChangeCandidate(int32_t CandList);
	BOOL SetOpenStatus();

	void ClearData();
	BOOL GetResultString();
	BOOL GetCompString(int32_t flag);
};

#endif // !defined(AFX_N3IME_H__87E26E3B_B5EB_403B_8126_2884169AFEE9__INCLUDED_)

// ===== END N3Base/N3IME.h =====

// ===== BEGIN N3Base/N3IMesh.cpp =====
#line 1 "N3Base/N3IMesh.cpp"
﻿// N3MeshIndexed: implementation of the CN3IMesh class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3IMesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

__VertexT1 CN3IMesh::s_Vertices[MAX_IMESH_BUFFER];
__VertexT2 CN3IMesh::s_Vertices2[MAX_IMESH_BUFFER];

CN3IMesh::CN3IMesh()
{
	m_dwType |= OBJ_MESH_INDEXED;

	m_nFC = 0;

	m_pwVtxIndices = nullptr; // 점 인덱스 리스트. 
	m_pwUVsIndices = nullptr; // 텍스처 좌표 인덱스 리스트.

	m_nVC = m_nUVC = 0;
	m_pVertices = nullptr;
	m_pfUVs = nullptr;
//	m_lpVB = nullptr;
}

CN3IMesh::~CN3IMesh()
{
	delete [] m_pVertices; m_pVertices = nullptr;
	delete [] m_pfUVs; m_pfUVs = nullptr;

	delete [] m_pwVtxIndices; m_pwVtxIndices = nullptr; // 점 인덱스 리스트. 
	delete [] m_pwUVsIndices; m_pwUVsIndices = nullptr; // 텍스처 좌표 인덱스 리스트.

//	if(m_lpVB) m_lpVB->Release();
}

void CN3IMesh::Release()
{
	CN3BaseFileAccess::Release();

	m_nFC = 0;
	m_nVC = 0;
	m_nUVC = 0;

	delete [] m_pVertices; m_pVertices = nullptr;
	delete [] m_pfUVs; m_pfUVs = nullptr;

	delete [] m_pwVtxIndices; m_pwVtxIndices = nullptr; // 점 인덱스 리스트. 
	delete [] m_pwUVsIndices; m_pwUVsIndices = nullptr; // 텍스처 좌표 인덱스 리스트.

//	if(m_lpVB) m_lpVB->Release(); m_lpVB = nullptr;

	m_vMin.Zero();
	m_vMax.Zero();
}

bool CN3IMesh::Create(int nFC, int nVC, int nUVC)
{
	if(nFC <= 0 || nVC <= 0) return false; // "Face count is less than 0 or vertex count is less than 0");

	if(m_nFC > 0) this->Release();

#ifdef _N3GAME
	if (nFC > 32768)
		CLogWriter::Write("CN3IMesh::Create - Too many faces. (more than 32768) ({})", m_szFileName);
#endif

	m_nFC = nFC;
	m_nVC = nVC;
	m_pVertices = new __VertexXyzNormal[nVC]; memset(m_pVertices, 0, sizeof(__VertexXyzNormal) * nVC);
	m_pwVtxIndices = new uint16_t[nFC*3]; memset(m_pwVtxIndices, 0, 2 * nFC * 3); // uint16_t
	
	if(nUVC > 0)
	{
		m_nUVC = nUVC; m_pfUVs = new float[nUVC*2]; memset(m_pfUVs, 0, 8 * nUVC); // 사이즈가 8 인 이유는 float 2개라 그렇다..
		m_pwUVsIndices = new uint16_t[nFC*3]; memset(m_pwUVsIndices, 0, 2 * nFC * 3); // uint16_t
	}

	return true;
}


__VertexT1* CN3IMesh::BuildVertexList()
{
	if(m_nFC <= 0) return nullptr;
	if(m_nFC >= MAX_IMESH_BUFFER / 3)
	{
		__ASSERT(0, "Vertex Buffer Overflow");
		return nullptr;
	}

	int n = 0, nVI = 0, nUVI = 0;
	if(m_nUVC > 0)
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			
			n = i*3+1; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );

			n = i*3+2; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
		}
	}
	else
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n];
			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );
			
			n = i*3+1; nVI = m_pwVtxIndices[n];
			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );

			n = i*3+2; nVI = m_pwVtxIndices[n];
			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );
		}
	}

	return s_Vertices;
}

__VertexT2* CN3IMesh::BuildVertexListTwoUV()
{
	if(m_nFC <= 0) return nullptr;
	if(m_nFC >= MAX_IMESH_BUFFER / 3)
	{
		__ASSERT(0, "Vertex Buffer Overflow");
		return nullptr;
	}

	int n = 0, nVI = 0, nUVI = 0;
	if(m_nUVC > 0)
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices2[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1],
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1]);
			
			n = i*3+1; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices2[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1],
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1]);

			n = i*3+2; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			s_Vertices[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			s_Vertices2[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
								m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1],
								m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1]);
		}
	}
	else
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n];
			s_Vertices2[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 1, 0, 1 );
			
			n = i*3+1; nVI = m_pwVtxIndices[n];
			s_Vertices2[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 1, 0, 1 );

			n = i*3+2; nVI = m_pwVtxIndices[n];
			s_Vertices2[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 1, 0, 1 );
		}
	}

	return s_Vertices2;
}

/*
__VertexT1* CN3IMesh::BuildVertexList()
{
	if(m_nFC <= 0 || nullptr == m_lpVB) return nullptr;

	__VertexT1* pVDests = nullptr;
	m_lpVB->Lock(0, 0, (uint8_t**)(&pVDests), 0);

	int n = 0, nVI = 0, nUVI = 0;
	if(m_nUVC > 0)
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			pVDests[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
							m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
							m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			
			n = i*3+1; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			pVDests[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
							m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
							m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );

			n = i*3+2; nVI = m_pwVtxIndices[n]; nUVI = m_pwUVsIndices[n];
//			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
			pVDests[n].Set(	m_pVertices[nVI].x, m_pVertices[nVI].y, m_pVertices[nVI].z,
							m_pVertices[nVI].n.x, m_pVertices[nVI].n.y, m_pVertices[nVI].n.z, 
							m_pfUVs[nUVI*2], m_pfUVs[nUVI*2+1] );
		}
	}
	else
	{
		for(int i = 0; i < m_nFC; i++)
		{
			n = i*3+0; nVI = m_pwVtxIndices[n];
			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );
			
			n = i*3+1; nVI = m_pwVtxIndices[n];
			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );

			n = i*3+2; nVI = m_pwVtxIndices[n];
			pVDests[n].Set(	m_pVertices[nVI], m_pVertices[nVI].n, 0, 0 );
		}
	}

	m_lpVB->Unlock();
	return pVDests;
}
*/

void CN3IMesh::Render(bool bUseTwoUV)
{
	if(s_lpD3DDev == nullptr || m_nFC <= 0) return;

	if(bUseTwoUV)
	{
		__VertexT2* pVs = this->BuildVertexListTwoUV();
		if(pVs)
		{
			s_lpD3DDev->SetFVF(FVF_VNT2);
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, m_nFC, pVs, sizeof(__VertexT2));
		}
	}
	else
	{
		__VertexT1* pVs = this->BuildVertexList();
		if(pVs)
		{
			s_lpD3DDev->SetFVF(FVF_VNT1);
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, m_nFC, pVs, sizeof(__VertexT1));
		}
	}

//	this->BuildVertexList();
//	s_lpD3DDev->SetFVF(FVF_VNT1);
//	s_lpD3DDev->SetStreamSource( 0, m_lpVB, sizeof(__VertexT1) );
//	s_lpD3DDev->DrawPrimitive(D3DPT_TRIANGLELIST, 0, m_nFC);
}

#ifdef _N3TOOL
void CN3IMesh::RenderSelected()
{
	if(s_lpD3DDev == nullptr || m_nFC <= 0) return;
	__VertexT1* pVs = this->BuildVertexList();
	if(nullptr == pVs) return;

	__Vector3 vFace[4];
	for(int i = 0; i < m_nFC; i++)
	{
		vFace[0] = pVs[i*3+0];
		vFace[1] = pVs[i*3+1];
		vFace[2] = pVs[i*3+2];
		vFace[3] = vFace[0];
		CN3Base::RenderLines(vFace, 3, 0xff00ff00); // 녹색으로 렌더링..
	}
}
#endif // end of _N3TOOL

bool CN3IMesh::Load(File& file)
{
	CN3BaseFileAccess::Load(file);
	
	int nFC = 0, nVC = 0, nUVC = 0;

	file.Read(&nFC, 4);
	file.Read(&nVC, 4);
	file.Read(&nUVC, 4);

	if(nFC > 0 && nVC > 0)
	{
		this->Create(nFC, nVC, nUVC);
		file.Read(m_pVertices, sizeof(__VertexXyzNormal) * nVC);
		file.Read(m_pwVtxIndices, 2 * nFC * 3); // uint16_t
	}
	else
	{
		Release();
	}
	
	if(m_nUVC > 0)
	{
		file.Read(m_pfUVs, 8 * nUVC);
		file.Read(m_pwUVsIndices, 2 * nFC * 3); // uint16_t
	}

	this->FindMinMax(); // 최소 최대값을 찾는다..

	return true;
}

#ifdef _N3TOOL
bool CN3IMesh::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	file.Write(&m_nFC, 4);
	file.Write(&m_nVC, 4);
	file.Write(&m_nUVC, 4);

	if(m_nFC > 0 && m_nVC > 0)
	{
		file.Write(m_pVertices, sizeof(__VertexXyzNormal) * m_nVC);
		file.Write(m_pwVtxIndices, 2 * m_nFC * 3); // uint16_t
	}
	
	if(m_nUVC > 0)
	{
		file.Write(m_pfUVs, 8 * m_nUVC);
		file.Write(m_pwUVsIndices, 2 * m_nFC * 3); // uint16_t
	}

	return true;
}
#endif // end of _N3TOOL

void CN3IMesh::FindMinMax()
{
	m_vMin.Zero();
	m_vMax.Zero();

	if(m_pVertices == nullptr || m_nVC < 0) return;

	// 최소, 최대 점을 찾는다.
	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	for(int i = 0; i < m_nVC; i++)
	{
		if(m_pVertices[i].x < m_vMin.x) m_vMin.x = m_pVertices[i].x;
		if(m_pVertices[i].y < m_vMin.y) m_vMin.y = m_pVertices[i].y;
		if(m_pVertices[i].z < m_vMin.z) m_vMin.z = m_pVertices[i].z;

		if(m_pVertices[i].x > m_vMax.x) m_vMax.x = m_pVertices[i].x;
		if(m_pVertices[i].y > m_vMax.y) m_vMax.y = m_pVertices[i].y;
		if(m_pVertices[i].z > m_vMax.z) m_vMax.z = m_pVertices[i].z;
	}
}

#ifdef _N3TOOL
void CN3IMesh::ReGenerateSmoothNormal()
{
	if(m_nFC <= 0) return;
	if(nullptr == this->BuildVertexList()) return;

	int* pnNs = new int[m_nVC];
	memset(pnNs, 0, 4 * m_nVC);
	__Vector3* pvNs = new __Vector3[m_nVC];
	memset(pvNs, 0, sizeof(__Vector3)*m_nVC);

	__Vector3 v0, v1, v2, vN(0,0,0);
	for(int i = 0; i < m_nVC; i++)
	{
		for(int j = 0; j < m_nFC; j++)
		{
			v0 = m_pVertices[m_pwVtxIndices[j*3+0]];
			v1 = m_pVertices[m_pwVtxIndices[j*3+1]];
			v2 = m_pVertices[m_pwVtxIndices[j*3+2]];

			if(	(m_pVertices[i].x == v0.x && m_pVertices[i].y == v0.y && m_pVertices[i].z == v0.z) ||
				(m_pVertices[i].x == v1.x && m_pVertices[i].y == v1.y && m_pVertices[i].z == v1.z) ||
				(m_pVertices[i].x == v2.x && m_pVertices[i].y == v2.y && m_pVertices[i].z == v2.z) )
			{
				vN.Cross(v1 - v0, v2 - v1);
				vN.Normalize();

				pnNs[i]++;
				pvNs[i] += vN;
			}
		}

		m_pVertices[i].n = pvNs[i] / (float)pnNs[i];
	}

	delete [] pnNs;
	delete [] pvNs;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3IMesh::ApplyOffset(__Vector3 vOffset)
{
	for(int i = 0; i < m_nVC; i++)
	{
		m_pVertices[i].x += vOffset.x;
		m_pVertices[i].y += vOffset.y;
		m_pVertices[i].z += vOffset.z;
	}
}
#endif // end of _N3TOOL

#ifdef _N3GAME
void CN3IMesh::TickForShadow(bool bUseTwoUV)
{
	if(s_lpD3DDev == nullptr || m_nFC <= 0) 
	{
		m_pVertexT1 = nullptr;
		return;
	}

	if(bUseTwoUV)
	{
		__Vector3* pVs = (__Vector3*)this->BuildVertexListTwoUV();
		if(pVs)
			m_pVertexT1 = pVs;
		else
			m_pVertexT1 = nullptr;
	}
	else
	{
		__Vector3* pVs = (__Vector3*)this->BuildVertexList();
		if(pVs)
			m_pVertexT1 = pVs;
		else
			m_pVertexT1 = nullptr;
	}
}

int CN3IMesh::GetVertexCount()
{
	return m_nFC;
}

__Vector3* CN3IMesh::GetVertexData()
{
	return m_pVertexT1;
}
#endif

// ===== END N3Base/N3IMesh.cpp =====

// ===== BEGIN N3Base/N3IMesh.h =====
#line 1 "N3Base/N3IMesh.h"
﻿// N3MeshIndexed.h: interface for the CN3IMesh class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3IMesh_h__INCLUDED_)
#define AFX_N3IMesh_h__INCLUDED_

#include "N3BaseFileAccess.h"

const int MAX_IMESH_BUFFER = 10000;

class CN3IMesh : public CN3BaseFileAccess
{
protected:
	static __VertexT1	s_Vertices[MAX_IMESH_BUFFER];
	static __VertexT2	s_Vertices2[MAX_IMESH_BUFFER];

	int					m_nFC; // 삼각형 갯수

	int					m_nVC; // Vertex Count
	uint16_t*				m_pwVtxIndices; // 점 인덱스 리스트. 
	int					m_nUVC; // UV 좌표 Count
	uint16_t*				m_pwUVsIndices; // 텍스처 좌표 인덱스 리스트.

	float*				m_pfUVs; // UV Data - m_nUVC * 2 만큼 할당한다.
//	LPDIRECT3DVERTEXBUFFER8 m_lpVB;

	__Vector3			m_vMin, m_vMax; // 최소, 최대점.. 변하긴 하지만 대략적으로...

public:
#ifdef _N3TOOL
	void				ApplyOffset(__Vector3 vOffset);
	void				ReGenerateSmoothNormal();
	void				RenderSelected();
#endif // end of _N3TOOL
	__Vector3			Min() { return m_vMin; }
	__Vector3			Max()	{ return m_vMax; }
	void				FindMinMax();
	void				Render(bool bUseTwoUV = false);
	__VertexT1*			BuildVertexList(); // Vertex Buffer 에다가 점을 만든다.. 동시에 두번 사용하지 않도록 주의가 필요
	__VertexT2*			BuildVertexListTwoUV(); // Vertex Buffer 에다가 점을 만든다.. 동시에 두번 사용하지 않도록 주의가 필요
	
	int					FaceCount() { return m_nFC; }
	int					VertexCount() { return m_nVC; }

	__VertexXyzNormal*	m_pVertices; // 좌표 Data

	__VertexXyzNormal*	Vertices() { return m_pVertices; }
	uint16_t*			VertexInices() { return m_pwVtxIndices; }
	int					UVCount() { return m_nUVC; }
#ifdef _N3TOOL
	void				VertexIndexSet(int index, int nVI) { if(index >= 0 && index < m_nFC*3) m_pwVtxIndices[index] = nVI; }
	void				UVSet(int index, float fU, float fV) { if(index >= 0 && index < m_nUVC) { m_pfUVs[index*2+0] = fU; m_pfUVs[index*2+1] = fV; } }
	void				UVIndexSet(int index, int nUVI) { if(index >= 0 && index < m_nFC*3) m_pwUVsIndices[index] = nUVI; }
#endif // end of _N3TOOL

	virtual bool		Create(int nFC, int nVC, int nUVC); // 차례대로  Face Count, VertexCount, UV Count
	bool				Load(File& file) override;
#ifdef _N3TOOL
	bool				Save(File& file) override;
#endif // end of _N3TOOL
	
	void Release() override;
	CN3IMesh();
	~CN3IMesh() override;

//	By : Ecli666 ( On 2002-07-23 오후 5:31:41 )
//
#ifdef _N3GAME
	void				TickForShadow(bool bUseTwoUV = false);
	int					GetVertexCount();
	__Vector3*			GetVertexData();

private:	
	__Vector3*			m_pVertexT1;
#endif

//	~(By Ecli666 On 2002-07-23 오후 5:31:41 )
};

#endif // !defined(AFX_N3IMesh_h__INCLUDED_)

// ===== END N3Base/N3IMesh.h =====

// ===== BEGIN N3Base/N3Joint.cpp =====
#line 1 "N3Base/N3Joint.cpp"
﻿// N3Joint.cpp: implementation of the CN3Joint class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Joint.h"
#include "N3Mesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Joint::CN3Joint()
{
	m_dwType |= OBJ_JOINT;
	
	m_qOrient.Identity();		// Joint Orient Quaternion
	m_pParent = nullptr;
}

CN3Joint::~CN3Joint()
{
	for(it_Joint it = m_Children.begin(), itEnd = m_Children.end(); it != itEnd; it++)
	{
		delete *it;
	}
	m_Children.clear();
}

void CN3Joint::Release()
{
	m_qOrient.Identity();		// Joint Orient Quaternion
	m_KeyOrient.Release();		// Joint Orient 키값... nullptr 이면 없는거다..
	
	for(it_Joint it = m_Children.begin(), itEnd = m_Children.end(); it != itEnd; it++)
	{
		delete *it;
	}
	m_Children.clear();
	m_pParent = nullptr;

	CN3Transform::Release();
}

bool CN3Joint::Load(File& file)
{
	CN3Transform::Load(file);

	m_KeyOrient.Load(file); // Joint Orient...

	int nCC = 0;
	file.Read(&nCC, 4);
	for (int i = 0; i < nCC; i++)
	{
		CN3Joint* pChild = new CN3Joint();
		ChildAdd(pChild);
		pChild->Load(file);
	}

	return true;
}

#ifdef _N3TOOL
bool CN3Joint::Save(File& file)
{
	CN3Transform::Save(file);
	
	m_KeyOrient.Save(file); // 

	int iSize = static_cast<int>(m_Children.size());
	file.Write(&iSize, 4);

	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		pChild->Save(file);
	}

	return true;
}
#endif // end of _N3TOOL


#ifdef _N3TOOL
void CN3Joint::Render(const __Matrix44* pMtxParent, float fUnitSize)
{
	DWORD dwAlpha, dwFog, dwLight, dwZ;
	s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	
	if(dwZ) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);

	static __Matrix44 stm;
	static __Material smtl;
	static bool bInit = false;
	if(false == bInit)
	{
		stm.Identity();
		smtl.Init();
		bInit = true;
	}

	s_lpD3DDev->SetTransform(D3DTS_WORLD, stm.toD3D());
	s_lpD3DDev->SetMaterial(&smtl);
	s_lpD3DDev->SetTexture(0, nullptr);

	if(m_pParent) // 부모 관절과 이어주는 선..
	{
		static __Vector3 v[2];
		static __VertexColor vBone[2];
	
		v[0] = m_pParent->m_Matrix.Pos();
		v[1] = m_Matrix.Pos();
		if(pMtxParent)
		{
			v[0] *= *pMtxParent;
			v[1] *= *pMtxParent;
		}

		vBone[0].Set(v[0], 0xff00ff00);
		vBone[1].Set(v[1], 0xff0000ff);
		s_lpD3DDev->SetFVF(FVF_CV);
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, vBone, sizeof(__VertexColor)); // 선그리기..
	}

	// 박스 그리기..
	static __VertexColor vBoxes[36];
	static __VertexColor vAxis[6];
	static bool bBoxCreated = false;
	if(false == bBoxCreated)
	{
		CN3Mesh mesh;
		mesh.Create_Cube(__Vector3(-0.5f, -0.5f, -0.5f), __Vector3(0.5f, 0.5f, 0.5f));
		__VertexT1* pVSrc = mesh.Vertices();
		for(int i = 0; i < 36; i++)
		{
			vBoxes[i].Set(pVSrc[i].x, pVSrc[i].y, pVSrc[i].z, 0xff00ff00);
		}

		float fL = 1.0f;
		vAxis[0].Set(0, 0, 0, 0xffff0000);
		vAxis[1].Set(fL, 0, 0, 0xffff0000);
		vAxis[2].Set(0, 0, 0, 0xff00ff00);
		vAxis[3].Set(0, fL, 0, 0xff00ff00);
		vAxis[4].Set(0, 0, 0, 0xff0000ff);
		vAxis[5].Set(0, 0, fL, 0xff0000ff);

		bBoxCreated = true;
	}

	__Matrix44 mtxAxis, mtxBox;
	mtxBox.Scale(fUnitSize, fUnitSize, fUnitSize);
	if(m_Children.size() > 0) mtxAxis.Scale(fUnitSize*2, fUnitSize*2, fUnitSize*2);
	else mtxAxis.Scale(fUnitSize*12, fUnitSize*12, fUnitSize*12);

	mtxBox *= m_Matrix;
	mtxAxis *= m_Matrix;

	s_lpD3DDev->SetFVF(FVF_CV);
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxBox.toD3D());
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 12, vBoxes, sizeof(__VertexColor)); // 박스 그리기..
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxAxis.toD3D());
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 3, vAxis, sizeof(__VertexColor)); // 축 그리기..

	if(dwZ) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	if(dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if(dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);

	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		pChild->Render(pMtxParent, fUnitSize);
	}
}
#endif // end of _N3TOOL

void CN3Joint::ChildAdd(CN3Joint *pChild)
{
	__ASSERT(pChild, "Child joint pointer is NULL!");

	for (CN3Joint* pChild2 : m_Children)
	{
		if (pChild2 == pChild)
			return;
	}

	m_Children.push_back(pChild);
	pChild->ParentSet(this);
}

void CN3Joint::ChildDelete(CN3Joint* pChild)
{
	if (pChild == nullptr)
		return;

	auto it = m_Children.begin(), itEnd = m_Children.end();
	for (; it != itEnd; )
	{
		if (*it == pChild)
		{
			it = m_Children.erase(it);
			pChild->ParentSet(nullptr);
			break;
		}
		else
		{
			it++;
		}
	}
}

void CN3Joint::ParentSet(CN3Joint* pParent)
{
	if (pParent == m_pParent)
		return;

	m_pParent = pParent;
	if (pParent != nullptr)
	{
		pParent->ChildAdd(this);
		m_iFileFormatVersion = pParent->m_iFileFormatVersion;
	}
}

void CN3Joint::NodeCount(int& nCount)
{
	nCount++;

	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		pChild->NodeCount(nCount);
	}
}

#ifdef _N3TOOL
BOOL CN3Joint::FindPointerByName(const std::string& szName, CN3Joint *&pJoint) // 이름을 넣으면 해당 노드의 포인터를 돌려준다..
{
	if(szName.empty())
	{
		pJoint = nullptr;
		return FALSE;
	}

	if(m_szName == szName) return TRUE;
	pJoint = this;
		
	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		if (pChild->FindPointerByName(szName, pJoint))
			return TRUE;
	}
	
	return FALSE;
}
#endif // end of _N3TOOL

BOOL CN3Joint::FindPointerByID(int nID, CN3Joint*& pJoint)
{
	static int stnID = 0;
	if (pJoint == nullptr)
		stnID = 0;

	pJoint = this;
	if (nID == stnID)
		return TRUE;

	stnID++;

	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		if (pChild->FindPointerByID(nID, pJoint))
			return TRUE;
	}

	return FALSE;
}

#ifdef _N3TOOL
BOOL CN3Joint::FindIndex(const std::string& szName, int &nIndex)
{
	if(szName.empty())
	{
		nIndex = -1;
		return FALSE;
	}

	if(m_szName == szName) return TRUE;
	nIndex++;
		
	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		if (pChild->FindIndex(szName, nIndex))
			return TRUE;
	}
	
	return FALSE;
}
#endif // end of _N3TOOL

void CN3Joint::Tick(float fFrm)
{
	m_KeyPos.DataGet(fFrm, m_vPos);
	m_KeyRot.DataGet(fFrm, m_qRot);
	m_KeyScale.DataGet(fFrm, m_vScale);
	m_KeyOrient.DataGet(fFrm, m_qOrient);

	CN3Joint::ReCalcMatrix();

	for (CN3Joint* pChild : m_Children)
	{
		__ASSERT(pChild, "Child joint pointer is NULL!");
		pChild->Tick(fFrm);
	}
}

bool CN3Joint::TickAnimationKey(float fFrm)
{
	bool bNeedReCalcMatrix = CN3Transform::TickAnimationKey(fFrm);
	if(m_KeyOrient.DataGet(fFrm, m_qOrient)) bNeedReCalcMatrix = true;

	return bNeedReCalcMatrix;
}

void CN3Joint::ReCalcMatrix()
{
	__Matrix44 mtx;
//	원래 행렬 계산 코드...
//	m_Matrix.Identity();
//	mtx.Rotation(m_vRot.x, m_vRot.y, m_vRot.z); m_Matrix *= mtx; // 부모 축 만큼 회전.
//	mtx.Scale(m_vScale); m_Matrix *= mtx; // 부모 축 만큼 회전.
//	mtx.Rotation(m_vOrigin.x, m_vOrigin.y, m_vOrigin.z); m_Matrix *= mtx; // 부모 로컬 축 만큼 회전.
//	mtx.Identity(); mtx.PosSet(m_vPos); m_Matrix *= mtx; // 이동

//	if(m_RotSeq == ROT_SEQ_XYZ)
//	{
//		m_Matrix.Rotation(m_vRot.x, m_vRot.y, m_vRot.z); // 부모 축 만큼 회전. // XYZ 회전일때..
//	}
//	else if(ROT_SEQ_YXZ)
//	{
//		m_Matrix.Identity();
//		mtx.RotationY(m_vRot.y); m_Matrix *= mtx; // YXZ 회전일때
//		mtx.RotationX(m_vRot.x); m_Matrix *= mtx;
//		mtx.RotationZ(m_vRot.z); m_Matrix *= mtx;
//	}

	if (m_KeyOrient.Count() > 0) // Orient 키값이 있으면..
		m_Matrix = m_qRot * m_qOrient; // 회전.. 쿼터니언 계산..
	else
		m_Matrix = m_qRot; // 회전.. 쿼터니언 계산..

	if(1.0f != m_vScale.x || 1.0f != m_vScale.y || 1.0f != m_vScale.z) // 스케일 값이 있으면..
	{
		mtx.Scale(m_vScale); // 스케일
		m_Matrix *= mtx;
	}
	m_Matrix.PosSet(m_vPos);

	if(m_pParent) m_Matrix *= m_pParent->m_Matrix; // 부모 행렬
}

void CN3Joint::MatricesGet(__Matrix44* pMtxs, int& nJointIndex)
{
	memcpy(&pMtxs[nJointIndex], &m_Matrix, sizeof(__Matrix44));
	nJointIndex++;

	for (CN3Joint* pChild : m_Children)
		pChild->MatricesGet(pMtxs, nJointIndex);
}

void CN3Joint::ReCalcMatrixBlended(float fFrm0, float fFrm1, float fWeight0)
{
//	__ASSERT(1.0f == (fWeight0 + fWeight1));

	static __Vector3 v1, v2;
	static __Quaternion qt1, qt2;
	int nKC = 0, nFrm0 = (int)fFrm0, nFrm1 = (int)fFrm1;
	float fWeight1 = 1.0f - fWeight0;

	bool bHaveKey1 = m_KeyPos.DataGet(fFrm0, v1);
	bool bHaveKey2 = m_KeyPos.DataGet(fFrm1, v2);
	if(bHaveKey1 && bHaveKey2) 
		m_vPos = (v1 * fWeight0) + (v2 * fWeight1);

	bHaveKey1 = m_KeyRot.DataGet(fFrm0, qt1);
	bHaveKey2 = m_KeyRot.DataGet(fFrm1, qt2);
	if(bHaveKey1 && bHaveKey2) 
		m_qRot.Slerp(qt1, qt2, fWeight1);

	bHaveKey1 = m_KeyScale.DataGet(fFrm0, v1);
	bHaveKey2 = m_KeyScale.DataGet(fFrm1, v2);
	if(bHaveKey1 && bHaveKey2) 
		m_vScale = (v1 * fWeight0) + (v2 * fWeight1);

	bHaveKey1 = m_KeyOrient.DataGet(fFrm0, qt1);
	bHaveKey2 = m_KeyOrient.DataGet(fFrm1, qt2);
	if(bHaveKey1 && bHaveKey2) 
		m_qOrient.Slerp(qt1, qt2, fWeight1);

	this->ReCalcMatrix(); // Matrix 계산...
}

#ifdef _N3TOOL
void CN3Joint::KeyDelete(CN3Joint *pJoint, int nKS, int nKE)
{
	CN3AnimKey* pAKs[3] = { &(pJoint->m_KeyPos), &(pJoint->m_KeyRot), &(pJoint->m_KeyScale) };

	int i;
	for(i = 0; i < 3; i++)
	{
		int nKC = pAKs[i]->Count();
		if(nKC > 0 && nKS > 0 && nKS < nKC && nKE > nKS && nKE < nKC)
		{
			int nKE2 = nKC - nKE - 1;

			__Vector3* pVs1 = new __Vector3[nKS];
			__Vector3* pVs2 = new __Vector3[nKE2];

			if(pAKs[i]->Type() == KEY_VECTOR3) 
			{
				memcpy(pVs1, &(((__Vector3*)pAKs[i]->m_pDatas)[0]), sizeof(__Vector3) * nKS);
				memcpy(pVs2, &(((__Vector3*)pAKs[i]->m_pDatas)[nKE+1]), sizeof(__Vector3) * nKE2);
			}
			else if(pAKs[i]->Type() == KEY_QUATERNION)
			{
				memcpy(pVs1, &(((__Quaternion*)pAKs[i]->m_pDatas)[0]), sizeof(__Quaternion) * nKS);
				memcpy(pVs2, &(((__Quaternion*)pAKs[i]->m_pDatas)[nKE+1]), sizeof(__Quaternion) * nKE2);
			}

			delete [] pAKs[i]->m_pDatas;
			pAKs[i]->m_nCount = 0;
			pAKs[i]->m_pDatas = nullptr;

			pAKs[i]->Alloc(nKS + nKE2, pAKs[i]->SamplingRate(), pAKs[i]->Type());

			if(pAKs[i]->Type() == KEY_VECTOR3) 
			{
				memcpy(&(((__Vector3*)pAKs[i]->m_pDatas)[0]), pVs1, sizeof(__Vector3) * nKS);
				memcpy(&(((__Vector3*)pAKs[i]->m_pDatas)[nKS]), pVs2, sizeof(__Vector3) * nKE2);
			}
			else if(pAKs[i]->Type() == KEY_QUATERNION)
			{
				memcpy(&(((__Quaternion*)pAKs[i]->m_pDatas)[0]), pVs1, sizeof(__Quaternion) * nKS);
				memcpy(&(((__Quaternion*)pAKs[i]->m_pDatas)[nKS]), pVs2, sizeof(__Quaternion) * nKE2);
			}

			delete [] pVs1;
			delete [] pVs2;
		}
	}

	// Child 를 다시 만들어 준다.
	int nCC = pJoint->ChildCount();
	for(i = 0; i < nCC; i++)
	{
		CN3Joint* pChild = pJoint->Child(i);
		pChild->KeyDelete(pChild, nKS, nKE); // 하위 조인트를 복사..
	}
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3Joint::AddKey(CN3Joint* pJSrc, int nIndexS, int nIndexE)
{
	m_KeyPos.Add(pJSrc->m_KeyPos, nIndexS, nIndexE);
	m_KeyRot.Add(pJSrc->m_KeyRot, nIndexS, nIndexE);
	m_KeyScale.Add(pJSrc->m_KeyScale, nIndexS, nIndexE);

	auto it = pJSrc->m_Children.begin();
	auto it2 = m_Children.begin();
	size_t srcSize = pJSrc->m_Children.size();
	size_t destSize = m_Children.size();
	__ASSERT(srcSize == destSize, "can't copy animation key - because child count is different from each other.");
	for (size_t i = 0; i < srcSize; i++, it++, it2++)
	{
		CN3Joint* pChildSrc = *it;
		CN3Joint* pChildDest = *it2;

		pChildDest->AddKey(pChildSrc, nIndexS, nIndexE); // 재귀호출
	}
}
#endif // end of _N3TOOL

// 회전값등을
#ifdef _N3TOOL
void CN3Joint::CopyExceptAnimationKey(CN3Joint *pJSrc)
{
	this->Release();

	m_szName = pJSrc->m_szName;
	m_szFileName = pJSrc->m_szFileName;

	m_vPos = pJSrc->m_vPos;
	m_qRot = pJSrc->m_qRot;
	m_vScale = pJSrc->m_vScale;

	m_Matrix = pJSrc->m_Matrix;
	m_fFrmCur = pJSrc->m_fFrmCur;
	m_fFrmWhole = pJSrc->m_fFrmWhole;

	if(m_KeyPos.Count() <= 0) m_KeyPos.m_eType = pJSrc->m_KeyPos.m_eType;
	if(m_KeyRot.Count() <= 0) m_KeyRot.m_eType = pJSrc->m_KeyRot.m_eType;
	if(m_KeyScale.Count() <= 0) m_KeyScale.m_eType = pJSrc->m_KeyScale.m_eType;

	CN3Joint* pChild = nullptr;
	it_Joint it = m_Children.begin(), itEnd = m_Children.end();
	for(; it != itEnd; )
	{
		pChild = *it;
		delete pChild;
		it = m_Children.erase(it);
	}
	m_Children.clear();

	it = pJSrc->m_Children.begin();
	itEnd = pJSrc->m_Children.end();
	for(; it != itEnd; it++)
	{
		CN3Joint* pChildDest = new CN3Joint();
		this->ChildAdd(pChildDest); // 자식 추가..

		CN3Joint* pChildSrc = *it;
		pChildDest->CopyExceptAnimationKey(pChildSrc); // 재귀호출
	}
}
#endif // end of _N3TOOL

// ===== END N3Base/N3Joint.cpp =====

// ===== BEGIN N3Base/N3Joint.h =====
#line 1 "N3Base/N3Joint.h"
﻿// N3Joint.h: interface for the CN3Joint class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3IJoint_h__INCLUDED_)
#define AFX_N3IJoint_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

#include "N3Transform.h"

#include <list>
class CN3Joint;
typedef std::list<CN3Joint*>::iterator	it_Joint;

const int MAX_JOINT_TRANSFORM = 64;

class CN3Joint : public CN3Transform
{
	friend class CN3Joint; // Position, Rotation, Scale 값들을 자유롭게 다룰수 있어야 한다..
public:
	__Quaternion			m_qOrient;		// Joint Orient Quaternion
	CN3AnimKey				m_KeyOrient;	// Joint Orient 키값... nullptr 이면 없는거다..

protected:
	CN3Joint*				m_pParent;
	std::list<CN3Joint*>	m_Children;

public:
	void ChildDelete(CN3Joint* pChild);
#ifdef _N3TOOL
	void CopyExceptAnimationKey(CN3Joint* pJSrc);
	void AddKey(CN3Joint* pJSrc, int nIndexS, int nIndexE);
	void KeyDelete(CN3Joint* pJoint, int nKS, int nKE);
#endif // end of _N3TOOL

	void MatricesGet(__Matrix44 *pMtxs, int& nJointIndex);
	
	void Tick(float fFrm) override;
	bool TickAnimationKey(float fFrm) override;
	void ReCalcMatrix() override;
	void ReCalcMatrixBlended(float fFrm0, float fFrm1, float fWeight0);
	void ParentSet(CN3Joint* pParent);
	void ChildAdd(CN3Joint* pChild);

	CN3Joint* Parent()
	{
		return m_pParent;
	}

	int ChildCount() const
	{
		return static_cast<int>(m_Children.size());
	}

	CN3Joint* Child(int index)
	{
		if (index < 0
			|| index >= static_cast<int>(m_Children.size()))
			return nullptr;

		auto it = m_Children.begin();
		std::advance(it, index);
		return *it;
	}

	void NodeCount(int& nCount);
	BOOL FindPointerByID(int nID, CN3Joint *&pJoint);
#ifdef _N3TOOL
	BOOL FindIndex(const std::string& szName, int& nIndex);
	BOOL FindPointerByName(const std::string& szName, CN3Joint*& pJoint); // 이름을 넣으면 해당 노드의 포인터를 돌려준다..
	void RotSet(const __Quaternion& qtRot) { m_qRot = qtRot; this->ReCalcMatrix(); }
	void RotSet(float x, float y, float z, float w) { m_qRot.x = x; m_qRot.y = y; m_qRot.z = z; m_qRot.w = w; this->ReCalcMatrix(); }
	void Render(const __Matrix44* pMtxParent = nullptr, float fUnitSize = 0.1f);
#endif // end of _N3TOOL

	void Release() override;
	bool Load(File& file) override;
#ifdef _N3TOOL
	bool Save(File& file) override;
#endif // end of _N3TOOL

	CN3Joint();
	~CN3Joint() override;
};

#endif // !defined(AFX_N3IJoint_h__INCLUDED_)

// ===== END N3Base/N3Joint.h =====

// ===== BEGIN N3Base/N3Light.cpp =====
#line 1 "N3Base/N3Light.cpp"
﻿// N3Light.cpp: implementation of the CN3Light class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Light.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Light::CN3Light()
{
	m_dwType |= OBJ_LIGHT;
	memset(&m_Data, 0, sizeof(m_Data));
}

CN3Light::~CN3Light()
{
}

void CN3Light::Release()
{
	memset(&m_Data, 0, sizeof(m_Data));
	CN3Transform::Release();
}

bool CN3Light::Load(File& file)
{
	CN3Transform::Load(file);

	file.Read(&m_Data, sizeof(m_Data)); // 라이트 세팅.

	__ASSERT(m_Data.nNumber >= 0 && m_Data.nNumber < 8, "Light Loading Warning - Light 번호가 범위를 벗어났습니다.");
	
	return true;
}

#ifdef _N3TOOL
bool CN3Light::Save(File& file)
{
	CN3Transform::Save(file);

	file.Write(&m_Data, sizeof(m_Data)); // 라이트 세팅.

	return true;
}
#endif // end of _N3TOOL

void CN3Light::Tick(float fFrm)
{
	CN3Transform::Tick(fFrm);

	m_Data.Position = m_vPos;
}

void CN3Light::Apply()
{
	__ASSERT(m_Data.nNumber >= 0 && m_Data.nNumber < 8, "Invalid Light Number");
	s_lpD3DDev->LightEnable(m_Data.nNumber, m_Data.bOn);
	if (m_Data.bOn)
	{
		if (m_Data.Type == D3DLIGHT_POINT
			|| m_Data.Type == D3DLIGHT_DIRECTIONAL
			|| m_Data.Type == D3DLIGHT_SPOT)
			s_lpD3DDev->SetLight(m_Data.nNumber, m_Data.toD3D());
	}
}

// ===== END N3Base/N3Light.cpp =====

// ===== BEGIN N3Base/N3Light.h =====
#line 1 "N3Base/N3Light.h"
﻿// N3Light.h: interface for the CN3Light class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3ILight_h__INCLUDED_)
#define AFX_N3ILight_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Transform.h"

class CN3Light : public CN3Transform
{
public:
	struct __Light : public __D3DLight9
	{
	public:

		BOOL		bOn; // 라이트가 켜져 있는지..
		int			nNumber; // 0 ~ 8
		
		void		Zero()
		{
			*this = {};
		}

		void InitPoint(int nLgtNumber, const __Vector3& dvPos, const __ColorValue& ltColor, float fRange = 10000.0f, float fAttenuation = 0.5f)
		{
			Zero();

			nNumber = nLgtNumber; // 라이트 번호..
			Type = D3DLIGHT_POINT;
			Position = dvPos;
			//Specular = 
			Diffuse = ltColor;
			Ambient.r = ltColor.r * 0.7f;
			Ambient.g = ltColor.g * 0.7f;
			Ambient.b = ltColor.b * 0.7f;

			Falloff = 1.0f;		// 효과가 미미하고 부하기 걸리기 때문에 보통 1.0으로 쓴다.
			if (fRange < 0.0001f) fRange = 0.0001f;
			Attenuation0 = 1.0f - fAttenuation;
			Attenuation1 = fAttenuation / fRange; // 감쇠 범위계산. 범위의 절반이 정확하게 절반의 감쇠가 되도록 한다..
			Attenuation2 = fAttenuation / (fRange * fRange);
			Range = fRange * 4.0f;
			bOn = TRUE;
		}

		void InitDirection(int nLgtNumber, const __Vector3& dvDir, const __ColorValue& ltColor)
		{
			Zero();

			nNumber = nLgtNumber; // 라이트 번호..
			bOn = TRUE;

			Type = D3DLIGHT_DIRECTIONAL;
			Direction = dvDir;

			//Specular = 
			Diffuse = ltColor;
			Ambient.r = ltColor.r * 0.7f;
			Ambient.g = ltColor.g * 0.7f;
			Ambient.b = ltColor.b * 0.7f;
		}

		void InitSpot(int nLgtNumber, const __Vector3& dvPos, const __Vector3& dvDir, const __ColorValue& ltColor, float fTheta, float fPhi, float fRange = 10000.0f)
		{
			Zero();

			nNumber = nLgtNumber; // 라이트 번호..
			Type = D3DLIGHT_SPOT;
			Position = dvPos;
			Direction = dvDir;

			Diffuse = ltColor;
			Ambient.r = ltColor.r * 0.7f;
			Ambient.g = ltColor.g * 0.7f;
			Ambient.b = ltColor.b * 0.7f;

			if (fRange < 0.0001f)
				fRange = 0.0001f;

			Attenuation0 = 1.0f;
			Attenuation1 = 1.0f / (fRange / 2.0f); // 감쇠 범위계산. 범위의 절반이 정확하게 절반의 감쇠가 되도록 한다..
			Range = fRange;

			Falloff = 1.0f;		// 효과가 미미하고 부하기 걸리기 때문에 보통 1.0으로 쓴다.
			Theta = fTheta;
			Phi = fPhi;
			bOn = TRUE;
		}
	};

	__Light m_Data;

public:
	void DirSet(const __Vector3& vDir)
	{
		DirSet(vDir.x, vDir.y, vDir.z);
	}

	void DirSet(float fx, float fy, float fz)
	{
		m_Data.Direction = { fx, fy, fz };
	}

	void PosSet(const __Vector3& vPos)
	{
		PosSet(vPos.x, vPos.y, vPos.z);
	}

	void PosSet(float fx, float fy, float fz)
	{
		m_Data.Position = m_vPos = { fx, fy, fz };
	}

	void		Apply(); // 세팅된 라이트값을 실제 D3DDevice 에 적용
	void		Tick(float fFrm = FRAME_SELFPLAY); // 라이트값만 세팅한다..
	
	bool		Load(File& file) override;
#ifdef _N3TOOL
	bool		Save(File& file) override;
#endif // end of _N3TOOL

	void		Release() override;
	CN3Light();
	~CN3Light() override;
};

#endif // !defined(AFX_N3ILight_h__INCLUDED_)

// ===== END N3Base/N3Light.h =====

// ===== BEGIN N3Base/N3Mesh.cpp =====
#line 1 "N3Base/N3Mesh.cpp"
﻿// N3Mesh.cpp: implementation of the C3DObject class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Mesh.h"
#include "N3IMesh.h"
#include "N3PMesh.h"
#include "N3PMeshInstance.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Mesh::CN3Mesh()
{
	m_dwType |= OBJ_MESH;

	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);

	m_nVC = 0;
	m_nIC = 0;

	m_pVertices = nullptr; // 점 버퍼
	m_psnIndices = nullptr; // 인덱스 버퍼
}

CN3Mesh::~CN3Mesh()
{
	delete [] m_pVertices; m_pVertices = nullptr;
	delete [] m_psnIndices; m_psnIndices = nullptr;
}

void CN3Mesh::Release()
{
	this->ReleaseVertices();
	this->ReleaseIndices();

	CN3BaseFileAccess::Release();
}

void CN3Mesh::ReleaseVertices()
{
	delete [] m_pVertices; m_pVertices = nullptr;
	
	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);

	m_nVC = 0;
}

void CN3Mesh::ReleaseIndices()
{
	delete [] m_psnIndices; m_psnIndices = nullptr;
	m_nIC = 0;
}

bool CN3Mesh::Load(File& file)
{
	if (m_pVertices != nullptr
		|| m_psnIndices != nullptr)
		Release();

	file.Read(&m_nVC, 4); // 점갯수 읽기..

	if (m_nVC > 0)
	{
		Create(m_nVC, 0); // Vertex Buffer 생성 및 데이터 채우기
		file.Read(m_pVertices, m_nVC * sizeof(__VertexT1));
		FindMinMax(); // 최대, 최소값을 찾는다.
	}

	file.Read(&m_nIC, 4); // 인덱스 갯수 읽기..
	if (m_nIC > 0)
	{
		Create(0, m_nIC); // 인덱스 버퍼 생성 및 데이터 채우기
		file.Read(m_psnIndices, m_nIC * 2);
	}

	return true;
}

#ifdef _N3TOOL
bool CN3Mesh::Save(File& file)
{
	file.Write(&m_nVC, 4); // 점갯수 읽기..
	if (m_nVC > 0)
		file.Write(m_pVertices, m_nVC * sizeof(__VertexT1));

	file.Write(&m_nIC, 4); // 인덱스 갯수 읽기..
	if (m_nIC > 0)
		file.Write(m_psnIndices, m_nIC * 2);

	return true;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3Mesh::MakeIndexed()
{
	if(m_nVC <= 0 || m_nIC > 0) return;

	int nIs[100000]; memset(nIs, -1, sizeof(nIs));

	__VertexT1* pVs = new __VertexT1[m_nVC]; memcpy(pVs, m_pVertices, sizeof(__VertexT1) * m_nVC);
	int nICount = 0, nVCount = 0;
	int i;
	for(i = 0; i < m_nVC; i++)
	{
		BOOL bAccord = FALSE;
		int j;
		for(j = 0; j < nVCount; j++)
		{
			if(	m_pVertices[i].x == pVs[j].x && 
				m_pVertices[i].y == pVs[j].y && 
				m_pVertices[i].z == pVs[j].z && 
//				m_pVertices[i].nx == pVs[j].nx && 
//				m_pVertices[i].ny == pVs[j].ny && 
//				m_pVertices[i].nz == pVs[j].nz && 
				m_pVertices[i].tu == pVs[j].tu && 
				m_pVertices[i].tv == pVs[j].tv )
			{
				bAccord = TRUE;
				break;
			}
		}

		if(TRUE == bAccord)
		{
			nIs[i] = j;
		}
		else
		{
			nIs[i] = nVCount;
			pVs[nVCount] = m_pVertices[i];
			nVCount++;
		}
	}

	this->Create(nVCount, m_nVC);
	memcpy(m_pVertices, pVs, sizeof(__VertexT1)*nVCount);
	for(i = 0 ; i < m_nIC; i++)
		m_psnIndices[i] = nIs[i];

	delete [] pVs; pVs = nullptr;
}
#endif // end of _N3TOOL

void CN3Mesh::Create(int nVC, int nIC)
{
	if(nVC > 0) // 점이 있으면...
	{
#ifdef _N3GAME
		if (nVC > 32768)
			CLogWriter::Write("CN3Mesh::Create - Too many vertices. (more than 32768) ({})", m_szFileName);
#endif
		if(m_pVertices) this->ReleaseVertices();
		m_pVertices = new __VertexT1[nVC]; memset(m_pVertices, 0, nVC * sizeof(__VertexT1)); // Vertex Buffer 생성
		m_nVC = nVC;
	}

	if(nIC > 0) // Mesh 로딩에 성공하고, 인덱스가 있으면..
	{
#ifdef _N3GAME
		if (nIC > 32768)
			CLogWriter::Write("CN3Mesh::Create - Too many indices. (more than 32768) ({})", m_szFileName);
#endif
		if(m_psnIndices) this->ReleaseIndices();
		m_psnIndices = new uint16_t[nIC]; memset(m_psnIndices, 0, nIC * 2); // Index Buffer 생성
		m_nIC = nIC;
	}
}

void CN3Mesh::FindMinMax()
{
	m_vMin.Zero();
	m_vMax.Zero();

	if(m_nVC <= 0) return;

	// 최소, 최대 점을 찾는다.
	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	
	for(int i = 0; i < m_nVC; i++)
	{
		if(m_pVertices[i].x < m_vMin.x) m_vMin.x = m_pVertices[i].x;
		if(m_pVertices[i].y < m_vMin.y) m_vMin.y = m_pVertices[i].y;
		if(m_pVertices[i].z < m_vMin.z) m_vMin.z = m_pVertices[i].z;

		if(m_pVertices[i].x > m_vMax.x) m_vMax.x = m_pVertices[i].x;
		if(m_pVertices[i].y > m_vMax.y) m_vMax.y = m_pVertices[i].y;
		if(m_pVertices[i].z > m_vMax.z) m_vMax.z = m_pVertices[i].z;
	}
}

void CN3Mesh::Create_Cube(const __Vector3& vMin, const __Vector3& vMax)
{
	this->Create(36, 0);

	__Vector3 vPs[6];
	__Vector3 vN;
	float fTUVs[6][2] = { 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1 };

	int i = 0;

	// z 축 음의 면
	vN.Set(0,0,-1);
	vPs[0].Set(vMin.x, vMax.y, vMin.z); vPs[1].Set(vMax.x, vMax.y, vMin.z); vPs[2].Set(vMax.x, vMin.y, vMin.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMin.x, vMin.y, vMin.z);
	for(i = 0; i < 6; i++) m_pVertices[0+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	// x 축 양의 면
	vN.Set(1, 0, 0);
	vPs[0].Set(vMax.x, vMax.y, vMin.z); vPs[1].Set(vMax.x, vMax.y, vMax.z); vPs[2].Set(vMax.x, vMin.y, vMax.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMax.x, vMin.y, vMin.z);
	for(i = 0; i < 6; i++) m_pVertices[6+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	// z 축 양의 면
	vN.Set(0, 0, 1);
	vPs[0].Set(vMax.x, vMax.y, vMax.z); vPs[1].Set(vMin.x, vMax.y, vMax.z); vPs[2].Set(vMin.x, vMin.y, vMax.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMax.x, vMin.y, vMax.z);
	for(i = 0; i < 6; i++) m_pVertices[12+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	// x 축 음의 면
	vN.Set(-1, 0, 0);
	vPs[0].Set(vMin.x, vMax.y, vMax.z); vPs[1].Set(vMin.x, vMax.y, vMin.z); vPs[2].Set(vMin.x, vMin.y, vMin.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMin.x, vMin.y, vMax.z);
	for(i = 0; i < 6; i++) m_pVertices[18+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	// y 축 양의 면
	vN.Set(0, 1, 0);
	vPs[0].Set(vMin.x, vMax.y, vMax.z); vPs[1].Set(vMax.x, vMax.y, vMax.z); vPs[2].Set(vMax.x, vMax.y, vMin.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMin.x, vMax.y, vMin.z);
	for(i = 0; i < 6; i++) m_pVertices[24+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	// y 축 음의 면
	vN.Set(0, -1, 0);
	vPs[0].Set(vMin.x, vMin.y, vMin.z); vPs[1].Set(vMax.x, vMin.y, vMin.z); vPs[2].Set(vMax.x, vMin.y, vMax.z);
	vPs[3] = vPs[0]; vPs[4] = vPs[2]; vPs[5].Set(vMin.x, vMin.y, vMax.z);
	for(i = 0; i < 6; i++) m_pVertices[30+i].Set(vPs[i], vN, fTUVs[i][0], fTUVs[i][1]);

	this->FindMinMax();
}

#ifdef _N3TOOL
void CN3Mesh::Create_Axis(float fLength)
{
	this->Create(12, 0);

	this->FindMinMax();

	// x 축
//	m_pVertices[0].Set(-fLength/2.0f, 0, 0, 0, 1, 0, 0, 0);
//	m_pVertices[1].Set( fLength/2.0f, 0, 0, 0, 1, 0, 0, 0);
//	m_pVertices[2] = m_pVertices[1];
//	m_pVertices[3] = m_pVertices[1];
//	m_pVertices[3].x -= fLength / 20.0f; 
//	m_pVertices[3].y += fLength / 20.0f;

	m_pVertices[0].Set(0, 0, 0, 0, 1, 0, 0, 0);
	m_pVertices[1].Set(fLength, 0, 0, 0, 1, 0, 0, 0);
	m_pVertices[2] = m_pVertices[1];
	m_pVertices[3] = m_pVertices[1];
	m_pVertices[3].x -= fLength / 10.0f; 
	m_pVertices[3].y += fLength / 10.0f;

	__Matrix44 mtx;
	
	// y 축
	mtx.RotationZ(__PI / -2.0f);
	int i;
	for(i = 0; i < 4; i++) 
	{
		m_pVertices[4+i].Set(m_pVertices[i] * mtx, m_pVertices[i].n * mtx, 0, 0);
	}

	// z 축
	mtx.RotationY(__PI / -2.0f);
	for(i = 0; i < 4; i++) 
	{
		m_pVertices[8+i].Set(m_pVertices[i] * mtx, m_pVertices[i].n * mtx, 0, 0);
	}
}
#endif // end of _N3TOOL

bool CN3Mesh::Import(CN3PMesh* pPMesh)
{
	if(nullptr == pPMesh) return false;
	int iNumIndices = pPMesh->GetMaxNumIndices();
	if (0 >= iNumIndices) return false;
	Release();	// 초기화

	// pmesh instance를 만들고 lod를 최고 상태로 조정
	CN3PMeshInstance PMeshInstance;
	PMeshInstance.Create(pPMesh);
	PMeshInstance.SetLODByNumVertices(pPMesh->GetMaxNumVertices());

	// vertex, index buffer 만들기
	Create(PMeshInstance.GetNumVertices(), PMeshInstance.GetNumIndices());

	// vertex index buffer 복사
	__VertexT1* pVertices = PMeshInstance.GetVertices();
	uint16_t* pIndices = PMeshInstance.GetIndices();
	memcpy(m_pVertices, pVertices, sizeof(__VertexT1)*m_nVC);
	memcpy(m_psnIndices, pIndices, sizeof(uint16_t)*m_nIC);

	m_szName = pPMesh->m_szName; // 이름..
	return true;
}

#ifdef _N3TOOL
bool CN3Mesh::Import(CN3IMesh *pIMesh)
{
	if(nullptr == pIMesh) return false;
	__VertexT1* pvSrc = pIMesh->BuildVertexList();
	if(nullptr == pvSrc) return false;
	
	int nFC = pIMesh->FaceCount();
	this->Release();
	this->Create(nFC * 3, 0);

	memcpy(m_pVertices, pvSrc, sizeof(__VertexT1) * nFC * 3);

	__Vector3 v0, v1, v2, vN(0,0,0);
	for(int i = 0; i < nFC; i++) // Normal 값 다시 세팅..
	{
		v0 = m_pVertices[i*3+0];
		v1 = m_pVertices[i*3+1];
		v2 = m_pVertices[i*3+2];

		vN.Cross(v1 - v0, v2 - v1); // Normal 값을 계산하고...
		vN.Normalize();

		m_pVertices[i*3+0].n = vN;
		m_pVertices[i*3+1].n = vN;
		m_pVertices[i*3+2].n = vN;
	}

	m_szName = pIMesh->m_szName; // 이름..
	return true;
}

void CN3Mesh::ReGenerateSmoothNormal()
{
	if(m_nVC <= 0) return;

	int* pnNs = new int[m_nVC];
	memset(pnNs, 0, 4 * m_nVC);
	__Vector3* pvNs = new __Vector3[m_nVC];
	memset(pvNs, 0, sizeof(__Vector3)*m_nVC);

	int nFC = 0;
	if(m_nIC > 0) nFC = m_nIC / 3;
	else nFC = m_nVC / 3;

	__Vector3 v0, v1, v2, vN(0,0,0);
	for(int i = 0; i < m_nVC; i++)
	{
		for(int j = 0; j < nFC; j++)
		{
			if(m_nIC > 0)
			{
				v0 = m_pVertices[m_psnIndices[j*3+0]];
				v1 = m_pVertices[m_psnIndices[j*3+1]];
				v2 = m_pVertices[m_psnIndices[j*3+2]];
			}
			else
			{
				v0 = m_pVertices[j*3+0];
				v1 = m_pVertices[j*3+1];
				v2 = m_pVertices[j*3+2];
			}

			if(	m_pVertices[i] == v0 ||
				m_pVertices[i] == v1 ||
				m_pVertices[i] == v2 )
			{
				vN.Cross(v1 - v0, v2 - v1); // Normal 값을 계산하고...
				vN.Normalize();

				pnNs[i]++;
				pvNs[i] += vN;
			}
		}

		m_pVertices[i].n = pvNs[i] / (float)pnNs[i];
	}

	delete [] pnNs;
	delete [] pvNs;

}
#endif // end of _N3TOOL

// ===== END N3Base/N3Mesh.cpp =====

// ===== BEGIN N3Base/N3Mesh.h =====
#line 1 "N3Base/N3Mesh.h"
﻿// N3MeshNormal.h: interface for the C3DObject class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Mesh_h__INCLUDED_)
#define AFX_N3Mesh_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"

class CN3IMesh;
class CN3PMesh;

class CN3Mesh : public CN3BaseFileAccess
{
protected:
	__VertexT1*	m_pVertices; // 점 버퍼
	uint16_t*		m_psnIndices; // 인덱스 버퍼

	int		m_nVC; // 점 갯수
	int		m_nIC; // 점 갯수
	__Vector3 m_vMin, m_vMax;

public:
	__Vector3 Min() { return m_vMin; }
	__Vector3 Max() { return m_vMax; }
	void	FindMinMax();
	
	int			VertexCount() { return m_nVC; }
	__VertexT1*	Vertices() { return m_pVertices; }
	int			IndexCount() { return m_nIC; }
	uint16_t*	Indices() { return m_psnIndices; } // 인덱스 버퍼

	bool	Load(File& file) override;

	void	Create(int nVC, int nIC);
	void	Create_Cube(const __Vector3& vMin, const __Vector3& vMax);

	bool	Import(CN3PMesh* pPMesh);

#ifdef _N3TOOL
	bool	Import(CN3IMesh* pIMesh);	
	bool	Save(File& file) override;
	void	Create_Axis(float fLength);
	void	MakeIndexed();
	void	ReGenerateSmoothNormal();
#endif // end of _N3TOOL
	
	void	Release() override;
	void	ReleaseVertices();
	void	ReleaseIndices();

	CN3Mesh();
	virtual ~CN3Mesh();
};

#endif // !defined(AFX_N3Mesh_h__INCLUDED_)

// ===== END N3Base/N3Mesh.h =====

// ===== BEGIN N3Base/N3Mng.h =====
#line 1 "N3Base/N3Mng.h"
﻿// N3Mng.h: interface for the CN3Mng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Mng_h__INCLUDED_)
#define AFX_N3Mng_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _N3GAME
#include "LogWriter.h"
#endif

#include <string>
#include <map>

template <class T> class CN3Mng
{
protected:
	
	typedef typename std::map<std::string, T*>::iterator		it_Data;
	typedef typename std::map<std::string, T*>::value_type	val_Data;

	typedef typename std::map<T*, int>::iterator				it_Ref;
	typedef typename std::map<T*, int>::value_type			val_Ref;

	typename std::map<std::string, T*>	m_Datas;
	typename std::map<T*, int>			m_Refs;

public:
	int Count() const
	{
		return static_cast<int>(m_Datas.size());
	}

	int Add(T* pData)
	{
		if(nullptr == pData)
		{ 
#ifdef _N3GAME
			CLogWriter::Write("CN3Mng::Add - Null object pointer");
#endif
			return -1;
		}
		if(pData->FileName().empty())
		{
#ifdef _N3GAME
			CLogWriter::Write("CN3Mng::Add - Null object file name");
#endif
			return -1;
		}

		std::pair<it_Ref, bool> pairRef = m_Refs.insert(val_Ref(pData, 1));
		if(false == pairRef.second)
		{
#ifdef _N3GAME
			CLogWriter::Write("CN3Mng::Add - Duplicated object pointer");
#endif
			return -1;
		}

		std::pair<it_Data, bool> pairData = m_Datas.insert(val_Data(pData->FileName(), pData));
		if(false == pairData.second)
		{
#ifdef _N3GAME
			CLogWriter::Write("CN3Mng::Add - duplicated object's file name.");
#endif
			m_Refs.erase(pairRef.first); // 참조 카운트 지우고..
			return -1;
		}

		return static_cast<int>(m_Datas.size()) - 1;
	}

	T* 	Get(int index, bool bIncreaseRefCount = TRUE)
	{
		if (index < 0
			|| index >= static_cast<int>(m_Datas.size()))
			return nullptr;

		if(bIncreaseRefCount)
		{
			it_Ref it = m_Refs.begin();
			for(int i = 0; i < index; i++, it++);
			it->second++;
		}

		it_Data it = m_Datas.begin();
		for(int i = 0; i < index; i++, it++);

		return it->second;
	}

	T* 	Get(const std::string& szFN, bool bIncreaseRefCount = TRUE, int iLOD = 0)
	{
		if(szFN.empty()) return nullptr;
		std::string szFN2 = szFN;
		CharLower(&(szFN2[0]));

		T* pData = nullptr;
		it_Data it = m_Datas.find(szFN2);
		if(it == m_Datas.end()) // 못 찾았다..
		{
			pData = new T();
			pData->m_iLOD = iLOD; // 로딩시 LOD 적용

			if(false == pData->LoadFromFile(szFN2)) // 파일 읽기에 실패했다!!
			{
				delete pData;
				pData = nullptr;
			}
			else 
			{
				int reChk = Add(pData); // 읽기 성공하면 추가..
				//	asm
				if(reChk==-1)	//	추가시 전에 데이터가 있어 참조 카운트를 하나 더한다 
				{
					T* pBakData = pData;	//	같은 파일중 전 데이타를 받아 리턴(새로운 그림으로 바뀌지 않을수 있다)
					it_Data it = m_Datas.find(pBakData->FileName());
					pData = (*it).second;

					if(bIncreaseRefCount)
					{						
						it_Ref it2 = m_Refs.find(pData);
						if(it2 != m_Refs.end()) // 참조 카운트 찾기..
						{
							((*it2).second)++;
						}
					}

					delete pBakData;	//	이번에 읽은 데이타는 필요가 없으므로 지움
					pBakData = nullptr;
				}
				//	asm
			}
		}
		else //  찾았다..!!
		{
			pData = (*it).second;

			if(bIncreaseRefCount)
			{
				it_Ref it2 = m_Refs.find(pData);
				if(it2 != m_Refs.end()) // 참조 카운트 찾기..
				{
					((*it2).second)++;
				}
			}
		}

		return pData;
	}

	bool IsExist(const std::string& szFN)
	{
		if(szFN.empty()) return false;

		if(m_Datas.find(szFN) != m_Datas.end()) return true;
		else return false;
	} // 있나 없나~

	void Delete(T** ppData, bool bReleaseOrg = true)
	{
#ifndef _N3GAME
		bReleaseOrg = true; // 툴에서는 무조건 
#endif
		if(nullptr == ppData || nullptr == *ppData) return;

		it_Data it = m_Datas.find((*ppData)->FileName());
		if(it == m_Datas.end()) return; // 못 찾았다..
		else //  찾았다..!!
		{
			it_Ref it2 = m_Refs.find(*ppData);
			if(bReleaseOrg && it2 != m_Refs.end()) // 참조 카운트 찾기..
			{
				((*it2).second)--;
				if(0 == (*it2).second)
				{
					delete (*ppData);
					m_Datas.erase(it);
					m_Refs.erase(it2);
				}
			}
			*ppData = nullptr;
		}
	}

#ifdef _N3TOOL
	void SaveToFiles()
	{
		it_Data it = m_Datas.begin(), itEnd = m_Datas.end();
		for(; it != itEnd; it++) (*it).second->SaveToFile();
	}
#endif // end of _N3TOOL
	
	void Release()
	{
		it_Data it = m_Datas.begin(), itEnd = m_Datas.end();
		for(; it != itEnd; it++) delete ((*it).second);

		m_Datas.clear();
		m_Refs.clear();
	}

	CN3Mng()
	{
	}
	
	~CN3Mng()
	{
		Release();
	}

};

#endif // !defined(AFX_N3Mng_h__INCLUDED_)

// ===== END N3Base/N3Mng.h =====

// ===== BEGIN N3Base/N3Moon.cpp =====
#line 1 "N3Base/N3Moon.cpp"
﻿// N3Moon.cpp: implementation of the CN3Moon class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Moon.h"
#include "My_3DStruct.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Moon::CN3Moon()
{
	m_pTexture = nullptr;
	m_fCurRadian = __PI;
	m_iMoonPhaseIndex = 0;
}

CN3Moon::~CN3Moon()
{
	s_MngTex.Delete(&m_pTexture);
}

void CN3Moon::Release()
{
	CN3Base::Release();
	s_MngTex.Delete(&m_pTexture);
	m_fCurRadian = __PI;
	m_iMoonPhaseIndex = 0;
}

void CN3Moon::Init(const std::string& szTexFN)
{
	Release();
	m_pTexture = s_MngTex.Get(szTexFN);
	__ASSERT(m_pTexture, "Texture load failed.");

	m_fMoonRatio = 0.2f;
	const float fZ = 0.9f;
	const float fRHW = 1.0f;
	D3DCOLOR color = 0xffffffff;
	m_pVertices[0].Set( 0, 0, fZ, fRHW, color, 0.0f, 0.0f);
	m_pVertices[1].Set( 0, 0, fZ, fRHW, color, 1.0f, 0.0f);
	m_pVertices[2].Set( 0, 0, fZ, fRHW, color, 1.0f, 1.0f);
	m_pVertices[3].Set( 0, 0, fZ, fRHW, color, 0.0f, 1.0f);

	SetMoonPhase(10);
}

void CN3Moon::Render(__Matrix44& matView, __Matrix44& matProj)
{
	// 달이 그려지는 화면 좌표 계산하기 (2D로 그리는 이유는 달이 왜곡되어서 보이는것을 막기 위해)
	__Matrix44 matWorld;
	matWorld.RotationZ(m_fCurRadian);
	__Matrix44 matFinal;
	matFinal = matWorld*matView;
	matFinal *= matProj;

	__Vector3 vMoon = { 5, 0, 0 };
	__Vector4 vOut;
	vOut.Transform(vMoon, matFinal);

	int Width = s_CameraData.vp.Width;
	int Height = s_CameraData.vp.Height;
	int X = s_CameraData.vp.X;
	int Y = s_CameraData.vp.Y;
	float fRHW = 1.0f/vOut.w;
	vMoon.z = vOut.z*fRHW;
	if (vMoon.z < 0.0f || vMoon.z > 1.0f) return;		// 화면 뒤에 그려진다.
	// Mapping Screen Coordinate.
	vMoon.x = (float)X + ((vOut.x*fRHW + 1.0f)*Width*0.5f);
	vMoon.y = (float)Y + ((-vOut.y*fRHW + 1.0f)*Height*0.5f);
	
	RECT rcMoon;
	int iMoonSize = (int)(Width * m_fMoonRatio) / 2;
	SetRect(&rcMoon, (int)(vMoon.x-iMoonSize), (int)(vMoon.y-iMoonSize), (int)(vMoon.x+iMoonSize), (int)(vMoon.y+iMoonSize));
	// clipping with screen.
	if ( rcMoon.right < X|| rcMoon.bottom < Y || rcMoon.left > X+Width || rcMoon.top > Y+Height) return;	// 화면 밖에 그려진다.

	// 2D로 그리기
	m_pVertices[0].x = (float)rcMoon.left;		m_pVertices[0].y = (float)rcMoon.top;
	m_pVertices[1].x = (float)rcMoon.right;		m_pVertices[1].y = (float)rcMoon.top;
	m_pVertices[2].x = (float)rcMoon.right;		m_pVertices[2].y = (float)rcMoon.bottom;
	m_pVertices[3].x = (float)rcMoon.left;		m_pVertices[3].y = (float)rcMoon.bottom;

	if(m_pTexture) s_lpD3DDev->SetTexture(0, m_pTexture->Get());
	else s_lpD3DDev->SetTexture(0, nullptr);
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	s_lpD3DDev->SetFVF(FVF_TRANSFORMED);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN , 2, m_pVertices, sizeof(m_pVertices[0]));
}

void CN3Moon::SetMoonPhase(int iIndex)
{
	iIndex %= 24;
	m_iMoonPhaseIndex = iIndex;

	int row = iIndex/6;
	int col = iIndex%6;
	static const float fOffsetX = 1.0f/6.0f;
	static const float fOffsetY = 1.0f/4.0f;
	m_pVertices[0].tu = fOffsetX*col;		m_pVertices[0].tv = fOffsetY*(row);
	m_pVertices[1].tu = fOffsetX*(col+1);	m_pVertices[1].tv = fOffsetY*(row);	
	m_pVertices[2].tu = fOffsetX*(col+1);	m_pVertices[2].tv = fOffsetY*(row+1);
	m_pVertices[3].tu = fOffsetX*col;		m_pVertices[3].tv = fOffsetY*(row+1);
}

// ===== END N3Base/N3Moon.cpp =====

// ===== BEGIN N3Base/N3Moon.h =====
#line 1 "N3Base/N3Moon.h"
﻿// N3Moon.h: interface for the CN3Moon class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3MOON_H__A89DCBCF_C959_4D36_92C1_E138448717D9__INCLUDED_)
#define AFX_N3MOON_H__A89DCBCF_C959_4D36_92C1_E138448717D9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include <string>

class CN3Texture;
class CN3Moon : public CN3Base  
{
#ifdef _N3TOOL
	friend class CN3SkyMng;
#endif

public:
	CN3Moon();
	virtual ~CN3Moon();
// Attributes
public:
	int						GetMoonPhaseIndex() const {return m_iMoonPhaseIndex;}
protected:	
	__VertexTransformed		m_pVertices[4];
	CN3Texture				*m_pTexture;
	float					m_fCurRadian;		// 현재 달의 회전위치
	float					m_fMoonRatio;		// 달의 pixel싸이즈
	int						m_iMoonPhaseIndex;	// 달의 모양 인덱스 0~23;

// Operations
public:
	void	Init(const std::string& szTexFN);
	void	SetMoonPhase(int iIndex);	// 달의 모양 설정
	void	SetCurAngle(float fAngle)	{m_fCurRadian = DegreesToRadians(fAngle);}	// 현재 각도설정

	void	Render(__Matrix44& matView, __Matrix44& matProj);
	void	Release();
};

#endif // !defined(AFX_N3MOON_H__A89DCBCF_C959_4D36_92C1_E138448717D9__INCLUDED_)

// ===== END N3Base/N3Moon.h =====

// ===== BEGIN N3Base/N3PMesh.cpp =====
#line 1 "N3Base/N3PMesh.cpp"
﻿// N3PMesh.cpp: implementation of the CN3PMesh class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3PMesh.h"
#include "N3PMeshInstance.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3PMesh::CN3PMesh()
{
	m_dwType |= OBJ_MESH_PROGRESSIVE;

	m_pVertices = nullptr;
	m_pVertices2 = nullptr;
	m_pIndices = nullptr;
	m_pCollapses = nullptr;
	m_pAllIndexChanges = nullptr;
	m_pLODCtrlValues = nullptr;

	m_iNumCollapses = 0;
	m_iTotalIndexChanges = 0;
	m_iMaxNumVertices = 0; m_iMaxNumIndices = 0;
	m_iMinNumVertices = 0; m_iMinNumIndices = 0;
	m_iLODCtrlValueCount = 0;

	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);
	m_fRadius = 0.0f;
}

CN3PMesh::~CN3PMesh()
{
	delete [] m_pVertices; m_pVertices = nullptr;
	delete [] m_pVertices2; m_pVertices2 = nullptr;
	delete [] m_pIndices; m_pIndices = nullptr;
	delete [] m_pCollapses; m_pCollapses = nullptr;
	delete [] m_pAllIndexChanges; m_pAllIndexChanges = nullptr;
	delete [] m_pLODCtrlValues;	m_pLODCtrlValues = nullptr;
}

void CN3PMesh::Release()
{
	if (m_pVertices) { delete[] m_pVertices; m_pVertices = nullptr;}
	if (m_pVertices2) { delete[] m_pVertices2; m_pVertices2 = nullptr;}
	if (m_pIndices) { delete[] m_pIndices; m_pIndices = nullptr;}
	if (m_pCollapses) {	delete[] m_pCollapses; m_pCollapses = nullptr;}
	if (m_pAllIndexChanges)	{ delete[] m_pAllIndexChanges; m_pAllIndexChanges = nullptr;}
	if (m_pLODCtrlValues) {	delete [] m_pLODCtrlValues;	m_pLODCtrlValues = nullptr;}

	m_iNumCollapses = 0;
	m_iTotalIndexChanges = 0;
	m_iMaxNumVertices = 0; m_iMaxNumIndices = 0;
	m_iMinNumVertices = 0; m_iMinNumIndices = 0;
	m_iLODCtrlValueCount = 0;

	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);
	m_fRadius = 0.0f;

	CN3BaseFileAccess::Release();
}

bool CN3PMesh::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	file.Read(&m_iNumCollapses, sizeof(m_iNumCollapses));
	file.Read(&m_iTotalIndexChanges, sizeof(m_iTotalIndexChanges));

	file.Read(&m_iMaxNumVertices, sizeof(int));
	file.Read(&m_iMaxNumIndices , sizeof(int));
	file.Read(&m_iMinNumVertices, sizeof(int));
	file.Read(&m_iMinNumIndices , sizeof(int));

	HRESULT hr = Create(m_iMaxNumVertices, m_iMaxNumIndices);
	__ASSERT(SUCCEEDED(hr), "Failed to create progressive mesh");

	if (m_iMaxNumVertices>0)
	{
//		m_pVertices = new __VertexT1[m_iMaxNumVertices];
		file.Read(m_pVertices, m_iMaxNumVertices*sizeof(__VertexT1));
	}

	if (m_iMaxNumIndices>0)
	{
//		m_pIndices = new uint16_t[m_iMaxNumIndices];
		file.Read(m_pIndices, m_iMaxNumIndices*sizeof(uint16_t));
	}

	if (m_iNumCollapses>0)
	{
		m_pCollapses = new __EdgeCollapse[m_iNumCollapses+1];	// +1을 한 이유 : PMeshInstance::SplitOne() 함수에서 부득이하게 포인터가 경계선을 가르키게 해야 하는 경우가 있어서.
		file.Read(m_pCollapses, m_iNumCollapses*sizeof(__EdgeCollapse));
		ZeroMemory(m_pCollapses + m_iNumCollapses, sizeof(__EdgeCollapse));	// 위의 +1을 한이유와 같음. 만약을 대비해 마지막 데이타를 초기화 해둠

		bool bFixed = false;
		for(int i = 0; i < m_iNumCollapses; i++)
		{
			if(m_pCollapses[i].iIndexChanges < 0)
			{
				m_pCollapses[i].iIndexChanges = 0;
				bFixed = true;
			}
		}
#ifdef _DEBUG
		if(bFixed)
			::MessageBox(s_hWndBase, "잘못된 Progressive Mesh 수정", m_szName.c_str(), MB_OK);
#endif
	}
	if (m_iTotalIndexChanges>0)
	{
		m_pAllIndexChanges = new int[m_iTotalIndexChanges];
		file.Read(m_pAllIndexChanges, m_iTotalIndexChanges*sizeof(int));
	}

	__ASSERT(m_pLODCtrlValues == nullptr && m_iLODCtrlValueCount == 0, "Invalid Level of detail control value");
	file.Read(&m_iLODCtrlValueCount, sizeof(m_iLODCtrlValueCount));
	if (m_iLODCtrlValueCount>0)
	{
		m_pLODCtrlValues = new __LODCtrlValue[m_iLODCtrlValueCount];
		file.Read(m_pLODCtrlValues, m_iLODCtrlValueCount*sizeof(__LODCtrlValue));
	}

	FindMinMax();

	return true;
}

#ifdef _N3TOOL
bool CN3PMesh::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	file.Write(&m_iNumCollapses, sizeof(m_iNumCollapses));
	file.Write(&m_iTotalIndexChanges, sizeof(m_iTotalIndexChanges));

	file.Write(&(m_iMaxNumVertices), sizeof(int));
	file.Write(&(m_iMaxNumIndices), sizeof(int));
	file.Write(&(m_iMinNumVertices), sizeof(int));
	file.Write(&(m_iMinNumIndices), sizeof(int));

	if (m_iMaxNumVertices>0) file.Write(m_pVertices, m_iMaxNumVertices*sizeof(__VertexT1));
	if (m_iMaxNumIndices>0) file.Write(m_pIndices, m_iMaxNumIndices*sizeof(uint16_t));

	if (m_iNumCollapses>0)
	{
		for(int i = 0; i < m_iNumCollapses; i++)
			if(m_pCollapses[i].iIndexChanges < 0) m_pCollapses[i].iIndexChanges = 0; // 저장..
		file.Write(m_pCollapses, m_iNumCollapses*sizeof(__EdgeCollapse));
	}
	if (m_iTotalIndexChanges>0) file.Write(m_pAllIndexChanges, m_iTotalIndexChanges*sizeof(m_pAllIndexChanges[0]));

	file.Write(&m_iLODCtrlValueCount, sizeof(m_iLODCtrlValueCount));
	if (m_iLODCtrlValueCount>0) file.Write(m_pLODCtrlValues, m_iLODCtrlValueCount*sizeof(__LODCtrlValue));

	return true;
}
#endif // end of _N3TOOL

void CN3PMesh::FindMinMax()
{
	if(m_iMaxNumVertices <= 0)
	{
		m_vMin.Zero();
		m_vMax.Zero();
		m_fRadius = 0;
		return;
	}

	// 최소, 최대 점을 찾는다.
	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);

	for(int i = 0; i < m_iMaxNumVertices; i++)
	{
		if(m_pVertices[i].x < m_vMin.x) m_vMin.x = m_pVertices[i].x;
		if(m_pVertices[i].y < m_vMin.y) m_vMin.y = m_pVertices[i].y;
		if(m_pVertices[i].z < m_vMin.z) m_vMin.z = m_pVertices[i].z;

		if(m_pVertices[i].x > m_vMax.x) m_vMax.x = m_pVertices[i].x;
		if(m_pVertices[i].y > m_vMax.y) m_vMax.y = m_pVertices[i].y;
		if(m_pVertices[i].z > m_vMax.z) m_vMax.z = m_pVertices[i].z;
	}

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

#ifdef _N3TOOL
void CN3PMesh::CopyMesh(CN3PMesh* pSrcPMesh)
{
	Release();

	HRESULT hr;
	
	__ASSERT(pSrcPMesh, "Source progressive mesh pointer is NULL");
	
	m_iNumCollapses			= pSrcPMesh->m_iNumCollapses;
	m_iTotalIndexChanges	= pSrcPMesh->m_iTotalIndexChanges;
	m_iMaxNumVertices		= pSrcPMesh->m_iMaxNumVertices;
	m_iMaxNumIndices		= pSrcPMesh->m_iMaxNumIndices;
	m_iMinNumVertices		= pSrcPMesh->m_iMinNumVertices;
	m_iMinNumIndices		= pSrcPMesh->m_iMinNumIndices;
	m_vMin					= pSrcPMesh->m_vMin;
	m_vMax					= pSrcPMesh->m_vMax;
	m_fRadius				= pSrcPMesh->m_fRadius;
	m_iLODCtrlValueCount	= pSrcPMesh->m_iLODCtrlValueCount;

	if (m_iTotalIndexChanges>0)
	{
		m_pAllIndexChanges = new int[m_iTotalIndexChanges];

		CopyMemory(m_pAllIndexChanges, pSrcPMesh->m_pAllIndexChanges, sizeof(int)*m_iTotalIndexChanges);
	}

	if (m_iNumCollapses>0)
	{
		m_pCollapses = new __EdgeCollapse[m_iNumCollapses+1];	// +1을 한 이유 : PMeshInstance::SplitOne() 함수에서 부득이하게 포인터가 경계선을 가르키게 해야 하는 경우가 있어서.
		CopyMemory(m_pCollapses, pSrcPMesh->m_pCollapses, sizeof(__EdgeCollapse)*m_iNumCollapses);
		ZeroMemory(m_pCollapses + m_iNumCollapses, sizeof(__EdgeCollapse));	// 위의 +1을 한이유와 같음. 만약을 대비해 마지막 데이타를 초기화 해둠
	}

	hr = Create(m_iMaxNumVertices, m_iMaxNumIndices);
	__ASSERT(SUCCEEDED(hr), "Failed to create progressive mesh");

	if (m_iMaxNumVertices>0)
	{
//		m_pVertices = new __VertexT1[m_iMaxNumVertices];
		CopyMemory(m_pVertices, pSrcPMesh->m_pVertices, sizeof(__VertexT1)*m_iMaxNumVertices);
	}

	if (m_iMaxNumIndices>0)
	{
//		m_pIndices = new uint16_t[m_iMaxNumIndices];
		CopyMemory(m_pIndices, pSrcPMesh->m_pIndices, sizeof(uint16_t)*m_iMaxNumIndices);
	}

	if (m_iLODCtrlValueCount>0)
	{
		m_pLODCtrlValues = new __LODCtrlValue[m_iLODCtrlValueCount];
		CopyMemory(m_pLODCtrlValues, pSrcPMesh->m_pLODCtrlValues, sizeof(__LODCtrlValue)*m_iLODCtrlValueCount);
	}

	m_szName = pSrcPMesh->m_szName;
}
#endif // end of _N3TOOL

HRESULT CN3PMesh::Create(int iNumVertices, int iNumIndices)
{
	m_iMaxNumVertices = iNumVertices;
	m_iMaxNumIndices = iNumIndices;

	if (m_pVertices) {delete m_pVertices; m_pVertices = nullptr;}
	if (m_pIndices) {delete m_pIndices; m_pIndices = nullptr;}

	if (m_iMaxNumVertices>0)
	{
		m_pVertices = new __VertexT1[m_iMaxNumVertices];
	}
	if (m_iMaxNumIndices>0)
	{
		m_pIndices = new uint16_t[m_iMaxNumIndices];
	}

	return S_OK;
}

HRESULT CN3PMesh::GenerateSecondUV()
{
	if (m_pVertices2) {delete m_pVertices2; m_pVertices2 = nullptr;}

	if (m_iMaxNumVertices>0)
	{
		m_pVertices2 = new __VertexT2[m_iMaxNumVertices];

		for(int i = 0; i < m_iMaxNumVertices; i++)
		{
			m_pVertices2[i].x = m_pVertices[i].x;
			m_pVertices2[i].y = m_pVertices[i].y;
			m_pVertices2[i].z = m_pVertices[i].z;
			m_pVertices2[i].n = m_pVertices[i].n;
			m_pVertices2[i].tu = m_pVertices[i].tu;
			m_pVertices2[i].tv = m_pVertices[i].tv;
			m_pVertices2[i].tu2 = m_pVertices[i].tu;
			m_pVertices2[i].tv2 = m_pVertices[i].tv;
		}
	}

	return S_OK;
}

#ifdef _N3TOOL
void CN3PMesh::LODCtrlSet(__LODCtrlValue *pLODCtrls, int nCount)
{
	m_iLODCtrlValueCount = 0;
	delete [] m_pLODCtrlValues; m_pLODCtrlValues = nullptr;
	if(nullptr == pLODCtrls || nCount <= 0) return;

	m_iLODCtrlValueCount = nCount;
	if(nCount > 0)
	{
		m_pLODCtrlValues = new __LODCtrlValue[nCount];
		memcpy(m_pLODCtrlValues, pLODCtrls, sizeof(__LODCtrlValue) * nCount);

		// 거리에 따라 정렬
		qsort(m_pLODCtrlValues, m_iLODCtrlValueCount, sizeof(__LODCtrlValue), SortByDistance);
	}
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
int CN3PMesh::SortByDistance(const void *pArg1, const void *pArg2)
{
	__LODCtrlValue *pObj1 = (__LODCtrlValue*)pArg1;
	__LODCtrlValue *pObj2 = (__LODCtrlValue*)pArg2;

	if(pObj1->fDist < pObj2->fDist) return -1;
	else if(pObj1->fDist > pObj2->fDist) return 1;
	else return 0;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3PMesh::ReGenerateSmoothNormal()
{
	if(m_iMaxNumVertices <= 0) return;

	CN3PMeshInstance PMI(this);
	PMI.SetLODByNumVertices(m_iMaxNumVertices); // 최대 점으로 세팅하고..
	int nIC = PMI.GetNumIndices(); // Index Count...
	uint16_t* pwIndices = PMI.GetIndices(); // Index ...

	int* pnNs = new int[m_iMaxNumVertices];
	memset(pnNs, 0, 4 * m_iMaxNumVertices);
	__Vector3* pvNs = new __Vector3[m_iMaxNumVertices];
	memset(pvNs, 0, sizeof(__Vector3)*m_iMaxNumVertices);

	int nFC = nIC / 3;

	__Vector3 v0, v1, v2, vN(0,0,0);
	for(int i = 0; i < m_iMaxNumVertices; i++)
	{
		for(int j = 0; j < nFC; j++)
		{
			v0 = m_pVertices[pwIndices[j*3+0]];
			v1 = m_pVertices[pwIndices[j*3+1]];
			v2 = m_pVertices[pwIndices[j*3+2]];

			if(	m_pVertices[i] == v0 ||
				m_pVertices[i] == v1 ||
				m_pVertices[i] == v2 )
			{
				vN.Cross(v1 - v0, v2 - v1); // Normal 값을 계산하고...
				vN.Normalize();

				pnNs[i]++;
				pvNs[i] += vN;
			}
		}

		if(pnNs[i] > 0) m_pVertices[i].n = pvNs[i] / (float)pnNs[i];
	}

	delete [] pnNs;
	delete [] pvNs;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3PMesh::ReGenerateSharpNormal()
{
	if(m_iMaxNumVertices <= 0) return;

	CN3PMeshInstance PMI(this);
	PMI.SetLODByNumVertices(m_iMaxNumVertices); // 최대 점으로 세팅하고..
	int nIC = PMI.GetNumIndices(); // Index Count...
	uint16_t* pwIndices = PMI.GetIndices(); // Index ...

	int nFC = nIC / 3;
	__Vector3 v0, v1, v2, vN(0,0,0);
	for(int j = 0; j < nFC; j++)
	{
		v0 = m_pVertices[pwIndices[j*3+0]];
		v1 = m_pVertices[pwIndices[j*3+1]];
		v2 = m_pVertices[pwIndices[j*3+2]];

		vN.Cross(v1 - v0, v2 - v1); // Normal 값을 계산하고...
		vN.Normalize();

		m_pVertices[pwIndices[j*3+0]].n = vN;
		m_pVertices[pwIndices[j*3+1]].n = vN;
		m_pVertices[pwIndices[j*3+2]].n = vN;
	}

}
#endif // end of _N3TOOL

// ===== END N3Base/N3PMesh.cpp =====

// ===== BEGIN N3Base/N3PMesh.h =====
#line 1 "N3Base/N3PMesh.h"
﻿// N3PMesh.h: interface for the CN3PMesh class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3PMesh_h__INCLUDED_)
#define AFX_N3PMesh_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"

class CN3PMesh : public CN3BaseFileAccess
{
friend class CN3FXPMeshInstance;
friend class CN3PMeshInstance;
friend class CN3PMeshCreate;
friend class CPMeshEditor;			// N3Viewer의 클래스

public:
	struct  __LODCtrlValue
	{
		float	fDist;
		int		iNumVertices;
	};

	// A single edge collapse / vertex split operation.
	struct __EdgeCollapse
	{
	//	float Value;
		int NumIndicesToLose, NumIndicesToChange, NumVerticesToLose;
		//int *IndexChanges;
		int iIndexChanges;	// 포인터 대신 n번째 저장 (0, 1, 2,...)
		int CollapseTo;
		bool	bShouldCollapse;	// 여기서 병합/나누기를 멈추면 구멍이 뚤린다. 다음단계를 더 진행해야함.
	};

protected:

	//int m_iNumMaterials;
	int m_iNumCollapses;			// 삼각형 병합 리스트
	int m_iTotalIndexChanges;
	int *m_pAllIndexChanges; // All the index changes

	// The mesh is an array of materials, and an edge collapse list. The mesh
	// is saved in its lowest level of detail

	__EdgeCollapse	*m_pCollapses;

	// Mesh 정보
	__VertexT1*		m_pVertices;
	__VertexT2*		m_pVertices2;
	uint16_t*			m_pIndices;

	int m_iMaxNumVertices, m_iMaxNumIndices;
	int m_iMinNumVertices, m_iMinNumIndices;

	__Vector3	m_vMin, m_vMax; // 최대 최소값..
	float		m_fRadius; // 반지름

	// LOD 조정 정보..(거리에 따라서 Vertex의 수를 조정할 수 있다.)
	int					m_iLODCtrlValueCount;
	__LODCtrlValue*		m_pLODCtrlValues;
protected:
#ifdef _N3TOOL
	static int SortByDistance(const void *pArg1, const void *pArg2);
#endif // end of _N3TOOL

public:
#ifdef _N3TOOL
	void ReGenerateSharpNormal();
	void ReGenerateSmoothNormal();
	int LODCtrlCount() { return m_iLODCtrlValueCount; }
	void LODCtrlSet(__LODCtrlValue* pLODCtrls, int nCount);
	__LODCtrlValue* LODCtrlGet(int index) { if(index < 0 || index >= m_iLODCtrlValueCount) return nullptr; return &m_pLODCtrlValues[index]; }
	int CollapsesCount() { return m_iNumCollapses; }
#endif // end of _N3TOOL

//	int					GetLODCtrlValueCount() const {return m_iLODCtrlValueCount;}
//	__PMLODCtrlValue*	GetLODCtrlValue(int iIndex) const {if (iIndex>=0&&m_iLODCtrlValueCount>iIndex)return m_pLODCtrlValues+iIndex; return nullptr;}
//	void				SetLODCtrlValues(__PMLODCtrlValue* pValues) {m_pLODCtrlValues = pValues;}

	__Vector3 Min() { return m_vMin; } // 월드 행렬을 적용하지 않은상태의 최소값이다.
	__Vector3 Max() { return m_vMax; } // 월드 행렬을 적용하지 않은상태의 최대값이다.

	void Release() override;
	HRESULT Create(int iNumVertices, int iNumIndices);
	HRESULT GenerateSecondUV();
	
	bool Load(File& file) override;
#ifdef _N3TOOL
	bool Save(File& file) override;
#endif // end of _N3TOOL
	
	void FindMinMax();

	float Radius() { return m_fRadius; }
	int	GetMinNumVertices() const {return m_iMinNumVertices;};
	int	GetMaxNumVertices() const {return m_iMaxNumVertices;};
	int GetMaxNumIndices() const {return m_iMaxNumIndices;};
	int GetMinNumIndices() const {return m_iMinNumIndices;};

	__VertexT1*		GetVertices() const { return m_pVertices; };
	__VertexT2*		GetVertices2() const { return m_pVertices2; };
	uint16_t*		GetIndices() const { return m_pIndices;};		// 제대로된 Index가 아님 
	// (제대로 된 인덱스를 얻으려면 N3PMeshInstance로 만든후 LOD조정후 인덱스값을 얻으면 된다.)

#ifdef _N3TOOL
	void CopyMesh(CN3PMesh* pSrcPMesh);
#endif // end of _N3TOOL

	CN3PMesh();
	~CN3PMesh() override;
};

#endif // !defined(AFX_N3PMesh_h__INCLUDED_)

// ===== END N3Base/N3PMesh.h =====

// ===== BEGIN N3Base/N3PMeshCreate.cpp =====
#line 1 "N3Base/N3PMeshCreate.cpp"
﻿// N3PMeshCreate.cpp: implementation of the CN3PMeshCreate class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3PMeshCreate.h"
#include "N3PMesh.h"
#include "N3PMeshInstance.h"
#include "N3Mesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

// Maximum buffer sizes. For greater flexibility, the buffers should reallocate dynamically.
#define MAX_COLLAPSES 5000
#define MAX_INDEX_CHANGES 10000
#define MAX_VERTICES_PER_MATERIAL 10000

//////////////////////////////////////////////////////////////////////////////
//
// Helper functions

// swap two variables
template <class T> void swap(T &a, T &b)
{
	T t;

	t = a;
	a = b;
	b = t;
}

// swap whole triangles
void CN3PMeshCreate::swap_triangle(uint16_t *t1, uint16_t *t2)
{
	swap(t1[0], t2[0]);
	swap(t1[1], t2[1]);
	swap(t1[2], t2[2]);
}

// 없어질 삼각형의 넓이 계산, 혹은 변의 길이의 합
float CN3PMeshCreate::GetTriCollapsesLoss(uint16_t* pTriIndex, bool bArea)
{
	// These are the corners of the triangle.
	__Vector3 pts[3] =
	{
		m_pVertices[pTriIndex[0]],
		m_pVertices[pTriIndex[1]],
		m_pVertices[pTriIndex[2]]
	};
	
	if (bArea)
	{
		// Calculate the area.
		__Vector3 cross, V1, V2;
		V1 = pts[2] - pts[0];
		V2 = pts[1] - pts[0];
		cross.Cross(V1, V2);
		return cross.Magnitude();
	}
	else
	{
		// Calculate side length.
		__Vector3 V1, V2, V3;
		V1 = pts[2] - pts[0];
		V2 = pts[1] - pts[0];
		V3 = pts[1] - pts[2];

		float fLoss = V1.Magnitude() + V2.Magnitude() + V3.Magnitude() + 0.0001f;
		__ASSERT(fLoss > 0, "Loss value is less than 0");
		return fLoss;
	}
}

// add the cost of a triangle being modified (ie one of its vertices being changed) into the accumulator "sofar".
// This is the meat of the edge evaluation function.
void CN3PMeshCreate::combine_modified(float &sofar, uint16_t *tri, int which, int what_to, bool bSumOfLoss)
{
	// These are the corners of the triangle at the moment.
	__Vector3 pts[3] =
	{
			m_pVertices[tri[0]],
			m_pVertices[tri[1]],
			m_pVertices[tri[2]]
	};

	// This is a point in the plane of the triangle.
	__Vector3 in_plane = pts[0];

	// Calculate the area and face normal for the triangle at the moment.
	__Vector3 oldcross, V1, V2;
	V1 = pts[2] - pts[0];
	V2 = pts[1] - pts[0];
	oldcross.Cross(V1, V2);

	float oldarea = oldcross.Magnitude();
	__Vector3 oldnorm;
	oldnorm.Normalize(oldcross);

	// Change the triangle.
	pts[which] = m_pVertices[what_to];

	// Re-calculate the area and face normal.
	__Vector3 newcross;
	V1 = pts[2] - pts[0];
	V2 = pts[1] - pts[0];
	newcross.Cross(V1, V2);

	float newarea = newcross.Magnitude();
	__Vector3 newnorm;
	newnorm.Normalize(newcross);

	// A measure of the difference in the face normals.
	float cosangdiff = newnorm.Dot(oldnorm);

	// Calculate some statistics about the triangle change.
	V1 = m_pVertices[what_to] - in_plane;
	float volume_change = std::abs(V1.Dot(oldcross));

	// The angle change weighted by the area of the triangle.
	float weighted_angle_change = (1.0f - cosangdiff) * (oldarea + newarea);
	if (weighted_angle_change<0.0f) weighted_angle_change = 0.0f;	// cosangdiff가 1보다 아주 조금 클때가 있어서 weighted_angle_change가 -값이 나올때가 있다.
	//__ASSERT(weighted_angle_change>=0.0f, "weighted_angle_change > 0 이어야 한다.");

	// These numbers are not in the same "units", one being length^3 and the other length^2
	// And let's put some arbitrary weighting on these things.
	        volume_change = powf(        volume_change, .333333f);
	weighted_angle_change = powf(weighted_angle_change, .5f     ) * 5.f;

	// Work out a cost for the changing of this triangle
	float newval = weighted_angle_change + volume_change;

	if (bSumOfLoss)
	{
		sofar += newval;
	}
	else
	{
		// And factor it in. Here I choose to accumulate the maximum cost.
		if (newval > sofar) sofar = newval;
	}
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3PMeshCreate::CN3PMeshCreate()
{
	m_pVertices = nullptr;
	m_pIndices = nullptr;

	m_pCollapses = nullptr;
	m_pAllIndexChanges = nullptr;

	Release();
}

CN3PMeshCreate::~CN3PMeshCreate()
{
	CN3PMeshCreate::Release();
}

void CN3PMeshCreate::Release()
{
	if (m_pVertices) { delete[] m_pVertices; m_pVertices = nullptr;}
	if (m_pIndices) { delete[] m_pIndices; m_pIndices = nullptr; }

	if (m_pCollapses) { delete[] m_pCollapses; m_pCollapses = nullptr;}
	if (m_pAllIndexChanges) { delete[] m_pAllIndexChanges; m_pAllIndexChanges = nullptr;}

	m_pCollapseUpTo = nullptr;
	m_iTotalIndexChanges = 0;
	m_iNumVertices = 0; m_iNumIndices = 0;
}

// collapse pt_from onto pt_to, adding the collapse to the collapse list
void CN3PMeshCreate::Collapse(uint16_t& pt_to, uint16_t& pt_from, float edge_val)
{
	// Swap the collapsing vertex to the end of the vertex list.
	SwapToEnd(pt_from, m_pCollapses, m_pCollapseUpTo, pt_to, pt_from);

	// Now we do the collapse.
	m_iNumVertices--;

	// Run through uncollapsed triangles to find ones that
	// refer to this vertex, and count up the ones that disappear.
	m_pCollapseUpTo->NumTrianglesToLose = 0;
	m_pCollapseUpTo->IndexChanges = nullptr;
	m_pCollapseUpTo->NumIndicesToChange = 0;

	// step through the triangle list
	int tri_index;
	for (tri_index = 0; tri_index < m_iNumIndices;)
	{
		// step through each point in the triangle
		for (int pt = 0; pt < 3; pt++)
		{
			// Is this the collapsing vertex?
			if (m_pIndices[tri_index + pt] == m_iNumVertices)
			{
				// Yes, but will this triangle be degenerate? Must look for
				// the other end of the collapse edge
				int pt2;

				// look for the other point
				for (pt2 = 0; pt2 < 3; pt2++)
				{
					if (m_pIndices[tri_index + pt2] == pt_to)
					{
						// This triangle contains the collapsing edge.
						
						// It goes on the end of the list, unless it's already there.
						m_pCollapseUpTo->NumTrianglesToLose++;
						m_iNumIndices -= 3;

						if (tri_index == m_iNumIndices)
						{
							// This triangle is the end of the list. We're done here,
							// and we've got no more triangles to look at (because it's
							// the end of the list)
							goto done_triangle_list;
						}

						// Swap the triangles.
						swap_triangle(m_pIndices + tri_index, m_pIndices + m_iNumIndices);

						// And any references to them (in other collapses)
						for (__PMCEdgeCollapse *c = m_pCollapses; c < m_pCollapseUpTo; c++)
						{
							// Look through the index changes.
							int *ic;

							for (ic = c->IndexChanges;
								 ic < c->IndexChanges + c->NumIndicesToChange;
								 ic++)
							{
								if (*ic >= tri_index && *ic < tri_index + 3)
								{
									// This index change refers to the triangle that's
									// been moved!
									*ic += (m_iNumIndices - tri_index);
								}
								else
								if (*ic >= m_iNumIndices && *ic < m_iNumIndices + 3)
								{
									// This index change refers to the other triangle
									*ic -= (m_iNumIndices - tri_index);
								}
							}
						}

						// So, this triangle became redundant. Try the next triangle,
						// but don't increment tri_index.
						// 이번에 검사한 삼각형은 사라졌다. 리스트 맨뒤로 보냈으니
						// tri_index는 중가시키지 않는다.
						goto try_same_triangle_location;
					}
				}

				// 여기에 오면 이 삼각형은 사라지는 삼각형은 아니다. 그러나 한 점이 다른점으로 옮겨진다.
				// This triangle isn't degenerate if we've got here. But it does
				// have a reference to the collapsing vertex. This is fine - it can
				// now just refer to the non-collapsing vertex.

				// We want to record the index change. First, do we have a buffer of them?
				if (!m_pCollapseUpTo->IndexChanges)
				{
					// We haven't recorded an index change yet.
					m_pCollapseUpTo->IndexChanges = m_pAllIndexChanges + m_iTotalIndexChanges;
				}

				// Add another index change on.
				__ASSERT(m_iTotalIndexChanges < MAX_INDEX_CHANGES, "You must increase MAX_INDEX_CHANGES");

				m_pAllIndexChanges[m_iTotalIndexChanges++] = tri_index + pt;
				m_pCollapseUpTo->NumIndicesToChange++;

				// And actually do the change.
				m_pIndices[tri_index + pt] = pt_to;

				// Definately no more indices to change in this triangle.
				goto try_another_triangle;
			}	
		}

try_another_triangle:
		// step on to the next triangle
		tri_index += 3;

try_same_triangle_location:;
		// You can jump to here if the next triangle is still in the same
		// place because triangles have been moved around.
	}

done_triangle_list:

	// So, the triangle list has been edited to account for the collapse.

	// Were any other vertices made redundant by the loss of these triangles?
	m_pCollapseUpTo->NumVerticesToLose = 1; // That's the collapser itself, of course.

	// Flag all vertices to see if they're referred to by triangles any more.
	int referred[MAX_VERTICES_PER_MATERIAL];
	memset(referred, 0, sizeof(referred));
	__ASSERT(m_iNumVertices < MAX_VERTICES_PER_MATERIAL, "You must increase MAX_VERTICES_PER_MATERIAL");

	int i;
	for (i = 0; i < m_iNumIndices; i++)
	{
		__ASSERT(m_pIndices[i] < m_iNumVertices, "indices array index overflow");
		referred[m_pIndices[i]] = 1;
	}

	// If not, let's lose them.
	for (i = 0; i < m_iNumVertices;)
	{
		if (!referred[i])
		{
			// We can swap this vertex with the one at the end of the list.
			SwapToEnd(i, m_pCollapses, m_pCollapseUpTo + 1, pt_to, pt_from);

			// And better swap its "referred" status.
			swap(referred[i], referred[m_iNumVertices - 1]);

			// One more vertex lost.
			m_pCollapseUpTo->NumVerticesToLose++;
			m_iNumVertices--;

			// And don't increment i
			continue;
		}

		i++;
	}

	// Fill in the remaining collapse data.
	m_pCollapseUpTo->CollapseTo = pt_to;
	m_pCollapseUpTo->Value = edge_val;
	m_pCollapseUpTo++;
}

// Evaluate the cost of an edge, and if it's better than the best edge so far, record it
void CN3PMeshCreate::TryEdge(
					 int pt_a, int pt_b,
					 float &be_val,
					 uint16_t &be_to,
					 uint16_t &be_from,
					 bool &IsOver)
{
	// There's actually two edge modifications being considered here:
	// - collapse of pt_a onto pt_b (a_loss)
	// - collapse of pt_b onto pt_a (b_loss)

	float a_loss = 0.f;
	float b_loss = 0.f;
	if (m_PMCOption.bUseSumOfLoss)
	{
		a_loss = 0.f;
		b_loss = 0.f;
	}
	else
	{
		// Start with both costing very little.
		a_loss = -1000000000000000.f;
		b_loss = -1000000000000000.f;
	}

	// Look for all triangles affected by the collapse
	for (uint16_t *tri = m_pIndices; tri < m_pIndices + m_iNumIndices; tri += 3)
	{
		if (tri[0] == pt_a)
		{
			if (tri[1] != pt_b && tri[2] != pt_b)
			{
				combine_modified(a_loss, tri, 0, pt_b, m_PMCOption.bUseSumOfLoss);
				__ASSERT(a_loss>=0.0f, "loss > 0이어야 한다.");
			}
			else
			{
				// tri collapses.
				if (m_PMCOption.bTriangleWeight)
				{
					float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
					if (m_PMCOption.bUseSumOfLoss)
					{
						a_loss += t_loss;
						b_loss += t_loss;
					}
					else
					{
						if (t_loss > a_loss) a_loss = t_loss;
					}
					__ASSERT(a_loss>=0.0f && b_loss>=0.0f, "loss > 0이어야 한다.");
				}
				continue;
			}
		}
		else
		if (tri[1] == pt_a)
		{
			if (tri[2] != pt_b && tri[0] != pt_b)
			{
				combine_modified(a_loss, tri, 1, pt_b, m_PMCOption.bUseSumOfLoss);
				__ASSERT(a_loss>=0.0f, "loss > 0이어야 한다.");
			}
			else
			{
				// tri collapses.
				if (m_PMCOption.bTriangleWeight)
				{
					float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
					if (m_PMCOption.bUseSumOfLoss)
					{
						a_loss += t_loss;
						b_loss += t_loss;
					}
					else
					{
						if (t_loss > a_loss) a_loss = t_loss;
					}
					__ASSERT(a_loss>=0.0f && b_loss>=0.0f, "loss > 0이어야 한다.");
				}
				continue;
			}
		}
		else
		if (tri[2] == pt_a)
		{
			if (tri[0] != pt_b && tri[1] != pt_b)
			{
				combine_modified(a_loss, tri, 2, pt_b, m_PMCOption.bUseSumOfLoss);
				__ASSERT(a_loss>=0.0f, "loss > 0이어야 한다.");
			}
			else
			{
				// tri collapses.
				if (m_PMCOption.bTriangleWeight)
				{
					float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
					if (m_PMCOption.bUseSumOfLoss)
					{
						a_loss += t_loss;
						b_loss += t_loss;
					}
					else
					{
						if (t_loss > a_loss) a_loss = t_loss;
					}
					__ASSERT(a_loss>=0.0f && b_loss>=0.0f, "loss > 0이어야 한다.");
				}
				continue;
			}
		}
		else
		{
			// no points are a's
			if (tri[0] == pt_b)
			{
				combine_modified(b_loss, tri, 0, pt_a, m_PMCOption.bUseSumOfLoss);
				__ASSERT(b_loss>=0.0f, "loss > 0이어야 한다.");
			}
			else
			if (tri[1] == pt_b)
			{
				combine_modified(b_loss, tri, 1, pt_a, m_PMCOption.bUseSumOfLoss);
				__ASSERT(b_loss>=0.0f, "loss > 0이어야 한다.");
			}
			else
			if (tri[2] == pt_b)
			{
				combine_modified(b_loss, tri, 2, pt_a, m_PMCOption.bUseSumOfLoss);
				__ASSERT(b_loss>=0.0f, "loss > 0이어야 한다.");
			}
		}
	}
	__ASSERT(a_loss>=0.0f && b_loss>=0.0f, "loss > 0이어야 한다.");

#ifdef _SAME_VERTEXPOS
	float temp_a_loss = GetLossOfSamePosVertex(pt_b, pt_a);
	float temp_b_loss = GetLossOfSamePosVertex(pt_a, pt_b);
	__ASSERT(temp_a_loss>=0.0f && temp_b_loss>=0.0f, "loss > 0이어야 한다.");
	if (m_PMCOption.bUseSumOfLoss)
	{
		a_loss += temp_a_loss;
		b_loss += temp_b_loss;
	}
	else
	{
		if (temp_a_loss > a_loss) a_loss = temp_a_loss;
		if (temp_b_loss > b_loss) b_loss = temp_b_loss;
	}
#endif // _SAME_VERTEXPOS

	// NOTE: What you should do here is check for edges of the object, where
	// the continuity of the mesh is broken. This example code will currently
	// actually collapse these preferentially! Bad idea.

	// We want to lose the point that costs the least.

	// Make sure it's point B that is the least cost by swapping if necessary.
	__ASSERT(a_loss>=0.0f && b_loss>=0.0f, "loss > 0이어야 한다.");
	if (b_loss > a_loss)
	{
		swap(pt_a, pt_b);
		b_loss = a_loss;
	}

	// And therefore, the cost of this edge is the cost of losing point B.
	float val = b_loss;

	//__ASSERT(m_PMCOption.bUseSumOfLoss == false || val>0.0f, "Sum of loss value is less than 0");

	// Is it a better candidate than what we've had so far?
	if (val < be_val)
	{
		be_to = pt_a;
		be_from = pt_b;
		be_val = val;
		IsOver = false;
	}
}

// Find a collapse to do, and do it. Returns false if there are no more collapses to do.
bool CN3PMeshCreate::FindACollapse(float &val_so_far)
{
	// First find the best edge to collapse in any material.
	uint16_t *tri;

	float be_val = 10000000000000000000000000000000000.f; // start with a big number
	bool IsOver = true;

	// The two ends of the edge.
	uint16_t be_index_a;
	uint16_t be_index_b;

	for (tri = m_pIndices; tri < m_pIndices + m_iNumIndices; tri += 3)
	{
		// Try each of the three edges of this triangle.
		TryEdge(tri[0], tri[1], be_val, be_index_a, be_index_b, IsOver);
		TryEdge(tri[1], tri[2], be_val, be_index_a, be_index_b, IsOver);
		TryEdge(tri[2], tri[0], be_val, be_index_a, be_index_b, IsOver);
	}

	// Was there a best edge? If not, collapsing is over.
	if (IsOver) return false;

	// The value (cost) of the mesh is the value so far plus the cost of the new edge.
	val_so_far += be_val;

	// Do the collapse
	Collapse(be_index_a, be_index_b, val_so_far);

#ifdef _SAME_VERTEXPOS
	// 같은 점 찾기
	int i;
	for (i=0; i<m_iNumVertices; ++i)
	{
		if (m_pVertices[be_index_b].x == m_pVertices[i].x &&
			m_pVertices[be_index_b].y == m_pVertices[i].y &&
			m_pVertices[be_index_b].z == m_pVertices[i].z )
		{
			uint16_t index_from = i;
			if (be_index_a < m_iNumVertices && index_from != be_index_a)
				Collapse(be_index_a, index_from, val_so_far);
		}
	}
#endif	// _SAME_VERTEXPOS

	return true;
}

void CN3PMeshCreate::CreateCollapseList()
{
	m_iOriginalNumVertices = m_iNumVertices;
	m_iOriginalNumIndices  = m_iNumIndices ;

	// make sure it hasn't been done before
	__ASSERT(!m_pCollapses, "Collapses pointer is not NULL!");

	m_pCollapses = new __PMCEdgeCollapse[MAX_COLLAPSES];
	__ASSERT(m_pCollapses, "Failed to create collapses buffer"); // note you should really have code to handle failure of malloc
	m_pCollapseUpTo = m_pCollapses;

//	__PMCEdgeCollapse *CollapseUpTo = m_pCollapses;

	m_pAllIndexChanges = new int[MAX_INDEX_CHANGES];
	__ASSERT(m_pAllIndexChanges, "Failed to create Index Change buffer");
	m_iTotalIndexChanges = 0;

	// Keep collapsing until none left to do.
	float start_val = 0.f;
	while (FindACollapse(start_val))
	{
	}
}

// Converts the mesh into one that can be used by the renderer
CN3PMesh *CN3PMeshCreate::CreateRendererMesh()
{
	CN3PMesh *pPMesh = new CN3PMesh;

	pPMesh->m_iTotalIndexChanges = m_iTotalIndexChanges;
	if (m_iTotalIndexChanges>0)
	{
		pPMesh->m_pAllIndexChanges = new int[m_iTotalIndexChanges];
		__ASSERT(pPMesh->m_pAllIndexChanges, "Index change buffer is NULL"); // again, you should check for malloc failure
		memcpy(pPMesh->m_pAllIndexChanges, m_pAllIndexChanges, m_iTotalIndexChanges * sizeof(m_pAllIndexChanges[0]));
	}

	if (m_pCollapseUpTo - m_pCollapses > 0)
	{
		pPMesh->m_pCollapses = new CN3PMesh::__EdgeCollapse[m_pCollapseUpTo - m_pCollapses];
		__ASSERT(pPMesh->m_pCollapses, "Collpases pointer is NULL!");
	}

	pPMesh->m_iNumCollapses = static_cast<int>(m_pCollapseUpTo - m_pCollapses);

	// Copy the collapses in reverse order, so that the lowest detail collapses are first
	int i;

	float fTempValue = 0.0f;
	for (i = 0; i < pPMesh->m_iNumCollapses; i++)
	{
		__PMCEdgeCollapse &src  = m_pCollapses[pPMesh->m_iNumCollapses - i - 1];
		CN3PMesh::__EdgeCollapse &dest = pPMesh->m_pCollapses[i];

		dest.CollapseTo = src.CollapseTo;
		dest.iIndexChanges = static_cast<int>(src.IndexChanges - m_pAllIndexChanges);
		dest.NumIndicesToChange = src.NumIndicesToChange;
		dest.NumIndicesToLose = src.NumTrianglesToLose * 3;
		dest.NumVerticesToLose = src.NumVerticesToLose;
		dest.bShouldCollapse = (fTempValue == src.Value ? true : false);
		fTempValue = src.Value;
	}

	// mesh 정보
	pPMesh->m_iMaxNumIndices  = m_iOriginalNumIndices ;
	pPMesh->m_iMaxNumVertices = m_iOriginalNumVertices;
	pPMesh->m_iMinNumIndices  = m_iNumIndices ;
	pPMesh->m_iMinNumVertices = m_iNumVertices;

	pPMesh->Create(pPMesh->m_iMaxNumVertices, pPMesh->m_iMaxNumIndices);
//	pPMesh->m_pIndices = new uint16_t[pPMesh->m_iMaxNumIndices];
//	__ASSERT(pPMesh->m_pIndices);
//	pPMesh->m_pVertices = new __VertexT1[pPMesh->m_iMaxNumVertices];
//	__ASSERT(pPMesh->m_pVertices);

	// The indices can be a straight copy.
	memcpy(pPMesh->m_pIndices, m_pIndices, pPMesh->m_iMaxNumIndices * sizeof(uint16_t));

	// The vertices however must be copied by hand, just in case there's extra data in the
	// PMCVertices (if you have a more complex edge choice function
	for (int j = 0; j < pPMesh->m_iMaxNumVertices; j++)
	{
		pPMesh->m_pVertices[j] = m_pVertices[j];
	}

	return pPMesh;
}

int CN3PMeshCreate::ReGenerate(CN3PMesh *pPMesh)
{
	if(nullptr == pPMesh) return -1;
	
	this->Release();
	this->ConvertFromN3PMesh(pPMesh); // Mesh 로 부터 만들기..
	this->CreateCollapseList(); // Progressive Mesh 처리..

	pPMesh->m_iTotalIndexChanges = m_iTotalIndexChanges;
	if (m_iTotalIndexChanges>0)
	{
		delete [] pPMesh->m_pAllIndexChanges;
		pPMesh->m_pAllIndexChanges = new int[m_iTotalIndexChanges];
		__ASSERT(pPMesh->m_pAllIndexChanges, "Index change buffer is NULL"); // again, you should check for malloc failure
		memcpy(pPMesh->m_pAllIndexChanges, m_pAllIndexChanges, m_iTotalIndexChanges * sizeof(m_pAllIndexChanges[0]));
	}

	if (m_pCollapseUpTo - m_pCollapses > 0)
	{
		delete [] pPMesh->m_pCollapses;
		pPMesh->m_pCollapses = new CN3PMesh::__EdgeCollapse[m_pCollapseUpTo - m_pCollapses];
		__ASSERT(pPMesh->m_pCollapses, "Collpases pointer is NULL!");
	}

	pPMesh->m_iNumCollapses = static_cast<int>(m_pCollapseUpTo - m_pCollapses);

	// Copy the collapses in reverse order, so that the lowest detail collapses are first
	int i;

	float fTempValue = 0.0f;
	for (i = 0; i < pPMesh->m_iNumCollapses; i++)
	{
		__PMCEdgeCollapse &src  = m_pCollapses[pPMesh->m_iNumCollapses - i - 1];
		CN3PMesh::__EdgeCollapse &dest = pPMesh->m_pCollapses[i];

		dest.CollapseTo = src.CollapseTo;
		if (src.IndexChanges != nullptr && m_pAllIndexChanges != nullptr)
			dest.iIndexChanges = static_cast<int>(src.IndexChanges - m_pAllIndexChanges);
		else
			dest.iIndexChanges = 0;
		dest.NumIndicesToChange = src.NumIndicesToChange;
		dest.NumIndicesToLose = src.NumTrianglesToLose * 3;
		dest.NumVerticesToLose = src.NumVerticesToLose;
		dest.bShouldCollapse = (fTempValue == src.Value ? true : false);
		fTempValue = src.Value;
	}

	// mesh 정보
	pPMesh->m_iMinNumIndices  = m_iNumIndices ;
	pPMesh->m_iMinNumVertices = m_iNumVertices;

	pPMesh->Create(m_iOriginalNumVertices, m_iOriginalNumIndices);

	// The indices can be a straight copy.
	memcpy(pPMesh->m_pIndices, m_pIndices, pPMesh->m_iMaxNumIndices * sizeof(uint16_t));

	// The vertices however must be copied by hand, just in case there's extra data in the
	// PMCVertices (if you have a more complex edge choice function
	for (int j = 0; j < pPMesh->m_iMaxNumVertices; j++)
	{
		pPMesh->m_pVertices[j] = m_pVertices[j];
	}

	return 0;
}
// swap "swapper" to the end of the material, updating all references to the vertices being swapped
// swapper번째 버텍스를 버텍스버퍼의 m_iNumVertices-1 번째로 보내고
// ( m_iNumVertices는 collapse 리스트를 만들때마다 하나씩 감소) m_iNumVertices-1번째는 swapper번째로 옮긴다.
// 인덱스 버퍼, collapse리스트 안의 참조 인덱스, pt_to, pt_end도 새로운 인덱스에 맞게 swap 하는 함수
void CN3PMeshCreate::SwapToEnd(uint16_t swapper, __PMCEdgeCollapse *collapses, __PMCEdgeCollapse *collapses_end, uint16_t &pt_to, uint16_t &pt_from)
{
	// NOTE: Here you may want to call back into your animation system (for example), so that it knows that
	// the vertex list is being reordered.

	// callback(this, swapper, NumVertices - 1); - tell someone that the vertices are being swapped.

	// pointer to the vertex
	__VertexT1 *v = &m_pVertices[swapper];

	// actually swap the vertex data
	swap(*v, m_pVertices[m_iNumVertices - 1]);

	// Then we have to find all references to the swapped vertices, and swap them too.

	// There's references in the triangles still uncollapsed, and the collapsed ones. So run through all
	// the triangles
	int tri_index;
	for (tri_index = 0; tri_index < m_iOriginalNumIndices; tri_index++)
	{
		// Swap any references around
		if (m_pIndices[tri_index] == swapper) 
		{
			m_pIndices[tri_index] = m_iNumVertices - 1;
		}
		else
		if (m_pIndices[tri_index] == m_iNumVertices - 1)
		{
			m_pIndices[tri_index] = swapper;
		}
	}

	// There's references in all the edge collapses for this material.
	for (__PMCEdgeCollapse *c = collapses; c < collapses_end; c++)
	{
		if (c->CollapseTo == swapper)
		{
			c->CollapseTo = m_iNumVertices - 1;
		}
		else
		if (c->CollapseTo == m_iNumVertices - 1)
		{
			c->CollapseTo = swapper;
		}
	}

	// and the points on the collapsing edge themselves may have been moved
	if (pt_to == m_iNumVertices - 1)
	{
		pt_to = swapper;
	}
	else
	if (pt_to == swapper)
	{
		pt_to = m_iNumVertices - 1;
	}

	if (pt_from == m_iNumVertices - 1)
	{
		pt_from = swapper;
	}
	else
	if (pt_from == swapper)
	{
		pt_from = m_iNumVertices - 1;
	}
}

bool CN3PMeshCreate::ConvertFromN3Mesh(CN3Mesh* pN3Mesh)	// N3Mesh -> CN3PMeshCreate 로 컨버팅..
{
	if (pN3Mesh == nullptr) return false;
	Release();

	// get vertices count , indices count
	m_iNumVertices = pN3Mesh->VertexCount();
	m_iNumIndices = pN3Mesh->IndexCount();
	if (m_iNumVertices<=0 || m_iNumIndices<=0) return false;

	// copy vertices
	if (pN3Mesh->Vertices())
	{
		m_pVertices = new __VertexT1[m_iNumVertices];
		CopyMemory(m_pVertices, pN3Mesh->Vertices(), m_iNumVertices*sizeof(__VertexT1));
	}
	else return false;

	// copy indices
	if (pN3Mesh->Indices())
	{
		m_pIndices = new uint16_t[m_iNumIndices];
		CopyMemory(m_pIndices, pN3Mesh->Indices(), sizeof(uint16_t)*m_iNumIndices);
	}
	else return false;

	m_iOriginalNumVertices = m_iNumVertices;
	m_iOriginalNumIndices  = m_iNumIndices;

	return true;
}

bool CN3PMeshCreate::ConvertFromN3PMesh(CN3PMesh* pN3PMesh)
{
	if (pN3PMesh == nullptr) return false;
	Release();

	CN3PMesh* pPMeshTmp = CN3Base::s_MngPMesh.Get(pN3PMesh->FileName()); // 이래야 참조 카운트가 하나 늘어서 포인터가 안없어진다.
	CN3PMeshInstance PMeshInst(pN3PMesh);
	PMeshInst.SetLODByNumVertices(pN3PMesh->GetMaxNumVertices());

	// get vertices count , indices count
	m_iNumVertices = PMeshInst.GetNumVertices();
	m_iNumIndices = PMeshInst.GetNumIndices();
	if (m_iNumVertices<=0 || m_iNumIndices<=0) return false;

	// copy vertices	
	if (PMeshInst.GetVertices())
	{
		m_pVertices = new __VertexT1[m_iNumVertices];
		CopyMemory(m_pVertices, PMeshInst.GetVertices(), m_iNumVertices*sizeof(__VertexT1));
	}
	else return false;

	// copy indices
	if (PMeshInst.GetIndices())
	{
		m_pIndices = new uint16_t[m_iNumIndices];
		CopyMemory(m_pIndices, PMeshInst.GetIndices(), sizeof(uint16_t)*m_iNumIndices);
	}
	else return false;

	m_iOriginalNumVertices = m_iNumVertices;
	m_iOriginalNumIndices  = m_iNumIndices ;

	return true;
}

#ifdef _SAME_VERTEXPOS
float CN3PMeshCreate::GetLossOfSamePosVertex(uint16_t pt_to, uint16_t pt_from)
{
	__ASSERT(pt_to<m_iNumVertices && pt_from<m_iNumVertices && m_pVertices && m_pIndices, "Pointer is NULL");
	float fLoss = 0.0f;

	float x = m_pVertices[pt_from].x;
	float y = m_pVertices[pt_from].y;
	float z = m_pVertices[pt_from].z;

	int i;
	for (i=0; i<m_iNumVertices; ++i)
	{
		// from 과 같은 위치의 Vertex찾기
		if (i != pt_to && i != pt_from &&
			m_pVertices[i].x == x &&
			m_pVertices[i].y == y &&
			m_pVertices[i].z == z )
		{
			// i는 같은 위치를 가진 버텍스의 인덱스
			uint16_t* tri;
			for (tri = m_pIndices; tri<m_pIndices+m_iNumIndices; tri += 3)
			{
				if (tri[0] == i)
				{
					if (tri[1] != pt_to && tri[2] != pt_to) combine_modified(fLoss, tri, 0, pt_to, m_PMCOption.bUseSumOfLoss);
					else
						// tri collapses.
					if (m_PMCOption.bTriangleWeight)
					{
						float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
						if (m_PMCOption.bUseSumOfLoss) fLoss += t_loss;
						else if (t_loss > fLoss) fLoss = t_loss;
					}
				}
				else if (tri[1] == i)
				{
					if (tri[0] != pt_to && tri[2] != pt_to) combine_modified(fLoss, tri, 1, pt_to, m_PMCOption.bUseSumOfLoss);
					else
						// tri collapses.
					if (m_PMCOption.bTriangleWeight)
					{
						float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
						if (m_PMCOption.bUseSumOfLoss) fLoss += t_loss;
						else if (t_loss > fLoss) fLoss = t_loss;
					}
				}
				else if (tri[2] == i)
				{
					if (tri[0] != pt_to && tri[1] != pt_to) combine_modified(fLoss, tri, 2, pt_to, m_PMCOption.bUseSumOfLoss);
					else
						// tri collapses.
					if (m_PMCOption.bTriangleWeight)
					{
						float t_loss = GetTriCollapsesLoss(tri, m_PMCOption.bArea) * m_PMCOption.fWeight;
						if (m_PMCOption.bUseSumOfLoss) fLoss += t_loss;
						else if (t_loss > fLoss) fLoss = t_loss;
					}
				}
			}
		}
	}
	return fLoss;
}
#endif // _SAME_VERTEXPOS

// ===== END N3Base/N3PMeshCreate.cpp =====

// ===== BEGIN N3Base/N3PMeshCreate.h =====
#line 1 "N3Base/N3PMeshCreate.h"
﻿// N3PMeshCreate.h: interface for the CN3PMeshCreate class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3PMeshCreate_h__INCLUDED_)
#define AFX_N3PMeshCreate_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "N3Base.h"

#define _SAME_VERTEXPOS

class CN3Mesh;
class CN3PMesh;
class CN3PMeshCreate
{
public:
	CN3PMeshCreate();
	virtual ~CN3PMeshCreate();

public:
	struct __PMCreateOption
	{
		bool	bUseSumOfLoss;		// Loss의 합을 사용할 것인가 아니면 ..
		bool	bTriangleWeight;	// 사라질 삼각형 가중치 계산 할 것인가?
		bool	bArea; // false = sum of side 가중치를 넓이로 할 것인가? 세 변의 합으로 할 것인가?
		float	fWeight; 	// 가중치
	};

protected:
	// An edge collapse. No-one but this module needs to see this.
	struct __PMCEdgeCollapse
	{
		float Value;
		//PMCMaterial *Material;
		int NumTrianglesToLose, NumIndicesToChange, NumVerticesToLose;
		int *IndexChanges;
		int CollapseTo;
	};
// Helper function
	void swap_triangle(uint16_t *t1, uint16_t *t2);
	float GetTriCollapsesLoss(uint16_t* pTriIndex, bool bArea);
	void combine_modified(float &sofar, uint16_t *tri, int which, int what_to, bool bSumOfLoss);

public:
	int ReGenerate(CN3PMesh* pPMesh); // 다시 생성한다..
	// Do the calculation
	void CreateCollapseList();

	// Then output a mesh for the renderer (this could be saved to disk)
	CN3PMesh* CreateRendererMesh();

	__PMCreateOption m_PMCOption;

	// N3Mesh -> CN3PMeshCreate 로 컨버팅..
	bool ConvertFromN3Mesh(CN3Mesh* pN3Mesh);
	bool ConvertFromN3PMesh(CN3PMesh* pN3PMesh);

	void Release();

protected:
	// For internal use:

	// There is a list of all the index changes in all collapses
	int m_iTotalIndexChanges;
	int *m_pAllIndexChanges;

	// These are all the collapses, in reverse order (highest resolution mesh collapse first)
	__PMCEdgeCollapse *m_pCollapses, *m_pCollapseUpTo;

	bool FindACollapse(float &val_so_far);
	void TryEdge(int pt_a, int pt_b,
				 float &be_val,
				 uint16_t &be_a,
				 uint16_t &be_b,
				 bool &IsOver);
	void Collapse(uint16_t& pt_to, uint16_t& pt_from, float edge_val);

// mesh 정보
protected:

	// A material is an array of vertices and an array of triangles (which is an array of 3x as many indices)
	// Fill these in with your raw mesh data.
	__VertexT1* m_pVertices;
	uint16_t* m_pIndices;
	int m_iNumVertices, m_iNumIndices;


	// After collapse, NumVertices will be the lowest detail level and OriginalNumVertices the original highest
	int m_iOriginalNumVertices, m_iOriginalNumIndices;

	// Internal to collapse code.
	void SwapToEnd(uint16_t swapper, __PMCEdgeCollapse *collapses, __PMCEdgeCollapse *collapses_end, uint16_t &pt_to, uint16_t &pt_from);

#ifdef _SAME_VERTEXPOS
	float GetLossOfSamePosVertex(uint16_t pt_to, uint16_t pt_from);
#endif // _SAME_VERTEXPOS

};

#endif // !defined(AFX_N3PMeshCreate_h__INCLUDED_)

// ===== END N3Base/N3PMeshCreate.h =====

// ===== BEGIN N3Base/N3PMeshInstance.cpp =====
#line 1 "N3Base/N3PMeshInstance.cpp"
﻿// N3PMeshInstance.cpp: implementation of the CN3PMeshInstance class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3PMeshInstance.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
//
// an instance of a mesh. Each version of each mesh that is rendered at a 
// separate level of detail needs one of these.

// Each instance is tied to the original mesh that it represents.
CN3PMeshInstance::CN3PMeshInstance()
{
	m_pPMesh = nullptr;
	m_pIndices = nullptr;
	m_iNumVertices = 0;
	m_iNumIndices  = 0;
	m_pCollapseUpTo = nullptr;
}

CN3PMeshInstance::CN3PMeshInstance(CN3PMesh *pN3PMesh)
{
	m_pPMesh = nullptr;

	m_pIndices = nullptr;
	m_iNumVertices = 0;
	m_iNumIndices  = 0;
	m_pCollapseUpTo = nullptr;

	CN3PMeshInstance::Create(pN3PMesh);
}

CN3PMeshInstance::CN3PMeshInstance(const std::string& szFN)
{
	m_pPMesh = nullptr;

	m_pIndices = nullptr;
	m_iNumVertices = 0;
	m_iNumIndices  = 0;
	m_pCollapseUpTo = nullptr;

	this->Create(szFN);
}

CN3PMeshInstance::~CN3PMeshInstance()
{
	delete [] m_pIndices; m_pIndices = nullptr;
	s_MngPMesh.Delete(&m_pPMesh);
}

void CN3PMeshInstance::Release()
{
	if (m_pIndices)	{ delete[] m_pIndices;m_pIndices = nullptr;}

	s_MngPMesh.Delete(&m_pPMesh);
	m_pCollapseUpTo = nullptr;
	m_iNumVertices = 0;
	m_iNumIndices = 0;
}

bool CN3PMeshInstance::Create(CN3PMesh* pN3PMesh)
{
	if(pN3PMesh == nullptr)
	{
		CN3PMeshInstance::Release();
		return false;
	}

	m_pPMesh = pN3PMesh;
	m_szName = pN3PMesh->m_szName;

	// And setup my instance-specific data.
	// We start with the lowest level of detail.
	int iMaxNumIndices = m_pPMesh->GetMaxNumIndices();
	if (iMaxNumIndices>0)
	{
		if(m_pIndices) delete [] m_pIndices; m_pIndices = nullptr;
		m_pIndices = new uint16_t[m_pPMesh->m_iMaxNumIndices];
		__ASSERT(m_pIndices, "Failed to create index buffer");
		CopyMemory(m_pIndices, m_pPMesh->m_pIndices, m_pPMesh->m_iMaxNumIndices * sizeof(uint16_t));
	}

	// lowest level of detail right now.
	m_iNumVertices = m_pPMesh->GetMinNumVertices();
	m_iNumIndices  = m_pPMesh->GetMinNumIndices();

	// So far, we're at the last collapse
	m_pCollapseUpTo = m_pPMesh->m_pCollapses;

	return true;
}

bool CN3PMeshInstance::Create(const std::string& szFN)
{
	if (m_pPMesh && m_pPMesh->FileName() == szFN) return true;	// 파일 이름이 같으면 새로 만들지 않고 리턴하자
	this->Release();

	CN3PMesh* pN3PMesh = s_MngPMesh.Get(szFN);
	return this->Create(pN3PMesh);
}

void CN3PMeshInstance::SetLODByNumVertices(int iNumVertices)
{
	if(m_pCollapseUpTo == nullptr) return;

	int iDiff = iNumVertices - m_iNumVertices;

	if(iDiff == 0)
	{
		return;
	}
	else if (iDiff > 0)
	{
		while(iNumVertices > m_iNumVertices)
		{
			if (m_pCollapseUpTo->NumVerticesToLose + m_iNumVertices > iNumVertices) break;		// 깜박임 방지 코드..
			if (SplitOne() == false) break;
		}
	}
	else if (iDiff < 0)
	{
		iDiff = -iDiff;
		while(iNumVertices < m_iNumVertices)
		{
			if (CollapseOne() == false) break;
		}
	}

	while(m_pCollapseUpTo->bShouldCollapse)
	{
		if (SplitOne() == false) break;
	}
}

void CN3PMeshInstance::SetLOD(float value)
{
#define _USE_LODCONTROL_VALUE
#ifdef _USE_LODCONTROL_VALUE
	// value는 distance * FOV이다.
	if (m_pPMesh == nullptr ) return;

	if (m_pPMesh->m_iLODCtrlValueCount == 0)
	{	// LODCtrlValue가 없으면 모두 그린다.
		SetLODByNumVertices(0x7fffffff);
		return;
	}
	
	__ASSERT(m_pPMesh->m_pLODCtrlValues, "LOD control value is NULL!");

	CN3PMesh::__LODCtrlValue* pTmpLODCV = m_pPMesh->m_pLODCtrlValues + m_pPMesh->m_iLODCtrlValueCount-1;

	if (value < m_pPMesh->m_pLODCtrlValues[0].fDist)
	{		// 최소 기준치보다 가까우므로 가장 많은 면으로 그린다.
		SetLODByNumVertices(m_pPMesh->m_pLODCtrlValues[0].iNumVertices);
	}
	else if ( pTmpLODCV->fDist < value)
	{		// 최대 기준치보다 멀리 있으므로 가장 적은 면으로 그린다.
		SetLODByNumVertices(pTmpLODCV->iNumVertices);
	}
	else
	{		// 중간 값에 맞게 조정된 면 수로 그린다.
		for (int i=1; i< m_pPMesh->m_iLODCtrlValueCount; ++i)
		{
			if (value < m_pPMesh->m_pLODCtrlValues[i].fDist)
			{
				CN3PMesh::__LODCtrlValue* pHiValue = m_pPMesh->m_pLODCtrlValues + i;
				CN3PMesh::__LODCtrlValue* pLowValue = pHiValue - 1;
				float fVertices = (pHiValue->iNumVertices - pLowValue->iNumVertices)*
									(value - pLowValue->fDist)/(pHiValue->fDist - pLowValue->fDist);
				SetLODByNumVertices(pLowValue->iNumVertices + (int)fVertices);
				break;
			}
		}
	}
#else
	// value는 distance * FOV이다.
	if (m_pCollapseUpTo == nullptr || m_pPMesh == nullptr) return;

	const int iLODCtrlValueCount = 5;
	__PMLODCtrlValue LODCtrlValues[iLODCtrlValueCount];
	__PMLODCtrlValue* pTmpLODCV = &(LODCtrlValues[iLODCtrlValueCount-1]);

	int iMaxNumVertices = m_pPMesh->GetMaxNumVertices();
	int iMinNumVertices = m_pPMesh->GetMinNumVertices();
	int iDiff = iMaxNumVertices - iMinNumVertices;
	
	float fVolume = m_pPMesh->GetVolume();
	float fD = (sqrtf(fVolume)*3.0f) / (value * 1.0f);
	fD = 1.0f;
//	float fD = fVolume/(value*13.0f) * (400.0f/(float)iMaxNumVertices);
	if(fD > 1.0f) SetLODByNumVertices(iMaxNumVertices);
	else if(fD < 0.1f) SetLODByNumVertices(iMinNumVertices);
	else SetLODByNumVertices(iMinNumVertices + (int)(iDiff * fD));

#endif
}

bool CN3PMeshInstance::CollapseOne()
{
	if (m_pCollapseUpTo <= m_pPMesh->m_pCollapses) return false;

	m_pCollapseUpTo--;

	m_iNumIndices -= m_pCollapseUpTo->NumIndicesToLose;
	
	for (	int *i = m_pPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges;
			i < m_pPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges + m_pCollapseUpTo->NumIndicesToChange;
			i++)
	{
		m_pIndices[*i] = m_pCollapseUpTo->CollapseTo;
	}

	m_iNumVertices -= m_pCollapseUpTo->NumVerticesToLose;

	return true;
}

bool CN3PMeshInstance::SplitOne()
{
	if (m_pCollapseUpTo >= m_pPMesh->m_pCollapses + m_pPMesh->m_iNumCollapses) return false; // 이렇게 하면 포인터 하나가 삐져 나오게 된다..
	// 하지만 이렇게 다시 하는 이유는 아래 코드로 하면 마지막 폴리곤이 절대 그려지지 않는다.
	// 이렇게 해도 괜찮을 수 있도록 방어코드를 넣었다. m_pPMesh->m_pCollapses 를 할당할때 1개 더 할당하고 마지막 데이터를 초기값으로 넣었다.
//	if (m_pCollapseUpTo >= m_pPMesh->m_pCollapses + m_pPMesh->m_iNumCollapses - 1) return false; // 이게 정상이다..

	m_iNumIndices  += m_pCollapseUpTo->NumIndicesToLose;
	m_iNumVertices += m_pCollapseUpTo->NumVerticesToLose;

	if(m_pPMesh->m_pAllIndexChanges)
	{
		for (	int *i = m_pPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges;
				i < m_pPMesh->m_pAllIndexChanges + m_pCollapseUpTo->iIndexChanges + m_pCollapseUpTo->NumIndicesToChange;
				i++)
		{
			m_pIndices[*i] = m_iNumVertices - 1;
		}
	}

	m_pCollapseUpTo++;
	return true;
}

void CN3PMeshInstance::Render()
{
	if (m_pPMesh == nullptr) return;
	s_lpD3DDev->SetFVF(FVF_VNT1);

	const int iPCToRender = 1000;	// primitive count to render

	if(m_iNumIndices > 3)
	{
		int iPC = m_iNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
	}
}

void CN3PMeshInstance::RenderTwoUV()
{
	if(nullptr == m_pPMesh) return;
	if(nullptr == m_pPMesh->GetVertices2())
	{
		m_pPMesh->GenerateSecondUV(); // 두번째 UV 가 없음 새로 만든다..
	}
	if(nullptr == m_pPMesh->GetVertices2()) return;
	
	s_lpD3DDev->SetFVF(FVF_VNT2);

	const int iPCToRender = 1000;	// primitive count to render

	if(m_iNumIndices > 3)
	{
		int iPC = m_iNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices2, sizeof(__VertexT2));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices2, sizeof(__VertexT2));
	}
}

__VertexT1*	CN3PMeshInstance::GetVertices() const
{
	if (m_pPMesh == nullptr) return nullptr;
	return m_pPMesh->m_pVertices;
}

//	By : Ecli666 ( On 2002-08-06 오후 4:33:04 )
//
void CN3PMeshInstance::PartialRender(int iCount, uint16_t* pIndices)
{
	if (m_pPMesh == nullptr) return;
	s_lpD3DDev->SetFVF(FVF_VNT1);
	const int iPCToRender = 1000;	// primitive count to render

/*	if(m_iNumIndices > 3)
	{
		int iPC = m_iNumIndices / 3;

		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, m_pIndices + i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
	}
*/

	if(iCount > 3)
	{
		int iPC = iCount / 3;
		int iLC = iPC / iPCToRender;
		int i;
		for (i=0; i<iLC; ++i)
		{
			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iPCToRender, pIndices+i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
		}

		int iRPC = iPC%iPCToRender;
		if(iRPC > 0) s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_iNumVertices, iRPC, pIndices+i*iPCToRender*3, D3DFMT_INDEX16, m_pPMesh->m_pVertices, sizeof(__VertexT1));
	}
}

int CN3PMeshInstance::GetIndexByiOrder(int iOrder)
{
	if (iOrder >= GetNumIndices()) 
		return 0;

	return m_pIndices[iOrder];
}

__Vector3 CN3PMeshInstance::GetVertexByIndex(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= GetNumVertices())
	{
		__Vector3 vec;
		vec.Zero();
		return vec;
	}

	return GetMesh()->m_pVertices[iIndex];
}

//	~(By Ecli666 On 2002-08-06 오후 4:33:04 )


// ===== END N3Base/N3PMeshInstance.cpp =====

// ===== BEGIN N3Base/N3PMeshInstance.h =====
#line 1 "N3Base/N3PMeshInstance.h"
﻿// N3PMeshInstance.h: interface for the CN3PMeshInstance class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3PMeshInstance_h__INCLUDED_)
#define AFX_N3PMeshInstance_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include "N3PMesh.h"

#include <string>

// Every instance of the mesh in the game needs one of these structures. They
// encode the level of detail being used to render at the moment.
class CN3PMeshInstance : public CN3Base
{
public:
	CN3PMeshInstance();
	CN3PMeshInstance(CN3PMesh *pN3PMesh);
	CN3PMeshInstance(const std::string& szFN);
	virtual ~CN3PMeshInstance();

protected:
	uint16_t* m_pIndices;

	int m_iNumIndices, m_iNumVertices; // number of triangles/vertices to use at this moment.

	CN3PMesh::__EdgeCollapse*	m_pCollapseUpTo;	// 참조 포인터

	// A pointer to the original mesh. This is where you'll find the vertex data (which
	// is invariant between PMRInstance's)
	CN3PMesh*	m_pPMesh;	// 참조 포인터

public:
	BOOL		IsLOD() { if(nullptr == m_pCollapseUpTo) return FALSE; return TRUE; }
	bool		Create(CN3PMesh* pN3Mesh);
	bool		Create(const std::string& szFN);
	void		Release();
	void		Render();
	void		RenderTwoUV();
	// The value you pass into this could be based on distance from camera, frame rate, etc
	void		SetLOD(float value); // value = Camera Distance / Camera FOV;

	// Or you can choose to collapse/split one step at a time. These return false if there was
	// no more collapsing/splitting to do.
	bool		CollapseOne();
	bool		SplitOne();

	void		SetLODByNumVertices(int iNumVertices);
	int			GetNumVertices() const {return m_iNumVertices;};
	int			GetNumIndices() const {return m_iNumIndices;};
	CN3PMesh*	GetMesh() {return m_pPMesh;};

	__VertexT1*	GetVertices() const;
	uint16_t*		GetIndices() const { return m_pIndices;};

//	By : Ecli666 ( On 2002-08-06 오후 4:33:04 )
//
	void			PartialRender(int iCount, uint16_t* pIndices);
	int				GetIndexByiOrder(int iOrder);
	__Vector3		GetVertexByIndex(int iIndex);
//	~(By Ecli666 On 2002-08-06 오후 4:33:04 )
};

#endif // !defined(AFX_N3PMeshInstance_h__INCLUDED_)

// ===== END N3Base/N3PMeshInstance.h =====

// ===== BEGIN N3Base/N3Scene.cpp =====
#line 1 "N3Base/N3Scene.cpp"
﻿// N3Scene.cpp: implementation of the CN3Scene class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Scene.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Scene::CN3Scene()
{
	m_dwType |= OBJ_SCENE;

	memset(m_pCameras, 0, sizeof(m_pCameras));
	memset(m_pLights, 0, sizeof(m_pLights));

	m_nCameraActive = 0;

	m_fFrmCur = 0.0f; // Animation Frame;
	m_fFrmStart = 0.0f; // 전체 프레임.
	m_fFrmEnd = 1000.0f; // 기본값 프레임.

	m_nCameraCount = 0; 
	m_nLightCount = 0;

	m_bDisableDefaultLight = false;

	m_AmbientLightColor = 0;
}

CN3Scene::~CN3Scene()
{
	int i = 0;
	for(i = 0; i < MAX_SCENE_CAMERA; i++) { if(m_pCameras[i]) { delete m_pCameras[i]; m_pCameras[i] = nullptr; } }
	for(i = 0; i < MAX_SCENE_LIGHT; i++) { if(m_pLights[i]) { delete m_pLights[i]; m_pLights[i] = nullptr; } }
	
	this->ShapeRelease();
	this->ChrRelease();
}

void CN3Scene::Release()
{
	m_nCameraActive = 0;

	m_fFrmCur = 0.0f; // Animation Frame;
	m_fFrmStart = 0.0f; // 전체 프레임.
	m_fFrmEnd = 1000.0f; // 기본값 프레임.

	int i = 0;
	for(i = 0; i < MAX_SCENE_CAMERA; i++) { if(m_pCameras[i]) { delete m_pCameras[i]; m_pCameras[i] = nullptr; } }
	for(i = 0; i < MAX_SCENE_LIGHT; i++) { if(m_pLights[i]) { delete m_pLights[i]; m_pLights[i] = nullptr; } }
	this->ShapeRelease();
	this->ChrRelease();

	m_nCameraCount = 0; 
	m_nLightCount = 0;

	m_bDisableDefaultLight = false;
}

bool CN3Scene::Load(File& file)
{
	file.Read(&m_nCameraActive, 4);
	file.Read(&m_fFrmCur, 4); // Animation Frame;
	file.Read(&m_fFrmStart, 4); // 전체 프레임.
	file.Read(&m_fFrmEnd, 4); // 전체 프레임.

	int i = 0, nL = 0;
	char szName[512] = "";

	int nCC = 0;
	file.Read(&nCC, 4); // 카메라..
	for(i = 0; i < nCC; i++)
	{
		file.Read(&nL, 4);
		if(nL <= 0) continue;

		file.Read(szName, nL);
		szName[nL] = '\0';

		CN3Camera* pCamera = new CN3Camera();
		if(false == pCamera->LoadFromFile(szName))
		{
			delete pCamera;
			continue;
		}

		this->CameraAdd(pCamera);
	}

	int nLC = 0;
	file.Read(&nLC, 4); // 카메라..
	for(i = 0; i < nLC; i++) 
	{
		file.Read(&nL, 4);
		if(nL <= 0) continue;

		file.Read(szName, nL);
		szName[nL] = '\0';

		CN3Light* pLight = new CN3Light();
		if(false == pLight->LoadFromFile(szName))
		{
			delete pLight;
			continue;
		}
		
		this->LightAdd(pLight);
	}

	int nSC = 0;
	file.Read(&nSC, 4); // Shapes..
	for(i = 0; i < nSC; i++)
	{
		file.Read(&nL, 4);
		if(nL <= 0) continue;

		file.Read(szName, nL);
		szName[nL] = '\0';

		CN3Shape* pShape = new CN3Shape();
		if(false == pShape->LoadFromFile(szName))
		{
			delete pShape;
			continue;
		}

		this->ShapeAdd(pShape);
	}

	int nChrC = 0;
	file.Read(&nChrC, 4); // 캐릭터
	for(i = 0; i < nChrC; i++)
	{
		file.Read(&nL, 4);
		if(nL <= 0) continue;

		file.Read(szName, nL);
		szName[nL] = '\0';

		CN3Chr* pChr = new CN3Chr();
		if(false == pChr->LoadFromFile(szName))
		{
			delete pChr;
			continue;
		}

		this->ChrAdd(pChr);
	}

	if(m_nCameraCount <= 0) this->DefaultCameraAdd();
	if(m_nLightCount <= 0) this->DefaultLightAdd();

	return true;
}

bool CN3Scene::Save(File& file)
{
	std::error_code ec;
	std::filesystem::create_directory(PathGet() + "/Data", ec);
	std::filesystem::create_directory(PathGet() + "/Chr", ec);
	std::filesystem::create_directory(PathGet() + "/Object", ec);
	std::filesystem::create_directory(PathGet() + "/Item", ec);
	
	file.Write(&m_nCameraActive, 4);
	file.Write(&m_fFrmCur, 4); // Animation Frame;
	file.Write(&m_fFrmStart, 4); // 전체 프레임.
	file.Write(&m_fFrmEnd, 4); // 전체 프레임.
	
	file.Write(&m_nCameraCount, 4); // 카메라..
	for (CN3Camera* camera : m_pCameras)
	{
		int nL = static_cast<int>(camera->FileName().size());
		file.Write(&nL, 4);
		file.Write(camera->FileName().c_str(), nL);
		camera->SaveToFile();
	}

	file.Write(&m_nLightCount, 4); // 카메라..
	for (CN3Light* light : m_pLights)
	{
		int nL = static_cast<int>(light->FileName().size());
		file.Write(&nL, 4);
		file.Write(light->FileName().c_str(), nL);
		light->SaveToFile();
	}

	int iSC = static_cast<int>(m_Shapes.size());
	file.Write(&iSC, 4); // Shapes..
	for (CN3Shape* shape : m_Shapes)
	{
		int nL = static_cast<int>(shape->FileName().size());
		file.Write(&nL, 4);
		if (nL <= 0)
			continue;

		file.Write(shape->FileName().c_str(), nL);
		shape->SaveToFile();
	}

	int iCC = static_cast<int>(m_Chrs.size());
	file.Write(&iCC, 4); // 캐릭터
	for (CN3Chr* chr : m_Chrs)
	{
		int nL = static_cast<int>(chr->FileName().size());
		file.Write(&nL, 4);
		if (nL <= 0)
			continue;

		file.Write(chr->FileName().c_str(), nL);
		chr->SaveToFile();
	}

	CN3Base::SaveResrc(); // Resource 를 파일로 저장한다..
	return true;
}

void CN3Scene::Render()
{
	int i = 0;
//	for(i = 0; i < m_nCameraCount; i++)
//	{
//		__ASSERT(m_pCameras[i], "Camera pointer is NULL");
//		if(m_nCameraActive != i) m_pCameras[i]->Render();
//	}

//	for(i = 0; i < m_nLightCount; i++)
//	{
//		__ASSERT(m_pLights[i], "Light pointer is NULL");
//		m_pLights[i]->Render(nullptr, 0.5f);
//	}
	s_lpD3DDev->SetRenderState(D3DRS_AMBIENT, m_AmbientLightColor);

	for (CN3Shape* shape : m_Shapes)
		shape->Render();

	for (CN3Chr* chr : m_Chrs)
		chr->Render();
}

void CN3Scene::Tick(float fFrm)
{
	if (FRAME_SELFPLAY == fFrm
		|| fFrm < m_fFrmStart
		|| fFrm > m_fFrmEnd)
	{
		m_fFrmCur += 30.0f / CN3Base::s_fFrmPerSec; // 일정하게 움직이도록 시간에 따라 움직이는 양을 조절..
		if (m_fFrmCur > m_fFrmEnd)
			m_fFrmCur = m_fFrmStart;
	}
	else
	{
		m_fFrmCur = fFrm;
	}

	TickCameras(m_fFrmCur);
	TickLights(m_fFrmCur);
	TickShapes(m_fFrmCur);
	TickChrs(m_fFrmCur);
}

void CN3Scene::TickCameras(float fFrm)
{
	for (int i = 0; i < m_nCameraCount; i++)
	{
		m_pCameras[i]->Tick(m_fFrmCur);
		if (m_nCameraActive == i)
			m_pCameras[i]->Apply(); // 카메라 데이터 값을 적용한다..
	}
}

void CN3Scene::TickLights(float fFrm)
{
	for (int i = 0; i < 8; i++)
		s_lpD3DDev->LightEnable(i, FALSE); // 일단 라이트 다 끄고..

	for (int i = 0; i < m_nLightCount; i++)
	{
		m_pLights[i]->Tick(m_fFrmCur);
		m_pLights[i]->Apply(); // 라이트 적용
	}

	// 라이트가 항상 카메라를 따라오게 만든다..
	if (!m_bDisableDefaultLight)
	{
		__Vector3 vDir = s_CameraData.vAt - s_CameraData.vEye;
		vDir.Normalize();

		__ColorValue crLgt = { 1.0f, 1.0f, 1.0f, 1.0f };

		CN3Light::__Light lgt;
		lgt.InitDirection(7, vDir, crLgt);

		s_lpD3DDev->LightEnable(7, TRUE);
		s_lpD3DDev->SetLight(7, lgt.toD3D());
	}

	// Ambient Light 바꾸기..
//	uint32_t dwAmbient =	0xff000000 | 
//						(((uint32_t)(m_pLights[i]->m_Data.Diffuse.r * 255 * 0.5f)) << 16) | 
//						(((uint32_t)(m_pLights[i]->m_Data.Diffuse.g * 255 * 0.5f)) << 8) | 
//						(((uint32_t)(m_pLights[i]->m_Data.Diffuse.b * 255 * 0.5f)) << 0);
//	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_AMBIENT, dwAmbient);
}

void CN3Scene::TickShapes(float fFrm)
{
	for (CN3Shape* shape : m_Shapes)
		shape->Tick(m_fFrmCur);
}

void CN3Scene::TickChrs(float fFrm)
{
	for (CN3Chr* chr : m_Chrs)
		chr->Tick(m_fFrmCur);
}

int CN3Scene::CameraAdd(CN3Camera* pCamera)
{
	if (m_nCameraCount < 0
		|| m_nCameraCount >= MAX_SCENE_CAMERA)
		return -1;

	if (pCamera == nullptr)
		return -1;

	delete m_pCameras[m_nCameraCount];
	m_pCameras[m_nCameraCount] = pCamera;

	m_nCameraCount++;
	return m_nCameraCount;
}

void CN3Scene::CameraDelete(int iIndex)
{
	if(iIndex < 0 || iIndex >= m_nCameraCount) return;

	delete m_pCameras[iIndex];
	m_pCameras[iIndex] = nullptr;
	
	m_nCameraCount--;
	for(int i = iIndex; i < m_nCameraCount; i++) m_pCameras[i] = m_pCameras[i+1];
	m_pCameras[m_nCameraCount] = nullptr;
}

void CN3Scene::CameraDelete(CN3Camera* pCamera)
{
	for (int i = 0; i < m_nCameraCount; i++)
	{
		if (m_pCameras[i] == pCamera)
		{
			CameraDelete(i);
			break;
		}
	}
}

void CN3Scene::CameraSetActive(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= m_nCameraCount)
		return;

	m_nCameraActive = iIndex;
}

int CN3Scene::LightAdd(CN3Light* pLight)
{
	if (pLight == nullptr)
		return -1;

	delete m_pLights[m_nLightCount];
	m_pLights[m_nLightCount] = pLight;

	m_nLightCount++;
	return m_nLightCount;
}

void CN3Scene::LightDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= m_nLightCount)
		return;

	delete m_pLights[iIndex];
	m_pLights[iIndex] = nullptr;

	m_nLightCount--;
	for (int i = iIndex; i < m_nLightCount; i++)
		m_pLights[i] = m_pLights[i + 1];

	m_pLights[m_nLightCount] = nullptr;
}

void CN3Scene::LightDelete(CN3Light* pLight)
{
	for (int i = 0; i < m_nLightCount; i++)
	{
		if (m_pLights[i] == pLight)
		{
			LightDelete(i);
			break;
		}
	}
}

int CN3Scene::ShapeAdd(CN3Shape* pShape)
{
	if (pShape == nullptr)
		return -1;

	m_Shapes.push_back(pShape);
	return static_cast<int>(m_Shapes.size());
}

void CN3Scene::ShapeDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Shapes.size()))
		return;

	auto it = m_Shapes.begin();
	std::advance(it, iIndex);

	delete *it;
	m_Shapes.erase(it);
}

void CN3Scene::ShapeDelete(CN3Shape* pShape)
{
	auto it = m_Shapes.begin(), itEnd = m_Shapes.end();
	for (; it != itEnd; it++)
	{
		CN3Shape* pShapeSrc = *it;
		if (pShapeSrc == pShape)
		{
			delete pShapeSrc;
			it = m_Shapes.erase(it);
			return;
		}
	}
}

void CN3Scene::ShapeRelease()
{
	for (CN3Shape* shape : m_Shapes)
		delete shape;

	m_Shapes.clear();
}

int CN3Scene::ChrAdd(CN3Chr* pChr)
{
	if (pChr == nullptr)
		return -1;

	m_Chrs.push_back(pChr);
	return static_cast<int>(m_Chrs.size());
}

void CN3Scene::ChrDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Chrs.size()))
		return;

	auto it = m_Chrs.begin();
	std::advance(it, iIndex);

	delete *it;
	m_Chrs.erase(it);
}

void CN3Scene::ChrDelete(CN3Chr* pChr)
{
	it_Chr it = m_Chrs.begin(), itEnd = m_Chrs.end();
	CN3Chr* pChrSrc;
	for(; it != itEnd; it++);
	{
		pChrSrc = *it;
		if(pChr == pChrSrc) 
		{
			delete pChrSrc;
			m_Chrs.erase(it);
			return;
		}
	}
}

void CN3Scene::ChrRelease()
{
	for (CN3Chr* pChr : m_Chrs)
		delete pChr;
	m_Chrs.clear();
}

bool CN3Scene::LoadDataAndResourcesFromFile(const std::string& szFN)
{
	if(szFN.empty()) return false;

	char szPath[512] = "", szDrv[_MAX_DRIVE] = "", szDir[_MAX_DIR] = "";
	::_splitpath(szFN.c_str(), szDrv, szDir, nullptr, nullptr);
	::_makepath(szPath, szDrv, szDir, nullptr, nullptr);

	this->Release();
	this->PathSet(szPath);
	return LoadFromFile(szFN);
}

bool CN3Scene::SaveDataAndResourcesToFile(const std::string& szFN)
{
	if(szFN.empty()) return false;

	char szPath[512] = "", szDrv[_MAX_DRIVE] = "", szDir[_MAX_DIR] = "";
	::_splitpath(szFN.c_str(), szDrv, szDir, nullptr, nullptr);
	::_makepath(szPath, szDrv, szDir, nullptr, nullptr);

	this->PathSet(szPath);
	return SaveToFile(szFN);
}

void CN3Scene::DefaultCameraAdd()
{
	CN3Camera* pCamera = new CN3Camera();
	pCamera->m_szName = "DefaultCamera";
	pCamera->FileNameSet("Data\\DefaultCamera.N3Camera");
	this->CameraAdd(pCamera);
}
void CN3Scene::DefaultLightAdd()
{
	// Light 초기화..
	CN3Light* pLight = new CN3Light();
	pLight->m_szName = "DefaultLight";
	pLight->FileNameSet("Data\\DefaultLight.N3Light");
	int nLight = this->LightAdd(pLight) - 1;

	__ColorValue ltColor = { 0.7f, 0.7f, 0.7f, 1.0f};
	pLight->m_Data.InitDirection(0, { -1.0f, -1.0f, 0.5f }, ltColor);
	pLight->PosSet(1000.0f, 1000.0f, -1000.0f);
	pLight->m_Data.bOn = TRUE;
	pLight->m_Data.nNumber = nLight;
}


// ===== END N3Base/N3Scene.cpp =====

// ===== BEGIN N3Base/N3Scene.h =====
#line 1 "N3Base/N3Scene.h"
﻿// N3Scene.h: interface for the CN3Scene class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Scene_h__INCLUDED_)
#define AFX_N3Scene_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Camera.h"
#include "N3Light.h"
#include "N3Shape.h"
#include "N3Chr.h"
#include "N3Mesh.h"

const int MAX_SCENE_CAMERA = 32;
const int MAX_SCENE_LIGHT = 32;
const int MAX_SCENE_SHAPE = 10240;
const int MAX_SCENE_CHARACTER = 4096;

#include <vector>

typedef std::vector<class CN3Shape*>::iterator	it_Shape;
typedef std::vector<class CN3Chr*>::iterator	it_Chr;

class CN3Scene : public CN3BaseFileAccess
{
public:
	float			m_fFrmCur, m_fFrmStart, m_fFrmEnd; // 현재, 시작, 끝 프레임..
	bool			m_bDisableDefaultLight; // 참이면 기본라이트를 끈다..
	D3DCOLOR		m_AmbientLightColor;

protected:
	int				m_nCameraActive; // 현재 선택된 카메라..
	int				m_nCameraCount;
	int				m_nLightCount;

	class CN3Camera*			m_pCameras[MAX_SCENE_CAMERA];
	class CN3Light*				m_pLights[MAX_SCENE_LIGHT];
	std::vector<class CN3Shape*>	m_Shapes;
	std::vector<class CN3Chr*>		m_Chrs;
	
public:
	void DefaultCameraAdd();
	void DefaultLightAdd();
	
	bool LoadDataAndResourcesFromFile(const std::string& szFileName);
	bool SaveDataAndResourcesToFile(const std::string& szFileName);

//	bool CheckOverlappedShapesAndReport();
//	void DeleteOverlappedShapes();

	void Tick(float fFrm = FRAME_SELFPLAY);
	void TickCameras(float fFrm = FRAME_SELFPLAY);
	void TickLights(float fFrm = FRAME_SELFPLAY);
	void TickShapes(float fFrm = FRAME_SELFPLAY);
	void TickChrs(float fFrm = FRAME_SELFPLAY);
	void Render();
	
	int	CameraCount() const
	{
		return m_nCameraCount;
	}

	int	 CameraAdd(CN3Camera *pCamera);
	void CameraDelete(CN3Camera* pCamera);
	void CameraDelete(int iIndex);
	CN3Camera* CameraGet(int iIndex) { if(iIndex < 0 || iIndex >= m_nCameraCount) return nullptr; return m_pCameras[iIndex]; }
	
	void CameraSetActive(int iIndex);
	int	 CameraGetActiveNumber() { return m_nCameraActive; };
	CN3Camera* CameraGetActive() { if(m_nCameraActive < 0 || m_nCameraActive >= m_nCameraCount) return nullptr; return m_pCameras[m_nCameraActive]; }

	int	 LightCount() const
	{
		return m_nLightCount;
	}

	int	 LightAdd(CN3Light* pLight);
	void LightDelete(CN3Light* pLight);
	void LightDelete(int iIndex);
	CN3Light* LightGet(int iIndex) { if(iIndex < 0 || iIndex >= m_nLightCount) return nullptr; return m_pLights[iIndex]; }

	int ShapeCount() const
	{
		return static_cast<int>(m_Shapes.size());
	}

	int	 ShapeAdd(CN3Shape* pShape);
	void ShapeDelete(CN3Shape* pShape);
	void ShapeDelete(int iIndex);
	CN3Shape* ShapeGet(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Shapes.size()))
			return nullptr;

		return m_Shapes[iIndex];
	}

	CN3Shape* ShapeGetByFileName(const std::string& str)
	{
		for (CN3Shape* shape : m_Shapes)
		{
			if (str == shape->FileName())
				return shape;
		}

		return nullptr;
	}

	void ShapeRelease();

	int ChrCount() const
	{
		return static_cast<int>(m_Chrs.size());
	}

	int	 ChrAdd(CN3Chr* pChr);
	void ChrDelete(int iIndex);
	void ChrDelete(CN3Chr* pChr);
	CN3Chr* ChrGet(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Chrs.size()))
			return nullptr;

		return m_Chrs[iIndex];
	}

	void ChrRelease();

	bool Load(File& file) override;
	bool Save(File& file) override;
	
	void Release() override;

	CN3Scene();
	~CN3Scene() override;
};

#endif // !defined(AFX_N3Scene_h__INCLUDED_)

// ===== END N3Base/N3Scene.h =====

// ===== BEGIN N3Base/N3Shape.cpp =====
#line 1 "N3Base/N3Shape.cpp"
﻿// N3Shape.cpp: implementation of the C3DObject class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Shape.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

/////////////////////////////
// CN3Shape Part ....
CN3SPart::CN3SPart()
{
	m_dwType |= OBJ_SHAPE_PART;

	m_vPivot.Set(0,0,0); // Local 축
	m_Matrix.Identity(); // World Matrix.. Shape Loading 때 미리 계산해야 좋다..		
	m_bOutOfCameraRange = TRUE; // Camera 범위 바깥에 있음...
	m_Mtl.Init(); // Material
	m_fTexFPS = 10.0f; // Texture Animation Interval;
	m_fTexIndex = 0; // Current Texture Index.. Animation 시킬때 필요한 인덱스이다..

//	m_vWindFactorCur.Zero();		// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
//	m_vWindFactorToReach.Zero();	// 바람 부는 값..
	m_fTimeToSetWind = 0;			// 바람 부는 값을 바꾸기 위한 시간..
	m_fWindFactorCur = 0;			// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
	m_fWindFactorToReach = 0;		// 바람 부는 값..
}

CN3SPart::~CN3SPart()
{
	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);
}

void CN3SPart::Release()
{
	m_vPivot.Set(0,0,0); // Local 축
	m_Matrix.Identity(); // World Matrix.. Shape Loading 때 미리 계산해야 좋다..		
	m_bOutOfCameraRange = TRUE; // Camera 범위 바깥에 있음...
	m_Mtl.Init(); // Material
	m_fTexFPS = 10.0f; // Texture Animation Interval;
	m_fTexIndex = 0; // Current Texture Index.. Animation 시킬때 필요한 인덱스이다..

//	m_vWindFactorCur.Zero();		// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
//	m_vWindFactorToReach.Zero();	// 바람 부는 값..
	m_fTimeToSetWind = 0;			// 바람 부는 값을 바꾸기 위한 시간..
	m_fWindFactorCur = 0;			// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
	m_fWindFactorToReach = 0;		// 바람 부는 값..

	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);

	m_TexRefs.clear();
	m_PMInst.Release();
}

void CN3SPart::MeshSet(const std::string& szFN)
{
	m_PMInst.Create(szFN);
}

void CN3SPart::TexAlloc(int nCount)
{
	if (nCount <= 0)
		return;

	for (size_t i = 0; i < m_TexRefs.size(); i++)
		s_MngTex.Delete(&m_TexRefs[i]);
	m_TexRefs.clear();

	m_TexRefs.assign(nCount, nullptr);
}

void CN3SPart::Tick(const __Matrix44& mtxParent, const __Quaternion& qRot, float fScale) // timeGetTime 으로 얻은 값을 넣으면 Texture Animation 을 컨트롤 한다..
{
	CN3PMesh* pPMesh = m_PMInst.GetMesh();
	if(nullptr == pPMesh) return;

	m_bOutOfCameraRange = FALSE;

	// 카메라와 멀리 떨어지면 지나간다..
	__Vector3 vCenter = (this->Min() + this->Max()) * 0.5f;
	if(s_CameraData.IsOutOfFrustum(vCenter, this->Radius() * fScale)) // 카메라 사면체 바깥이면 지나간다..
	{
		m_bOutOfCameraRange = TRUE;
		return;
	}
	
	float fDist = (vCenter - s_CameraData.vEye).Magnitude();
	float fLOD = fDist * s_CameraData.fFOV / fScale;
//	float fLOD = fDist + fDist * (s_CameraData.fFOV - 1.0f) / 3.0f;
//	float fLOD = fDist * s_CameraData.fFOV * (512.0f / s_CameraData.fFP);

	// 카메라 거리에 따라 LOD 수준을 조절한다.
//	fLOD *= 256.0f / s_CameraData.fFP;
	m_PMInst.SetLOD(fLOD);
	
	int iTC = static_cast<int>(m_TexRefs.size());
	if (iTC > 1) // 텍스처 에니메이션
	{
		m_fTexIndex += CN3Base::s_fSecPerFrm * m_fTexFPS;
		if (m_fTexIndex >= iTC)
			m_fTexIndex -= (iTC * m_fTexIndex) / iTC; // 정수로 나누면 소숫점만 남기게 된다??(하여튼 비슷해~)
	}

	if(m_Mtl.nRenderFlags & RF_BOARD_Y) // 카메라를 바라봐야하는 거면..
	{
		__Vector3 vPos = m_vPivot * mtxParent;
		__Vector3 vDir = s_CameraData.vEye - vPos;
		if( vDir.x > 0.0f ) m_Matrix.RotationY(-atanf(vDir.z/vDir.x) - (__PI * 0.5f));
		else m_Matrix.RotationY(-atanf(vDir.z/vDir.x) + (__PI * 0.5f));

		// 부모 회전과 반대로 회전을 시킨다..
		float fAngle;
		qRot.AxisAngle(vDir, fAngle);
		if(fAngle != 0)
		{
			__Quaternion qRotI;
			qRotI.RotationAxis(vDir, -fAngle);
			m_Matrix *= qRotI;
		}

		m_Matrix *= mtxParent;
		m_Matrix.PosSet(vPos);
	}

	if(m_Mtl.nRenderFlags & RF_WINDY) // 바람에 살짝 날려야 하면..
	{
		m_fTimeToSetWind -= CN3Base::s_fSecPerFrm;


		if(m_fTimeToSetWind <= 0)
		{
//			m_vWindFactorToReach.x = 0.05f - (0.1f * (rand()%100) / 100.0f);
//			m_vWindFactorToReach.y = 0.05f - (0.1f * (rand()%100) / 100.0f); // 위아래로는 조금만 불게 한다.
//			m_vWindFactorToReach.z = 0.05f - (0.1f * (rand()%100) / 100.0f);

			m_fWindFactorToReach = (rand()%100)/100.0f;
			m_fTimeToSetWind = 3.0f * ((rand()%100)/100.0f); // 바람이 지속될 값..
		}
		else if(m_fWindFactorToReach != m_fWindFactorCur)
//		else if(m_vWindFactorToReach != m_vWindFactorCur)
		{
//			float fFactor = s_fSecPerFrm * (m_vWindFactorToReach - m_vWindFactorCur).Magnitude();
			float fFactor = s_fSecPerFrm * std::abs(m_fWindFactorToReach - m_fWindFactorCur);

//			if(m_vWindFactorCur.x < m_vWindFactorToReach.x) m_vWindFactorCur.x += fFactor;
//			if(m_vWindFactorCur.x > m_vWindFactorToReach.x) m_vWindFactorCur.x -= fFactor;
//			if(m_vWindFactorCur.y < m_vWindFactorToReach.y) m_vWindFactorCur.y += fFactor;
//			if(m_vWindFactorCur.y > m_vWindFactorToReach.y) m_vWindFactorCur.y -= fFactor;
//			if(m_vWindFactorCur.z < m_vWindFactorToReach.z) m_vWindFactorCur.z += fFactor;
//			if(m_vWindFactorCur.z > m_vWindFactorToReach.z) m_vWindFactorCur.z -= fFactor;
			if(m_fWindFactorCur < m_fWindFactorToReach) m_fWindFactorCur += fFactor;
			if(m_fWindFactorCur > m_fWindFactorToReach) m_fWindFactorCur -= fFactor;

//			if(std::abs(m_vWindFactorToReach.x - m_vWindFactorCur.x) < fFactor) m_vWindFactorCur.x = m_vWindFactorToReach.x;
//			if(std::abs(m_vWindFactorToReach.y - m_vWindFactorCur.y) < fFactor) m_vWindFactorCur.y = m_vWindFactorToReach.y;
//			if(std::abs(m_vWindFactorToReach.z - m_vWindFactorCur.z) < fFactor) m_vWindFactorCur.z = m_vWindFactorToReach.z;
			if(std::abs(m_fWindFactorToReach - m_fWindFactorCur) < fFactor) m_fWindFactorCur = m_fWindFactorToReach;
			
			__Vector3 vPos = m_vPivot * mtxParent;
//			m_Matrix.Rotation(CN3Base::s_vWindFactor * m_fWindFactorCur);
			m_Matrix.Rotation(__Vector3(0.05f, 0.02f, 0.05f) * m_fWindFactorCur);
			m_Matrix *= mtxParent;
			m_Matrix.PosSet(vPos);
		}

	}
}

void CN3SPart::Render()
{
	if(m_bOutOfCameraRange || m_PMInst.GetNumVertices() <= 0) return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Part++; // Rendering Information Update...
#endif

	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	int iTC = static_cast<int>(m_TexRefs.size());
	if (iTC > 0)
	{
		int iTexIndex = (int) m_fTexIndex;
		if (iTexIndex >= 0 && iTexIndex < iTC && m_TexRefs[iTexIndex]) lpTex = m_TexRefs[iTexIndex]->Get();
	}

	if(m_Mtl.nRenderFlags & RF_ALPHABLENDING) // Alpha 사용
	{
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_Mtl.dwDestBlend;
			pAP->dwBlendSrc			= m_Mtl.dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - m_Matrix.Pos()).Magnitude();
			pAP->lpTex				= lpTex;
			pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMInst.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_Mtl.nRenderFlags;
			pAP->nVertexCount		= m_PMInst.GetNumVertices();
			pAP->MtxWorld			= m_Matrix;
			pAP->pVertices			= m_PMInst.GetVertices();
			pAP->pwIndices			= m_PMInst.GetIndices();
		}

		return; // 렌더링 안하지롱.
	}

//	static uint32_t dwAlpha, dwFog, dwCull;
	DWORD dwFog, dwCull;
//	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
//	if(TRUE != dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
//	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND,   m_Mtl.dwSrcBlend);
//	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND,  m_Mtl.dwDestBlend);

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Polygon += m_PMInst.GetNumIndices() / 3; // Rendering Information Update...
#endif

	if(m_Mtl.nRenderFlags & RF_NOTUSEFOG) // Fog 무시..
	{
		s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
		if(TRUE == dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	}
	if(m_Mtl.nRenderFlags & RF_DOUBLESIDED) // Render Flags - 
	{
		s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	}

	s_lpD3DDev->SetMaterial(&m_Mtl); // 재질 설정..
	s_lpD3DDev->SetTexture(0, lpTex);
	if(nullptr != lpTex)
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   m_Mtl.dwColorOp);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, m_Mtl.dwColorArg1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, m_Mtl.dwColorArg2);
	}
	else
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	}

	// 로딩할때 미리 계산해 놓은 월드 행렬 적용..
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	m_PMInst.Render();

//	if((m_Mtl.nRenderFlags & RF_ALPHABLENDING) && FALSE == dwAlpha)	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if((m_Mtl.nRenderFlags & RF_NOTUSEFOG) && TRUE == dwFog) 		s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, TRUE); // 안개 사용하지 않는다..
	if((m_Mtl.nRenderFlags & RF_DOUBLESIDED) && D3DCULL_NONE != dwCull) 		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);
}

#ifdef _N3TOOL
void CN3SPart::RenderSelected(bool bWireFrame)
{
	if (m_bOutOfCameraRange || m_PMInst.GetNumVertices() <= 0)
		return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Part++; // Rendering Information Update...
	CN3Base::s_RenderInfo.nShape_Polygon += m_PMInst.GetNumIndices() / 3;
#endif _DEBUG

	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	int iTC = static_cast<int>(m_TexRefs.size());
	if (iTC > 0)
	{
		int iTexIndex = (int) m_fTexIndex;
		if (iTexIndex >= 0 && iTexIndex < iTC && m_TexRefs[iTexIndex]) lpTex = m_TexRefs[iTexIndex]->Get();
	}

	s_lpD3DDev->SetTexture(0, lpTex);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
	if(lpTex != nullptr) s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	else s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);

	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());
	if(bWireFrame)
	{
		__Vector3 vLines[4];
		
		int nFC = m_PMInst.GetNumIndices() / 3;
		uint16_t* pwIndices = m_PMInst.GetIndices();
		__VertexT1* pVs = m_PMInst.GetVertices();

		for(int i = 0; i < nFC; i++)
		{
			vLines[0] = pVs[pwIndices[i*3+0]];
			vLines[1] = pVs[pwIndices[i*3+1]];
			vLines[2] = pVs[pwIndices[i*3+2]];
			vLines[3] = vLines[0];
			CN3Base::RenderLines(vLines, 3, 0xff00ff00);
		}
	}
	else m_PMInst.Render();
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3SPart::RenderAxis()
{
	// 축그리기..
	float fRadius = 1.0f;
	if(m_PMInst.GetMesh()) fRadius = m_PMInst.GetMesh()->Radius();
	static CN3Transform TTmp;
	TTmp.m_Matrix = m_Matrix;
	TTmp.Render(&m_Matrix, fRadius * 1.5f);
}
#endif // end of _N3TOOL

bool CN3SPart::Load(File& file)
{
	int nL = 0;
	char szFN[256];

	file.Read(&m_vPivot, sizeof(__Vector3));

	file.Read(&nL, 4); // Mesh FileName
	file.Read(szFN, nL); szFN[nL] = '\0'; // 메시 파일 이름..
	this->MeshSet(szFN);

	file.Read(&m_Mtl, sizeof(__Material)); // 재질

	int iTC = 0;
	file.Read(&iTC, 4);
	file.Read(&m_fTexFPS, 4);
	m_TexRefs.clear();
	this->TexAlloc(iTC); // Texture Pointer Pointer 할당..
	for(int j = 0; j < iTC; j++) // Texture Count 만큼 파일 이름 읽어서 텍스처 부르기..
	{
		file.Read(&nL, 4);
		if(nL > 0)
		{
			file.Read(szFN, nL); szFN[nL] = '\0'; // 텍스처 파일 이름..
			m_TexRefs[j] = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Shape);
		}
	}

	return true;
}

#ifdef _N3TOOL
bool CN3SPart::Save(File& file)
{
	file.Write(&m_vPivot, sizeof(__Vector3));

	CN3PMesh* pPMesh = m_PMInst.GetMesh();
	__ASSERT(pPMesh, "Progressive mesh pointer is NULL!");
	int nL = 0;
	if (pPMesh != nullptr)
		nL = static_cast<int>(pPMesh->FileName().size());
	else
		MessageBox(s_hWndBase, "Progressive mesh pointer is NULL! : object가 제대로 보이지 않을 수 있습니다.(리소스 파일이 Load되지 않았을 가능성이 큼)", "warning", MB_OK);

	file.Write(&nL, 4); // Mesh FileName
	if (nL > 0)
	{
		
//		if(-1 == pPMesh->FileName().find("object\\")) // 임시로 경로를 바꾸려고 넣었다.. 나중에 필요없음 지운다..
//		{
//			std::string szFNTmp = fmt::format("Object\\{}.N3PMesh", pPMesh->Name());
//			pPMesh->FileNameSet(szFNTmp);
//
//			SetFilePointer(hFile, -4, 0, FILE_CURRENT);
//			nL = pPMesh->FileName().size();
//			file.Write(&nL, 4); // Mesh FileName
//		}




		file.Write(pPMesh->FileName().c_str(), nL); // 메시 파일 이름..
	}

	file.Write(&m_Mtl, sizeof(__Material)); // 재질

	int iTC = static_cast<int>(m_TexRefs.size());
	file.Write(&iTC, 4);
	file.Write(&m_fTexFPS, 4);
	for (int j = 0; j < iTC; j++) // Texture File 이름 쓰기...
	{
		if (m_TexRefs[j])
			nL = static_cast<int>(m_TexRefs[j]->FileName().size());
		else
			nL = 0;

		file.Write(&nL, 4);
		if (nL > 0)
		{
			
//			if(-1 == m_TexRefs[j]->FileName().find("object\\")) // 임시로 경로를 바꾸려고 넣었다.. 나중에 필요없음 지운다..
//			{
//				// 폴더 이름을 분리하고..
//				char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
//				_splitpath(m_TexRefs[j]->FileName(), szDrive, szDir, szFName, szExt);
//
//				std::string szFNTmp = fmt::format("Object\\{}.DXT", szFName);
//				m_TexRefs[j]->FileNameSet(szFNTmp);
//
//				SetFilePointer(hFile, -4, 0, FILE_CURRENT);
//				nL = lstrlen(m_TexRefs[j]->FileName());
//				file.Write(&nL, 4); // Mesh FileName
//			}

			
			file.Write(m_TexRefs[j]->FileName().c_str(), nL); // 택스처 파일 이름..
		}
	}

	return true;
}
#endif // end of _N3TOOL

void CN3SPart::PartialRender(int iCount, uint16_t* pIndices)
{
	if(m_bOutOfCameraRange || m_PMInst.GetNumVertices() <= 0) return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Part++; // Rendering Information Update...
#endif

	LPDIRECT3DTEXTURE9 lpTex = nullptr;
	int iTC = static_cast<int>(m_TexRefs.size());
	if (iTC > 0)
	{
		int iTexIndex = (int) m_fTexIndex;
		if (iTexIndex >= 0 && iTexIndex < iTC && m_TexRefs[iTexIndex]) lpTex = m_TexRefs[iTexIndex]->Get();
	}

	if(m_Mtl.nRenderFlags & RF_ALPHABLENDING) // Alpha 사용
	{
		__AlphaPrimitive* pAP = s_AlphaMgr.Add();
		if(pAP)
		{
			pAP->bUseVB				= FALSE;
			pAP->dwBlendDest		= m_Mtl.dwDestBlend;
			pAP->dwBlendSrc			= m_Mtl.dwSrcBlend;
			pAP->dwFVF				= FVF_VNT1;
			pAP->dwPrimitiveSize	= sizeof(__VertexT1);
			pAP->fCameraDistance	= (s_CameraData.vEye - m_Matrix.Pos()).Magnitude();
			pAP->lpTex				= lpTex;
			pAP->ePrimitiveType		= D3DPT_TRIANGLELIST;
			pAP->nPrimitiveCount	= m_PMInst.GetNumIndices() / 3;
			pAP->nRenderFlags		= m_Mtl.nRenderFlags;
			pAP->nVertexCount		= m_PMInst.GetNumVertices();
			pAP->MtxWorld			= m_Matrix;
			pAP->pVertices			= m_PMInst.GetVertices();
			pAP->pwIndices			= m_PMInst.GetIndices();
		}

		return; // 렌더링 안하지롱.
	}

	DWORD dwFog, dwCull;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape_Polygon += m_PMInst.GetNumIndices() / 3; // Rendering Information Update...
#endif

	if(m_Mtl.nRenderFlags & RF_NOTUSEFOG) // Fog 무시..
	{
		s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
		if(TRUE == dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	}
	if(m_Mtl.nRenderFlags & RF_DOUBLESIDED) // Render Flags - 
	{
		s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	}

	s_lpD3DDev->SetMaterial(&m_Mtl); // 재질 설정..
	s_lpD3DDev->SetTexture(0, lpTex);
	if(nullptr != lpTex)
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   m_Mtl.dwColorOp);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, m_Mtl.dwColorArg1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, m_Mtl.dwColorArg2);
	}
	else
	{
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	}

	// 로딩할때 미리 계산해 놓은 월드 행렬 적용..
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	m_PMInst.PartialRender(iCount, pIndices);

	if((m_Mtl.nRenderFlags & RF_NOTUSEFOG) && TRUE == dwFog) 		s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, TRUE); // 안개 사용하지 않는다..
	if((m_Mtl.nRenderFlags & RF_DOUBLESIDED) && D3DCULL_NONE != dwCull) 		s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);
}


// CN3Shape Part ....
///////////////////////////////////

///////////////////////////////////
// CN3Shape
CN3Shape::CN3Shape()
{
	m_dwType |= OBJ_SHAPE;

	m_bDontRender = false;
	m_bVisible = true;

	m_iBelong = 0;
	m_iEventID = 0; // Event ID
	m_iEventType = 0; // Event Type
	m_iNPC_ID = 0;  // NPC 로 쓰는 오브젝트일 경우 NPC ID
	m_iNPC_Status = 0; // NPC 로 쓰는 오브젝트일 경우 NPC Status
}

CN3Shape::~CN3Shape()
{
	for (CN3SPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();
}

void CN3Shape::Release()
{
	m_bDontRender = false;
	m_bVisible = true;
	
	for (CN3SPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();
	
	m_iBelong = 0;
	m_iEventID = 0; // Event ID
	m_iEventType = 0; // Event Type - 바인드포인트,성문,레버 등등...
	m_iNPC_ID = 0;  // NPC 로 쓰는 오브젝트일 경우 NPC ID
	m_iNPC_Status = 0; // NPC 로 쓰는 오브젝트일 경우 NPC Status

	CN3TransformCollision::Release();
}

void CN3Shape::Tick(float fFrm)
{
	if(false == m_bVisible) return;

	// 만약 가까운 거리면.. 좀더 컬링을 느슨하게 한다..
	// 가장 큰 스케일 값을 찾아서..
	float fScale = m_vScale.x;
	if(fScale < m_vScale.y) fScale = m_vScale.y;
	if(fScale < m_vScale.z) fScale = m_vScale.z;

	// 카메라와 멀리 떨어지면 지나간다..
	float fDist = (m_vPos - s_CameraData.vEye).Magnitude();
	if(fDist > s_CameraData.fFP + m_fRadius * fScale * 2.0f)
	{
		m_bDontRender = true;
		return;
	}

//	float fDelta = 2.4f;
//	if(fDist < 64.0f)
//		fDelta += (64.0f - fDist)/24.0f;
	__Vector3 vCenter = (this->Min() + this->Max()) * 0.5f;
	if(s_CameraData.IsOutOfFrustum(vCenter, this->Radius()))
	{
		m_bDontRender = true;
		return;
	}

	m_bDontRender = false;

	CN3TransformCollision::Tick(fFrm);

	for (CN3SPart* pPart : m_Parts)
	{
		if (pPart != nullptr)
			pPart->Tick(m_Matrix, m_qRot, fScale);
	}
}

// 카메라 위치, 카메라 평면(관찰 절두체 평면) -> 12개의 벡터 배열로 되어 있다.
// [0][1]:카메라 위치와 벡터, [2][3]:카메라 범위 위치와 방향 벡터, [4][5] ~ [10][11]:상하좌우평면벡터
void CN3Shape::Render()
{
	if (!m_bVisible)
		return;

	if (m_bDontRender)
		return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nShape++;
#endif

	for (CN3SPart* pPart : m_Parts)
	{
		if (pPart != nullptr)
			pPart->Render();
	}
}

#ifdef _N3TOOL
void CN3Shape::RenderSelected(bool bWireFrame)
{
	// 축그리기..
	CN3Transform::Render(nullptr, m_fRadius * 3.0f);

	for (CN3SPart* pPart : m_Parts)
		pPart->RenderSelected(bWireFrame);
}
#endif // end of _N3TOOL

bool CN3Shape::Load(File& file)
{
	CN3TransformCollision::Load(file); // 기본정보 읽기...

	for (CN3SPart* pPart : m_Parts)
		delete pPart;
	m_Parts.clear();

	int iPC = 0;
	file.Read(&iPC, 4); // Part Count
	if (iPC > 0)
	{
		m_Parts.assign(iPC, nullptr);
		for (int i = 0; i < iPC; i++)
		{
			m_Parts[i] = new CN3SPart();
			m_Parts[i]->Load(file);
			m_Parts[i]->ReCalcMatrix(m_Matrix); // Part Matrix 계산
		}
	}
		
	file.Read(&m_iBelong, 4);	// 소속
	file.Read(&m_iEventID, 4);	// Event ID
	file.Read(&m_iEventType, 4); // Event Type - 바인드 포인트, 성문, 레버 등등...
	file.Read(&m_iNPC_ID, 4);	// NPC 로 쓰는 오브젝트일 경우 NPC ID
	file.Read(&m_iNPC_Status, 4); // NPC 로 쓰는 오브젝트일 경우 NPC Status

	this->FindMinMax();

	return true;
}

bool CN3Shape::LoadTransformOnly(File& file)
{
	return CN3Transform::Load(file); // 기본정보 읽기...
}

#ifdef _N3TOOL
bool CN3Shape::Save(File& file)
{
	CN3TransformCollision::Save(file); // 기본정보 읽기...
	
	int nL = 0;
	
	int iPC = static_cast<int>(m_Parts.size());
	file.Write(&iPC, 4); // Mesh FileName
	for (int i = 0; i < iPC; i++)
		m_Parts[i]->Save(file);

	file.Write(&m_iBelong, 4);		// 소속
	file.Write(&m_iEventID, 4);		// Event ID
	file.Write(&m_iEventType, 4);		// Event Type - 바인드 포인트, 성문, 레버 등등...
	file.Write(&m_iNPC_ID, 4);		// NPC 로 쓰는 오브젝트일 경우 NPC ID
	file.Write(&m_iNPC_Status, 4);	// NPC 로 쓰는 오브젝트일 경우 NPC Status

	return true;
}
#endif // end of _N3TOOL

void CN3Shape::PartDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Parts.size()))
		return;

	auto it = m_Parts.begin();
	std::advance(it, iIndex);
	delete *it;
	m_Parts.erase(it);
}

#ifdef _N3TOOL
void CN3Shape::RenderSelected(int iPart, bool bWireFrame)
{
	if (iPart < 0
		|| iPart >= static_cast<int>(m_Parts.size()))
		return;

	m_Parts[iPart]->RenderSelected(bWireFrame);
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3Shape::IsPMeshProcessed()
{
	if (m_Parts.empty())
		return false;

	for (CN3SPart* pPart : m_Parts)
	{
		if (pPart == nullptr || pPart->MeshInstance() == nullptr)
			continue;

		if (!pPart->MeshInstance()->IsLOD())
			return false;
	}

	return true;
}
#endif // end of _N3TOOL

void CN3Shape::ReCalcMatrix()
{
	CN3Transform::ReCalcMatrix(); // Transfomr Matrix 를 계산 해주고..

	// 각 파트의 매트릭스를 다시 계산해 준다..
	ReCalcPartMatrix();
}

void CN3Shape::ReCalcPartMatrix()
{
	// 각 파트의 매트릭스를 다시 계산해 준다..
	for (CN3SPart* pPart : m_Parts)
		pPart->ReCalcMatrix(m_Matrix);
}

void CN3Shape::FindMinMax()
{
	m_vMin.Zero();
	m_vMax.Zero();
	m_fRadius = 0;

	if (m_Parts.empty())
		return;

	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	__Vector3 vMinTmp(0,0,0);
	__Vector3 vMaxTmp(0,0,0);

	// 가장 큰 지점찾기..
	__Matrix44 mtxWI = m_Matrix.Inverse(); // World Matrix Inverse
	for (CN3SPart* pPart : m_Parts)
	{
		vMinTmp = pPart->Min() * mtxWI; // 월드 상의 최소값을 로컬 좌표로 바꾸어준다..
		vMaxTmp = pPart->Max() * mtxWI; // 월드 상의 최대값을 로컬 좌표로 바꾸어준다..

		if (vMinTmp.x < m_vMin.x) m_vMin.x = vMinTmp.x;
		if (vMinTmp.y < m_vMin.y) m_vMin.y = vMinTmp.y;
		if (vMinTmp.z < m_vMin.z) m_vMin.z = vMinTmp.z;
		if (vMaxTmp.x > m_vMax.x) m_vMax.x = vMaxTmp.x;
		if (vMaxTmp.y > m_vMax.y) m_vMax.y = vMaxTmp.y;
		if (vMaxTmp.z > m_vMax.z) m_vMax.z = vMaxTmp.z;
	}

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

int CN3Shape::CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol, __Vector3* pVNormal)
{
	// Compute the vector of the pick ray in screen space
	__Vector3 vTmp;

	vTmp.x =  ( ( ( 2.0f * ixScreen ) / (CN3Base::s_CameraData.vp.Width) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[0][0];
	vTmp.y = -( ( ( 2.0f * iyScreen ) / (CN3Base::s_CameraData.vp.Height) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[1][1];
	vTmp.z =  1.0f;

	// Transform the screen space pick ray into 3D space
	__Matrix44* pMtxVI = &CN3Base::s_CameraData.mtxViewInverse;
	__Vector3 vPos, vDir;
	vDir.x  = vTmp.x * pMtxVI->m[0][0] + vTmp.y * pMtxVI->m[1][0] + vTmp.z * pMtxVI->m[2][0];
	vDir.y  = vTmp.x * pMtxVI->m[0][1] + vTmp.y * pMtxVI->m[1][1] + vTmp.z * pMtxVI->m[2][1];
	vDir.z  = vTmp.x * pMtxVI->m[0][2] + vTmp.y * pMtxVI->m[1][2] + vTmp.z * pMtxVI->m[2][2];
	vPos = pMtxVI->Pos();

	return this->CheckCollisionPrecisely(bIgnoreBoxCheck, vPos, vDir, pVCol, pVNormal);
}

int CN3Shape::CheckCollisionPrecisely(bool bIgnoreBoxCheck, const __Vector3& vPos, const __Vector3& vDir, __Vector3* pVCol, __Vector3* pVNormal)
{
	// 박스 체크 먼저한다..
	if (!bIgnoreBoxCheck
		&& !_CheckCollisionByBox(vPos, vDir, m_vMin * m_Matrix, m_vMax * m_Matrix))
		return -1;

	__Vector3 vPos2 = vPos, vDir2 = vDir;
	int partCount = static_cast<int>(m_Parts.size());
	for (int i = 0; i < partCount; i++)
	{
		CN3SPart* pPart = m_Parts[i];

		CN3PMeshInstance* pPMI = pPart->MeshInstance();
		if (pPMI == nullptr)
			continue;

		__VertexT1* pVs = pPMI->GetVertices();
		uint16_t* pwIs = pPMI->GetIndices();
		int nIndexCount = pPMI->GetNumIndices();

		int nFC = nIndexCount / 3; // Face Count

		// Face 수가 24 개보다 많은 경우 일단 박스체크를 한다..
		if (nFC > 64 && !::_CheckCollisionByBox(vPos, vDir, pPart->Min(), pPart->Max()))
			continue; 

		__Matrix44 mtxWI = pPart->m_Matrix.Inverse(); // World Matrix Inverse

		vPos2 = vPos * mtxWI;
		mtxWI.PosSet(0, 0, 0);
		vDir2 = vDir * mtxWI; // 역행렬로 회전..

		int nCI0, nCI1, nCI2;
		for (int j = 0; j < nFC; j++) // 각각의 Face 마다 충돌체크..
		{
			nCI0 = pwIs[j * 3 + 0];
			nCI1 = pwIs[j * 3 + 1];
			nCI2 = pwIs[j * 3 + 2];

			if (!_IntersectTriangle(vPos2, vDir2, pVs[nCI0], pVs[nCI1], pVs[nCI2]))
				continue;

			float fT, fU, fV;
			::_IntersectTriangle(vPos2, vDir2, pVs[nCI0], pVs[nCI1], pVs[nCI2], fT, fU, fV, pVCol);
			if (pVCol != nullptr)
				(*pVCol) *= pPart->m_Matrix;

			if (pVNormal != nullptr)
			{
				pVNormal->Cross(pVs[nCI1] - pVs[nCI0], pVs[nCI2] - pVs[nCI1]);
				pVNormal->Normalize();

				mtxWI = pPart->m_Matrix.Inverse(); // World Matrix Inverse
				mtxWI.PosSet(0, 0, 0); // 역행렬로 회전..
				*pVNormal *= mtxWI; // 역행렬로 회전..
			}

			return i;
		}
	}

	return -1;
}

bool CN3Shape::MakeCollisionMeshByParts()  // 충돌 메시를 박스로 만든다...
{
	int iVC = 0, iIC = 0;
	for (CN3SPart* pPart : m_Parts)
	{
		CN3PMesh* pPMesh = pPart->Mesh();
		if (pPMesh == nullptr)
			continue;

		iVC += 8;
		iIC += 36;
	}

	if (iVC <= 0 || iIC <= 0)
		return false;

	CN3VMesh* pVMesh = new CN3VMesh();
	pVMesh->CreateVertices(iVC);
	pVMesh->CreateIndex(iIC);

	__Vector3* pVDest = pVMesh->Vertices();
	uint16_t* pwIDest = pVMesh->Indices();

	__Matrix44 mtxI = m_Matrix.Inverse();
	CN3VMesh VMTmp;

	iVC = 0; iIC = 0;
	for (CN3SPart* pPart : m_Parts)
	{
		CN3PMesh* pPMesh = pPart->Mesh();
		if (pPMesh == nullptr)
			continue;

		VMTmp.CreateCube(pPMesh->Min(), pPMesh->Max());

		__Vector3* pVSrc = VMTmp.Vertices();
		uint16_t* pwISrc = VMTmp.Indices();

		pPart->Tick(m_Matrix, m_qRot, 1.0f);

		__Matrix44 mtxPart = pPart->m_Matrix;
		mtxPart *= mtxI;

		for (int j = 0; j < 8; j++)
			pVDest[iVC + j] = pVSrc[j] * mtxPart;

		for (int j = 0; j < 36; j++)
			pwIDest[iIC + j] = pwISrc[j] + iVC;

		iVC += 8;
		iIC += 36;
	}

	if (iVC <= 0 || iIC <= 0)
	{
		delete pVMesh;
		return false;
	}

	int iCount = CN3Base::s_MngVMesh.Count();
	std::string buff = fmt::format("{}_collision_{}.n3vmesh", m_szFileName.c_str(), iCount); // 임시로 이름일 짓고..

	pVMesh->FileNameSet(buff);
	CN3Base::s_MngVMesh.Delete(&m_pMeshCollision); // 전의 거 지우고..
	CN3Base::s_MngVMesh.Add(pVMesh);
	m_pMeshCollision = s_MngVMesh.Get(pVMesh->FileName());

	FindMinMax();

	return true;
}

bool CN3Shape::MakeCollisionMeshByPartsDetail()  // 현재 모습 그대로... 충돌 메시를 만든다...
{
	int iMaxNumVertices = 0, iMaxNumIndices = 0;
	int iVC = 0, iIC = 0;
	for (CN3SPart* pPart : m_Parts)
	{
		CN3PMesh* pPMesh = pPart->Mesh();
		CN3PMeshInstance* pPMI = pPart->MeshInstance();
		if (pPMesh == nullptr || pPMI == nullptr)
			continue;

		iMaxNumVertices = pPMesh->GetMaxNumVertices();
		iMaxNumIndices = pPMesh->GetMaxNumIndices();

		iVC += iMaxNumVertices;
		iIC += iMaxNumIndices;
	}

	if (iVC <= 0 || iIC <= 0)
		return false;

	CN3VMesh* pVMesh = new CN3VMesh();
	pVMesh->CreateVertices(iVC);
	pVMesh->CreateIndex(iIC);

	__Vector3* pVDest = pVMesh->Vertices();
	uint16_t* pwIDest = pVMesh->Indices();

	__VertexT1* pVSrc = nullptr;
	uint16_t* pwISrc = nullptr;

	iVC = 0; iIC = 0;
	__Matrix44 mtxI = m_Matrix.Inverse();

	for (CN3SPart* pPart : m_Parts)
	{
		CN3PMesh* pPMesh = pPart->Mesh();
		CN3PMeshInstance* pPMI = pPart->MeshInstance();
		if (pPMesh == nullptr || pPMI == nullptr)
			continue;

		iMaxNumVertices = pPMesh->GetMaxNumVertices();
		iMaxNumIndices = pPMesh->GetMaxNumIndices();
		pPMI->SetLODByNumVertices(iMaxNumVertices);

		pVSrc = pPMesh->GetVertices();
		pwISrc = pPMI->GetIndices();
		if (pVSrc == nullptr || pwISrc == nullptr)
			continue;

		pPart->Tick(m_Matrix, m_qRot, 1.0f);

		__Matrix44 mtxPart = pPart->m_Matrix;
		mtxPart *= mtxI;

		for (int j = 0; j < iMaxNumVertices; j++)
			pVDest[iVC + j] = pVSrc[j] * mtxPart;

		for (int j = 0; j < iMaxNumIndices; j++)
			pwIDest[iIC + j] = pwISrc[j] + iVC;

		iVC += iMaxNumVertices;
		iIC += iMaxNumIndices;
	}

	if (iVC <= 0 || iIC <= 0)
	{
		delete pVMesh;
		return false;
	}

	int iCount = CN3Base::s_MngVMesh.Count();
	std::string buff = fmt::format("{}_collision_{}.n3vmesh", m_szFileName.c_str(), iCount); // 임시로 이름일 짓고..

	pVMesh->FileNameSet(buff);
	CN3Base::s_MngVMesh.Delete(&m_pMeshCollision); // 전의 거 지우고..
	CN3Base::s_MngVMesh.Add(pVMesh);
	m_pMeshCollision = s_MngVMesh.Get(pVMesh->FileName());

	FindMinMax();

	return true;
}

#ifdef _N3TOOL
void CN3Shape::MakeDefaultMaterial()
{
	// 각 파트의 재질을 기본적인 흰색으로 해준다..
	__Material mtlBasic;
	mtlBasic.Init();

	for (CN3SPart* pPart : m_Parts)
		memcpy(&pPart->m_Mtl, &mtlBasic, sizeof(_D3DMATERIAL9));
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3Shape::RemoveRenderFlags(int nFlags)
{
	// 각 파트의 매트릭스를 다시 계산해 준다..
	for (CN3SPart* pPart : m_Parts)
		pPart->m_Mtl.nRenderFlags &= ~nFlags; // 기본 흰색..
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3Shape::SaveToSameFolder(const std::string& szFullPath)
{
	if(szFullPath.empty()) return false;
	
	std::string szPath = szFullPath;
	for (int i = static_cast<int>(szFullPath.size()) - 1; i >= 0; i--)
	{
		if ('\\' == szPath[i] || '/' == szPath[i])
		{
			szPath = szPath.substr(0, i + 1);
			break;
		}
	}

	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
	std::string szNameTmp, szOldFN;

	std::vector<std::string> OldPartFNs;
	std::vector<std::string> OldTexFNs;
	for (CN3SPart* pPart : m_Parts)
	{
		szOldFN = pPart->Mesh()->FileName();
		OldPartFNs.push_back(szOldFN); // 파일 이름 보관..

		_splitpath(szOldFN.c_str(), szDrive, szDir, szFName, szExt);
		szNameTmp = szPath + szFName + szExt;
		pPart->Mesh()->SaveToFile(szNameTmp);

		int iTC = pPart->TexCount();
		for (int j = 0; j < iTC; j++)
		{
			CN3Texture* pTex = pPart->Tex(j);

			szOldFN = pTex->FileName();
			OldTexFNs.push_back(szOldFN); // 파일 이름 보관..

			_splitpath(szOldFN.c_str(), szDrive, szDir, szFName, szExt);
			szNameTmp = szPath + szFName + szExt;
			pTex->SaveToFile(szNameTmp);
		}
	}

	szOldFN = m_szFileName;
	_splitpath(m_szFileName.c_str(), szDrive, szDir, szFName, szExt);
	szNameTmp = szPath + szFName + szExt;
	SaveToFile(szNameTmp);
	m_szFileName = szOldFN;

	// 원래대로 파일 이름 돌려놓기..
	int iSeq = 0;
	for (size_t i = 0; i < m_Parts.size(); i++)
	{
		CN3SPart* pPart = m_Parts[i];
		pPart->Mesh()->FileNameSet(OldPartFNs[i]);

		int iTC = pPart->TexCount();
		for (int j = 0; j < iTC; j++)
		{
			pPart->Tex(j)->FileNameSet(OldTexFNs[iSeq]);
			iSeq++;
		}
	}

//	By : Ecli666 ( On 2002-10-16 오전 11:44:19 )
//
	// TODO(srmeier): m_pvCollisions is undefined, if I need this I'll have to revisit this
	/*
	szOldFN = m_pvCollisions->FileName();
	_splitpath(CollisionMesh()->FileName().c_str(), szDrive, szDir, szFName, szExt);
	szNameTmp = szPath + szFName + szExt;
	CollisionMesh()->SaveToFile(szNameTmp);
	CollisionMesh()->FileNameSet(szOldFN);	
	*/

//	~(By Ecli666 On 2002-10-16 오전 11:44:19 )

	return true;
}

bool CN3Shape::SaveToSameFolderAndMore(const std::string& szFullPath, const std::string& szRelativePath)
{
	if(szFullPath.empty()) return false;
	
	std::string szPath = szFullPath;
	for (int i = static_cast<int>(szFullPath.size()) - 1; i >= 0; i--)
	{
		if ('\\' == szPath[i] || '/' == szPath[i])
		{
			szPath = szPath.substr(0, i + 1);
			break;
		}
	}

	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
	std::string szNameTmp, szOldFN;

	for (CN3SPart* pPart : m_Parts)
	{
		szOldFN = pPart->Mesh()->FileName();

		_splitpath(szOldFN.c_str(), szDrive, szDir, szFName, szExt);
		szNameTmp = szPath + szFName + szExt;
		pPart->Mesh()->SaveToFile(szNameTmp);
		pPart->Mesh()->FileNameSet(szRelativePath + szFName + szExt);

		int iTC = pPart->TexCount();
		for(int j = 0; j < iTC; j++)
		{
			CN3Texture* pTex = pPart->Tex(j);

			szOldFN = pTex->FileName();

			_splitpath(szOldFN.c_str(), szDrive, szDir, szFName, szExt);
			szNameTmp = szPath + szFName + szExt;
			pTex->SaveToFile(szNameTmp);
			pTex->FileNameSet(szRelativePath + szFName + szExt);
		}
	}

	_splitpath(m_szFileName.c_str(), szDrive, szDir, szFName, szExt);
	szNameTmp = szPath + szFName + szExt;
	SaveToFile(szNameTmp);
	m_szFileName = szRelativePath + szFName + szExt;

//	By : Ecli666 ( On 2002-10-16 오전 11:44:19 )
//
	if (CollisionMesh())
	{
		_splitpath(CollisionMesh()->FileName().c_str(), szDrive, szDir, szFName, szExt);
		szNameTmp = szPath + szFName + szExt;
		CollisionMesh()->SaveToFile(szNameTmp);
		szOldFN = szFName; szOldFN += szExt; 
		CollisionMesh()->FileNameSet(szRelativePath + szFName + szExt);	
	}
//	~(By Ecli666 On 2002-10-16 오전 11:44:19 )

	return true;
}

#endif // end of _N3TOOL

//	By : Ecli666 ( On 2002-08-06 오후 4:33:32 )
//
void CN3Shape::SetMaxLOD()
{
	m_bDontRender = false;	

	for (auto itr = m_Parts.begin(); itr != m_Parts.end(); ++itr)
	{
		auto part = *itr;
		part->m_bOutOfCameraRange = FALSE;
		part->m_PMInst.SetLOD(0);
	}
}

__Matrix44 CN3Shape::GetPartMatrix(int iPartIndex) const
{
	return m_Parts[iPartIndex]->m_Matrix;
}

void CN3Shape::PartialRender(int iPartIndex, int iCount, uint16_t* pIndices)
{
	if (iPartIndex < 0
		|| iPartIndex >= static_cast<int>(m_Parts.size()))
		return;

	m_Parts[iPartIndex]->PartialRender(iCount, pIndices);
}

int	CN3Shape::GetIndexbufferCount(int iPartIndex)
{
	if (iPartIndex < 0
		|| iPartIndex >= static_cast<int>(m_Parts.size()))
		return 0;
	
	return m_Parts[iPartIndex]->MeshInstance()->GetNumIndices();
}

int CN3Shape::GetIndexByiOrder(int iPartIndex, int iOrder)
{
	return m_Parts[iPartIndex]->MeshInstance()->GetIndexByiOrder(iOrder);
}

__Vector3 CN3Shape::GetVertexByIndex(int iPartIndex, int iIndex)
{
	return m_Parts[iPartIndex]->MeshInstance()->GetVertexByIndex(iIndex);
}

int CN3Shape::GetColIndexbufferCount()
{
	if (CollisionMesh())
		if(CollisionMesh()->IndexCount())
			return CollisionMesh()->IndexCount();
		else
			return CollisionMesh()->VertexCount();
	else
		return -1;
}

int CN3Shape::GetColIndexByiOrder(int iOrder)
{
	return CollisionMesh()->GetColIndexByiOrder(iOrder);
}

__Vector3 CN3Shape::GetColVertexByIndex(int iIndex)
{
	return CollisionMesh()->GetColVertexByIndex(iIndex);
}

void CN3Shape::PartialColRender(int iCount, int* piIndices)
{
	CollisionMesh()->PartialColRender(iCount, piIndices);
}

void CN3Shape::PartialGetCollision(int iIndex, __Vector3& vec)
{
	CollisionMesh()->PartialGetCollision(iIndex, vec);
}

//	~(By Ecli666 On 2002-08-06 오후 4:33:32 )


// ===== END N3Base/N3Shape.cpp =====

// ===== BEGIN N3Base/N3Shape.h =====
#line 1 "N3Base/N3Shape.h"
﻿// N3Shape.h: interface for the C3DObject class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Shape_h__INCLUDED_)
#define AFX_N3Shape_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

#include "N3TransformCollision.h"
#include "N3PMeshInstance.h"
#include "N3Texture.h"

#include <vector>

typedef std::vector<CN3Texture*> it_pTex;

class CN3SPart : public CN3BaseFileAccess
{
	friend class CN3Shape;
public:
	__Vector3	m_vPivot; // Local 축
	__Matrix44	m_Matrix; // World Matrix.. Shape Loading 때 미리 계산해야 좋다..		
	BOOL		m_bOutOfCameraRange; // Camera 범위 바깥에 있음...

	__Material	m_Mtl; // Material
	float		m_fTexFPS; // Texture Animation Interval;

//	__Vector3	m_vWindFactorCur;		// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
//	__Vector3	m_vWindFactorToReach;	// 바람 부는 값..
	float		m_fTimeToSetWind;		// 바람 부는 값을 바꾸기 위한 시간..
	float		m_fWindFactorToReach;	// 현재 바람 부는 값.. 이값으로 회전을 시킨다..
	float		m_fWindFactorCur;		// 바람 부는 값..

protected:
	std::vector<CN3Texture*>	m_TexRefs; // Texture Reference Pointers
	CN3PMeshInstance			m_PMInst; // Progressive Mesh Instance

	float	m_fTexIndex; // Current Texture Index.. Animation 시킬때 필요한 인덱스이다.. float 로 해서 텍스처 에니메이션 제어한다.

public:
	bool Load(File& file) override;
#ifdef _N3TOOL
	bool Save(File& file) override;
#endif // end of _N3TOOL
	
	int TexCount() const
	{
		return static_cast<int>(m_TexRefs.size());
	}

	CN3Texture* Tex(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_TexRefs.size()))
			return nullptr;

		return m_TexRefs[iIndex];
	}

	void		TexAlloc(int nCount);
	CN3Texture* TexSet(int iIndex, const std::string& szFN)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_TexRefs.size()))
			return nullptr;

		s_MngTex.Delete(&m_TexRefs[iIndex]);
		m_TexRefs[iIndex] = s_MngTex.Get(szFN, true, s_Options.iTexLOD_Shape);
		return m_TexRefs[iIndex];
	}

	void TexSet(int iIndex, CN3Texture* pTex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_TexRefs.size()))
			return;

		s_MngTex.Delete(&m_TexRefs[iIndex]);
		m_TexRefs[iIndex] = pTex;
	}

	CN3PMeshInstance*	MeshInstance() { return &m_PMInst; } 
	CN3PMesh*			Mesh() { return m_PMInst.GetMesh(); }
	void				MeshSet(const std::string& szFN);

	void ReCalcMatrix(const __Matrix44& mtxParent) { m_Matrix.Identity(); m_Matrix.PosSet(m_vPivot); m_Matrix *= mtxParent; }

	void Tick(const __Matrix44& mtxParent, const __Quaternion& qRot, float fScale); // 부모 행렬 즉 Shape 행렬, 회전쿼터니언 을 넣는다.
	void Render();
#ifdef _N3TOOL
	void RenderSelected(bool bWireFrame);
	void RenderAxis();
#endif // end of _N3TOOL

	__Vector3 Min() { if(m_PMInst.GetMesh()) return m_PMInst.GetMesh()->Min() * m_Matrix; else return __Vector3(0,0,0); } // 월드 상의 최소값
	__Vector3 Max() { if(m_PMInst.GetMesh()) return m_PMInst.GetMesh()->Max() * m_Matrix; else return __Vector3(0,0,0); } // 월드 상의 최대값
	float	Radius() { if(m_PMInst.GetMesh()) return m_PMInst.GetMesh()->Radius(); else return 0.0f; }

	virtual void	Release();
	
	CN3SPart();
	virtual ~CN3SPart();

	void			PartialRender(int iCount, uint16_t* pIndices);
};

typedef std::vector<CN3SPart*>::iterator it_SPart;

class CN3Shape : public CN3TransformCollision
{
public:
	int		m_iBelong;			// 소속 - 0:소속 없음 1:엘모라드 2:카루스 3:?? ....
	int		m_iEventID;			// Event ID
	int		m_iEventType;		// Event Type
	int		m_iNPC_ID;			// NPC 로 쓰는 오브젝트일 경우 NPC ID
	int		m_iNPC_Status;		// NPC 로 쓰는 오브젝트일 경우 Default Status

	bool	m_bDontRender; // 카메라 거리에 따라 이플래그가 설정되면 렌더링하지 않는다..
	bool	m_bVisible;	// .. 

	std::vector<CN3SPart*>	m_Parts; // Part Data Pointer Linked List

public:
#ifdef _N3TOOL
	bool			SaveToSameFolderAndMore(const std::string& szFullPath, const std::string& szRelativePath);
	bool			SaveToSameFolder(const std::string& szFullPath);
	void			RemoveRenderFlags(int nFlags = -1);
	void			MakeDefaultMaterial();
#endif // end of _N3TOOL
	int				CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr); // 정밀하게 폴리곤 단위로 체크 - 먼저 박스 체크후 다시 정밀 체크..
	int				CheckCollisionPrecisely(bool bIgnoreBoxCheck, const __Vector3& vPos, const __Vector3& vDir, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr); // 정밀하게 폴리곤 단위로 체크 - 먼저 박스 체크후 다시 정밀 체크..
	bool			MakeCollisionMeshByParts();  // 충돌 메시를 박스 형태로 다시 만든다...
	bool			MakeCollisionMeshByPartsDetail();  // 현재 모습 그대로... 충돌 메시를 만든다...

	void			FindMinMax() override;
	void			ReCalcMatrix() override;
	void			ReCalcPartMatrix();
	void			Tick(float fFrm = FRAME_SELFPLAY) override;
	virtual void	Render();

	int PartCount() const
	{
		return static_cast<int>(m_Parts.size());
	}

	CN3SPart* Part(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Parts.size()))
			return nullptr;

		return m_Parts[iIndex];
	}

	CN3SPart*		PartAdd() { CN3SPart* pPart = new CN3SPart(); m_Parts.push_back(pPart); return pPart; }
	void			PartDelete(int iIndex);
	
	bool			Load(File& file) override;
#ifdef _N3TOOL
	bool			Save(File& file) override;
	void			RenderSelected(bool bWireFrame);
	void			RenderSelected(int iPart, bool bWireFrame);
	bool			IsPMeshProcessed();
#endif // end of _N3TOOL

	void			Release() override;
	CN3Shape();
	~CN3Shape() override;

//	By : Ecli666 ( On 2002-08-06 오후 4:33:04 )
//
	void			SetMaxLOD();
	__Matrix44		GetPartMatrix(int iPartIndex) const;
	void			PartialRender(int iPartIndex, int iCount, uint16_t* pIndices);
	int				GetIndexbufferCount(int iPartIndex);
	int				GetIndexByiOrder(int iPartIndex, int iOrder);
__Vector3			GetVertexByIndex(int iPartIndex, int iIndex);
	int				GetColIndexbufferCount();
	int				GetColIndexByiOrder(int iOrder);
__Vector3			GetColVertexByIndex(int iIndex); 
	void			PartialColRender(int iCount, int* piIndices);
	void			PartialGetCollision(int iIndex, __Vector3& vec);
	bool			LoadTransformOnly(File& file);
//	~(By Ecli666 On 2002-08-06 오후 4:33:04 )
};

#endif // !defined(AFX_N3Shape_h__INCLUDED_)

// ===== END N3Base/N3Shape.h =====

// ===== BEGIN N3Base/N3ShapeExtra.cpp =====
#line 1 "N3Base/N3ShapeExtra.cpp"
﻿// N3ShapeExtra.cpp: implementation of the CN3ShapeExtra class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3ShapeExtra.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3ShapeExtra::CN3ShapeExtra()
{
	m_dwType |= OBJ_SHAPE_EXTRA;
}

CN3ShapeExtra::~CN3ShapeExtra()
{
	m_Rotations.clear();
}

void CN3ShapeExtra::Release()
{
	CN3Shape::Release();
	
	m_Rotations.clear();
}

bool CN3ShapeExtra::Load(File& file)
{
	bool bSuccess = CN3Shape::Load(file);

	m_Rotations.clear();

	size_t partCount = m_Parts.size();
	if (partCount <= 0)
		return bSuccess;

	m_Rotations.assign(partCount, __Rotation());
	return bSuccess;
}

void CN3ShapeExtra::Tick(float fFrm)
{
	if (!m_bVisible)
	{
		m_bDontRender = true;
		return; // 강제로 렌더링 하지 않는다.
	}

	CN3Shape::Tick();

	if (m_bDontRender)
		return;

	if (m_Parts.empty())
		return;

	bool bNeedRemakeCollisionMeshes = false;
	float fDir = 0, fRotDelta = 0;
	__Rotation* pRot = nullptr;
	__Quaternion qRot;
	for (size_t i = 0; i < m_Parts.size(); i++)
	{
		CN3SPart* pPart = m_Parts[i];
		if (pPart->m_bOutOfCameraRange)
			continue;

		__Rotation* pRot = &m_Rotations[i];
		if (pRot->fRadianPerSec == 0
			|| pRot->fRadianCur == pRot->fRadianToReach)
			continue;

		// 도는 방향..
		if (pRot->fRadianCur < pRot->fRadianToReach)
			fDir = 1.0f;
		else
			fDir = -1.0f;

		fRotDelta = pRot->fRadianPerSec * fDir * CN3Base::s_fSecPerFrm;
		pRot->fRadianCur += fRotDelta;

		// 원하는 곳까지 다 열렸다!!
		if (std::abs(pRot->fRadianToReach - pRot->fRadianCur) <= fRotDelta)
		{
			bNeedRemakeCollisionMeshes = true;
			pRot->fRadianPerSec = 0;
			pRot->fRadianCur = pRot->fRadianToReach;
		}

		qRot.RotationAxis(pRot->vAxis, pRot->fRadianCur);
		pPart->m_Matrix = qRot;
		pPart->m_Matrix.PosSet(pPart->m_vPivot);
		pPart->m_Matrix *= m_Matrix;
	}

	if (bNeedRemakeCollisionMeshes)
		MakeCollisionMeshByParts(); // 충돌메시를 다시 만든다..
}

void CN3ShapeExtra::RotateTo(int iPart, const __Vector3& vAxis, float fRadianToReach, float fRadianPerSec, bool bImmediately)
{
	if (iPart < 0
		|| iPart >= static_cast<int>(m_Rotations.size()))
		return;

	__Rotation* pRot = &(m_Rotations[iPart]);
	
	pRot->fRadianToReach = fRadianToReach;
	pRot->fRadianPerSec = fRadianPerSec;
	pRot->vAxis = vAxis;
	if(bImmediately) pRot->fRadianCur = pRot->fRadianToReach - 0.01f; // 이러면 직빵으로 열린다.. 약간 값을 빼주는 이유는 한번은 틱을 돌게 하기 위해서이다.
}

// ===== END N3Base/N3ShapeExtra.cpp =====

// ===== BEGIN N3Base/N3ShapeExtra.h =====
#line 1 "N3Base/N3ShapeExtra.h"
﻿// N3ShapeExtra.h: interface for the CN3ShapeExtra class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SHAPEEXTRA_H__F3D6E8DF_A20F_45F5_8729_2FD36796969C__INCLUDED_)
#define AFX_N3SHAPEEXTRA_H__F3D6E8DF_A20F_45F5_8729_2FD36796969C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

#include "N3Shape.h"
#include <vector>

// std::vector<struct __Rotation>::iterator it_Rot;

class CN3ShapeExtra : public CN3Shape  
{
protected:
	struct __Rotation
	{
		float			fRadianPerSec;	// 초당 회전.. Radian...
		__Vector3		vAxis;			// 회전축..
		float			fRadianCur;		// 현재 회전값..
		float			fRadianToReach;	// 회전시킬값..

		__Rotation()
		{
			fRadianPerSec = 0.0f;
			vAxis.Set(0,1,0);
			fRadianCur = 0.0f;
			fRadianToReach = 0.0f;
		}
	};

	std::vector<__Rotation>	m_Rotations;

public:
	void RotateTo(int iPart, const __Vector3& vAxis, float fRadianToReach, float fRadianPerSec, bool bImmediately = false); // 원하는 파트를 축에 따라 지정한 각도까지 지정한 속도로 회전시킨다..

	bool Load(File& file) override;
	void Tick(float fFrm) override;
	
	void Release() override;
	CN3ShapeExtra();
	~CN3ShapeExtra() override;
};

#endif // !defined(AFX_N3SHAPEEXTRA_H__F3D6E8DF_A20F_45F5_8729_2FD36796969C__INCLUDED_)

// ===== END N3Base/N3ShapeExtra.h =====

// ===== BEGIN N3Base/N3ShapeMgr.cpp =====
#line 1 "N3Base/N3ShapeMgr.cpp"
﻿// N3ShapeMgr.cpp: implementation of the CN3ShapeMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3ShapeMgr.h"
#include "N3ShapeExtra.h"

#include <shared/globals.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3ShapeMgr::CN3ShapeMgr()
{
	m_fMapWidth = 0.0f;
	m_fMapLength = 0.0f;
	m_nCollisionFaceCount = 0;
	m_pvCollisions = nullptr;
	memset(m_pCells, 0, sizeof(m_pCells));
}

CN3ShapeMgr::~CN3ShapeMgr()
{
#ifndef _3DSERVER
	for (CN3Shape* pShape : m_Shapes)
		delete pShape;
	m_Shapes.clear();
#endif // end of #ifndef _3DSERVER

	delete[] m_pvCollisions;
	m_pvCollisions = nullptr;

	for (int z = 0; z < MAX_CELL_MAIN; z++)
	{
		for (int x = 0; x < MAX_CELL_MAIN; x++)
			delete m_pCells[x][z];
	}
}

void CN3ShapeMgr::Release()
{
#ifndef _3DSERVER
	ReleaseShapes();
#endif // end of #ifndef _3DSERVER

	m_fMapWidth = 0.0f;
	m_fMapLength = 0.0f;
	m_nCollisionFaceCount = 0;

	delete[] m_pvCollisions;
	m_pvCollisions = nullptr;

	for (int z = 0; z < MAX_CELL_MAIN; z++)
	{
		for (int x = 0; x < MAX_CELL_MAIN; x++)
		{
			delete m_pCells[x][z];
			m_pCells[x][z] = nullptr;
		}
	}

	memset(m_pCells, 0, sizeof(MAX_CELL_MAIN));

#ifndef _3DSERVER
	m_ShapesToRender.clear();
#endif // end of #ifndef _3DSERVER

#ifdef _N3TOOL
	m_CollisionExtras.clear(); // 추가로 넣을 충돌체크 데이터
#endif // end of #ifedef _N3TOOL
}

#ifndef _3DSERVER
void CN3ShapeMgr::ReleaseShapes()
{
	for (CN3Shape* pShape : m_Shapes)
		delete pShape;
	m_Shapes.clear();
	m_ShapesHaveID.clear();
	m_ShapesToRender.clear();
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
bool CN3ShapeMgr::Load(File& file)
{
	int nL = 0;

	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
	{
		int iIdk0;
		file.Read(&iIdk0, sizeof(int));

		int iNL;
		file.Read(&iNL, sizeof(int));
		if (iNL > 0)
		{
			m_szName.resize(iNL);
			file.Read(&m_szName[0], iNL);
		}
	}

	if (!LoadCollisionData(file))
		return false;

	int iSC = 0;
	if (!m_Shapes.empty())
		ReleaseShapes();
	m_ShapesHaveID.clear();

	file.Read(&iSC, 4); // Shape Count
	if (iSC > 0)
	{
		CN3Shape* pShape = nullptr;
		m_Shapes.reserve(iSC);

		uint32_t dwType = 0;
		for (int i = 0; i < iSC; i++)
		{
			file.Read(&dwType, 4); // Shape Type

			// 성문등 확장된 Object 로 쓸경우..
			if (dwType & OBJ_SHAPE_EXTRA)
				pShape = new CN3ShapeExtra();
			else
				pShape = new CN3Shape();

			pShape->m_iFileFormatVersion = m_iFileFormatVersion;

			m_Shapes.push_back(pShape);

			// pShape->m_iEventID; 바인드 포인트 100~, 200~ 성문 1100~, 1200~ 레버 2100~, 2200~
			// pShape->m_iEventType; 0-바인드포인트 1-성문(좌우열림) 2-성문(상하열림) 3-레버(상하당김) 4-깃발(보임, 안보임)
			// pShape->m_iNPC_ID; 조종할 Object ID
			// pShape->m_iNPC_Status; toggle 0, 1

			pShape->Load(file);

			//  ID 가 있는 오브젝트 ... NPC 로 쓸수 있다..
			if (pShape->m_iEventID != 0)
			{
				m_ShapesHaveID.push_back(pShape);
				pShape->MakeCollisionMeshByPartsDetail(); // 현재 모습 그대로... 충돌 메시를 만든다...

				//TRACE(_T("  Load OBject Event : ID(%d) Type(%d) CtrlID(%d) Status(%d)\n"),
					//pShape->m_iEventID, pShape->m_iEventType, pShape->m_iNPC_ID, pShape->m_iNPC_Status);

				switch (pShape->m_iEventType)
				{
					case OBJECT_TYPE_BIND: // 좌우열림성문,
					case OBJECT_TYPE_WARP_GATE:
						pShape->m_bVisible = true;
						break;

					default:
						pShape->m_bVisible = false;
				}
			}

#ifdef _N3GAME
			// 강제 코딩... 각종 성문 열기..
//			if(dwType & OBJ_SHAPE_EXTRA)
//			{
//				CN3ShapeExtra* pSE = (CN3ShapeExtra*)pShape; // 성문등 확장된 Object 로 쓸경우..
//				pSE->RotateTo(0, __Vector3(0,1,0), 80, 1, true); // 바로 열기.
//				pSE->RotateTo(1, __Vector3(0,1,0), -80, 1, true); // 바로 열기.
//			}

			if (!(i % 64))
				UpdateLoadStatus(i, iSC);
#endif // end of #ifndef _N3GAME
		}
	}

	return true;
}
#endif // end of #ifndef _3DSERVER

bool CN3ShapeMgr::LoadCollisionData(File& file)
{
	file.Read(&m_fMapWidth, 4);
	file.Read(&m_fMapLength, 4);

	if (!Create(m_fMapWidth, m_fMapLength))
		return false;

	// 충돌 체크 폴리곤 데이터 읽기..
	file.Read(&m_nCollisionFaceCount, 4);

	delete[] m_pvCollisions;
	m_pvCollisions = nullptr;

	if (m_nCollisionFaceCount > 0)
	{
		m_pvCollisions = new __Vector3[m_nCollisionFaceCount * 3];
		file.Read(m_pvCollisions, sizeof(__Vector3) * m_nCollisionFaceCount * 3);
	}

#if !defined(_3DSERVER)
	if (m_iFileFormatVersion == N3FORMAT_VER_HERO)
	{
		// NOTE(srmeier): for the "ah_hapbi_zone.opd" the jump seems to be specifically 0x338 bytes
		uint8_t* tmp = new uint8_t[0x338];
		file.Read(tmp, 0x338);
		delete[] tmp;
	}
#endif

	// Cell Data 쓰기.
	int iExist = 0;
	int z = 0;
	for (float fZ = 0.0f; fZ < m_fMapLength; fZ += CELL_MAIN_SIZE, z++)
	{
		int x = 0;
		for (float fX = 0.0f; fX < m_fMapWidth; fX += CELL_MAIN_SIZE, x++)
		{
			delete m_pCells[x][z]; m_pCells[x][z] = nullptr;

			file.Read(&iExist, 4); // 데이터가 있는 셀인지 쓰고..

			if (iExist == 0)
				continue;

			m_pCells[x][z] = new __CellMain;
			m_pCells[x][z]->Load(file);
		}
	}

	return true;
}

#ifdef _N3TOOL
bool CN3ShapeMgr::Save(File& file)
{
	if (!SaveCollisionData(file))
		return false;

#ifndef _3DSERVER
	int iSC = static_cast<int>(m_Shapes.size());

	file.Write(&iSC, 4); // Shape Count
	for (CN3Shape* pShape : m_Shapes)
	{
		uint32_t dwType = pShape->Type();
		if (pShape->m_iEventID != 0
			|| pShape->m_iEventType != 0
			|| pShape->m_iNPC_ID != 0
			|| pShape->m_iNPC_Status != 0)
			dwType |= OBJ_SHAPE_EXTRA; // NPC ID 가 있으면.. 확장 Shape 로 ...

		file.Write(&dwType, 4); // Shape Type
		pShape->CollisionMeshSet(""); // 충돌 메시는 지워준다..
		pShape->ClimbMeshSet(""); // 충돌 메시는 지워준다..
		pShape->Save(file);
	}
#endif // end of #ifndef _3DSERVER
	return true;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3ShapeMgr::SaveCollisionData(File& file)
{
	file.Write(&m_fMapWidth, 4); // 맵 실제 미터 단위 너비
	file.Write(&m_fMapLength, 4); // 맵 실제 미터 단위 길이

	// 충돌 체크 폴리곤 데이터 쓰기..
	file.Write(&m_nCollisionFaceCount, 4);
	if (m_nCollisionFaceCount > 0)
		file.Write(m_pvCollisions, sizeof(__Vector3) * m_nCollisionFaceCount * 3);

	// Cell Data 쓰기.
	int z = 0;
	for (float fZ = 0.0f; fZ < m_fMapLength; fZ += CELL_MAIN_SIZE, z++)
	{
		int x = 0;
		for (float fX = 0.0f; fX < m_fMapWidth; fX += CELL_MAIN_SIZE, x++)
		{
			int iExist = 0;
			if (m_pCells[x][z] != nullptr)
				iExist = 1;

			// 데이터가 있는 셀인지 쓰고..
			file.Write(&iExist, 4);

			if (m_pCells[x][z] != nullptr)
				m_pCells[x][z]->Save(file);
		}
	}

	return true;
}
#endif // end of _N3TOOL

// 맵의 너비와 높이를 미터 단위로 넣는다..
bool CN3ShapeMgr::Create(float fMapWidth, float fMapLength)
{
	if (fMapWidth <= 0.0f
		|| fMapWidth > MAX_CELL_MAIN * CELL_MAIN_SIZE
		|| fMapLength <= 0.0f
		|| fMapLength > MAX_CELL_MAIN * CELL_MAIN_SIZE)
		return false;

	m_fMapWidth = fMapWidth;
	m_fMapLength = fMapLength;

	return true;
}

#ifdef _N3TOOL
void CN3ShapeMgr::GenerateCollisionData()
{
	int nFC = 0;

	// Shape 에 있는 충돌 메시 만큼 생성.
	for (CN3Shape* pShape : m_Shapes)
	{
		CN3VMesh* pVM = pShape->CollisionMesh();
		if (pVM == nullptr)
			continue;

		int nIC = pVM->IndexCount();
		if (nIC > 0)
			nFC += nIC / 3;
		else
			nFC += pVM->VertexCount() / 3;
	}

	nFC += static_cast<int>(m_CollisionExtras.size()) / 3; // 추가 충돌 데이터..

	if (nFC <= 0)
		return;

	m_nCollisionFaceCount = nFC;

	delete[] m_pvCollisions;
	m_pvCollisions = new __Vector3[nFC * 3]; // 충돌 폴리곤 생성

	memset(m_pvCollisions, 0, sizeof(__Vector3) * nFC * 3);

	int nCPC = 0; // Collision Polygon Count

	// Shape 에 있는 충돌 메시 만큼 데이터 복사..
	for (CN3Shape* pShape : m_Shapes)
	{
		CN3VMesh* pVMesh = pShape->CollisionMesh();
		if (pVMesh == nullptr)
			continue;

		__Vector3* pVSrc = pVMesh->Vertices();
		int nIC = pVMesh->IndexCount();
		if (nIC > 0)
		{
			uint16_t* pwIs = pVMesh->Indices();
			for (int j = 0; j < nIC; j++)
				m_pvCollisions[nCPC++] = pVSrc[pwIs[j]] * pShape->m_Matrix; // 월드 위치이다.
		}
		else
		{
			int nVC = pVMesh->VertexCount();
			for (int j = 0; j < nVC; j++)
				m_pvCollisions[nCPC++] = pVSrc[j] * pShape->m_Matrix; // 월드 위치이다.
		}
	}

	// 추가 충돌 데이터 넣기..
	for (const __Vector3& vColExtra : m_CollisionExtras)
		m_pvCollisions[nCPC++] = vColExtra;

	if (nCPC != (nFC * 3))
	{
		__ASSERT(0, "충돌 체크 폴리곤의 점갯수와 면 갯수가 다릅니다.");
		Release();
		return;
	}

	// 각 선분이 셀에 걸쳐 있는지 혹은 포함되어 있는지 등등 판단해서 인덱스 생성을 한다.
	int xSMax = (int) (m_fMapWidth / CELL_SUB_SIZE);
	int zSMax = (int) (m_fMapLength / CELL_SUB_SIZE);
	for (int i = 0; i < nFC; i++)
	{
		__Vector3 vEdge[3][2];

		vEdge[0][0] = m_pvCollisions[i * 3];
		vEdge[0][1] = m_pvCollisions[i * 3 + 1];
		vEdge[1][0] = m_pvCollisions[i * 3 + 1];
		vEdge[1][1] = m_pvCollisions[i * 3 + 2];
		vEdge[2][0] = m_pvCollisions[i * 3 + 2];
		vEdge[2][1] = m_pvCollisions[i * 3];

		// 걸쳐 있는 메시 만큼 생성...
		for (int j = 0; j < 3; j++)
		{
			// 범위를 정하고..
			int xx1 = 0, xx2 = 0, zz1 = 0, zz2 = 0;

			if (vEdge[j][0].x < vEdge[j][1].x)
			{
				xx1 = (int) (vEdge[j][0].x / CELL_SUB_SIZE) - 1;
				xx2 = (int) (vEdge[j][1].x / CELL_SUB_SIZE) + 1;
			}
			else
			{
				xx1 = (int) (vEdge[j][1].x / CELL_SUB_SIZE) - 1;
				xx2 = (int) (vEdge[j][0].x / CELL_SUB_SIZE) + 1;
			}

			if (xx1 < 0)
				xx1 = 0;

			if (xx1 >= xSMax)
				xx1 = xSMax - 1;

			if (xx2 < 0)
				xx2 = 0;

			if (xx2 >= xSMax)
				xx2 = xSMax - 1;

			if (vEdge[j][0].z < vEdge[j][1].z)
			{
				zz1 = (int) (vEdge[j][0].z / CELL_SUB_SIZE) - 1;
				zz2 = (int) (vEdge[j][1].z / CELL_SUB_SIZE) + 1;
			}
			else
			{
				zz1 = (int) (vEdge[j][1].z / CELL_SUB_SIZE) - 1;
				zz2 = (int) (vEdge[j][0].z / CELL_SUB_SIZE) + 1;
			}

			if (zz1 < 0) zz1 = 0;
			if (zz1 >= zSMax) zz1 = zSMax - 1;
			if (zz2 < 0) zz2 = 0;
			if (zz2 >= zSMax) zz2 = zSMax - 1;

			// 범위만큼 처리..
			for (int z = zz1; z <= zz2; z++)
			{
				float fZMin = (float) (z * CELL_SUB_SIZE);
				float fZMax = (float) ((z + 1) * CELL_SUB_SIZE);

				for (int x = xx1; x <= xx2; x++)
				{
					float fXMin = (float) (x * CELL_SUB_SIZE);
					float fXMax = (float) ((x + 1) * CELL_SUB_SIZE);

					// Cohen thuderland algorythm
					uint32_t dwOC0 = 0, dwOC1 = 0; // OutCode 0, 1
					if (vEdge[j][0].z > fZMax)
						dwOC0 |= 0xf000;

					if (vEdge[j][0].z < fZMin)
						dwOC0 |= 0x0f00;

					if (vEdge[j][0].x > fXMax)
						dwOC0 |= 0x00f0;

					if (vEdge[j][0].x < fXMin)
						dwOC0 |= 0x000f;

					if (vEdge[j][1].z > fZMax)
						dwOC1 |= 0xf000;

					if (vEdge[j][1].z < fZMin)
						dwOC1 |= 0x0f00;

					if (vEdge[j][1].x > fXMax)
						dwOC1 |= 0x00f0;

					if (vEdge[j][1].x < fXMin)
						dwOC1 |= 0x000f;

					bool bWriteID = false;

					// 두 끝점이 같은 변의 외부에 있다.
					if (dwOC0 & dwOC1)
						bWriteID = false;
					// 선분이 사각형 내부에 있음
					else if (dwOC0 == 0 && dwOC1 == 0)
						bWriteID = true;
					// 선분 한점은 셀의 내부에 한점은 외부에 있음.
					else if ((dwOC0 == 0 && dwOC1 != 0)
						|| (dwOC0 != 0 && dwOC1 == 0))
						bWriteID = true;
					// 두 꿑점 모두 셀 외부에 있지만 판단을 다시 해야 한다.
					else if ((dwOC0 & dwOC1) == 0)
					{
						// 위의 변과의 교차점을 계산하고..
						float fXCross = vEdge[j][0].x + (fZMax - vEdge[j][0].z) * (vEdge[j][1].x - vEdge[j][0].x) / (vEdge[j][1].z - vEdge[j][0].z);
						if (fXCross < fXMin)
							bWriteID = false; // 완전히 외곽에 있다.
						else
							bWriteID = true; // 걸처있다.
					}

					// 만약 걸린게 없다면... 위에서 직선을 쏘아서 충돌인지 체크한다.
					if (!bWriteID)
					{
						__Vector3 vPos, vDir;
						vDir.Set(0, -1.0f, 0);

						float zz3 = static_cast<float>(z * CELL_SUB_SIZE),
							zz4 = static_cast<float>((z + 1) * CELL_SUB_SIZE);
						float xx3 = static_cast<float>(x * CELL_SUB_SIZE),
							xx4 = static_cast<float>((x + 1) * CELL_SUB_SIZE);
						for (float fZ = zz3; fZ <= zz4 && !bWriteID; fZ += 0.25f)
						{
							for (float fX = xx3; fX <= xx4 && !bWriteID; fX += 0.25f)
							{
								vPos.Set(fX, 10000.0f, fZ);

								// 폴리곤 충돌 체크..
								if (::_IntersectTriangle(vPos, vDir, m_pvCollisions[i * 3], m_pvCollisions[i * 3 + 1], m_pvCollisions[i * 3 + 2]))
									bWriteID = true; // 충돌 폴리곤 인덱스를 쓰게 만든다..
							}
						}
					}

					// 충돌 폴리곤 쓸일 없소..
					if (!bWriteID)
						continue;

					// 충돌 정보를 써야 한다..
					int nX = x / CELL_MAIN_DIVIDE;
					int nZ = z / CELL_MAIN_DIVIDE;
					if (nX < 0
						|| nX >= MAX_CELL_MAIN
						|| nZ < 0
						|| nZ >= MAX_CELL_MAIN)
						continue;

					if (m_pCells[nX][nZ] == nullptr)
						m_pCells[nX][nZ] = new __CellMain;

					int nXSub = x % CELL_MAIN_DIVIDE;
					int nZSub = z % CELL_MAIN_DIVIDE;

					__CellSub* pSubCell = &(m_pCells[nX][nZ]->SubCells[nXSub][nZSub]);
					int nCCPC = pSubCell->nCCPolyCount; // Collision Check Polygon Count

					bool bOverlapped = false;
					for (int k = 0; k < nCCPC; k++) // 중복 되는지 체크
					{
						if (i * 3 == pSubCell->pdwCCVertIndices[k * 3])
						{
							bOverlapped = true;
							break;
						}
					}

					// 겹친게 있는지 체크
					if (bOverlapped)
						continue;

					// 중복된게 없으면..
					if (0 == nCCPC) // 첨 생성 되었으면..
					{
						pSubCell->pdwCCVertIndices = new uint32_t[768];
						memset(pSubCell->pdwCCVertIndices, 0, 768 * 4);
					}
//					else // 이미 있으면..
//					{
//						uint32_t* pwBack = pSubCell->pdwCCVertIndices;
//						pSubCell->pdwCCVertIndices = new uint32_t[(nCCPC+1)*3];
//						memcpy(pSubCell->pdwCCVertIndices, pwBack, nCCPC * 3 * 4); // 점세개가 하나의 폴리곤이고 워드 인덱스이므로..
//						delete [] pwBack;
//					}

					if (nCCPC >= 256)
					{
						__ASSERT(0, "충돌 체크 폴리곤 수가 너무 많습니다");
						continue;
					}

					pSubCell->pdwCCVertIndices[nCCPC * 3 + 0] = i * 3 + 0; // 인덱스 저장..
					pSubCell->pdwCCVertIndices[nCCPC * 3 + 1] = i * 3 + 1; // 인덱스 저장..
					pSubCell->pdwCCVertIndices[nCCPC * 3 + 2] = i * 3 + 2; // 인덱스 저장..
					pSubCell->nCCPolyCount++; // Collision Check Polygon Count 를 늘린다.
				} // end of for(int x = xx1; x <= xx2; x++)
			} // end of for(int z = zz1; z <= zz2; z++) // 범위만큼 처리..
		} // end of for(int j = 0; j < 3; j++) // 걸쳐 있는 메시 만큼 생성...
	}
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
int CN3ShapeMgr::Add(CN3Shape* pShape)
{
	if (pShape == nullptr)
		return -1;

	__Vector3 vPos = pShape->Pos();
	int nX = (int) (vPos.x / CELL_MAIN_SIZE);
	int nZ = (int) (vPos.z / CELL_MAIN_SIZE);
	if (nX < 0
		|| nX >= MAX_CELL_MAIN
		|| nZ < 0
		|| nZ >= MAX_CELL_MAIN)
	{
		__ASSERT(0, "CN3ShapeMgr::Add - Shape Add Failed. Check position");
		return -1;
	}

	pShape->SaveToFile(); // 파일로 저장하고..

	CN3Shape* pShapeAdd = new CN3Shape();

	// 이 파일을 열은 다음
	if (!pShapeAdd->LoadFromFile(pShape->FileName()))
	{
		delete pShapeAdd;
		return -1;
	}

	if (m_pCells[nX][nZ] == nullptr)
		m_pCells[nX][nZ] = new __CellMain;

	int iSC = m_pCells[nX][nZ]->nShapeCount;

	// 첨 생성 되었으면..
	if (0 == iSC)
	{
		m_pCells[nX][nZ]->pwShapeIndices = new uint16_t[iSC + 1];
	}
	// 이미 있으면..
	else
	{
		uint16_t* pwBack = m_pCells[nX][nZ]->pwShapeIndices;
		m_pCells[nX][nZ]->pwShapeIndices = new uint16_t[iSC + 1];
		memcpy(m_pCells[nX][nZ]->pwShapeIndices, pwBack, iSC * 2);
		delete[] pwBack;
	}

	// 인덱스 저장..
	m_pCells[nX][nZ]->pwShapeIndices[iSC] = static_cast<uint16_t>(m_Shapes.size());

	m_Shapes.push_back(pShapeAdd); // 추가 한다..
	m_pCells[nX][nZ]->nShapeCount++; // Shape Count 를 늘린다.

	return static_cast<int>(m_Shapes.size()) - 1;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3ShapeMgr::AddCollisionTriangle(const __Vector3& v1, const __Vector3& v2, const __Vector3& v3)
{
	size_t count = m_CollisionExtras.size();
	m_CollisionExtras.push_back(v1); // 추가로 넣을 충돌체크 데이터
	m_CollisionExtras.push_back(v2); // 추가로 넣을 충돌체크 데이터
	m_CollisionExtras.push_back(v3); // 추가로 넣을 충돌체크 데이터

	if ((count + 3) == m_CollisionExtras.size())
		return true;

	return false;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
void CN3ShapeMgr::MakeMoveTable(int16_t** pMoveArray)
{
	int ArraySize = (MAX_CELL_MAIN * CELL_MAIN_DIVIDE) + 1;

	for (int bx = 0; bx < MAX_CELL_MAIN; bx++)
	{
		for (int bz = 0; bz < MAX_CELL_MAIN; bz++)
		{
			if (m_pCells[bx][bz] == nullptr)
				continue;

			for (int sx = 0; sx < CELL_MAIN_DIVIDE; sx++)
			{
				for (int sz = 0; sz < CELL_MAIN_DIVIDE; sz++)
				{
					if (m_pCells[bx][bz]->SubCells[sx][sz].nCCPolyCount <= 0)
						continue;

					int ix = (bx * CELL_MAIN_DIVIDE) + sx;
					int iz = (bz * CELL_MAIN_DIVIDE) + sz;
					pMoveArray[ix][iz] = 0;
				} //for(int sz=0; sz<CELL_MAIN_DIVIDE; sz++)
			} //for(int sx=0; sx<CELL_MAIN_DIVIDE; sx++)
		}
	}
}
#endif // end of _N3TOOL

#ifndef _3DSERVER
void CN3ShapeMgr::Tick()
{
	int xMainS = (int) ((s_CameraData.vEye.x - s_CameraData.fFP) / CELL_MAIN_SIZE);
	if (xMainS < 0)
		xMainS = 0;

	int xMainE = (int) ((s_CameraData.vEye.x + s_CameraData.fFP) / CELL_MAIN_SIZE);
	if (xMainE > MAX_CELL_MAIN)
		xMainE = MAX_CELL_MAIN;

	int zMainS = (int) ((s_CameraData.vEye.z - s_CameraData.fFP) / CELL_MAIN_SIZE);
	if (zMainS < 0)
		zMainS = 0;

	int zMainE = (int) ((s_CameraData.vEye.z + s_CameraData.fFP) / CELL_MAIN_SIZE);
	if (zMainE > MAX_CELL_MAIN)
		zMainE = MAX_CELL_MAIN;

	int iSC = static_cast<int>(m_Shapes.size());

	m_ShapesToRender.clear();

	// 렌더링 리스트 비우고..
	for (int zM = zMainS; zM < zMainE; zM++)
	{
		for (int xM = xMainS; xM < xMainE; xM++)
		{
			__CellMain* pCellCur = m_pCells[xM][zM];
			if (pCellCur == nullptr)
				continue;

			int iSCC = pCellCur->nShapeCount;
			for (int i = 0; i < iSCC; i++)
			{
				int iSIndex = pCellCur->pwShapeIndices[i];
				__ASSERT(iSIndex >= 0 && iSIndex < iSC, "Shape Index is invalid");

				CN3Shape* pShape = m_Shapes[iSIndex];
				
				pShape->Tick();
				if (pShape->m_bDontRender)
					continue;

				m_ShapesToRender.push_back(pShape);
			}
		}
	}
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
void CN3ShapeMgr::Render()
{
	for (CN3Shape* pShape : m_ShapesToRender)
	{
		__ASSERT(pShape, "Shape pointer is null!!!");

		pShape->Render();
#if _DEBUG
		pShape->RenderCollisionMesh();
#endif
	}
}
#endif // end of #ifndef _3DSERVER

bool CN3ShapeMgr::CheckCollision(
	const __Vector3& vPos,		// 충돌 위치
	const __Vector3& vDir,		// 방향 벡터
	float fSpeedPerSec,			// 초당 움직이는 속도
	__Vector3* pvCol,			// 충돌 지점 (crash position)
	__Vector3* pvNormal,		// 충돌한면의 법선벡터 (crash normal)
	__Vector3* pVec)			// 충돌한 면 의 폴리곤 __Vector3[3] (polygon/triangle of crash)
{
	// 움직이는 속도가 없거나 반대로 움직이면 넘어간다..
	if (fSpeedPerSec <= 0)
		return false;

	static __CellSub* ppCells[128];

	// 다음 위치
	__Vector3 vPosNext = vPos + (vDir * fSpeedPerSec);

	int iSubCellCount = 0;

	if (fSpeedPerSec < 4.0f)
	{
		__Vector3 vPos2 = vPos + (vDir * 4.0f);
		iSubCellCount = SubCellPathThru(vPos, vPos2, 128, ppCells); // 통과하는 서브셀을 가져온다..
	}
	else
	{
		iSubCellCount = SubCellPathThru(vPos, vPosNext, 128, ppCells); // 통과하는 서브셀을 가져온다..
	}

	// 없음 말자.
	if (iSubCellCount <= 0)
		return false;

	__Vector3 vColTmp(0, 0, 0);
	int nIndex0, nIndex1, nIndex2;
	static float fT, fU, fV;
	float fDistClosest = FLT_MAX;

	for (int i = 0; i < iSubCellCount; i++)
	{
		if (ppCells[i]->nCCPolyCount <= 0)
			continue;

		for (int j = 0; j < ppCells[i]->nCCPolyCount; j++)
		{
			nIndex0 = ppCells[i]->pdwCCVertIndices[j * 3];
			nIndex1 = ppCells[i]->pdwCCVertIndices[j * 3 + 1];
			nIndex2 = ppCells[i]->pdwCCVertIndices[j * 3 + 2];

			// NOTE: does the vector intersect the triangle?
			if (!::_IntersectTriangle(vPos, vDir, m_pvCollisions[nIndex0], m_pvCollisions[nIndex1], m_pvCollisions[nIndex2], fT, fU, fV, &vColTmp))
				continue;

			if (::_IntersectTriangle(vPosNext, vDir, m_pvCollisions[nIndex0], m_pvCollisions[nIndex1], m_pvCollisions[nIndex2]))
				continue;

			float fDistTmp = (vPos - vColTmp).Magnitude(); // 거리를 재보고..
			if (fDistTmp < fDistClosest)
			{
				fDistClosest = fDistTmp;

				// 충돌이다..
				if (pvCol != nullptr)
					*pvCol = vColTmp;

				if (pvNormal != nullptr)
				{
					pvNormal->Cross(
						m_pvCollisions[nIndex1] - m_pvCollisions[nIndex0],
						m_pvCollisions[nIndex2] - m_pvCollisions[nIndex0]);
					pvNormal->Normalize();
				}

				if (pVec != nullptr)
				{
					pVec[0] = m_pvCollisions[nIndex0];
					pVec[1] = m_pvCollisions[nIndex1];
					pVec[2] = m_pvCollisions[nIndex2];
				}
			}
		}
	}

	if (fDistClosest != FLT_MAX)
		return true;

#ifndef _3DSERVER
	// 눈에 보이는것만 대상으로 해서...
	if (!m_ShapesToRender.empty())
	{
		// 거리순으로 정렬..
		std::vector<CN3Shape*> Shapes;
		Shapes.reserve(m_ShapesToRender.size());

		for (CN3Shape* pShape : m_ShapesToRender)
		{
			if (pShape->CollisionMesh() == nullptr)
				continue;

			// 멀리 떨어진거면 지나간다..
			if ((pShape->Pos() - vPos).Magnitude() > pShape->Radius() * 2)
				continue;

			Shapes.push_back(pShape);
		}

		if (Shapes.empty())
			return false;

		// 카메라 거리에 따라 정렬하고..
		if (Shapes.size() > 1)
			qsort(&Shapes[0], Shapes.size(), sizeof(CN3Shape*), SortByCameraDistance);

		for (CN3Shape* pShape : Shapes)
		{
			CN3VMesh* pVMesh = pShape->CollisionMesh();
			if (pVMesh->CheckCollision(pShape->m_Matrix, vPos, vPosNext, pvCol, pvNormal))
				return true;
		}
	}
#endif // end of #ifndef _3DSERVER

	return false;
}

#ifndef _3DSERVER
bool CN3ShapeMgr::CheckCollisionCamera(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	__Vector3 vDir = vEyeResult - vAt;
	float fD = vDir.Magnitude();
	vDir.Normalize();
	__Vector3 vCol(0, 0, 0);
	if (!CheckCollision(vAt, vDir, fD, &vCol))
		return false;

	// 충돌점과 처다보는 거리를 재보고..
	float fDelta = (vEyeResult - vCol).Magnitude();

	// 너무 가까이 붙으면 돌아간다..
	if (fDelta < fNP * 2.0f)
		return false;

	vEyeResult -= vDir * fDelta;
	return true;
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
void CN3ShapeMgr::RenderCollision(const __Vector3& vPos)
{
	int x = (int) (vPos.x / CELL_MAIN_SIZE);
	int z = (int) (vPos.z / CELL_MAIN_SIZE);

	__CellSub* ppCell[9] = {};
	SubCell(vPos, ppCell);

	__Matrix44 mtxWorld;
	mtxWorld.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D());

	DWORD dwFillPrev;
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwFillPrev);
	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
	DWORD dwLight;
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
//	DWORD dwZ;
//	s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
//	s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	s_lpD3DDev->SetTexture(0, nullptr);

	for (int i = 0; i < 9; i++)
	{
		if (ppCell[i] == nullptr
			|| ppCell[i]->nCCPolyCount <= 0)
			continue;

		int nFC = ppCell[i]->nCCPolyCount;
		int n0, n1, n2;

		__VertexColor vCols[4];
		__VertexColor vNormalDir[2];
		__Vector3 vDir;

		for (int j = 0; j < nFC; j++)
		{
			n0 = ppCell[i]->pdwCCVertIndices[j * 3 + 0];
			n1 = ppCell[i]->pdwCCVertIndices[j * 3 + 1];
			n2 = ppCell[i]->pdwCCVertIndices[j * 3 + 2];

			vCols[0].Set(m_pvCollisions[n0], 0xffff0000);
			vCols[1].Set(m_pvCollisions[n1], 0xff00ff00);
			vCols[2].Set(m_pvCollisions[n2], 0xff0000ff);
//			vCols[3] = vCols[0]; vCols[3].color = 0xffffffff;

			vDir.Cross(
				(m_pvCollisions[n1] - m_pvCollisions[n0]),
				(m_pvCollisions[n2] - m_pvCollisions[n1]));
			
			vDir.Normalize();

			vNormalDir[0] = (m_pvCollisions[n0] + m_pvCollisions[n1] + m_pvCollisions[n2]) / 3.0f;
			vNormalDir[1] = vNormalDir[0] + vDir;
			vNormalDir[0].color = 0xffff0000;
			vNormalDir[1].color = 0xffffffff;

			s_lpD3DDev->SetFVF(FVF_CV);
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 1, vCols, sizeof(__VertexColor));
			s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 1, vNormalDir, sizeof(__VertexColor));
		}
	}

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwFillPrev);
	s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
//	s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
CN3Shape* CN3ShapeMgr::Pick(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick)
{
	if (m_ShapesToRender.empty())
		return nullptr;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		iXScreen, iYScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	// 눈에 보이는것만 대상으로 해서...
	size_t shapeCount = m_ShapesToRender.size();

	// 거리순으로 정렬..
	std::vector<CN3Shape*> Shapes(m_ShapesToRender.begin(), m_ShapesToRender.end());

	if (Shapes.size() > 1)
		qsort(&Shapes[0], shapeCount, sizeof(CN3Shape*), SortByCameraDistance);

	for (CN3Shape* pShape : Shapes)
	{
		// 이벤트가 있어야 한다면...
		if (bMustHaveEvent
			&& pShape->m_iEventID <= 0)
			continue;

		if (pShape->CheckCollisionPrecisely(false, vPos, vDir, pvPick) >= 0)
			return pShape;
	}

	return nullptr;
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
CN3Shape* CN3ShapeMgr::PickMovable(int iXScreen, int iYScreen, __Vector3* pvPick)
{
	if (m_ShapesToRender.empty())
		return nullptr;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		iXScreen, iYScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	// 눈에 보이는것만 대상으로 해서...
	// 거리순으로 정렬..
	std::vector<CN3Shape*> Shapes(m_ShapesToRender.begin(), m_ShapesToRender.end());

	if (Shapes.size() > 1)
		qsort(&Shapes[0], Shapes.size(), sizeof(CN3Shape*), SortByCameraDistance);

	for (CN3Shape* pShape : Shapes)
	{
		if (pShape->CheckCollisionPrecisely(false, vPos, vDir, pvPick) >= 0)
			return pShape;
	}

	return nullptr;
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
CN3Shape* CN3ShapeMgr::ShapeGetByID(int iID)
{
	for (CN3Shape* pShape : m_ShapesHaveID)
	{
		if (pShape->m_iEventID == iID)
			return pShape;
	}

	return nullptr;
}
#endif // end of #ifndef _3DSERVER

#ifndef _3DSERVER
int CN3ShapeMgr::SortByCameraDistance(const void* pArg1, const void* pArg2)
{
	CN3Shape* pShape1 = *((CN3Shape**) pArg1);
	CN3Shape* pShape2 = *((CN3Shape**) pArg2);

	float fDist1 = (CN3Base::s_CameraData.vEye - pShape1->Pos()).Magnitude();
	float fDist2 = (CN3Base::s_CameraData.vEye - pShape2->Pos()).Magnitude();

	if (fDist1 < fDist2)
		return -1; // 가까우면 true
	else if (fDist1 > fDist2)
		return 1;

	return 0;
}
#endif // end of #ifndef _3DSERVER

// 벡터 사이에 걸친 셀포인터 돌려준다..
int CN3ShapeMgr::SubCellPathThru(const __Vector3& vFrom, const __Vector3& vAt, int iMaxSubCell, __CellSub** ppSubCells)
{
	if (ppSubCells == nullptr)
		return 0;

	// 범위를 정하고..
	int xx1 = 0, xx2 = 0, zz1 = 0, zz2 = 0;

	if (vFrom.x < vAt.x)
	{
		xx1 = (int) (vFrom.x / CELL_SUB_SIZE);
		xx2 = (int) (vAt.x / CELL_SUB_SIZE);
	}
	else
	{
		xx1 = (int) (vAt.x / CELL_SUB_SIZE);
		xx2 = (int) (vFrom.x / CELL_SUB_SIZE);
	}

	if (vFrom.z < vAt.z)
	{
		zz1 = (int) (vFrom.z / CELL_SUB_SIZE);
		zz2 = (int) (vAt.z / CELL_SUB_SIZE);
	}
	else
	{
		zz1 = (int) (vAt.z / CELL_SUB_SIZE);
		zz2 = (int) (vFrom.z / CELL_SUB_SIZE);
	}

	bool bPathThru;
	float fZMin, fZMax, fXMin, fXMax;
	int iSubCellCount = 0;
	for (int z = zz1; z <= zz2; z++) // 범위만큼 처리..
	{
		fZMin = (float) (z * CELL_SUB_SIZE);
		fZMax = (float) ((z + 1) * CELL_SUB_SIZE);

		for (int x = xx1; x <= xx2; x++)
		{
			fXMin = (float) (x * CELL_SUB_SIZE);
			fXMax = (float) ((x + 1) * CELL_SUB_SIZE);

			// Cohen thuderland algorythm
			uint32_t dwOC0 = 0, dwOC1 = 0; // OutCode 0, 1
			if (vFrom.z > fZMax)
				dwOC0 |= 0xf000;

			if (vFrom.z < fZMin)
				dwOC0 |= 0x0f00;

			if (vFrom.x > fXMax)
				dwOC0 |= 0x00f0;

			if (vFrom.x < fXMin)
				dwOC0 |= 0x000f;

			if (vAt.z > fZMax)
				dwOC1 |= 0xf000;

			if (vAt.z < fZMin)
				dwOC1 |= 0x0f00;

			if (vAt.x > fXMax)
				dwOC1 |= 0x00f0;

			if (vAt.x < fXMin)
				dwOC1 |= 0x000f;

			bPathThru = false;

			// 두 끝점이 같은 변의 외부에 있다.
			if (dwOC0 & dwOC1)
				bPathThru = false;
			// 선분이 사각형 내부에 있음
			else if (dwOC0 == 0 && dwOC1 == 0)
				bPathThru = true;
			// 선분 한점은 셀의 내부에 한점은 외부에 있음.
			else if ((dwOC0 == 0 && dwOC1 != 0)
				|| (dwOC0 != 0 && dwOC1 == 0))
				bPathThru = true;
			// 두 L점 모두 셀 외부에 있지만 판단을 다시 해야 한다.
			else if ((dwOC0 & dwOC1) == 0)
			{
				// 위의 변과의 교차점을 계산하고..
				float fXCross = vFrom.x + (fZMax - vFrom.z) * (vAt.x - vFrom.x) / (vAt.z - vFrom.z);
				if (fXCross < fXMin)
					bPathThru = false; // 완전히 외곽에 있다.
				else
					bPathThru = true; // 걸처있다.
			}

			if (!bPathThru)
				continue;

			// 충돌 정보를 써야 한다..
			int nX = x / CELL_MAIN_DIVIDE;
			int nZ = z / CELL_MAIN_DIVIDE;

			// 메인셀바깥에 있음 지나간다.
			if (nX < 0
				|| nX >= MAX_CELL_MAIN
				|| nZ < 0
				|| nZ >= MAX_CELL_MAIN)
				continue;

			// 메인셀이 널이면 지나간다..
			if (m_pCells[nX][nZ] == nullptr)
				continue;

			int nXSub = x % CELL_MAIN_DIVIDE;
			int nZSub = z % CELL_MAIN_DIVIDE;

			// NOTE: the check on nX and nZ isn't good enough because
			//       "z/CELL_MAIN_DIVIDE" will round a small neg "z" to zero
			//       and we'll run into an error!!!!!
			if (nXSub < 0
				|| nXSub >= (MAX_CELL_MAIN % CELL_MAIN_DIVIDE)
				|| nZSub < 0
				|| nZSub >= (MAX_CELL_MAIN % CELL_MAIN_DIVIDE))
				continue;

			ppSubCells[iSubCellCount++] = &m_pCells[nX][nZ]->SubCells[nXSub][nZSub];

			if (iSubCellCount >= iMaxSubCell)
				return iMaxSubCell;
		} // end of for(int x = xx1; x <= xx2; x++)
	} // end of for(int z = zz1; z <= zz2; z++) // 범위만큼 처리..

	return iSubCellCount; // 걸친 셀 포인터 돌려주기..
}

// 가장 가까운 높이값을 돌려준다. 없으면 -FLT_MAX 을 돌려준다.
float CN3ShapeMgr::GetHeightNearstPos(const __Vector3& vPos, float fDist, __Vector3* pvNormal)
{
	__CellSub* pCell = SubCell(vPos.x, vPos.z); // 서브셀을 가져온다..

	// 없음 말자.
	if (pCell == nullptr
		|| pCell->nCCPolyCount <= 0)
		return -FLT_MAX;

	// 꼭대기에 위치를 하고..
	__Vector3 vPosV = vPos;
	vPosV.y = 5000.0f;

	__Vector3 vDir(0, -1, 0); // 수직 방향 벡터
	__Vector3 vColTmp(0, 0, 0); // 최종적으로 가장 가까운 충돌 위치..

	int nIndex0, nIndex1, nIndex2;
	float fT, fU, fV;
	float fNearst = FLT_MAX, fHeight = -FLT_MAX;		// 일단 최소값을 큰값으로 잡고..

	for (int i = 0; i < pCell->nCCPolyCount; i++)
	{
		nIndex0 = pCell->pdwCCVertIndices[i * 3];
		nIndex1 = pCell->pdwCCVertIndices[i * 3 + 1];
		nIndex2 = pCell->pdwCCVertIndices[i * 3 + 2];

		// 충돌된 점이 있으면..
		if (!::_IntersectTriangle(vPosV, vDir, m_pvCollisions[nIndex0], m_pvCollisions[nIndex1], m_pvCollisions[nIndex2], fT, fU, fV, &vColTmp))
			continue;

		float fMinTmp = (vColTmp - vPos).Magnitude();

		// 가장 가까운 충돌 위치를 찾기 위한 코드..
		if (fMinTmp < fNearst)
		{
			fNearst = fMinTmp;
			fHeight = vColTmp.y; // 높이값.

			if (pvNormal != nullptr)
			{
				pvNormal->Cross(
					m_pvCollisions[nIndex1] - m_pvCollisions[nIndex0],
					m_pvCollisions[nIndex2] - m_pvCollisions[nIndex0]);
				pvNormal->Normalize();
			}
		}
	}

	return fHeight;
}

// 가장 가까운 높이값을 돌려준다. 없으면 -FLT_MAX 을 돌려준다.
float CN3ShapeMgr::GetHeightNearstPos(const __Vector3& vPos, __Vector3* pvNormal)
{
	__CellSub* pCell = SubCell(vPos.x, vPos.z); // 서브셀을 가져온다..

	// 없음 말자.
	if (pCell == nullptr
		|| pCell->nCCPolyCount <= 0)
		return -FLT_MAX;

	// 꼭대기에 위치를 하고..
	__Vector3 vPosV = vPos;
	vPosV.y = 5000.0f;

	__Vector3 vDir(0, -1, 0); // 수직 방향 벡터
	__Vector3 vColTmp(0, 0, 0); // 최종적으로 가장 가까운 충돌 위치..

	int nIndex0, nIndex1, nIndex2;
	float fT, fU, fV;
	float fNearst = FLT_MAX, fHeight = -FLT_MAX;		// 일단 최소값을 큰값으로 잡고..

	for (int i = 0; i < pCell->nCCPolyCount; i++)
	{
		nIndex0 = pCell->pdwCCVertIndices[i * 3];
		nIndex1 = pCell->pdwCCVertIndices[i * 3 + 1];
		nIndex2 = pCell->pdwCCVertIndices[i * 3 + 2];

		// 충돌된 점이 있으면..
		if (!::_IntersectTriangle(vPosV, vDir, m_pvCollisions[nIndex0], m_pvCollisions[nIndex1], m_pvCollisions[nIndex2], fT, fU, fV, &vColTmp))
			continue;

		float fMinTmp = (vColTmp - vPos).Magnitude();

		// 가장 가까운 충돌 위치를 찾기 위한 코드..
		if (fMinTmp < fNearst)
		{
			fNearst = fMinTmp;
			fHeight = vColTmp.y; // 높이값.

			if (pvNormal != nullptr)
			{
				pvNormal->Cross(
					m_pvCollisions[nIndex1] - m_pvCollisions[nIndex0],
					m_pvCollisions[nIndex2] - m_pvCollisions[nIndex0]);
				pvNormal->Normalize();
			}
		}
	}

	return fHeight;
}

// 가장 높은 곳을 돌려준다.. 없으면 -FLT_MAX값을 돌려준다.
float CN3ShapeMgr::GetHeight(float fX, float fZ, __Vector3* pvNormal)
{
	__CellSub* pCell = SubCell(fX, fZ); // 서브셀을 가져온다..

	// 없음 말자.
	if (pCell == nullptr
		|| pCell->nCCPolyCount <= 0)
		return -FLT_MAX;

	__Vector3 vPosV(fX, 5000.0f, fZ); // 꼭대기에 위치를 하고..
	__Vector3 vDir(0, -1, 0); // 수직 방향 벡터
	__Vector3 vColTmp(0, 0, 0); // 최종적으로 가장 가까운 충돌 위치..

	float fT, fU, fV;
	float fMaxTmp = -FLT_MAX;

	for (int i = 0; i < pCell->nCCPolyCount; i++)
	{
		int nIndex0 = pCell->pdwCCVertIndices[i * 3];
		int nIndex1 = pCell->pdwCCVertIndices[i * 3 + 1];
		int nIndex2 = pCell->pdwCCVertIndices[i * 3 + 2];

		// 충돌된 점이 있으면..
		if (!::_IntersectTriangle(vPosV, vDir, m_pvCollisions[nIndex0], m_pvCollisions[nIndex1], m_pvCollisions[nIndex2], fT, fU, fV, &vColTmp))
			continue;

		if (vColTmp.y > fMaxTmp)
		{
			fMaxTmp = vColTmp.y;

			if (pvNormal != nullptr)
			{
				pvNormal->Cross(
					m_pvCollisions[nIndex1] - m_pvCollisions[nIndex0],
					m_pvCollisions[nIndex2] - m_pvCollisions[nIndex0]);
				pvNormal->Normalize();
			}
		}
	}

	return fMaxTmp;
}

// 해당 위치의 셀 포인터를 돌려준다.
void CN3ShapeMgr::SubCell(const __Vector3& vPos, __CellSub** ppSubCell)
{
	int x = (int) (vPos.x / CELL_MAIN_SIZE);
	int z = (int) (vPos.z / CELL_MAIN_SIZE);

	__ASSERT(x >= 0 && x < MAX_CELL_MAIN && z >= 0 && z < MAX_CELL_MAIN, "Invalid cell number");

	int xx = (((int) vPos.x) % CELL_MAIN_SIZE) / CELL_SUB_SIZE;
	int zz = (((int) vPos.z) % CELL_MAIN_SIZE) / CELL_SUB_SIZE;

	// 2, 3, 4
	// 1, 0, 5
	// 8, 7, 6
	for (int i = 0; i < 9; i++)
	{
		switch (i)
		{
			case 0:
				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx][zz];
				else
					ppSubCell[i] = nullptr;
				break;

			case 1:
				if ((x == 0)
					&& (xx == 0))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if ((x != 0)
					&& (xx == 0))
				{
					if (m_pCells[x - 1][z] != nullptr)
						ppSubCell[i] = &m_pCells[x - 1][z]->SubCells[CELL_MAIN_DIVIDE - 1][zz];
					else
						ppSubCell[i] = nullptr;
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx - 1][zz];
				else
					ppSubCell[i] = nullptr;
				break;

			case 2:
				if (x == 0
					&& xx == 0)
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z == (CELL_MAIN_SIZE - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				// x 감소, z 증가.
				if (x != 0
					&& xx == 0)
				{
					if ((z != (MAX_CELL_MAIN - 1))
						&& (zz == (CELL_MAIN_DIVIDE - 1)))
					{
						if (m_pCells[x - 1][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z + 1]->SubCells[CELL_MAIN_DIVIDE - 1][0];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x - 1][z] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z]->SubCells[CELL_MAIN_DIVIDE - 1][zz + 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				// x 감소, z 증가.
				if (z != (MAX_CELL_MAIN - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					if (x != 0
						&& xx == 0)
					{
						if (m_pCells[x - 1][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z + 1]->SubCells[CELL_MAIN_DIVIDE - 1][0];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x][z + 1]->SubCells[xx - 1][0];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx - 1][zz + 1];
				else
					ppSubCell[i] = nullptr;
				break;

			// z 증가.
			case 3:
				if (z == (MAX_CELL_MAIN - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z != (MAX_CELL_MAIN - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					if (m_pCells[x - 1][z] != nullptr)
						ppSubCell[i] = &m_pCells[x - 1][z]->SubCells[xx][0];
					else
						ppSubCell[i] = nullptr;
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx][zz + 1];
				else
					ppSubCell[i] = nullptr;
				break;

			// x 증가, z 증가.
			case 4:
				if (x == (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z == (MAX_CELL_MAIN - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (x != (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					if (z != (MAX_CELL_MAIN - 1)
						&& zz == (CELL_MAIN_DIVIDE - 1))
					{
						if (m_pCells[x + 1][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z + 1]->SubCells[0][0];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x + 1][z] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z]->SubCells[0][zz + 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (z != (MAX_CELL_MAIN - 1)
					&& zz == (CELL_MAIN_DIVIDE - 1))
				{
					if (x != (MAX_CELL_MAIN - 1)
						&& xx == (CELL_MAIN_DIVIDE - 1))
					{
						if (m_pCells[x + 1][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z + 1]->SubCells[0][0];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x][z + 1] != nullptr)
							ppSubCell[i] = &m_pCells[x][z + 1]->SubCells[xx + 1][0];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx + 1][zz + 1];
				else
					ppSubCell[i] = nullptr;
				break;

			// x 증가.
			case 5:
				if (x == (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (x != (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					if (m_pCells[x + 1][z] != nullptr)
						ppSubCell[i] = &m_pCells[x + 1][z]->SubCells[0][zz];
					else
						ppSubCell[i] = nullptr;
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx + 1][zz];
				else
					ppSubCell[i] = nullptr;
				break;

			// x 증가. z 감소.
			case 6:
				if (x == (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z == 0
					&& zz == 0)
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (x != (MAX_CELL_MAIN - 1)
					&& xx == (CELL_MAIN_DIVIDE - 1))
				{
					if (z != 0
						&& zz == 0)
					{
						if (m_pCells[x + 1][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z - 1]->SubCells[0][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x + 1][z] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z]->SubCells[0][zz - 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (z != 0
					&& zz == 0)
				{
					if (x != (CELL_MAIN_SIZE - 1)
						&& xx == (CELL_MAIN_DIVIDE - 1))
					{
						if (m_pCells[x + 1][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x + 1][z - 1]->SubCells[0][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x][z - 1]->SubCells[xx + 1][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx + 1][zz - 1];
				else
					ppSubCell[i] = nullptr;
				break;

			// z 감소.
			case 7:
				if (z == 0
					&& zz == 0)
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z != 0
					&& zz == 0)
				{
					if (m_pCells[x][z - 1] != nullptr)
						ppSubCell[i] = &m_pCells[x][z - 1]->SubCells[xx][CELL_MAIN_DIVIDE - 1];
					else
						ppSubCell[i] = nullptr;
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx][zz - 1];
				else
					ppSubCell[i] = nullptr;
				break;

			// x 감소, z 감소.
			case 8:
				if (x == 0
					&& xx == 0)
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (z == 0
					&& zz == 0)
				{
					ppSubCell[i] = nullptr;
					break;
				}

				if (x != 0
					&& xx == 0)
				{
					if (z != 0
						&& zz == 0)
					{
						if (m_pCells[x - 1][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z - 1]->SubCells[CELL_MAIN_DIVIDE - 1][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x - 1][z] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z]->SubCells[CELL_MAIN_DIVIDE - 1][zz - 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (z != 0
					&& zz == 0)
				{
					if (x != 0
						&& xx == 0)
					{
						if (m_pCells[x - 1][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x - 1][z - 1]->SubCells[CELL_MAIN_DIVIDE - 1][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					else
					{
						if (m_pCells[x][z - 1] != nullptr)
							ppSubCell[i] = &m_pCells[x][z - 1]->SubCells[xx - 1][CELL_MAIN_DIVIDE - 1];
						else
							ppSubCell[i] = nullptr;
					}
					break;
				}

				if (m_pCells[x][z] != nullptr)
					ppSubCell[i] = &m_pCells[x][z]->SubCells[xx - 1][zz - 1];
				else
					ppSubCell[i] = nullptr;
				break;
		}	// switch
	}	// for 
}

// ===== END N3Base/N3ShapeMgr.cpp =====

// ===== BEGIN N3Base/N3ShapeMgr.h =====
#line 1 "N3Base/N3ShapeMgr.h"
﻿#pragma once

#ifdef _3DSERVER
#include "My_3DStruct.h"
#else
#include "N3BaseFileAccess.h"
#endif // end of #ifndef _3DSERVER

constexpr int CELL_MAIN_DIVIDE = 4; // 메인셀은 4 X 4 의 서브셀로 나뉜다..
constexpr int CELL_SUB_SIZE = 4; // 4 Meter 가 서브셀의 사이즈이다..
constexpr int CELL_MAIN_SIZE = CELL_MAIN_DIVIDE * CELL_SUB_SIZE; // 메인셀 크기는 서브셀갯수 X 서브셀 크기이다.
constexpr int MAX_CELL_MAIN = 4096 / CELL_MAIN_SIZE; // 메인셀의 최대 갯수는 지형크기 / 메인셀크기 이다.
constexpr int MAX_CELL_SUB = MAX_CELL_MAIN * CELL_MAIN_DIVIDE; // 서브셀 최대 갯수는 메인셀 * 메인셀나눔수 이다.

#ifdef _3DSERVER
class CN3ShapeMgr
#else
#include <list>
#include <vector>
class CN3Shape;
class CN3ShapeMgr : public CN3BaseFileAccess
#endif // end of #ifndef _3DSERVER
{
public:
	struct __CellSub // 하위 셀 데이터
	{
		int 		nCCPolyCount; // Collision Check Polygon Count
		uint32_t* pdwCCVertIndices; // Collision Check Polygon Vertex Indices - wCCPolyCount * 3 만큼 생성된다.

		void Load(File& file)
		{
			file.Read(&nCCPolyCount, 4);

			if (nCCPolyCount > 0)
			{
				delete[] pdwCCVertIndices;
				pdwCCVertIndices = new uint32_t[nCCPolyCount * 3];
				__ASSERT(pdwCCVertIndices, "New memory failed");

				file.Read(pdwCCVertIndices, nCCPolyCount * 3 * 4);

				// TRACE(_T("CollisionCheckPolygon : %d\n"), nCCPolyCount);
			}
		}

#ifdef _N3TOOL
		void Save(File& file)
		{
			file.Write(&nCCPolyCount, 4);
			if (nCCPolyCount > 0)
				file.Write(pdwCCVertIndices, nCCPolyCount * 3 * 4);
		}
#endif // end of _N3TOOL

		__CellSub()
		{
			nCCPolyCount = 0;
			pdwCCVertIndices = nullptr;
		}

		~__CellSub()
		{
			delete[] pdwCCVertIndices;
		}
	};

	struct __CellMain // 기본 셀 데이터
	{
		int		nShapeCount; // Shape Count;
		uint16_t* pwShapeIndices; // Shape Indices
		__CellSub SubCells[CELL_MAIN_DIVIDE][CELL_MAIN_DIVIDE];

		void Load(File& file)
		{
			file.Read(&nShapeCount, 4);

			if (nShapeCount > 0)
			{
				delete[] pwShapeIndices;
				pwShapeIndices = new uint16_t[nShapeCount];
				file.Read(pwShapeIndices, nShapeCount * 2);
			}

			for (int z = 0; z < CELL_MAIN_DIVIDE; z++)
			{
				for (int x = 0; x < CELL_MAIN_DIVIDE; x++)
					SubCells[x][z].Load(file);
			}
		}

#ifdef _N3TOOL
		void Save(File& file)
		{
			file.Write(&nShapeCount, 4);
			if (nShapeCount > 0)
				file.Write(pwShapeIndices, nShapeCount * 2);

			for (int z = 0; z < CELL_MAIN_DIVIDE; z++)
			{
				for (int x = 0; x < CELL_MAIN_DIVIDE; x++)
					SubCells[x][z].Save(file);
			}
		}
#endif // end of _N3TOOL

		__CellMain()
		{
			nShapeCount = 0;
			pwShapeIndices = nullptr;
		}

		~__CellMain()
		{
			delete[] pwShapeIndices;
		}
	};

	__Vector3* m_pvCollisions;

protected:
#ifndef _3DSERVER
	std::vector<CN3Shape*>	m_Shapes;			// 리스트로 안 만든 이유는... 배열이 훨씬 효율적이기 때문이다.
	std::list<CN3Shape*>	m_ShapesToRender;	// Tick 을 호출하면 렌더링할 것만 추린다..
	std::list<CN3Shape*>	m_ShapesHaveID;		// ID 를 갖고 있어 NPC 가 될수 있는 Shapes....
#endif // end of #ifndef _3DSERVER

	float					m_fMapWidth;	// 맵 너비.. 미터 단위
	float					m_fMapLength;	// 맵 길이.. 미터 단위
	int						m_nCollisionFaceCount;
	__CellMain*				m_pCells[MAX_CELL_MAIN][MAX_CELL_MAIN];

#ifdef _N3TOOL
	std::list<__Vector3>	m_CollisionExtras; // 추가로 넣을 충돌체크 데이터
#endif // end of #ifedef _N3TOOL

public:
#ifndef _3DSERVER
	// 고유 ID 를 가진 오브젝트... NPC 로 쓸수 있는 오브젝트를 검색해서 돌려준다..
	CN3Shape* ShapeGetByID(int iID);

	// 위치를 돌려준다..
	CN3Shape* Pick(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr);

	CN3Shape* PickMovable(int iXScreen, int iYScreen, __Vector3* pvPick);
#endif // end of #ifndef _3DSERVER
	void SubCell(const __Vector3& vPos, __CellSub** ppSubCell);

	// 해당 위치의 셀 포인터를 돌려준다.
	__CellSub* SubCell(float fX, float fZ)
	{
		int x = (int) (fX / CELL_MAIN_SIZE);
		int z = (int) (fZ / CELL_MAIN_SIZE);

		__ASSERT(x >= 0 && x < MAX_CELL_MAIN && z >= 0 && z < MAX_CELL_MAIN, "Invalid cell number");
		if (x < 0
			|| x >= MAX_CELL_MAIN
			|| z < 0
			|| z >= MAX_CELL_MAIN)
			return nullptr;

		if (nullptr == m_pCells[x][z])
			return nullptr;

		int xx = (((int) fX) % CELL_MAIN_SIZE) / CELL_SUB_SIZE;
		int zz = (((int) fZ) % CELL_MAIN_SIZE) / CELL_SUB_SIZE;

		return &m_pCells[x][z]->SubCells[xx][zz];
	}

	// 가장 가까운 높이을 돌려준다. 없으면 -FLT_MAX 을 돌려준다.
	float		GetHeightNearstPos(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr);

	// 가장 가까운 높이을 돌려준다. 없으면 -FLT_MAX 을 돌려준다.
	float		GetHeightNearstPos(const __Vector3& vPos, __Vector3* pvNormal = nullptr);

	// 현재 지점에서 제일 높은 값을 돌려준다. 없으면 -FLT_MAX 을 돌려준다.
	float		GetHeight(float fX, float fZ, __Vector3* pvNormal = nullptr);

	// 벡터 사이에 걸친 셀포인터 돌려준다..
	int			SubCellPathThru(const __Vector3& vFrom, const __Vector3& vAt, int iMaxSubCell, __CellSub** ppSubCells);

	// 맵의 너비. 단위는 미터이다.
	float Width() const {
		return m_fMapWidth;
	}

	// 맵의 너비. 단위는 미터이다.
	float Height() const {
		return m_fMapWidth;
	}

#ifdef _N3GAME
	virtual void UpdateLoadStatus(int iLoadedShapes, int iTotalShapes) = 0;
#endif

#ifndef _3DSERVER
	void		ReleaseShapes();

	// 넣은 위치에 있는 충돌 메시를 그려준다.. 디버깅용...
	void		RenderCollision(const __Vector3& vPos);

	void		Tick();
	void		Render();
	bool		Load(File& file);
	bool		CheckCollisionCamera(__Vector3& vEye, const __Vector3& vAt, float fNP);
	static int SortByCameraDistance(const void* pArg1, const void* pArg2);
#endif // end of #ifndef _3DSERVER

	bool		CheckCollision(
		const __Vector3& vPos,			// 충돌 위치
		const __Vector3& vDir,			// 방향 벡터
		float fSpeedPerSec,				// 초당 움직이는 속도
		__Vector3* pvCol = nullptr,		// 충돌 지점
		__Vector3* pvNormal = nullptr,	// 충돌한면의 법선벡터
		__Vector3* pVec = nullptr);		// 충돌한 면 의 폴리곤 __Vector3[3]

	bool		Create(float fMapWidth, float fMapLength); // 맵의 너비와 높이를 미터 단위로 넣는다..
	bool		LoadCollisionData(File& file);

#ifdef _N3TOOL
	//지형에서 shape가 있는 타일은 1, 없는 타일은 0으로 셋팅한 테이블을 만든다.
	void		MakeMoveTable(int16_t** pMoveArray);

	int			Add(CN3Shape* pShape);
	bool		AddCollisionTriangle(const __Vector3& v1, const __Vector3& v2, const __Vector3& v3);
	void		GenerateCollisionData();
	bool		Save(File& file);
	bool		SaveCollisionData(File& file);
#endif // end of _N3TOOL

	void Release();
	CN3ShapeMgr();
	virtual ~CN3ShapeMgr();
};

// ===== END N3Base/N3ShapeMgr.h =====

// ===== BEGIN N3Base/N3ShapeMod.h =====
#line 1 "N3Base/N3ShapeMod.h"
﻿// N3ShapeMod.h: interface for the CN3ShapeMod class.
// 만든이 : dino
// n3shape의 한 일부분을 움직일 수 있게 한 클래스
// 상태(0번 상태, 1번상태, 2번상태)를 변경할 수 있다.
// 상태 변경시 (시간을 넣어주면 상태간의 pos rot scale 정보를 linear하게 변화시킨다.

// 개선점 : Shape 전체가 움직이는 상태를 추가하자
//          설계시 추가하려다 너무 복잡하여 보류함. 리마크 된 부분이 그에 관련된 것임. 추가 보강해야함.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SHAPEMOD_H__6F3C87B4_D10B_412B_B385_0ECE2D4A19A8__INCLUDED_)
#define AFX_N3SHAPEMOD_H__6F3C87B4_D10B_412B_B385_0ECE2D4A19A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Shape.h"

class CN3ShapeMod : public CN3Shape  
{
public:
	CN3ShapeMod();
	~CN3ShapeMod() override;

// Structures
protected:
	struct __ModPosRotScale
	{
		__Vector3 vPos;
		__Quaternion qRot;
		__Vector3 vScale;

		__ModPosRotScale() {vPos.Set(0,0,0); qRot.Set(0,0,0,0); vScale.Set(1,1,1);}
	};
	struct __ModPart
	{
		CN3SPart*			pPart;				// 움직일 Part
		bool				bPos;				// Pos 변화가 있는가?
		bool				bRot;				// Rot 변화가 있는가?
		bool				bScale;				// Scale 변화가 있는가?
		__ModPosRotScale*	pStateInfos;		// 움직일 상태 정보들(이동,회전,확대축소 정보 m_iStateCount개)
		__ModPosRotScale	CurStateInfo;		// 현재 움직인 상태 정보(tick에 따라 변화한다)

		__ModPart() {pPart = nullptr; pStateInfos = nullptr; bPos = false; bRot = false; bScale = false; }
		~__ModPart() {pPart = nullptr; if (pStateInfos) { delete [] pStateInfos; pStateInfos = nullptr;}}
	};

	struct __ModShape
	{
		bool				bShapePos;
		bool				bShapeRot;
		bool				bShapeScale;		// Shape가 위치, 회전, 스케일 변화가 있는가?
		__ModPosRotScale*	pShapeStateInfos;	// Shape 전체의 변화 정보
		__ModPosRotScale	CurShapeStateInfo;	// 현재 움직인 상태 정보(tick에 따라 변화한다)
		__ModShape() {pShapeStateInfos = nullptr; bShapePos = false; bShapeRot = false; bShapeScale = false;}
		~__ModShape() {if (pShapeStateInfos) {delete [] pShapeStateInfos; pShapeStateInfos = nullptr;}}
	};

// Attributes
public:
protected:
//	enum	{
//			N3SHAPEMOD_TYPE_NOT_MOD = 0,		// 아무 정보도 변화하지 않는 것
//			N3SHAPEMOD_TYPE_ONLY_SHAPE = 1,		// Shape정보만 변화하는 것
//			N3SHAPEMOD_TYPE_ONLY_PART = 2,		// Part 정보만 변화하는 것
//			N3SHAPEMOD_TYPE_NORMAL = 4			// 둘 다 변화하는 것
//	};
//	int		m_iModType;			// type..
	int		m_iStateCount;		// 상태가 몇개가 있는지 나타낸다.
	int		m_iCurState;		// 현재 상태
	int		m_iPrevState;		// 이전 상태(새로운 상태를 설정해주면 Animation되는 동안 이전상태를 저장해둔다.
	float	m_fTimeChanged;		// 상태가 완전히 바뀌는 시간
	float	m_fTimeChanging;	// 상태가 바뀌는 시작시간부터 지금까지의 경과 시간

	__ModShape	m_ModShape;			// shape의 상태 변화 정보
	int			m_iModPartCount;		// 변화하는 파트의 갯수
	__ModPart*	m_pModParts;		// 변화하는 파트들 정보

	__ModPart**	m_pMatchPart2ModPart;		// CPart리스트 배열순으로 __ModPart*와 매치시킨 배열 (load시 CPart 갯수만큼 배열로 잡고 정보를 넣는다)

// Operations
public:
	BOOL	SetState(int iState, float fSec);	// fSec시간동안 상태를 바꾼다. (fSec이 0일경우 즉시 바뀐다.)
	BOOL	LoadStateInfo(FILE* stream);	// 상태 정보를 읽어온다.(text로부터)
	void	Release() override;
	void	ReCalcMatrix() override;
	void	Tick(float fFrm = FRAME_SELFPLAY) override;
	bool	Load(File& file) override;

protected:
	CN3SPart* GetPartByPMeshFileName(const std::string& szFN);	// 이름으로 PMesh포인터 구하기
};

#endif // !defined(AFX_N3SHAPEMOD_H__6F3C87B4_D10B_412B_B385_0ECE2D4A19A8__INCLUDED_)

// ===== END N3Base/N3ShapeMod.h =====

// ===== BEGIN N3Base/N3Skin.cpp =====
#line 1 "N3Base/N3Skin.cpp"
﻿// N3Skin.cpp: implementation of the CN3Skin class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Skin.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Skin::CN3Skin()
{
	m_dwType |= OBJ_SKIN;

	m_pSkinVertices = nullptr;
}

CN3Skin::~CN3Skin()
{
	delete [] m_pSkinVertices; m_pSkinVertices = nullptr;
}

void CN3Skin::Release()
{
	delete [] m_pSkinVertices; m_pSkinVertices = nullptr;

	CN3IMesh::Release();
}

bool CN3Skin::Load(File& file)
{
	CN3IMesh::Load(file);

	for (int i = 0; i < m_nVC; i++)
	{
		__VertexSkinned* pVtx = &m_pSkinVertices[i];
		file.Read(&pVtx->vOrigin, sizeof(__Vector3));
		file.Read(&pVtx->nAffect, sizeof(int));

		// Skip the useless explicitly-32-bit pointers pnJoints & pfWeights.
		file.Seek(8, SEEK_CUR);

		pVtx->pnJoints = nullptr;
		pVtx->pfWeights = nullptr;

		int nAffect = pVtx->nAffect;
		if (nAffect > 1)
		{
			pVtx->pnJoints = new int[nAffect];
			pVtx->pfWeights = new float[nAffect];

			file.Read(pVtx->pnJoints, 4 * nAffect);
			file.Read(pVtx->pfWeights, 4 * nAffect);
		}
		else if (nAffect == 1)
		{
			pVtx->pnJoints = new int[1];
			file.Read(pVtx->pnJoints, 4);
		}
	}

	return true;
}

#ifdef _N3TOOL
bool CN3Skin::Save(File& file)
{
	CN3IMesh::Save(file);

	uint32_t unused = 0;
	for (int i = 0; i < m_nVC; i++)
	{
		__VertexSkinned* pVtx = &m_pSkinVertices[i];
		file.Write(&pVtx->vOrigin, sizeof(__Vector3));
		file.Write(&pVtx->nAffect, sizeof(int));

		// Skip the useless pointers pnJoints, pfWeights (assume they're 32-bit).
		file.Write(&unused, sizeof(uint32_t));
		file.Write(&unused, sizeof(uint32_t));

		int nAffect = pVtx->nAffect;
		if (nAffect > 1)
		{
			file.Write(pVtx->pnJoints, 4 * nAffect);
			file.Write(pVtx->pfWeights, 4 * nAffect);
		}
		else if (nAffect == 1)
		{
			file.Write(pVtx->pnJoints, 4);
		}
	}

	return true;
}
#endif // end of _N3TOOL

bool CN3Skin::Create(int nFC, int nVC, int nUVC)
{
	if (!CN3IMesh::Create(nFC, nVC, nUVC))
		return false;

	delete [] m_pSkinVertices;
	m_pSkinVertices = new __VertexSkinned[nVC];
	memset(m_pSkinVertices, 0, sizeof(__VertexSkinned)*nVC);

	return true;
}

#ifdef _N3TOOL
int CN3Skin::SortWeightsProc(const void *pArg1, const void *pArg2)
{
	__Weight* pW1 = (__Weight*)pArg1;
	__Weight* pW2 = (__Weight*)pArg2;

	if(pW1->fWeight < pW2->fWeight) return 1;
	else return -1;
}

void CN3Skin::RecalcWeight()
{
	if (nullptr == m_pSkinVertices) return;
	int i, j;
	for (i=0; i<m_nVC; ++i)
	{
		__VertexSkinned* pVtx = m_pSkinVertices + i;
		if (1 >= pVtx->nAffect) continue;
		float fSum = 0;
		for (j=0; j<pVtx->nAffect; ++j) fSum += pVtx->pfWeights[j];
		for (j=0; j<pVtx->nAffect; ++j) pVtx->pfWeights[j] /= fSum;
	}
}

#endif // end of _N3TOOL

bool CN3Skin::CheckCollisionPrecisely(const __Vector3 &vPos, const __Vector3 &vDir, __Vector3 *pvPick)
{
	uint16_t* pwIs;
	__VertexXyzNormal* pVs;
	int nFC, nCI0, nCI1, nCI2;

	pVs	 = Vertices();
	pwIs = VertexInices();

	if(pVs == nullptr || pwIs == nullptr) return false;

	nFC = FaceCount();
	for(int j = 0; j < nFC; j++) // 각각의 Face 마다 충돌체크..
	{
		nCI0 = pwIs[j*3+0];
		nCI1 = pwIs[j*3+1];
		nCI2 = pwIs[j*3+2];

		if(false == ::_IntersectTriangle(vPos, vDir, pVs[nCI0], pVs[nCI1], pVs[nCI2])) continue;
		
		if(pvPick)
		{
			float fT, fU, fV;
			::_IntersectTriangle(vPos, vDir, pVs[nCI0], pVs[nCI1], pVs[nCI2], fT, fU, fV, pvPick);
//			(*pvPick) *= m_Mtx;
		}
		return true;
	}

	return false;

}

// ===== END N3Base/N3Skin.cpp =====

// ===== BEGIN N3Base/N3Skin.h =====
#line 1 "N3Base/N3Skin.h"
﻿// N3Skin.h: interface for the CN3Skin class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Skin_h__INCLUDED_)
#define AFX_N3Skin_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3IMesh.h"

struct __VertexSkinned
{
	__Vector3	vOrigin; // 원래 점 위치..
	int			nAffect; // 관절 몇개가 영향을 주는지..
	int*		pnJoints; // 관절 인덱스
	float*		pfWeights; // 가중치

	__VertexSkinned()
	{
		vOrigin = {};
		nAffect = 0;
		pnJoints = nullptr;
		pfWeights = nullptr;
	}

	~__VertexSkinned()
	{
		delete[] pnJoints;
		delete[] pfWeights;
	}
};

class CN3Skin : public CN3IMesh
{
protected:
#ifdef _N3TOOL
	struct __Weight
	{
		int nIndex;
		float fWeight;
	};

	static int SortWeightsProc(const void* pArg1, const void* pArg2);
#endif // end of _N3TOOL
	
	__VertexSkinned*	m_pSkinVertices;

public:
	__VertexSkinned*	SkinVertices() { return m_pSkinVertices; }
	bool				Create(int nFC, int nVC, int nUVC);
	bool				Load(File& file) override;

	bool				CheckCollisionPrecisely(const __Vector3& vPos, const __Vector3& vDir, __Vector3* pvPick);

#ifdef _N3TOOL
	bool				Save(File& file) override;
	void				RecalcWeight();		// 웨이트값 다시 계산하기
#endif // end of _N3TOOL
	
	void Release() override;
	CN3Skin();
	~CN3Skin() override;

};

#endif // !defined(AFX_N3Skin_h__INCLUDED_)

// ===== END N3Base/N3Skin.h =====

// ===== BEGIN N3Base/N3Sky.cpp =====
#line 1 "N3Base/N3Sky.cpp"
﻿// N3Sky.cpp: implementation of the CN3Sky class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Sky.h"
#include "N3PMesh.h"
#include "N3PMeshInstance.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Sky::CN3Sky()
{
	m_SkyColor.ChangeColor(0xFF5284DE);	// Day color
	m_FogColor.ChangeColor(0xFFB5C6DE);	// Day color
}

CN3Sky::~CN3Sky()
{
}

void CN3Sky::Release()
{
	CN3Base::Release();
	m_SkyColor.ChangeColor(0xFF5284DE);	// Day color
	m_FogColor.ChangeColor(0xFFB5C6DE);	// Day color
	//m_SkyColor.ChangeColor(0xFF081021);	// Night color
	//m_FogColor.ChangeColor(0xFF102942);	// Night color
}

void CN3Sky::Tick()
{
	m_SkyColor.Tick();
	m_FogColor.Tick();

	D3DCOLOR FogColor = m_FogColor.GetCurColor();
	for (int i = 0; i < 4; ++i)
	{
		m_vFronts[i].color = (m_vFronts[i].color & 0xff000000) | (FogColor & 0x00ffffff);
		m_Bottom[i].color  = FogColor;
	}
}

void CN3Sky::Render()
{
    // Set up a rotation matrix to orient the billboard towards the camera.
	__Matrix44 matWorld;
	__Vector3 vDir = s_CameraData.vEye - s_CameraData.vAt;	// Camera direction
	if (0.0f == vDir.x) matWorld.Identity();
	else if( vDir.x > 0.0f ) matWorld.RotationY(-atanf(vDir.z/vDir.x) - (__PI * 0.5f));
	else  matWorld.RotationY(-atanf(vDir.z/vDir.x) + (__PI * 0.5f));
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());

	s_lpD3DDev->SetTexture(0, nullptr); // Do not set a texture as we want to create an illusion of distance fog.
	s_lpD3DDev->SetFVF(FVF_XYZCOLOR); // D3DFVF_XYZ | D3DFVF_DIFFUSE - Spreads the texture around the x, y, z vertices.

	// Draws the front and bottom billboard.
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_Bottom , sizeof(m_Bottom[0])  );
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_vFronts, sizeof(m_vFronts[0]) );
}

void CN3Sky::Init()
{
	Release();
	
	const float fWidth        = 3.5f;  // Width of billboard.
	const float fTopY         = 0.5f;  // Height of the front billboard above the reddish part of the sky.
	const float fBottomY      = 0.1f;  // Height of the bottom front billboard below the reddish part of the glow - the bottom is pure fog.
	const float fDistance     = 1.5f;  // Distance/Length of the front billboard.
	const float fBottomOffset = -5.0f; // Height of the bottom billboard.
	const D3DCOLOR color      = m_FogColor.GetCurColor();

	// Vertices of the front billboard.
	m_vFronts[0].Set(  fWidth, fTopY        , fDistance, 0x00ffffff & color);
	m_vFronts[1].Set(  fWidth, fBottomY     , fDistance, color);
	m_vFronts[2].Set( -fWidth, fBottomY     , fDistance, color);
	m_vFronts[3].Set( -fWidth, fTopY        , fDistance, 0x00ffffff & color);

	// Vertices of the bottom billboard.
	m_Bottom[0].Set(   fWidth, fBottomY     , fDistance, color);
	m_Bottom[1].Set(   fWidth, fBottomOffset, fDistance, color);
	m_Bottom[2].Set(  -fWidth, fBottomOffset, fDistance, color);
	m_Bottom[3].Set(  -fWidth, fBottomY     , fDistance, color);
}

// ===== END N3Base/N3Sky.cpp =====

// ===== BEGIN N3Base/N3Sky.h =====
#line 1 "N3Base/N3Sky.h"
﻿// N3Sky.h: interface for the CN3Sky class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SKY_H__0966C25E_2E50_48A2_9DF4_E4CD279E73CE__INCLUDED_)
#define AFX_N3SKY_H__0966C25E_2E50_48A2_9DF4_E4CD279E73CE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include "N3ColorChange.h"

//class CN3Texture;
class CN3Sky : public CN3Base  
{
	friend class CN3SkyMng;
public:
	CN3Sky();
	virtual ~CN3Sky();

// Attributes
public:
protected:
	CN3ColorChange		m_SkyColor;
	CN3ColorChange		m_FogColor;

	__VertexXyzColor	m_vFronts[4];
	__VertexXyzColor	m_Bottom[4];

// Operations
public:
	void				Init();
	void				Render();
	void				Release() override;
	virtual				void Tick();
protected:
};

#endif // !defined(AFX_N3SKY_H__0966C25E_2E50_48A2_9DF4_E4CD279E73CE__INCLUDED_)

// ===== END N3Base/N3Sky.h =====

// ===== BEGIN N3Base/N3SkyMng.cpp =====
#line 1 "N3Base/N3SkyMng.cpp"
﻿// N3SkyMng.cpp: implementation of the CN3SkyMng class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3SkyMng.h"
#include "N3Sky.h"
#include "N3Moon.h"
#include "N3Sun.h"
#include "N3Cloud.h"
#include "N3Star.h"
#include "mmsystem.h"
#include "N3Texture.h"

#include "N3GERain.h"
#include "N3GESnow.h"

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
#include "N3SndObj.h"
#include "N3SndMgr.h"
#endif // #ifdef _N3GAME

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

typedef std::vector<__SKY_DAYCHANGE>::iterator it_SDC;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3SkyMng::CN3SkyMng()
{
	m_pMoon = nullptr;
	m_pSky = nullptr;
	m_pSun = nullptr;
	m_pCloud = nullptr;
	m_pStar = nullptr;

	memset(m_pLightColorDiffuses, 0, sizeof(m_pLightColorDiffuses));
	memset(m_pLightColorAmbients, 0, sizeof(m_pLightColorAmbients));

	m_pGERain = nullptr;
	m_pGESnow = nullptr;

	m_iDayChangeCurPos = 0;
	m_iWeatherChangeCurPos = 0;
	m_eWeather = SW_CLEAR;
	m_dwCheckTick = timeGetTime();

	m_iYear = 0;
	m_iMonth = 0;
	m_iDay = 0;

	m_iHourFix = 0;

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	m_pSnd_Weather_Snow = nullptr;
	m_pSnd_Weather_Rain = nullptr;
#endif // #ifdef _N3GAME
}

CN3SkyMng::~CN3SkyMng()
{
	if (m_pSky) {delete m_pSky;	m_pSky = nullptr;}
	if (m_pMoon) {delete m_pMoon; m_pMoon = nullptr;}
	if (m_pSun)	{delete m_pSun;	m_pSun = nullptr;}
	if (m_pCloud) {delete m_pCloud; m_pCloud = nullptr;}
	if (m_pStar) {delete m_pStar; m_pStar = nullptr;}
	for(int i = 0; i < MAX_GAME_LIGHT; i++)
	{
		delete m_pLightColorDiffuses[i]; m_pLightColorDiffuses[i] = nullptr;
		delete m_pLightColorAmbients[i]; m_pLightColorAmbients[i] = nullptr;
	}

	m_fCellSize = 0.0f;
	m_CurCellPos.x = m_CurCellPos.y = -1;
	if (m_pGERain) {delete m_pGERain; m_pGERain = nullptr;}
	if (m_pGESnow) {delete m_pGESnow; m_pGESnow = nullptr;}

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Snow);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Rain);
#endif // #ifdef _N3GAME
}

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
void CN3SkyMng::ReleaseSound()
{	
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Snow);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Rain);
}
#endif // #ifdef _N3GAME

void CN3SkyMng::Release()
{
	CN3Base::Release();
	
	if (m_pSky) {delete m_pSky;	m_pSky = nullptr;}
	if (m_pMoon) {delete m_pMoon; m_pMoon = nullptr;}
	if (m_pSun)	{delete m_pSun;	m_pSun = nullptr;}
	if (m_pCloud) {delete m_pCloud; m_pCloud = nullptr;}
	if (m_pStar) {delete m_pStar; m_pStar = nullptr;}
	for(int i = 0; i < MAX_GAME_LIGHT; i++)
	{
		delete m_pLightColorDiffuses[i]; m_pLightColorDiffuses[i] = nullptr;
		delete m_pLightColorAmbients[i]; m_pLightColorAmbients[i] = nullptr;
	}

	m_DayChanges.clear();
	m_iDayChangeCurPos = 0;

	m_WeatherChanges.clear();
	m_iWeatherChangeCurPos = 0;
	m_eWeather = SW_CLEAR;

	if (m_pGERain) {delete m_pGERain; m_pGERain = nullptr;}
	if (m_pGESnow) {delete m_pGESnow; m_pGESnow = nullptr;}

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Snow);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Rain);
#endif // #ifdef _N3GAME
}

void CN3SkyMng::Render()
{
    // Disable zbuffer, center view matrix, and set FOV to 72 degrees
    __Matrix44 matView = s_CameraData.mtxView;
    matView.m[3][0] = matView.m[3][1] = matView.m[3][2] = 0.0f;
    
    s_lpD3DDev->SetTransform(D3DTS_VIEW, matView.toD3D());

	// backup render state
	DWORD dwAlphaBlend, dwSrcBlend, dwDestBlend, dwZEnable, dwFog, dwLighting;
    s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaBlend );
    s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND,   &dwSrcBlend );
    s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND,  &dwDestBlend );
	s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZEnable);
	s_lpD3DDev->GetRenderState( D3DRS_FOGENABLE, &dwFog );
	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING,	&dwLighting );

	// set render state
	if (TRUE != dwAlphaBlend) s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );
	if (D3DZB_FALSE != dwZEnable) s_lpD3DDev->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
    if (FALSE != dwFog) s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, FALSE );
	if (FALSE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );	// default 수치 이다.
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );		// default 수치 이다.

	if (m_pSky) m_pSky->Render();							// 하늘
	if (m_pStar) m_pStar->Render();							// 별
	if (m_pMoon) m_pMoon->Render(matView, s_CameraData.mtxProjection);							// 달
	if (m_pSun)	 m_pSun->Render(matView, s_CameraData.mtxProjection);							// 해
	if (m_pCloud) m_pCloud->Render();						// 구름

    // Restore the modified renderstates
	if (TRUE != dwAlphaBlend) s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlphaBlend );
	if (D3DBLEND_SRCALPHA != dwSrcBlend) s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,   dwSrcBlend );
	if (D3DBLEND_INVSRCALPHA != dwDestBlend) s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,  dwDestBlend );
	if (D3DZB_FALSE != dwZEnable) s_lpD3DDev->SetRenderState( D3DRS_ZENABLE, dwZEnable );
    if (FALSE != dwFog) s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, dwFog );
	if (FALSE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLighting );
	s_lpD3DDev->SetTransform(D3DTS_VIEW, s_CameraData.mtxView.toD3D());
}

void CN3SkyMng::RenderWeather()
{
	int i, j;
	for (i=0; i<3; ++i)
	{
		for(j=0; j<3; ++j)
		{
			if (m_pGERain)
			{
				m_pGERain->Render(m_vPos[j*3+i]);
			}
			if (m_pGESnow)
			{
				m_pGESnow->Render(m_vPos[j*3+i]);
			}
		}
	}
}

void CN3SkyMng::Tick()
{
	uint32_t dwCurTickCount = timeGetTime();
	__ASSERT(dwCurTickCount >= m_dwCheckTick,"음수이다.");
	uint32_t dwCurGameTime = m_dwCheckGameTime + (uint32_t)((dwCurTickCount - m_dwCheckTick)*TIME_REAL_PER_GAME*0.001f);
	if (!m_DayChanges.empty())
	{
		// dwCurGameTime 가 24*60*60을 넘었을 경우
		if ( dwCurGameTime>86400)
		{
			m_iDayChangeCurPos = 0;
			__ASSERT(m_dwCheckGameTime < 86400, "시간이 이상해요");
			m_dwCheckTick += (int)((86400 - m_dwCheckGameTime)*TIME_GAME_PER_REAL);	// CheckTick을 게임 0시에 맞게 다시 설정
			dwCurGameTime -= 86400;
			m_dwCheckGameTime = 0;	// 기준 게임시간을 0시로..

			m_iDay++; // 날짜 증가..
			m_pMoon->SetMoonPhase(m_iMonth*30 + m_iDay); // 달모양을 변화시키고..
			if(m_iDay > 30)
			{
				m_iDay = 0;
				m_iMonth++;
				if(m_iMonth > 12)
				{
					m_iMonth = 0;
					m_iYear++;
				}
			}
		}

		// 해의 위치 계산
		float fAngleTime = 0;
		if(m_iHourFix > 0) fAngleTime = (m_iHourFix * 3600.0f / 86400.0f) * 360.0f;// 해와 달의 위치가 고정돼야 한다면..
		else fAngleTime = (dwCurGameTime / 86400.0f) * 360.0f;

		if(m_pSun) m_pSun->SetCurAngle(fAngleTime + 270.0f);
		if(m_pMoon) m_pMoon->SetCurAngle(fAngleTime + 90.0f);

		while (m_iDayChangeCurPos >= 0
			&& m_iDayChangeCurPos < static_cast<int>(m_DayChanges.size())
			&& m_DayChanges[m_iDayChangeCurPos].dwWhen < dwCurGameTime)
		{
			__SKY_DAYCHANGE* pSDC = &(m_DayChanges[m_iDayChangeCurPos]);
			// 실행할 명령의 시간과 현재 시간 차이
			uint32_t dwDiffTime = dwCurGameTime - pSDC->dwWhen;

			// 변화에 걸리는 시간 조정 
			float fTakeTime = pSDC->fHowLong - dwDiffTime*TIME_GAME_PER_REAL;	// 걸리는 시간
			if (fTakeTime<0.0f)
			{
				//TRACE("!!!!! 하늘이 즉시 변화됨 !!!!!\n");
				fTakeTime = 0.0f;	// 0보다 작으면 즉시 변화하게 하자
			}

			// 하늘 변화명령 실행하기
			if (SW_CLEAR == m_eWeather ||	// 맑은 날씨이거나
				(SDC_SKYCOLOR != pSDC->eSkyDayChange && SDC_FOGCOLOR != pSDC->eSkyDayChange &&
				SDC_SUNCOLOR != pSDC->eSkyDayChange && SDC_FLARECOLOR != pSDC->eSkyDayChange && SDC_GLOWCOLOR != pSDC->eSkyDayChange &&
				SDC_CLOUD1COLOR != pSDC->eSkyDayChange && SDC_CLOUD2COLOR != pSDC->eSkyDayChange &&
				SDC_CLOUDTEX != pSDC->eSkyDayChange))	// 날씨 변화요소가 아닐경우
			{	
				ChangeSky(pSDC, fTakeTime);
			}
			m_iDayChangeCurPos++;
		}

		// 날씨 변화에 따른 하늘 변화명령 실행하기
		if (!m_WeatherChanges.empty())
		{
			while (m_iWeatherChangeCurPos >= 0
				&& m_iWeatherChangeCurPos < static_cast<int>(m_WeatherChanges.size())
				&& m_WeatherChanges[m_iWeatherChangeCurPos].dwWhen < dwCurGameTime)
			{
				__SKY_DAYCHANGE* pSDC = &m_WeatherChanges[m_iWeatherChangeCurPos];
				// 실행할 명령의 시간과 현재 시간 차이
				uint32_t dwDiffTime = dwCurGameTime - pSDC->dwWhen;

				// 변화에 걸리는 시간 조정 
				float fTakeTime = pSDC->fHowLong - dwDiffTime*TIME_GAME_PER_REAL;	// 걸리는 시간
				if (fTakeTime<0.0f)	fTakeTime = 0.0f;	// 0보다 작으면 즉시 변화하게 하자
				ChangeSky(pSDC, fTakeTime);	// 변화시키기
				m_iWeatherChangeCurPos++;
			}

			// 날씨 변화 queue 삭제하기
			if (m_iWeatherChangeCurPos >= static_cast<int>(m_WeatherChanges.size()))
			{
				m_WeatherChanges.clear();
				m_iWeatherChangeCurPos = 0;
			}
		}
	}
	if (m_pSky) m_pSky->Tick();
//	if (m_pMoon) m_pMoon->Tick();
	if (m_pSun) m_pSun->Tick();
	if (m_pCloud) m_pCloud->Tick();
	if (m_pStar) m_pStar->Tick();
	
	for(int i = 0; i < MAX_GAME_LIGHT; i++)
	{
		m_pLightColorDiffuses[i]->Tick();
		m_pLightColorAmbients[i]->Tick();
	}

	if (m_fCellSize > 0.0f)
	{
		POINT NewCellPos;	
		NewCellPos.x = int(s_CameraData.vEye.x/m_fCellSize);
		NewCellPos.y = int(s_CameraData.vEye.z/m_fCellSize);
		if (NewCellPos.x != m_CurCellPos.x || NewCellPos.y != m_CurCellPos.y)
		{
			m_CurCellPos = NewCellPos;
			int i, j;
			for(i=0; i<3; ++i)
				for(j=0; j<3; ++j)
					m_vPos[j*3+i].Set( (m_CurCellPos.x+i-0.5f)*m_fCellSize, 0, (m_CurCellPos.y+j-0.5f)*m_fCellSize);
		}

		if (m_pGERain)
		{
			m_pGERain->Tick();
			if(m_pGERain->NeedDelete()) { delete m_pGERain; m_pGERain = nullptr; }
		}
		if (m_pGESnow)
		{
			m_pGESnow->Tick();
			if(m_pGESnow->NeedDelete()) { delete m_pGESnow; m_pGESnow = nullptr; }
		}
	}
}

#ifdef _N3TOOL
bool CN3SkyMng::DayChangeParse(FILE* fp, __SKY_DAYCHANGE* pDayChange)
{
	if(nullptr == fp || nullptr == pDayChange) return false;
	char szLine0[512] = "", szLine1[512] = "";
	char* pResult0 = fgets(szLine0, 256, fp);
	char* pResult1 = fgets(szLine1, 256, fp);
	if(nullptr == pResult0 || nullptr == pResult1) return false;

	pDayChange->Init(); // 초기화 해주고..
	
	pDayChange->szName = szLine0;
	if(pDayChange->szName.size() >= 2)
		pDayChange->szName = pDayChange->szName.substr(0, pDayChange->szName.size() - 2);
	sscanf(szLine1, "Type : [%d], Time : [%d], Parameter1 : [%d], Parameter2 : [%d], Elapse : [%f]",
		&(pDayChange->eSkyDayChange), &pDayChange->dwWhen, &pDayChange->dwParam1, &pDayChange->dwParam2, &pDayChange->fHowLong);

	return true;
}
#endif // #ifdef _N3TOOL

#ifdef _N3TOOL
bool CN3SkyMng::DayChangeWrite(FILE* fp, __SKY_DAYCHANGE* pDayChange)
{
	if(nullptr == fp || nullptr == pDayChange) return false;
	
	char szLine[512] = "";
	fprintf(fp, "%s\r\n", pDayChange->szName.c_str());
	fprintf(fp, "Type : [%d], Time : [%d], Parameter1 : [%d], Parameter2 : [%d], Elapse : [%f]\r\n",
		pDayChange->eSkyDayChange, pDayChange->dwWhen, pDayChange->dwParam1, pDayChange->dwParam2, pDayChange->fHowLong);

	return true;
}
#endif // #ifdef _N3TOOL

#ifdef _N3TOOL
bool CN3SkyMng::LoadFromTextFile(const char* szIniFN)
{
	if(nullptr == szIniFN || strlen(szIniFN) <= 0) return false;

	FILE* fp = fopen(szIniFN, "r");
	if(!fp) return false;

	std::string szMoon;
	std::string szSuns[NUM_SUNPART];
	std::string szClouds[NUM_CLOUD];

	char szLine[512] = "", szBuff[256] = "";
	char* pResult = fgets(szLine, 512, fp);
	if(pResult)
	{
		sscanf(szLine, "Moon : %s", szBuff);
		szMoon = szBuff;
	}

	int i;
	for(i = 0 ; i < NUM_SUNPART; i++)
	{
		pResult = fgets(szLine, 512, fp);
		if(pResult)
		{
			sscanf(szLine, "Sun : %s", szBuff);
			szSuns[i] = szBuff;
		}
	}

	for(i = 0 ; i < NUM_CLOUD; i++)
	{
		pResult = fgets(szLine, 512, fp);
		if(pResult)
		{
			sscanf(szLine, "Cloud : %s", szBuff);
			szClouds[i] = szBuff;
		}
	}

	int iSDCC = 0;
	pResult = fgets(szLine, 512, fp);
	if(pResult)
	{
		sscanf(szLine, "DayChange Count : %d", &iSDCC);

		if(iSDCC > 0)
		{
			m_DayChanges.resize(iSDCC); //m_DayChanges.assign(iSDCC);
			for(int i = 0; i < iSDCC; i++)
			{
				if(false == this->DayChangeParse(fp, &(m_DayChanges[i])))
				{
					std::string szErrLine = fmt::format("From \"DayChage Count : \" -> Line : {}", i);
					MessageBoxA(CN3Base::s_hWndBase, szErrLine.c_str(), "하늘 환경설정 데이터 Parsing 실패", MB_OK); //CN3Base::s_hWndBase
					this->Release();
					return false;
				}
			}
		}
	}

	fclose(fp); // 파일 닫기..

	if(nullptr == m_pSky) m_pSky = new CN3Sky();
	m_pSky->Init();

	if(nullptr == m_pStar) m_pStar = new CN3Star();
	m_pStar->Init();

	if(nullptr == m_pSun) m_pSun = new CN3Sun();
	m_pSun->Init(szSuns);

	if(nullptr == m_pCloud) m_pCloud = new CN3Cloud();
	m_pCloud->Init(szClouds);

	if(nullptr == m_pMoon) m_pMoon = new CN3Moon();
	m_pMoon->Init(szMoon);

	for(i = 0; i < MAX_GAME_LIGHT; i++)
	{
		if(nullptr == m_pLightColorDiffuses[i]) m_pLightColorDiffuses[i] = new CN3ColorChange();
		if(nullptr == m_pLightColorAmbients[i]) m_pLightColorAmbients[i] = new CN3ColorChange();
	}

	std::vector<__SKY_DAYCHANGE>(m_DayChanges).swap(m_DayChanges); // 용량을 딱 맞추기..

	qsort(&(m_DayChanges[0]), m_DayChanges.size(), sizeof(__SKY_DAYCHANGE), CompareTime);
	SetCheckGameTime(CONVERT_SEC(10,0,0));

	return true;
}
#endif // #ifdef _N3TOOL

#ifdef _N3TOOL
bool CN3SkyMng::SaveToTextFile(const char* szIniFN)
{
	if(nullptr == szIniFN || strlen(szIniFN) <= 0) return false;

	FILE* fp = fopen(szIniFN, "w");
	if(!fp) return false;

	char szBuff[256] = "";

	if(this->MoonTextureGet()) fprintf(fp, "Moon : %s\r\n", this->MoonTextureGet()->FileName().c_str());
	else fprintf(fp, "Moon : \r\n");
	

	int i = 0;
	for(i = 0; i < NUM_SUNPART; i++) 
	{
		if(this->SunTextureGet(i)) fprintf(fp, "Sun : %s\r\n", this->SunTextureGet(i)->FileName().c_str());
		else fprintf(fp, "Sun : \r\n");
	}

	for(i = 0; i < NUM_CLOUD; i++) 
	{
		if(this->CloudTextureFileName(i)) fprintf(fp, "Cloud : %s\r\n", this->CloudTextureFileName(i));
		else fprintf(fp, "Cloud : \r\n");
	}
	

	fprintf(fp, "DayChange Count : %zu\r\n", m_DayChanges.size());
	for (__SKY_DAYCHANGE& dayChange : m_DayChanges)
		DayChangeWrite(fp, &dayChange);

	fclose(fp); // 파일 닫기..

	return true;
}
#endif // #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3SkyMng::InitToDefaultHardCoding()
{
	this->Release();

	m_pSky = new CN3Sky();
	m_pSky->Init();

	m_pMoon = new CN3Moon();
	m_pMoon->Init("misc\\sky\\phases.tga");

	std::string szSuns[NUM_SUNPART] = { "misc\\sky\\sundisk.bmp", "misc\\sky\\sunglow.bmp",	"misc\\sky\\sunflare.bmp" };
	m_pSun = new CN3Sun();
	m_pSun->Init(szSuns);

	std::string szClouds[NUM_CLOUD] = { "misc\\sky\\wisps.tga", "misc\\sky\\puffs.tga", "misc\\sky\\tatters.tga", "misc\\sky\\streaks.tga", "misc\\sky\\dense.tga", "misc\\sky\\overcast.tga" };
	m_pCloud = new CN3Cloud();
	m_pCloud->Init(szClouds);

	m_pStar = new CN3Star();
	m_pStar->Init();

	for(int i = 0; i < MAX_GAME_LIGHT; i++)
	{
		m_pLightColorDiffuses[i] = new CN3ColorChange();
		m_pLightColorAmbients[i] = new CN3ColorChange();
	}

	// 임시 hard coding
	__SKY_DAYCHANGE tmpDayChange;
	m_DayChanges.reserve(64);
	uint32_t dwTime = 0;

	// 해뜨기..
	dwTime = CONVERT_SEC(5,0,0); // 5시에 해가 뜬다..
	
	tmpDayChange.Init("SunRise - SkyColor", SDC_SKYCOLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - FogColor", SDC_FOGCOLOR, dwTime, D3DCOLOR_ARGB(255, 80, 110, 160), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - SunColor", SDC_SUNCOLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - GlowColor", SDC_GLOWCOLOR, dwTime, D3DCOLOR_ARGB(255, 165, 122, 110), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - FlareColor", SDC_FLARECOLOR, dwTime, D3DCOLOR_ARGB(255, 122, 80, 50), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - Cloud1Color", SDC_CLOUD1COLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - Cloud2Color", SDC_CLOUD2COLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - Light0", SDC_LIGHT0COLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - Light1", SDC_LIGHT1COLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunRise - Light2", SDC_LIGHT2COLOR, dwTime, D3DCOLOR_ARGB(255, 165, 115, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);


	// 한낮..
	dwTime = CONVERT_SEC(6,0,0); // 6시부터 낮이다..

	tmpDayChange.Init("Noon - StarCount", SDC_STARCOUNT, dwTime, 0, 0, 300.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - SkyColor", SDC_SKYCOLOR, dwTime, D3DCOLOR_ARGB(255, 46, 97, 189), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - FogColor", SDC_FOGCOLOR, dwTime, D3DCOLOR_ARGB(255, 169, 203, 215), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - SunColor", SDC_SUNCOLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - GlowColor", SDC_GLOWCOLOR, dwTime, D3DCOLOR_ARGB(255, 224, 224, 192), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - FlareColor", SDC_FLARECOLOR, dwTime, D3DCOLOR_ARGB(255, 96, 96, 96), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - Cloud1Color", SDC_CLOUD1COLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - Cloud2Color", SDC_CLOUD2COLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - Light0", SDC_LIGHT0COLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - Light1", SDC_LIGHT1COLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("Noon - Light2", SDC_LIGHT2COLOR, dwTime, D3DCOLOR_ARGB(255, 255, 255, 255), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);


	tmpDayChange.Init("Noon - MoonPhase", SDC_MOONPHASE, CONVERT_SEC(12,0,0), 0, 0, 0); // 낮 12시에 달 모양 변화
	m_DayChanges.push_back(tmpDayChange);


	// 해질때..
	dwTime = CONVERT_SEC(20,0,0); // 저녁 8시에 해가 지기 시작한다..

	tmpDayChange.Init("SunSet - SkyColor", SDC_SKYCOLOR, dwTime, D3DCOLOR_ARGB(255, 98, 115, 125), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - FogColor", SDC_FOGCOLOR, dwTime, D3DCOLOR_ARGB(255, 135, 162, 159), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - SunColor", SDC_SUNCOLOR, dwTime, D3DCOLOR_ARGB(255, 203, 132, 85), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - GlowColor", SDC_GLOWCOLOR, dwTime, D3DCOLOR_ARGB(255, 192, 128, 128), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - FlareColor", SDC_FLARECOLOR, dwTime, D3DCOLOR_ARGB(255, 204, 128, 40), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - Cloud1Color", SDC_CLOUD1COLOR, dwTime, D3DCOLOR_ARGB(255, 182, 152, 116), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - Cloud2Color", SDC_CLOUD2COLOR, dwTime, D3DCOLOR_ARGB(255, 162, 145, 107), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - Light0", SDC_LIGHT0COLOR, dwTime, D3DCOLOR_ARGB(255, 135, 162, 159), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - Light1", SDC_LIGHT1COLOR, dwTime, D3DCOLOR_ARGB(255, 135, 162, 159), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("SunSet - Light2", SDC_LIGHT2COLOR, dwTime, D3DCOLOR_ARGB(255, 135, 162, 159), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);



	// 완전히 해가 짐..
	dwTime = CONVERT_SEC(21,0,0); // 저녁 9시에 완전히 해가 진다.

	tmpDayChange.Init("MidNight - SkyColor", SDC_SKYCOLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - FogColor", SDC_FOGCOLOR, dwTime, D3DCOLOR_ARGB(255, 39, 52, 95), 0, 180.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - StarCount", SDC_STARCOUNT, dwTime, MAX_STAR, 0, 300.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - SunColor", SDC_SUNCOLOR, dwTime, D3DCOLOR_ARGB(255, 30, 36, 85), 0, 150.0f); // 푸르스름
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - GlowColor", SDC_GLOWCOLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 150.0f); // 하늘과 동
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - FlareColor", SDC_FLARECOLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 150.0f); // 하늘과 동
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - Cloud1Color", SDC_CLOUD1COLOR, dwTime, D3DCOLOR_ARGB(255, 151, 144, 160), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - Cloud2Color", SDC_CLOUD2COLOR, dwTime, D3DCOLOR_ARGB(255, 79, 78, 92), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - Light0", SDC_LIGHT0COLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - Light1", SDC_LIGHT1COLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	tmpDayChange.Init("MidNight - Light2", SDC_LIGHT2COLOR, dwTime, D3DCOLOR_ARGB(255, 15, 18, 49), 0, 150.0f);
	m_DayChanges.push_back(tmpDayChange);

	
	std::vector<__SKY_DAYCHANGE>(m_DayChanges).swap(m_DayChanges); // 용량을 딱 맞추기..

	qsort(&(m_DayChanges[0]), m_DayChanges.size(), sizeof(__SKY_DAYCHANGE), CompareTime);
	SetCheckGameTime(CONVERT_SEC(10,0,0));
}
#endif // #ifdef _N3TOOL


//	CheckGameTime을 정해주고 현재시간을 다시 세팅한다.(특정 시간으로 강제적으로 만들때 호출한다.)
void CN3SkyMng::SetCheckGameTime(uint32_t dwCheckGameTime)
{
	dwCheckGameTime %= 86400;
	uint32_t dwCheckTick = timeGetTime();
	m_dwCheckGameTime = dwCheckGameTime;
	m_dwCheckTick = dwCheckTick;

	// 해와 달의 각도 계산.
	m_pSun->SetCurAngle(dwCheckGameTime/86400.0f*360.0f  + 270.0f);
	m_pMoon->SetCurAngle(dwCheckGameTime/86400.0f*360.0f  + 90.0f);

	if (m_DayChanges.empty())
		return;

	// 큐에서 현재 게임시간에 맞는 순서를 찾는다.
	m_iDayChangeCurPos = 0;
	int iDCC = static_cast<int>(m_DayChanges.size());
	while (m_iDayChangeCurPos >= 0
		&& m_iDayChangeCurPos < iDCC
		&& m_DayChanges[m_iDayChangeCurPos].dwWhen < dwCheckGameTime)
		++m_iDayChangeCurPos;

	if (m_iDayChangeCurPos >= iDCC)
		m_iDayChangeCurPos = iDCC - 1;

	// 현재 게임시간에서 각 sky상태별로 가장 최근에 변경된 값을 찾아서 값을 지정해준다.
	int i;
	for(i=0; i<NUM_SKYDAYCHANGE; ++i)
	{
		if (i == SDC_MOONPHASE) continue;

		int iPos = GetLatestChange((eSKY_DAYCHANGE)i, m_iDayChangeCurPos);
		if (iPos<0) continue;	// 한바퀴를 다 돌았는데도 변화값을 찾을 수 없다.
		__SKY_DAYCHANGE* pSDC = &(m_DayChanges[iPos]);
		uint32_t dwEnd = pSDC->dwWhen + (uint32_t)(TIME_REAL_PER_GAME * pSDC->fHowLong);	// 변화가 끝나는 시간
		if (dwEnd>86400) dwEnd -= 86400;	// 24시간이 넘었을경우 24시간을 빼준다.
		if ( dwEnd < dwCheckGameTime)
		{	// 현재 겜시간에서 변화가 이미 끝났을 경우
			ChangeSky(pSDC, 0.0f);
		}
		else
		{	// 현재 겜시간에서 변화가 진행중인 경우
			int iPrevPos = GetLatestChange((eSKY_DAYCHANGE)i, iPos);
			__ASSERT(iPrevPos>=0, "여기에 올리가 없다");
			__SKY_DAYCHANGE* pPrevSDC = &(m_DayChanges[iPrevPos]);
			ChangeSky(pPrevSDC, 0.0f);	// 이전 상태로 만들기

			// 변화상태로 만들기
			// 실행할 명령의 시간과 현재 시간 차이
			uint32_t dwDiffTime = dwCheckGameTime - pSDC->dwWhen;
			// 변화에 걸리는 시간 조정 
			float fTakeTime = pSDC->fHowLong - dwDiffTime*TIME_GAME_PER_REAL;	// 걸리는 시간
			if (fTakeTime<0.0f) fTakeTime = 0.0f;	// 0보다 작으면 즉시 변화하게 하자
			ChangeSky(pSDC, fTakeTime);
		}
	}
}

// m_DayChanges에서 지정된 위치(iPos) 이전의 가장 최근에 변화하는 위치 얻어오기
int CN3SkyMng::GetLatestChange(eSKY_DAYCHANGE eSDC, int iPos)
{
	int iFind = iPos - 1;
	if (iFind < 0 || iFind >= static_cast<int>(m_DayChanges.size()))
		iFind = static_cast<int>(m_DayChanges.size()) - 1;

	while (iFind >= 0)
	{
		if (m_DayChanges[iFind].eSkyDayChange == eSDC)
			break;	// 가장 최근의 변화를 찾았다.

		--iFind;
	}

	if (iFind < 0)
	{
		// 맨 뒤에서부터 다시 검색
		iFind = static_cast<int>(m_DayChanges.size()) - 1;
		while (iFind >= 0)
		{
			if (m_DayChanges[iFind].eSkyDayChange == eSDC)
				break;	// 가장 최근의 변화를 찾았다.

			// 한바퀴를 다 돌았는데도 변화값을 찾을 수 없다.
			if (iPos > iFind)
			{
				iFind = -1;
				break;
			}

			--iFind;
		}
	}
	return iFind;
}

// (It allows to calculate the precise rate of change by comparing the pSDC-> How Long fTakeTime value and the value.)
// Changing the status of the sky
void CN3SkyMng::ChangeSky(__SKY_DAYCHANGE* pSDC, float fTakeTime)
{
	if (nullptr == pSDC) return;
	float fPercentage = 1.0f - fTakeTime/pSDC->fHowLong;

	// Execute command changes
	switch(pSDC->eSkyDayChange)
	{
	case SDC_SKYCOLOR:
		m_pSky->m_SkyColor.ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pSky->m_SkyColor.SetPercentage(fPercentage);
		break;
	case SDC_FOGCOLOR:
		m_pSky->m_FogColor.ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pSky->m_FogColor.SetPercentage(fPercentage);
		break;
	case SDC_STARCOUNT:
		m_pStar->SetStar(pSDC->dwParam1, fTakeTime);
		break;
	case SDC_MOONPHASE:
		m_pMoon->SetMoonPhase(m_pMoon->GetMoonPhaseIndex()+1);	// The phase index increased one.
		break;
	case SDC_SUNCOLOR:
		m_pSun->m_Parts[SUNPART_SUN].Color.ChangeColor(pSDC->dwParam1, pSDC->fHowLong); // color
		m_pSun->m_Parts[SUNPART_SUN].Color.SetPercentage(fPercentage);
		m_pSun->m_Parts[SUNPART_SUN].Delta.ChangeDelta(pSDC->dwParam2/1000.0f, pSDC->fHowLong); // size..
		m_pSun->m_Parts[SUNPART_SUN].Delta.SetPercentage(fPercentage);
		break;
	case SDC_GLOWCOLOR:
		m_pSun->m_Parts[SUNPART_GLOW].Color.ChangeColor(pSDC->dwParam1, pSDC->fHowLong); // color
		m_pSun->m_Parts[SUNPART_GLOW].Color.SetPercentage(fPercentage);
		m_pSun->m_Parts[SUNPART_GLOW].Delta.ChangeDelta(pSDC->dwParam2/1000.0f, pSDC->fHowLong); // size..
		m_pSun->m_Parts[SUNPART_GLOW].Delta.SetPercentage(fPercentage);
		break;
	case SDC_FLARECOLOR:
		m_pSun->m_Parts[SUNPART_FLARE].Color.ChangeColor(pSDC->dwParam1, pSDC->fHowLong); // color
		m_pSun->m_Parts[SUNPART_FLARE].Color.SetPercentage(fPercentage);
		m_pSun->m_Parts[SUNPART_FLARE].Delta.ChangeDelta(pSDC->dwParam2/1000.0f, pSDC->fHowLong); // size..
		m_pSun->m_Parts[SUNPART_FLARE].Delta.SetPercentage(fPercentage);
		break;
	case SDC_CLOUD1COLOR:
		m_pCloud->m_Color1.ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pCloud->m_Color1.SetPercentage(fPercentage);
		break;
	case SDC_CLOUD2COLOR:
		m_pCloud->m_Color2.ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pCloud->m_Color2.SetPercentage(fPercentage);
		break;
	case SDC_CLOUDTEX:
		m_pCloud->SetCloud((e_CLOUDTEX)pSDC->dwParam1, (e_CLOUDTEX)pSDC->dwParam2, fTakeTime);
		break;
	case SDC_LIGHT0COLOR:
		m_pLightColorDiffuses[0]->ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pLightColorDiffuses[0]->SetPercentage(fPercentage);
		m_pLightColorAmbients[0]->ChangeColor(pSDC->dwParam2, pSDC->fHowLong);
		m_pLightColorAmbients[0]->SetPercentage(fPercentage);
		break;
	case SDC_LIGHT1COLOR:
		m_pLightColorDiffuses[1]->ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pLightColorDiffuses[1]->SetPercentage(fPercentage);
		m_pLightColorAmbients[1]->ChangeColor(pSDC->dwParam2, pSDC->fHowLong);
		m_pLightColorAmbients[1]->SetPercentage(fPercentage);
		break;
	case SDC_LIGHT2COLOR:
		m_pLightColorDiffuses[2]->ChangeColor(pSDC->dwParam1, pSDC->fHowLong);
		m_pLightColorDiffuses[2]->SetPercentage(fPercentage);
		m_pLightColorAmbients[2]->ChangeColor(pSDC->dwParam2, pSDC->fHowLong);
		m_pLightColorAmbients[2]->SetPercentage(fPercentage);
		break;
	}
}

float CN3SkyMng::GetSunAngleByRadin()
{
	if(m_pSun) return m_pSun->m_fCurRadian;
	else return 0;
}

int CN3SkyMng::CompareTime(const void* pArg1, const void* pArg2)
{
	const __SKY_DAYCHANGE* pSDC1 = (__SKY_DAYCHANGE*)pArg1;
	const __SKY_DAYCHANGE* pSDC2 = (__SKY_DAYCHANGE*)pArg2;
	return (int)pSDC1->dwWhen - (int)pSDC2->dwWhen;
}

void CN3SkyMng::SetWeather(eSKY_WEATHER eWeather, int iPercentage)
{
	// 날씨에 변하는 것들 : SDC_SKYCOLOR, SDC_FOGCOLOR, SDC_CLOUD1COLOR, SDC_CLOUD2COLOR, SDC_CLOUDTEX
	eSKY_WEATHER ePrevWeather = m_eWeather;	// 이전 날씨
	m_eWeather = eWeather;

	// 현재 게임 시간 구하기
	uint32_t dwCurTickCount = timeGetTime();
	__ASSERT(dwCurTickCount >= m_dwCheckTick,"음수이다.");
	uint32_t dwCurGameTime = m_dwCheckGameTime + (uint32_t)((dwCurTickCount - m_dwCheckTick)*TIME_REAL_PER_GAME*0.001f);
	BOOL	IsNight = (dwCurGameTime < CONVERT_SEC(6,0,0) || dwCurGameTime > CONVERT_SEC(19,0,0));

	if(SW_CLEAR == m_eWeather) // 맑은 날씨. 퍼센트는 안개...
	{
		if (SW_CLEAR == ePrevWeather) return;	// 이전 날씨가 맑았으면 변화시키지 않는다.
		int iAfterNSecPos = GetDayChangePos_AfterNSec(dwCurGameTime, 10);	// 60초 후에 DayChangePos구하기
		float fHowLong = 10.0f;
		uint32_t dwWhen = dwCurGameTime + CONVERT_SEC(0, 0,0);
		uint32_t dwParam1 = 0, dwParam2 = 0;

		// 날씨 변화 큐 만들기
		m_WeatherChanges.clear();
		m_iWeatherChangeCurPos = 0;
		m_WeatherChanges.reserve(16);
		__SKY_DAYCHANGE tmpWeatherChange;
		int iPos = 0;

		// 해
		iPos = GetLatestChange(SDC_SUNCOLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Sun", SDC_SUNCOLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 해의 flare
		iPos = GetLatestChange(SDC_FLARECOLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Flare", SDC_FLARECOLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 해의 glow
		iPos = GetLatestChange(SDC_GLOWCOLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Glow", SDC_GLOWCOLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 하늘색
		iPos = GetLatestChange(SDC_SKYCOLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Sky", SDC_SKYCOLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 안개색
		iPos = GetLatestChange(SDC_FOGCOLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Fog", SDC_FOGCOLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 구름 1 색
		iPos = GetLatestChange(SDC_CLOUD1COLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Cloud1", SDC_CLOUD1COLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 구름 2색 
		iPos = GetLatestChange(SDC_CLOUD2COLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Cloud2", SDC_CLOUD2COLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);
		
		// 구름 텍스쳐 - 미리 바뀌게 한다..
		iPos = GetLatestChange(SDC_CLOUDTEX, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = CLOUD_WISPS; dwParam2 = CLOUD_PUFFS; }
		tmpWeatherChange.Init("CloudTex", SDC_CLOUDTEX, dwCurGameTime, dwParam1, dwParam2, 10.0f);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 라이트 0
		iPos = GetLatestChange(SDC_LIGHT0COLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Light0", SDC_LIGHT0COLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);
		
		// 라이트 1
		iPos = GetLatestChange(SDC_LIGHT1COLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Light1", SDC_LIGHT1COLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 라이트 2
		iPos = GetLatestChange(SDC_LIGHT2COLOR, iAfterNSecPos); // N초 후에 가장 최근에 변한 하늘 변화 위치 구하기
		if (iPos>=0) { dwParam1 = m_DayChanges[iPos].dwParam1; dwParam2 = m_DayChanges[iPos].dwParam2; }
		else { dwParam1 = D3DCOLOR_ARGB(255, 255, 255, 255); dwParam2 = 100; }
		tmpWeatherChange.Init("Light2", SDC_LIGHT2COLOR, dwWhen, dwParam1, dwParam2, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);


		// 원래대로 날씨 돌리기..
		iAfterNSecPos = GetDayChangePos_AfterNSec(dwCurGameTime, 10);	// 10초 후에 DayChangePos구하기

		std::vector<__SKY_DAYCHANGE>(m_WeatherChanges).swap(m_WeatherChanges); // 용량을 딱 맞추기..
		qsort(&(m_WeatherChanges[0]), m_WeatherChanges.size(), sizeof(__SKY_DAYCHANGE), CompareTime);


		// 날씨 좋다~
		if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
		if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
		if (m_pSnd_Weather_Rain) m_pSnd_Weather_Rain->Stop(5.0f);
		if (m_pSnd_Weather_Snow) m_pSnd_Weather_Snow->Stop(5.0f);
#endif // #ifdef _N3GAME
	}
	else if(SW_RAINY == m_eWeather || SW_SNOW == m_eWeather) // 비, 눈 옴
	{
		if (SW_CLEAR != ePrevWeather) return;	// 이전 날씨가 맑은날이 아니면 변화시키지 않는다.
		float fHowLong = 10.0f;

		// 날씨 변화 큐 만들기
		m_WeatherChanges.clear();
		m_iWeatherChangeCurPos = 0;
		m_WeatherChanges.reserve(16);
		__SKY_DAYCHANGE tmpWeatherChange;
		__ColorValue crTmp1, crTmp2;
		float fDelta = (0.5f + 0.3f * (100 - iPercentage) / 100.0f);
		uint32_t dwWhen = dwCurGameTime + CONVERT_SEC(0, 0, 10);

		// 라이트 세팅 변수 구하기..
		__ColorValue crLgt(1,1,1,1);
		int iAfterNSecPos = GetDayChangePos_AfterNSec(dwCurGameTime, 10);	// 60초 후에 DayChangePos구하기
		int iPos = GetLatestChange(SDC_LIGHT1COLOR, iAfterNSecPos); // 지형에 내리쬐는 빛
		if (iPos>=0) { crLgt = m_DayChanges[iPos].dwParam1; }
		float fDelta2 = (crLgt.r + crLgt.g + crLgt.b) / 3.0f;
		fDelta2 = 1.0f - fDelta2 * 0.8f * (iPercentage/100.0f);


		// 해
		tmpWeatherChange.Init("Sun", SDC_SUNCOLOR, dwWhen, 0xff000000, (uint32_t)(this->GetSunRatio() * 1000), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 해의 flare
		tmpWeatherChange.Init("Flare", SDC_FLARECOLOR, dwWhen, 0xff000000, (uint32_t)(this->GetFlareRatio() * 1000), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 해의 glow
		tmpWeatherChange.Init("Glow", SDC_GLOWCOLOR, dwWhen, 0xff000000, (uint32_t)(this->GetGlowRatio() * 1000), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		//  하늘색
		crTmp1 = this->GetSkyColor(); crTmp1 *= fDelta; crTmp1.a = 1.0f;
		tmpWeatherChange.Init("Sky", SDC_SKYCOLOR, dwWhen, crTmp1.ToD3DCOLOR(), 0, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		//  안개색
		crTmp1 = this->GetFogColor(); crTmp1 *= fDelta2; crTmp1.a = 1.0f;
		tmpWeatherChange.Init("Fog", SDC_FOGCOLOR, dwWhen, crTmp1.ToD3DCOLOR(), 0, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 구름색1
		crTmp1 = this->GetCloud1Color(); crTmp1 *= fDelta * 0.75f; crTmp1.a = 1.0f;
		tmpWeatherChange.Init("Cloud1Color", SDC_CLOUD1COLOR, dwWhen, crTmp1.ToD3DCOLOR(), 0, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 구름색2 - 좀더 어둡게 한다..
		crTmp1 = this->GetCloud2Color(); crTmp1 *= fDelta * 0.5f; crTmp1.a = 1.0f;
		tmpWeatherChange.Init("Cloud2Color", SDC_CLOUD2COLOR, dwWhen, crTmp1.ToD3DCOLOR(), 0, fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);
		
		// 구름 텍스쳐
		uint32_t dwTex1, dwTex2;
		if (iPercentage>80)			{ dwTex1 = CLOUD_OVERCAST;	dwTex2 = CLOUD_DENSE; }
		else if (iPercentage>60)	{ dwTex1 = CLOUD_DENSE;		dwTex2 = CLOUD_STREAKS; }
		else if (iPercentage>40)	{ dwTex1 = CLOUD_STREAKS;	dwTex2 = CLOUD_TATTERS; }
		else { dwTex1 = CLOUD_TATTERS; dwTex2 = CLOUD_PUFFS; }
		tmpWeatherChange.Init("CloudTex", SDC_CLOUDTEX, dwCurGameTime, dwTex1, dwTex2, 10.0f);
		m_WeatherChanges.push_back(tmpWeatherChange);

		// 라이트 0
		crTmp1 = this->GetLightDiffuseColor(0); crTmp1 *= fDelta2; crTmp1.a = 1.0f;
		crTmp2 = this->GetLightAmbientColor(0); crTmp2 *= fDelta2; crTmp2.a = 1.0f;
		tmpWeatherChange.Init("Light0", SDC_LIGHT0COLOR, dwWhen, crTmp1.ToD3DCOLOR(), crTmp2.ToD3DCOLOR(), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);
		
		// 라이트 1
		crTmp1 = this->GetLightDiffuseColor(1); crTmp1 *= fDelta2; crTmp1.a = 1.0f;
		crTmp2 = this->GetLightAmbientColor(1); crTmp2 *= fDelta2; crTmp2.a = 1.0f;
		tmpWeatherChange.Init("Light1", SDC_LIGHT1COLOR, dwWhen, crTmp1.ToD3DCOLOR(), crTmp2.ToD3DCOLOR(), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);
		
		// 라이트 2
		crTmp1 = this->GetLightDiffuseColor(2); crTmp1 *= fDelta2; crTmp1.a = 1.0f;
		crTmp2 = this->GetLightAmbientColor(2); crTmp2 *= fDelta2; crTmp2.a = 1.0f;
		tmpWeatherChange.Init("Light2", SDC_LIGHT2COLOR, dwWhen, crTmp1.ToD3DCOLOR(), crTmp2.ToD3DCOLOR(), fHowLong);
		m_WeatherChanges.push_back(tmpWeatherChange);


		
		std::vector<__SKY_DAYCHANGE>(m_WeatherChanges).swap(m_WeatherChanges); // 용량을 딱 맞추기..
		qsort(&(m_WeatherChanges[0]), m_WeatherChanges.size(), sizeof(m_WeatherChanges[0]), CompareTime);


		float fHeight = 20.0f;
		float fPercent = iPercentage / 100.0f;
//		float fDensity = fPercent * 0.1f;
		float fDensity = fPercent * 0.03f;
		if(SW_RAINY == m_eWeather)
		{
			if (m_pGESnow) m_pGESnow->FadeSet(3.0f, false);
			if (m_pGERain == nullptr) m_pGERain = new CN3GERain;

			__Vector3 vVelocity(3.0f * ((50-rand()%100) / 50.0f), -(10.0f + 8.0f * fPercent), 0);
			float fRainLength = 0.4f + 0.6f * fPercent;

			m_fCellSize = 20.0f;
			m_pGERain->Create(fDensity, m_fCellSize, fHeight, fRainLength, vVelocity, 10.0f);	// 비
			m_pGERain->SetActive(TRUE);

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
			if(m_pSnd_Weather_Snow) m_pSnd_Weather_Snow->Stop(5.0f);
			CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Rain);
			m_pSnd_Weather_Rain = CN3Base::s_SndMgr.CreateObj(201);	// 비오는 소리..
			if(m_pSnd_Weather_Rain)
			{
				int iMaxVol = (int)(70 * fPercent);
				m_pSnd_Weather_Rain->SetMaxVolume(iMaxVol);
				m_pSnd_Weather_Rain->Looping(true);
				m_pSnd_Weather_Rain->Play(nullptr, 0.0f, 2.0f);
			}
#endif // #ifdef _N3GAME
		}
		else if(SW_SNOW == m_eWeather)
		{
			if (m_pGERain) m_pGERain->FadeSet(3.0f, false);
			if (m_pGESnow == nullptr) m_pGESnow = new CN3GESnow;

			float fHorz = (3.0f * fPercent) + (3.0f * ((50-rand()%100) / 50.0f));
			__Vector3 vVelocity(fHorz, -(2.0f + 2.0f * fPercent), 0);
			float fSnowSize = 0.1f + 0.1f * fPercent;

			m_fCellSize = 20.0f;
			m_pGESnow->Create(fDensity, m_fCellSize, fHeight, fSnowSize, vVelocity, 10.0f);	// 비
			m_pGESnow->SetActive(TRUE);

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
			if(m_pSnd_Weather_Rain) m_pSnd_Weather_Rain->Stop(5.0f);
			CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Weather_Snow);
			m_pSnd_Weather_Snow = CN3Base::s_SndMgr.CreateObj(200);	// 바람소리..
			if(m_pSnd_Weather_Snow)
			{
				int iMaxVol = (int)(70 * fPercent);
				m_pSnd_Weather_Snow->SetMaxVolume(iMaxVol);
				m_pSnd_Weather_Snow->Looping(true);
				m_pSnd_Weather_Snow->Play(nullptr, 0.0f, 2.0f);
			}
#endif // #ifdef _N3GAME
		}
	}
}

void CN3SkyMng::SunAndMoonDirectionFixByHour(int iHour) // 해와 달 각도 관리
{
	m_iHourFix = iHour;
}

void CN3SkyMng::GetGameTime(int* piYear, int* piMonth, int* piDay, int* piHour, int*piMin)
{
	uint32_t dwCurTickCount = timeGetTime();
	__ASSERT(dwCurTickCount >= m_dwCheckTick,"음수이다.");
	uint32_t dwCurGameTime = m_dwCheckGameTime + (uint32_t)((dwCurTickCount - m_dwCheckTick)*TIME_REAL_PER_GAME*0.001f);

	// dwCurGameTime - 초
	int iSecond = dwCurGameTime%3600;

	if(piYear)	*piYear = m_iYear;
	if(piMonth) *piMonth = m_iMonth;
	if(piDay)	*piDay = m_iDay;
	if(piHour)	*piHour = dwCurGameTime/3600;
	if(piMin)	*piMin = iSecond/60;
}

void CN3SkyMng::SetGameTime(int iYear, int iMonth, int iDay, int iHour, int iMin)
{
	m_iYear = iYear;
	m_iMonth = iMonth;
	m_iDay = iDay;

	__ASSERT(m_pMoon,"null pointer");
	m_pMoon->SetMoonPhase(iMonth*30 + iDay);
	SetCheckGameTime(CONVERT_SEC(iHour, iMin,0));
}

int	CN3SkyMng::GetDayChangePos_AfterNSec(uint32_t dwCurGameTime, float fSec)
{
	// n초 후의 체크할 게임 시간을 계산
	uint32_t dwCheckGameTime = dwCurGameTime + (uint32_t)(fSec*TIME_REAL_PER_GAME);	// 150초 후 게임시간
	int iCheckDayChangeCurPos = m_iDayChangeCurPos;
	if (dwCheckGameTime>86400)	// 체크 시간이 게임시간의 24시를 넘으면
	{
		iCheckDayChangeCurPos = 0;
		dwCheckGameTime %= 86400;
	}

	// n초후의 queue의 위치 찾기
	while (iCheckDayChangeCurPos >= 0
		&& iCheckDayChangeCurPos < static_cast<int>(m_DayChanges.size())
		&& m_DayChanges[m_iDayChangeCurPos].dwWhen < dwCheckGameTime)
		++iCheckDayChangeCurPos;

	if (iCheckDayChangeCurPos >= static_cast<int>(m_DayChanges.size()))
		iCheckDayChangeCurPos = static_cast<int>(m_DayChanges.size()) - 1;

	return iCheckDayChangeCurPos;
}


D3DCOLOR CN3SkyMng::GetFogColor()
{
	if(m_pSky) return m_pSky->m_FogColor.GetCurColor(); 
	else return 0;
}

D3DCOLOR CN3SkyMng::GetSkyColor()
{
	if(m_pSky) return m_pSky->m_SkyColor.GetCurColor();
	else return 0;
}

D3DCOLOR CN3SkyMng::GetSunColor()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_SUN].Color.GetCurColor();
	else return 0;
}

D3DCOLOR CN3SkyMng::GetGlowColor()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_GLOW].Color.GetCurColor();
	else return 0;
}

D3DCOLOR CN3SkyMng::GetFlareColor()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_FLARE].Color.GetCurColor();
	else return 0;
}

float CN3SkyMng::GetSunRatio()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_SUN].Delta.GetCurDelta();
	else return 0;
}

float CN3SkyMng::GetGlowRatio()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_GLOW].Delta.GetCurDelta();
	else return 0;
}

float CN3SkyMng::GetFlareRatio()
{
	if(m_pSun) return m_pSun->m_Parts[SUNPART_FLARE].Delta.GetCurDelta();
	else return 0;
}


D3DCOLOR CN3SkyMng::GetCloud1Color()
{
	if(m_pCloud) return m_pCloud->m_Color1.GetCurColor();
	else return 0;
}

D3DCOLOR CN3SkyMng::GetCloud2Color()
{
	if(m_pCloud) return m_pCloud->m_Color2.GetCurColor();
	else return 0;
}

D3DCOLOR CN3SkyMng::GetLightDiffuseColor(int iIndex)
{
	if(iIndex < 0 || iIndex >= MAX_GAME_LIGHT) return 0;
	if(nullptr == m_pLightColorDiffuses[iIndex]) return 0;
	
	return m_pLightColorDiffuses[iIndex]->GetCurColor();
}

D3DCOLOR CN3SkyMng::GetLightAmbientColor(int iIndex)
{
	if(iIndex < 0 || iIndex >= MAX_GAME_LIGHT) return 0;
	if(nullptr == m_pLightColorAmbients[iIndex]) return 0;
	
	return m_pLightColorAmbients[iIndex]->GetCurColor();
}

bool CN3SkyMng::Load(File& file)
{
	std::string szSuns[NUM_SUNPART];
	std::string szClouds[NUM_CLOUD];
	std::string szMoon;

	int i = 0;
	for(i = 0; i < NUM_SUNPART; i++) 
	{
		int iL = 0;
		file.Read(&iL, 4);
		if(iL > 0)
		{
			szSuns[i].assign(iL, ' ');
			file.Read(&(szSuns[i][0]), iL);
		}
	}

	for(i = 0; i < NUM_CLOUD; i++) 
	{
		int iL = 0;
		file.Read(&iL, 4);
		if(iL > 0)
		{
			szClouds[i].assign(iL, ' ');
			file.Read(&(szClouds[i][0]), iL);
		}
	}
	
	int iL = 0;
	file.Read(&iL, 4);
	if(iL > 0)
	{
		szMoon.assign(iL, ' ');
		file.Read(&(szMoon[0]), iL);
	}

	if(nullptr == m_pSky) m_pSky = new CN3Sky();
	m_pSky->Init();

	if(nullptr == m_pStar) m_pStar = new CN3Star();
	m_pStar->Init();

	if(nullptr == m_pSun) m_pSun = new CN3Sun();
	m_pSun->Init(szSuns);

	if(nullptr == m_pCloud) m_pCloud = new CN3Cloud();
	m_pCloud->Init(szClouds);

	if(nullptr == m_pMoon) m_pMoon = new CN3Moon();
	m_pMoon->Init(szMoon);

	for(i = 0; i < MAX_GAME_LIGHT; i++)
	{
		if(nullptr == m_pLightColorDiffuses[i]) m_pLightColorDiffuses[i] = new CN3ColorChange();
		if(nullptr == m_pLightColorAmbients[i]) m_pLightColorAmbients[i] = new CN3ColorChange();
	}

	// Day Change .....
	m_DayChanges.clear();
	int iSDCC = 0;
	file.Read(&iSDCC, 4);
	if(iSDCC > 0)
	{
		m_DayChanges.assign(iSDCC, __SKY_DAYCHANGE());
		for(i = 0; i < iSDCC; i++)
		{
			m_DayChanges[i].Load(file);
		}

		qsort(&(m_DayChanges[0]), m_DayChanges.size(), sizeof(__SKY_DAYCHANGE), CompareTime); // 시간순으로 정렬
	}

	SetCheckGameTime(CONVERT_SEC(10,0,0));
	return true;
}

#ifdef _N3TOOL
bool CN3SkyMng::Save(File& file)
{
	std::string szSuns[NUM_SUNPART];
	std::string szClouds[NUM_CLOUD];
	std::string szMoon;

	for (int i = 0; i < NUM_SUNPART; i++)
	{
		if (m_pSun != nullptr && m_pSun->m_Parts[i].pTex != nullptr)
			szSuns[i] = m_pSun->m_Parts[i].pTex->FileName();
	}

	for (int i = 0; i < NUM_CLOUD; i++)
	{
		if (m_pCloud != nullptr)
			szClouds[i] = m_pCloud->m_szTextures[i];
	}

	if (m_pMoon != nullptr && m_pMoon->m_pTexture != nullptr)
		szMoon = m_pMoon->m_pTexture->FileName();

	for (int i = 0; i < NUM_SUNPART; i++)
	{
		int iL = static_cast<int>(szSuns[i].size());
		file.Write(&iL, 4);
		if (iL > 0)
			file.Write(szSuns[i].c_str(), iL);
	}

	for (int i = 0; i < NUM_CLOUD; i++)
	{
		int iL = static_cast<int>(szClouds[i].size());
		file.Write(&iL, 4);
		if (iL > 0)
			file.Write(szClouds[i].c_str(), iL);
	}

	int iL = static_cast<int>(szMoon.size());
	file.Write(&iL, 4);
	if (iL > 0)
		file.Write(szMoon.c_str(), iL);

	// Day Change .....
	int iSDCC = static_cast<int>(m_DayChanges.size());
	file.Write(&iSDCC, 4);
	for (int i = 0; i < iSDCC; i++)
		m_DayChanges[i].Save(file);

	return true;
}
#endif // #ifdef _N3TOOL


#ifdef _N3TOOL
__SKY_DAYCHANGE* CN3SkyMng::DayChangeGet(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_DayChanges.size()))
		return nullptr;

	return &m_DayChanges[iIndex];
}

__SKY_DAYCHANGE* CN3SkyMng::DayChangeAdd()
{
	__SKY_DAYCHANGE SDC;
	m_DayChanges.push_back(SDC);
	return &(m_DayChanges[m_DayChanges.size()-1]);
}

__SKY_DAYCHANGE* CN3SkyMng::DayChangeInsert(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_DayChanges.size()))
		return nullptr;
	
	it_SDC it = m_DayChanges.begin();
	for(int i = 0; i < iIndex; i++, it++);
	
	// TODO(srmeier): need to figure this out
	return nullptr; //it = m_DayChanges.insert(it);
	
	return &(*it);
}

bool CN3SkyMng::DayChangeDelete(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_DayChanges.size()))
		return false;
	
	it_SDC it = m_DayChanges.begin();
	for(int i = 0; i < iIndex; i++, it++);
	
	it = m_DayChanges.erase(it);
	return true;
}

CN3Texture* CN3SkyMng::SunTextureSet(int iIndex, const char* szPath)
{
	if(nullptr == szPath || nullptr == m_pSun || iIndex < 0 || iIndex >= NUM_SUNPART) return nullptr;

	s_MngTex.Delete(&(m_pSun->m_Parts[iIndex].pTex));
	m_pSun->m_Parts[iIndex].pTex = s_MngTex.Get(szPath);

	return m_pSun->m_Parts[iIndex].pTex;
}

CN3Texture* CN3SkyMng::MoonTextureSet(const char* szPath)
{
	if(nullptr == szPath || nullptr == m_pMoon) return nullptr;

	s_MngTex.Delete(&(m_pMoon->m_pTexture));
	m_pMoon->m_pTexture = s_MngTex.Get(szPath);

	return m_pMoon->m_pTexture;
}

CN3Texture* CN3SkyMng::CloudTextureSet(int iIndex, const char* szPath)
{
	if(nullptr == szPath || nullptr == m_pCloud || iIndex < 0 || iIndex >= NUM_CLOUD) return nullptr;

	s_MngTex.Delete(&(m_pCloud->m_pTextures[iIndex]));
	m_pCloud->m_pTextures[iIndex] = s_MngTex.Get(szPath);
	m_pCloud->m_szTextures[iIndex] = "";
	if(m_pCloud->m_pTextures[iIndex])
		m_pCloud->m_szTextures[iIndex] = m_pCloud->m_pTextures[iIndex]->FileName();

	return m_pCloud->m_pTextures[iIndex];
}

CN3Texture* CN3SkyMng::SunTextureGet(int iIndex)
{
	if(nullptr == m_pSun || iIndex < 0 || iIndex >= NUM_CLOUD) return nullptr;
	return m_pSun->m_Parts[iIndex].pTex;
}

CN3Texture* CN3SkyMng::MoonTextureGet()
{
	if(nullptr == m_pMoon) return nullptr;
	return m_pMoon->m_pTexture;
}

CN3Texture* CN3SkyMng::CloudTextureGet(int iIndex)
{
	if(nullptr == m_pCloud || iIndex < 0 || iIndex >= NUM_CLOUD) return nullptr;
	return m_pCloud->m_pTextures[iIndex];
}

const char* CN3SkyMng::CloudTextureFileName(int iIndex)
{
	if(nullptr == m_pCloud || iIndex < 0 || iIndex >= NUM_CLOUD) return nullptr;
	return m_pCloud->m_szTextures[iIndex].c_str();
}
#endif

/*
void CN3SkyMng::ColorDeltaSet(int iPercentage, float fHowLong) // 현재 하늘, 안개 색을 퍼센트 단위로 변화시킨다.. 비, 눈 올때 쓴다..
{
	if(iPercentage < 0) iPercentage = 0;
	if(iPercentage > 100) iPercentage = 100;

	D3DCOLOR crFinalFog = m_pSky->m_FogColor.GetCurColor();
	D3DCOLOR crFinalSky = m_pSky->m_SkyColor.GetCurColor();

	crFinalFog = 	((((crFinalFog & 0x00ff0000) >> 16) * iPercentage / 100) << 16) | 
					((((crFinalFog & 0x0000ff00) >> 8) * iPercentage / 100) << 8) | 
					((crFinalFog & 0x000000ff) * iPercentage / 100);
	
	crFinalSky = 	((((crFinalSky & 0x00ff0000) >> 16) * iPercentage / 100) << 16) | 
					((((crFinalSky & 0x0000ff00) >> 8) * iPercentage / 100) << 8) | 
					((crFinalSky & 0x000000ff) * iPercentage / 100);
	
	m_pSky->m_FogColor.ChangeColor(crFinalFog, fHowLong);
	m_pSky->m_SkyColor.ChangeColor(crFinalSky, fHowLong);

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	if(m_pSnd_Weather_Snow) m_pSnd_Weather_Snow->Stop(5.0f);
	if(m_pSnd_Weather_Rain) m_pSnd_Weather_Rain->Stop(5.0f);
#endif // #ifdef _N3GAME
}
*/

// ===== END N3Base/N3SkyMng.cpp =====

// ===== BEGIN N3Base/N3SkyMng.h =====
#line 1 "N3Base/N3SkyMng.h"
﻿// N3SkyMng.h: interface for the CN3SkyMng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SKYMNG_H__30DC78FB_6563_43BD_841E_B90928E850CD__INCLUDED_)
#define AFX_N3SKYMNG_H__30DC78FB_6563_43BD_841E_B90928E850CD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"
#include <vector>

const float TIME_REAL_PER_GAME = 10.0f;						// 실제 시간과 game시간의 비율(현재 게임은 실제 시간보다 열배 빨리 돌아간다..)
const float TIME_GAME_PER_REAL = 1.0f/TIME_REAL_PER_GAME;	// game시간과 실제 시간의 비율
#define CONVERT_SEC(h, m, s) ((h)*3600 + (m)*60 + (s))

// 시간 관리
enum		eSKY_DAYCHANGE {	SDC_SKYCOLOR=0,		// 하늘색
								SDC_FOGCOLOR,		// 안개색
								SDC_STARCOUNT,		// 별 수
								SDC_MOONPHASE,		// 달 모양
								SDC_SUNCOLOR,		// 해 색, 크기 - 1000 이 뷰포트에서 꽉차는 크기.
								SDC_GLOWCOLOR,		// 해의 glow색, 크기 - 1000 이 뷰포트에서 꽉차는 크기.
								SDC_FLARECOLOR,		// 해의 flare색, 크기 - 1000 이 뷰포트에서 꽉차는 크기.
								SDC_CLOUD1COLOR,	// 구름층 1의 색
								SDC_CLOUD2COLOR,	// 구름층 2의 색
								SDC_CLOUDTEX,		// 구름 텍스쳐 바꾸기
								
								SDC_LIGHT0COLOR,	// Direction Light 0
								SDC_LIGHT1COLOR,	// Direction Light 1
								SDC_LIGHT2COLOR,	// 플레이어 주위의 Light
								
								NUM_SKYDAYCHANGE,
								
								SDC_UNKNOWN = 0xffffffff
};

struct __SKY_DAYCHANGE
{
	std::string		szName;			// 이름 붙이기..
	eSKY_DAYCHANGE	eSkyDayChange;	// 어떤 변화인가?
	uint32_t			dwWhen;			// 언제 변화시작인가?(0시부터 초단위로 나타낸 시간)
	uint32_t			dwParam1;		// parameter 1
	uint32_t			dwParam2;		// parameter 2
	float			fHowLong;		// 얼마나 걸릴것인가?(실시간 초)

	void Init()
	{
		szName = "";
		eSkyDayChange = SDC_UNKNOWN;
		dwWhen = dwParam1 = dwParam2 = 0;
		fHowLong = 0;
	}

	void Init(const std::string& szName_Arg, eSKY_DAYCHANGE eSDC_Arg, uint32_t dwWhen_Arg, uint32_t dwParam1_Arg, uint32_t dwParam2_Arg, float fHowLong_Arg)
	{
		szName = szName_Arg;
		eSkyDayChange = eSDC_Arg;
		dwWhen = dwWhen_Arg;
		dwParam1 = dwParam1_Arg;
		dwParam2 = dwParam2_Arg;
		fHowLong = fHowLong_Arg;
	}

	bool Load(File& file)
	{
		int nL = 0;
		file.Read(&nL, 4);
		if (nL > 0)
		{
			szName.assign(nL, '\0');
			file.Read(&szName[0], nL);
		}
		else
		{
			szName.clear();
		}

		file.Read(&eSkyDayChange, 4);
		file.Read(&dwWhen, 4);
		file.Read(&dwParam1, 4);
		file.Read(&dwParam2, 4);
		file.Read(&fHowLong, 4);

		return true;
	}
	
	bool Save(File& file)
	{
		int nL = static_cast<int>(szName.size());
		file.Write(&nL, 4);
		if (nL > 0)
			file.Write(szName.c_str(), nL);

		file.Write(&eSkyDayChange, 4);
		file.Write(&dwWhen, 4);
		file.Write(&dwParam1, 4);
		file.Write(&dwParam2, 4);
		file.Write(&fHowLong, 4);

		return true;
	}

	__SKY_DAYCHANGE() { this->Init(); }
};

const int MAX_GAME_LIGHT = 3;

class CN3SkyMng : public CN3BaseFileAccess
{
public:
	CN3SkyMng();
	virtual ~CN3SkyMng();
// Attributes
public:
	enum		eSKY_WEATHER {  SW_CLEAR=1,	// 맑음
								SW_RAINY,	// 비
								SW_SNOW};	// 눈
protected:
	class CN3Sky*			m_pSky;
	class CN3Moon*			m_pMoon;
	class CN3Sun*			m_pSun;
	class CN3Cloud*			m_pCloud;
	class CN3Star*			m_pStar;
	class CN3ColorChange*	m_pLightColorDiffuses[MAX_GAME_LIGHT];
	class CN3ColorChange*	m_pLightColorAmbients[MAX_GAME_LIGHT];

	std::vector<__SKY_DAYCHANGE> m_DayChanges;		// 정보입력후에 qsort하자
	int						m_iDayChangeCurPos;

	std::vector<__SKY_DAYCHANGE> m_WeatherChanges;		// 정보입력후에 qsort하자
	int						m_iWeatherChangeCurPos;

	uint32_t		m_dwCheckTick;	// 서버에서 시간을 받을때의 윈도우TickCount(실시간) (게임시간으로 24시에 다시 설정하기도 한다.)
	uint32_t		m_dwCheckGameTime;	// 서버에서 내려받은 시간(게임 시간 초단위) 0 ~ (24*60*60)
	eSKY_WEATHER	m_eWeather;

	int			m_iYear;
	int			m_iMonth;
	int			m_iDay;

	int			m_iHourFix;		// 해,달 방향 고정시 시간으로 나타내는 방향.


	float			m_fCellSize;	// 내부 셀 크기
	POINT			m_CurCellPos;	// 현재 내부셀 좌표
	__Vector3		m_vPos[9];		// 주변 셀 9칸의 중심좌표들

	// 효과들..
	class CN3GERain*		m_pGERain;		// 비
	class CN3GESnow*		m_pGESnow;		// 눈
#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	class CN3SndObj*		m_pSnd_Weather_Rain;
	class CN3SndObj*		m_pSnd_Weather_Snow;
#endif // #ifdef _N3GAME

// Operations
public:
#ifdef _N3TOOL
	void InitToDefaultHardCoding();
	bool LoadFromTextFile(const char* szIniFN);
	bool SaveToTextFile(const char* szIniFN);
	bool DayChangeParse(FILE* fp, __SKY_DAYCHANGE* pDayChange);
	bool DayChangeWrite(FILE* fp, __SKY_DAYCHANGE* pDayChange);

	int DayChangeCount() const
	{
		return static_cast<int>(m_DayChanges.size());
	}

	__SKY_DAYCHANGE*	DayChangeGet(int iIndex);
	__SKY_DAYCHANGE*	DayChangeAdd();
	__SKY_DAYCHANGE*	DayChangeInsert(int iIndex);
	bool				DayChangeDelete(int iIndex);

	CN3Texture*			SunTextureSet(int iIndex, const char* szPath);
	CN3Texture*			MoonTextureSet(const char* szPath);
	CN3Texture*			CloudTextureSet(int iIndex, const char* szPath);
	
	CN3Texture*			SunTextureGet(int iIndex);
	CN3Texture*			MoonTextureGet();
	CN3Texture*			CloudTextureGet(int iIndex);
	const char*			CloudTextureFileName(int iIndex);
#endif

	bool Load(File& file) override;

#ifdef _N3GAME // 게임이 아닌 툴에서는 필요없다...
	void ReleaseSound();
#endif // #ifdef _N3GAME

#ifdef _N3TOOL
	bool Save(File& file);
#endif

	D3DCOLOR	GetFogColor();
	D3DCOLOR	GetSkyColor();
	D3DCOLOR	GetSunColor();
	D3DCOLOR	GetGlowColor();
	D3DCOLOR	GetFlareColor();
	float		GetSunRatio();
	float		GetGlowRatio();
	float		GetFlareRatio();

	D3DCOLOR	GetCloud1Color();
	D3DCOLOR	GetCloud2Color();
	
	float		GetSunAngleByRadin();

	D3DCOLOR	GetLightDiffuseColor(int iIndex);
	D3DCOLOR	GetLightAmbientColor(int iIndex);

	void	Release() override;
	void	Render(); // 하늘만 렌더링..
	void	RenderWeather(); // 비나 눈등의 날씨 렌더링..
	void	Tick();

	// 시간 관리
	void	GetGameTime(int* piYear, int* piMonth, int* piDay, int* piHour, int*piMin);
	void	SetGameTime(int iYear, int iMonth, int iDay, int iHour, int iMin);
	void	SetWeather(eSKY_WEATHER eWeather, int iPercentage);	//	날씨 세팅
	
	void	SunAndMoonDirectionFixByHour(int iHour); // 해와 달 각도 관리

//	By : Ecli666 ( On 2002-04-04 오전 10:53:58 )
//
	CN3Sun*	GetSunPointer()	{	return m_pSun;	}
//	~(By Ecli666 On 2002-04-04 오전 10:53:58 )
	
protected:
	void		SetCheckGameTime(uint32_t dwCheckGameTime);//	CheckGameTime을 정해주고 현재시간을 다시 세팅한다.(특정 시간으로 강제적으로 만들때 호출한다.)
	int			GetLatestChange(eSKY_DAYCHANGE eSDC, int iPos);// m_pDayChangeQueues에서 지정된 위치(iPos) 이전의 가장 최근에 변화하는 위치 얻어오기
	void		ChangeSky(__SKY_DAYCHANGE* pSDC, float fTakeTime);
	int			GetDayChangePos_AfterNSec(uint32_t dwCurGameTime, float fSec);		// 실시간 N초 후에 DayChangeQueue의 위치 구하기
	static int	CompareTime(const void* pArg1, const void* pArg2);
};

#endif // !defined(AFX_N3SKYMNG_H__30DC78FB_6563_43BD_841E_B90928E850CD__INCLUDED_)

// ===== END N3Base/N3SkyMng.h =====

// ===== BEGIN N3Base/N3SndDef.h =====
#line 1 "N3Base/N3SndDef.h"
﻿////////////////////////////////////////////////////////////////////////////////////////
//
//	N3SndDef.h
//	- 이것저것 Sound에 관련된 자료형정의, 상수정의...
//
//	By Donghoon..
//
////////////////////////////////////////////////////////////////////////////////////////

#ifndef __N3SNDDEF_H__
#define __N3SNDDEF_H__

#include "WaveFile.h"
#include <DSound.h>
#include <string>

class CN3SndObj;

typedef struct __SoundSource
{
	int						iID;
	std::string				szFN;
	LPDIRECTSOUNDBUFFER		pDSBuff;
	int						Size;
	int						Type; // 0:2d 1:3d 2: streammin..
	int						Count;
	int						iMaxCount;
	CN3SndObj**				ppObjs;

	__SoundSource()
	{
		iID = 0;
		ppObjs = nullptr;
		szFN = "";
		pDSBuff = nullptr;
		Size = 0;
		Type = 0;
		Count = 0;
		iMaxCount = 0;
	}	
} SOUNDSOURCE, *LPSOUNDSOURCE;

typedef struct __TABLE_SOUND // Sound 리소스 레코드...
{
	uint32_t		dwID;		// 고유 ID
	std::string	szFN;		// wave file name
	int			iType;		// 사운드 타입...
	int			iNumInst;	// 최대 사용할 수 있는 인스턴스의 갯수..
} TABLE_SOUND;


// 사운드 오브젝트 타입 정의..
enum e_SndType { SNDTYPE_2D=0, SNDTYPE_3D, SNDTYPE_STREAM };
enum e_SndState { SNDSTATE_STOP=0, SNDSTATE_DELAY, SNDSTATE_FADEIN, SNDSTATE_PLAY, SNDSTATE_FADEOUT };

#endif	//end of #ifndef __N3SNDDEF_H__
// ===== END N3Base/N3SndDef.h =====

// ===== BEGIN N3Base/N3SndEng.h =====
#line 1 "N3Base/N3SndEng.h"
﻿// N3SndEng.h: interface for the CN3SndEng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SNDENG_H__0205273B_6697_4AB9_A33F_218534153AB3__INCLUDED_)
#define AFX_N3SNDENG_H__0205273B_6697_4AB9_A33F_218534153AB3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3SndDef.h"

class CN3SndObj;

class CN3SndEng  
{
protected:
	LPDIRECTSOUND8			m_pDS;

	LPDIRECTSOUND3DLISTENER m_pDSListener;			// 3D listener object
	DS3DLISTENER            m_dsListenerParams;		// Listener properties

	bool					m_Tick;

protected:
	HRESULT RestoreBuffer( LPDIRECTSOUNDBUFFER pDSB, BOOL* pbWasRestored );
	bool SetPrimaryBufferFormat( uint32_t dwPrimaryChannels, uint32_t dwPrimaryFreq, uint32_t dwPrimaryBitRate );
	bool Get3DListenerInterface( LPDIRECTSOUND3DLISTENER* ppDSListener );

	bool FillBufferWithSound( LPSOUNDSOURCE pSrc, CWaveFile* pWaveFile);
	
public:
	LPDIRECTSOUND8*		GetDS() { return &m_pDS; }
	void SetDopplerFactor(D3DVALUE factor);
	
	void DuplicateBuff(LPSOUNDSOURCE pSrc, CN3SndObj* pDest, D3DVECTOR* pPos=nullptr);
	
	void Tick();
	
	void SetRollOffFactor(D3DVALUE value, bool IsDeferred = true);
	void SetListenerOrientation(D3DVECTOR* pVAt, D3DVECTOR* pVUp, bool IsDeferred = true);
	void SetListenerPos(D3DVECTOR* pVPos, bool IsDeferred = true);
	
	bool LoadSource(LPSOUNDSOURCE pSrc);
	bool Init( HWND hWnd, uint32_t dwCoopLevel = DSSCL_PRIORITY, uint32_t dwPrimaryChannels = 2, uint32_t dwPrimaryFreq = 22050, uint32_t dwPrimaryBitRate = 16 );
	void Release();

	CN3SndEng();
	virtual ~CN3SndEng();

};

#endif // !defined(AFX_N3SNDENG_H__0205273B_6697_4AB9_A33F_218534153AB3__INCLUDED_)

// ===== END N3Base/N3SndEng.h =====

// ===== BEGIN N3Base/N3SndMgr.cpp =====
#line 1 "N3Base/N3SndMgr.cpp"
﻿// N3SndMgr.cpp: implementation of the CN3SndMgr class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3SndMgr.h"
#include "N3SndObj.h"
#include "N3SndObjStream.h"
#include "N3Base.h"

#include <mpg123.h>
#include <filesystem>

#include <shlobj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3SndMgr::CN3SndMgr()
{
	m_bSndEnable = false;	
	m_bSndDuplicated = false;
}

CN3SndMgr::~CN3SndMgr()
{
	Release();
}

//
//	엔진 초기화..
//
void CN3SndMgr::Init(HWND hWnd)
{
	Release();
	m_bSndEnable = CN3SndObj::StaticInit(hWnd);
	m_Tbl_Source.LoadFromFile("Data\\sound.tbl");
}

CN3SndObj* CN3SndMgr::CreateObj(int iID, e_SndType eType)
{
	TABLE_SOUND* pTbl = m_Tbl_Source.Find(iID);
	if(pTbl==nullptr) return nullptr;

	return this->CreateObj(pTbl->szFN, eType);
}

CN3SndObj* CN3SndMgr::CreateObj(std::string szFN, e_SndType eType)
{
	if (!m_bSndEnable)
		return nullptr;

	if (eType == SNDTYPE_STREAM)
	{
		if (!CN3Base::s_Options.bSndBgmEnable)
			return nullptr;
	}
	else
	{
		if (!CN3Base::s_Options.bSndEffectEnable)
			return nullptr;
	}

	if (!PreprocessFilename(szFN))
		return nullptr;

	CN3SndObj* pObjSrc = nullptr;
	itm_Snd it = m_SndObjSrcs.find(szFN);
	if(it == m_SndObjSrcs.end()) // 못 찾았다... 새로 만들자..
	{
		pObjSrc = new CN3SndObj();
		if(false == pObjSrc->Create(szFN, eType)) // 새로 로딩..
		{
			delete pObjSrc; pObjSrc = nullptr;
			return nullptr;
		}
		m_SndObjSrcs.insert(val_Snd(szFN, pObjSrc)); // 맵에 추가한다..
	}
	else pObjSrc = it->second;

	if(!m_bSndDuplicated) return pObjSrc;//this_Snd

	if(nullptr == pObjSrc) return nullptr;

	CN3SndObj* pObjNew = new CN3SndObj();
	if(false == pObjNew->Duplicate(pObjSrc, eType)) // Duplicate 처리..
	{
		delete pObjNew; pObjNew = nullptr;
		return nullptr;
	}
	
	if(pObjNew) m_SndObjs_Duplicated.push_back(pObjNew); // 리스트에 넣는다...
	return pObjNew;
}

CN3SndObjStream* CN3SndMgr::CreateStreamObj(std::string szFN)
{
	if (!CN3Base::s_Options.bSndBgmEnable)
		return nullptr;

	if (!PreprocessFilename(szFN))
		return nullptr;

	CN3SndObjStream* pObj = new CN3SndObjStream();
	if(false == pObj->Create(szFN))
	{
		delete pObj; pObj = nullptr;
		return nullptr;
	}

	m_SndObjStreams.push_back(pObj); // 리스트에 넣기..

	return pObj;
}

CN3SndObjStream* CN3SndMgr::CreateStreamObj(int iID)
{
	__TABLE_SOUND* pTbl = m_Tbl_Source.Find(iID);
	if (pTbl == nullptr)
		return nullptr;

	return CreateStreamObj(pTbl->szFN);
}

void CN3SndMgr::ReleaseStreamObj(CN3SndObjStream** ppObj)
{
	if(nullptr == ppObj || nullptr == *ppObj) return;

	itl_SndStream it = m_SndObjStreams.begin(), itEnd = m_SndObjStreams.end();
	for(; it != itEnd; it++)
	{
		if(*ppObj == *it) 
		{
			delete *ppObj; *ppObj = nullptr;
			m_SndObjStreams.erase(it);
			break;
		}
	}
}


//
//	TickTick...^^
//
void CN3SndMgr::Tick()
{
	if(!m_bSndEnable) return;

//	m_Eng.SetListenerPos(&(CN3Base::s_CameraData.vEye));
//	__Vector3 vUP(0.0f, 1.0f, 0.0f);
//	__Vector3 vDir = CN3Base::s_CameraData.vAt - CN3Base::s_CameraData.vEye;
//
//	if(vDir.Magnitude() <= FLT_MIN) vDir.Set(0.0f, 0.0f, 1.0f);
//
//	m_Eng.SetListenerOrientation(&vDir, &vUP);
//

/*
	CN3SndObj* pObj = nullptr;
	itl_Snd it = m_SndObjs_Duplicated.begin(), itEnd = m_SndObjs_Duplicated.end();
	for(; it != itEnd; it++)
	{
		pObj = *it;
		pObj->Tick();
	}
*/
	itl_Snd it, itEnd;//this_Snd
	CN3SndObj* pObj = nullptr;
	if(!m_bSndDuplicated)
	{
		itm_Snd it_m = m_SndObjSrcs.begin(), itEnd_m = m_SndObjSrcs.end();
		for(; it_m != itEnd_m; it_m++)
		{
			pObj = it_m->second;
			pObj->Tick();
		}
	}
	else
	{
		it = m_SndObjs_Duplicated.begin();
		itEnd = m_SndObjs_Duplicated.end();
		for(; it != itEnd; it++)
		{
			pObj = *it;
			pObj->Tick();
		}
	}


	it = m_SndObjs_PlayOnceAndRelease.begin();
	itEnd = m_SndObjs_PlayOnceAndRelease.end();
	for(; it != itEnd; )
	{
		pObj = *it;
		pObj->Tick();
		if(false == pObj->IsPlaying())
		{
			it = m_SndObjs_PlayOnceAndRelease.erase(it);
			delete pObj; pObj = nullptr;
		}
		else it++;
	}

	CN3SndObjStream* pObj2 = nullptr;
	itl_SndStream it2 = m_SndObjStreams.begin(), itEnd2 = m_SndObjStreams.end();
	for(; it2 != itEnd2; it2++)
	{
		pObj2 = *it2;
		if (pObj2) pObj2->Tick();
	}

//	itm_Snd it2 = m_SndObjSrcs.begin();
//	for(; it2 != m_SndObjSrcs.end(); it2++)
//	{
//		pObj = it2->second.pSndObj;
//		if(pObj) pObj->Tick();
//	}

	CN3SndObj::StaticTick(); // CommitDeferredSetting...
}


//
//	Obj하나 무효화..
void CN3SndMgr::ReleaseObj(CN3SndObj** ppObj)
{
	if(nullptr == ppObj || nullptr == *ppObj) return;
	std::string szFN = (*ppObj)->m_szFileName; // 파일 이름을 기억하고..

	itl_Snd it = m_SndObjs_Duplicated.begin(), itEnd = m_SndObjs_Duplicated.end();
	for(; it != itEnd; it++)
	{
		if(*ppObj == *it)
		{
			m_SndObjs_Duplicated.erase(it);
			delete *ppObj; *ppObj = nullptr; // 객체 지우기..
			return;
		}
	}

	it = m_SndObjs_PlayOnceAndRelease.begin();
	itEnd = m_SndObjs_PlayOnceAndRelease.end();
	for(; it != itEnd; it++)
	{
		if(*ppObj == *it)
		{
			m_SndObjs_PlayOnceAndRelease.erase(it);
			delete *ppObj; *ppObj = nullptr; // 객체 지우기..
			return;
		}
	}

	*ppObj = nullptr; // 포인터만 널로 만들어 준다..

/*	itm_Snd it = m_SndObjSrcs.find(szFN);
	if(it != m_SndObjSrcs.end()) // 찾았다..
	{
		CN3SndObj* pObj = it->second;
		delete pObj;
		m_SndObjSrcs.erase(it);
	}
	else
	{
		itl_Snd it2 = m_SndObjs_PlayOnceAndRelease.begin();
		for(; it2 != m_SndObjs_PlayOnceAndRelease.end(); it2++)
		{
			CN3SndObj* pObj = *it2;
			if(pObj == *ppObj)
			{
				delete pObj;
				m_SndObjs_PlayOnceAndRelease.erase(it2);
				break;
			}		
		}
	}
*/
}


//
//	Release Whole Objects & Sound Sources & Sound Engine..
//
void CN3SndMgr::Release()
{
	if(!m_bSndEnable) return;

	CN3SndObj* pObj = nullptr;
	itm_Snd it = m_SndObjSrcs.begin(), itEnd = m_SndObjSrcs.end();
	for(; it != itEnd; it++)
	{
		pObj = it->second;
		if(pObj) delete pObj;
	}
	m_SndObjSrcs.clear();

	itl_Snd it2 = m_SndObjs_Duplicated.begin(), itEnd2 = m_SndObjs_Duplicated.end();
	for(; it2 != itEnd2; it2++)
	{
		pObj = *it2;
		if(pObj) delete pObj;
	}
	m_SndObjs_Duplicated.clear();

	it2 = m_SndObjs_PlayOnceAndRelease.begin();
	itEnd2 = m_SndObjs_PlayOnceAndRelease.end();
	for(; it2 != itEnd2; it2++)
	{
		pObj = *it2;
		if(pObj) delete pObj;
	}
	m_SndObjs_PlayOnceAndRelease.clear();

	CN3SndObjStream* pObj2 = nullptr;
	itl_SndStream it3 = m_SndObjStreams.begin(), itEnd3 = m_SndObjStreams.end();
	for(; it3 != itEnd3; it3++)
	{
		pObj2 = *it3;
		if(pObj2) delete pObj2;
	}
	m_SndObjStreams.clear();

	CN3SndObj::StaticRelease();
}


// 이 함수는 한번 플레이 하고 그 포인터를 다시 쓸수있게 ReleaseObj를 호출한다.
// 대신 위치는 처음 한번밖에 지정할 수 없다.
bool CN3SndMgr::PlayOnceAndRelease(int iSndID, const __Vector3* pPos)
{
	if (!m_bSndEnable)
		return false;

	if (!CN3Base::s_Options.bSndEffectEnable)
		return false;

	TABLE_SOUND* pTbl = m_Tbl_Source.Find(iSndID);
	if(pTbl==nullptr || pTbl->szFN.empty()) return false;
	
	CN3SndObj* pObjSrc = nullptr;
	itm_Snd it = m_SndObjSrcs.find(pTbl->szFN);
	if(it == m_SndObjSrcs.end()) // 못 찾았다... 새로 만들자..
	{
		pObjSrc = new CN3SndObj();
		if(false == pObjSrc->Create(pTbl->szFN, (e_SndType)pTbl->iType)) // 새로 로딩..
		{
			delete pObjSrc; pObjSrc = nullptr;
			return false;
		}
		m_SndObjSrcs.insert(val_Snd(pTbl->szFN, pObjSrc)); // 맵에 추가한다..
		if(!m_bSndDuplicated) pObjSrc->Play(pPos);//this_Snd
	}
	else pObjSrc = it->second;

	if(nullptr == pObjSrc) return false;

	if(!m_bSndDuplicated)
	{
		pObjSrc->Play(pPos); //this_Snd
		return true;
	}

	CN3SndObj* pObj = new CN3SndObj();
	if(false == pObj->Duplicate(pObjSrc, (e_SndType)pTbl->iType)) // Duplicate 처리..
	{
		delete pObj; pObj = nullptr;
		return false;
	}
	
	if(pObj) // 리스트에 넣는다...noah
	{
		m_SndObjs_PlayOnceAndRelease.push_back(pObj);
		pObj->Play(pPos);
		return true;
	}
	return false;
/*
	CN3SndObj* pObj = new CN3SndObj();
	if(false == pObj->Create(pTbl->szFN, (e_SndType)pTbl->iType))
	{
		delete pObj; pObj = nullptr;
		return false;
	}
	pObj->Play(pPos);
	m_SndObjs_PlayOnceAndRelease.push_back(pObj);
	return true;
*/
}

bool CN3SndMgr::PreprocessFilename(std::string& szFN)
{
	// Expect an extension (.mp3, .wav)
	if (szFN.length() < 4)
		return false;

	// Officially it has native support for MP3 decoding.
	// We decode back to WAV (one-time) and use the new filename instead.
	// Ideally this would just load it into memory directly, but that would require restructuring
	// a little.
	// This approach is fairly unintrusive and only incurs the performance hit once.
	// There's also very few mp3 files to actually convert, so space should not be an issue.
	// Finally, the game requires admin access, so it should have write access.
	if (_stricmp(&szFN[szFN.length() - 4], ".mp3") == 0)
	{
		if (!DecodeMp3ToWav(szFN))
			return false;
	}

	return true;
}

bool CN3SndMgr::DecodeMp3ToWav(std::string& filename)
{
	// We've seen this MP3 before. Replace its filename.
	auto itr = m_mp3ToWavFileMap.find(filename);
	if (itr != m_mp3ToWavFileMap.end())
	{
		filename = itr->second;
		return true;
	}

	PWSTR path = {};
	HRESULT hr = SHGetKnownFolderPath(FOLDERID_LocalAppData, 0, nullptr, &path);
	if (FAILED(hr))
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to fetch LocalAppData directory: {:X}", hr);
#endif
		return false;
	}

	std::error_code fsErrorCode = {};

	std::wstring audioDir = path;
	CoTaskMemFree(path);
	audioDir += L"\\OpenKO\\Snd";

	std::filesystem::path newPath(audioDir);
	std::filesystem::create_directories(newPath, fsErrorCode);
		
	std::filesystem::path oldPath(filename);
	newPath /= oldPath.filename();
	newPath.replace_extension(".wav");

	// If we've already converted this file, we can just use it immediately.
	if (std::filesystem::exists(newPath, fsErrorCode))
	{
		std::string newFilename = newPath.string();
		m_mp3ToWavFileMap.insert(std::make_pair(filename, newFilename));
		filename = std::move(newFilename);
		return true;
	}

	// We have yet to convert it, so we need to load it up and decode it.
	int error = MPG123_ERR;

	mpg123_handle* mpgHandle = mpg123_new(nullptr, &error);
	if (mpgHandle == nullptr)
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to allocate MP3 handle: {} ({})",
			filename, error);
#endif
		return false;
	}

	// Force output as 16-bit PCM - preserve sample rate and channel count.
	mpg123_format(mpgHandle, 0, 0, MPG123_ENC_SIGNED_16);

	error = mpg123_open(mpgHandle, filename.c_str());
	if (error != MPG123_OK)
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to open MP3: {} ({})",
			filename, error);
#endif
		mpg123_delete(mpgHandle);
		return false;
	}

	long rate = 0;
	int channels = 0, encoding = 0;

	error = mpg123_getformat(mpgHandle, &rate, &channels, &encoding);
	if (error != MPG123_OK)
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to get MP3 format: {} ({}: {})",
			filename, error, mpg123_strerror(mpgHandle));
#endif

		mpg123_delete(mpgHandle);
		return false;
	}

	off_t sampleCount = mpg123_length(mpgHandle);
	if (sampleCount < 0)
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to get total MP3 samples per channel: {}",
			filename);
#endif

		mpg123_delete(mpgHandle);
		return false;
	}

	std::string newFilename = newPath.string();

	// Open the new WAV file for writing.
	FILE* fp = fopen(newFilename.c_str(), "wb");
	if (fp == nullptr)
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to open file for writing decoded MP3 to: {}",
			newFilename);
#endif
		return false;
	}

	const int sampleSizeBytes = mpg123_encsize(encoding);

	// Initialise header to defaults
	WavFileHeader wavFileHeader = {};

	// Setup the file header.
	wavFileHeader.Format.AudioFormat	= 1; // PCM
	wavFileHeader.Format.NumChannels	= static_cast<uint16_t>(channels);
	wavFileHeader.Format.SampleRate		= static_cast<uint16_t>(rate);
	wavFileHeader.Format.BitsPerSample	= static_cast<uint16_t>(sampleSizeBytes * 8);
	wavFileHeader.Format.BytesPerBlock	= wavFileHeader.Format.NumChannels * wavFileHeader.Format.BitsPerSample / 8;
	wavFileHeader.Format.BytesPerSec	= wavFileHeader.Format.SampleRate * wavFileHeader.Format.BytesPerBlock;

	size_t done = 0, decodedBytes = 0;
	const size_t frameSize = mpg123_outblock(mpgHandle);
	std::vector<uint8_t> frameBlock(frameSize);

	// Skip the header - we'll write that at the end.
	fseek(fp, sizeof(WavFileHeader), SEEK_SET);

	error = mpg123_read(mpgHandle, &frameBlock[0], frameSize, &done);
	while (error == MPG123_OK)
	{
		decodedBytes += done;

		fwrite(&frameBlock[0], done, 1, fp);
		error = mpg123_read(mpgHandle, &frameBlock[0], frameSize, &done);
	}

	mpg123_delete(mpgHandle);

	if (error != MPG123_DONE)
	{
		fclose(fp);
		std::remove(newFilename.c_str());

#ifdef _N3GAME
		CLogWriter::Write("Failed to decode MP3: {} ({} - decoded {} bytes)",
			filename, error, decodedBytes);
#endif
		return false;
	}

	wavFileHeader.FileSize += static_cast<uint32_t>(decodedBytes);
	wavFileHeader.Data.Size = static_cast<uint32_t>(decodedBytes);

	// Write out the header.
	long endOfFileOffset = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	fwrite(&wavFileHeader, sizeof(WavFileHeader), 1, fp);

	// Seek back to the known end, before the file is closed and flushed.
	fseek(fp, endOfFileOffset, SEEK_SET);
	fclose(fp);

	m_mp3ToWavFileMap.insert(std::make_pair(filename, newFilename));
	filename = std::move(newFilename);

	return true;
}

// ===== END N3Base/N3SndMgr.cpp =====

// ===== BEGIN N3Base/N3SndMgr.h =====
#line 1 "N3Base/N3SndMgr.h"
﻿// N3SndMgr.h: interface for the CN3SndMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SNDMGR_H__9CB531B0_4FEB_4360_8141_D0BF61347BD7__INCLUDED_)
#define AFX_N3SNDMGR_H__9CB531B0_4FEB_4360_8141_D0BF61347BD7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3SndDef.h"
#include "N3TableBase.h"

#include <list>
#include <map>
#include <unordered_map>

class CN3SndObj;
class CN3SndObjStream;

typedef std::list<CN3SndObj*>::iterator itl_Snd;
typedef std::list<CN3SndObjStream*>::iterator itl_SndStream;
typedef std::map<std::string, CN3SndObj*>::iterator itm_Snd;
typedef std::map<std::string, CN3SndObj*>::value_type val_Snd;

class CN3SndMgr
{
protected:
	CN3TableBase<__TABLE_SOUND>			m_Tbl_Source; // 사운드 소스 정보 테이블..

	bool								m_bSndEnable;
	bool								m_bSndDuplicated;
	std::map<std::string, CN3SndObj*>	m_SndObjSrcs;
	std::list<CN3SndObjStream*>			m_SndObjStreams;	// 스트리밍 사운드..
	std::list<CN3SndObj*>				m_SndObjs_Duplicated;
	std::list<CN3SndObj*>				m_SndObjs_PlayOnceAndRelease;	// 한번만 플레이 하고 릴리즈 해야 하는 사운드들
	std::unordered_map<std::string, std::string> m_mp3ToWavFileMap;
	
public:
	void		ReleaseObj(CN3SndObj** ppObj);
	void		ReleaseStreamObj(CN3SndObjStream** ppObj);
//	void		DeleteObjWithSource(CN3SndObj* pObj);
//	CN3SndObj*	GetObj(int iID);
	bool		PlayOnceAndRelease(int iSndID, const __Vector3* pPos = nullptr);
		
	void		SetDuplicated(bool bDuplicate) { m_bSndDuplicated = bDuplicate; }
	bool		GetDuplicated() { return m_bSndDuplicated; }
	void		SetEnable(bool bEnable) { m_bSndEnable = bEnable; }
	void		Init(HWND hWnd);
	void		Release();
	void		Tick();	

	CN3SndObj*			CreateObj(std::string szFN, e_SndType eType = SNDTYPE_3D);
	CN3SndObj*			CreateObj(int iID, e_SndType eType = SNDTYPE_3D);
	CN3SndObjStream*	CreateStreamObj(std::string szFN);
	CN3SndObjStream*	CreateStreamObj(int iID);

	CN3SndMgr();
	virtual ~CN3SndMgr();

private:
	bool PreprocessFilename(std::string& filename);
	bool DecodeMp3ToWav(std::string& filename);
};

#endif // !defined(AFX_N3SNDMGR_H__9CB531B0_4FEB_4360_8141_D0BF61347BD7__INCLUDED_)

// ===== END N3Base/N3SndMgr.h =====

// ===== BEGIN N3Base/N3SndObj.cpp =====
#line 1 "N3Base/N3SndObj.cpp"
﻿// N3SndObj.cpp: implementation of the CN3SndObj class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3SndObj.h"
#include "N3Base.h"
#include <math.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
LPDIRECTSOUND				CN3SndObj::s_lpDS = nullptr;
LPDIRECTSOUND3DLISTENER		CN3SndObj::s_lpDSListener = nullptr;		// 3D listener object
DS3DLISTENER				CN3SndObj::s_dsListenerParams;			// Listener properties
bool						CN3SndObj::s_bNeedDeferredTick = false;	// 3D Listener CommitDeferredSetting

CN3SndObj::CN3SndObj()
{
	m_lpDSBuff = nullptr;
	m_lpDS3DBuff = nullptr;
	m_bIsLoop = false;
	m_iVol = -1;
	m_szFileName = "";

	m_fFadeInTime = 0;
	m_fFadeOutTime = 0;
	m_fStartDelayTime = 0;
	m_fTmpSecPerFrm = 0;
	m_ePlayState = SNDSTATE_STOP;

	m_iMaxVolume = 100;
}

CN3SndObj::~CN3SndObj()
{
	Release();
}


//
//	Initialize....
//
void CN3SndObj::Init()
{
	Release();

	m_bIsLoop = false;
	m_iVol = -1;
	m_szFileName = "";

	m_fStartDelayTime = 0;
	m_fTmpSecPerFrm = 0;
	m_ePlayState = SNDSTATE_STOP;
	m_fFadeInTime = 0;
	m_fFadeOutTime = 0;

	m_iMaxVolume = 100;
}


//
//	Release...
//
void CN3SndObj::Release()
{
	if(m_lpDS3DBuff)
	{
		m_lpDS3DBuff->Release();
		m_lpDS3DBuff = nullptr;
	}	

	if(m_lpDSBuff)
	{
		m_lpDSBuff->Stop();
		m_lpDSBuff->Release();
		m_lpDSBuff = nullptr;
	}
}

bool CN3SndObj::StaticInit( HWND  hWnd, DWORD dwCoopLevel, DWORD dwPrimaryChannels, DWORD dwPrimaryFreq, DWORD dwPrimaryBitRate )
{
    HRESULT hr;
    LPDIRECTSOUNDBUFFER lpDSBPrimary = nullptr;

	if(s_lpDS)
	{
		s_lpDS->Release();
		s_lpDS = nullptr;
	}

    // Create IDirectSound using the primary sound device
    if( FAILED( hr = DirectSoundCreate( nullptr, &s_lpDS, nullptr ) ) )
        return false;

    // Set DirectSound coop level 
    if( FAILED( hr = s_lpDS->SetCooperativeLevel( hWnd, dwCoopLevel ) ) )
        return false;
    
    // Set primary buffer format
    // Get the primary buffer 
    DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );
    dsbd.dwSize        = sizeof(DSBUFFERDESC);
    dsbd.dwFlags       = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE;
    dsbd.dwBufferBytes = 0;
    dsbd.lpwfxFormat   = nullptr;
    if( FAILED( hr = s_lpDS->CreateSoundBuffer( &dsbd, &lpDSBPrimary, nullptr ) ) ) return false;

    WAVEFORMATEX wfx;
    ZeroMemory( &wfx, sizeof(WAVEFORMATEX) ); 
    wfx.wFormatTag      = WAVE_FORMAT_PCM; 
    wfx.nChannels       = (uint16_t) dwPrimaryChannels; 
    wfx.nSamplesPerSec  = dwPrimaryFreq; 
    wfx.wBitsPerSample  = (uint16_t) dwPrimaryBitRate; 
    wfx.nBlockAlign     = wfx.wBitsPerSample / 8 * wfx.nChannels;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    if( FAILED( hr = lpDSBPrimary->SetFormat(&wfx) ) ) return false;

	if(lpDSBPrimary)
	{
		lpDSBPrimary->Release();
		lpDSBPrimary = nullptr;
	}


	// Create listener
    // Obtain primary buffer, asking it for 3D control
    ZeroMemory( &dsbd, sizeof(dsbd) );
    dsbd.dwSize = sizeof(DSBUFFERDESC);
    dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_CTRL3D;
    if( FAILED( hr = s_lpDS->CreateSoundBuffer( &dsbd, &lpDSBPrimary, nullptr ) ) )
        return false;

    if( FAILED( hr = lpDSBPrimary->QueryInterface( IID_IDirectSound3DListener, (VOID**)(&s_lpDSListener) ) ) )
    {
       if(lpDSBPrimary)
	   {
		   lpDSBPrimary->Release();
		   lpDSBPrimary = nullptr;
	   }		   
	   return false;
    }

    if(lpDSBPrimary)
	{
		lpDSBPrimary->Release();
		lpDSBPrimary = nullptr;
	}

	// Set listener 
	s_dsListenerParams.dwSize = sizeof(DS3DLISTENER);
	s_lpDSListener->GetAllParameters( &s_dsListenerParams );
	s_lpDSListener->SetRolloffFactor( DS3D_DEFAULTROLLOFFFACTOR/2, DS3D_IMMEDIATE);
	s_lpDSListener->SetDopplerFactor(0, DS3D_DEFERRED);
	
	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
    return true;
}

void CN3SndObj::StaticRelease()
{
	if(s_lpDSListener)
	{
		s_lpDSListener->Release();
		s_lpDSListener = nullptr;
	}
	if(s_lpDS)
	{
		s_lpDS->Release();
		s_lpDS = nullptr;
	}

	s_bNeedDeferredTick = false;	// 3D Listener CommitDeferredSetting
}

void CN3SndObj::StaticTick()
{
	if(false == s_bNeedDeferredTick) return;
	// 3D Listener CommitDeferredSetting

	s_lpDSListener->CommitDeferredSettings();
	s_bNeedDeferredTick = false;
}

bool CN3SndObj::Create(const std::string& szFN, e_SndType eType)
{
	if(nullptr == s_lpDS) return false;
	if(SNDTYPE_2D != eType && SNDTYPE_3D != eType) return false;
	if(m_lpDSBuff) this->Init();

	CWaveFile	WaveFile;
	HRESULT hr = WaveFile.Open(szFN.c_str(), nullptr, 1);	//#define WAVEFILE_READ   1
	if(FAILED(hr))
	{
#ifdef _N3GAME
		if (!szFN.empty())
			CLogWriter::Write("CN3SndObj::Create - WaveFile Open Failed.. ({})", szFN);
#endif
		return false;
	}

	DSBUFFERDESC dsbd;
    ZeroMemory( &dsbd, sizeof(DSBUFFERDESC) );
    dsbd.dwSize          = sizeof(DSBUFFERDESC);
	dsbd.dwBufferBytes   = WaveFile.GetSize();
	dsbd.lpwfxFormat     = WaveFile.m_pwfx;

	if(SNDTYPE_2D == eType) // 2D 음원
	{
		dsbd.dwFlags		 = DSBCAPS_CTRLVOLUME; // | DSBCAPS_STATIC;
	}
	else if(SNDTYPE_3D == eType)	//3D 음원..
	{
		dsbd.dwFlags         = DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE; // | DSBCAPS_STATIC;
		dsbd.guid3DAlgorithm = DS3DALG_HRTF_LIGHT;
	}

	hr = s_lpDS->CreateSoundBuffer( &dsbd, &m_lpDSBuff, nullptr );
	if(FAILED(hr))
	{
#ifdef _N3GAME
		CLogWriter::Write("CN3SndObj::Create - CreateSoundBuffer Failed.. ({})", szFN);
#endif
		return false;
	}

    if(!FillBufferWithSound(&WaveFile))
	{
#ifdef _N3GAME
		CLogWriter::Write("CN3SndObj::Create - FillBufferWithSound Failed.. ({})", szFN);
#endif
		return false;
	}

	m_lpDSBuff->SetCurrentPosition(0);
	if(SNDTYPE_3D == eType)	//3D 음원..
		if(S_OK != m_lpDSBuff->QueryInterface(IID_IDirectSound3DBuffer, (VOID**)(&m_lpDS3DBuff)))
			return false;

	m_szFileName = szFN; // 파일 이름을 기록한다..

	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
	return true;
}

bool CN3SndObj::Duplicate(CN3SndObj* pSrc, e_SndType eType, __Vector3* pPos)
{
	if(nullptr == s_lpDS || nullptr == pSrc || nullptr == pSrc->m_lpDSBuff)
		return false;
	if(m_lpDSBuff) this->Init();

	HRESULT hr = 0;
	if(DS_OK != s_lpDS->DuplicateSoundBuffer(pSrc->m_lpDSBuff, &(m_lpDSBuff)))
		return false;
	
	m_lpDSBuff->SetCurrentPosition(0);
	if(SNDTYPE_3D == eType)
	{
		if(S_OK != m_lpDSBuff->QueryInterface( IID_IDirectSound3DBuffer, (VOID**)(&m_lpDS3DBuff)))
			return false;
		
		/*
		if(pSrc->m_lpDS3DBuff)
		{
			DS3DBUFFER BuffParam;
			BuffParam.dwSize = sizeof(DS3DBUFFER);
			hr = pSrc->m_lpDS3DBuff->GetAllParameters(&BuffParam);
		  	hr = m_lpDS3DBuff->SetAllParameters(&BuffParam, DS3D_DEFERRED);			
		}
		*/

		if (pPos != nullptr)
			SetPos(pPos);
		SetMaxDistance(100);
		
		__Vector3 vDir = { 0.0f, 1.0f, 0.0f };
		SetConeOrientation(&vDir);
	}

	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
	m_szFileName = pSrc->m_szFileName;
	return true;
}

bool CN3SndObj::FillBufferWithSound(CWaveFile* pWaveFile)
{
    if( nullptr == m_lpDSBuff || nullptr == pWaveFile )
		return false; // 포인터들 점검..
	
    HRESULT hr; 
    VOID*   pDSLockedBuffer      = nullptr; // Pointer to locked buffer memory
    DWORD   dwDSLockedBufferSize = 0;    // Size of the locked DirectSound buffer
    DWORD   dwWavDataRead        = 0;    // Amount of data read from the wav file 

	DSBCAPS dsbc; dsbc.dwSize = sizeof(dsbc);
	m_lpDSBuff->GetCaps(&dsbc);
	if(dsbc.dwBufferBytes != pWaveFile->GetSize())
		return false; // 사이즈 점검..

	if (!RestoreBuffer())
		return false;

    // Lock the buffer down
	if( FAILED( hr = m_lpDSBuff->Lock( 0, dsbc.dwBufferBytes, &pDSLockedBuffer, &dwDSLockedBufferSize, nullptr, nullptr, 0L ) ) )
        return false;

	pWaveFile->ResetFile();

    if( FAILED( hr = pWaveFile->Read( (uint8_t*) pDSLockedBuffer, dwDSLockedBufferSize, &dwWavDataRead ) ) )
		return false;

    if( dwWavDataRead == 0 )
    {
        // Wav is blank, so just fill with silence
        FillMemory( (uint8_t*) pDSLockedBuffer, dwDSLockedBufferSize, (uint8_t)(pWaveFile->m_pwfx->wBitsPerSample == 8 ? 128 : 0 ) );
    }
    else if( dwWavDataRead < dwDSLockedBufferSize )
    {
       // just fill in silence 
        FillMemory( (uint8_t*) pDSLockedBuffer + dwWavDataRead, 
                    dwDSLockedBufferSize - dwWavDataRead, 
                    (uint8_t)(pWaveFile->m_pwfx->wBitsPerSample == 8 ? 128 : 0 ) );
    }

    // Unlock the buffer, we don't need it anymore.
    m_lpDSBuff->Unlock( pDSLockedBuffer, dwDSLockedBufferSize, nullptr, 0 );

    return true;
}

bool CN3SndObj::RestoreBuffer()
{
    if( nullptr == m_lpDSBuff ) return false;

    HRESULT hr;
    DWORD dwStatus;
    if( FAILED( hr = m_lpDSBuff->GetStatus( &dwStatus ) ) )
        return false;

    if( dwStatus & DSBSTATUS_BUFFERLOST )
    {
        // Since the app could have just been activated, then
        // DirectSound may not be giving us control yet, so 
        // the restoring the buffer may fail.  
        // If it does, sleep until DirectSound gives us control.
		hr = m_lpDSBuff->Restore();
		while (FAILED(hr))
        {
			if (hr == DSERR_BUFFERLOST)
				Sleep(10);

			hr = m_lpDSBuff->Restore();
        }
    }

	return true;
}

//
//	SetVolume...
//	range : [0,100]
//
void CN3SndObj::SetVolume(int Vol)
{
	if(nullptr == m_lpDSBuff) return;
	if(m_lpDS3DBuff) return; // 3D Sound 일때는 소리 조절이 안된다..!!!

	m_iVol = Vol;
	if(Vol==0)
	{
		m_lpDSBuff->SetVolume(-10000);
		return;
	}

	float fVol = (float)(Vol) / 100.0f;
	long dwVol = (long)(log10(fVol) * 3000);	//데시벨 관련 소리조절식..
	m_lpDSBuff->SetVolume(dwVol);
}


//
//
//
bool CN3SndObj::IsPlaying()
{
	if(nullptr == m_lpDSBuff) return false;
	
	DWORD dwStatus = 0;
	m_lpDSBuff->GetStatus( &dwStatus );
	if(dwStatus & DSBSTATUS_PLAYING) return true;

	if(m_ePlayState != SNDSTATE_STOP) return true;
	return false;
}


//
//
//
void CN3SndObj::Tick()
{
	if(nullptr == m_lpDSBuff || m_ePlayState == SNDSTATE_STOP) return;

	m_fTmpSecPerFrm += CN3Base::s_fSecPerFrm;
	
	if(m_ePlayState==SNDSTATE_DELAY && m_fTmpSecPerFrm >= m_fStartDelayTime)
	{
		m_fTmpSecPerFrm = 0;
		m_ePlayState = SNDSTATE_FADEIN;
		RealPlay();
	}

	if(m_ePlayState==SNDSTATE_FADEIN) 
	{
		if(m_fTmpSecPerFrm >= m_fFadeInTime)
		{
			m_fTmpSecPerFrm = 0;
			m_ePlayState = SNDSTATE_PLAY;
			this->SetVolume(m_iMaxVolume);
		}
		else
		{
			int vol = 0;
			if(m_fFadeInTime>0.0f) vol = (int)((m_fTmpSecPerFrm/m_fFadeInTime)*(float)m_iMaxVolume);
			SetVolume(vol);
		}
	}

	if(m_ePlayState==SNDSTATE_PLAY)
	{
		if(!m_bIsLoop) m_ePlayState = SNDSTATE_STOP;		
	}
	if(m_ePlayState==SNDSTATE_FADEOUT)
	{
		if(m_fTmpSecPerFrm >= m_fFadeOutTime)
		{
			m_fTmpSecPerFrm = 0;
			m_ePlayState = SNDSTATE_STOP;
			this->SetVolume(0);
			HRESULT hr = m_lpDSBuff->Stop();
		}
		else
		{
			//볼륨 점점 작게....
			int vol = 0;
			if(m_fFadeOutTime>0.0f)  vol = (int)(((m_fFadeOutTime - m_fTmpSecPerFrm)/m_fFadeOutTime)*(float)m_iMaxVolume);
			SetVolume(vol);
		}
	}
}


//
//
//
void CN3SndObj::Play(const __Vector3* pvPos, float delay, float fFadeInTime, bool bImmediately)
{
	SetPos(pvPos);
	if(bImmediately) this->Stop();

	m_fFadeInTime = fFadeInTime;
	m_fFadeOutTime = 0;
	m_fStartDelayTime = delay;
	m_fTmpSecPerFrm = 0;
	m_ePlayState = SNDSTATE_DELAY;

	if(m_lpDS3DBuff) // 3D 사운드일때에는 FadeIn 등이 필요 없구.. 볼륨이 먹지 않기 때문에 리턴..
	{
		m_ePlayState = SNDSTATE_PLAY;
		if(m_lpDSBuff)
		{
			if(m_bIsLoop) m_lpDSBuff->Play(0,0,DSBPLAY_LOOPING);
			else m_lpDSBuff->Play( 0, 0, 0 );
		}
	}
}


//
//
//
void CN3SndObj::RealPlay()
{
    if(nullptr == m_lpDSBuff) return;

	DWORD dwStatus = 0;
	m_lpDSBuff->GetStatus( &dwStatus );
	if((dwStatus & DSBSTATUS_PLAYING)==DSBSTATUS_PLAYING) return;

	HRESULT hr;
	hr = m_lpDSBuff->SetCurrentPosition(0);

	if(m_bIsLoop) m_lpDSBuff->Play(0,0,DSBPLAY_LOOPING);
	else hr |= m_lpDSBuff->Play( 0, 0, 0 );

	return; 
}


//
//
//
void CN3SndObj::Stop(float fFadeOutTime)
{
	if( nullptr == m_lpDSBuff ) return;
	if( m_ePlayState == SNDSTATE_FADEOUT || m_ePlayState == SNDSTATE_STOP) return; 

	if(fFadeOutTime==0.0f)
	{
		m_fTmpSecPerFrm = 0;
		m_fFadeOutTime = fFadeOutTime;
		m_ePlayState = SNDSTATE_STOP;
		HRESULT hr = m_lpDSBuff->Stop();
		return;
	}

	m_fTmpSecPerFrm = 0;
	m_fFadeOutTime = fFadeOutTime;
	m_ePlayState = SNDSTATE_FADEOUT;
	return;
}


void CN3SndObj::SetPos(const __Vector3* pvPos)
{
    if( m_lpDS3DBuff && pvPos ) 
		HRESULT hr = m_lpDS3DBuff->SetPosition(pvPos->x, pvPos->y, pvPos->z, DS3D_IMMEDIATE );
}


//
//
//
void CN3SndObj::SetMaxDistance(D3DVALUE max)
{
	if( m_lpDS3DBuff )	m_lpDS3DBuff->SetMaxDistance(max, DS3D_IMMEDIATE);
}


//
//
//
void CN3SndObj::SetMinDistance(D3DVALUE min)
{
	if( m_lpDS3DBuff )	m_lpDS3DBuff->SetMinDistance(min, DS3D_IMMEDIATE);
}


//
//
//
void CN3SndObj::SetConeOutSizeVolume(int32_t vol)
{
	if( m_lpDS3DBuff )	m_lpDS3DBuff->SetConeOutsideVolume(vol, DS3D_IMMEDIATE);
}


//
//
//
void CN3SndObj::SetConeOrientation(__Vector3* pDir)
{
	if( m_lpDS3DBuff )	m_lpDS3DBuff->SetConeOrientation(pDir->x, pDir->y, pDir->z, DS3D_IMMEDIATE);
}



//
// static functions ....
//

void CN3SndObj::SetDopplerFactor(D3DVALUE factor)
{
	if(nullptr == s_lpDSListener) return;
	s_lpDSListener->SetDopplerFactor(factor, DS3D_DEFERRED);
	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
}

void CN3SndObj::SetListenerPos(const __Vector3* pVPos, bool IsDeferred)
{
	if(nullptr == s_lpDSListener || nullptr == pVPos) return;
	DWORD dwParam = (IsDeferred) ? DS3D_DEFERRED : DS3D_IMMEDIATE;
	s_lpDSListener->SetPosition(pVPos->x, pVPos->y, pVPos->z, dwParam);
	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
}


//
//
//
void CN3SndObj::SetListenerOrientation(const __Vector3* pVAt, const __Vector3* pVUp, bool IsDeferred)
{
	if(nullptr == s_lpDSListener || nullptr == pVAt || nullptr == pVUp) return;
	DWORD dwParam = (IsDeferred) ? DS3D_DEFERRED : DS3D_IMMEDIATE;
	s_lpDSListener->SetOrientation(pVAt->x, pVAt->y, pVAt->z, pVUp->x, pVUp->y, pVUp->z, dwParam);
	s_bNeedDeferredTick = true;	// 3D Listener CommitDeferredSetting
}

// ===== END N3Base/N3SndObj.cpp =====

// ===== BEGIN N3Base/N3SndObj.h =====
#line 1 "N3Base/N3SndObj.h"
﻿// N3SndObj.h: interface for the CN3SndObj class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SndObj_H__64BCBFD5_FD77_438D_9BF4_DC9B7C5D5BB9__INCLUDED_)
#define AFX_N3SndObj_H__64BCBFD5_FD77_438D_9BF4_DC9B7C5D5BB9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3SndDef.h"
#include <stdio.h>
#include <string>

class CN3SndObj
{
protected:
	static LPDIRECTSOUND			s_lpDS;
	static LPDIRECTSOUND3DLISTENER	s_lpDSListener;			// 3D listener object
	static DS3DLISTENER				s_dsListenerParams;		// Listener properties
	static bool						s_bNeedDeferredTick;	// 3D Listener CommitDeferredSetting

	LPDIRECTSOUNDBUFFER		m_lpDSBuff;
	LPDIRECTSOUND3DBUFFER	m_lpDS3DBuff;			// 3D sound buffer
	bool					m_bIsLoop;
	int						m_iVol;
	int						m_iMaxVolume;
	e_SndState				m_ePlayState;
	
	float					m_fFadeInTime;
	float					m_fFadeOutTime;
	float					m_fStartDelayTime;
	float					m_fTmpSecPerFrm;

public:
	std::string				m_szFileName;	//파일이름...(ID 대용).
	

protected:
	virtual void RealPlay();
	bool	FillBufferWithSound(class CWaveFile* pWaveFile);
	bool	RestoreBuffer();

		
public:
	static bool StaticInit( HWND hWnd, DWORD dwCoopLevel = DSSCL_PRIORITY, DWORD dwPrimaryChannels = 2, DWORD dwPrimaryFreq = 22050, DWORD dwPrimaryBitRate = 16 );
	static void StaticRelease();
	static void StaticTick();
	static void SetDopplerFactor(D3DVALUE factor);
	static void SetListenerPos(const __Vector3* pVPos, bool IsDeferred = true);
	static void SetListenerOrientation(const __Vector3* pVAt, const __Vector3* pVUp, bool IsDeferred = true);

	LPDIRECTSOUNDBUFFER		GetDSBuffer() { return m_lpDSBuff; }
	LPDIRECTSOUND3DBUFFER	GetDS3DBuffer() { return m_lpDS3DBuff; }

	bool		IsPlaying();

	void	Looping(bool loop) { m_bIsLoop = loop; }
	bool	IsLoop() { return m_bIsLoop; }
	
	int		GetVolume() { return m_iVol; }
	void	SetVolume(int Vol);	// range : [0,100]

	void	SetMaxVolume(int vol) { m_iMaxVolume = vol; }
	int		GetMaxVolume() { return m_iMaxVolume; }

	void	Init();
	void	Release(); // 참조 카운트를 리턴 해준다.. 사운드 매니저에서는 이 참조 카운트를 보고 맵에서 지운다..
	virtual bool Create(const std::string& szFN, e_SndType eType);
	bool	Duplicate(CN3SndObj* pSrc, e_SndType eType, __Vector3* pPos = nullptr);

	void	Play(const __Vector3* pvPos = nullptr, float delay = 0.0f, float fFadeInTime = 0.0f, bool bImmediately = true);
	void	Stop(float fFadeOutTime = 0.0f);
	void	Tick();

	void	SetConeOrientation(__Vector3* pDir);
	void	SetConeOutSizeVolume(int32_t vol);
	void	SetMaxDistance(D3DVALUE max);
	void	SetMinDistance(D3DVALUE min);	
	void	SetPos(const __Vector3* pvPos);

	CN3SndObj();
	virtual ~CN3SndObj();
};

#endif // !defined(AFX_N3SndObj_H__64BCBFD5_FD77_438D_9BF4_DC9B7C5D5BB9__INCLUDED_)

// ===== END N3Base/N3SndObj.h =====

// ===== BEGIN N3Base/N3SndObjStream.cpp =====
#line 1 "N3Base/N3SndObjStream.cpp"
﻿//////////////////////////////////////////////////
//	Commented By : Lynus
//	Commented On 2001-04-12 오후 8:42:02
//
//	CN3SndObjStream class (N3SndObjStream.h)
//
//	End Of Comment (By Lynus On 2001-04-12 오후 8:42:02 )
//////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3SndObjStream.h"
#include "N3SndMgr.h"
#include "N3Base.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3SndObjStream::CN3SndObjStream()
{
	m_WaveSize = 0;
	
	m_CurrState = 0;
	m_CurrPos = 0;
	m_PrevState = 0;

	hMMIO = nullptr;
	m_hWaveMem = nullptr;
	m_pWaveMem = nullptr;
}

CN3SndObjStream::~CN3SndObjStream()
{
	Release();
}

bool CN3SndObjStream::Create(const std::string& szFN, e_SndType eType)
{
	Release();

	if(nullptr == s_lpDS) return false;
	if(SNDTYPE_STREAM != eType) return false;
	if(!LoadWave(szFN.c_str())) return false;

	m_szFileName = szFN;

	uint32_t nBlockAlign = m_WaveFormat.nBlockAlign;
	uint32_t BlockPerSec = m_WaveFormat.nSamplesPerSec * nBlockAlign; 

	m_PlayTime = m_PastTime = m_WaveSize/BlockPerSec;
	m_FinalByte = m_WaveSize%BlockPerSec;

	m_BlockSize = BlockPerSec;
	m_BufferSize = m_BlockSize*2;

	ZeroMemory(&m_dsbd, sizeof(m_dsbd));
	m_dsbd.dwSize = sizeof(DSBUFFERDESC);
    m_dsbd.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLVOLUME;
	m_dsbd.dwBufferBytes = m_BufferSize;
	m_dsbd.lpwfxFormat = &m_WaveFormat;

	if(m_lpDSBuff) m_lpDSBuff->Release();

	HRESULT	hResult;
	hResult = s_lpDS->CreateSoundBuffer(&m_dsbd, &m_lpDSBuff, nullptr);
	if(FAILED(hResult)) return false;

	m_hWaveMem = ::GlobalAlloc(GHND, m_BlockSize);

	InitWriteBuffer();

	m_ePlayState = SNDSTATE_STOP;

	return true;
}


BOOL CN3SndObjStream::LoadWave(LPCSTR pFileName)
{
	hMMIO = mmioOpen((LPSTR)pFileName,nullptr,MMIO_READ|MMIO_ALLOCBUF);
	if(hMMIO==nullptr) return FALSE;

	mmCkInfoRIFF.fccType = mmioFOURCC('W','A','V','E');

	MMRESULT mmResult;
	mmResult = mmioDescend(hMMIO, &mmCkInfoRIFF, nullptr, MMIO_FINDRIFF);
	if(mmResult != MMSYSERR_NOERROR) return FALSE;

	mmCkInfoChunk.ckid = mmioFOURCC('f','m','t',' ');

	mmResult = mmioDescend(hMMIO, &mmCkInfoChunk, &mmCkInfoRIFF, MMIO_FINDCHUNK);
	if(mmResult != MMSYSERR_NOERROR) return FALSE;

	if(mmioRead(hMMIO, (LPSTR)&m_WaveFormat,sizeof(WAVEFORMATEX))==-1) 
		return FALSE;

	mmResult = mmioAscend(hMMIO, &mmCkInfoChunk,0);
	if(mmResult != MMSYSERR_NOERROR) return FALSE;

	mmCkInfoChunk.ckid = mmioFOURCC('d','a','t','a');
	mmResult = mmioDescend(hMMIO, &mmCkInfoChunk, &mmCkInfoRIFF, MMIO_FINDCHUNK);
	if(mmResult != MMSYSERR_NOERROR) return FALSE;

	m_WaveSize = mmCkInfoChunk.cksize;
	return TRUE;
}

BOOL CN3SndObjStream::InitWriteBuffer()
{	
	LPVOID	pSoundBlock1 = nullptr;
	LPVOID	pSoundBlock2 = nullptr;
	DWORD	byteSoundBlock1 = 0;
	DWORD	byteSoundBlock2 = 0;
	DWORD	Offset = 0;
	
	HRESULT hResult;
	//ReadStream();
	
	hResult = m_lpDSBuff->Lock(Offset,m_BlockSize*2,&pSoundBlock1,&byteSoundBlock1,
							&pSoundBlock2,&byteSoundBlock2,0);
	if(FAILED(hResult)) return FALSE;

	if(mmioRead(hMMIO, (LPSTR)pSoundBlock1, m_BlockSize*2)==-1) return FALSE;

	m_lpDSBuff->Unlock(pSoundBlock1,byteSoundBlock1,pSoundBlock2,byteSoundBlock2);

	return TRUE;
}

BOOL CN3SndObjStream::WriteBuffer()
{	
	LPVOID	pSoundBlock1 = nullptr;
	LPVOID	pSoundBlock2 = nullptr;
	DWORD	byteSoundBlock1 = 0;
	DWORD	byteSoundBlock2 = 0;
	DWORD	Offset;
	
	HRESULT hResult;
	//ReadStream();
	//if(m_CurrState==0) Offset = 2*m_BlockSize; 
	//else Offset = (m_CurrState-1)*m_BlockSize;
	if(m_CurrState==0) Offset = m_BlockSize; 
	else Offset = (m_CurrState-1)*m_BlockSize;
	
	hResult = m_lpDSBuff->Lock(Offset,m_BlockSize,&pSoundBlock1,&byteSoundBlock1,
							&pSoundBlock2,&byteSoundBlock2,0);
	if(FAILED(hResult)) return FALSE;

	if(m_PastTime>=2)
	{
		if(mmioRead(hMMIO, (LPSTR)pSoundBlock1, m_BlockSize)==-1) return FALSE;
	}
	else 
	{
		FillMemory((LPSTR)pSoundBlock1, m_BlockSize, (uint8_t)(m_WaveFormat.wBitsPerSample == 8 ? 128:0));
		if(m_PastTime==1)
		{
			//mmioSeek(hMMIO, m_FinalByte, SEEK_END);
			mmioRead(hMMIO, (LPSTR)pSoundBlock1, m_FinalByte);
		}
	}

	m_lpDSBuff->Unlock(pSoundBlock1,byteSoundBlock1,pSoundBlock2,byteSoundBlock2);

	return TRUE;
}

void CN3SndObjStream::RealPlay()
{
//^^	if(m_PlayState==0) Reset();

//^^	m_ePlayState = SNDSTATE_PLAY;
	
	if(m_lpDSBuff)
	{
		if(m_ePlayState==SNDSTATE_DELAY)
		{
			m_lpDSBuff->SetCurrentPosition(0);
			m_lpDSBuff->Play(0,0,DSBPLAY_LOOPING);			
		}

		m_lpDSBuff->GetCurrentPosition(&m_CurrPos,nullptr);
		m_PrevState = m_CurrState;
		m_CurrState = m_CurrPos/m_BlockSize;
		if(m_CurrState != m_PrevState)
		{
			m_PastTime--;
			if(m_PastTime<0)
			{
				if(m_bIsLoop==false)
				{
					//tick에 어케 적용할 것인가..
					m_PastTime = m_PlayTime;
					Stop();
					return;
				}
				else if(m_bIsLoop==true)
				{
					//tick에 어케 적용할 것인가..
					//Stop();
					//m_lpDSBuff->Stop();
					Play();
					return;
				}				
			}
			WriteBuffer();
		}
	}
}

void CN3SndObjStream::Reset()
{
	m_PastTime = m_PlayTime;
	mmioSeek(hMMIO, 44, SEEK_SET);

	m_CurrPos = 0;
	m_CurrState = 0;
	InitWriteBuffer();
}

void CN3SndObjStream::Release()
{
	m_fTmpSecPerFrm = 0;
	if(m_lpDSBuff) HRESULT hr = m_lpDSBuff->Stop();
	m_fFadeOutTime = 0;
	m_ePlayState = SNDSTATE_STOP;

	CN3SndObj::Release();

	if(hMMIO) 
	{
		mmioClose(hMMIO,0);
		hMMIO = nullptr;
	}
	if(m_hWaveMem)
	{
		::GlobalFree(m_hWaveMem);
		m_hWaveMem = nullptr;
	}
}


//
//	음악이 플레이되고 있을때 streamming시키기..
//
void CN3SndObjStream::Tick()
{
	if(m_ePlayState == SNDSTATE_STOP) return;

	m_fTmpSecPerFrm += CN3Base::s_fSecPerFrm;
	
	if(m_ePlayState==SNDSTATE_DELAY && m_fTmpSecPerFrm >= m_fStartDelayTime)
	{
		m_fTmpSecPerFrm = 0;
		Reset();
		RealPlay();
		m_ePlayState = SNDSTATE_FADEIN;		
	}

	if(m_ePlayState==SNDSTATE_FADEIN) 
	{
		if(m_fTmpSecPerFrm >= m_fFadeInTime)
		{
			m_fTmpSecPerFrm = 0;
			m_ePlayState = SNDSTATE_PLAY;
			SetVolume(m_iMaxVolume);
		}
		else
		{
			int vol = 0;			
			if(m_fFadeInTime>0.0f) vol = (int)((m_fTmpSecPerFrm/m_fFadeInTime)*(float)m_iMaxVolume);
			SetVolume(vol);
		}
		RealPlay();
	}

	if(m_ePlayState==SNDSTATE_PLAY)
	{
		RealPlay();
	}
	if(m_ePlayState==SNDSTATE_FADEOUT)
	{
		if(m_fTmpSecPerFrm >= m_fFadeOutTime || m_PastTime<0)
		{
			m_fTmpSecPerFrm = 0;
			SetVolume(0);

			HRESULT hr = m_lpDSBuff->Stop();
			m_ePlayState = SNDSTATE_STOP;
		}
		else
		{
			//볼륨 점점 작게....
			int vol = 0;
			if(m_fFadeOutTime>0.0f)  vol = (int)(((m_fFadeOutTime - m_fTmpSecPerFrm)/m_fFadeOutTime)*(float)m_iMaxVolume);
			SetVolume(vol);
			RealPlay();
		}
	}
}

/*
//
// 똑같다.
//
void CN3SndObjStream::Play(float delay, float fFadeInTime)
{
	m_fFadeInTime = fFadeInTime;
	m_fFadeOutTime = 0.0f;
	m_fStartDelayTime = delay;
	m_fTmpSecPerFrm = 0.0f;
	m_ePlayState = SNDSTATE_DELAY;
}


//
// 똑같다.
//
void CN3SndObjStream::Stop(float fFadeOutTime)
{
	if( m_lpDSBuff == nullptr ) return;

	m_fTmpSecPerFrm = 0;
	m_fFadeOutTime = fFadeOutTime;
	m_ePlayState = SNDSTATE_FADEOUT;
	return;
}
*/
// end of N3SndObjStream.cpp

// ===== END N3Base/N3SndObjStream.cpp =====

// ===== BEGIN N3Base/N3SndObjStream.h =====
#line 1 "N3Base/N3SndObjStream.h"
﻿//////////////////////////////////////////////////
//	Commented By : Lynus
//	Commented On 2001-04-12 오후 5:09:28
//
//	CN3SndObjStream class (SoundObj.h)
//
//	End Of Comment (By Lynus On 2001-04-12 오후 5:09:28 )
//////////////////////////////////////////////////

#ifndef __N3SndObjStream_H_
#define __N3SndObjStream_H_

#include "N3SndObj.h"

class CN3SndEng;

class CN3SndObjStream : public CN3SndObj
{
private:
	int					m_PlayTime;		//wave파일의 전체 플레이 타임.
	int					m_FinalByte;
			
	DSBUFFERDESC		m_dsbd;
	uint32_t				m_BufferSize;
	uint32_t				m_BlockSize;	//buffer를 초단위로 나눈 것.
	
	int					m_CurrState;	//현재 어느 블럭에 있는지..
	int					m_PrevState;	//지금 바로 전에 어느 블럭에 있었는지..
	DWORD				m_CurrPos;		//현재 버퍼에서의 위치 
	int					m_PastTime;		//전체 플레이 타임에서 남은 시간

	//related wave data
	WAVEFORMATEX		m_WaveFormat;
	uint32_t				m_WaveSize;
	LPSTR				m_pWaveMem;
	HGLOBAL				m_hWaveMem;
	MMCKINFO			mmCkInfoRIFF;
	MMCKINFO			mmCkInfoChunk;
	HMMIO				hMMIO;
	
public:
	bool Create(const std::string& szFN, e_SndType eType = SNDTYPE_STREAM);

//	void Play(float delay = 0.0f, float fFadeInTime = 0.0f);
//	void Stop(float fFadeOutTime = 0.0f);		
	
	void Tick();		
	void Release();
	
	CN3SndObjStream();
	virtual ~CN3SndObjStream();
			
private:
	void RealPlay();
	
	//void Stop();

	BOOL LoadWave(LPCSTR pFileName);
	BOOL WriteBuffer();
	BOOL InitWriteBuffer();
	void Reset();
};

#endif // #ifndef __N3SndObjStream_H_
// ===== END N3Base/N3SndObjStream.h =====

// ===== BEGIN N3Base/N3Star.cpp =====
#line 1 "N3Base/N3Star.cpp"
﻿// N3Star.cpp: implementation of the CN3Star class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Star.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Star::CN3Star()
{
	m_iCurNumStar = 0;
	m_iNextNumStar = 0;
	m_fAddTime = 0;
}

CN3Star::~CN3Star()
{
}

void CN3Star::Release()
{
	CN3Base::Release();
	m_iCurNumStar = 0;
	m_iNextNumStar = 0;
	m_fAddTime = 0;
}

void CN3Star::Tick()
{
	// 별이 점점 늘어나고 줄어드는것 조정하기
	static float fSec = 0.0f;
	if (0.0f == m_fAddTime) return;

	fSec += s_fSecPerFrm;
	if (fSec > m_fAddTime)
	{
		int iCount = (int)(fSec/m_fAddTime);
		fSec -= m_fAddTime*iCount;
		if (m_bIncrease)
		{
			m_iCurNumStar += iCount;
			if (m_iCurNumStar>=m_iNextNumStar)
			{
				m_iCurNumStar = m_iNextNumStar;
				m_fAddTime = 0.0f;
				fSec = 0.0f;
			}
		}
		else
		{
			m_iCurNumStar -= iCount;
			if (m_iCurNumStar<=m_iNextNumStar)
			{
				m_iCurNumStar = m_iNextNumStar;
				m_fAddTime = 0.0f;
				fSec = 0.0f;
			}
		}
	}
}

void CN3Star::Render()
{
	if (0 == m_iCurNumStar) return;
	__Matrix44 matWorld; matWorld.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());

	s_lpD3DDev->SetTexture(0, nullptr);
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

	s_lpD3DDev->SetFVF(FVF_XYZCOLOR);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_POINTLIST, m_iCurNumStar, m_Stars, sizeof(m_Stars[0]));
}

void CN3Star::Init()
{
	Release();

	int i;
	uint8_t alpha = 0xff;
	uint8_t alpha_min = 0x80;
	uint8_t alpha_max = 0xff;
	float fInc = ((float)(alpha_max - alpha_min))/MAX_STAR;
	for (i=0; i<MAX_STAR; ++i)
	{
		float fX = ((float)(rand()%10000))/1000.f - 5.0f;
		float fY = ((float)(rand()%10000))/1000.f - 2.0f;
		float fZ = ((float)(rand()%10000))/1000.f - 5.0f;

		while ( (fX*fX + fY*fY + fZ*fZ) < 2.0f*2.0f )
		{
			fX = ((float)(rand()%10000))/1000.f - 5.0f;
			fY = ((float)(rand()%10000))/1000.f - 2.0f;
			fZ = ((float)(rand()%10000))/1000.f - 5.0f;
		}

		alpha = alpha_max - (uint8_t)(fInc*i);
		m_Stars[i].Set(fX, fY, fZ, (alpha<<24)|0x00ffffff);
	}
	m_iCurNumStar = 0;
}

void CN3Star::SetStar(int iNum, float fSec)
{
	if (iNum>MAX_STAR) iNum = MAX_STAR;
	else if (iNum<0) iNum = 0;
	m_iNextNumStar = iNum;
	if (0.0f>=fSec)
	{
		m_iCurNumStar = iNum;
		m_fAddTime = 0;
		return;
	}

	int iDiff = m_iNextNumStar - m_iCurNumStar;
	if (0 == iDiff) return;
	else if (iDiff>0)
	{
		m_bIncrease = TRUE;
		m_fAddTime = fSec/iDiff;
	}
	else
	{
		m_bIncrease = FALSE;
		m_fAddTime = fSec/(-iDiff);
	}
}
// ===== END N3Base/N3Star.cpp =====

// ===== BEGIN N3Base/N3Star.h =====
#line 1 "N3Base/N3Star.h"
﻿// N3Star.h: interface for the CN3Star class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3STAR_H__09250C74_48BB_4F81_9903_45EAE7605CB6__INCLUDED_)
#define AFX_N3STAR_H__09250C74_48BB_4F81_9903_45EAE7605CB6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"

const int	MAX_STAR = 200;

class CN3Star : public CN3Base  
{
public:
	CN3Star();
	virtual ~CN3Star();

// Attributes
public:
	int		GetNumStar() const {return m_iCurNumStar;}
protected:
	int		m_iCurNumStar;		// 현재 떠있는 별의 수
	int		m_iNextNumStar;		// 앞으로 보일 별 숫자
	float	m_fAddTime;			// 별 하나가 추가되거나 없어지는 시간 간격
	BOOL	m_bIncrease;		// 별이 증가할 것인가 감소할 것인가
	__VertexXyzColor	m_Stars[MAX_STAR];
// Operations
public:
	void		Init();
	virtual void Release();
	virtual void Tick();
	virtual void Render();

	void		SetStar(int iNum, float fSec);
};

#endif // !defined(AFX_N3STAR_H__09250C74_48BB_4F81_9903_45EAE7605CB6__INCLUDED_)

// ===== END N3Base/N3Star.h =====

// ===== BEGIN N3Base/N3Sun.cpp =====
#line 1 "N3Base/N3Sun.cpp"
﻿// N3Sun.cpp: implementation of the CN3Sun class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3Sun.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3Sun::CN3Sun()
{
	memset(m_Parts, 0, sizeof(__SunPart)*NUM_SUNPART);
	int i;
	for(i=0; i<NUM_SUNPART; ++i)
	{
		m_Parts[i].Color.ChangeColor(0xffffffff);
	}
	m_fCurRadian = 0.0f;
}

CN3Sun::~CN3Sun()
{
	int i;
	for(i=0; i<NUM_SUNPART; ++i)
	{
		__SunPart* pSP = m_Parts+i;
		s_MngTex.Delete(&(pSP->pTex));
	}
}

void CN3Sun::Release()
{
	CN3Base::Release();
	
	memset(m_Parts, 0, sizeof(__SunPart) * NUM_SUNPART);
	int i;
	for(i=0; i<NUM_SUNPART; ++i)
	{
		s_MngTex.Delete(&m_Parts[i].pTex);
		m_Parts[i].Color.ChangeColor(0xffffffff);
	}

	m_fCurRadian = 0.0f;
}

void CN3Sun::Render(__Matrix44& matView, __Matrix44& matProj)
{
	// 해가 그려지는 화면 좌표 계산하기 (2D로 그리는 이유는 왜곡되어서 보이는것을 막기 위해)
	__Matrix44 matWorld;
	matWorld.RotationZ(m_fCurRadian);
	__Matrix44 matFinal;
	matFinal = matWorld*matView;
	matFinal *= matProj;

	__Vector3 vSun;	vSun.Set(5, 0, 0);
	__Vector4 vOut;
	vOut.Transform(vSun, matFinal);

	int Width = s_CameraData.vp.Width;
	int Height = s_CameraData.vp.Height;
	int X = s_CameraData.vp.X;
	int Y = s_CameraData.vp.Y;

	float rhw = 1.0f/vOut.w;
	vSun.z = vOut.z*rhw;
	if (vSun.z < 0.0f || vSun.z > 1.0f) return;
	// Mapping Screen Coordinate.
	vSun.x = (float)X + int((vOut.x*rhw + 1)*Width*0.5f);
	vSun.y = (float)Y + int((-vOut.y*rhw + 1)*Height*0.5f);

	// back up render state
	DWORD dwSrcBlend, dwDestBlend;
	s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);

	// set render state
	if (D3DBLEND_ONE != dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	if (D3DBLEND_ONE != dwDestBlend) s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	s_lpD3DDev->SetFVF(FVF_TRANSFORMED);

	RECT rcSun[NUM_SUNPART];
	RECT rcScreen;	SetRect(&rcScreen, X, Y, X+Width, Y+Width);
	for (int i=0; i<NUM_SUNPART; ++i)
	{
		__SunPart* pSP = &(m_Parts[i]);

		float iWTmp = iWTmp = (Width * pSP->Delta.GetCurDelta())/2;
		SetRect(&(rcSun[i]), (int)(vSun.x - iWTmp), (int)(vSun.y - iWTmp), (int)(vSun.x + iWTmp), (int)(vSun.y + iWTmp));
		// clipping with screen.
		if ( rcSun[i].right < rcScreen.left ||
			rcSun[i].bottom < rcScreen.top ||
			rcSun[i].left > rcScreen.right ||
			rcSun[i].top > rcScreen.bottom) continue;	// 화면 밖에 그려진다.

		// 2D로 그리기
		pSP->pVertices[0].x = (float)rcSun[i].left;		pSP->pVertices[0].y = (float)rcSun[i].top;
		pSP->pVertices[1].x = (float)rcSun[i].right;	pSP->pVertices[1].y = (float)rcSun[i].top;
		pSP->pVertices[2].x = (float)rcSun[i].right;	pSP->pVertices[2].y = (float)rcSun[i].bottom;
		pSP->pVertices[3].x = (float)rcSun[i].left;		pSP->pVertices[3].y = (float)rcSun[i].bottom;

		if(pSP->pTex) s_lpD3DDev->SetTexture(0, pSP->pTex->Get());
		else s_lpD3DDev->SetTexture(0, nullptr);
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN , 2, pSP->pVertices, sizeof(__VertexTransformed) );
	}

	// restore render state
	if (D3DBLEND_ONE != dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	if (D3DBLEND_ONE != dwDestBlend) s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
}

void CN3Sun::Tick()
{
	// 해의 색, 크기 변화 계산
	int i;
	for(i=0; i<NUM_SUNPART; ++i)
	{
		m_Parts[i].Color.Tick();
		m_Parts[i].Delta.Tick();
		__VertexTransformed* pV = m_Parts[i].pVertices;
		pV[0].color = pV[1].color = pV[2].color = pV[3].color = m_Parts[i].Color.GetCurColor();
	}
}

void CN3Sun::Init(const std::string* pszFNs)
{
	Release();

	const float fZ = 0.9f;
	const float rhw = 1.0f;
	const D3DCOLOR color = 0xffffffff;
	for(int i=0; i<NUM_SUNPART; ++i)
	{
		m_Parts[i].pTex = s_MngTex.Get(pszFNs[i]);	// load texture

		m_Parts[i].pVertices[0].Set( 0, 0, fZ, rhw, color, 0.0f, 0.0f);
		m_Parts[i].pVertices[1].Set( 0, 0, fZ, rhw, color, 1.0f, 0.0f);
		m_Parts[i].pVertices[2].Set( 0, 0, fZ, rhw, color, 1.0f, 1.0f);
		m_Parts[i].pVertices[3].Set( 0, 0, fZ, rhw, color, 0.0f, 1.0f);
	}

	m_Parts[SUNPART_SUN].Delta.ChangeDelta(0.1f); // ViewPort 에서 상대적인 크기
	m_Parts[SUNPART_GLOW].Delta.ChangeDelta(0.25f);
	m_Parts[SUNPART_FLARE].Delta.ChangeDelta(0.13f);
}

// ===== END N3Base/N3Sun.cpp =====

// ===== BEGIN N3Base/N3Sun.h =====
#line 1 "N3Base/N3Sun.h"
﻿// N3Sun.h: interface for the CN3Sun class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3SUN_H__8CBCEEB3_465E_4884_9549_C86D2CCC8936__INCLUDED_)
#define AFX_N3SUN_H__8CBCEEB3_465E_4884_9549_C86D2CCC8936__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Base.h"
#include "N3ColorChange.h"

enum	eSUNPART {SUNPART_SUN=0, SUNPART_GLOW, SUNPART_FLARE, NUM_SUNPART};

class CN3Texture;
class CN3Sun : public CN3Base  
{
	friend class CN3SkyMng;
public:
	CN3Sun();
	virtual ~CN3Sun();
protected:
	struct __SunPart
	{
		CN3Texture*				pTex;			// texture
		__VertexTransformed		pVertices[4];	// vertex

		CN3ColorChange			Color;			// 색을 담당하는 클래스
		CN3DeltaChange			Delta;
	};

	__SunPart					m_Parts[NUM_SUNPART];
	float						m_fCurRadian;		// 현재 해의 회전위치
// Operations
public:
	void	SetCurAngle(float fAngle)	{m_fCurRadian = DegreesToRadians(fAngle);}	// 현재 각도설정
	void	Init(const std::string* pszFNs);
//	By : Ecli666 ( On 2002-04-04 오전 10:55:52 )
//
	float	GetCurAngle()	{	return RadiansToDegrees(m_fCurRadian);	}
//	~(By Ecli666 On 2002-04-04 오전 10:55:52 )

	void Release();
	void Render(__Matrix44& matView, __Matrix44& matProj);
	void Tick();
protected:

};

#endif // !defined(AFX_N3SUN_H__8CBCEEB3_465E_4884_9549_C86D2CCC8936__INCLUDED_)

// ===== END N3Base/N3Sun.h =====

// ===== BEGIN N3Base/N3TableBase.h =====
#line 1 "N3Base/N3TableBase.h"
﻿// N3TableBase.h: interface for the CN3TableBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3TABLEBASE_H__DD4F005E_05B0_49E3_883E_94BE6C8AC7EF__INCLUDED_)
#define AFX_N3TABLEBASE_H__DD4F005E_05B0_49E3_883E_94BE6C8AC7EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>
#include <map>

#include "My_3DStruct.h" // _ASSERT
#include "N3TableBaseImpl.h"

template <typename Type>
class CN3TableBase : public CN3TableBaseImpl
{
public:
	using MAP_TYPE = std::map<uint32_t, Type>;

	CN3TableBase();
	~CN3TableBase() override;

// Attributes
protected:
	std::vector<DATA_TYPE> m_DataTypes;	// 실제 사용되는 정보의 데이타 타입
	MAP_TYPE m_Datas; // 실제 사용되는 정보

// Operations
public:
	const MAP_TYPE& GetMap() const {
		return m_Datas;
	}

	Type* Find(uint32_t dwID) // ID로 data 찾기
	{
		auto it = m_Datas.find(dwID);
		if (it == m_Datas.end())
			return nullptr; // 찾기에 실패 했다!~!!
		
		return &it->second;
	}

	int GetSize() const
	{
		return static_cast<int>(m_Datas.size());
	}

	// index로 찾기..
	Type* GetIndexedData(int index)
	{
		if (index < 0
			|| index >= static_cast<int>(m_Datas.size()))
			return nullptr;
		
		auto it = m_Datas.begin();
		std::advance(it, index);
		return &it->second;
	}

	// 해당 ID의 Index 리턴..	Skill에서 쓴다..
	bool IDToIndex(uint32_t dwID, int* index)
	{
		auto it = m_Datas.find(dwID);
		if (it == m_Datas.end())
			return false; // 찾기에 실패 했다!~!!

		auto itSkill = m_Datas.begin();
		int iSize = static_cast<int>(m_Datas.size());
		for (int i = 0; i < iSize; i++, itSkill++)
		{
			if (itSkill == it)
			{
				*index = i;
				return true;
			}
		}

		return false;
	}

	void Release();

protected:
	bool Load(File& file) override;
	bool MakeOffsetTable(std::vector<int>& offsets);
};


// cpp파일에 있으니까 link에러가 난다. 왜 그럴까?

template <class Type>
CN3TableBase<Type>::CN3TableBase()
{
}

template <class Type>
CN3TableBase<Type>::~CN3TableBase()
{
	Release();
}

template <class Type>
void CN3TableBase<Type>::Release()
{
	m_DataTypes.clear(); // data type 저장한것 지우기
	m_Datas.clear(); // row 데이타 지우기
}

template <class Type>
bool CN3TableBase<Type>::Load(File& file)
{
	Release();

	// data(column) 의 구조가 어떻게 되어 있는지 읽기
	int iDataTypeCount = 0;
	file.Read(&iDataTypeCount, 4);			// (엑셀에서 column 수)

	std::vector<int> offsets;
	__ASSERT(iDataTypeCount > 0, "Data Type 이 0 이하입니다.");
	if (iDataTypeCount > 0)
	{
		m_DataTypes.insert(m_DataTypes.begin(), iDataTypeCount, DT_NONE);
		file.Read(&m_DataTypes[0], sizeof(DATA_TYPE) * iDataTypeCount);	// 각각의 column에 해당하는 data type

		if (!MakeOffsetTable(offsets))
		{
			__ASSERT(0, "can't make offset table");
			return FALSE;	// structure변수에 대한 offset table 만들어주기
		}

		int iSize = offsets[iDataTypeCount];	// MakeOffstTable 함수에서 리턴되는 값중 m_iDataTypeCount번째에 이 함수의 실제 사이즈가 들어있다.
		if (sizeof(Type) != iSize				// 전체 type의 크기와 실제 구조체의 크기와 다르거나 
			|| DT_DWORD != m_DataTypes[0])		// 맨 처음의 데이타가 DT_DWORD형이 아닐때(맨처음은 고유한 ID이므로)
		{
			m_DataTypes.clear();
			__ASSERT(0, "DataType is mismatch or DataSize is incorrect!!");
			return false;
		}
	}

	// row 가 몇줄인지 읽기
	int iRC;
	file.Read(&iRC, sizeof(iRC));

	Type Data;
	for (int i = 0; i < iRC; i++)
	{
		for (int j = 0; j < iDataTypeCount; j++)
			ReadData(file, m_DataTypes[j], (char*) (&Data) + offsets[j]);

		uint32_t dwKey = *((uint32_t*) (&Data));
		auto pt = m_Datas.insert(std::make_pair(dwKey, Data));

		__ASSERT(pt.second, "CN3TableBase<Type> : Key 중복 경고.");
	}

	return true;
}

// structure는 4바이트 정렬하여서 메모리를 잡는다. 따라서 아래 함수가 필요하다.
// 아래 함수로 OffsetTable을 만들어 쓴 후에는 만드시 리턴값을 delete [] 를 해주어야 한다.
template <class Type>
bool CN3TableBase<Type>::MakeOffsetTable(std::vector<int>& offsets)
{
	if (m_DataTypes.empty())
		return false;

	static constexpr int StructAlignment = alignof(Type);

	int iDataTypeCount = (int) m_DataTypes.size();

	offsets.clear();
	offsets.resize(iDataTypeCount + 1);
	offsets[0] = 0;

	int iPrevDataSize = SizeOf(m_DataTypes[0]);
	for (int i = 1; i < iDataTypeCount; i++)
	{
		int iCurDataSize = SizeOf(m_DataTypes[i]);
		int iPreviousOffset = offsets[i - 1];

		int modulo = (iCurDataSize % StructAlignment);
		if (0 == modulo)
		{
			modulo = (iPreviousOffset + iPrevDataSize) % StructAlignment;
			if (0 == modulo)
				offsets[i] = iPreviousOffset + iPrevDataSize;
			else
				offsets[i] = ((int) (iPreviousOffset + iPrevDataSize + (StructAlignment - 1)) / StructAlignment) * StructAlignment;
		}
		else if (1 == modulo)
		{
			offsets[i] = iPreviousOffset + iPrevDataSize;
		}
		else if (2 == modulo)
		{
			modulo = ((iPreviousOffset + iPrevDataSize) % 2);
			if (0 == modulo)
				offsets[i] = iPreviousOffset + iPrevDataSize;
			else
				offsets[i] = iPreviousOffset + iPrevDataSize + 1; // NOTE: Effectively this is (2 - modulo), but modulo can only be 1 here.
		}
		else if (4 == modulo)
		{
			modulo = ((iPreviousOffset + iPrevDataSize) % 4);
			if (0 == modulo)
				offsets[i] = iPreviousOffset + iPrevDataSize;
			else
				offsets[i] = iPreviousOffset + iPrevDataSize + (4 - modulo);
		}
		else
		{
			__ASSERT(0, "");
		}

		iPrevDataSize = iCurDataSize;
	}

	offsets[iDataTypeCount] = ((int) (offsets[iDataTypeCount - 1] + iPrevDataSize + (StructAlignment - 1)) / StructAlignment) * StructAlignment;
	return true;
}

#endif // !defined(AFX_N3TABLEBASE_H__DD4F005E_05B0_49E3_883E_94BE6C8AC7EF__INCLUDED_)

// ===== END N3Base/N3TableBase.h =====

// ===== BEGIN N3Base/N3TableBaseImpl.cpp =====
#line 1 "N3Base/N3TableBaseImpl.cpp"
﻿#include "StdAfxBase.h"
#include "N3TableBaseImpl.h"

#include <FileIO/FileReader.h>
#include <FileIO/FileWriter.h>

#ifdef _N3GAME
#include "LogWriter.h"
#endif

CN3TableBaseImpl::CN3TableBaseImpl()
{
}

CN3TableBaseImpl::~CN3TableBaseImpl()
{
}

bool CN3TableBaseImpl::LoadFromFile(const std::string& szFN)
{
	if (szFN.empty())
		return false;

	FileReader encryptedFile;
	if (!encryptedFile.OpenExisting(szFN))
	{
#ifdef _N3GAME
		CLogWriter::Write("N3TableBase - Can't open file(read) File Handle error ({})", szFN);
#endif
		return false;
	}

	std::error_code ec;

	// 파일 암호화 풀기.. .. 임시 파일에다 쓴다음 ..
	std::string szFNTmp = szFN + ".tmp";
	size_t encryptedFileSize = static_cast<size_t>(encryptedFile.Size());
	if (encryptedFileSize == 0)
	{
		encryptedFile.Close();
		std::filesystem::remove(szFNTmp, ec); // 임시 파일 지우기..
		return false;
	}

	// 원래 파일을 읽고..
	uint8_t* pDatas = new uint8_t[encryptedFileSize];
	encryptedFile.Read(pDatas, encryptedFileSize); // 암호화된 데이터 읽고..
	encryptedFile.Close(); // 원래 파일 닫고

// 테이블 만드는 툴에서 쓰는 키와 같은 키..
	uint16_t key_r = 0x0816;
	uint16_t key_c1 = 0x6081;
	uint16_t key_c2 = 0x1608;

//uint8_t Encrypt(uint8_t plain)
//{
//	uint8_t cipher;
//	cipher = (plain ^ (key_r>>8));
//	key_r = (cipher + key_r) * key_c1 + key_c2;
//	return cipher;
//}

//uint8_t Decrypt(uint8_t cipher)
//{
//	uint8_t plain;
//	plain = (cipher ^ (m_r>>8));
//	m_r = (cipher + m_r) * m_c1 + m_c2;
//	return plain;
//}

	// 암호화 풀고..
	for (uint32_t i = 0; i < encryptedFileSize; i++)
	{
		uint8_t byData = (pDatas[i] ^ (key_r >> 8));
		key_r = (pDatas[i] + key_r) * key_c1 + key_c2;
		pDatas[i] = byData;
	}

	// TODO: Rather than write to file to read it back again, we should just read it from a memory stream.

	// 임시 파일에 쓴다음.. 다시 연다..
	{
		FileWriter tmpFileWriter;
		if (!tmpFileWriter.Create(szFNTmp))
		{
			tmpFileWriter.Close();
			delete[] pDatas;
			return false;
		}

		tmpFileWriter.Write(pDatas, encryptedFileSize); // 임시파일에 암호화 풀린 데이터 쓰기
	}

	delete[] pDatas;
	pDatas = nullptr;

	// 임시 파일 읽기 모드로 열기.
	FileReader decryptedFile;
	if (!decryptedFile.OpenExisting(szFNTmp))
	{
		std::filesystem::remove(szFNTmp, ec);
		return false;
	}

	bool bResult = Load(decryptedFile);
	decryptedFile.Close();

	if (!bResult)
	{
#ifdef _N3GAME
		CLogWriter::Write("N3TableBase - incorrect table ({})", szFN);
#endif
	}

	// 임시 파일 지우기..
	std::filesystem::remove(szFNTmp, ec);

	return bResult;
}

bool CN3TableBaseImpl::ReadData(File& file, DATA_TYPE DataType, void* pData)
{
	switch (DataType)
	{
		case DT_CHAR:
			file.Read(pData, sizeof(char));
			break;

		case DT_BYTE:
			file.Read(pData, sizeof(uint8_t));
			break;

		case DT_SHORT:
			file.Read(pData, sizeof(int16_t));
			break;

		case DT_WORD:
			file.Read(pData, sizeof(uint16_t));
			break;

		case DT_INT:
			file.Read(pData, sizeof(int));
			break;

		case DT_DWORD:
			file.Read(pData, sizeof(uint32_t));
			break;

		case DT_STRING:
		{
			std::string& szString = *((std::string*) pData);

			int iStrLen = 0;
			file.Read(&iStrLen, sizeof(iStrLen));

			szString.clear();
			if (iStrLen > 0)
			{
				szString.assign(iStrLen, ' ');
				file.Read(&szString[0], iStrLen);
			}
		}
		break;

		case DT_FLOAT:
			file.Read(pData, sizeof(float));
			break;

		case DT_DOUBLE:
			file.Read(pData, sizeof(double));
			break;

		case DT_NONE:
		default:
			__ASSERT(0, "");
			return false;
	}

	return true;
}

int CN3TableBaseImpl::SizeOf(DATA_TYPE DataType) const
{
	switch (DataType)
	{
		case DT_CHAR:
			return sizeof(char);

		case DT_BYTE:
			return sizeof(uint8_t);

		case DT_SHORT:
			return sizeof(int16_t);

		case DT_WORD:
			return sizeof(uint16_t);

		case DT_INT:
			return sizeof(int);

		case DT_DWORD:
			return sizeof(uint32_t);

		case DT_STRING:
			return sizeof(std::string);

		case DT_FLOAT:
			return sizeof(float);

		case DT_DOUBLE:
			return sizeof(double);
	}

	__ASSERT(0, "");
	return 0;
}

// ===== END N3Base/N3TableBaseImpl.cpp =====

// ===== BEGIN N3Base/N3TableBaseImpl.h =====
#line 1 "N3Base/N3TableBaseImpl.h"
﻿#ifndef CLIENT_N3BASE_N3TABLEBASEIMPL_H
#define CLIENT_N3BASE_N3TABLEBASEIMPL_H

#pragma once

#include <FileIO/File.h>

enum TBL_DATA_TYPE
{
	DT_NONE, DT_CHAR, DT_BYTE, DT_SHORT, DT_WORD, DT_INT, DT_DWORD, DT_STRING, DT_FLOAT, DT_DOUBLE
};

class CN3TableBaseImpl
{
protected:
	using DATA_TYPE = TBL_DATA_TYPE;

	CN3TableBaseImpl();

public:
	virtual ~CN3TableBaseImpl();
	virtual bool Load(File& file) = 0;
	bool LoadFromFile(const std::string& szFN);

protected:
	bool ReadData(File& file, DATA_TYPE DataType, void* pData);
	int SizeOf(DATA_TYPE DataType) const;
};

#endif // CLIENT_N3BASE_N3TABLEBASEIMPL_H

// ===== END N3Base/N3TableBaseImpl.h =====

// ===== BEGIN N3Base/N3TerrainDef.h =====
#line 1 "N3Base/N3TerrainDef.h"
﻿#ifndef __N3TERRAINDEF_H_
#define __N3TERRAINDEF_H_

#include <list>
#include <float.h>

#include "N3Base.h"

//-----------------------------------------------------------------------------
const int PATCH_TILE_SIZE          = 8;
const int TILE_SIZE                = 4;
const int MAX_LOD_LEVEL            = 10;
const int MIN_LOD_LEVEL            = 0;
const int MAX_PATCH_LEVEL          = 3;
const int PATCH_PIXEL_SIZE         = 32;
const int UNITUV                   = 32;
const int LIGHTMAP_TEX_SIZE        = 16;
const int TILE_PIXEL_SIZE          = 128;
const int COLORMAPTEX_SIZE         = 128;
const int DISTANCE_TABLE_SIZE      = 64;
const int MAX_GRASS                = 8;
const int MAX_TERRAIN_SOUND_EFFECT = 4;

enum {
	DIR_LT   = 0, DIR_CT = 1, DIR_RT = 2,
	DIR_LM   = 3, DIR_CM = 4, DIR_RM = 5,
	DIR_LB   = 6, DIR_CB = 7, DIR_RB = 8,
	DIR_WARP = 9
};

//-----------------------------------------------------------------------------
typedef struct __MapData {
	float fHeight;

	uint32_t bIsTileFull : 1;
	uint32_t Tex1Dir     : 5;
	uint32_t Tex2Dir     : 5;
	uint32_t Tex1Idx     : 10;
	uint32_t Tex2Idx     : 10;

	__MapData(void) {
		fHeight     = FLT_MIN;

		bIsTileFull = true;
		Tex1Dir     = 0;
		Tex2Dir     = 0;
		Tex1Idx     = 1023;
		Tex2Idx     = 1023;
	}
} MAPDATA, *LPMAPDATA;

//-----------------------------------------------------------------------------
typedef struct __FanInfo {
	int NumFace;
	int NumVertex;
} FANINFO, *LPFANINFO;

//-----------------------------------------------------------------------------
typedef std::list<FANINFO> FanInfoList;
typedef FanInfoList::iterator FIIt;

#endif

// ===== END N3Base/N3TerrainDef.h =====

// ===== BEGIN N3Base/N3Texture.cpp =====
#line 1 "N3Base/N3Texture.cpp"
﻿// N3Texture.cpp: implementation of the CN3Texture class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Texture.h"
#include "WinCrypt.h"

#ifdef _N3TOOL
#include "BitmapFile.h"
#endif // #ifdef _N3TOOL

#include <FileIO/FileReader.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

static inline uint32_t GetTextureSize(
	const D3DSURFACE_DESC& sd)
{
	uint32_t nTexSize = sd.Width * sd.Height;
	if (sd.Format == D3DFMT_DXT1)
		return nTexSize / 2;

	return nTexSize & ~0xF;
}

CN3Texture::CN3Texture()
{
	m_dwType |= OBJ_TEXTURE;

	memset(&m_Header, 0, sizeof(m_Header));
	m_lpTexture = nullptr;
	m_iLOD = 0;
}

CN3Texture::~CN3Texture()
{
	if(m_lpTexture)
	{
		int nRefCount = m_lpTexture->Release();
		if(nRefCount == 0) m_lpTexture = nullptr;
	}
}

void CN3Texture::Release()
{
	if(32 == m_Header.nWidth && 32 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_32X32--;
	else if(64 == m_Header.nWidth && 64 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_64X64--;
	else if(128 == m_Header.nWidth && 128 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_128X128--;
	else if(256 == m_Header.nWidth && 256 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_256X256--;
	else if(512 == m_Header.nWidth && 512 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_512X512--;
	else if(512 < m_Header.nWidth && 512 < m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_Huge--;
	else s_ResrcInfo.nTexture_Loaded_OtherSize--;

	memset(&m_Header, 0, sizeof(m_Header));
	if(m_lpTexture && m_lpTexture->Release() == 0) m_lpTexture = nullptr;
	m_iLOD = 0;

	CN3BaseFileAccess::Release();
}

bool CN3Texture::Create(int nWidth, int nHeight, D3DFORMAT Format, BOOL bGenerateMipMap)
{
	if(nWidth != nHeight)

	if(nWidth <= 1 || nHeight <= 1 || D3DFMT_UNKNOWN == Format) return false;
	if(m_lpTexture != nullptr) this->Release();

	if(s_dwTextureCaps & TEX_CAPS_POW2) // 2 의 승수만 된다면..
	{
		int nW, nH;
		for(nW = 1; nW <= nWidth; nW *= 2); nW /= 2;
		for(nH = 1; nH <= nHeight; nH *= 2); nH /= 2;

		nWidth = nW;
		nHeight = nH;
	}

	if((s_dwTextureCaps & TEX_CAPS_SQUAREONLY) && nWidth != nHeight) // 정사각형 텍스처만 되면..
	{
		if(nWidth > nHeight) nWidth = nHeight;
		else nHeight = nWidth;
	}

	// 비디오 카드가 256 이상의 텍스처를 지원 하지 못하면..
	if(nWidth > 256 && CN3Base::s_DevCaps.MaxTextureWidth <= 256) nWidth = CN3Base::s_DevCaps.MaxTextureWidth;
	if(nHeight > 256 && CN3Base::s_DevCaps.MaxTextureHeight <= 256) nHeight = CN3Base::s_DevCaps.MaxTextureHeight;

	// 헤더 세팅..
	memset(&m_Header, 0, sizeof(m_Header));

	// MipMap 단계 결정..
	// 4 X 4 픽셀까지만 MipMap 을 만든다..
	int nMMC = 1;
	if(bGenerateMipMap)
	{
		nMMC = 0;
		for(int nW = nWidth, nH = nHeight; nW >=4 && nH >= 4; nW /=2, nH /= 2) nMMC++;
	}

	HRESULT rval = s_lpD3DDev->CreateTexture(nWidth, nHeight, nMMC, 0, Format, D3DPOOL_MANAGED, &m_lpTexture, nullptr);

#ifdef _N3GAME
	if(rval == D3DERR_INVALIDCALL)
	{
		CLogWriter::Write("N3Texture: createtexture err D3DERR_INVALIDCALL({})", m_szFileName);
		return false;
	}
	if(rval == D3DERR_OUTOFVIDEOMEMORY)
	{
		CLogWriter::Write("N3Texture: createtexture err D3DERR_OUTOFVIDEOMEMORY({})", m_szFileName);
		return false;
	}
	if(rval == E_OUTOFMEMORY)
	{
		CLogWriter::Write("N3Texture: createtexture err E_OUTOFMEMORY({})", m_szFileName);
		return false;
	}
#endif
	if(nullptr == m_lpTexture)
	{
		__ASSERT(m_lpTexture, "Texture pointer is NULL!");
		return false;
	}


	m_Header.nWidth = nWidth;
	m_Header.nHeight = nHeight;
	m_Header.Format = Format;
	m_Header.bMipMap = bGenerateMipMap;

	if(32 == m_Header.nWidth && 32 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_32X32++;
	else if(64 == m_Header.nWidth && 64 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_64X64++;
	else if(128 == m_Header.nWidth && 128 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_128X128++;
	else if(256 == m_Header.nWidth && 256 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_256X256++;
	else if(512 == m_Header.nWidth && 512 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_512X512++;
	else if(512 < m_Header.nWidth && 512 < m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_Huge++;
	else s_ResrcInfo.nTexture_Loaded_OtherSize++;

	return true;
}

#ifdef _N3TOOL
bool CN3Texture::CreateFromSurface(LPDIRECT3DSURFACE9 lpSurf, D3DFORMAT Format, BOOL bGenerateMipMap)
{
	if(lpSurf == nullptr) return false;

	D3DSURFACE_DESC sd;
	lpSurf->GetDesc(&sd);

	if(this->Create(sd.Width, sd.Height, Format, bGenerateMipMap) == false) return false;
	if(bGenerateMipMap)
	{
		this->GenerateMipMap(lpSurf);
	}
	
	return true;
}
#endif // end of _N3TOOL

bool CN3Texture::LoadFromFile(const std::string& szFileName, uint32_t iVer)
{
	m_iFileFormatVersion = iVer;

	if(m_lpTexture != nullptr) this->Release();

	this->FileNameSet(szFileName); // 파일 이름을 복사하고..
	std::string szFullPath;
	if(-1 != m_szFileName.find(':') || -1 != m_szFileName.find("\\\\") || -1 != m_szFileName.find("//")) // 문자열에 ':', '\\', '//' 이 들어 있으면 전체 경로이다..
	{
		szFullPath = m_szFileName;
	}
	else
	{
		if('\0' != s_szPath[0]) szFullPath = s_szPath;
		szFullPath += m_szFileName;
	}

	size_t nFNL = szFullPath.size();
	if (nFNL >= 3
		&& lstrcmpi(&szFullPath[nFNL - 3], "DXT") == 0)
	{
		FileReader file;
		if (!file.OpenExisting(szFullPath))
		{
#ifdef _N3GAME
			CLogWriter::Write("Can't open texture file({})", szFullPath);
#endif
			return false;
		}

		Load(file);
	}
	else
	{
		D3DXIMAGE_INFO ImgInfo;
		HRESULT rval = D3DXCreateTextureFromFileEx(	s_lpD3DDev, 
													szFullPath.c_str(),
													D3DX_DEFAULT, 
													D3DX_DEFAULT, 
													D3DX_DEFAULT, 
													0,
													D3DFMT_UNKNOWN,
													D3DPOOL_MANAGED,
													D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR,
													D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR,
													0,
													&ImgInfo,
													nullptr,
													&m_lpTexture );
		if(rval == D3D_OK)
		{
			D3DSURFACE_DESC sd;
			m_lpTexture->GetLevelDesc(0, &sd);

			m_Header.nWidth = sd.Width;
			m_Header.nHeight = sd.Height;
			m_Header.Format = sd.Format;
		}
		else
		{
#ifdef _N3GAME
			CLogWriter::Write("N3Texture - Failed to load texture({})", szFullPath);
#endif
		}

		if(32 == m_Header.nWidth && 32 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_32X32++;
		else if(64 == m_Header.nWidth && 64 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_64X64++;
		else if(128 == m_Header.nWidth && 128 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_128X128++;
		else if(256 == m_Header.nWidth && 256 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_256X256++;
		else if(512 == m_Header.nWidth && 512 == m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_512X512++;
		else if(512 < m_Header.nWidth && 512 < m_Header.nHeight) s_ResrcInfo.nTexture_Loaded_Huge++;
		else s_ResrcInfo.nTexture_Loaded_OtherSize++;
	}

	if(nullptr == m_lpTexture)
	{
		this->Release();
		return false;
	}
	return true;
}

bool CN3Texture::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	CWinCrypt crypt;

	__DXT_HEADER HeaderOrg; // 헤더를 저장해 놓고..
	file.Read(&HeaderOrg, sizeof(HeaderOrg)); // 헤더를 읽는다..
	if ('N' != HeaderOrg.szID[0]
		|| 'T' != HeaderOrg.szID[1]
		|| 'F' != HeaderOrg.szID[2]
		// "NTF"3 - Noah Texture File Ver. 3.0
		|| HeaderOrg.szID[3] < 3)
	{
#ifdef _N3GAME
		CLogWriter::Write("N3Texture Warning - Old format DXT file ({})", m_szFileName);
#endif
	}

	if (HeaderOrg.szID[3] == 7
		&& !crypt.Load())
		return false;

	// DXT Format 을 읽어야 하는데 지원이 되는지 안되는지 보고 지원안되면 대체 포맷을 정한다.
	bool bDXTSupport = FALSE;
	D3DFORMAT fmtNew = HeaderOrg.Format;
	if(D3DFMT_DXT1 == HeaderOrg.Format) 
	{
		if(s_dwTextureCaps & TEX_CAPS_DXT1) bDXTSupport = true;
		else fmtNew = D3DFMT_A1R5G5B5;
	}
	else if(D3DFMT_DXT2 == HeaderOrg.Format)
	{
		if(s_dwTextureCaps & TEX_CAPS_DXT2) bDXTSupport = true;
		else fmtNew = D3DFMT_A4R4G4B4;
	}
	else if(D3DFMT_DXT3 == HeaderOrg.Format)
	{
		if(s_dwTextureCaps & TEX_CAPS_DXT3) bDXTSupport = true;
		else fmtNew = D3DFMT_A4R4G4B4;
	}
	else if(D3DFMT_DXT4 == HeaderOrg.Format)
	{
		if(s_dwTextureCaps & TEX_CAPS_DXT4) bDXTSupport = true;
		else fmtNew = D3DFMT_A4R4G4B4;
	}
	else if(D3DFMT_DXT5 == HeaderOrg.Format)
	{
		if(s_dwTextureCaps & TEX_CAPS_DXT5) bDXTSupport = true;
		else fmtNew = D3DFMT_A4R4G4B4;
	}

	int iWCreate = HeaderOrg.nWidth, iHCreate = HeaderOrg.nHeight;
	if(fmtNew != HeaderOrg.Format) { iWCreate /= 2; iHCreate /= 2; }// DXT 지원이 안되면 너비 높이를 줄인다.
	if(m_iLOD > 0 && m_iLOD <= 2 && HeaderOrg.nWidth >= 16 && HeaderOrg.nHeight >= 16) // LOD 만큼 작게 생성..
	{
		for(int i = 0; i < m_iLOD; i++)
		{
			iWCreate /= 2;
			iHCreate /= 2;
		}
	}
	else m_iLOD = 0; // LOD 적용이 아니면..

	int iLODPrev = m_iLOD;
	this->Create(iWCreate, iHCreate, fmtNew, HeaderOrg.bMipMap); // 서피스 만들고..
	m_iLOD = iLODPrev;

	if (m_lpTexture == nullptr)
	{
#ifdef _N3GAME
		CLogWriter::Write("N3Texture error - Can't create texture ({})", m_szFileName);
#endif
		return false;
	}

	D3DSURFACE_DESC sd;
	D3DLOCKED_RECT LR;
	int iMMC = m_lpTexture->GetLevelCount(); // 생성한 MipMap 수

	// 압축 포맷이면..
	if(	D3DFMT_DXT1 == HeaderOrg.Format || 
		D3DFMT_DXT2 == HeaderOrg.Format || 
		D3DFMT_DXT3 == HeaderOrg.Format || 
		D3DFMT_DXT4 == HeaderOrg.Format || 
		D3DFMT_DXT5 == HeaderOrg.Format )
	{
		if(TRUE == bDXTSupport) // 압축 텍스처 지원이면..
		{
			if(iMMC > 1)
			{
				if (m_iLOD > 0) // LOD 만큼 건너뛰기...
				{
					int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
					for (int i = 0; i < m_iLOD; i++, iWTmp /= 2, iHTmp /= 2)
					{
						if (D3DFMT_DXT1 == HeaderOrg.Format)
							iSkipSize += iWTmp * iHTmp / 2; // DXT1 형식은 16비트 포맷에 비해 1/4 로 압축..
						else
							iSkipSize += iWTmp * iHTmp; // DXT2 ~ DXT5 형식은 16비트 포맷에 비해 1/2 로 압축..
					}

					file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.
				}

				for (int i = 0; i < iMMC; i++)
				{
					m_lpTexture->GetLevelDesc(i, &sd);

					uint32_t nTexSize = GetTextureSize(sd);

					m_lpTexture->LockRect(i, &LR, nullptr, 0);

					// 일렬로 된 데이터를 쓰고..
					crypt.ReadFile(file, LR.pBits, nTexSize);

					m_lpTexture->UnlockRect(i);
				}

				// 텍스처 압축안되는 비디오 카드를 위한 여분의 데이터 건너뛰기.. 
				int iWTmp = HeaderOrg.nWidth / 2, iHTmp = HeaderOrg.nHeight / 2;
				for(; iWTmp >= 4 && iHTmp >= 4; iWTmp /= 2, iHTmp /= 2) // 한픽셀에 두바이트가 들어가는 A1R5G5B5 혹은 A4R4G4B4 포맷으로 되어 있다..
					file.Seek(iWTmp * iHTmp * 2, SEEK_CUR); // 건너뛰고.
			}
			else // pair of if(iMMC > 1)
			{
				m_lpTexture->GetLevelDesc(0, &sd);

				uint32_t nTexSize = GetTextureSize(sd);

				m_lpTexture->LockRect(0, &LR, nullptr, 0);

				// 일렬로 된 데이터를 쓰고..
				crypt.ReadFile(file, LR.pBits, nTexSize);

				m_lpTexture->UnlockRect(0);

				// 텍스처 압축안되는 비디오 카드를 위한 여분의 데이터 건너뛰기.. 
				file.Seek(HeaderOrg.nWidth * HeaderOrg.nHeight / 4, SEEK_CUR); // 건너뛰고.
				if (HeaderOrg.nWidth >= 1024)
					file.Seek(256 * 256 * 2, SEEK_CUR); // 사이즈가 512 보다 클경우 부두용 데이터 건너뛰기..
			}
		}
		else // DXT 지원이 안되면..
		{
			if(iMMC > 1) // LOD 만큼 건너뛰기...
			{
				// 압축 데이터 건너뛰기..
				int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
				for (; iWTmp >= 4 && iHTmp >= 4; iWTmp /= 2, iHTmp /= 2)
				{
					if (D3DFMT_DXT1 == HeaderOrg.Format)
						iSkipSize += iWTmp * iHTmp / 2; // DXT1 형식은 16비트 포맷에 비해 1/4 로 압축..
					else
						iSkipSize += iWTmp * iHTmp; // DXT2 ~ DXT5 형식은 16비트 포맷에 비해 1/2 로 압축..
				}

				file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.

				// LOD 만큼 건너뛰기..
				iWTmp = HeaderOrg.nWidth / 2; iHTmp = HeaderOrg.nHeight / 2; iSkipSize = 0;
				if(m_iLOD > 0)
				{
					for(int i = 0; i < m_iLOD; i++, iWTmp /= 2, iHTmp /= 2)
						iSkipSize += iWTmp * iHTmp * 2; // 피치에 너비를 나눈게 픽셀의 크기라 생각한다...
				}

				// 비디오 카드 지원 텍스처 크기가 작을경우 건너뛰기..
				for (; iWTmp > static_cast<int>(s_DevCaps.MaxTextureWidth) || iHTmp > static_cast<int>(s_DevCaps.MaxTextureHeight);
					iWTmp /= 2, iHTmp /= 2)
					iSkipSize += iWTmp * iHTmp * 2;
				if (iSkipSize != 0)
					file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.

				for (int i = 0; i < iMMC; i++)
				{
					m_lpTexture->GetLevelDesc(i, &sd);
					m_lpTexture->LockRect(i, &LR, nullptr, 0);
					int nH = sd.Height;
					for (int y = 0; y < nH; y++)
					{
						uint8_t* pBits = (uint8_t*) LR.pBits + y * LR.Pitch;
						if (!crypt.ReadFile(file, pBits, 2 * sd.Width))
							break;
					}
					m_lpTexture->UnlockRect(i);
				}
			}
			else // pair of if(iMMC > 1)
			{
				// 압축 데이터 건너뛰기..
				int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
				if(D3DFMT_DXT1 == HeaderOrg.Format) iSkipSize = iWTmp * iHTmp / 2; // DXT1 형식은 16비트 포맷에 비해 1/4 로 압축..
				else iSkipSize = iWTmp * iHTmp; // DXT2 ~ DXT5 형식은 16비트 포맷에 비해 1/2 로 압축..
			}
		}
	}
	else
	{
		int iPixelSize = 0;
		if(	fmtNew == D3DFMT_A1R5G5B5 || fmtNew == D3DFMT_A4R4G4B4) iPixelSize = 2;
		else if(fmtNew == D3DFMT_R8G8B8) iPixelSize = 3;
		else if(fmtNew == D3DFMT_A8R8G8B8 || fmtNew == D3DFMT_X8R8G8B8) iPixelSize = 4;
		else 
		{
			__ASSERT(0, "Not supported texture format");
		}

		if(iMMC > 1)
		{
			if(m_iLOD > 0) // LOD 만큼 건너뛰기...
			{
				int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
				for (int i = 0; i < m_iLOD; i++, iWTmp /= 2, iHTmp /= 2)
					iSkipSize += iWTmp * iHTmp * iPixelSize; // 피치에 너비를 나눈게 픽셀의 크기라 생각한다...
				file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.
			}

			// 비디오 카드 지원 텍스처 크기가 작을경우 건너뛰기..
			int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
			for (; iWTmp > static_cast<int>(s_DevCaps.MaxTextureWidth) || iHTmp > static_cast<int>(s_DevCaps.MaxTextureHeight);
				iWTmp /= 2, iHTmp /= 2)
				iSkipSize += iWTmp * iHTmp * iPixelSize;
			if (iSkipSize != 0)
				file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.

			// 데이터 읽기..
			for (int i = 0; i < iMMC; i++)
			{
				m_lpTexture->GetLevelDesc(i, &sd);
				m_lpTexture->LockRect(i, &LR, nullptr, 0);
				for (int y = 0; y < (int) sd.Height; y++)
				{
					uint8_t* pBits = (uint8_t*) LR.pBits + y * LR.Pitch;
					if (!crypt.ReadFile(file, pBits, iPixelSize * sd.Width))
						break;
				}
				m_lpTexture->UnlockRect(i);
			}
		}
		else // pair of if(iMMC > 1)
		{
			// 비디오 카드 지원 텍스처 크기가 작을경우 건너뛰기..
			if (HeaderOrg.nWidth >= 512 && m_Header.nWidth <= 256)
				file.Seek(HeaderOrg.nWidth * HeaderOrg.nHeight * iPixelSize, SEEK_CUR); // 건너뛰고.

			m_lpTexture->LockRect(0, &LR, nullptr, 0);
			D3DSURFACE_DESC sd;
			m_lpTexture->GetLevelDesc(0, &sd);
			for (int y = 0; y < (int) sd.Height; y++)
			{
				uint8_t* pBits = (uint8_t*) LR.pBits + y * LR.Pitch;
				if (!crypt.ReadFile(file, pBits, iPixelSize * sd.Width))
					break;
			}
			m_lpTexture->UnlockRect(0);

			if (m_Header.nWidth >= 512 && m_Header.nHeight >= 512)
				file.Seek(256 * 256 * 2, SEEK_CUR); // 사이즈가 512 보다 클경우 부두용 데이터 건너뛰기..
		}
	}

	//	this->GenerateMipMap(); // Mip Map 을 만든다..
	return true;
}

bool CN3Texture::SkipFileHandle(File& file)
{
	CN3BaseFileAccess::Load(file);

	__DXT_HEADER HeaderOrg; // 헤더를 저장해 놓고..
	file.Read(&HeaderOrg, sizeof(HeaderOrg)); // 헤더를 읽는다..
	if(	'N' != HeaderOrg.szID[0] || 'T' != HeaderOrg.szID[1] || 'F' != HeaderOrg.szID[2] || 3 != HeaderOrg.szID[3] ) // "NTF"3 - Noah Texture File Ver. 3.0
	{
#ifdef _N3GAME
		CLogWriter::Write("N3Texture Warning - Old format DXT file ({})", m_szFileName);
#endif
	}

	// 압축 포맷이면..
	if(	D3DFMT_DXT1 == HeaderOrg.Format || 
		D3DFMT_DXT2 == HeaderOrg.Format || 
		D3DFMT_DXT3 == HeaderOrg.Format || 
		D3DFMT_DXT4 == HeaderOrg.Format || 
		D3DFMT_DXT5 == HeaderOrg.Format )
	{
		int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
		if(HeaderOrg.bMipMap)
		{
			// 압축 데이터 건너뛰기..
			for(; iWTmp >= 4 && iHTmp >= 4; iWTmp/=2, iHTmp/=2)
			{
				if(D3DFMT_DXT1 == HeaderOrg.Format) iSkipSize += iWTmp * iHTmp / 2;
				else iSkipSize += iWTmp * iHTmp;
			}
			// 텍스처 압축안되는 비디오 카드를 위한 여분의 데이터 건너뛰기.. 
			iWTmp = HeaderOrg.nWidth / 2; iHTmp = HeaderOrg.nHeight / 2;
			for(; iWTmp >= 4 && iHTmp >= 4; iWTmp /= 2, iHTmp /= 2) // 한픽셀에 두바이트가 들어가는 A1R5G5B5 혹은 A4R4G4B4 포맷으로 되어 있다..
				iSkipSize += iWTmp * iHTmp * 2; // 건너뛰고.
		}
		else // pair of if(HeaderOrg.bMipMap)
		{
			// 압축 데이터 건너뛰기..
			if(D3DFMT_DXT1 == HeaderOrg.Format) iSkipSize += HeaderOrg.nWidth * HeaderOrg.nHeight / 2;
			else iSkipSize += iSkipSize += HeaderOrg.nWidth * HeaderOrg.nHeight;

			// 텍스처 압축안되는 비디오 카드를 위한 여분의 데이터 건너뛰기.. 
			iSkipSize += HeaderOrg.nWidth * HeaderOrg.nHeight * 2;
			if(HeaderOrg.nWidth >= 1024) iSkipSize += 256 * 256 * 2; // 사이즈가 1024 보다 클경우 부두용 데이터 건너뛰기..
		}

		file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.
	}
	else
	{
		int iPixelSize = 0;
		if(	HeaderOrg.Format == D3DFMT_A1R5G5B5 || HeaderOrg.Format == D3DFMT_A4R4G4B4) iPixelSize = 2;
		else if(HeaderOrg.Format == D3DFMT_R8G8B8) iPixelSize = 3;
		else if(HeaderOrg.Format == D3DFMT_A8R8G8B8 || HeaderOrg.Format == D3DFMT_X8R8G8B8) iPixelSize = 4;
		else 
		{
			__ASSERT(0, "Not supported texture format");
		}

		int iWTmp = HeaderOrg.nWidth, iHTmp = HeaderOrg.nHeight, iSkipSize = 0;
		if(HeaderOrg.bMipMap)
		{
			for(; iWTmp >= 4 && iHTmp >= 4; iWTmp/=2, iHTmp/=2)
				iSkipSize += iWTmp * iHTmp * iPixelSize;
		}
		else
		{
			iSkipSize += iWTmp * iHTmp * iPixelSize;
			if(HeaderOrg.nWidth >= 512) iSkipSize += 256 * 256 * 2; // 사이즈가 512 보다 클경우 부두용 데이터 건너뛰기..
		}
		
		file.Seek(iSkipSize, SEEK_CUR); // 건너뛰고.
	}
	return true;
}


#ifdef _N3TOOL
bool CN3Texture::SaveToFile()
{
	char szExt[_MAX_EXT];
	_splitpath(m_szFileName.c_str(), nullptr, nullptr, nullptr, szExt);
	if(lstrcmpi(szExt, ".dxt")!=0) return false;

	return CN3BaseFileAccess::SaveToFile();
}
#endif // end of _N3TOOL


#ifdef _N3TOOL
bool CN3Texture::SaveToFile(const std::string& szFileName)
{
	this->FileNameSet(szFileName);
	return this->SaveToFile();
}
#endif // end of _N3TOOL


#ifdef _N3TOOL
bool CN3Texture::Save(File& file)
{
	if (m_lpTexture == nullptr)
		return false;

	CN3BaseFileAccess::Save(file);

	D3DSURFACE_DESC sd;
	m_lpTexture->GetLevelDesc(0, &sd);

	int nMMC = m_lpTexture->GetLevelCount();
	(nMMC > 1) ? m_Header.bMipMap = TRUE : m_Header.bMipMap = FALSE;
	if(TRUE == m_Header.bMipMap) // MipMap 갯수가 맞는지 확인..
	{
		int nMMC2 = 0;
		for(int nW = sd.Width, nH = sd.Height; nW >=4 && nH >= 4; nW /=2, nH /= 2) nMMC2++;
		if(nMMC < nMMC2)
		{
#ifdef _N3GAME
			CLogWriter::Write("N3Texture save warning - Invalid MipMap Count ({})", m_szFileName);
#endif
			m_Header.bMipMap = FALSE;
			nMMC = 1;
		}
		else
		{
			nMMC = nMMC2;
		}
	}

	m_Header.szID[0] = 'N';
	m_Header.szID[1] = 'T';
	m_Header.szID[2] = 'F';
	m_Header.szID[3] = 3; // Noah Texture File Ver '3'
	m_Header.nWidth = sd.Width;
	m_Header.nHeight = sd.Height;
	m_Header.bMipMap = (nMMC > 1) ? TRUE : FALSE;
	
	file.Write(&m_Header, sizeof(m_Header)); // 헤더를 쓰고

	if(m_lpTexture == nullptr) return false;

	if(	D3DFMT_DXT1 == sd.Format || 
		D3DFMT_DXT2 == sd.Format || 
		D3DFMT_DXT3 == sd.Format || 
		D3DFMT_DXT4 == sd.Format || 
		D3DFMT_DXT5 == sd.Format )
	{
		D3DLOCKED_RECT LR;

		for(int i = 0; i < nMMC; i++)
		{
			m_lpTexture->GetLevelDesc(i, &sd);

			uint32_t nTexSize = GetTextureSize(sd);

			m_lpTexture->LockRect(i, &LR, nullptr, 0);
			file.Write((uint8_t*)LR.pBits, nTexSize); // 일렬로 된 데이터를 쓰고..
			m_lpTexture->UnlockRect(i);
		}

		// 추가로 압축되지 않은 형식을 써준다.. 절반 크기이다.
		// 압축되지 않은 형식을 해상도를 한단계 낮추어서 저장.
		LPDIRECT3DSURFACE9 lpSurfSrc = nullptr, lpSurfDest = nullptr;
		D3DFORMAT fmtExtra = D3DFMT_UNKNOWN;
		if(D3DFMT_DXT1 == sd.Format) fmtExtra = D3DFMT_A1R5G5B5;
		else fmtExtra = D3DFMT_A4R4G4B4;
		
		int nMMC2 = nMMC - 1;
		if(nMMC == 1) nMMC2 = nMMC;
		for(int i = 0; i < nMMC2; i++)
		{
			m_lpTexture->GetLevelDesc(i, &sd);
			m_lpTexture->GetSurfaceLevel(i, &lpSurfSrc);
			int nW = sd.Width / 2, nH = sd.Height / 2;
			s_lpD3DDev->CreateOffscreenPlainSurface(nW, nH, fmtExtra, D3DPOOL_MANAGED, &lpSurfDest, nullptr);
			D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, D3DX_FILTER_TRIANGLE, 0); // 서피스 복사.
			int nPixelSize = 2;
			lpSurfDest->LockRect(&LR, nullptr, 0);
			for(int y = 0; y < nH; y++)
			{
				file.Write((uint8_t*)LR.pBits + y * LR.Pitch, nW * 2);
			}
			lpSurfDest->UnlockRect();
			lpSurfDest->Release(); lpSurfDest = nullptr; 
			lpSurfSrc->Release(); lpSurfSrc = nullptr;
		}

		if(nMMC == 1 && m_Header.nWidth >= 1024) // 부두를 위해 256 * 256 짜리 하나 더 저장해준다..
		{
			m_lpTexture->GetLevelDesc(0, &sd);
			m_lpTexture->GetSurfaceLevel(0, &lpSurfSrc);
			int nW = 256, nH = 256;
			s_lpD3DDev->CreateOffscreenPlainSurface(nW, nH, fmtExtra, D3DPOOL_MANAGED, &lpSurfDest, nullptr);
			D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, D3DX_FILTER_TRIANGLE, 0); // 서피스 복사.
			int nPixelSize = 2;
			lpSurfDest->LockRect(&LR, nullptr, 0);
			for(int y = 0; y < nH; y++)
			{
				file.Write((uint8_t*)LR.pBits + y * LR.Pitch, nW * 2);
			}
			lpSurfDest->UnlockRect();
			lpSurfDest->Release(); lpSurfDest = nullptr; 
			lpSurfSrc->Release(); lpSurfSrc = nullptr;
		}
	}
	else // 일반적인 포맷이면.
	{
		int nPixelSize = 0;
		if(	D3DFMT_A1R5G5B5 == sd.Format ||
			D3DFMT_A4R4G4B4 == sd.Format) nPixelSize = 2;
		else if(D3DFMT_R8G8B8 == sd.Format) nPixelSize = 3;
		else if(D3DFMT_A8R8G8B8 == sd.Format || D3DFMT_X8R8G8B8 == sd.Format) nPixelSize = 4;
		else 
		{
			__ASSERT(0, "this Texture Format Not Supported");
		}

		D3DLOCKED_RECT LR;
		for(int i = 0; i < nMMC; i++)
		{
			m_lpTexture->GetLevelDesc(i, &sd);
			m_lpTexture->LockRect(i, &LR, nullptr, 0); // 각 레벨 Lock
			int nH = sd.Height;
			for(int y = 0; y < nH; y++) // 그냥 픽셀 저장..
				file.Write((uint8_t*)LR.pBits + y * LR.Pitch, sd.Width * nPixelSize);
			m_lpTexture->UnlockRect(i);
		}

		if(nMMC == 1 && m_Header.nWidth >= 512) // 부두를 위해 256 * 256 짜리 하나 더 저장해준다..
		{
			LPDIRECT3DSURFACE9 lpSurfSrc = nullptr, lpSurfDest = nullptr;

			m_lpTexture->GetLevelDesc(0, &sd);
			m_lpTexture->GetSurfaceLevel(0, &lpSurfSrc);
			int nW = 256, nH = 256;
			s_lpD3DDev->CreateOffscreenPlainSurface(nW, nH, sd.Format, D3DPOOL_MANAGED, &lpSurfDest, nullptr);
			HRESULT rval = D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, D3DX_FILTER_TRIANGLE, 0); // 서피스 복사.
			lpSurfDest->LockRect(&LR, nullptr, 0);
			for(int y = 0; y < nH; y++)
			{
				file.Write((uint8_t*)LR.pBits + y * LR.Pitch, nW * 2);
			}
			lpSurfDest->UnlockRect();
			lpSurfDest->Release(); lpSurfDest = nullptr; 
			lpSurfSrc->Release(); lpSurfSrc = nullptr;
		}
	}

	return true;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3Texture::Convert(D3DFORMAT Format, int nWidth, int nHeight, BOOL bGenerateMipMap)
{
	if(m_lpTexture == nullptr) return false;

	D3DSURFACE_DESC dsd;
	m_lpTexture->GetLevelDesc(0, &dsd);
	if(0 >= nWidth || 0 >= nHeight)
	{
		nWidth = dsd.Width;
		nHeight = dsd.Height;
	}

	LPDIRECT3DTEXTURE9 lpTexOld = m_lpTexture;

	m_lpTexture = nullptr;
	if(this->Create(nWidth, nHeight, Format, bGenerateMipMap) == false) return false;
	if(bGenerateMipMap)
	{
		LPDIRECT3DSURFACE9 lpTSOld;
		lpTexOld->GetSurfaceLevel(0, &lpTSOld);
		this->GenerateMipMap(lpTSOld); // MipMap 생성
		lpTSOld->Release();
	}
	else
	{
		LPDIRECT3DSURFACE9 lpTSNew;
		LPDIRECT3DSURFACE9 lpTSOld;
		m_lpTexture->GetSurfaceLevel(0, &lpTSNew);
		lpTexOld->GetSurfaceLevel(0, &lpTSOld);
		D3DXLoadSurfaceFromSurface(lpTSNew, nullptr, nullptr, lpTSOld, nullptr, nullptr, D3DX_FILTER_NONE, 0); // 첫번재 레벨 서피스 복사.
		lpTSOld->Release();
		lpTSNew->Release();
	}

	lpTexOld->Release(); lpTexOld = nullptr;
	
	return true;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
bool CN3Texture::GenerateMipMap(LPDIRECT3DSURFACE9 lpSurfSrc)
{
	if(m_lpTexture == nullptr) return false;

	// MipMap 이 몇개 필요한지 계산..
	int nMMC = m_lpTexture->GetLevelCount();
	int nMMC2 = 0;
	for(int nW = m_Header.nWidth, nH = m_Header.nHeight; nW >=4 && nH >= 4; nW /=2, nH /= 2) nMMC2++;

	bool bNeedReleaseSurf = false;
	if(nullptr == lpSurfSrc) 
	{
		bNeedReleaseSurf = true;
		if(D3D_OK != m_lpTexture->GetSurfaceLevel(0, &lpSurfSrc)) return false;
	}

	HRESULT rval = D3D_OK;
	if(nMMC < nMMC2) // 적으면 새로 생성..
	{
		LPDIRECT3DTEXTURE9 lpTexOld = m_lpTexture;
		m_lpTexture = nullptr;

		bool created = CreateFromSurface(lpSurfSrc, m_Header.Format, TRUE);

		if (bNeedReleaseSurf)
		{
			lpSurfSrc->Release();
			lpSurfSrc = nullptr;
		}

		lpTexOld->Release();
		lpTexOld = nullptr;

		if (created)
			m_Header.bMipMap = TRUE;
		else
			m_Header.bMipMap = FALSE;

		return created;
	}
	else // MipMap 이 있으면 그냥 표면만 복사
	{
		if(false == bNeedReleaseSurf) // 다른 서피스에서 복사해야 되는 거면 0 레벨도 복사..
		{
			LPDIRECT3DSURFACE9 lpSurfDest;
			m_lpTexture->GetSurfaceLevel(0, &lpSurfDest);
			uint32_t dwFilter = D3DX_FILTER_TRIANGLE; // 기본 필터는 없다..
			HRESULT rval = D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, dwFilter, 0); // 작은 맵 체인에 서피스 이미지 축소 복사 
			lpSurfDest->Release(); lpSurfDest = nullptr;
		}

		for(int i = 1; i < nMMC2; i++)
		{
			LPDIRECT3DSURFACE9 lpSurfDest, lpSurfUp;
			m_lpTexture->GetSurfaceLevel(i-1, &lpSurfUp);
			m_lpTexture->GetSurfaceLevel(i, &lpSurfDest);
			uint32_t dwFilter = D3DX_FILTER_TRIANGLE; // 기본 필터는 없다..
			HRESULT rval = D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfUp, nullptr, nullptr, dwFilter, 0); // 작은 맵 체인에 서피스 이미지 축소 복사 
			lpSurfDest->Release();
			lpSurfUp->Release();
		}

		if(bNeedReleaseSurf) { lpSurfSrc->Release(); lpSurfSrc = nullptr; }
		if(D3D_OK == rval)
		{
			m_Header.bMipMap = TRUE;
			return true;
		}
		else
		{
			m_Header.bMipMap = FALSE;
			return FALSE;
		}
	}
}
#endif // end of _N3TOOL

void CN3Texture::UpdateRenderInfo()
{
}

#ifdef _N3TOOL
bool CN3Texture::SaveToBitmapFile(const std::string& szFN)
{
	if(szFN.empty()) return false;
	if(nullptr == m_lpTexture) return false;

	LPDIRECT3DSURFACE9 lpSurfSrc = nullptr;
	m_lpTexture->GetSurfaceLevel(0, &lpSurfSrc);

	if(nullptr == lpSurfSrc) return false;

	LPDIRECT3DSURFACE9 lpSurfDest = nullptr;
	s_lpD3DDev->CreateOffscreenPlainSurface(m_Header.nWidth, m_Header.nHeight, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &lpSurfDest, nullptr);

	if(nullptr == lpSurfDest) return false;
	if(D3D_OK != D3DXLoadSurfaceFromSurface(lpSurfDest, nullptr, nullptr, lpSurfSrc, nullptr, nullptr, D3DX_FILTER_TRIANGLE, 0)) // 서피스 복사.
	{
		lpSurfDest->Release(); lpSurfDest = nullptr;
		lpSurfSrc->Release(); lpSurfSrc = nullptr;
	}

	CBitMapFile bmpf;
	bmpf.Create(m_Header.nWidth, m_Header.nHeight);

	D3DLOCKED_RECT LR;
	lpSurfDest->LockRect(&LR, nullptr, 0);
	for(int y = 0; y < m_Header.nHeight; y++)
	{
		uint8_t* pPixelsSrc = ((uint8_t*)LR.pBits) + y * LR.Pitch;
		uint8_t* pPixelsDest = (uint8_t*)(bmpf.Pixels(0, y));
		for(int x = 0; x < m_Header.nWidth; x++)
		{
			pPixelsDest[0] = pPixelsSrc[0];
			pPixelsDest[1] = pPixelsSrc[1];
			pPixelsDest[2] = pPixelsSrc[2];
			
			pPixelsSrc += 4;
			pPixelsDest += 3;
		}
	}
	lpSurfDest->UnlockRect();
	
	lpSurfDest->Release(); lpSurfDest = nullptr;
	lpSurfSrc->Release(); lpSurfSrc = nullptr;

	return bmpf.SaveToFile(szFN.c_str());
}
#endif // end of _N3TOOL

// ===== END N3Base/N3Texture.cpp =====

// ===== BEGIN N3Base/N3Texture.h =====
#line 1 "N3Base/N3Texture.h"
﻿#pragma once

#include "N3BaseFileAccess.h"
#include <string>

class CN3Texture : public CN3BaseFileAccess
{
public:
	typedef struct __DXT_HEADER
	{
		char szID[4]; // "NTF"숫자 - Noah Texture File Ver. ?.0
		int nWidth;
		int nHeight;
		D3DFORMAT Format; // 0 - 압축 안함 1 ~ 5 : D3DFMT_DXT1 ~ D3DFMT_DXT5
		BOOL bMipMap; // Mip Map ??
	} __DxtHeader;

protected:
	__DXT_HEADER m_Header;
	LPDIRECT3DTEXTURE9 m_lpTexture;

public:
	void				UpdateRenderInfo();
	bool				LoadFromFile(const std::string& szFileName, uint32_t iVer = N3FORMAT_VER_DEFAULT) override;
	bool				Load(File& file) override;
	bool				SkipFileHandle(File& file);

#ifdef _N3TOOL
	bool				GenerateMipMap(LPDIRECT3DSURFACE9 lpSurf = nullptr); // nullptr 이면 0 레벨의 서피스로부터 생성..
	bool				Convert(D3DFORMAT Format, int nWidth = 0, int nHeight = 0, BOOL bGenerateMipMap = TRUE);
//#ifdef _N3TOOL
	bool				SaveToFile() override; // 현재 파일 이름대로 저장.
	bool				SaveToFile(const std::string& szFileName) override; // 새이름으로 저장.
	bool				Save(File& file) override;
	bool				SaveToBitmapFile(const std::string& szFN); // 24비트 비트맵 파일로 저장..
	bool				CreateFromSurface(LPDIRECT3DSURFACE9 lpSurf, D3DFORMAT Format, BOOL bGenerateMipMap);
#endif // end of _N3TOOL

	uint32_t			Width() { return m_Header.nWidth; }
	uint32_t			Height() { return m_Header.nHeight; }
	D3DFORMAT			PixelFormat() { return m_Header.Format; }
	int					MipMapCount() { if(nullptr == m_lpTexture) return 0; else return m_lpTexture->GetLevelCount(); }
	
	bool				Create(int nWidth, int nHeight, D3DFORMAT Format, BOOL bGenerateMipMap); // 장치에 맞게 생성
	LPDIRECT3DTEXTURE9	Get() { return m_lpTexture; }
	operator LPDIRECT3DTEXTURE9 () { return m_lpTexture; }
	
	void Release() override;
	CN3Texture();
	~CN3Texture() override;
};

// ===== END N3Base/N3Texture.h =====

// ===== BEGIN N3Base/N3Transform.cpp =====
#line 1 "N3Base/N3Transform.cpp"
﻿// N3Obj.cpp: implementation of the CN3 class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3Transform.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3Transform::CN3Transform()
{
	m_dwType |= OBJ_TRANSFORM;

	m_vPos.Set(0,0,0); // 위치, 스케일, 회전 벡터. 
	m_vScale.Set(1,1,1);
	m_qRot.Identity();
	m_Matrix.Identity();

	// 에니메이션 키
	m_fFrmCur = 0;
	m_fFrmWhole = 0;
}

CN3Transform::~CN3Transform()
{
}

void CN3Transform::Release()
{
	m_vPos.Set(0,0,0); // 위치, 스케일, 회전 벡터. 
	m_vScale.Set(1,1,1);
	m_qRot.Identity();

	m_Matrix.Identity();

	// 에니메이션 키
	m_fFrmCur = 0;
	m_fFrmWhole = 0;

	m_KeyPos.Release();
	m_KeyRot.Release();
	m_KeyScale.Release();

	CN3Base::Release();
}

bool CN3Transform::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	file.Read(&m_vPos, sizeof(__Vector3)); // 위치, 스케일, 회전 벡터. 
	file.Read(&m_qRot, sizeof(__Quaternion));
	file.Read(&m_vScale, sizeof(__Vector3));

	// 에니메이션 키
	m_KeyPos.Load(file);
	m_KeyRot.Load(file);
	m_KeyScale.Load(file);

	m_fFrmCur = 0;
	m_fFrmWhole = 0;

	float fFrmWhole = 0;

	fFrmWhole = m_KeyPos.Count() * m_KeyPos.SamplingRate() / 30.0f;
	if (fFrmWhole > m_fFrmWhole)
		m_fFrmWhole = fFrmWhole;

	fFrmWhole = m_KeyRot.Count() * m_KeyRot.SamplingRate() / 30.0f;
	if (fFrmWhole > m_fFrmWhole)
		m_fFrmWhole = fFrmWhole;

	fFrmWhole = m_KeyScale.Count() * m_KeyScale.SamplingRate() / 30.0f;
	if (fFrmWhole > m_fFrmWhole)
		m_fFrmWhole = fFrmWhole;

	ReCalcMatrix(); // 변환 행렬 계산..

	return true;
}

#ifdef _N3TOOL
bool CN3Transform::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	file.Write(&m_vPos, sizeof(__Vector3)); // 위치, 스케일, 회전 벡터. 
	file.Write(&m_qRot, sizeof(__Quaternion));
	file.Write(&m_vScale, sizeof(__Vector3));

	// 에니메이션 키
	m_KeyPos.Save(file);
	m_KeyRot.Save(file);
	m_KeyScale.Save(file);

	return true;
}
#endif // end of _N3TOOL

void CN3Transform::Tick(float fFrm)
{
	if(FRAME_SELFPLAY == fFrm)
	{
		m_fFrmCur += s_fSecPerFrm;
		if(m_fFrmCur < 0) m_fFrmCur = 0.0f;
		if(m_fFrmCur >= m_fFrmWhole) m_fFrmCur = 0.0f;
		fFrm = m_fFrmCur;
	}
	else
	{
		m_fFrmCur = fFrm;
	}

	bool bNdeedReCalcMatrix = this->TickAnimationKey(m_fFrmCur);
	
	if(m_dwType & OBJ_JOINT) return; // Joint 일 경우는 행렬을 계산하는 방법이 다르기 땜시 넘어간다..

	if(bNdeedReCalcMatrix) this->ReCalcMatrix();
}

void CN3Transform::ReCalcMatrix()
{
	m_Matrix.Scale(m_vScale);
	if (m_qRot.w != 0)
		m_Matrix *= m_qRot;
	m_Matrix.PosSet(m_vPos);
}

bool CN3Transform::TickAnimationKey(float fFrm)
{
	// 에니메이션 키
	int nKCP = m_KeyPos.Count();
	int nKCR = m_KeyRot.Count();
	int nKCS = m_KeyScale.Count();
	if(nKCP <= 0 && nKCR <= 0 && nKCS <= 0) return false;

	bool bNeedReCalcMatrix = false;
	if(m_KeyPos.DataGet(fFrm, m_vPos) == true) bNeedReCalcMatrix = true;
	if(m_KeyRot.DataGet(fFrm, m_qRot) == true) bNeedReCalcMatrix = true;
	if(m_KeyScale.DataGet(fFrm, m_vScale) == true) bNeedReCalcMatrix = true;

	return bNeedReCalcMatrix;
}

#ifdef _N3TOOL
void CN3Transform::Render(const __Matrix44* pMtxParent, float fUnitSize)
{
	// 축 그리기..
	static __Vector3 vAxis[9];
	static bool bAxisCreated = false;
	if(false == bAxisCreated)
	{
		__Vector3 v0(0,0,0), v1(1,0,0), v2(0.8f,0.2f,0);
		__Matrix44 mtxRot;
		for(int i = 0; i < 3; i++)
		{
			if(i == 0) { mtxRot.Identity(); } // X 축
			else if(i == 1) { mtxRot.RotationZ(DegreesToRadians(90.0f)); } // Y 축
			else if(i == 2) { mtxRot.RotationY(DegreesToRadians(-90.0f)); } // Z 축
			
			vAxis[i*3+0] = v0*mtxRot;
			vAxis[i*3+1] = v1*mtxRot;
			vAxis[i*3+2] = v2*mtxRot;
		}

		bAxisCreated = true;
	}

	__Matrix44 mtxBox;
	mtxBox.Scale(fUnitSize, fUnitSize, fUnitSize); // 관절부 박스에 스케일 적용
	mtxBox *= m_Matrix;

	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxBox.toD3D());
	CN3Base::RenderLines(&(vAxis[0]), 2, 0xffff0000); // 선그리기..
	CN3Base::RenderLines(&(vAxis[3]), 2, 0xff00ff00); // 선그리기..
	CN3Base::RenderLines(&(vAxis[6]), 2, 0xff0000ff); // 선그리기..
}
#endif // end of _N3TOOL

/*
#if _DEBUG 
// 선택 상자 만들기.
void CN3Transform::GenerateSelectBox(__Vector3 &vMin, __Vector3 &vMax)
{
	// Bounding Box Vertex Buffer 생성
	if(m_lpVBBox != nullptr) { m_lpVBBox->Release(); m_lpVBBox = nullptr; }
	HRESULT rval = m_lpDevRef->CreateVertexBuffer(54 * sizeof(__VertexColor), 0, FVF_CV, D3DPOOL_MANAGED, &m_lpVBBox);
	if(rval != D3D_OK)
	{
		rval = m_lpDevRef->CreateVertexBuffer(54 * sizeof(__VertexColor), 0, FVF_CV, D3DPOOL_MANAGED, &m_lpVBBox);
		if(rval != D3D_OK)
		{
			char szDebug[256]; D3DXGetErrorString(rval, szDebug, 256);
			MessageBox(s_hWndBase, szDebug, "VertexBuffer 생성 실패", MB_OK);
			return;
		}
	}

	float fW = (vMax.x - vMin.x)/5, fH = (vMax.y - vMin.y)/5, fL = (vMax.z - vMin.z)/5; // 길이 높이 너비 (x y z)

	__VertexColor* pVC;
	m_lpVBBox->Lock(0, 0, (uint8_t**)&pVC, nullptr);
	
	pVC[4] =  pVC[2] =  pVC[0] =  __VertexColor(vMin.x, vMax.y, vMin.z, 0xff7f7f7f);  // 정면 - 아래와 같은 선 리스트를 만든다.
	pVC[10] = pVC[8] =  pVC[6] =  __VertexColor(vMax.x, vMax.y, vMin.z, 0xff7f7f7f);  //  /          /
	pVC[16] = pVC[14] = pVC[12] = __VertexColor(vMax.x, vMin.y, vMin.z, 0xff7f7f7f);  // +--      --+
	pVC[22] = pVC[20] = pVC[18] = __VertexColor(vMin.x, vMin.y, vMin.z, 0xff7f7f7f);  // |          |
	pVC[28] = pVC[26] = pVC[24] = __VertexColor(vMax.x, vMax.y, vMax.z, 0xff7f7f7f);  // 
	pVC[34] = pVC[32] = pVC[30] = __VertexColor(vMin.x, vMax.y, vMax.z, 0xff7f7f7f);  // |/         |/
	pVC[40] = pVC[38] = pVC[36] = __VertexColor(vMin.x, vMin.y, vMax.z, 0xff7f7f7f);  // +--      --+
	pVC[46] = pVC[44] = pVC[42] = __VertexColor(vMax.x, vMin.y, vMax.z, 0xff7f7f7f);  // 

	pVC[1] =  pVC[0];  pVC[1].x  += fW;   pVC[3] =  pVC[2];  pVC[3].y  -= fH;   pVC[5] =  pVC[4];  pVC[5].z  += fL;
	pVC[7] =  pVC[6];  pVC[7].x  -= fW;   pVC[9] =  pVC[8];  pVC[9].y  -= fH;   pVC[11] = pVC[10]; pVC[11].z += fL;
	pVC[13] = pVC[12]; pVC[13].x -= fW;   pVC[15] = pVC[14]; pVC[15].y += fH;   pVC[17] = pVC[16]; pVC[17].z += fL;
	pVC[19] = pVC[18]; pVC[19].x += fW;   pVC[21] = pVC[20]; pVC[21].y += fH;   pVC[23] = pVC[22]; pVC[23].z += fL;
	
	pVC[25] = pVC[24]; pVC[25].x -= fW;   pVC[27] = pVC[26]; pVC[27].y -= fH;   pVC[29] = pVC[28]; pVC[29].z -= fL;
	pVC[31] = pVC[30]; pVC[31].x += fW;   pVC[33] = pVC[32]; pVC[33].y -= fH;   pVC[35] = pVC[34]; pVC[35].z -= fL;
	pVC[37] = pVC[36]; pVC[37].x += fW;   pVC[39] = pVC[38]; pVC[39].y += fH;   pVC[41] = pVC[40]; pVC[41].z -= fL;
	pVC[43] = pVC[42]; pVC[43].x -= fW;   pVC[45] = pVC[44]; pVC[45].y += fH;   pVC[47] = pVC[46]; pVC[47].z -= fL;

	__Vector3 vLength = (vMax - vMin);
	float fLength = vLength.Magnitude();
	__Vector3 vCenter = vMin + (vMax - vMin)/2.0f;
	pVC[48].Set(0, 0, 0, 0xffff0000); pVC[48].x -= vLength.x/2 + fLength/5 + 0.5f;// x 축 빨간색 -> 빨간색
	pVC[49].Set(0, 0, 0, 0xffff0000); pVC[49].x += vLength.x/2 + fLength/5 + 0.5f;// x 축 빨간색 -> 빨간색
	pVC[50].Set(0, 0, 0, 0xff00ff00); pVC[50].y -= vLength.y/2 + fLength/5 + 0.5f;// y 축 녹색 -> 녹색
	pVC[51].Set(0, 0, 0, 0xff00ff00); pVC[51].y += vLength.y/2 + fLength/5 + 0.5f;// y 축 녹색 -> 녹색
	pVC[52].Set(0, 0, 0, 0xff0000ff); pVC[52].z -= vLength.z/2 + fLength/5 + 0.5f;// z 축 파란색 -> 파란색
	pVC[53].Set(0, 0, 0, 0xff0000ff); pVC[53].z += vLength.z/2 + fLength/5 + 0.5f;// z 축 파란색 -> 파란색
	m_lpVBBox->Unlock();
}
#endif
*/

// ===== END N3Base/N3Transform.cpp =====

// ===== BEGIN N3Base/N3Transform.h =====
#line 1 "N3Base/N3Transform.h"
﻿// N3Transform.h: interface for the CN3Transform class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Transform_h__INCLUDED_)
#define AFX_N3Transform_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"
#include "N3AnimKey.h"

class CN3Transform : public CN3BaseFileAccess
{
protected:
	__Quaternion	m_qRot;
	__Vector3		m_vScale;


public:
	__Vector3		m_vPos;
	__Matrix44		m_Matrix; // 변환 행렬

	CN3AnimKey		m_KeyPos; // 에니메이션 키
	CN3AnimKey		m_KeyRot;
	CN3AnimKey		m_KeyScale;

	float			m_fFrmWhole; // 전체 프레임수
	float			m_fFrmCur; // 현재 프레임

public:
	virtual void	Tick(float fFrm = FRAME_SELFPLAY);
	virtual bool	TickAnimationKey(float fFrm); // Animation Key Tick... Animation Key 가 있어 움직이면 true, 아니면 false 를 return;

	const __Vector3&	Pos() const { return m_vPos; }
	const __Quaternion&	Rot() const { return m_qRot; }
	const __Vector3&	Scale() const { return m_vScale; }

	virtual void	PosSet(const __Vector3& v) { m_vPos = v; ReCalcMatrix(); }
	virtual void	PosSet(float x, float y, float z) { m_vPos.Set(x, y, z); ReCalcMatrix(); }
	virtual void	RotSet(const __Quaternion& q) { m_qRot = q; ReCalcMatrix(); }
	virtual void	RotSet(float x, float y, float z, float w) { m_qRot.x = x, m_qRot.y = y, m_qRot.z = z, m_qRot.w = w; ReCalcMatrix(); }
	virtual void	ScaleSet(const __Vector3& v) { m_vScale = v; ReCalcMatrix(); }
	virtual void	ScaleSet(float x, float y, float z) { m_vScale.Set(x, y, z); ReCalcMatrix(); }
	virtual void	ReCalcMatrix();

	bool			Load(File& file) override;
#ifdef _N3TOOL
	virtual void	Render(const __Matrix44* pMtxParent, float fUnitSize = 1.0f);
	bool			Save(File& file) override;
#endif // end of _N3TOOL

	void Release() override;
	CN3Transform();
	~CN3Transform() override;
};

#endif // !defined(AFX_N3Transform_h__INCLUDED_)

// ===== END N3Base/N3Transform.h =====

// ===== BEGIN N3Base/N3TransformCollision.cpp =====
#line 1 "N3Base/N3TransformCollision.cpp"
﻿// N3TransformCollision.cpp: implementation of the CN3TransformCollision class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3TransformCollision.h"
#include "N3VMesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3TransformCollision::CN3TransformCollision()
{
	m_dwType |= OBJ_TRANSFORM_COLLISION;

	m_fRadius = 0;
	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);

	m_pMeshCollision = nullptr;
	m_pMeshClimb = nullptr;
}

CN3TransformCollision::~CN3TransformCollision()
{
	s_MngVMesh.Delete(&m_pMeshCollision);
	s_MngVMesh.Delete(&m_pMeshClimb);
}

void CN3TransformCollision::Release()
{
	m_fRadius = 0;
	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);

	s_MngVMesh.Delete(&m_pMeshCollision);
	s_MngVMesh.Delete(&m_pMeshClimb);

	CN3Transform::Release();
}

bool CN3TransformCollision::Load(File& file)
{
	CN3Transform::Load(file);

	int nL = 0;
	char szFN[512] = "";

	file.Read(&nL, 4); // Mesh FileName
	if(nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0'; // 메시 파일 이름..
		m_pMeshCollision = s_MngVMesh.Get(szFN);
	}

	file.Read(&nL, 4); // Mesh FileName
	if(nL > 0)
	{
		file.Read(szFN, nL); szFN[nL] = '\0'; // 메시 파일 이름..
		m_pMeshClimb = s_MngVMesh.Get(szFN);
	}
	return true;
}

#ifdef _N3TOOL
bool CN3TransformCollision::Save(File& file)
{
	CN3Transform::Save(file);

	int nL = 0;
	if (m_pMeshCollision != nullptr)
		nL = static_cast<int>(m_pMeshCollision->FileName().size());
	file.Write(&nL, 4); // Mesh FileName

	if (nL > 0)
	{
		// 임시로 경로를 바꾸려고 넣었다.. 나중에 필요없음 지운다..
		if (m_pMeshCollision->FileName().find("object\\") == std::string::npos)
		{
			std::string szFNTmp = fmt::format("Object\\{}.N3VMesh", m_pMeshCollision->m_szName);
			m_pMeshCollision->FileNameSet(szFNTmp);

			file.Seek(-4, SEEK_CUR);
			nL = static_cast<int>(m_pMeshCollision->FileName().size());
			file.Write(&nL, 4); // Mesh FileName
		}

		file.Write(m_pMeshCollision->FileName().c_str(), nL);
	}

	nL = 0;
	if (m_pMeshClimb != nullptr)
		nL = static_cast<int>(m_pMeshClimb->FileName().size());
	file.Write(&nL, 4); // Mesh FileName

	if (nL > 0)
	{
		// 임시로 경로를 바꾸려고 넣었다.. 나중에 필요없음 지운다..
		if (m_pMeshClimb->FileName().find("object\\") == std::string::npos)
		{
			std::string szFNTmp = fmt::format("Object\\{}.N3VMesh", m_pMeshClimb->m_szName);
			m_pMeshClimb->FileNameSet(szFNTmp);

			file.Seek(-4, SEEK_CUR);
			nL = static_cast<int>(m_pMeshClimb->FileName().size());
			file.Write(&nL, 4); // Mesh FileName
		}

		file.Write(m_pMeshClimb->FileName().c_str(), nL);
	}
	return true;
}
#endif // end of _N3TOOL

void CN3TransformCollision::CollisionMeshSet(const std::string& szFN)
{
	s_MngVMesh.Delete(&m_pMeshCollision);
	m_pMeshCollision = s_MngVMesh.Get(szFN);
	if(m_pMeshCollision) this->FindMinMax();
}

void CN3TransformCollision::ClimbMeshSet(const std::string& szFN)
{
	s_MngVMesh.Delete(&m_pMeshClimb);
	m_pMeshClimb = s_MngVMesh.Get(szFN);
	if(m_pMeshClimb) m_pMeshClimb->FindMinMax();
}

int CN3TransformCollision::CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol, __Vector3* pVNormal)
{
	__Vector3 vPos, vDir; // 2D 좌표를 3D 좌표로 바꾸고..
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	if(false == m_pMeshCollision->Pick(m_Matrix, vPos, vDir, pVCol, pVNormal)) return -1;
	else return 0;
}

#if defined(_DEBUG) || defined(_N3TOOL)
void CN3TransformCollision::RenderCollisionMesh()
{
	if(nullptr == m_pMeshCollision) return;
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	m_pMeshCollision->Render(0xffff0000); // 빨간색.
}

void CN3TransformCollision::RenderClimbMesh()
{
	if(nullptr == m_pMeshClimb) return;
	s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Matrix.toD3D());

	m_pMeshClimb->Render(0xff0000ff); // 파란색..
}
#endif

/*
#ifdef _N3TOOL
BOOL CN3TransformCollision::CheckClimb(__Vector3 &vPos, __Vector3 &vDir, __Vector3* pVCol, __Vector3* pVNormal, __Vector3* pVPolygon)
{
	if(nullptr == m_pMeshClimb) return FALSE;
	
	int nIC = m_pMeshClimb->IndexCount();
	int nFC = 0;
	if(nIC > 0)
	{
		nFC = nIC / 3; // Face Count
	}
	else
	{
		nFC = m_pMeshClimb->VertexCount() / 3;
	}
	if(nFC <= 0) return FALSE;

	float t,u,v;
	__Vector3 vSrc[3];

	if(nIC > 0)
	{
		uint16_t* pwIndices = m_pMeshClimb->Indices();
		__Vector3* pVSrc = m_pMeshClimb->Vertices();
		for(int i = 0; i < nFC; i++)
		{
			vSrc[0] = pVSrc[pwIndices[i*3+0]] * m_Matrix;
			vSrc[1] = pVSrc[pwIndices[i*3+1]] * m_Matrix;
			vSrc[2] = pVSrc[pwIndices[i*3+2]] * m_Matrix;

			if(TRUE == ::IntersectTriangle(vPos, vDir, vSrc[0], vSrc[1], vSrc[2], t, u, v)) 
			{
				if(pVCol) *pVCol = (vDir * t) + vPos;
				if(pVNormal) { pVNormal->Cross(vSrc[1] - vSrc[0], vSrc[2] - vSrc[0]); pVNormal->Normalize(); }
				if(pVPolygon)
				{
					pVPolygon[0] = vSrc[0];
					pVPolygon[1] = vSrc[1];
					pVPolygon[2] = vSrc[2];
				}
				return TRUE;
			}
		}
	}
	else
	{
		__Vector3* pVSrc = m_pMeshClimb->Vertices();
		for(int i = 0; i < nFC; i++, pVSrc += 3)
		{
			vSrc[0] = pVSrc[0] * m_Matrix;
			vSrc[1] = pVSrc[1] * m_Matrix;
			vSrc[2] = pVSrc[2] * m_Matrix;

			if(TRUE == ::IntersectTriangle(vPos, vDir, vSrc[0], vSrc[1], vSrc[2], t, u, v)) 
			{
				if(pVCol) *pVCol = (vDir * t) + vPos;
				if(pVNormal) { pVNormal->Cross(vSrc[1] - vSrc[0], vSrc[2] - vSrc[0]); pVNormal->Normalize(); }
				if(pVPolygon)
				{
					pVPolygon[0] = vSrc[0];
					pVPolygon[1] = vSrc[1];
					pVPolygon[2] = vSrc[2];
				}
				return TRUE;
			}
		}
	}

	return FALSE;
}
#endif // end of _N3TOOL

#ifdef _N3TOOL
BOOL CN3TransformCollision::CheckClimb(int x, int y, __Vector3* pVCol, __Vector3* pVNormal, __Vector3* pVPolygon)
{
	if(nullptr == m_pMeshClimb || nullptr == m_pMeshClimb->Vertices()) return FALSE;

	// Compute the vector of the pick ray in screen space
	__Vector3 vTmp;
	vTmp.x =  ( ( ( 2.0f * x ) / (CN3Base::s_CameraData.vp.Width) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[0][0];
	vTmp.y = -( ( ( 2.0f * y ) / (CN3Base::s_CameraData.vp.Height) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[1][1];
	vTmp.z =  1.0f;

	// Transform the screen space pick ray into 3D space
	__Matrix44* pMtxVI = &CN3Base::s_CameraData.mtxViewInverse;
	__Vector3 vPos, vDir;
	vDir.x  = vTmp.x * pMtxVI->m[0][0] + vTmp.y * pMtxVI->m[1][0] + vTmp.z * pMtxVI->m[2][0];
	vDir.y  = vTmp.x * pMtxVI->m[0][1] + vTmp.y * pMtxVI->m[1][1] + vTmp.z * pMtxVI->m[2][1];
	vDir.z  = vTmp.x * pMtxVI->m[0][2] + vTmp.y * pMtxVI->m[1][2] + vTmp.z * pMtxVI->m[2][2];
	vPos = pMtxVI->Pos();

	return CheckClimb(vPos, vDir, pVCol, pVNormal, pVPolygon);
}
#endif // end of _N3TOOL
*/

void CN3TransformCollision::FindMinMax()
{
	m_vMin.Set(0,0,0);
	m_vMax.Set(0,0,0);
	m_fRadius = 0.0f;

	if(nullptr == m_pMeshCollision || m_pMeshCollision->VertexCount() <= 0) return;

	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	
	int nVC = m_pMeshCollision->VertexCount();
	__Vector3* pVs = m_pMeshCollision->Vertices();
	for(int i = 0; i < nVC; i++)
	{
		if(pVs[i].x < m_vMin.x) m_vMin.x = pVs[i].x;
		if(pVs[i].y < m_vMin.y) m_vMin.y = pVs[i].y;
		if(pVs[i].z < m_vMin.z) m_vMin.z = pVs[i].z;
		if(pVs[i].x > m_vMax.x) m_vMax.x = pVs[i].x;
		if(pVs[i].y > m_vMax.y) m_vMax.y = pVs[i].y;
		if(pVs[i].z > m_vMax.z) m_vMax.z = pVs[i].z;
	}

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

// ===== END N3Base/N3TransformCollision.cpp =====

// ===== BEGIN N3Base/N3TransformCollision.h =====
#line 1 "N3Base/N3TransformCollision.h"
﻿// N3TransformCollision.h: interface for the CN3TransformCollision class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3TRANSFORMCOLLISION_H__81088A50_9039_45F5_82D7_B0FF14C161F2__INCLUDED_)
#define AFX_N3TRANSFORMCOLLISION_H__81088A50_9039_45F5_82D7_B0FF14C161F2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

#include "N3Transform.h"
#include "N3VMesh.h"

class CN3TransformCollision : public CN3Transform  
{
protected:
	float			m_fRadius; // 반지름..
	__Vector3		m_vMin, m_vMax; // 최대 최소점..
	CN3VMesh*		m_pMeshCollision; // 충돌 체크용 메시..
	CN3VMesh*		m_pMeshClimb; // 기어 올라가는 충돌 체크용 메시..

public:
	virtual void	FindMinMax();
	__Vector3		Min() { return m_vMin * m_Matrix; } // 월드 상의 최소값
	__Vector3		Max() { return m_vMax * m_Matrix; } // 월드 상의 최대값
	__Vector3		RawMin() { return m_vMin; } // 월드 상의 최소값
	__Vector3		RawMax() { return m_vMax; } // 월드 상의 최대값
	float			Radius() { return m_fRadius * m_vScale.y; }

	void			SetRadius(float fRadius) { m_fRadius = fRadius; }
	void			SetMin(__Vector3 vMin) { m_vMin = vMin; }
	void			SetMax(__Vector3 vMax) { m_vMin = vMax; }
	void			SetMeshCollision(const std::string& szFN) { m_pMeshCollision = s_MngVMesh.Get(szFN); }
	void			SetMeshClimb(const std::string& szFN) { m_pMeshClimb = s_MngVMesh.Get(szFN); }
	
//	By : Dino ( On 2001-08-27 오후 9:15:24 )
//	주어진 지점이 m_fRadius 범위안에 있는지 체크
	bool			IsInRadius(__Vector3& vCheckPos)	{return ((vCheckPos - m_vPos).Magnitude() > m_fRadius ? FALSE : TRUE);}
	bool			IsInRadiusXZ(float fX, float fZ) {fX -= m_vPos.x; fZ -= m_vPos.z; return (sqrtf(fX*fX + fZ*fZ) > m_fRadius ? FALSE : TRUE);}
//	~(By Dino On 2001-08-27 오후 9:15:24 )

	virtual int		CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr);
//	BOOL CheckClimb(int x, int y, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr, __Vector3* pVPolygon = nullptr);
//	BOOL CheckClimb(__Vector3 &vPos, __Vector3 &vDir, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr, __Vector3* pVPolygon = nullptr);

#if defined(_DEBUG) || defined(_N3TOOL)
	void			RenderCollisionMesh();
	void			RenderClimbMesh();
#endif

	CN3VMesh*		CollisionMesh() { return m_pMeshCollision; }
	CN3VMesh*		ClimbMesh() { return m_pMeshClimb; }
	void			CollisionMeshSet(const std::string& szFN);
	void			ClimbMeshSet(const std::string& szFN);

	bool			Load(File& file) override;
#ifdef _N3TOOL
	bool			Save(File& file) override;
#endif // end of _N3TOOL

	void Release() override;
	CN3TransformCollision();
	~CN3TransformCollision() override;
};

#endif // !defined(AFX_N3TRANSFORMCOLLISION_H__81088A50_9039_45F5_82D7_B0FF14C161F2__INCLUDED_)

// ===== END N3Base/N3TransformCollision.h =====

// ===== BEGIN N3Base/N3UIArea.cpp =====
#line 1 "N3Base/N3UIArea.cpp"
﻿// N3UIArea.cpp: implementation of the CN3UIArea class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIArea.h"
#include "N3UIEdit.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIArea::CN3UIArea()
{
	m_eType = UI_TYPE_AREA;
	m_eAreaType = UI_AREA_TYPE_NONE;
}

CN3UIArea::~CN3UIArea()
{
}

void CN3UIArea::Release()
{
	CN3UIBase::Release();
}

void CN3UIArea::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		(*itor)->SetRegion(Rect);
	}
}

bool CN3UIArea::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

#ifndef _REPENT
	// 추가사항이 있으면 이곳에 추가하기
	int iAreaType;
	file.Read(&iAreaType, sizeof(int));	// click 영역
	m_eAreaType = (eUI_AREA_TYPE)iAreaType;
#endif
	return true;
}

uint32_t CN3UIArea::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

#ifndef _REPENT
#ifdef _N3GAME
	if (s_bWaitFromServer)
		return dwRet;
#endif
#endif

	// 특정 이벤트에 대해 메시지 전송..
	if(IsIn(ptCur.x, ptCur.y) && (dwFlags & UI_MOUSE_LBCLICK) )	
	{
		m_pParent->ReceiveMessage(this, UIMSG_BUTTON_CLICK); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

#ifndef _REPENT
#ifdef _N3GAME
bool CN3UIArea::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (s_bWaitFromServer)
		return false;

	return CN3UIBase::ReceiveMessage(pSender, dwMsg);
}
#endif
#endif

#ifdef _N3TOOL
bool CN3UIArea::Save(File& file)
{
	if (false == CN3UIBase::Save(file)) return false;
#ifndef _REPENT
	int iAreaType = (int)m_eAreaType;
	file.Write(&iAreaType, sizeof(int));	// click 영역
#endif
	return true;
}

void CN3UIArea::operator = (const CN3UIArea& other)
{
	CN3UIBase::operator = (other);
#ifndef _REPENT
	m_eAreaType = other.m_eAreaType;
#endif
}
#endif


// ===== END N3Base/N3UIArea.cpp =====

// ===== BEGIN N3Base/N3UIArea.h =====
#line 1 "N3Base/N3UIArea.h"
﻿// N3UIArea.h: interface for the CN3UIArea class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIAREA_H__895A2972_7C58_4264_92AA_B740D40B0C22__INCLUDED_)
#define AFX_N3UIAREA_H__895A2972_7C58_4264_92AA_B740D40B0C22__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"

enum eUI_AREA_TYPE	{ 
						UI_AREA_TYPE_NONE = 0, 
						UI_AREA_TYPE_SLOT,
						UI_AREA_TYPE_INV,
						UI_AREA_TYPE_TRADE_NPC,
						UI_AREA_TYPE_PER_TRADE_MY,
						UI_AREA_TYPE_PER_TRADE_OTHER,
						UI_AREA_TYPE_DROP_ITEM,
						UI_AREA_TYPE_SKILL_TREE,
						UI_AREA_TYPE_SKILL_HOTKEY,
						UI_AREA_TYPE_REPAIR_INV,
						UI_AREA_TYPE_REPAIR_NPC,
						UI_AREA_TYPE_TRADE_MY,
						UI_AREA_TYPE_PER_TRADE_INV,
					};

class CN3UIArea : public CN3UIBase  
{
public:
	CN3UIArea();
	~CN3UIArea() override;

public:
	eUI_AREA_TYPE	m_eAreaType;

public:
	void	Release() override;
	bool	Load(File& file) override;
	void	SetRegion(const RECT& Rect) override;

	uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
#ifndef _REPENT
#ifdef _N3GAME
	bool	ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
#endif
#endif

#ifdef _N3TOOL
// 툴에서 사용하기 위한 함수
	virtual void	operator = (const CN3UIArea& other);
	bool	Save(File& file) override;
#endif
};

#endif // !defined(AFX_N3UIAREA_H__895A2972_7C58_4264_92AA_B740D40B0C22__INCLUDED_)


// ===== END N3Base/N3UIArea.h =====

// ===== BEGIN N3Base/N3UIBase.cpp =====
#line 1 "N3Base/N3UIBase.cpp"
﻿// N3UIBase.cpp: implementation of the CN3UIBase class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIBase.h"

#include <vector>
#include "N3UIButton.h"
#include "N3UIProgress.h"
#include "N3UIImage.h"
#include "N3UIScrollBar.h"
#include "N3UIString.h"
#include "N3UITrackBar.h"
#include "N3UIStatic.h"
#include "N3UIEdit.h"
#include "N3UITooltip.h"
#include "N3UIArea.h"
#include "N3UIList.h"
#ifdef _REPENT
#include "N3UIIconSlot.h"
#endif

#include "N3SndMgr.h"
#include "N3SndObj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

#ifdef _N3GAME
bool CN3UIBase::s_bWaitFromServer = false;
#endif

CN3UIEdit* CN3UIBase::s_pFocusedEdit = nullptr;
CN3UITooltip* CN3UIBase::s_pTooltipCtrl = nullptr;
std::string CN3UIBase::s_szStringTmp; // 임시변수..

CN3UIBase::CN3UIBase()
{
	m_eType = UI_TYPE_BASE;
	m_pParent = nullptr;
	m_pChildUI	= nullptr;
	m_pParentUI = nullptr;

	m_iChildID	= -1;

	memset(&m_rcRegion, 0, sizeof(m_rcRegion));
	memset(&m_rcMovable, 0, sizeof(m_rcMovable));
	m_eState = UI_STATE_COMMON_NONE;
	m_dwStyle = UISTYLE_NONE;

	m_dwReserved = 0;
	m_bVisible = true;
	m_pSnd_OpenUI = nullptr;
	m_pSnd_CloseUI = nullptr;

	m_crToolTip = DefaultTooltipColor;
}

CN3UIBase::~CN3UIBase()
{
	if(m_pParent) m_pParent->RemoveChild(this);	// 부모의 자식에서 나를 지우기

	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_OpenUI);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_CloseUI);

	while(!m_Children.empty())
	{
		CN3UIBase* pChild = m_Children.front();
		if (pChild) delete pChild;	// 자식이 delete되면서 부모의 list에서는 자동으로 제거된다.
									// 따라서 리스트에서 따로 지우는 부분이 없어도 된다.
	}
}

void CN3UIBase::Release()
{
	if (m_pParent != nullptr)
		m_pParent->RemoveChild(this);

	memset(&m_rcRegion, 0, sizeof(m_rcRegion));
	memset(&m_rcMovable, 0, sizeof(m_rcMovable));
	
	m_szID.clear();
	m_szToolTip.clear();
	m_crToolTip = DefaultTooltipColor;

	m_eState = UI_STATE_COMMON_NONE;
	m_dwStyle = UISTYLE_NONE;
	m_dwReserved = 0;
	m_bVisible = true;
	s_SndMgr.ReleaseObj(&m_pSnd_OpenUI);
	s_SndMgr.ReleaseObj(&m_pSnd_CloseUI);

	while (!m_Children.empty())
	{
		// 자식이 delete되면서 부모의 list에서는 자동으로 제거된다.
		// 따라서 리스트에서 따로 지우는 부분이 없어도 된다.
		delete m_Children.front();
	}

	CN3BaseFileAccess::Release();
}

void CN3UIBase::Init(CN3UIBase* pParent)
{
	Release();
	SetParent(pParent);
}

void CN3UIBase::RemoveChild(CN3UIBase* pChild)
{
	if(nullptr == pChild) return;

	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor;)
	{
		if((*itor) == pChild)
		{
			itor = m_Children.erase(itor);
			break;
		}
		else
		{
			++itor;
		}
	}
}

void CN3UIBase::SetParent(CN3UIBase* pParent)
{
	if(m_pParent) m_pParent->RemoveChild(this);
	m_pParent = pParent;
	if (m_pParent) m_pParent->AddChild(this);

	if(pParent) m_iFileFormatVersion = pParent->m_iFileFormatVersion;
}

POINT CN3UIBase::GetPos() const
{
	POINT p;
	p.x = m_rcRegion.left;
	p.y = m_rcRegion.top;
	return p;
}

// Reposition
void CN3UIBase::SetPos(int x, int y)
{
	// Find the delta
	int dx, dy;
	dx = x - m_rcRegion.left;
	dy = y - m_rcRegion.top;

	MoveOffset(dx, dy);
}

void CN3UIBase::SetPosCenter()
{
	// Target location of our UI Element
	const int elementCenterX = static_cast<int>((s_CameraData.vp.Width - GetWidth()) / 2);
	const int elementCenterY = static_cast<int>((s_CameraData.vp.Height - GetHeight()) / 2);
	
	// Delta is the diff between our target and our current position
	POINT currentPos = GetPos();
	const int deltaX = elementCenterX - currentPos.x;
	const int deltaY = elementCenterY - currentPos.y;

	// Shift the UI element; We call MoveOffset as it will also shift all child elements
	MoveOffset(deltaX, deltaY);
}

// MoveOffset shifts the UI element and all of its children by the given offsets
BOOL CN3UIBase::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (iOffsetX == 0
		&& iOffsetY == 0)
		return FALSE;
	
	// Shift UI Element Bounding Box
	m_rcRegion.left += iOffsetX;
	m_rcRegion.top += iOffsetY;
	m_rcRegion.right += iOffsetX;
	m_rcRegion.bottom += iOffsetY;

	// movable 영역
	if(	m_rcMovable.right - m_rcMovable.left != 0 &&
		m_rcMovable.bottom - m_rcMovable.top != 0 )
	{
		m_rcMovable.left += iOffsetX;
		m_rcMovable.top += iOffsetY;
		m_rcMovable.right += iOffsetX;
		m_rcMovable.bottom += iOffsetY;
	}

	// Shift child elements
	for (CN3UIBase* pCUI : m_Children)
	{
		__ASSERT(pCUI, "child UI pointer is NULL!");
		pCUI->MoveOffset(iOffsetX, iOffsetY);
	}
	return TRUE;
}

//	점 (x,y)가 영역안에 있으면 true..
bool CN3UIBase::IsIn(int x, int y)
{
	if(x<m_rcRegion.left || x>m_rcRegion.right || y<m_rcRegion.top || y>m_rcRegion.bottom) return false;
	return true;
}

void CN3UIBase::SetSize(int iWidth, int iHeight)
{
	RECT rc;
	SetRect(&rc, m_rcRegion.left, m_rcRegion.top, m_rcRegion.left + iWidth, m_rcRegion.top + iHeight);
	SetRegion(rc);
}

bool CN3UIBase::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) // 메시지를 받는다.. 보낸놈, msg
{
	if(m_pParent && pSender) m_pParent->ReceiveMessage(pSender, dwMsg); // 부모가 있으면 그넘에게도 보낸다..
	return true;
}

void CN3UIBase::CallBackProc(int iID, uint32_t dwFlag)
{
}

void CN3UIBase::ShowWindow(int iID, CN3UIBase* pParent)
{
	if(pParent)
		pParent->m_pChildUI = this;

	m_pParentUI = pParent;
	m_iChildID = iID;

	SetVisible(true);
}

bool CN3UIBase::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	// children 정보
	int iCC = 0;
	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
	{
		int16_t sCC, sIdk0;
		file.Read(&sCC, sizeof(int16_t)); // children count
		file.Read(&sIdk0, sizeof(int16_t));
		iCC = (int) sCC;
	}
	else
	{
		file.Read(&iCC, sizeof(iCC)); // children count
	}

	eUI_TYPE eChildUIType;
	for (int i = 0; i < iCC; i++)
	{
		CN3UIBase* pChild = nullptr;
		file.Read(&eChildUIType, sizeof(eChildUIType)); // child의 ui type

		switch (eChildUIType)
		{
		case UI_TYPE_BASE:			pChild = new CN3UIBase();			break;
		case UI_TYPE_IMAGE:			pChild = new CN3UIImage();			break;
		case UI_TYPE_STRING:		pChild = new CN3UIString();			break;
		case UI_TYPE_BUTTON:		pChild = new CN3UIButton();			break;
		case UI_TYPE_STATIC:		pChild = new CN3UIStatic();			break;
		case UI_TYPE_PROGRESS:		pChild = new CN3UIProgress();		break;
		case UI_TYPE_SCROLLBAR:		pChild = new CN3UIScrollBar();		break;
		case UI_TYPE_TRACKBAR:		pChild = new CN3UITrackBar();		break;
		case UI_TYPE_EDIT:			pChild = new CN3UIEdit();			break;
		case UI_TYPE_AREA:			pChild = new CN3UIArea();			break;
#ifdef _REPENT
		case UI_TYPE_ICONSLOT:		pChild = new CN3UIIconSlot();		break;
#endif
		case UI_TYPE_LIST:			pChild = new CN3UIList();			break;
		}
		__ASSERT(pChild, "Unknown type UserInterface!!!");
		pChild->Init(this);
		pChild->Load(file);
	}

	// base 정보
	int iIDLen = 0;
	file.Read(&iIDLen, sizeof(iIDLen));				// ui id length
	if (iIDLen > 0)
	{
		m_szID.assign(iIDLen, '\0');
		file.Read(&m_szID[0], iIDLen);				// ui id
	}
	else
	{
		m_szID.clear();
	}

	file.Read(&m_rcRegion, sizeof(m_rcRegion));		// m_rcRegion
	file.Read(&m_rcMovable, sizeof(m_rcMovable));	// m_rcMovable
	file.Read(&m_dwStyle, sizeof(m_dwStyle));		// style
	file.Read(&m_dwReserved, sizeof(m_dwReserved));	// m_dwReserved

	int iTooltipLen;
	file.Read(&iTooltipLen, sizeof(iTooltipLen));	//	tooltip문자열 길이
	if (iTooltipLen > 0)
	{
		m_szToolTip.assign(iTooltipLen, '\0');
		file.Read(&m_szToolTip[0], iTooltipLen);
	}

	std::string szSoundFN;
	// 이전 uif파일을 컨버팅 하려면 사운드 로드 하는 부분 막기
	int iSndFNLen = 0;
	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		szSoundFN.assign(iSndFNLen, '\0');
		file.Read(&szSoundFN[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_OpenUI, "memory leak");
		m_pSnd_OpenUI = s_SndMgr.CreateObj(szSoundFN, SNDTYPE_2D);
	}

	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		szSoundFN.assign(iSndFNLen, '\0');
		file.Read(&szSoundFN[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_CloseUI, "memory leak");
		m_pSnd_CloseUI = s_SndMgr.CreateObj(szSoundFN, SNDTYPE_2D);
	}

	return true;
}


void CN3UIBase::Tick()
{
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->Tick();
	}
}

void CN3UIBase::Render()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->Render();

		//this_ui
		CN3UIBase* pCUI = nullptr;
		pCUI = pChild->m_pChildUI;
		while(pCUI)
		{
			pCUI->Render();
			pCUI = pCUI->m_pChildUI;
		}
	}
}

uint32_t CN3UIBase::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld )
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE == m_eState)
	{
		if (dwFlags&UI_MOUSE_LBCLICKED)
		{
			SetState(UI_STATE_COMMON_NONE);
		}
		else
		{
			MoveOffset(ptCur.x - ptOld.x, ptCur.y - ptOld.y);
		}
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if(false == IsIn(ptCur.x, ptCur.y))	// 영역 밖이면
	{
		if(false == IsIn(ptOld.x, ptOld.y))
		{
			return dwRet;// 이전 좌표도 영역 밖이면 
		}
		dwRet |= UI_MOUSEPROC_PREVINREGION;	// 이전 좌표는 영역 안이었다.
	}
	else
	{
		// tool tip 관련
		if (s_pTooltipCtrl != nullptr)
			s_pTooltipCtrl->SetText(m_szToolTip, m_crToolTip);
	}

	dwRet |= UI_MOUSEPROC_INREGION;	// 이번 좌표는 영역 안이다.


	//this_ui
	if(m_pChildUI && m_pChildUI->IsVisible())
		return dwRet;

	// child에게 메세지 전달
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		uint32_t dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{	// 이경우에는 먼가 포커스를 받은 경우이다.
			// (아래 코드는 dialog를 관리하는 곳에서 해야 한다. 따라서 막아놓음)
//			m_Children.erase(itor);			// 우선 리스트에서 지우고
//			m_Children.push_front(pChild);	// 맨앞에 넣는다. 그리는 순서를 맨 나중에 그리도록 하려고

			dwRet |= (UI_MOUSEPROC_CHILDDONESOMETHING|UI_MOUSEPROC_DONESOMETHING);
			return dwRet;
		}
	}

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE != m_eState && 
			PtInRect(&m_rcMovable, ptCur) && (dwFlags&UI_MOUSE_LBCLICK) )
	{
		SetState(UI_STATE_COMMON_MOVE);
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	return dwRet;
}

bool CN3UIBase::EnableTooltip(const std::string& szFN)
{
	delete s_pTooltipCtrl;
	s_pTooltipCtrl = nullptr;
	if (szFN.empty()) return false;
	
	s_pTooltipCtrl = new CN3UITooltip();
	s_pTooltipCtrl->Init(nullptr);
	s_pTooltipCtrl->LoadFromFile(szFN);
	return true;
}

void CN3UIBase::DestroyTooltip()
{
	if (s_pTooltipCtrl) {delete s_pTooltipCtrl; s_pTooltipCtrl = nullptr;}
}

void CN3UIBase::PrintChildIDs()
{
	for (CN3UIBase* pChild : m_Children)
	{
		if (!pChild->m_szID.empty())
			printf("%s\n", pChild->m_szID.c_str());
	}
}

CN3UIBase* CN3UIBase::GetChildByID(const std::string_view szID) const
{
	if (szID.empty())
		return nullptr;

	for (CN3UIBase* pChild : m_Children)
	{
		const std::string& childID = pChild->GetID();
		if (szID.length() == childID.length()
			&& _strnicmp(szID.data(), childID.data(), szID.length()) == 0)
			return pChild;
	}

	return nullptr;
}

CN3UIBase* CN3UIBase::GetChildByID(const std::string_view szID, eUI_TYPE eUIType) const
{
	if (szID.empty())
		return nullptr;

	for (CN3UIBase* pChild : m_Children)
	{
		if (eUIType != pChild->UIType())
			continue;

		const std::string& childID = pChild->GetID();
		if (szID.length() == childID.length()
			&& _strnicmp(szID.data(), childID.data(), szID.length()) == 0)
			return pChild;
	}

	return nullptr;
}

template <eUI_TYPE... UITypes>
static CN3UIBase* GetChildByIDImpl(const CN3UIBase* parent, const std::string_view szID)
{
	if (szID.empty())
		return nullptr;

	for (CN3UIBase* pChild : parent->GetChildren())
	{
		// Use a fold expression here to include all of the supported types.
		if (((pChild->UIType() != UITypes) && ...))
			continue;

		const std::string& childID = pChild->GetID();
		if (szID.length() == childID.length()
			&& _strnicmp(szID.data(), childID.data(), szID.length()) == 0)
			return pChild;
	}

	return nullptr;
}

#define IMPL_GETCHILDBYID(Class, MainUIType, ...)							\
template <>																	\
Class* CN3UIBase::GetChildByID<Class>(const std::string_view szID) const	\
{																			\
    return static_cast<Class*>(												\
		GetChildByIDImpl<MainUIType, ##__VA_ARGS__>(this, szID));			\
}

// Preferred behaviour for this specialization would be to just use the base class, and not require UI_TYPE_BASE.
// This is achievable with the method it already resolves to.
// If we truly require verifying it is in fact UI_TYPE_BASE (which is pointless), the caller can pass it to the
// base call themselves.
// IMPL_GETCHILDBYID(CN3UIBase,		UI_TYPE_BASE);

IMPL_GETCHILDBYID(CN3UIArea,		UI_TYPE_AREA);
IMPL_GETCHILDBYID(CN3UIButton,		UI_TYPE_BUTTON);
IMPL_GETCHILDBYID(CN3UIEdit,		UI_TYPE_EDIT);
IMPL_GETCHILDBYID(CN3UIImage,		UI_TYPE_IMAGE);
IMPL_GETCHILDBYID(CN3UIList,		UI_TYPE_LIST);
IMPL_GETCHILDBYID(CN3UIProgress,	UI_TYPE_PROGRESS);
IMPL_GETCHILDBYID(CN3UIScrollBar,	UI_TYPE_SCROLLBAR);
IMPL_GETCHILDBYID(CN3UIStatic,		UI_TYPE_STATIC, UI_TYPE_EDIT);	// CN3UIEdit inherits from CN3UIStatic
IMPL_GETCHILDBYID(CN3UIString,		UI_TYPE_STRING);
IMPL_GETCHILDBYID(CN3UITooltip,		UI_TYPE_TOOLTIP);
IMPL_GETCHILDBYID(CN3UITrackBar,	UI_TYPE_TRACKBAR);

#undef IMPL_GETCHILDBYID

void CN3UIBase::SetVisible(bool bVisible)
{
	// No change
	if (bVisible == m_bVisible)
		return;

	// update state
	m_bVisible = bVisible;

	// UI element made visible
	if (bVisible)
	{
		// play open sound, if defined
		if (m_pSnd_OpenUI != nullptr)
			m_pSnd_OpenUI->Play();
	}
	// UI element hidden
	else
	{
		// play close sound, if defined
		if (m_pSnd_CloseUI != nullptr)
			m_pSnd_CloseUI->Play();

		// hide child UI and delink pointer
		if (m_pChildUI != nullptr)
			m_pChildUI->SetVisible(false);

		m_pChildUI = nullptr;

		// delink pointer to parent
		if (m_pParentUI != nullptr
			&& m_pParentUI->m_pChildUI == this)
			m_pParentUI->m_pChildUI = nullptr;

		m_pParentUI = nullptr;
		m_iChildID	= -1;
	}
}

void CN3UIBase::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{ 
	m_bVisible = bVisible; 
	if(!m_bVisible)
	{
		if(m_pChildUI)
		{
			m_pChildUI->SetVisible(false);
		}
		m_pChildUI	= nullptr;
		if(m_pParentUI)
		{
			if(m_pParentUI->m_pChildUI == this)
				m_pParentUI->m_pChildUI = nullptr;
		}
		m_pParentUI = nullptr;
		m_iChildID	= -1;
	}
}

#ifndef _N3TOOL
void CN3UIBase::operator = (const CN3UIBase& other)
{
	Init(nullptr);	// 일단 부모는 없게 초기화

	UIListItorConst it = other.m_Children.begin();
	UIListItorConst itEnd = other.m_Children.end();
	CN3UIBase* pOtherChild = nullptr;
	CN3UIBase* pChild = nullptr;
	for(; it != itEnd; it++)
	{
		pOtherChild = *it;

		if(nullptr == pOtherChild) continue;

		pChild = nullptr;
		switch(pOtherChild->UIType())
		{
		case UI_TYPE_BASE:
			{ 
				pChild = new CN3UIBase();
				*pChild = *pOtherChild;
			}
			break;
		case UI_TYPE_BUTTON:
			{
				CN3UIButton *pUINew = new CN3UIButton();
				*pUINew = *((CN3UIButton*)pOtherChild);
				pChild = pUINew;
			}
			break;	// button
		case UI_TYPE_STATIC:	
			{ 
				CN3UIStatic* pUINew = new CN3UIStatic();		
				*pUINew = *((CN3UIStatic*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// static (배경그림과 글자가 나오는 클래스)
		case UI_TYPE_PROGRESS:	
			{ 
				CN3UIProgress* pUINew = new CN3UIProgress();	
				*pUINew = *((CN3UIProgress*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// progress
		case UI_TYPE_IMAGE:		
			{ 
				CN3UIImage* pUINew = new CN3UIImage();		
				*pUINew = *((CN3UIImage*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// image
		case UI_TYPE_SCROLLBAR:	
			{ 
				CN3UIScrollBar* pUINew = new CN3UIScrollBar();	
				*pUINew = *((CN3UIScrollBar*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// scroll bar
		case UI_TYPE_STRING:	
			{ 
				CN3UIString* pUINew = new CN3UIString();		
				*pUINew = *((CN3UIString*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// string
		case UI_TYPE_TRACKBAR:	
			{ 
				CN3UITrackBar* pUINew = new CN3UITrackBar();	
				*pUINew = *((CN3UITrackBar*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// track bar
		case UI_TYPE_EDIT:		
			{ 
				CN3UIEdit* pUINew = new CN3UIEdit();		
				*pUINew = *((CN3UIEdit*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// edit
		case UI_TYPE_AREA:		
			{ 
				CN3UIArea* pUINew = new CN3UIArea();		
				*pUINew = *((CN3UIArea*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// area
		case UI_TYPE_TOOLTIP:
			{ 
				CN3UITooltip* pUINew = new CN3UITooltip();
				*pUINew = *((CN3UITooltip*)pOtherChild);
				pChild = pUINew;
			} 
			break;	// tooltip
		case UI_TYPE_LIST:
			{ 
				CN3UIList* pUINew = new CN3UIList();
				*pUINew = *((CN3UIList*)pOtherChild);
				pChild = pUINew;
			} 
			break;	// tooltip
//		case UI_TYPE_ICON:		pUIDest = new CN3UIIcon();		*pUIDest = *((CN3UIBase*)pUISrc); break;	// icon
//		case UI_TYPE_ICON_MANAGER:	pUIDest = new CN3UIIconManager();	*pUIDest = *((CN3UIBase*)pUISrc); break;	// icon manager.. 
#ifdef _REPENT
		case UI_TYPE_ICONSLOT:
			{
				CN3UIIconSlot* pUINew = new CN3UIIconSlot();
				*pUINew = *((CN3UIIconSlot*)pOtherChild);
				pChild = pUINew;
			}
			break;	// icon slot
#endif
		}
		if(pChild) pChild->SetParent(this);	// 부모 지정
	}

	m_bVisible = other.m_bVisible;
	m_dwReserved = other.m_dwReserved;
	m_dwStyle = other.m_dwStyle;
	m_eState = other.m_eState;
	m_eType = other.m_eType;

	if(other.m_pSnd_OpenUI)
	{
		CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_OpenUI);
		m_pSnd_OpenUI = s_SndMgr.CreateObj(other.m_pSnd_OpenUI->m_szFileName, SNDTYPE_2D);
	}

	if(other.m_pSnd_CloseUI)
	{
		CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_CloseUI);
		m_pSnd_CloseUI = s_SndMgr.CreateObj(other.m_pSnd_CloseUI->m_szFileName, SNDTYPE_2D);
	}

	m_rcMovable = other.m_rcMovable;
	m_rcRegion = other.m_rcRegion;
	m_szID = other.m_szID;
	m_szToolTip = other.m_szToolTip;
}
#endif

#ifdef _N3TOOL
bool CN3UIBase::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	// child 정보
	int iCC = static_cast<int>(m_Children.size());

	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
	{	
		int16_t sCC = static_cast<int16_t>(iCC);
		int16_t sIdk0 = 1; // unknown

		file.Write(&sCC, sizeof(int16_t)); // children count
		file.Write(&sIdk0, sizeof(int16_t)); //unknown
	}
	else
	{
		file.Write(&iCC, sizeof(iCC));
	}

	//file.Write(&iCC, sizeof(iCC)); // Child 갯수 ㅆ고..고..

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	// childadd할때 push_front이므로 저장할 때 거꾸로 저장해야 한다.
	{
		CN3UIBase* pChild = (*itor);
		eUI_TYPE eUIType = pChild->UIType();

		file.Write(&eUIType, sizeof(eUIType)); // UI Type 쓰고..
		pChild->Save(file);
	}

	// base 정보
	int iIDLen = static_cast<int>(m_szID.size());
	file.Write(&iIDLen, sizeof(iIDLen));					// id length
	if (iIDLen > 0)
		file.Write(m_szID.c_str(), iIDLen);				// ui id
	file.Write(&m_rcRegion, sizeof(m_rcRegion));			// m_rcRegion
	file.Write(&m_rcMovable, sizeof(m_rcMovable));		// m_rcMovable
	file.Write(&m_dwStyle, sizeof(m_dwStyle));			// style
	file.Write(&m_dwReserved, sizeof(m_dwReserved));		//	m_dwReserved

	int iTooltipLen = static_cast<int>(m_szToolTip.size());
	file.Write(&iTooltipLen, sizeof(iTooltipLen));		//	tooltip문자열 길이
	if (iTooltipLen > 0)
		file.Write(m_szToolTip.c_str(), iTooltipLen);

	int iSndFNLen = 0;
	if (m_pSnd_OpenUI != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_OpenUI->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));			//	사운드 파일 문자열 길이
	if (iSndFNLen>0) file.Write(m_pSnd_OpenUI->m_szFileName.c_str(), iSndFNLen);

	iSndFNLen = 0;
	if (m_pSnd_CloseUI != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_CloseUI->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));			//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
		file.Write(m_pSnd_CloseUI->m_szFileName.c_str(), iSndFNLen);
	
	return true;
}

void CN3UIBase::ChangeImagePath(const std::string& szPathOld, const std::string& szPathNew)
{
	// child 정보
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->ChangeImagePath(szPathOld, szPathNew);
	}
}

void CN3UIBase::ChangeFont(const std::string& szFont)
{
	// child 정보
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->ChangeFont(szFont);
	}
}

void CN3UIBase::GatherImageFileName(std::set<std::string>& setImgFile)
{
	// child 정보
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->GatherImageFileName(setImgFile);
	}
}


void CN3UIBase::ResizeAutomaticalyByChild()
{
	if(m_Children.empty()) return;

	RECT rcMax = { 100000000, 100000000, -100000000, -100000000 };
	int iIndex = 0;
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; itor++, iIndex++)
	{
		CN3UIBase* pChild = (*itor);
		RECT rcTmp = pChild->GetRegion();
		if(rcTmp.left < rcMax.left) rcMax.left = rcTmp.left;
		if(rcTmp.top < rcMax.top) rcMax.top = rcTmp.top;
		if(rcTmp.right > rcMax.right) rcMax.right = rcTmp.right;
		if(rcTmp.bottom > rcMax.bottom) rcMax.bottom = rcTmp.bottom;
	}

	RECT rcCur = this->GetRegion();
	if(rcCur.left > rcMax.left) rcCur.left = rcMax.left;
	if(rcCur.top > rcMax.top) rcCur.top = rcMax.top;
	if(rcCur.right < rcMax.right) rcCur.right = rcMax.right;
	if(rcCur.bottom < rcMax.bottom) rcCur.bottom = rcMax.bottom;
//	this->SetRegion(rcCur);
	m_rcRegion = rcCur;	// SetRegion을 해버리면 child의 영역을 바꿔버리는 경우가 있으므로 내 영역만 바꾸기위해 직접 넣는다.
}

int CN3UIBase::IsMyChild(CN3UIBase* pUI)
{
	int iIndex = 0;
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; itor++, iIndex++)
	{
		CN3UIBase* pChild = (*itor);
		if(pChild == pUI) return iIndex;
	}

	return -1;
}

bool CN3UIBase::SwapChild(CN3UIBase* pChild1, CN3UIBase* pChild2)
{
	if(this->IsMyChild(pChild1) < 0 || IsMyChild(pChild2) < 0) return false;
	
	UIListItor itor1;
	for(itor1 = m_Children.begin(); m_Children.end() != itor1; itor1++)
		if(*itor1 == pChild1) break;
	if(itor1 == m_Children.end()) return false;

	UIListItor itor2;
	for(itor2 = m_Children.begin(); m_Children.end() != itor2; itor2++)
		if(*itor2 == pChild2) break;
	if(itor2 == m_Children.end()) return false;

	std::swap(*itor1, *itor2);

	return true;
}

bool CN3UIBase::MoveToHighest(CN3UIBase* pChild)
{
	if(this->IsMyChild(pChild) < 0) return false;
	
	for(UIListItor itor1 = m_Children.begin(); m_Children.end() != itor1; itor1++)
	{
		if(*itor1 == pChild) 
		{
			m_Children.erase(itor1);
			m_Children.push_front(pChild);
			return true;
		}
	}

	return false;
}

bool CN3UIBase::MoveToLowest(CN3UIBase* pChild)
{
	if(this->IsMyChild(pChild) < 0) return false;
	
	for(UIListItor itor1 = m_Children.begin(); m_Children.end() != itor1; itor1++)
	{
		if(*itor1 == pChild) 
		{
			m_Children.erase(itor1);
			m_Children.push_back(pChild);
			return true;
		}
	}

	return false;
}

bool CN3UIBase::MoveToLower(CN3UIBase* pChild)
{
	if(this->IsMyChild(pChild) < 0) return false;
	
	for(UIListItor itor1 = m_Children.begin(); itor1 != m_Children.end(); itor1++)
	{
		if(*itor1 == pChild)
		{
			UIListItor itNext = itor1; itNext++;
			if(itNext != m_Children.end())
			{
				std::swap(*itNext, *itor1);
				return true;
			}
			break;
		}
	}

	return false;
}

bool CN3UIBase::MoveToUpper(CN3UIBase* pChild)
{
	if(this->IsMyChild(pChild) < 0) return false;
	
	for(UIListItor itor1 = m_Children.begin(); itor1 != m_Children.end(); itor1++)
	{
		if(*itor1 == pChild) 
		{
			if(itor1 != m_Children.begin())
			{
				UIListItor itPrev = itor1; itPrev--;
				std::swap(*itPrev, *itor1);
				return true;
			}
			break;
		}
	}

	return false;
}

void CN3UIBase::ArrangeZOrder()
{
	// 보통 image가 배경그림이 되므로 child list에서 맨 뒤로 보낸다.
	// 왜냐하면 맨 뒤에 있는것이 맨 먼저 그려지므로
	UIList tempList;
	UIListItor itor;
	for(itor = m_Children.begin(); m_Children.end() != itor;)
	{
		CN3UIBase* pChild = (*itor);
		if(UI_TYPE_IMAGE == pChild->UIType())
		{
			itor = m_Children.erase(itor);	// 현재 위치에서 지우고
			tempList.push_back(pChild);		// 임시 버퍼에 저장
		}
		else ++itor;
	}

	for(itor = tempList.begin(); tempList.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		m_Children.push_back(pChild);		// child list맨 뒤에 넣기
	}
	tempList.clear();
}

void CN3UIBase::operator = (const CN3UIBase& other)
{
	Init(nullptr);	// 일단 부모는 없게 초기화

	UIListItorConst it = other.m_Children.begin();
	UIListItorConst itEnd = other.m_Children.end();
	CN3UIBase* pOtherChild = nullptr;
	CN3UIBase* pChild = nullptr;
	for(; it != itEnd; it++)
	{
		pOtherChild = *it;

		if(nullptr == pOtherChild) continue;

		pChild = nullptr;
		switch(pOtherChild->UIType())
		{
		case UI_TYPE_BASE:
			{ 
				pChild = new CN3UIBase();
				*pChild = *pOtherChild;
			}
			break;
		case UI_TYPE_BUTTON:
			{
				CN3UIButton *pUINew = new CN3UIButton();
				*pUINew = *((CN3UIButton*)pOtherChild);
				pChild = pUINew;
			}
			break;	// button
		case UI_TYPE_STATIC:	
			{ 
				CN3UIStatic* pUINew = new CN3UIStatic();		
				*pUINew = *((CN3UIStatic*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// static (배경그림과 글자가 나오는 클래스)
		case UI_TYPE_PROGRESS:	
			{ 
				CN3UIProgress* pUINew = new CN3UIProgress();	
				*pUINew = *((CN3UIProgress*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// progress
		case UI_TYPE_IMAGE:		
			{ 
				CN3UIImage* pUINew = new CN3UIImage();		
				*pUINew = *((CN3UIImage*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// image
		case UI_TYPE_SCROLLBAR:	
			{ 
				CN3UIScrollBar* pUINew = new CN3UIScrollBar();	
				*pUINew = *((CN3UIScrollBar*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// scroll bar
		case UI_TYPE_STRING:	
			{ 
				CN3UIString* pUINew = new CN3UIString();		
				*pUINew = *((CN3UIString*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// string
		case UI_TYPE_TRACKBAR:	
			{ 
				CN3UITrackBar* pUINew = new CN3UITrackBar();	
				*pUINew = *((CN3UITrackBar*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// track bar
		case UI_TYPE_EDIT:		
			{ 
				CN3UIEdit* pUINew = new CN3UIEdit();		
				*pUINew = *((CN3UIEdit*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// edit
		case UI_TYPE_AREA:		
			{ 
				CN3UIArea* pUINew = new CN3UIArea();		
				*pUINew = *((CN3UIArea*)pOtherChild); 
				pChild = pUINew;
			} 
			break;	// area
		case UI_TYPE_TOOLTIP:
			{ 
				CN3UITooltip* pUINew = new CN3UITooltip();
				*pUINew = *((CN3UITooltip*)pOtherChild);
				pChild = pUINew;
			} 
			break;	// tooltip
		case UI_TYPE_LIST:
			{ 
				CN3UIList* pUINew = new CN3UIList();
				*pUINew = *((CN3UIList*)pOtherChild);
				pChild = pUINew;
			} 
			break;	// tooltip
//		case UI_TYPE_ICON:		pUIDest = new CN3UIIcon();		*pUIDest = *((CN3UIBase*)pUISrc); break;	// icon
//		case UI_TYPE_ICON_MANAGER:	pUIDest = new CN3UIIconManager();	*pUIDest = *((CN3UIBase*)pUISrc); break;	// icon manager.. 
#ifdef _REPENT
		case UI_TYPE_ICONSLOT:
			{
				CN3UIIconSlot* pUINew = new CN3UIIconSlot();
				*pUINew = *((CN3UIIconSlot*)pOtherChild);
				pChild = pUINew;
			}
			break;	// icon slot
#endif
		}
		if(pChild) pChild->SetParent(this);	// 부모 지정
	}

	m_bVisible = other.m_bVisible;
	m_dwReserved = other.m_dwReserved;
	m_dwStyle = other.m_dwStyle;
	m_eState = other.m_eState;
	m_eType = other.m_eType;

	SetSndOpen(other.GetSndFName_OpenUI());
	SetSndClose(other.GetSndFName_CloseUI());

	m_rcMovable = other.m_rcMovable;
	m_rcRegion = other.m_rcRegion;
	m_szID = other.m_szID;
	m_szToolTip = other.m_szToolTip;
}

void CN3UIBase::SetSndOpen(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_OpenUI);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_OpenUI = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

void CN3UIBase::SetSndClose(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_CloseUI);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_CloseUI = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

std::string CN3UIBase::GetSndFName_OpenUI() const
{
	if (m_pSnd_OpenUI) return m_pSnd_OpenUI->m_szFileName;
	else return std::string("");
}

std::string CN3UIBase::GetSndFName_CloseUI() const
{
	if (m_pSnd_CloseUI) return m_pSnd_CloseUI->m_szFileName;
	else return std::string("");
}

bool CN3UIBase::ReplaceAllTextures(const std::string& strFind, const std::string& strReplace)
{
	if (strFind.size() <= 0 || strReplace.size() <= 0) return false;
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		if (false == (*itor)->ReplaceAllTextures(strFind, strReplace)) return false;
	}
	return true;
}

#endif	// _N3TOOL

// ===== END N3Base/N3UIBase.cpp =====

// ===== BEGIN N3Base/N3UIBase.h =====
#line 1 "N3Base/N3UIBase.h"
﻿// N3UIBase.h: interface for the CN3UIBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UI_H__5F1578F8_8476_4647_8C53_E22A5F6184FE__INCLUDED_)
#define AFX_N3UI_H__5F1578F8_8476_4647_8C53_E22A5F6184FE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"
#include "N3UIDef.h"
#include <list>
#include <set>
#include <string>

#define N3_VERIFY_UI_COMPONENT(varName, lookupResult) { \
	varName = lookupResult; \
	__ASSERT(varName != nullptr, "NULL UI Component!!!"); \
}

class CN3UIBase;

typedef std::list<CN3UIBase*>			UIList;
typedef UIList::iterator				UIListItor;
typedef UIList::const_iterator			UIListItorConst;
typedef UIList::reverse_iterator		UIListReverseItor;

class CN3UIImage;
class CN3UIString;
class CN3UIButton;
class CN3UIStatic;
class CN3UIProgress;
class CN3UITrackBar;
class CN3UIScrollBar;
class CN3UIEdit;
class CN3UITooltip;
class CN3UIArea;
class CN3SndObj;
class CN3UIList;

class CN3UIBase : public CN3BaseFileAccess
{
//friend class CN3IME;
#ifdef _N3TOOL
friend class CN3UIBase;
friend class CHierarchyView;	// 툴에서 child list를 접근하기 위해서.
friend class CPropertyView;	// 툴에서 각 변수들을 접근하기 위해서 
friend class CUIEView;	// 툴에서 child list를 접근하기 위해서.
#endif

public:
	static constexpr D3DCOLOR DefaultTooltipColor = D3DCOLOR_XRGB(255, 255, 255);

#ifdef _N3GAME
	static bool s_bWaitFromServer;
#endif

	std::string m_szID;			// UI id
	std::string	m_szToolTip;	// tooltip text
	D3DCOLOR	m_crToolTip;

	void SetID(const std::string& szID)
	{
		m_szID = szID;
	}

	const std::string& GetID() const
	{
		return m_szID;
	}

	void SetTooltipText(const std::string& szTooltipText)
	{
		m_szToolTip = szTooltipText;
	}

	void SetTooltipColor(D3DCOLOR crTooltip)
	{
		m_crToolTip = crTooltip;
	}

	static CN3UITooltip*	s_pTooltipCtrl;		// tool tip
	
	CN3UIBase*	m_pChildUI;		// UI 부속이 아니라 다른 UI를 자식으로 갖는다..
	CN3UIBase*	m_pParentUI;

protected:
	static std::string	s_szStringTmp;		// 임시 문자열.. 포인터를 넘기기 위해서이다..

	int			m_iChildID;
	CN3UIBase*	m_pParent;		// parent pointer
	UIList		m_Children;		// children pointer list
	eUI_TYPE	m_eType;		// UI Type - button, image .....
	eUI_STATE	m_eState;		// UI state
	uint32_t	m_dwStyle;		// style
	uint32_t	m_dwReserved;	// 기타 임시로 넣고 싶은 정보를 넣으면 된다.

	RECT		m_rcRegion;		// UI - screen coordinates (screen : main window client area) 중의 : 부모에 대한 상대좌표가 아니다.
	RECT		m_rcMovable;	// UI를 드래그 하여 움직이게 할 수 있는 영역 - (screen : main window client area)           ~~~~~~~

	bool		m_bVisible;		// 화면에 보이는가 (부모가 보이지 않으면 자식들은 render 하지 않는다.)
	CN3SndObj*	m_pSnd_OpenUI;	// UI가 화면에 보이는 순간 내는 소리
	CN3SndObj*	m_pSnd_CloseUI;	// UI가 화면에서 사라지는 순간 내는 소리

	static CN3UIEdit*		s_pFocusedEdit;		// 현재 포커스를 가지고 있는 Edit, nullptr이면 아무도 포커스를 가지고 있지 않다.
	
public:
	CN3UIBase();
	~CN3UIBase() override;

// Attributes
public:
	void			PrintChildIDs();
	eUI_TYPE		UIType() const { return m_eType; }
	eUI_STATE 		GetState() const { return m_eState; }
	bool			IsVisible()	const { return m_bVisible; }
	RECT			GetRegion() const { return m_rcRegion; }
	void			SetMoveRect(const RECT& Rect) { m_rcMovable = Rect; }
	RECT			GetMoveRect() { return m_rcMovable; }
	void			SetReserved(uint32_t dwReserved) {m_dwReserved = dwReserved;}
	uint32_t		GetReserved() const {return m_dwReserved;}
	CN3UIBase*		GetParent() const {return m_pParent;}
	static CN3UIEdit*	GetFocusedEdit() {return s_pFocusedEdit;}
	static CN3UITooltip*	GetTooltipCtrl() {return s_pTooltipCtrl;}
	uint32_t		GetStyle()	{return m_dwStyle;}

	const UIList& GetChildren() const
	{
		return m_Children;
	}

	void			SetUIType(eUI_TYPE eUIType) { m_eType = eUIType; }	// by ecli666 툴에 기능 넣기 귀찮아서.. ^^
// Operations
public:	
	bool			IsIn(int x, int y);
	void			AddChild(CN3UIBase* pChild) { m_Children.push_front(pChild); }
	void			RemoveChild(CN3UIBase* pChild); // 자식 리스트에서 포인터만 없어지고 실제로 delete 되지는 않는다.
	void			SetParent(CN3UIBase* pParent);	// 부모를 바꾼다.
	int				GetWidth() { return m_rcRegion.right - m_rcRegion.left; }
	int				GetHeight() { return m_rcRegion.bottom - m_rcRegion.top; }
	POINT			GetPos() const;
	virtual void	SetPos(int x, int y);	// 위치 지정(chilren의 위치도 같이 바꾸어준다.) 내부적으로 MoveOffset함수를 부른다.
	void			SetPosCenter();	// 화면 정가운데로 맞추어준다..(chilren의 위치도 같이 바꾸어준다.) 내부적으로 MoveOffset함수를 부른다.

	// Find first control matching the specified ID.
	CN3UIBase*		GetChildByID(const std::string_view szID) const;

	// Find first control matching both the specified ID and UI type.
	CN3UIBase*		GetChildByID(const std::string_view szID, eUI_TYPE eUIType) const;

	template <typename T>
	T* GetChildByID(const std::string_view szID) const;

	virtual void	SetRegion(const RECT& pRect) { m_rcRegion = pRect; }	// 영역 지정
	virtual BOOL	MoveOffset(int iOffsetX, int iOffsetY);	// offset만큼 이동해준다.(region, children, move rect 이동)
	virtual void	SetSize(int iWidth, int iHeight);	// 크기 지정
	virtual void	SetState(eUI_STATE eState) { m_eState = eState; }
	virtual void	SetStyle(uint32_t dwStyle) {m_dwStyle = dwStyle;}	// style지정
	virtual void	SetVisible(bool bVisible);

	virtual void	SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false);

	virtual void	CallBackProc(int iID, uint32_t dwFlag);
	virtual void	ShowWindow(int iID = -1, CN3UIBase* pParent = nullptr);
	bool			Load(File& file) override;
	virtual bool	ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg); // 메시지를 받는다.. 보낸놈, msg
	virtual uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	virtual void	Tick();
	virtual void	Render();
	void			Release() override; // 자식 포인터까지 delete 한다..
	virtual void	Init(CN3UIBase* pParent);
	virtual bool	OnKeyPress(int iKey) { return false; }
	virtual bool	OnKeyPressed(int iKey) { return false; }
	virtual bool	OnMouseWheelEvent(short delta) { return false; }

	static	bool	EnableTooltip(const std::string& szFN);	// tooltip UI를 초기화 해준다.
	static	void	DestroyTooltip();	// tooltip ui에 관련된 것을 해제해준다.

	int GetChildrenCount() const
	{
		return static_cast<int>(m_Children.size());
	}

	CN3UIBase* GetChildByIndex(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_Children.size()))
			return nullptr;

		auto it = m_Children.begin();
		std::advance(it, iIndex);
		return *it;
	}

	virtual void	operator = (const CN3UIBase& other);

protected:

#ifdef _N3TOOL
public:
	bool			Save(File& file) override;
	virtual void	ChangeImagePath(const std::string& szPathOld, const std::string& szPathNew);
	virtual void	ChangeFont(const std::string& szFont);
	virtual void	GatherImageFileName(std::set<std::string>& setImgFile);
	
	void			ResizeAutomaticalyByChild();
	int				IsMyChild(CN3UIBase* pUI);
	bool			SwapChild(CN3UIBase* pChild1, CN3UIBase* pChild2);
	
	bool			MoveToLower(CN3UIBase* pChild);
	bool			MoveToUpper(CN3UIBase* pChild);
	bool			MoveToLowest(CN3UIBase* pChild);
	bool			MoveToHighest(CN3UIBase* pChild);
	
	void			ArrangeZOrder();
	RECT			GetMoveRect() const {return m_rcMovable;}
	//void			SetMoveRect(RECT rc) {m_rcMovable = rc;}
	void			SetSndOpen(const std::string& strFileName);
	void			SetSndClose(const std::string& strFileName);
	std::string		GetSndFName_OpenUI() const;
	std::string		GetSndFName_CloseUI() const;

	virtual bool	ReplaceAllTextures(const std::string& strFind, const std::string& strReplace);
#endif
};


#endif // !defined(AFX_N3UI_H__5F1578F8_8476_4647_8C53_E22A5F6184FE__INCLUDED_)

// ===== END N3Base/N3UIBase.h =====

// ===== BEGIN N3Base/N3UIButton.cpp =====
#line 1 "N3Base/N3UIButton.cpp"
﻿// N3UIButton.cpp: implementation of the CN3UIButton class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIButton.h"
#include "N3UIImage.h"

#include "N3SndMgr.h"
#include "N3SndObj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3UIButton::CN3UIButton()
{
	m_eType = UI_TYPE_BUTTON;

	m_dwStyle = UISTYLE_BTN_NORMAL;
	m_eState = UI_STATE_BUTTON_NORMAL;
	ZeroMemory(m_ImageRef, sizeof(CN3UIImage*)*NUM_BTN_STATE);
	ZeroMemory(&m_rcClick, sizeof(m_rcClick));
	m_pSnd_On = nullptr;
	m_pSnd_Click = nullptr;
}

CN3UIButton::~CN3UIButton()
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_On);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
}

void CN3UIButton::Release()
{
	CN3UIBase::Release();

	m_dwStyle = UISTYLE_BTN_NORMAL;
	m_eState = UI_STATE_BUTTON_NORMAL;
	ZeroMemory(m_ImageRef, sizeof(CN3UIImage*)*NUM_BTN_STATE);
	ZeroMemory(&m_rcClick, sizeof(m_rcClick));

	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_On);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
}

void CN3UIButton::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	SetClickRect(Rect);
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		(*itor)->SetRegion(Rect);
	}
}

BOOL CN3UIButton::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (FALSE == CN3UIBase::MoveOffset(iOffsetX, iOffsetY)) return FALSE;
	// click 영역
	m_rcClick.left += iOffsetX;		m_rcClick.top += iOffsetY;
	m_rcClick.right += iOffsetX;	m_rcClick.bottom += iOffsetY;	
	return TRUE;
}

void CN3UIButton::Render()
{
 	if(!m_bVisible) return;

	switch(m_eState)
	{
	case UI_STATE_BUTTON_NORMAL:
		{
			if (m_ImageRef[BS_NORMAL]) m_ImageRef[BS_NORMAL]->Render();
		}
		break;
	case UI_STATE_BUTTON_DOWN:
	case UI_STATE_BUTTON_DOWN_2CHECKDOWN:
	case UI_STATE_BUTTON_DOWN_2CHECKUP:
		{
			if (m_ImageRef[BS_DOWN]) m_ImageRef[BS_DOWN]->Render();
		}
		break;
	case UI_STATE_BUTTON_ON:
		{
			if (m_ImageRef[BS_ON]) m_ImageRef[BS_ON]->Render();
		}
		break;
	case UI_STATE_BUTTON_DISABLE:
		{
			if (m_ImageRef[BS_DISABLE]) m_ImageRef[BS_DISABLE]->Render();
		}
	}

	int i = 0;
	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		for(i = 0; i < NUM_BTN_STATE; i++) // 버튼의 구성 요소가 아닌지 보고..
			if(pChild == m_ImageRef[i]) break;
		if(i >= NUM_BTN_STATE) pChild->Render(); // 버튼 차일드가 아니면 렌더링..
	}
}

uint32_t CN3UIButton::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

#ifndef _REPENT
#ifdef _N3GAME
	if (s_bWaitFromServer)
		return dwRet;
#endif
#endif

	if(false == IsIn(ptCur.x, ptCur.y))	// 영역 밖이면
	{
		if (false == IsIn(ptOld.x, ptOld.y))	return dwRet; // 이전 pointer도 영역 밖이었으면 그냥 리턴
		dwRet |= UI_MOUSEPROC_PREVINREGION;	// 이전 마우스 좌표는 영역 안이었다.

		if (UI_STATE_BUTTON_DISABLE == m_eState) return dwRet;	// disable이면 그냥 리턴

		if(UISTYLE_BTN_NORMAL & m_dwStyle) // normal 버튼 이면
		{
			SetState(UI_STATE_BUTTON_NORMAL);	// normal 상태로
		}
		else if (UISTYLE_BTN_CHECK & m_dwStyle) // check 버튼 이면
		{
			if (UI_STATE_BUTTON_DOWN_2CHECKUP == m_eState)	// up시키려다 만 경우 
				SetState(UI_STATE_BUTTON_DOWN);	// down 상태로
			else if (UI_STATE_BUTTON_DOWN_2CHECKDOWN == m_eState ||	// down시키려다 만 경우 또는
				UI_STATE_BUTTON_ON == m_eState)	// on 상태일 경우
				SetState(UI_STATE_BUTTON_NORMAL);	// normal 상태로
		}
		return dwRet; // 영역 밖이므로 더이상 처리 하지 않는다.
	}
	dwRet |= UI_MOUSEPROC_INREGION;	// 이번 마우스 좌표는 영역 안이다

	if (UI_STATE_BUTTON_DISABLE == m_eState) return dwRet;	// disable이면 그냥 리턴

	// 클릭 영역 밖이면
	if (FALSE == PtInRect(&m_rcClick, ptCur))
	{
		if(UISTYLE_BTN_NORMAL & m_dwStyle) // normal 버튼 이면
		{
			SetState(UI_STATE_BUTTON_NORMAL);	// normal 상태로
		}
		else if (UISTYLE_BTN_CHECK & m_dwStyle) // check 버튼 이면
		{
			if (UI_STATE_BUTTON_DOWN_2CHECKUP == m_eState)	// up시키려다 만 경우 
				SetState(UI_STATE_BUTTON_DOWN);	// down 상태로
			else if (UI_STATE_BUTTON_DOWN_2CHECKDOWN == m_eState ||	// down시키려다 만 경우 또는
				UI_STATE_BUTTON_ON == m_eState)	// on 상태일 경우
				SetState(UI_STATE_BUTTON_NORMAL);	// normal 상태로
		}
		return dwRet;
	}

	// 아래는 클릭 영역 안일때..
	// normal 버튼 이면
	if(UISTYLE_BTN_NORMAL & m_dwStyle)
	{
		if(dwFlags & UI_MOUSE_LBCLICK)  // 왼쪽버튼 눌르는 순간
		{
			SetState(UI_STATE_BUTTON_DOWN); // 누른 상태로 만들고..
			if (m_pSnd_Click) m_pSnd_Click->Play();	// 사운드가 있으면 play 하기
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
		else if(dwFlags & UI_MOUSE_LBCLICKED) // 왼쪽버튼을 떼는 순간
		{
			if(m_pParent && UI_STATE_BUTTON_DOWN == m_eState) // 이전 상태가 버튼을 Down 상태이면
			{
				SetState(UI_STATE_BUTTON_ON); // 버튼을 On 상태로 만든다..
				m_pParent->ReceiveMessage(this, UIMSG_BUTTON_CLICK); // 부모에게 버튼 클릭 통지..
			}
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
		else if (UI_STATE_BUTTON_NORMAL == m_eState)	// normal상태이면 on상태로..
		{
			SetState(UI_STATE_BUTTON_ON); // On 상태로 만들고..
			if (m_pSnd_On) m_pSnd_On->Play();	// 사운드가 있으면 play 하기
			dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
			return dwRet;
			// UI_MOUSEPROC_DONESOMETHING를 넣으면 안된다.(마우스 포인터가 버튼에서 다른 버튼으로 빠르게 옮겨갈때 
			// 이전 버튼의 상태가 이상해지는 것을 방지하기 위해)
		}
	}

	// 체크 버튼이면
	else if(UISTYLE_BTN_CHECK & m_dwStyle) 
	{
		if(dwFlags & UI_MOUSE_LBCLICK)  // 왼쪽버튼 눌르는 순간
		{
			if (UI_STATE_BUTTON_NORMAL == m_eState || UI_STATE_BUTTON_ON == m_eState)
			{
				SetState(UI_STATE_BUTTON_DOWN_2CHECKDOWN); // 임시로 누른 상태(DOWN_2CHECKDOWN)로 만들고..
				if (m_pSnd_Click) m_pSnd_Click->Play();	// 사운드가 있으면 play 하기
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
			else if(UI_STATE_BUTTON_DOWN == m_eState)
			{
				SetState(UI_STATE_BUTTON_DOWN_2CHECKUP); // 임시로 누른 상태(DOWN_2CHECKUP)로 만들고..
				if (m_pSnd_Click) m_pSnd_Click->Play();	// 사운드가 있으면 play 하기
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
		}
		else if(dwFlags & UI_MOUSE_LBCLICKED)  // 왼쪽버튼 떼는 순간
		{
			if(UI_STATE_BUTTON_DOWN_2CHECKDOWN == m_eState) // 이전 상태가 2CHECKDOWN 상태이면
			{
				SetState(UI_STATE_BUTTON_DOWN); // down 상태로 만들기
				if (m_pParent) m_pParent->ReceiveMessage(this, UIMSG_BUTTON_CLICK); // 부모에게 버튼 클릭 통지..
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
			else if (UI_STATE_BUTTON_DOWN_2CHECKUP == m_eState) // 전의 상태가 2CHECKUP 상태이면
			{
				SetState(UI_STATE_BUTTON_ON); // On 상태로 만들기
				if (m_pParent) m_pParent->ReceiveMessage(this, UIMSG_BUTTON_CLICK); // 부모에게 버튼 클릭 통지..
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
		}
		else if (UI_STATE_BUTTON_NORMAL == m_eState)	// normal상태이면 on상태로..
		{
			SetState(UI_STATE_BUTTON_ON); // On 상태로 만들고..
			if (m_pSnd_On) m_pSnd_On->Play();	// 사운드가 있으면 play 하기
			dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
			return dwRet;
			// UI_MOUSEPROC_DONESOMETHING를 넣으면 안된다.(마우스 포인터가 버튼에서 다른 버튼으로 빠르게 옮겨갈때 
			// 이전 버튼의 상태가 이상해지는 것을 방지하기 위해)
		}

	}
	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

bool CN3UIButton::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	file.Read(&m_rcClick, sizeof(m_rcClick));	// click 영역

	// m_ImageRef 설정하기
	for (CN3UIBase* pChild : m_Children)
	{
		if (UI_TYPE_IMAGE != pChild->UIType())
			continue;	// image만 골라내기

		int iBtnState = (int) (pChild->GetReserved());
		if (iBtnState < NUM_BTN_STATE)
			m_ImageRef[iBtnState] = (CN3UIImage*) pChild;
	}

	std::string filename;

	// 이전 uif파일을 컨버팅 하려면 사운드 로드 하는 부분 막기
	int iSndFNLen = 0;
	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		filename.assign(iSndFNLen, '\0');
		file.Read(&filename[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_On, "memory leak");
		m_pSnd_On = s_SndMgr.CreateObj(filename, SNDTYPE_2D);
	}

	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		filename.assign(iSndFNLen, '\0');
		file.Read(&filename[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_Click, "memory leak");
		m_pSnd_Click = s_SndMgr.CreateObj(filename, SNDTYPE_2D);
	}

	return true;
}

void CN3UIButton::operator = (const CN3UIButton& other)
{
	CN3UIBase::operator = (other);

	m_rcClick = other.m_rcClick;			// 클릭 영역
	SetSndOn(other.GetSndFName_On());		// 사운드
	SetSndClick(other.GetSndFName_Click());	// 사운드

	// m_ImageRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE != pChild->UIType()) continue;	// image만 골라내기
		int iBtnState = (int)(pChild->GetReserved());
		if (iBtnState<NUM_BTN_STATE)
		{
			m_ImageRef[iBtnState] = (CN3UIImage*)pChild;
		}
	}
}

#ifdef _N3TOOL
bool CN3UIButton::Save(File& file)
{
	if (!CN3UIBase::Save(file))
		return false;

	file.Write(&m_rcClick, sizeof(m_rcClick));		// click 영역

	int iSndFNLen = 0;
	if (m_pSnd_On != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_On->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
		file.Write(m_pSnd_On->m_szFileName.c_str(), iSndFNLen);

	iSndFNLen = 0;
	if (m_pSnd_Click != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_Click->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
		file.Write(m_pSnd_Click->m_szFileName.c_str(), iSndFNLen);

	return true;
}

// 툴에서 사용하기 위한 함수 : n3uiImage를 생성한다.
void CN3UIButton::CreateImages()
{
	int i;
	for (i=0; i<NUM_BTN_STATE; ++i)
	{
		__ASSERT(nullptr == m_ImageRef[i],"이미지가 이미 할당되어 있어여");
		m_ImageRef[i] = new CN3UIImage();
		m_ImageRef[i]->Init(this);
		m_ImageRef[i]->SetRegion(m_rcRegion);

		m_ImageRef[i]->SetReserved(i);		// 상태 번호(eBTN_STATE) 할당.
	}
}
#endif

void CN3UIButton::SetSndOn(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_On);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_On = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

void CN3UIButton::SetSndClick(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_Click = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

std::string CN3UIButton::GetSndFName_On() const
{
	if (m_pSnd_On) return m_pSnd_On->m_szFileName;
	else return std::string("");
}

std::string CN3UIButton::GetSndFName_Click() const
{
	if (m_pSnd_Click) return m_pSnd_Click->m_szFileName;
	else return std::string("");
}


// ===== END N3Base/N3UIButton.cpp =====

// ===== BEGIN N3Base/N3UIButton.h =====
#line 1 "N3Base/N3UIButton.h"
﻿// N3UIButton.h: interface for the CN3UIButton class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIBUTTON_H__7A7B3E89_9D17_45E8_8405_87877F3E6FF0__INCLUDED_)
#define AFX_N3UIBUTTON_H__7A7B3E89_9D17_45E8_8405_87877F3E6FF0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"
class CN3UIImage;
class CN3SndObj;
class CN3UIButton : public CN3UIBase  
{
public:
	CN3UIButton();
	virtual ~CN3UIButton();

// Attributes
public:
	enum eBTN_STATE	{BS_NORMAL=0, BS_DOWN, BS_ON, BS_DISABLE, NUM_BTN_STATE};	// button state
	void			SetClickRect(const RECT& Rect) {m_rcClick = Rect;}
	RECT			GetClickRect() const {return m_rcClick;}
protected:
	CN3UIImage*		m_ImageRef[NUM_BTN_STATE];	// 버튼의 각 상태별 image의 참조 포인터(참조인 이유는  children list로 관리하므로 참조만 한다.)
	RECT			m_rcClick;					// click되는 영역

	CN3SndObj*		m_pSnd_On;		// 버튼 위에 마우스가 올라가는 순간 내는 소리
	CN3SndObj*		m_pSnd_Click;	// 버튼이 눌리는 순간 내는 소리

// Operations
public:
	bool	Load(File& file) override;
	void	Release() override;
	void	SetRegion(const RECT& Rect) override;
	BOOL	MoveOffset(int iOffsetX, int iOffsetY) override;

	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	void	Render() override;

// 툴에서 사용하기 위한 함수
public:
	virtual void	operator = (const CN3UIButton& other);
	void			SetSndOn(const std::string& strFileName);
	void			SetSndClick(const std::string& strFileName);

	std::string GetSndFName_On() const;
	std::string GetSndFName_Click() const;

#ifdef _N3TOOL
	bool			Save(File& file) override;
	void			CreateImages();
	CN3UIImage*		GetImageRef(eBTN_STATE eState) const {	return m_ImageRef[eState];}
#endif
};

#endif // !defined(AFX_N3UIBUTTON_H__7A7B3E89_9D17_45E8_8405_87877F3E6FF0__INCLUDED_)


// ===== END N3Base/N3UIButton.h =====

// ===== BEGIN N3Base/N3UIDef.h =====
#line 1 "N3Base/N3UIDef.h"
﻿// N3UIDef.h: 
//
//////////////////////////////////////////////////////////////////////

#if !defined __N3UIDEF_H__
#define __N3UIDEF_H__

#include <string>

#define DIR_UITEXTURE		("Texture\\UI\\")

const float UI_DEFAULT_Z = 0.9f;
const float UI_DEFAULT_RHW = 1.0f;

// type
enum eUI_TYPE	{	UI_TYPE_BASE = 0,		// none
					UI_TYPE_BUTTON,			// button
					UI_TYPE_STATIC,			// static (배경그림과 글자가 나오는 클래스)
					UI_TYPE_PROGRESS,		// progress
					UI_TYPE_IMAGE,			// image
					UI_TYPE_SCROLLBAR,		// scroll bar
					UI_TYPE_STRING,			// string
					UI_TYPE_TRACKBAR,		// track bar
					UI_TYPE_EDIT,			// edit
					
					//cerberus 01,12,29
					UI_TYPE_AREA,			// area
					UI_TYPE_TOOLTIP,		// tooltip

					// ecli666
					UI_TYPE_ICON,			// icon
					UI_TYPE_ICON_MANAGER,	// icon manager.. 

					// repent 전용
					UI_TYPE_ICONSLOT,		// icon slot
					UI_TYPE_LIST,			// Text List...
				};

// State
enum eUI_STATE	{	UI_STATE_COMMON_NONE = 0,				// 아무렇지도 않은 그냥 평범한 상태 혹은 아이콘을 가진 윈도우가 아이콘을 선택하지 않은 상태
					UI_STATE_COMMON_MOVE,					// 움직여야 하는 
					UI_STATE_BUTTON_NORMAL,					// 아무렇지도 않은 그냥 평범한 상태..
					UI_STATE_BUTTON_DOWN,					// 버튼이 눌린상태
					UI_STATE_BUTTON_DOWN_2CHECKDOWN,		// 버튼이 임시적으로 눌린 상태(체크 버튼시 사용, 진짜로 눌린 상태가 아니다) 다음에 down상태로
					UI_STATE_BUTTON_DOWN_2CHECKUP,			// 버튼이 임시적으로 눌린 상태(체크 버튼시 사용, 진짜로 눌린 상태가 아니다) 다음에 normal상태로
					UI_STATE_BUTTON_ON,						// 버튼이 켜진 상태.. 
					UI_STATE_BUTTON_DISABLE,				// 버튼이 비활성화된 상태
					UI_STATE_BUTTON_CLICK,					// 버튼이 눌렸다 떨어진 상태 - Click.
					UI_STATE_SCROLLBAR_NULL,				// 아무상태도 아님..
					UI_STATE_SCROLLBAR_TOPBUTTON_DOWN,		// 위로 올리는 버튼이 눌린 상태.
					UI_STATE_SCROLLBAR_BOTTOMBUTTON_DOWN,	// 아래로 내리는 버튼이 눌린상태.
					UI_STATE_EDTCTRL_ACTIVE,
					UI_STATE_EDTCTRL_UNACTIVE,
					UI_STATE_TRACKBAR_THUMBDRAG,			// Thumb를 드래그 하는 중이다.
					UI_STATE_LIST_ENABLE,					// List 에서 선택 가능
					UI_STATE_LIST_DISABLE,					// List 에서 선택 불가능

					// ecli666 (아이콘을 가진 윈도우.. 아이콘 자체는 아니다..)
//					UI_STATE_ICON_NONE,						// 아이콘을 가진 윈도우가 아이콘을 선택하지 않은 상태..
					UI_STATE_ICON_MOVING,					// 아이콘을 가진 윈도우가 아이콘을 움직이고 있는 상태..
//					UI_STATE_ICON_SELECTED,					// 아이콘을 가진 윈도우가 아이콘을 선택한 상태..
					UI_STATE_ICON_WAIT_FROM_SERVER,			// 아이콘을 가진 윈도우가 아이콘을 옮기고 서버로 부터 응답을 기다리는 상태..
					UI_STATE_ICON_DO_SUCCESS,				// 아이콘을 가진 윈도우가 서버로 부터 성공을 받은 상태..
					UI_STATE_ICON_DO_FAIL,					// 아이콘을 가진 윈도우가 서버로 부터 실패를 받은 상태..
					UI_STATE_ICON_DO_RECOVERY,				// 아이콘을 가진 윈도우가 서버로 부터 실패를 받아 복구해야 하는 상태..
				};

// message
const uint32_t UIMSG_BUTTON_CLICK		= 0x00000001;		// normal 버튼 클릭
const uint32_t UIMSG_TRACKBAR_POS		= 0x00000010;		// trackbar의 pos가 변경됨
const uint32_t UIMSG_SCROLLBAR_POS		= 0x00000100;		// scrollbar의 pos가 변경됨.
const uint32_t UIMSG_EDIT_RETURN		= 0x00001000;		// Edit에서 enter가 들어옴
const uint32_t UIMSG_EDIT_TAB			= 0x00002000;		// Edit에서 Tab이 들어옴 - NOTE: Officially this isn't triggered anymore
const uint32_t UIMSG_EDIT_ESCAPE		= 0x00004000;		// Edit에서 esc이 들어옴
const uint32_t UIMSG_ICON_DOWN_FIRST	= 0x00010000;		// Icon에 왼쪽 마우스 버튼 처음으로 다운..
const uint32_t UIMSG_ICON_DOWN			= 0x00020000;		// Icon에 왼쪽 마우스 버튼 다운..
const uint32_t UIMSG_ICON_UP			= 0x00040000;		// Icon에 왼쪽 마우스 버튼 업..
const uint32_t UIMSG_ICON_DBLCLK		= 0x00080000;		// Icon에 버튼 더블 클릭
// const uint32_t UIMSG_AREA_DOWN_FIRST	= 0x00100000;		// Area에 왼쪽 마우스 버튼 처음으로 다운.. - intended for the inventory only, but it's unused. Use UIMSG_BUTTON_CLICK instead.
const uint32_t UIMSG_LIST_SELCHANGE	= 0x00200000;		// List Selection Change..
const uint32_t UIMSG_LIST_DBLCLK		= 0x00400000;
const uint32_t UIMSG_ICON_RDOWN_FIRST	= 0x01000000;		// Icon에 오른쪽 마우스 버튼 처음으로 다운..
const uint32_t UIMSG_ICON_RDOWN		= 0x02000000;		// Icon에 오른쪽 마우스 버튼 다운..
const uint32_t UIMSG_ICON_RUP			= 0x04000000;		// Icon에 오른쪽 마우스 버튼 업..
const uint32_t UIMSG_ICON_RDBLCLK		= 0x08000000;		// Icon에 오른쪽 마우스 더블 클릭
const uint32_t UIMSG_STRING_LCLICK		= 0x10000000;		// string에 마우스가 왼쪽 클릭 되었을때...
const uint32_t UIMSG_STRING_LDCLICK	= 0x20000000;		// string에 마우스가 왼쪽 더블 클릭 되었을때...

// 리펜트용 메세지
const uint32_t UIMSG_ICONSLOT_LBCLICK	= 0x00010000;		// icon slot에 왼쪽 마우스 버튼 클릭
const uint32_t UIMSG_ICONSLOT_RBCLICK	= 0x00020000;		// icon slot에 오른쪽 마우스 버튼 클릭
const uint32_t UIMSG_ICONSLOT_MBCLICK	= 0x00040000;		// icon slot에 왼쪽 마우스 버튼 클릭
const uint32_t UIMSG_ICONSLOT_MOUSEOVER= 0x00080000;		// icon slot에 마우스가 걸쳐 있다.

// mouse flag (localinput.h의 값과 일치해야 한다.)
const uint32_t UI_MOUSE_LBCLICK	= 0x00000001;
const uint32_t UI_MOUSE_LBCLICKED	= 0x00000002;
const uint32_t UI_MOUSE_LBDOWN		= 0x00000004;
const uint32_t UI_MOUSE_MBCLICK	= 0x00000008;
const uint32_t UI_MOUSE_MBCLICKED	= 0x00000010;
const uint32_t UI_MOUSE_MBDOWN		= 0x00000020;
const uint32_t UI_MOUSE_RBCLICK	= 0x00000040;
const uint32_t UI_MOUSE_RBCLICKED	= 0x00000080;
const uint32_t UI_MOUSE_RBDOWN		= 0x00000100;
const uint32_t UI_MOUSE_LBDBLCLK	= 0x00000200;
const uint32_t UI_MOUSE_MBDBLCLK	= 0x00000400;
const uint32_t UI_MOUSE_RBDBLCLK	= 0x00000800;

// mouse procedure return value flag
const uint32_t UI_MOUSEPROC_NONE			= 0x00000000;	// 아무 일도 하지 않았다.
const uint32_t UI_MOUSEPROC_DONESOMETHING	= 0x00000001;	// 먼가 일을 했다.
const uint32_t UI_MOUSEPROC_CHILDDONESOMETHING	= 0x00000002;	// 자식이 먼가 일을 했다.(이 플래그가 설정되어 있으면 항상 UI_MOUSEPROC_DONESOMETHING도 설정되어있다.)
const uint32_t UI_MOUSEPROC_INREGION		= 0x00000004;	// 영역 안에 마우스 포인터가 있다.
const uint32_t UI_MOUSEPROC_PREVINREGION	= 0x00000008;	// 영역 안에 이전 틱의 마우스 포인터가 있었다.
const uint32_t UI_MOUSEPROC_DIALOGFOCUS	= 0x00000010;	// dialog가 포커스 받았다.


// ui_string type
const uint32_t UI_STR_TYPE_LINE			= 0x00000000;	// 스트링 라인 설정 싱글라인인지 멀티라인인지..
const uint32_t UI_STR_TYPE_HALIGN			= 0x00000001;	// 스트링 수평정렬
const uint32_t UI_STR_TYPE_VALIGN			= 0x00000002;	// 스트링 수직정렬

// ui style
const uint32_t UISTYLE_NONE				= 0x00000000;
const uint32_t UISTYLE_ALWAYSTOP			= 0x00000001;	// 항상 최상위에
const uint32_t UISTYLE_MODAL				= 0x00000002;	// modal dialog
const uint32_t UISTYLE_FOCUS_UNABLE		= 0x00000004;	// 포커스를 받을수 없는 유아이
const uint32_t UISTYLE_SHOW_ME_ALONE		= 0x00000008;	// 단지 자기 자신만 열릴수 있는 다른것은 닫혀야한다면..
const uint32_t UISTYLE_HIDE_UNABLE			= 0x00000010;	// 닫히지 않는 유아이
const uint32_t UISTYLE_USER_MOVE_HIDE		= 0x00000020;	// 유저가 움직이면 닫히는 유아이
const uint32_t UISTYLE_POS_LEFT			= 0x00000040;	// 왼쪽에 달린 유아이
const uint32_t UISTYLE_POS_RIGHT			= 0x00000080;	// 오른쪽에 달린 유아이

	// button
const uint32_t UISTYLE_BTN_NORMAL			= 0x00010000;	// 일반 버튼
const uint32_t UISTYLE_BTN_CHECK			= 0x00020000;	// 체크 버튼(toggle버튼)
	// image
const uint32_t UISTYLE_IMAGE_ANIMATE		= 0x00010000;	// 에니메이션 되는 이미지이다.
	// string
const uint32_t UISTYLE_STRING_MULTILINE	= 0x00000000;	// 여러줄로 표시된다.
const uint32_t UISTYLE_STRING_SINGLELINE	= 0x00100000;	// 한줄로만 표시된다.
const uint32_t UISTYLE_STRING_ALIGNLEFT	= 0x00200000;	// 왼쪽 정렬(default)
const uint32_t UISTYLE_STRING_ALIGNRIGHT	= 0x00400000;	// 오른쪽 정렬 (한줄일때만)
const uint32_t UISTYLE_STRING_ALIGNCENTER	= 0x00800000;	// 가운데 정렬 (한줄일때만)
const uint32_t UISTYLE_STRING_ALIGNTOP		= 0x01000000;	// 상단 정렬 (한줄일때만, default)
const uint32_t UISTYLE_STRING_ALIGNBOTTOM	= 0x02000000;	// 하단 정렬 (한줄일때만)
const uint32_t UISTYLE_STRING_ALIGNVCENTER	= 0x04000000;	// 수직가운데 정렬 (한줄일때만)
	// edit
const uint32_t UISTYLE_EDIT_PASSWORD		= 0x10000000;	// 암호를 입력받는 edit이다.
const uint32_t UISTYLE_EDIT_NUMBERONLY		= 0x20000000;
	// progress
const uint32_t UISTYLE_PROGRESS_LEFT2RIGHT	= 0x10000000;	// 왼쪽에서 오른쪽으로 증가(default)
const uint32_t UISTYLE_PROGRESS_RIGHT2LEFT	= 0x20000000;	// 오른쪽에서 왼쪽으로 증가
const uint32_t UISTYLE_PROGRESS_TOP2BOTTOM	= 0x40000000;	// 위쪽에서 아래쪽으로 증가
const uint32_t UISTYLE_PROGRESS_BOTTOM2TOP	= 0x80000000;	// 아래쪽에서 위쪽으로 증가
	// TrackBar
const uint32_t UISTYLE_TRACKBAR_HORIZONTAL	= 0x00010000;	// 가로(default)
const uint32_t UISTYLE_TRACKBAR_VERTICAL	= 0x00020000;	// 세로
	// ScrollBar
const uint32_t UISTYLE_SCROLLBAR_HORIZONTAL= 0x00010000;	// 가로(default)
const uint32_t UISTYLE_SCROLLBAR_VERTICAL	= 0x00020000;	// 세로

	// Icon type.. ecli666..
const uint32_t UISTYLE_ICON_ITEM			= 0x00000010;	// 아이템 아이콘..
const uint32_t UISTYLE_ICON_SKILL			= 0x00000020;	// 스킬 아이콘..
const uint32_t UISTYLE_ICON_CERTIFICATION_NEED		= 0X00000100;	// 서버로 부터 인증이 필요한 아이콘..
const uint32_t UISTYLE_ICON_CERTIFICATION_NONEED	= 0X00000200;	// 서버로 부터 인증이 불필요한 아이콘..
const uint32_t UISTYLE_ICON_HIGHLIGHT				= 0x00001000;	// No highlight Icon.. 
const uint32_t UISTYLE_DURABILITY_EXHAUST			= 0x00002000;	// Durability exhausted Icon.. 
const uint32_t UISTYLE_DISABLE_SKILL	= 0x00004000;	// Disable Skill Icon..
const uint32_t UISTYLE_ICON_NO_HIGHLIGHT			= 0x00000000;	// Highlight Icon..

// structures
struct __FLOAT_RECT
{
	float left, top, right, bottom;
	BOOL PtInRect2D(float x, float y) const {return ((x>=left && x<=right && y>=top && y<=bottom)?TRUE:FALSE);}
	BOOL PtInRect3D(float x, float y) const {return ((x>=left && x<=right && y>=bottom && y<=top)?TRUE:FALSE);}
};

#endif // #if !defined __N3UIDEF_H__

// ===== END N3Base/N3UIDef.h =====

// ===== BEGIN N3Base/N3UIEdit.cpp =====
#line 1 "N3Base/N3UIEdit.cpp"
﻿// N3UIEdit.cpp: implementation of the CN3UIEdit class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIEdit.h"
#include "N3UIString.h"
#include "N3UIImage.h"
#include "DFont.h"
#include "N3UIStatic.h"

#include "N3SndMgr.h"
#include "N3SndObj.h"
#include <imm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

const float CARET_FLICKERING_TIME = 0.4f;

//HWND CN3UIEdit::s_hWndParent = nullptr;
HWND CN3UIEdit::s_hWndEdit = nullptr;
HWND CN3UIEdit::s_hWndParent = nullptr;
WNDPROC	CN3UIEdit::s_lpfnEditProc = nullptr;
char CN3UIEdit::s_szBuffTmp[512] = "";

//////////////////////////////////////////////////////////////////////
// CN3UIEdit::CN3Caret
//////////////////////////////////////////////////////////////////////
CN3UIEdit::CN3Caret::CN3Caret()
{
	m_pVB[0].Set(0,0,UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xffff0000);
	m_pVB[1].Set(0,10,UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xffff0000);
	m_bVisible = FALSE;
	m_fFlickerTimePrev = CN3Base::TimeGet();	// 깜박이기 위한 시간..
	m_bFlickerStatus = true;

}
CN3UIEdit::CN3Caret::~CN3Caret()
{
}
void CN3UIEdit::CN3Caret::SetPos(int x, int y)
{
	m_pVB[0].x = (float)x; m_pVB[0].y = (float)y;
	m_pVB[1].x = (float)x; m_pVB[1].y = (float)y+m_iSize;
	this->InitFlckering();
}
void CN3UIEdit::CN3Caret::MoveOffset(int iOffsetX, int iOffsetY)
{
	m_pVB[0].x += iOffsetX; m_pVB[0].y += iOffsetY; 
	m_pVB[1].x = m_pVB[0].x; m_pVB[1].y = m_pVB[0].y+m_iSize;
	this->InitFlckering();
}
void CN3UIEdit::CN3Caret::SetSize(int iSize)
{
	m_iSize = iSize;
	m_pVB[1].y = m_pVB[0].y+m_iSize;
}
void CN3UIEdit::CN3Caret::SetColor(D3DCOLOR color)
{
	m_pVB[0].color = color;
	m_pVB[1].color = color;
}
void CN3UIEdit::CN3Caret::Render(LPDIRECT3DDEVICE9	lpD3DDev)
{
	if (FALSE == m_bVisible) return;

	// 깜박임 처리..
	float fTime = CN3Base::TimeGet();
	if(fTime - m_fFlickerTimePrev > CARET_FLICKERING_TIME)
	{
		m_bFlickerStatus = !m_bFlickerStatus;
		m_fFlickerTimePrev = fTime;
	}
	if(!m_bFlickerStatus) return;

	__ASSERT(lpD3DDev, "DIRECT3DDEVICE8 is null");
	lpD3DDev->SetTexture(0, nullptr);
//	lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,    D3DTOP_SELECTARG1 );
//	lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1,  D3DTA_DIFFUSE );
	lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	lpD3DDev->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_pVB, sizeof(m_pVB[0]));
}
void CN3UIEdit::CN3Caret::InitFlckering()
{
	m_fFlickerTimePrev = CN3Base::TimeGet();	// 깜박이기 위한 시간..
	m_bFlickerStatus = true;
}

//////////////////////////////////////////////////////////////////////
// CN3UIEdit
//////////////////////////////////////////////////////////////////////

BOOL CN3UIEdit::CreateEditWindow(HWND hParent, RECT rect)
{
	if(nullptr == hParent) return FALSE;
	if(s_hWndEdit) return FALSE;

	s_hWndParent = hParent;
	s_hWndEdit = CreateWindow("EDIT", "EditWindow", WS_CHILD|WS_TABSTOP|ES_LEFT|ES_WANTRETURN, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top, hParent, nullptr, nullptr, nullptr);
	s_lpfnEditProc = (WNDPROC) SetWindowLongPtr(s_hWndEdit, GWLP_WNDPROC, (LONG_PTR) CN3UIEdit::EditWndProc);

	// Set the edit control's text size to the maximum.
	::SendMessage(s_hWndEdit, EM_LIMITTEXT, 0, 0);

	// Set the edit control's font
	HFONT hFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
	::SendMessage(s_hWndEdit, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
	::SendMessage(s_hWndEdit, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));

	// 배경 지우기...??
	HDC hDC = GetDC(s_hWndEdit);
	SetBkMode(hDC, TRANSPARENT);
	SetROP2(hDC, R2_XORPEN);
	ReleaseDC(s_hWndEdit, hDC);

	return TRUE;
}

LRESULT APIENTRY CN3UIEdit::EditWndProc(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam)
{
   //
   // When the focus is in an edit control inside a dialog box, the
   //  default ENTER key action will not occur.
   //
    switch (Message)
	{
	case WM_KEYDOWN:
		if (wParam == VK_RETURN)
		{
			if(s_pFocusedEdit && s_pFocusedEdit->GetParent())
			{
				s_pFocusedEdit->GetParent()->ReceiveMessage(s_pFocusedEdit, UIMSG_EDIT_RETURN);
			}
			return 0;
		}

		(CallWindowProc(s_lpfnEditProc, hWnd, Message, wParam, lParam));
		if(s_pFocusedEdit) CN3UIEdit::UpdateCaretPosFromEditCtrl();
		return 0;
		//break;

    case WM_CHAR:
		if(s_pFocusedEdit) CN3UIEdit::UpdateCaretPosFromEditCtrl();
		if(wParam==VK_RETURN) return 0;
		if(wParam==VK_TAB) return 0;
		break;
	case WM_INPUTLANGCHANGE:
		{
			POINT ptPos;
			ptPos.x = 0;
			ptPos.y = 0;
			SetImeStatus(ptPos,true);
		}
		break;
	case WM_IME_ENDCOMPOSITION:
		{
			POINT ptPos;
			ptPos.x = -1000;
			ptPos.y = -1000;
			SetImeStatus(ptPos,false);
		}
		break;
	case WM_IME_STARTCOMPOSITION:
		{
			POINT ptPos;
			ptPos.x = 0;
			ptPos.y = 0;
			SetImeStatus(ptPos,true);
		}
		break;
    } // switch









/*
	switch(Message)
	{
	case WM_IME_CHAR:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_COMPOSITION:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_COMPOSITIONFULL:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_CONTROL:
		{
			int iiii = 0;
			uint32_t dwCmd = wParam;
			switch(dwCmd)
			{
			case IMC_GETCANDIDATEPOS: 
				iiii = 0;
				break;
			case IMC_OPENSTATUSWINDOW:
				iiii = 0;
				break;
			case IMC_GETCOMPOSITIONFONT:
				iiii = 0;
				break;
			case IMC_SETCANDIDATEPOS :
				iiii = 0;
				break;
			case IMC_GETCOMPOSITIONWINDOW:
				iiii = 0;
				break;
			case IMC_SETCOMPOSITIONFONT :
				iiii = 0;
				break;
//			case IMC_GETCONVERSIONMODE:
//				iiii = 0;
//				break;
			case IMC_SETCOMPOSITIONWINDOW :
				iiii = 0;
				break;
//			case IMC_GETOPENSTATUS:
//				iiii = 0;
//				break;
//			case IMC_SETCONVERSIONMODE :
//				iiii = 0;
//				break;
//			case IMC_GETSENTENCEMODE:
//				iiii = 0;
//				break;
//			case IMC_SETOPENSTATUS :
//				iiii = 0;
//				break;
			case IMC_GETSTATUSWINDOWPOS:
				iiii = 0;
				break;
//			case IMC_SETSENTENCEMODE :
//				iiii = 0;
//				break;
			case IMC_CLOSESTATUSWINDOW:
				iiii = 0;
				break;
			case IMC_SETSTATUSWINDOWPOS :
				iiii = 0;
				break;
			}
		}
		break;
	case WM_IME_ENDCOMPOSITION:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_KEYDOWN:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_KEYUP:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_NOTIFY:
		{
			int iiii = 0;

			switch(wParam)
			{
			case IMN_CHANGECANDIDATE:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETCANDIDATEPOS:
				{
					int iiii = 0;
					break;
				}
			case IMN_CLOSECANDIDATE:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETCOMPOSITIONFONT:
				{
					int iiii = 0;
					break;
				}
			case IMN_CLOSESTATUSWINDOW:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETCOMPOSITIONWINDOW:
				{
					int iiii = 0;
					
					COMPOSITIONFORM CompForm;
					CompForm.dwStyle = CFS_RECT;
					int msg2 = (UINT) WM_IME_CONTROL;
					WPARAM wParam2 = (WPARAM) IMC_GETCOMPOSITIONWINDOW;
					WPARAM lParam2 = (LPARAM) &CompForm;
					SendMessage(hWnd, msg2, wParam2, lParam2);

					break;
				}
			case IMN_GUIDELINE:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETCONVERSIONMODE:
				{
					int iiii = 0;
					break;
				}
			case IMN_OPENCANDIDATE:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETOPENSTATUS:
				{
					int iiii = 0;
					break;
				}
			case IMN_OPENSTATUSWINDOW:
				{
					int iiii = 0;
					break;
				}
			case IMN_SETSENTENCEMODE:
				{
					int iiii = 0;
					break;
				}
			case IMN_PRIVATE:
				{
					int iiii = 0;

					CANDIDATEFORM cf;
					cf.dwStyle = CFS_RECT;
					iiii = ::SendMessage(hWnd, WM_IME_CONTROL, IMC_GETCANDIDATEPOS, (LPARAM)(&cf));

					LOGFONT lf;
					iiii = ::SendMessage(hWnd, WM_IME_CONTROL, IMC_GETCOMPOSITIONFONT, (LPARAM)(&lf));

					iiii = 0;



					break;
				}
			case IMN_SETSTATUSWINDOWPOS:
				{
					int iiii = 0;
					break;
				}
			}

//			CANDIDATEFORM form;
//			form.dwIndex = 0;
//			form.dwStyle = CFS_EXCLUDE;
//			this->SendMessage(0x0288, 0x0002, (LPARAM)(&form));
//			iiii = -1;
//			this->SendMessage(WM_IME_REQUEST, IMR_CANDIDATEWINDOW, &form);
		}
		break;
	case WM_IME_SELECT:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_SETCONTEXT:
		{
			int iiii = 0;
		}
		break;
	case WM_IME_STARTCOMPOSITION:
		{
			int iiii = 0;
		}
		break;
	}
*/
















	return (CallWindowProc(s_lpfnEditProc, hWnd, Message, wParam, lParam));
}

CN3UIEdit::CN3Caret CN3UIEdit::s_Caret;

CN3UIEdit::CN3UIEdit()
{
	m_eType = UI_TYPE_EDIT;
	m_nCaretPos = 0;
	m_iCompLength = 0;
	m_iMaxStrLen = 0x7fffffff;
	KillFocus();
	m_pSnd_Typing = nullptr;
}

CN3UIEdit::~CN3UIEdit()
{
	KillFocus();
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Typing);
}

void CN3UIEdit::Release()
{
	CN3UIBase::Release();
	m_nCaretPos = 0;
	m_iCompLength = 0;
	m_iMaxStrLen = 0x7fffffff;
	KillFocus();
	m_szPassword = "";
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Typing);
}

void CN3UIEdit::Render()
{
	if (!m_bVisible) return;

	CN3UIStatic::Render();
	if (HaveFocus())
	{
		s_Caret.Render(s_lpD3DDev);	// 포커스가 있으면 캐럿 그리기
	}
}

void CN3UIEdit::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if (false == bVisible && true == m_bVisible)	// 보이지 않게 할때
	{
		KillFocus();
	}
}

void CN3UIEdit::KillFocus()
{
	if (HaveFocus())
	{
		s_pFocusedEdit = nullptr;
		s_Caret.m_bVisible = FALSE;

		if(s_hWndEdit)
		{
			::SetWindowText(s_hWndEdit, "");
			::SetFocus(s_hWndParent);
		}
	}
}

bool CN3UIEdit::SetFocus()
{
//	if (HaveFocus()) return true;		// 이미 내가 포커스를 가지고 있으면 return true;
	if (nullptr != s_pFocusedEdit) s_pFocusedEdit->KillFocus();	// 다른 edit 가 가지고 있으면 killfocus호출
	s_pFocusedEdit = this;				// 포커스를 가지고 있는 edit를 나로 설정

	SIZE size;
	if (m_pBuffOutRef && m_pBuffOutRef->GetTextExtent("가",2,&size))
	{
		s_Caret.SetSize(size.cy);
		s_Caret.SetColor(m_pBuffOutRef->GetFontColor());
	}

	s_Caret.m_bVisible = TRUE;
	s_Caret.InitFlckering();
	CN3UIEdit::UpdateCaretPosFromEditCtrl(); // 캐럿 포지션 설정

	if(s_hWndEdit)
	{
		::SetFocus(s_hWndEdit);

		RECT rcEdit = GetRegion();
		int iX		= rcEdit.left;
		int iY		= rcEdit.top;
		int iH		= rcEdit.bottom - rcEdit.top;
		int iW		= rcEdit.right - rcEdit.left;
		::MoveWindow(s_hWndEdit, iX, iY, iW, iH, false);
		
		if(UISTYLE_EDIT_PASSWORD & m_dwStyle)
		{
			::SetWindowText(s_hWndEdit, m_szPassword.c_str());
		}
		else
		{
			if(m_pBuffOutRef) ::SetWindowText(s_hWndEdit, m_pBuffOutRef->GetString().c_str());
			else ::SetWindowText(s_hWndEdit, "");
		}
	}

	return true;
}

uint32_t CN3UIEdit::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;
	if(dwFlags & UI_MOUSE_LBCLICK &&IsIn(ptCur.x, ptCur.y))	// 영역 안에서 왼쪽 버튼이 눌렸으면
	{
		SetFocus();	// 나에게 포커스를 준다.
		dwRet |= (UI_MOUSEPROC_DONESOMETHING|UI_MOUSEPROC_INREGION);
		return dwRet;
	}
	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

void CN3UIEdit::SetCaretPos(size_t nPos)
{
	if (nPos > m_iMaxStrLen)
		nPos = m_iMaxStrLen;	// 최대 길이보다 길경우 작게 세팅
	m_nCaretPos = nPos;

	const std::string& szBuff = m_pBuffOutRef->GetString();
	__ASSERT(szBuff.empty() || -1 == szBuff.find('\n'), "multiline edit");	// 지금은 multiline은 지원하지 않는다.
	SIZE size = { 0,0 };
	if (!szBuff.empty() && m_pBuffOutRef != nullptr)
		m_pBuffOutRef->GetTextExtent(szBuff, static_cast<int>(m_nCaretPos), &size);

	int iRegionWidth = m_rcRegion.right - m_rcRegion.left;
	if (size.cx > iRegionWidth)
		size.cx = iRegionWidth;

	s_Caret.SetPos(m_pBuffOutRef->m_ptDrawPos.x + size.cx, m_pBuffOutRef->m_ptDrawPos.y);
}

void CN3UIEdit::SetMaxString(size_t nMax)		// 최대 글씨 수를 정해준다
{
	if (nMax == 0)
	{
		__ASSERT(0, "최대 글씨 수를 0보다 크게 정해주세요");
		return;
	}

	m_iMaxStrLen = nMax;

	if (m_pBuffOutRef == nullptr)
		return;

	const std::string szBuff = GetString();
	if (m_iMaxStrLen >= szBuff.size())
		return;

	// 여기까지 오는 경우는 현재 글씨길이가 iMax보다 큰 경우이므로 제한글자에 맞춰 잘라주게 다시 설정한다.
	SetString(szBuff);
}

/////////////////////////////////////////////////////////////////////
//
// 특정 위치가 한글의 2byte중에 두번째 바이트인지 검사하는 부분이다.
// IsDBCSLeadByte라는 함수가 있지만 조합형일 경우는
// 시작Byte와 끝byte의 범위가 같으로 이 함수로 검사 할 수 없다.
// 따라서 처음부터 검사를 하는 방법 외에는 다른 방법이 없다.
//
// NT의 Unicode에서는 어떻게 작용하는지 검사해 보지 않았지만
// 별 다른 문제 없이 사용할 수 있다고 생각한다.
//
/////////////////////////////////////////////////////////////////////
BOOL CN3UIEdit::IsHangulMiddleByte( const char* lpszStr, int iPos )
{
    if( !lpszStr ) return FALSE;
    if (iPos <= 0) return FALSE;
    int nLength = lstrlen(lpszStr);
    if (iPos >= nLength) return FALSE;
    if (!(lpszStr[iPos] & 0x80))
        return FALSE;

	BOOL bMiddle = FALSE;
	for (int i = 0; i < iPos && i < nLength; i++)
	{
		if (lpszStr[i] & 0x80)
			bMiddle = !bMiddle;
	}
	return bMiddle;
}

const std::string& CN3UIEdit::GetString()
{
	if (UISTYLE_EDIT_PASSWORD & m_dwStyle) return m_szPassword;
	return CN3UIStatic::GetString();
}

void CN3UIEdit::SetString(const std::string& szString)
{
	if (m_pBuffOutRef == nullptr)
		return;

	if (szString.size() > m_iMaxStrLen)
	{
		std::string szNewBuff(m_iMaxStrLen, '?');

		if (IsHangulMiddleByte(szString.c_str(), static_cast<int>(m_iMaxStrLen)))
		{
			szNewBuff = szString.substr(0, m_iMaxStrLen - 1);	// -1은 한글이므로 하나 덜 카피하기 위해 +1은 맨 마지막에 nullptr 넣기 위해
			if (UISTYLE_EDIT_PASSWORD & m_dwStyle)
			{
				m_szPassword = szNewBuff;

				szNewBuff.assign(m_iMaxStrLen - 1, '*');
				__ASSERT('\0' == szNewBuff[m_iMaxStrLen - 1], "글자수가 다르다.");
			}
			m_pBuffOutRef->SetString(szNewBuff);
		}
		else
		{
			szNewBuff = szString.substr(0, m_iMaxStrLen);	// +1은 맨 마지막에 nullptr 넣기 위해
			if (UISTYLE_EDIT_PASSWORD & m_dwStyle)
			{
				m_szPassword = szNewBuff;

				szNewBuff.assign(m_iMaxStrLen, '*');
				__ASSERT('\0' == szNewBuff[m_iMaxStrLen], "글자수가 다르다.");
			}
			m_pBuffOutRef->SetString(szNewBuff);
		}
	}
	else
	{
		if (UISTYLE_EDIT_PASSWORD & m_dwStyle)
		{
			m_szPassword = szString;
			if (!szString.empty())
			{
				std::string szNewBuff(szString.size(), '*');
				m_pBuffOutRef->SetString(szNewBuff);
			}
			else
			{
				m_pBuffOutRef->SetString("");
			}
		}
		else
		{
			m_pBuffOutRef->SetString(szString);
		}
	}

	const std::string& szTempStr = m_pBuffOutRef->GetString();
	uint32_t nStrLen = static_cast<uint32_t>(szTempStr.size());
	if (m_nCaretPos > nStrLen)
		SetCaretPos(nStrLen);
}

BOOL CN3UIEdit::MoveOffset(int iOffsetX, int iOffsetY)		// 위치 지정(chilren의 위치도 같이 바꾸어준다. caret위치도 같이 바꾸어줌.)
{
	if (FALSE == CN3UIBase::MoveOffset(iOffsetX, iOffsetY)) return FALSE;
/*
	RECT rcEdit = GetRegion();
	int iX		= rcEdit.left;
	int iY		= rcEdit.top;
	int iH		= rcEdit.bottom - rcEdit.top;
	int iW		= rcEdit.right - rcEdit.left;

	::MoveWindow(s_hWndEdit, iX, iY, iW, iH, false);
*/
	if (HaveFocus()) s_Caret.MoveOffset(iOffsetX, iOffsetY);
	return TRUE;
}

bool CN3UIEdit::Load(File& file)
{
	if (!CN3UIStatic::Load(file))
		return false;

	// 이전 uif파일을 컨버팅 하려면 사운드 로드 하는 부분 막기
	int iSndFNLen = 0;

	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		std::string filename(iSndFNLen, '\0');
		file.Read(&filename[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_Typing, "memory leak");
		m_pSnd_Typing = s_SndMgr.CreateObj(filename, SNDTYPE_2D);
	}

	return true;
}

#ifdef _N3TOOL
void CN3UIEdit::operator = (const CN3UIEdit& other)
{
	CN3UIStatic::operator = (other);
	SetSndTyping(other.GetSndFName_Typing());
}

bool CN3UIEdit::Save(File& file)
{
	if (!CN3UIStatic::Save(file))
		return false;

	int iSndFNLen = 0;
	if (m_pSnd_Typing != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_Typing->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
		file.Write(m_pSnd_Typing->m_szFileName.c_str(), iSndFNLen);

	return true;
}

void CN3UIEdit::SetSndTyping(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Typing);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_Typing = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

std::string CN3UIEdit::GetSndFName_Typing() const
{
	if (m_pSnd_Typing) return m_pSnd_Typing->m_szFileName;
	else return std::string("");
}
#endif

void CN3UIEdit::UpdateTextFromEditCtrl()
{
	if(nullptr == s_pFocusedEdit || nullptr == s_hWndEdit) return;

	::GetWindowText(s_hWndEdit, s_szBuffTmp, 512);
	s_pFocusedEdit->SetString(s_szBuffTmp);
}

void CN3UIEdit::UpdateCaretPosFromEditCtrl()
{
	if(nullptr == s_pFocusedEdit || nullptr == s_hWndEdit) return;

/*	int iCaret = 0;
	int iLen = GetWindowTextLength(s_hWndEdit);
	POINT ptCaret;
	GetCaretPos(&ptCaret);
	if(ptCaret.x > 0)
	{
		HDC hDC = GetDC(s_hWndEdit);
		SIZE size;
		GetTextExtentPoint32(hDC, "1", 1, &size);
		iCaret = ptCaret.x / size.cx;
		ReleaseDC(s_hWndEdit, hDC);
	}
*/
	LRESULT lResult = ::SendMessage(s_hWndEdit, EM_GETSEL, 0, 0);
	int iCaret = LOWORD(lResult);
	int iCTmp2 = HIWORD(lResult);
	s_pFocusedEdit->SetCaretPos(iCaret);
}

void CN3UIEdit::SetImeStatus(POINT ptPos, bool bOpen)
{
#ifndef _N3TOOL
	HKL hHKL = GetKeyboardLayout(0);
	if(ImmIsIME(hHKL))
	{
		HIMC hImc = ImmGetContext(s_hWndEdit);
		if(bOpen)
		{
			SendMessage(s_hWndEdit, WM_IME_NOTIFY, IMN_OPENSTATUSWINDOW, 0);
			ImmSetStatusWindowPos(hImc,&ptPos);
		}
		else
		{
			SendMessage(s_hWndEdit, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0);
		}
		ImmReleaseContext( s_hWndEdit, hImc );
	}
#endif
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////
//	IME 관련해서
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
#include<map>
typedef std::map<HWND, CN3UIEdit*>::iterator		it_Edit;
typedef std::map<HWND, CN3UIEdit*>::value_type		val_Edit;
static std::map<HWND, CN3UIEdit*> s_Edits;

bool CN3UIEdit::AddEdit(CN3UIEdit* pEdit)
{
	if(pEdit == nullptr)
	{
		__ASSERT(0, "NULL POINTER");
		return false;
	}

	it_Edit it = s_Edits.find(pEdit->m_hWndEdit);
	if(it == s_Edits.end()) // 중복된게 없으면..
	{
		s_Edits.insert(val_Edit(pEdit->m_hWndEdit, pEdit));
		return true;
	}
	else // 중복되었으면..
	{
		__ASSERT(0, "Edit Handle Duplicate");
		return false;
	}
}

bool CN3UIEdit::DeleteEdit(CN3UIEdit* pEdit)
{
	if(pEdit == nullptr)
	{
		__ASSERT(0, "NULL POINTER");
		return false;
	}

	it_Edit it = s_Edits.find(pEdit->m_hWndEdit);
	if(it == s_Edits.end()) return false;

	s_Edits.erase(it);
	return true;
}

CN3UIEdit* CN3UIEdit::GetEdit(HWND hWnd)
{
	it_Edit it = s_Edits.find(hWnd);
	if(it == s_Edits.end()) return nullptr;

	return it->second;
}

LRESULT APIENTRY CN3UIEdit::EditWndProc(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam)
{
   //
   // When the focus is in an edit control inside a dialog box, the
   //  default ENTER key action will not occur.
   //
	CN3UIEdit* pEdit = CN3UIEdit::GetEdit(hWnd);
	if(pEdit) pEdit->EditWndProcFuncPointer(hWnd, Message, wParam, lParam);

	return 0;
}

LRESULT APIENTRY CN3UIEdit::EditWndProcFuncPointer(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam)
{
   //
   // When the focus is in an edit control inside a dialog box, the
   //  default ENTER key action will not occur.
   //
    switch (Message)
	{
	case WM_CREATE:
		::SetWindowText(m_hWndEdit,"");
		break;
	case WM_KEYDOWN:
		if (wParam == VK_RETURN)
		{
			if(GetParent())
			{
				GetParent()->ReceiveMessage(this, UIMSG_EDIT_RETURN);
			}
			return 0;
		}
		(CallWindowProc(m_lpfnEditProc, hWnd, Message, wParam, lParam));
		UpdateCaretPosFromEditCtrl();
		return 0;
		//break;

    case WM_CHAR:
		CN3UIEdit::UpdateCaretPosFromEditCtrl();
		if(wParam==VK_RETURN) return 0;
		if(wParam==VK_TAB) return 0;
		break;
    } // switch
	return (CallWindowProc(m_lpfnEditProc, hWnd, Message, wParam, lParam));
}
*/


// ===== END N3Base/N3UIEdit.cpp =====

// ===== BEGIN N3Base/N3UIEdit.h =====
#line 1 "N3Base/N3UIEdit.h"
﻿// N3UIEdit.h: interface for the CN3UIEdit class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIEDIT_H__91BCC181_3AA5_4CD4_8D33_06D5D96F4F26__INCLUDED_)
#define AFX_N3UIEDIT_H__91BCC181_3AA5_4CD4_8D33_06D5D96F4F26__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIStatic.h"

class CN3UIEdit : public CN3UIStatic  
{
//	friend class CN3IME;
public:
	CN3UIEdit();
	virtual ~CN3UIEdit();
// class
protected:
	class CN3Caret
	{
	public:
		CN3Caret();
		virtual ~CN3Caret();
		void	SetPos(int x, int y);
		void	MoveOffset(int iOffsetX, int iOffsetY);
		void	SetSize(int iSize);
		void	SetColor(D3DCOLOR color);
		void	Render(LPDIRECT3DDEVICE9 lpD3DDev);
		void	InitFlckering();		// 깜박임 초기화..
		BOOL	m_bVisible;				// 보이나
	protected:
		int		m_iSize;				// caret의 pixel 크기
		float	m_fFlickerTimePrev;	// 깜박이기 위한 시간..
		bool	m_bFlickerStatus;
//		POINT	m_ptPos;				// caret의 pixel 좌표
		__VertexTransformedColor	m_pVB[2];	// vertex 버퍼
	};

// Attributes
public:
/*
	static bool		AddEdit(CN3UIEdit* pEdit);
	static bool		DeleteEdit(CN3UIEdit* pEdit);
	static CN3UIEdit* GetEdit(HWND hWnd);
	static HWND		s_hWndParent;

	LRESULT APIENTRY EditWndProcFuncPointer(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam);
	static LRESULT	APIENTRY EditWndProc(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam);
	static			void SetParentWindowHwnd(HWND hWnd) { s_hWndParent = hWnd; }
*/
	static HWND		s_hWndEdit, s_hWndParent;
	static WNDPROC	s_lpfnEditProc;
	static char		s_szBuffTmp[512];

	static void				SetImeStatus(POINT ptPos, bool bOpen);
	static BOOL				CreateEditWindow(HWND hParent, RECT rect);
	static LRESULT APIENTRY EditWndProc(HWND hWnd, uint16_t Message, WPARAM wParam, LPARAM lParam);
	static void				UpdateTextFromEditCtrl();
	static void				UpdateCaretPosFromEditCtrl();

protected:
	static CN3Caret		s_Caret;
	size_t				m_nCaretPos;		// 글자 단위위치(byte단위)
	int					m_iCompLength;		// 현재 조합중인 글자의 byte수 0이면 조합중이 아니다.
	size_t				m_iMaxStrLen;		// 쓸수 있는 글씨의 최대 숫자
	std::string			m_szPassword;		// password buffer

	CN3SndObj*			m_pSnd_Typing;		// 타이핑 할 때 나는 소리
// Operations
public:
	const std::string&	GetString() override;
	void				SetString(const std::string& szString) override;

	bool				Load(File& file) override;
	void				Render() override;
	void				Release() override;
	void				SetVisible(bool bVisible) override;
	uint32_t			MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	BOOL				MoveOffset(int iOffsetX, int iOffsetY) override;		// 위치 지정(chilren의 위치도 같이 바꾸어준다. caret위치도 같이 바꾸어줌.)
	void				KillFocus();			// 포커스를 없앤다.
	bool				SetFocus();				// 포커스를 준다.
	bool				HaveFocus() const {return (this == s_pFocusedEdit);}
	void				SetCaretPos(size_t nPos);	//몇번째 바이트에 있는지 설정한다.
	void				SetMaxString(size_t nMax);		// 최대 글씨 수를 정해준다.
protected:
	BOOL				IsHangulMiddleByte( const char* lpszStr, int iPos );	// 한글의 2번째 바이트 글자인가?

#ifdef _N3TOOL
public:	
	virtual void		operator = (const CN3UIEdit& other);
	bool				Save(File& file) override;
	void				SetSndTyping(const std::string& strFileName);
	std::string			GetSndFName_Typing() const;
#endif
};

#endif // !defined(AFX_N3UIEDIT_H__91BCC181_3AA5_4CD4_8D33_06D5D96F4F26__INCLUDED_)

// ===== END N3Base/N3UIEdit.h =====

// ===== BEGIN N3Base/N3UIImage.cpp =====
#line 1 "N3Base/N3UIImage.cpp"
﻿// N3UIImage.cpp: implementation of the CN3UIImage class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIImage.h"
#include "N3Texture.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIImage::CN3UIImage()
{
	m_eType = UI_TYPE_IMAGE;

	m_pVB = nullptr;
	m_pTexRef = nullptr;
	m_szTexFN = "";
	m_pAnimImagesRef = nullptr;

	ZeroMemory(&m_frcUVRect, sizeof(m_frcUVRect));
	m_Color = D3DCOLOR_ARGB(0xff,0xff,0xff,0xff);
	m_fAnimFrame = 30.0f;
	m_iAnimCount = 0;
	m_fCurAnimFrame = 0.0f;
}

CN3UIImage::~CN3UIImage()
{
	if(m_pVB) {	m_pVB->Release();	m_pVB = nullptr;}
	s_MngTex.Delete(&m_pTexRef);
	if (m_pAnimImagesRef) {delete [] m_pAnimImagesRef; m_pAnimImagesRef = nullptr;}
}

void CN3UIImage::Release()
{
	CN3UIBase::Release();
	if(m_pVB) {	m_pVB->Release();	m_pVB = nullptr;}
	s_MngTex.Delete(&m_pTexRef);
	m_szTexFN = "";

	ZeroMemory(&m_frcUVRect, sizeof(m_frcUVRect));
	m_Color = D3DCOLOR_ARGB(0xff,0xff,0xff,0xff);
	m_fAnimFrame = 30.0f;
	m_iAnimCount = 0;
	m_fCurAnimFrame = 0.0f;
	if (m_pAnimImagesRef) {delete [] m_pAnimImagesRef; m_pAnimImagesRef = nullptr;}
}

void CN3UIImage::Init(CN3UIBase* pParent)
{
	CN3UIBase::Init(pParent);
	CreateVB();
}

bool CN3UIImage::CreateVB()
{
	HRESULT hr;
	if (m_pVB) {m_pVB->Release(); m_pVB = nullptr;}
	hr = s_lpD3DDev->CreateVertexBuffer( 4*sizeof(__VertexTransformed), 0, FVF_TRANSFORMED, D3DPOOL_MANAGED, &m_pVB , nullptr);
	return SUCCEEDED(hr);
}

void CN3UIImage::SetVB()
{
	if (UISTYLE_IMAGE_ANIMATE & m_dwStyle)	// animate image이면 vertex buffer release하기
	{
		if (m_pVB) {m_pVB->Release(); m_pVB = nullptr;}
	}
	else
	{
		if(m_pVB)
		{
			__VertexTransformed* pVertices;
			if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
				return;

			uint32_t dwColor = 0xffffffff;
			float fRHW = 1.0f;
			// -0.5f를 해주지 않으면 가끔 이미지가 한 돗트씩 밀리는 경우가 있다.(왜 그런지는 확실하게 모르겠음)
			pVertices[0].Set((float)m_rcRegion.left-0.5f,	(float)m_rcRegion.top-0.5f,		UI_DEFAULT_Z, fRHW, m_Color, m_frcUVRect.left,		m_frcUVRect.top);
			pVertices[1].Set((float)m_rcRegion.right-0.5f,	(float)m_rcRegion.top-0.5f,		UI_DEFAULT_Z, fRHW, m_Color, m_frcUVRect.right,	m_frcUVRect.top);
			pVertices[2].Set((float)m_rcRegion.right-0.5f,	(float)m_rcRegion.bottom-0.5f,	UI_DEFAULT_Z, fRHW, m_Color, m_frcUVRect.right,	m_frcUVRect.bottom);
			pVertices[3].Set((float)m_rcRegion.left-0.5f,	(float)m_rcRegion.bottom-0.5f,	UI_DEFAULT_Z, fRHW, m_Color, m_frcUVRect.left,		m_frcUVRect.bottom);
			
			m_pVB->Unlock();
		}
	}
}


void CN3UIImage::SetTex(const std::string& szFN)
{
	m_szTexFN = szFN;
	s_MngTex.Delete(&m_pTexRef);
	// animate image일때만 texture 지정하기
	if (!(UISTYLE_IMAGE_ANIMATE & m_dwStyle)) m_pTexRef = s_MngTex.Get(szFN);
}

void CN3UIImage::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		(*itor)->SetRegion(Rect);
	}
	SetVB();
}

void CN3UIImage::SetUVRect(float left, float top, float right, float bottom)
{
	m_frcUVRect.left = left;	m_frcUVRect.top = top;
	m_frcUVRect.right = right;	m_frcUVRect.bottom = bottom;
	SetVB();
}

void CN3UIImage::Tick()
{
	CN3UIBase::Tick();
	if (m_iAnimCount>0)		// Animate Image일때 현재 frame 계산
	{
		m_fCurAnimFrame += (s_fSecPerFrm * m_fAnimFrame);
		while (m_fCurAnimFrame >= (float)m_iAnimCount)
		{
			m_fCurAnimFrame -= ((float)m_iAnimCount);
		}
	}
}

void CN3UIImage::Render()
{
	if(!m_bVisible) return;

	if (UISTYLE_IMAGE_ANIMATE & m_dwStyle) // Animate되는 이미지이면
	{
		__ASSERT(m_fCurAnimFrame>=0.0f && m_fCurAnimFrame < (float)m_iAnimCount, "animate image 가 이상작동");
		__ASSERT(m_pAnimImagesRef, "초기화 이상");
		m_pAnimImagesRef[(int)m_fCurAnimFrame]->Render();
	}
	else
	{
		if (m_pVB && m_pTexRef)
		{
			s_lpD3DDev->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexTransformed) );
			s_lpD3DDev->SetFVF(FVF_TRANSFORMED);

			s_lpD3DDev->SetTexture( 0, m_pTexRef->Get());
			s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,    D3DTOP_MODULATE );
			s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1,  D3DTA_TEXTURE );
			s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2,  D3DTA_DIFFUSE );

			s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2);
		} 

		CN3UIBase::Render();
	}
}

void CN3UIImage::RenderIconWrapper()
{
	if(!m_bVisible) return;

	if (m_pVB)
	{
		s_lpD3DDev->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexTransformed) );
		s_lpD3DDev->SetFVF(FVF_TRANSFORMED);
		s_lpD3DDev->SetTexture( 0, nullptr);

		s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2);
	}

	CN3UIBase::Render();
}

BOOL CN3UIImage::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (FALSE == CN3UIBase::MoveOffset(iOffsetX, iOffsetY)) return FALSE;
	SetVB();
	return TRUE;
}

void CN3UIImage::SetColor(D3DCOLOR color)
{
	if (m_Color == color) return;
	m_Color = color;
	if ((UISTYLE_IMAGE_ANIMATE & m_dwStyle) && m_pAnimImagesRef)
	{
		int i;
		for(i=0; i<m_iAnimCount; ++i) m_pAnimImagesRef[i]->SetColor(color);
	}
	SetVB();
}

bool CN3UIImage::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	// texture 정보
	__ASSERT(nullptr == m_pTexRef, "load 하기 전에 초기화가 되지 않았습니다.");
	int	iStrLen = 0;
	file.Read(&iStrLen, sizeof(iStrLen));			// 파일 이름 길이
	char szFName[MAX_PATH] = "";
	if (iStrLen>0)
	{
		file.Read(szFName, iStrLen);		// 파일 이름
		szFName[iStrLen]='\0';
		this->SetTex(szFName);
	} 

	file.Read(&m_frcUVRect, sizeof(m_frcUVRect));	// uv좌표
	file.Read(&m_fAnimFrame, sizeof(m_fAnimFrame));

	// Animate 되는 image이면 관련된 변수 세팅
	m_iAnimCount = 0; // animate image 수 정하기
	for (CN3UIBase* pChild : m_Children)
	{
		if (UI_TYPE_IMAGE == pChild->UIType())
			++m_iAnimCount;
	}

	if ((UISTYLE_IMAGE_ANIMATE & m_dwStyle) && m_iAnimCount > 0)
	{
		m_pAnimImagesRef = new CN3UIImage* [m_iAnimCount];
		ZeroMemory(m_pAnimImagesRef, sizeof(CN3UIImage*) * m_iAnimCount);

		int i = 0;
		for (CN3UIBase* pChild : m_Children)
		{
			if (UI_TYPE_IMAGE == pChild->UIType())
				m_pAnimImagesRef[i] = static_cast<CN3UIImage*>(pChild);

			__ASSERT(m_pAnimImagesRef[i]->GetReserved() == (uint32_t) i, "animate Image load fail");	// 제대로 정렬이 되지 않았을경우 실패한다.
			++i;
		}
	}

	SetVB();	// vertex 세팅
	return true;
}

void CN3UIImage::operator = (const CN3UIImage& other)
{
	CN3UIBase::operator = (other);

	m_Color = other.m_Color;
	m_fAnimFrame = other.m_fAnimFrame;
	m_fCurAnimFrame = other.m_fCurAnimFrame;
	m_frcUVRect = other.m_frcUVRect;
	m_iAnimCount = other.m_iAnimCount;

	if (other.m_pTexRef) m_pTexRef = s_MngTex.Get(other.m_pTexRef->FileName());
	m_szTexFN = other.m_szTexFN;

	// Animate 되는 image이면 관련된 변수 세팅
	m_iAnimCount = static_cast<int>(m_Children.size());	// animate image 수 정하기
	if ((UISTYLE_IMAGE_ANIMATE & m_dwStyle) && m_iAnimCount>0)
	{
		m_pAnimImagesRef = new CN3UIImage*[m_iAnimCount];
		ZeroMemory(m_pAnimImagesRef, sizeof(CN3UIImage*)*m_iAnimCount);
		int i=0;
		for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
		{
			__ASSERT(UI_TYPE_IMAGE == (*itor)->UIType(), "animate image child의 UI type이 image가 아니다.");
			m_pAnimImagesRef[i] = (CN3UIImage*)(*itor);
			__ASSERT(m_pAnimImagesRef[i]->GetReserved() == (uint32_t)i, "animate Image load fail");	// 제대로 정렬이 되지 않았을경우 실패한다.
			++i;
		}
	}

	SetVB();	// vertex 세팅
}

#ifdef _N3TOOL
bool CN3UIImage::Save(File& file)
{
	ReorderChildImage();	// child image들 순서대로 정렬
	if (!CN3UIBase::Save(file))
		return false;

	// texture 정보
	if (m_pTexRef != nullptr)
		m_szTexFN = m_pTexRef->FileName();

	int iStrLen = static_cast<int>(m_szTexFN.size());
	file.Write(&iStrLen, sizeof(iStrLen));			// 파일 길이
	if (iStrLen > 0)
		file.Write(m_szTexFN.c_str(), iStrLen);		// 파일 이름

	file.Write(&m_frcUVRect, sizeof(m_frcUVRect));	// uv좌표
	file.Write(&m_fAnimFrame, sizeof(m_fAnimFrame));	// Animate frame

	return true;
}

void CN3UIImage::ChangeImagePath(const std::string& szPathOld, const std::string& szPathNew)
{
	CN3UIBase::ChangeImagePath(szPathOld, szPathNew);

	std::string szOld = szPathOld, szNew = szPathNew;

	if (!szOld.empty())
		CharLower(&szOld[0]);

	if (!szNew.empty())
		CharLower(&szNew[0]);

	if (!m_szTexFN.empty())
		CharLower(&m_szTexFN[0]);

	if (m_pTexRef != nullptr)
		m_szTexFN = m_pTexRef->FileName();

	size_t pos = m_szTexFN.find(szOld);
	if (pos != std::string::npos)
	{
		std::string szF = m_szTexFN.substr(0, pos);
		std::string szL = m_szTexFN.substr(pos + szOld.size());
		m_szTexFN = szF + szNew + szL;
		s_MngTex.Delete(&m_pTexRef);
		m_pTexRef = s_MngTex.Get(m_szTexFN);
	}
}

void CN3UIImage::GatherImageFileName(std::set<std::string>& setImgFile)
{
	CN3UIBase::GatherImageFileName(setImgFile); // child 정보
	
	std::string szImgFN = m_szTexFN;
	if(!szImgFN.empty())
	{
		::CharLower(&(szImgFN[0]));
		setImgFile.insert(szImgFN);
	}
}

// child의 image가 m_dwReserved에 들어가있는 숫자 순서에 맞게 재배치
void CN3UIImage::ReorderChildImage()
{
	if (m_iAnimCount<=0) return;
	CN3UIBase** pNewList = new CN3UIBase*[m_iAnimCount];
	ZeroMemory(pNewList, sizeof(CN3UIBase*)*m_iAnimCount);

	int i;
	for (i=0; i<m_iAnimCount; ++i)
	{
		CN3UIBase* pSelChild = nullptr;
		for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
		{
			CN3UIBase* pChild = (*itor);
			__ASSERT(UI_TYPE_IMAGE == pChild->UIType(), "image가 아닌 child가 있습니다.");
			if (nullptr == pSelChild) pSelChild = pChild;
			else if (pSelChild->GetReserved() > pChild->GetReserved()) pSelChild = pChild;
		}
		__ASSERT(pSelChild,"제일 작은 m_dwReserved를 가진 child가 없다.");
		pNewList[i] = pSelChild;
		RemoveChild(pSelChild);
	}
	
	for (i=0; i<m_iAnimCount; ++i) m_Children.push_back(pNewList[i]);	// 작은 순서대로 넣기

	delete [] pNewList;
}

CN3UIImage* CN3UIImage::GetChildImage(int iIndex)
{
	if (iIndex>=0 && iIndex < m_iAnimCount)	return m_pAnimImagesRef[iIndex];
	return nullptr;
}

void CN3UIImage::SetAnimImage(int iAnimCount)
{
	// 이미 설정 되어 있는것이 있으면 지우기
	int i;
	if (m_pAnimImagesRef)
	{
		for (i=0; i<m_iAnimCount; ++i)
		{	// 자식 지우기
			if (m_pAnimImagesRef[i]) {delete m_pAnimImagesRef[i]; m_pAnimImagesRef[i] = nullptr;}
		}
		delete [] m_pAnimImagesRef; m_pAnimImagesRef = nullptr;
	}
	m_iAnimCount = iAnimCount;

	// 0으로 설정하면 보통 image로 전환
	if (0 == m_iAnimCount)
	{
		SetStyle(m_dwStyle & (~UISTYLE_IMAGE_ANIMATE));
		CreateVB();
		SetVB();
	}
	else
	{
		SetStyle(m_dwStyle | UISTYLE_IMAGE_ANIMATE);
		s_MngTex.Delete(&m_pTexRef);
		SetVB();

		m_pAnimImagesRef = new CN3UIImage*[m_iAnimCount];
		ZeroMemory(m_pAnimImagesRef, sizeof(CN3UIImage*)*m_iAnimCount);
		for (i=0; i<m_iAnimCount; ++i)
		{
			m_pAnimImagesRef[i] = new CN3UIImage();
			m_pAnimImagesRef[i]->Init(this);
			m_pAnimImagesRef[i]->SetReserved(i);
			m_pAnimImagesRef[i]->SetRegion(m_rcRegion);
		}
	}
}

bool CN3UIImage::ReplaceAllTextures(const std::string& strFind, const std::string& strReplace)
{
	if (strFind.size() <= 0 || strReplace.size() <= 0) return false;
	while (m_pTexRef)
	{
		char szFindDir[_MAX_DIR], szFindFName[_MAX_FNAME], szFindExt[_MAX_EXT];
		char szReplaceDir[_MAX_DIR], szReplaceFName[_MAX_FNAME], szReplaceExt[_MAX_EXT];
		char szTexDir[_MAX_DIR], szTexFName[_MAX_FNAME], szTexExt[_MAX_EXT];
		_splitpath(strFind.c_str(), nullptr, szFindDir, szFindFName, szFindExt);
		_splitpath(strReplace.c_str(), nullptr, szReplaceDir, szReplaceFName, szReplaceExt);
		_splitpath(m_pTexRef->FileName().c_str(), nullptr, szTexDir, szTexFName, szTexExt);

		if (lstrlen(szFindFName) == 0 || lstrlen(szFindExt) == 0 ||
			lstrlen(szReplaceFName) == 0 || lstrlen(szReplaceExt) == 0) return false;

		std::string strNew(szTexDir);
		if (lstrcmpi(szFindFName, "*") == 0)
		{
			if (lstrcmpi(szFindExt, ".*") == 0)
			{	// *.* -> 
				if (lstrcmpi(szReplaceFName, "*") == 0)	strNew += szTexFName;
				else strNew += szReplaceFName;
				if (lstrcmpi(szReplaceExt, ".*") == 0) strNew += szTexExt;
				else strNew += szReplaceExt;
			}
			else
			{	// *.tga ->
				if (lstrcmpi(szFindExt, szTexExt) != 0 ) break;	// 확장자가 같지 않으므로 그냥 리턴

				if (lstrcmpi(szReplaceFName, "*") == 0)	strNew += szTexFName;
				else strNew += szReplaceFName;
				if (lstrcmpi(szReplaceExt, ".*") == 0) strNew += szTexExt;
				else strNew += szReplaceExt;
			}
		}
		else
		{
			if (lstrcmpi(szFindFName, szTexFName) != 0 ) break;	// 이름이 같지 않으므로 그냥 리턴

			if (lstrcmpi(szFindExt, ".*") == 0)
			{	// abc.* ->
				if (lstrcmpi(szReplaceFName, "*") == 0)	strNew += szFindFName;
				else strNew += szReplaceFName;
				if (lstrcmpi(szReplaceExt, ".*") == 0) strNew += szTexExt;
				else strNew += szReplaceExt;
			}
			else
			{	// 찾는 파일명과 확장자가 지정되어 있을경우 // abc.tga ->
				if (lstrcmpi(szFindExt, szTexExt) != 0 ) break;	// 확장자가 같지 않으므로 그냥 리턴

				if (lstrcmpi(szReplaceFName, "*") == 0)	strNew += szFindFName;
				else strNew += szReplaceFName;
				if (lstrcmpi(szReplaceExt, ".*") == 0) strNew += szTexExt;
				else strNew += szReplaceExt;
			}
		}
		// 텍스쳐 다시 지정하기
		SetTex(strNew);
		break;
	}
	return CN3UIBase::ReplaceAllTextures(strFind, strReplace);
}
#endif

// ===== END N3Base/N3UIImage.cpp =====

// ===== BEGIN N3Base/N3UIImage.h =====
#line 1 "N3Base/N3UIImage.h"
﻿// N3UIImage.h: interface for the CN3UIImage class.
// 보강해야 할 점 : animation되는 이미지도 그리도록 가능하게 하자..
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIIMAGE_H__80AE123C_5A12_4A0E_9CF0_511ED98BB896__INCLUDED_)
#define AFX_N3UIIMAGE_H__80AE123C_5A12_4A0E_9CF0_511ED98BB896__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"

class N3Texture;
class CN3UIImage : public CN3UIBase  
{
#ifdef _N3TOOL
friend class CPropertyView;	// 툴에서 각 변수들을 접근하기 위해서 
#endif

public:
	CN3UIImage();
	virtual ~CN3UIImage();

// Attributes
public:
	__FLOAT_RECT*			GetUVRect() {return &m_frcUVRect;}
protected:
	LPDIRECT3DVERTEXBUFFER9 m_pVB;			// vertex buffer
	CN3Texture*				m_pTexRef;		// texture 참조 포인터 (s_TexMng에서 관리하므로 참조포인터이다.)
	std::string				m_szTexFN;		// 텍스처 이름.. 따로 갖고 있는 이유는 툴에서 텍스처 부르기가 실패할 경우를 대비해서이다.
	__FLOAT_RECT			m_frcUVRect;	// uv 좌표를 저장
	D3DCOLOR				m_Color;		// 칼라(배경 이미지가 없을경우 사용된다.)

	float					m_fAnimFrame;	// 1초당 그려지는 이미지의 수
	int						m_iAnimCount;	// Animate되는 이미지 수(Load할 때 child의 숫자로 파악)
	float					m_fCurAnimFrame;	// 현재 그려질 animate frame index (소수는 버리고 사용하자)
	CN3UIImage**			m_pAnimImagesRef;	// Animate 될 자식 이미지들 참조 포인터들

//	Operations
public:
	D3DCOLOR	GetColor()	{ return m_Color; }

	CN3Texture*		GetTex() const { return m_pTexRef; }	// Texture 포인터 얻기
	void			SetTex(const std::string& szFN);		// Texture 지정
	void			SetUVRect(float left, float top, float right, float bottom);	// image의 uv좌표 지정
	void			SetColor(D3DCOLOR color);				// 칼라 지정

	void			SetRegion(const RECT& Rect);					// 영역 지정
	BOOL			MoveOffset(int iOffsetX, int iOffsetY) override;
	void			Release() override;								// Release
	void			Tick() override;								// Tick
	void			Render() override;								// 그리기
	virtual void	RenderIconWrapper();
	void			Init(CN3UIBase* pParent) override;				// 초기화
	bool			Load(File& file) override;

	virtual void	operator = (const CN3UIImage& other);

protected:
	bool			CreateVB();								// 4개의 vertex를 가진 vertex buffer 생성
	virtual void	SetVB();								// vertex buffer 다시 세팅
// tool에서 사용하는 함수들
#ifdef _N3TOOL
public:
	bool			Save(File& file) override;
	virtual void	ChangeImagePath(const std::string& szPathOld, const std::string& szPathNew);
	void			GatherImageFileName(std::set<std::string>& setImgFile);
	std::string		GetTexFN() { return m_szTexFN; }

	void			ReorderChildImage();
	void			SetAnimImage(int iAnimCount);
	CN3UIImage*		GetChildImage(int iIndex);
	virtual bool	ReplaceAllTextures(const std::string& strFind, const std::string& strReplace);
#endif
};

#endif // !defined(AFX_N3UIIMAGE_H__80AE123C_5A12_4A0E_9CF0_511ED98BB896__INCLUDED_)

// ===== END N3Base/N3UIImage.h =====

// ===== BEGIN N3Base/N3UIList.cpp =====
#line 1 "N3Base/N3UIList.cpp"
﻿// N3UIList.cpp: implementation of the CN3UIList class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIList.h"
#include "N3UIString.h"
#include "N3UIScrollBar.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIList::CN3UIList()
{
	m_eType = UI_TYPE_LIST;

	m_iCurSel = 0;		// 현재 선택..
	m_pScrollBarRef = nullptr;

	m_szFontName = "굴림체";
	m_dwFontHeight = 10;
	m_bFontBold = FALSE;
	m_bFontItalic = FALSE;
	m_crFont = 0xffffffff;
}

CN3UIList::~CN3UIList()
{
}

void CN3UIList::Release()
{
	CN3UIBase::Release();

//	it_pString it = m_ListString.begin(), itEnd = m_ListString.end();
//	for(; it != itEnd; it++)
//	{
//		delete (*it);
//	}

	m_ListString.clear(); // 어차피 자식은 다지우니까... 리스트의 포인터를 Delete 할 필요 없다..
	m_iCurSel = 0;
	m_pScrollBarRef = nullptr;

	m_szFontName = "굴림체";
	m_dwFontHeight = 10;
	m_bFontBold = FALSE;
	m_bFontItalic = FALSE;
	m_crFont = 0xffffffff;
}

void CN3UIList::SetFont(const std::string& szFontName, uint32_t dwHeight, BOOL bBold, BOOL bItalic)
{
	m_szFontName = szFontName;
	m_dwFontHeight = dwHeight;
	m_bFontBold = bBold;
	m_bFontItalic = bItalic;

	for (CN3UIString* pUIString : m_ListString)
		pUIString->SetFont(m_szFontName, m_dwFontHeight, m_bFontBold, m_bFontItalic);

	UpdateChildRegions();
}

void CN3UIList::SetFontColor(int iIndex, D3DCOLOR color)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListString.size()))
		return;

	auto it = m_ListString.begin();
	std::advance(it, iIndex);
	(*it)->SetColor(color);
}

void CN3UIList::SetFontColor(D3DCOLOR color)
{
	m_crFont = color;

	for (CN3UIString* pUIString : m_ListString)
		pUIString->SetColor(m_crFont);
}

int CN3UIList::AddStrings(const std::string* pszStrings, int iStringCount)
{
	for (int i = 0; i < iStringCount; i++)
	{
		CN3UIString* pString = new CN3UIString();
		pString->Init(this);
		pString->SetFont(m_szFontName, m_dwFontHeight, m_bFontBold, m_bFontItalic);
		pString->SetColor(m_crFont);
		pString->SetString(pszStrings[i]);

		m_ListString.push_back(pString);
	}
		
	UpdateChildRegions();

	return static_cast<int>(m_ListString.size()) - 1;
}

int	CN3UIList::AddString(const std::string& szString)
{
	CN3UIString* pString = new CN3UIString();
	pString->Init(this);
	pString->SetFont(m_szFontName, m_dwFontHeight, m_bFontBold, m_bFontItalic);
	pString->SetColor(m_crFont);
	pString->SetString(szString);

	m_ListString.push_back(pString);
	UpdateChildRegions();

	return static_cast<int>(m_ListString.size()) - 1;
}

bool CN3UIList::InsertString(int iIndex, const std::string& szString)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListString.size()))
		return false;

	CN3UIString* pString = new CN3UIString();
	pString->Init(this);
	pString->SetFont(m_szFontName, m_dwFontHeight, m_bFontBold, m_bFontItalic);
	pString->SetColor(m_crFont);
	pString->SetString(szString);

	auto it = m_ListString.begin();
	std::advance(it, iIndex);
	m_ListString.insert(it, pString);

	UpdateChildRegions();
	return true;
}

bool CN3UIList::DeleteString(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListString.size()))
		return false;

	auto it = m_ListString.begin();
	std::advance(it, iIndex);
	delete (*it);
	m_ListString.erase(it);

	int iSC = static_cast<int>(m_ListString.size());

	if (m_pScrollBarRef != nullptr)
	{
		int iScrollPos = m_pScrollBarRef->GetCurrentPos();
		if (iScrollPos >= iSC)
			m_pScrollBarRef->SetCurrentPos(iSC - 1);
	}

	if (m_iCurSel >= iSC)
		m_iCurSel = iSC - 1;

	UpdateChildRegions();
	return true;
}

bool CN3UIList::GetString(int iIndex, std::string& szString)
{
	szString.clear();

	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListString.size()))
		return false;

	auto it = m_ListString.begin();
	std::advance(it, iIndex);

	CN3UIString* pUIString = (*it);
	szString = pUIString->GetString();

	return true;
}

bool CN3UIList::SetString(int iIndex, const std::string& szString)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListString.size()))
		return false;

	auto it = m_ListString.begin();
	std::advance(it, iIndex);
	
	CN3UIString* pUIString = (*it);
	pUIString->SetString(szString);

	return false;
}

CN3UIString* CN3UIList::GetChildStrFromList(const std::string& str)
{
	for (CN3UIString* pUIString : m_ListString)
	{
		if (pUIString->GetString() == str)
			return pUIString;
	}

	return nullptr;
}

void CN3UIList::UpdateChildRegions()
{
	RECT rc = GetRegion();
	RECT rcThis = rc;
	POINT pt;
	SIZE size;
	int iScrollPos = 0;
	if (m_pScrollBarRef != nullptr)
	{
		iScrollPos = m_pScrollBarRef->GetCurrentPos();
		RECT rcTmp = m_pScrollBarRef->GetRegion();
		rc.right = rcTmp.left;
	}

	it_pString it = m_ListString.begin(), itEnd = m_ListString.end();
	for (int i = 0; it != itEnd; it++, i++)
	{
		CN3UIString* pStr = *it;
		if (i < iScrollPos)
		{
			pStr->SetVisibleWithNoSound(false);
			continue;
		}

		pt = pStr->GetPos();

		const std::string& str = pStr->GetString();

		pStr->GetTextExtent(str, static_cast<int>(str.size()), &size);
		pStr->SetPos(rc.left, rc.top);
		RECT rcTmp = { rc.left, rc.top, rc.left + (rc.right - rc.left), rc.top + size.cy };
		pStr->SetRegion(rcTmp);
		rc.top += size.cy;

		if (rc.top >= rcThis.bottom) pStr->SetVisibleWithNoSound(false);
		else pStr->SetVisibleWithNoSound(true);
	}

	if (m_pScrollBarRef)
	{
		if (rc.bottom <= rcThis.bottom)
		{
			m_pScrollBarRef->SetCurrentPos(0);
			m_pScrollBarRef->SetVisibleWithNoSound(false);
		}
		else
		{
			m_pScrollBarRef->SetVisibleWithNoSound(true);
		}

		m_pScrollBarRef->SetRange(0, static_cast<int>(m_ListString.size()));
	}
}

int CN3UIList::GetScrollPos() const
{
	if (m_pScrollBarRef == nullptr)
		return 0;

	return m_pScrollBarRef->GetCurrentPos();
}

bool CN3UIList::SetScrollPos(int iScrollPos)
{
	if (m_pScrollBarRef == nullptr)
		return false;
	
	m_pScrollBarRef->SetCurrentPos(iScrollPos);
	UpdateChildRegions();
	return true;
}

bool CN3UIList::Load(File& file)
{
	bool bSuccess = CN3UIBase::Load(file);

	// font 정보
	int iStrLen = 0;
	file.Read(&iStrLen, sizeof(iStrLen));			// font 이름 길이 
	__ASSERT(iStrLen > 0, "No font name");
	if (iStrLen > 0)
	{
		m_szFontName.assign(iStrLen, ' ');
		file.Read(&m_szFontName[0], iStrLen);				// string
		file.Read(&m_dwFontHeight, 4);	// font height
		file.Read(&m_crFont, 4);	// font color
		file.Read(&m_bFontBold, 4);	// font flag (bold, italic)
		file.Read(&m_bFontItalic, 4);	// font flag (bold, italic)
	}

	// Child 중에 Scroll Bar 가 있는지 찾아본다.
	for (CN3UIBase* pUI : m_Children)
	{
		if (pUI->UIType() == UI_TYPE_SCROLLBAR)
			m_pScrollBarRef = (CN3UIScrollBar*) pUI;
	}

	return bSuccess;
}

#ifdef _N3TOOL
bool CN3UIList::Save(File& file)
{
	if (!CN3UIBase::Save(file))
		return false;
	
	// font 정보
	int iStrLen = static_cast<int>(m_szFontName.size());
	__ASSERT(iStrLen > 0, "No font name");
	file.Write(&iStrLen, sizeof(iStrLen));			// font 이름 길이 
	if (iStrLen > 0)
	{
		file.Write(m_szFontName.c_str(), iStrLen);				// string
		file.Write(&m_dwFontHeight, 4);	// font height
		file.Write(&m_crFont, 4);	// font color
		file.Write(&m_bFontBold, 4);	// font flag (bold, italic)
		file.Write(&m_bFontItalic, 4);	// font flag (bold, italic)
	}

	return true;
}
#endif // #ifdef _N3TOOL

#ifdef _N3TOOL
void CN3UIList::operator = (const CN3UIList& other)
{
	CN3UIBase::operator = (other);

	m_szFontName = other.m_szFontName;
	m_dwFontHeight = other.m_dwFontHeight;
	m_bFontBold = other.m_bFontBold;
	m_bFontItalic = other.m_bFontItalic;
	m_crFont = other.m_crFont;
}
#endif // #ifdef _N3TOOL

uint32_t CN3UIList::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible || UI_STATE_LIST_DISABLE == m_eState) return dwRet;

	// 특정 이벤트에 대해 메시지 전송..
	if(IsIn(ptCur.x, ptCur.y) && ((dwFlags & UI_MOUSE_LBCLICK) || (dwFlags & UI_MOUSE_LBDBLCLK)) )	
	{
		RECT rc = this->GetRegion(), rcStr;
		SIZE size;

		it_pString it = m_ListString.begin(), itEnd = m_ListString.end();
		for(int i = 0; it != itEnd; it++, i++)
		{
			CN3UIString* pStr = (*it);
			if(false == pStr->IsVisible()) continue;

			pStr->GetTextExtent("1", 1, &size);
			rcStr = pStr->GetRegion();

			rc.top += size.cy;
			rc.bottom += size.cy;

			if(::PtInRect(&rcStr, ptCur))
			{
				m_iCurSel = i;
				if(dwFlags & UI_MOUSE_LBCLICK)
				{
					if(m_pParent) m_pParent->ReceiveMessage(this, UIMSG_LIST_SELCHANGE); // 부모에게 버튼 클릭 통지..
					dwRet |= UIMSG_LIST_SELCHANGE;
				}
				else
				{
					if(m_pParent) m_pParent->ReceiveMessage(this, UIMSG_LIST_DBLCLK); // 부모에게 버튼 클릭 통지..
					dwRet |= UIMSG_LIST_DBLCLK;
				}
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
		}
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

void CN3UIList::Render()
{
	CN3UIBase::Render();

	if (m_iCurSel >= 0
		&& m_iCurSel < static_cast<int>(m_ListString.size()))
	{
		auto it = m_ListString.begin();
		std::advance(it, m_iCurSel);
		CN3UIString* pStr = *it;
		if(pStr)
		{
			RECT rc = pStr->GetRegion(); // 선택 표시
		
			__VertexTransformedColor vLines[5];
			vLines[0].Set((float)rc.left, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
			vLines[1].Set((float)rc.right, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
			vLines[2].Set((float)rc.right, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
			vLines[3].Set((float)rc.left, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
			vLines[4] = vLines[0];
	
			DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
			CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
			CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
			CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
			CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
			CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
			CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
			CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
			CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
			CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
			CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

			CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
			CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, vLines, sizeof(__VertexTransformedColor));
			
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
			CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
			CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
			CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
		}
	}
}

bool CN3UIList::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (UIMSG_SCROLLBAR_POS == dwMsg)
	{
		if (pSender == m_pScrollBarRef)
		{
			this->SetScrollPos(m_pScrollBarRef->GetCurrentPos());
//			return m_pParent->ReceiveMessage(this, UIMSG_SCROLLBAR_POS);
		}
	}

	return true;
}

void CN3UIList::ResetContent()
{
	it_pString it = m_ListString.begin(), itEnd = m_ListString.end();
	for(; it != itEnd; it++)
	{
		
		CN3UIString* pString = *it;
		delete pString;		
	}
	m_ListString.clear();
	m_iCurSel = 0;
	if(m_pScrollBarRef)
	{
		m_pScrollBarRef->SetRange(0, 0);
		m_pScrollBarRef->SetCurrentPos(0);
		m_pScrollBarRef->SetVisibleWithNoSound(false);
	}
}

// ===== END N3Base/N3UIList.cpp =====

// ===== BEGIN N3Base/N3UIList.h =====
#line 1 "N3Base/N3UIList.h"
﻿// N3UIList.h: interface for the CN3UIList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UILIST_H__89CAFCE3_0042_4F6C_A195_E830111DA03F__INCLUDED_)
#define AFX_N3UILIST_H__89CAFCE3_0042_4F6C_A195_E830111DA03F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"
#include <list>

class CN3UIString;
typedef std::list<CN3UIString*>::iterator it_pString;

class CN3UIList : public CN3UIBase  
{
protected:
	int						m_iCurSel;		// 현재 선택..
	std::list<CN3UIString*>	m_ListString;	// String List
	class CN3UIScrollBar*	m_pScrollBarRef;

	std::string				m_szFontName;
	uint32_t				m_dwFontHeight;
	BOOL					m_bFontBold;
	BOOL					m_bFontItalic;
	D3DCOLOR				m_crFont;
	
public:
	const std::string& FontName() const
	{
		return m_szFontName;
	}

	uint32_t FontHeight() const
	{
		return m_dwFontHeight;
	}

	D3DCOLOR FontColor() const
	{
		return m_crFont;
	}

	BOOL FontIsBold() const
	{
		return m_bFontBold;
	}

	BOOL FontIsItalic() const
	{
		return m_bFontItalic;
	}

	void	SetFont(const std::string& szFontName, uint32_t dwHeight, BOOL bBold, BOOL bItalic);
	void	SetFontColor(D3DCOLOR color);
	void	SetFontColor(int iIndex, D3DCOLOR color);

	void	ResetContent();
	void	UpdateChildRegions();
	int		AddStrings(const std::string* pszStrings, int iStringCount);
	int		AddString(const std::string& szString);
	bool	InsertString(int iIndex, const std::string& szString);
	bool	DeleteString(int iIndex);
	bool	GetString(int iIndex, std::string& szString);
	bool	SetString(int iIndex, const std::string& szString);

	int	GetCurSel() const
	{
		return m_iCurSel;
	}

	bool SetCurSel(int iIndex)
	{
		if (iIndex < 0
			|| iIndex >= static_cast<int>(m_ListString.size()))
			m_iCurSel = -1;
		else
			m_iCurSel = iIndex;
		return true;
	}

	CN3UIString* GetChildStrFromList(const std::string& str);

	int GetCount() const
	{
		return static_cast<int>(m_ListString.size());
	}

	int		GetScrollPos() const;
	bool	SetScrollPos(int iScrollPos);
	
	void	Render() override;
	bool	ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool	Load(File& file) override;
	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;

#ifdef _N3TOOL
	bool	Save(File& file) override;
	virtual void	operator = (const CN3UIList& other);
#endif

	void	Release() override;
	CN3UIList();
	~CN3UIList() override;
};

#endif // !defined(AFX_N3UILIST_H__89CAFCE3_0042_4F6C_A195_E830111DA03F__INCLUDED_)

// ===== END N3Base/N3UIList.h =====

// ===== BEGIN N3Base/N3UIProgress.cpp =====
#line 1 "N3Base/N3UIProgress.cpp"
﻿// CN3UIProgress.cpp: implementation of the CN3UIProgress class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIImage.h"
#include "N3UIProgress.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIProgress::CN3UIProgress()
{
	m_eType = UI_TYPE_PROGRESS;

	m_pBkGndImgRef = nullptr;
	m_pFrGndImgRef = nullptr;
	ZeroMemory(&m_frcFrGndImgUV, sizeof(m_frcFrGndImgUV));
	m_iMaxValue = m_iMinValue = 0;
	m_iValueToReach = 0;
	m_fCurValue = 0;
	m_fChangeSpeedPerSec = 0;
	m_fTimeToDelay = 0;					// 지연시간..
}

CN3UIProgress::~CN3UIProgress()
{
}

void CN3UIProgress::Release()
{
	CN3UIBase::Release();

	m_pBkGndImgRef = nullptr;
	m_pFrGndImgRef = nullptr;
	ZeroMemory(&m_frcFrGndImgUV, sizeof(m_frcFrGndImgUV));
	m_iMaxValue = m_iMinValue = 0;
	m_fCurValue = 0;
	m_fChangeSpeedPerSec = 0;
}

void CN3UIProgress::Render()
{
	if(!m_bVisible) return;
	
	CN3UIBase::Render();

	if(m_pBkGndImgRef) m_pBkGndImgRef->Render();
	if(m_pFrGndImgRef) m_pFrGndImgRef->Render();
}

void CN3UIProgress::SetCurValue(int iValue, float fTimeToDelay, float fChangeSpeedPerSec)
{
	if (iValue<m_iMinValue) iValue = m_iMinValue;
	if (iValue>m_iMaxValue) iValue = m_iMaxValue;
	if (fTimeToDelay < 0.0f) fTimeToDelay = 0.0f;
	if (fChangeSpeedPerSec < 0.0f) fChangeSpeedPerSec = 0.0f;

	if (m_iValueToReach == iValue) return;
	
	m_iValueToReach = iValue;
	m_fTimeToDelay = fTimeToDelay; // 지연시간..
	m_fChangeSpeedPerSec = fChangeSpeedPerSec;
	
	if(0.0f == fTimeToDelay  && 0.0f == fChangeSpeedPerSec) // 지연 시간이 없으면 바로 세팅..
	{
		m_fCurValue = (float)iValue;
		UpdateFrGndImage();
	}
}

void CN3UIProgress::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	if (m_pBkGndImgRef) m_pBkGndImgRef->SetRegion(Rect);
	UpdateFrGndImage();
}

void CN3UIProgress::SetStyle(uint32_t dwStyle)
{
	CN3UIBase::SetStyle(dwStyle);
	UpdateFrGndImage();
}

void CN3UIProgress::UpdateFrGndImage()
{
	if (nullptr == m_pFrGndImgRef) return;
	int iDiff = m_iMaxValue - m_iMinValue;
	if (0 == iDiff) return;
	const float fPercentage = ((float)(m_fCurValue - m_iMinValue)) / ((float)(m_iMaxValue - m_iMinValue));

	RECT			rcRegion;
	__FLOAT_RECT	frcUVRect;
	if (m_dwStyle & UISTYLE_PROGRESS_RIGHT2LEFT)
	{
		rcRegion.right = m_rcRegion.right;
		rcRegion.top = m_rcRegion.top;
		rcRegion.bottom = m_rcRegion.bottom;
		rcRegion.left = m_rcRegion.right - ((int)((m_rcRegion.right - m_rcRegion.left)*fPercentage));

		frcUVRect.right = m_frcFrGndImgUV.right;
		frcUVRect.top = m_frcFrGndImgUV.top;
		frcUVRect.bottom = m_frcFrGndImgUV.bottom;
		frcUVRect.left = m_frcFrGndImgUV.right - (m_frcFrGndImgUV.right - m_frcFrGndImgUV.left) *
			((rcRegion.right-rcRegion.left)/((float)(m_rcRegion.right - m_rcRegion.left)));
	}
	else if (m_dwStyle & UISTYLE_PROGRESS_TOP2BOTTOM)
	{
		rcRegion.left = m_rcRegion.left;
		rcRegion.right = m_rcRegion.right;
		rcRegion.top = m_rcRegion.top;
		rcRegion.bottom = m_rcRegion.top + ((int)((m_rcRegion.bottom - m_rcRegion.top)*fPercentage));

		frcUVRect.left = m_frcFrGndImgUV.left;
		frcUVRect.right = m_frcFrGndImgUV.right;
		frcUVRect.top = m_frcFrGndImgUV.top;
		frcUVRect.bottom = m_frcFrGndImgUV.top + (m_frcFrGndImgUV.bottom - m_frcFrGndImgUV.top) *
			((rcRegion.bottom-rcRegion.top)/((float)(m_rcRegion.bottom - m_rcRegion.top)));
	}
	else if (m_dwStyle & UISTYLE_PROGRESS_BOTTOM2TOP)
	{
		rcRegion.left = m_rcRegion.left;
		rcRegion.right = m_rcRegion.right;
		rcRegion.bottom = m_rcRegion.bottom;
		rcRegion.top = m_rcRegion.bottom - ((int)((m_rcRegion.bottom - m_rcRegion.top)*fPercentage));

		frcUVRect.left = m_frcFrGndImgUV.left;
		frcUVRect.right = m_frcFrGndImgUV.right;
		frcUVRect.bottom = m_frcFrGndImgUV.bottom;
		frcUVRect.top = m_frcFrGndImgUV.bottom - (m_frcFrGndImgUV.bottom - m_frcFrGndImgUV.top) *
			((rcRegion.bottom-rcRegion.top)/((float)(m_rcRegion.bottom - m_rcRegion.top)));
	}
	else
	{
		rcRegion.left = m_rcRegion.left;
		rcRegion.top = m_rcRegion.top;
		rcRegion.bottom = m_rcRegion.bottom;
		rcRegion.right = m_rcRegion.left + ((int)((m_rcRegion.right - m_rcRegion.left)*fPercentage));

		frcUVRect.left = m_frcFrGndImgUV.left;
		frcUVRect.top = m_frcFrGndImgUV.top;
		frcUVRect.bottom = m_frcFrGndImgUV.bottom;
		frcUVRect.right = m_frcFrGndImgUV.left + (m_frcFrGndImgUV.right - m_frcFrGndImgUV.left)*
			((rcRegion.right-rcRegion.left)/((float)(m_rcRegion.right - m_rcRegion.left)));
	}

	m_pFrGndImgRef->SetRegion(rcRegion);
	m_pFrGndImgRef->SetUVRect(frcUVRect.left, frcUVRect.top, frcUVRect.right, frcUVRect.bottom);
}

void CN3UIProgress::SetFrGndUVFromFrGndImage()
// m_pFrGndImgRef로부터 uv좌표를 얻어와서 m_frcFrGndImgUV를 세팅한다.
{
	__ASSERT(m_pFrGndImgRef, "not found foreground image in N3UIProgress");
	if (nullptr == m_pFrGndImgRef) return;
	m_frcFrGndImgUV = *(m_pFrGndImgRef->GetUVRect());
	UpdateFrGndImage();
}

bool CN3UIProgress::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;

	// m_ImageRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE != pChild->UIType()) continue;	// image만 골라내기
		int iImageType = (int)(pChild->GetReserved());
		if (iImageType == IMAGETYPE_BKGND)
		{
			m_pBkGndImgRef = (CN3UIImage*)pChild;
		}
		else if (iImageType == IMAGETYPE_FRGND)
		{
			m_pFrGndImgRef = (CN3UIImage*)pChild;
		}
		SetFrGndUVFromFrGndImage();
	}	
	return true;
}

#ifdef _N3TOOL
void CN3UIProgress::operator = (const CN3UIProgress& other)
{
	CN3UIBase::operator = (other);

	m_frcFrGndImgUV = other.m_frcFrGndImgUV;				// m_FrGndImgRef 의 uv좌표
	m_iMaxValue = other.m_iMaxValue;					// 최대
	m_iMinValue = other.m_iMinValue;					// 최소
	m_fCurValue = other.m_fCurValue;					// 현재 값 - 부드럽게 점차 값을 올려가려고 float 로 했다..
	m_fChangeSpeedPerSec = other.m_fChangeSpeedPerSec;			// 현재값이 변해야 되는 속도.. Unit SpeedPerSec
	m_iValueToReach = other.m_iValueToReach;				// 도달해야 될값 - 부드럽게 값이 올라가는 경우에 필요하다..
	m_fTimeToDelay = other.m_fTimeToDelay;					// 지연시간..
	m_iStepValue = other.m_iStepValue;					// 변화값 StepIt()을 통한 변화되는 값

	// m_ImageRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE != pChild->UIType()) continue;	// image만 골라내기
		int iImageType = (int)(pChild->GetReserved());
		if (iImageType == IMAGETYPE_BKGND)
		{
			m_pBkGndImgRef = (CN3UIImage*)pChild;
		}
		else if (iImageType == IMAGETYPE_FRGND)
		{
			m_pFrGndImgRef = (CN3UIImage*)pChild;
		}
	}
	SetFrGndUVFromFrGndImage();
}

bool CN3UIProgress::Save(File& file)
{
	int iCur = (int)m_fCurValue;	// 이전 상태 기억해 놓기
	SetCurValue(m_iMaxValue);	// foreground가 꽉 채운 이미지 만들기
	bool bRet = CN3UIBase::Save(file);	// 저장하기

	SetCurValue((int)m_fCurValue);	// 이전 상태로 되돌리기

	return bRet;
}

void CN3UIProgress::CreateImages()
{
	m_pBkGndImgRef = new CN3UIImage();
	m_pBkGndImgRef->Init(this);
	m_pBkGndImgRef->SetRegion(m_rcRegion);
	m_pBkGndImgRef->SetReserved(IMAGETYPE_BKGND);	// 이 이미지가 배경이미지임을 지정해줌

	m_pFrGndImgRef = new CN3UIImage();
	m_pFrGndImgRef->Init(this);
	m_pFrGndImgRef->SetRegion(m_rcRegion);
	m_pFrGndImgRef->SetReserved(IMAGETYPE_FRGND);	// 이 이미지가 foreground 이미지임을 지정해줌

	// 임시로 넣기
	m_iMaxValue = 100;
	m_iMinValue = 0;
	m_fCurValue = 70;
}

void CN3UIProgress::DeleteBkGndImage()	// Back ground이미지는 필요 없는 경우가 있다.
{
	if (m_pBkGndImgRef)	{ delete m_pBkGndImgRef; m_pBkGndImgRef = nullptr;}
}

#endif

void CN3UIProgress::Tick()
{
	CN3UIBase::Tick();

	if(m_fTimeToDelay > 0)
	{
		m_fTimeToDelay -= s_fSecPerFrm; // 시간 지연
		if(m_fTimeToDelay < 0) m_fTimeToDelay = 0;
		return;
	}

	if(m_fChangeSpeedPerSec <= 0) return;
	if((int)m_fCurValue == m_iValueToReach) return;
	
	if(m_fCurValue < m_iValueToReach)
	{
		m_fCurValue += m_fChangeSpeedPerSec * s_fSecPerFrm; // 초당 30 퍼센트 올라가게 조정..
		if(m_fCurValue > m_iValueToReach) m_fCurValue = (float)m_iValueToReach;
		UpdateFrGndImage();
	}
	else if(m_fCurValue > m_iValueToReach)
	{
		m_fCurValue -= m_fChangeSpeedPerSec * s_fSecPerFrm; // 초당 30 퍼센트 올라가게 조정..
		if(m_fCurValue < m_iValueToReach) m_fCurValue = (float)m_iValueToReach;
		UpdateFrGndImage();
	}
}

// ===== END N3Base/N3UIProgress.cpp =====

// ===== BEGIN N3Base/N3UIProgress.h =====
#line 1 "N3Base/N3UIProgress.h"
﻿// N3UIProgress.h: interface for the CN3UIProgress class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIPROGRESS_H__09307DB0_2F95_4205_AF1D_0262F1CE0E24__INCLUDED_)
#define AFX_N3UIPROGRESS_H__09307DB0_2F95_4205_AF1D_0262F1CE0E24__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"

class CN3UIImage;
class CN3UIProgress : public CN3UIBase  
{
#ifdef _N3TOOL
friend class CPropertyView;	// 툴에서 각 변수들을 접근하기 위해서 
#endif

public:
	CN3UIProgress();
	virtual ~CN3UIProgress();
// Attributes
public:
	enum eIMAGE_TYPE{ IMAGETYPE_BKGND=0, IMAGETYPE_FRGND, NUM_IMAGETYPE};
	int				GetMax() const {return m_iMaxValue;}
	int				GetMin() const {return m_iMinValue;}
	int				GetCurValue() const {return (int)m_fCurValue;}

	void			SetStepValue(int iValue) {m_iStepValue = iValue;}
	void			StepIt() {SetCurValue((int)m_fCurValue + m_iStepValue);}
protected:
	CN3UIImage*		m_pBkGndImgRef;
	CN3UIImage*		m_pFrGndImgRef;

	__FLOAT_RECT	m_frcFrGndImgUV;				// m_FrGndImgRef 의 uv좌표

	int				m_iMaxValue;					// 최대
	int				m_iMinValue;					// 최소
	float			m_fCurValue;					// 현재 값 - 부드럽게 점차 값을 올려가려고 float 로 했다..
	float			m_fChangeSpeedPerSec;			// 현재값이 변해야 되는 속도.. Unit SpeedPerSec
	int				m_iValueToReach;				// 도달해야 될값 - 부드럽게 값이 올라가는 경우에 필요하다..
	float			m_fTimeToDelay;					// 지연시간..
	
	int				m_iStepValue;					// 변화값 StepIt()을 통한 변화되는 값
//	Operations
public:
	void			Tick() override;
	void			Render() override;
	void			Release() override;
	void			SetRegion(const RECT& Rect) override;
	void			SetStyle(uint32_t dwStyle) override;
	bool			Load(File& file) override;

	void			SetCurValue(int iValue, float fTimeToDelay = 0, float fChangeSpeedPerSec = 0);
	void			SetCurValue_Smoothly(int iValue, float fPercentPerSec){SetCurValue(iValue, 0, fPercentPerSec*(m_iMaxValue-m_iMinValue));}	// 초당 몇 퍼센트 수치로 올라간다.
	void			SetRange(int iMin, int iMax) {m_iMinValue = iMin; m_iMaxValue = iMax; UpdateFrGndImage();}
	void			SetFrGndUVFromFrGndImage();	// m_pFrGndImgRef로부터 uv좌표를 얻어와서 m_frcFrGndImgUV를 세팅한다.
protected:
	void			UpdateFrGndImage();	//m_FrGndImgRef 의 영역과 uv좌표를 m_fCurValue에 따라 알맞게 바꾼다.

#ifdef _N3TOOL
// tool에서 사용하는 함수들
public:
	virtual void	operator = (const CN3UIProgress& other);
	bool			Save(File& file) override;
	CN3UIImage*		GetBkGndImgRef() const {return m_pBkGndImgRef;}
	CN3UIImage*		GetFrGndImgRef() const {return m_pFrGndImgRef;}
	void			CreateImages();		// 이미지 생성
	void			DeleteBkGndImage();	// Back ground이미지는 필요 없는 경우가 있다.
#endif
};

#endif // !defined(AFX_N3UIPROGRESS_H__09307DB0_2F95_4205_AF1D_0262F1CE0E24__INCLUDED_)


// ===== END N3Base/N3UIProgress.h =====

// ===== BEGIN N3Base/N3UIScrollBar.cpp =====
#line 1 "N3Base/N3UIScrollBar.cpp"
﻿// N3UIScrollBar.cpp: implementation of the CN3UIScrollBar class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIScrollBar.h"
#include "N3UIButton.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIScrollBar::CN3UIScrollBar()
{
	m_eType = UI_TYPE_SCROLLBAR;
	m_pTrackBarRef = nullptr;
	ZeroMemory(m_pBtnRef, sizeof(CN3UIButton*)*NUM_BTN_TYPE);
	m_iLineSize = 1;
}

CN3UIScrollBar::~CN3UIScrollBar()
{
}

void CN3UIScrollBar::Release()
{
	CN3UIBase::Release();
	m_pTrackBarRef = nullptr;
	ZeroMemory(m_pBtnRef, sizeof(CN3UIButton*)*NUM_BTN_TYPE);
	m_iLineSize = 1;
}

bool CN3UIScrollBar::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;
	__ASSERT(nullptr == m_pTrackBarRef, "scrollbar가 초기화되어 있지 않아여");

	// m_pTrackBarRef, m_pBtnRef  설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_TRACKBAR == pChild->UIType())
		{
			m_pTrackBarRef = (CN3UITrackBar*)pChild;
		}
		else if (UI_TYPE_BUTTON == pChild->UIType())
		{
			int iBtnType = pChild->GetReserved();
			if (iBtnType<0 || iBtnType >= NUM_BTN_TYPE) continue;
			m_pBtnRef[iBtnType] = (CN3UIButton*)pChild;
		}
	}
	return true;
}

void CN3UIScrollBar::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	// 우선 임시로 스크롤 영역 크기와 같게 배치
//	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
//	{
//		(*itor)->SetRegion(Rect);
//	}
}

bool CN3UIScrollBar::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (UIMSG_TRACKBAR_POS == dwMsg)
	{
		if (m_pParent) return m_pParent->ReceiveMessage(this, UIMSG_SCROLLBAR_POS);
	}
	else if (UIMSG_BUTTON_CLICK == dwMsg)
	{
		if (m_pTrackBarRef)
		{
			if (BTN_LEFTUP == pSender->GetReserved()) m_pTrackBarRef->SetCurrentPos(m_pTrackBarRef->GetPos()-m_iLineSize);
			else if (BTN_RIGHTDOWN == pSender->GetReserved()) m_pTrackBarRef->SetCurrentPos(m_pTrackBarRef->GetPos()+m_iLineSize);

			if (m_pParent) return m_pParent->ReceiveMessage(this, UIMSG_SCROLLBAR_POS);
		}
	}
	return true;
}

void CN3UIScrollBar::SetStyle(uint32_t dwStyle)
{
	CN3UIBase::SetStyle(dwStyle);
	if (UISTYLE_SCROLLBAR_HORIZONTAL == dwStyle)
	{
		if (m_pTrackBarRef) m_pTrackBarRef->SetStyle(UISTYLE_TRACKBAR_HORIZONTAL);
	}
	else
	{
		if (m_pTrackBarRef) m_pTrackBarRef->SetStyle(UISTYLE_TRACKBAR_VERTICAL);
	}
}

#ifdef _N3TOOL
void CN3UIScrollBar::operator = (const CN3UIScrollBar& other)
{
	CN3UIBase::operator = (other);
	m_iLineSize = other.m_iLineSize;		// 버튼을 눌렀을때 trackbar가 움직여지는 크기

	// m_pTrackBarRef, m_pBtnRef  설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_TRACKBAR == pChild->UIType())
		{
			m_pTrackBarRef = (CN3UITrackBar*)pChild;
		}
		else if (UI_TYPE_BUTTON == pChild->UIType())
		{
			int iBtnType = pChild->GetReserved();
			if (iBtnType<0 || iBtnType >= NUM_BTN_TYPE) continue;
			m_pBtnRef[iBtnType] = (CN3UIButton*)pChild;
		}
	}
}

void CN3UIScrollBar::CreateTrackBarAndBtns()
{
	__ASSERT(nullptr == m_pTrackBarRef, "구성요소가 이미 할당되어 있어요");
	int i;
	for (i=0; i<NUM_BTN_TYPE; ++i)
	{
		m_pBtnRef[i] = new CN3UIButton();
		m_pBtnRef[i]->Init(this);
		m_pBtnRef[i]->SetReserved(i);		// 상태 번호(eBTN_TYPE) 할당.
		m_pBtnRef[i]->CreateImages();
	}
	
	m_pTrackBarRef = new CN3UITrackBar();
	m_pTrackBarRef->Init(this);
	m_pTrackBarRef->CreateImages();			// trackbar의 이미지 생성
}
#endif
// ===== END N3Base/N3UIScrollBar.cpp =====

// ===== BEGIN N3Base/N3UIScrollBar.h =====
#line 1 "N3Base/N3UIScrollBar.h"
﻿// N3UIScrollBar.h: interface for the CN3UIScrollBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UISCROLLBAR_H__76F849B9_9A93_4439_8FB0_A1DB922CBC73__INCLUDED_)
#define AFX_N3UISCROLLBAR_H__76F849B9_9A93_4439_8FB0_A1DB922CBC73__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"
#include "N3UITrackBar.h"

class CN3UIScrollBar : public CN3UIBase 
{
public:
	CN3UIScrollBar();
	virtual ~CN3UIScrollBar();
// Attributes
public:
	enum eBTN_TYPE	{BTN_LEFTUP=0, BTN_RIGHTDOWN, NUM_BTN_TYPE};
protected:
	CN3UITrackBar*	m_pTrackBarRef;
	CN3UIButton*	m_pBtnRef[NUM_BTN_TYPE];

	int				m_iLineSize;		// 버튼을 눌렀을때 trackbar가 움직여지는 크기

// Operations
public:
	void			Release() override;
	bool			Load(File& file) override;
	void			SetRegion(const RECT& Rect) override;
	void			SetStyle(uint32_t dwStyle) override;
	bool			ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override; // 메시지를 받는다.. 보낸놈, msg

	void			SetRange(int iMin, int iMax) {if(m_pTrackBarRef) m_pTrackBarRef->SetRange(iMin,iMax);}
	void			SetRangeMax(int iMax) {if(m_pTrackBarRef) m_pTrackBarRef->SetRangeMax(iMax);}
	void			SetRangeMin(int iMin) {if(m_pTrackBarRef) m_pTrackBarRef->SetRangeMin(iMin);}
	int				GetCurrentPos() const {if(m_pTrackBarRef) return m_pTrackBarRef->GetPos(); return 0;}
	void			SetCurrentPos(int iPos) {if(m_pTrackBarRef) m_pTrackBarRef->SetCurrentPos(iPos);}
	void			SetPageSize(int iSize) {if(m_pTrackBarRef) m_pTrackBarRef->SetPageSize(iSize);}
	int				GetPageSize() const {if(m_pTrackBarRef) return m_pTrackBarRef->GetPageSize(); return 0;}
	void			SetLineSize(int iSize) {m_iLineSize = iSize;}
	int				GetLineSize() const {return m_iLineSize;}
	int				GetMaxPos() const {if (m_pTrackBarRef) return m_pTrackBarRef->GetMaxPos(); return 0;}

#ifdef _N3TOOL
// tool에서 사용하는 함수들
public:
	virtual void	operator = (const CN3UIScrollBar& other);
	void			CreateTrackBarAndBtns();			// trackbar와 button 생성
	CN3UITrackBar*	GetTrackBarRef() const {return m_pTrackBarRef;}
	CN3UIButton*	GetBtnRef(eBTN_TYPE eBtnType) const {return m_pBtnRef[eBtnType];}
#endif

};

#endif // !defined(AFX_N3UISCROLLBAR_H__76F849B9_9A93_4439_8FB0_A1DB922CBC73__INCLUDED_)

// ===== END N3Base/N3UIScrollBar.h =====

// ===== BEGIN N3Base/N3UIStatic.cpp =====
#line 1 "N3Base/N3UIStatic.cpp"
﻿// N3UIStatic.cpp: implementation of the CN3UIStatic class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIStatic.h"
#include "N3UIString.h"
#include "N3UIImage.h"

#include "N3SndMgr.h"
#include "N3SndObj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIStatic::CN3UIStatic()
{
	m_eType = UI_TYPE_STATIC;

	m_pBuffOutRef = nullptr;
	m_pImageBkGnd = nullptr;
	m_pSnd_Click = nullptr;
}

CN3UIStatic::~CN3UIStatic()
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
}

void CN3UIStatic::Release()
{
	CN3UIBase::Release();
	m_pBuffOutRef = nullptr;
	m_pImageBkGnd = nullptr;
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
}

//void CN3UIStatic::Render()
//{
//	if (!m_bVisible) return;
//	
//	CN3UIBase::Render();
//
////	if (m_pImageBkGnd) m_pImageBkGnd->Render();
////	if (m_pBuffOutRef) m_pBuffOutRef->Render();
//}

void CN3UIStatic::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);

	for (CN3UIBase* pChild : m_Children)
		pChild->SetRegion(Rect);
}

bool CN3UIStatic::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	// m_pImageBkGnd,  m_pBuffOutRef 설정하기
	for (CN3UIBase* pChild : m_Children)
	{
		if (UI_TYPE_IMAGE == pChild->UIType())
			m_pImageBkGnd = (CN3UIImage*)pChild;
		else if (UI_TYPE_STRING == pChild->UIType())
			m_pBuffOutRef = (CN3UIString*)pChild;
	}
	
	// 이전 uif파일을 컨버팅 하려면 사운드 로드 하는 부분 막기
	int iSndFNLen = 0;
	file.Read(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
	{
		std::string filename(iSndFNLen, '\0');
		file.Read(&filename[0], iSndFNLen);

		__ASSERT(nullptr == m_pSnd_Click, "memory leak");
		m_pSnd_Click = s_SndMgr.CreateObj(filename, SNDTYPE_2D);
	}

	return true;
}

const std::string& CN3UIStatic::GetString()
{
	if (m_pBuffOutRef) return m_pBuffOutRef->GetString();
	else return s_szStringTmp;
}

void CN3UIStatic::SetString(const std::string& szString)
{
	if (m_pBuffOutRef) m_pBuffOutRef->SetString(szString);
}


uint32_t CN3UIStatic::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

	if((dwFlags & UI_MOUSE_LBCLICK) && IsIn(ptCur.x, ptCur.y))  // 왼쪽버튼 눌르는 순간 영역 안이면
	{
		if (m_pSnd_Click) m_pSnd_Click->Play();	// 사운드가 있으면 play하기

		if(m_pParent) m_pParent->ReceiveMessage(this, UIMSG_BUTTON_CLICK); // 부모에게 버튼 클릭 통지..
		dwRet |= (UI_MOUSEPROC_DONESOMETHING|UI_MOUSEPROC_INREGION);
		return dwRet;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

#ifdef _N3TOOL
void CN3UIStatic::operator = (const CN3UIStatic& other)
{
	CN3UIBase::operator = (other);

	SetSndClick(other.GetSndFName_Click());

	// m_pImageBkGnd,  m_pBuffOutRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE == pChild->UIType())
		{
			m_pImageBkGnd = (CN3UIImage*)pChild;
		}
		else if (UI_TYPE_STRING == pChild->UIType())
		{
			m_pBuffOutRef = (CN3UIString*)pChild;
		}
	}
}

bool CN3UIStatic::Save(File& file)
{
	if (!CN3UIBase::Save(file))
		return false;

	int iSndFNLen = 0;
	if (m_pSnd_Click != nullptr)
		iSndFNLen = static_cast<int>(m_pSnd_Click->m_szFileName.size());
	file.Write(&iSndFNLen, sizeof(iSndFNLen));		//	사운드 파일 문자열 길이
	if (iSndFNLen > 0)
		file.Write(m_pSnd_Click->m_szFileName.c_str(), iSndFNLen);
	return true;
}

void CN3UIStatic::CreateImageAndString()
{
	m_pImageBkGnd = new CN3UIImage();
	m_pImageBkGnd->Init(this);
	m_pImageBkGnd->SetRegion(m_rcRegion);

	m_pBuffOutRef = new CN3UIString();		// 화면에 표시할 ui string 생성하고 
	m_pBuffOutRef->Init(this);				// 초기화(자동으로 children list 들어간다.)
	m_pImageBkGnd->SetRegion(m_rcRegion);
}

void CN3UIStatic::DeleteImage()
{
	if (m_pImageBkGnd) {delete m_pImageBkGnd; m_pImageBkGnd = nullptr;}
}

void CN3UIStatic::SetSndClick(const std::string& strFileName)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Click);
	if (0 == strFileName.size()) return;

	CN3BaseFileAccess tmpBase;
	tmpBase.FileNameSet(strFileName);	// Base경로에 대해서 상대적 경로를 넘겨준다.

	SetCurrentDirectory(tmpBase.PathGet().c_str());
	m_pSnd_Click = s_SndMgr.CreateObj(tmpBase.FileName(), SNDTYPE_2D);
}

std::string CN3UIStatic::GetSndFName_Click() const
{
	if (m_pSnd_Click) return m_pSnd_Click->m_szFileName;
	else return std::string("");
}
#endif

// ===== END N3Base/N3UIStatic.cpp =====

// ===== BEGIN N3Base/N3UIStatic.h =====
#line 1 "N3Base/N3UIStatic.h"
﻿// N3UIStatic.h: interface for the CN3UIStatic class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UISTATIC_H__CF0050A8_2813_40CB_B696_1CB689FDCC41__INCLUDED_)
#define AFX_N3UISTATIC_H__CF0050A8_2813_40CB_B696_1CB689FDCC41__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"

class CN3UIStatic : public CN3UIBase  
{
public:
	CN3UIStatic();
	virtual ~CN3UIStatic();
// Attributes
protected:
	CN3UIString*	m_pBuffOutRef;		// CN3UIString 참조 포인터 (실제는 child리스트에서 관리)
	CN3UIImage*		m_pImageBkGnd;		// 배경 이미지 참조 포인터 (실제는 child리스트에서 관리)
	CN3SndObj*		m_pSnd_Click;	// static이 눌리는 순간 내는 소리
	
// Operations
public:
	virtual const std::string& GetString();
	virtual void	SetString(const std::string& szString);
	void	Release() override;
//	void	Render() override;
	bool	Load(File& file) override;
	void	SetRegion(const RECT& Rect) override;
	uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
protected:

#ifdef _N3TOOL
// 툴에서만 사용하는 함수
public:
	virtual	void	operator = (const CN3UIStatic& other);
	bool			Save(File& file) override;
	void			CreateImageAndString();		// 배경 이미지 및 string 생성하기
	CN3UIImage*		GetImageBkGnd() const {return m_pImageBkGnd;}
	CN3UIString*	GetUIString() const {return m_pBuffOutRef;}
	void			DeleteImage();		// 이미지를 사용하지 않는 static일 경우 호출하면 지워진다.
	void			SetSndClick(const std::string& strFileName);
	std::string		GetSndFName_Click() const;
#endif
};	
#endif // !defined(AFX_N3UISTATIC_H__CF0050A8_2813_40CB_B696_1CB689FDCC41__INCLUDED_)

// ===== END N3Base/N3UIStatic.h =====

// ===== BEGIN N3Base/N3UIString.cpp =====
#line 1 "N3Base/N3UIString.cpp"
﻿// N3UIString.cpp: implementation of the CN3UIString class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UIString.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIString::CN3UIString()
{
	m_eType = UI_TYPE_STRING;
	m_pDFont = nullptr;

	m_Color = 0xffffffff;
	ZeroMemory(&m_ptDrawPos, sizeof(m_ptDrawPos));
	m_iLineCount = 0;
	m_iStartLine = 0;
	m_iIdk0 = 0;
}

CN3UIString::~CN3UIString()
{
	delete m_pDFont;	m_pDFont = nullptr;
}

void CN3UIString::Release()
{
	CN3UIBase::Release();

	m_szString = "";
	delete m_pDFont;	m_pDFont = nullptr;
	m_Color = 0xffffffff;

	ZeroMemory(&m_ptDrawPos, sizeof(m_ptDrawPos));
	m_iLineCount = 0;
	m_iStartLine = 0;
	m_NewLineIndices.clear();
}

void CN3UIString::Render()
{
	if(!m_bVisible) return;
	
	__ASSERT(m_pDFont,"m_pDFont is NULL");
	m_pDFont->DrawText((float)m_ptDrawPos.x, (float)m_ptDrawPos.y, m_Color, 0 );

	CN3UIBase::Render();
}

void CN3UIString::Init(CN3UIBase* pParent)
{
	CN3UIBase::Init(pParent);

	if(m_pDFont) delete m_pDFont; m_pDFont = nullptr;
	m_pDFont = new CDFont("굴림", 16);	// default 로 굴림 16으로 설정
	m_pDFont->InitDeviceObjects( CN3Base::s_lpD3DDev );
	m_pDFont->RestoreDeviceObjects();
}

void CN3UIString::SetString(const std::string& szString)
{
	m_szString = szString;

	if(m_szString.empty()) m_pDFont->SetText("");
	else WordWrap();
}

void CN3UIString::SetStringAsInt(int iVal)
{
	std::string buff = std::to_string(iVal);
	SetString(buff);
}

void CN3UIString::SetString_NoWordWrap(const std::string& szString)
{
	// 왼쪽위 정렬해서 그린다.
	m_ptDrawPos.x = m_rcRegion.left;
	m_ptDrawPos.y = m_rcRegion.top;

	m_pDFont->SetText(szString.c_str());
}

void CN3UIString::SetFont(const std::string& szFontName, uint32_t dwHeight, BOOL bBold, BOOL bItalic)
{
	uint32_t dwFlag = 0;
	if (bBold) dwFlag |= D3DFONT_BOLD;
	if (bItalic) dwFlag |= D3DFONT_ITALIC;
	if (m_pDFont)
	{
		m_pDFont->SetFont(szFontName, dwHeight, dwFlag);
		WordWrap();
	}
}

void CN3UIString::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	WordWrap();
}

void CN3UIString::SetStyle(uint32_t dwStyle)
{
	CN3UIBase::SetStyle(dwStyle);
	WordWrap();
}

// 글씨찍는 위치도 바뀌어 준다.
BOOL CN3UIString::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (FALSE == CN3UIBase::MoveOffset(iOffsetX, iOffsetY)) return FALSE;
	m_ptDrawPos.x += iOffsetX;	m_ptDrawPos.y += iOffsetY;
	return TRUE;
}

// 문자를 dwStyle에 맞게 정렬해준다.
void CN3UIString::WordWrap()
{
	m_iLineCount = 0;

	if (m_pDFont == nullptr)
		return;

	int iStrLen = static_cast<int>(m_szString.size());

	if (0 == iStrLen)
	{
		m_pDFont->SetText("");

		// 글씨를 찍지는 않지만 edit의 경우 caret을 찍기때문에 글씨 그리는 좌표를 세팅해준다.
		if (m_dwStyle & UISTYLE_STRING_SINGLELINE)
		{
			if (m_dwStyle & UISTYLE_STRING_ALIGNCENTER)	m_ptDrawPos.x = m_rcRegion.left + (m_rcRegion.right - m_rcRegion.left)/2;
			else m_ptDrawPos.x = m_rcRegion.left;

			if (m_dwStyle & UISTYLE_STRING_ALIGNVCENTER)
			{
				// 문자열의 pixel 길이 측정
				SIZE sizeTmp = {0, 0};
				m_pDFont->GetTextExtent("가", 2, &sizeTmp);
				m_ptDrawPos.y = m_rcRegion.top + ((m_rcRegion.bottom - m_rcRegion.top-sizeTmp.cy)/2);
			}
			else m_ptDrawPos.y = m_rcRegion.top;
		}
		else
		{
			m_ptDrawPos.x = m_rcRegion.left;
			m_ptDrawPos.y = m_rcRegion.top;
		}

		return;
	}

	// 문자열의 pixel 길이 측정
	SIZE size;
	const std::string szString = GetString();
	iStrLen = static_cast<int>(szString.size());
	if (FALSE == m_pDFont->GetTextExtent(szString.c_str(), iStrLen, &size))
	{	// 길이를 측정할 수 없을경우(m_hDC가 생성되지 않았을경우)
		m_pDFont->SetText(szString);
		return;
	}

	int iRegionWidth = m_rcRegion.right - m_rcRegion.left;
	int iRegionHeight = m_rcRegion.bottom - m_rcRegion.top;

	if (m_dwStyle & UISTYLE_STRING_SINGLELINE)
	{
		// 임시 변수 잡기
		std::string szNewBuff;

		/*if (size.cy>iRegionHeight)	// 글자 높이가 해당 영역보다 큰 경우
		{	
			// NOTE: need to look into putting this back!!!

			m_ptDrawPos.y = m_rcRegion.top;
			//m_pDFont->SetText("글자 높이가 STRING control보다 큽니다.");
			m_pDFont->SetText("Temp1");
			return;
		}
		else*/ if (size.cx <= iRegionWidth)	// 글자 가로 길이가 영역 길이보다 작을경우
		{
			szNewBuff = m_szString;

			// 가로 정렬 
			if (m_dwStyle & UISTYLE_STRING_ALIGNRIGHT) m_ptDrawPos.x = m_rcRegion.right - size.cx;
			else if (m_dwStyle & UISTYLE_STRING_ALIGNCENTER) m_ptDrawPos.x = m_rcRegion.left + ((iRegionWidth-size.cx)/2);
			else m_ptDrawPos.x = m_rcRegion.left;
			// 세로 정렬
			if (m_dwStyle & UISTYLE_STRING_ALIGNBOTTOM) m_ptDrawPos.y = m_rcRegion.bottom-size.cy;
			else if (m_dwStyle & UISTYLE_STRING_ALIGNVCENTER) m_ptDrawPos.y = m_rcRegion.top + ((iRegionHeight-size.cy)/2);
			else m_ptDrawPos.y = m_rcRegion.top;
			m_iLineCount = 1;
		}
		else	// 글자 가로 길이가 영역 길이보다 클경우 영역안에 들어가는 글자만 표시하자.
		{
			// 가로 정렬은 왼쪽 정렬로.
			m_ptDrawPos.x = m_rcRegion.left;
			// 세로 정렬
			if (m_dwStyle & UISTYLE_STRING_ALIGNBOTTOM) m_ptDrawPos.y = m_rcRegion.bottom-size.cy;
			else if (m_dwStyle & UISTYLE_STRING_ALIGNVCENTER) m_ptDrawPos.y = m_rcRegion.top + ((iRegionHeight-size.cy)/2);
			else m_ptDrawPos.y = m_rcRegion.top;

			// 글자 자르는 코드
			int iCount = 0;
			while(iCount<iStrLen)
			{
				if ('\n' == szString[iCount])		// \n
				{
					break;
				}
				else if (0x80 & szString[iCount])	// 2BYTE 문자
				{
					BOOL bFlag = m_pDFont->GetTextExtent(szString.c_str(), iCount+2, &size);
					__ASSERT(bFlag, "cannot get size of dfont");
					if (size.cx>iRegionWidth) break;
					iCount += 2;
				}
				else								// 1BYTE 문자
				{
					BOOL bFlag = m_pDFont->GetTextExtent(szString.c_str(), iCount+1, &size);
					__ASSERT(bFlag, "cannot get size of dfont");
					if (size.cx>iRegionWidth) break;
					++iCount;
				}
			}
			// strDisplayString 에 iCount 만큼만 카피하기
			szNewBuff = m_szString.substr(0, iCount);	// +1은 맨 마지막에 nullptr 넣기 위해
			m_iLineCount = 1;
		}
		m_pDFont->SetText(szNewBuff);

	}
	else
	{	// mutiline일때는 항상 왼쪽 정렬해서 그린다.
		m_ptDrawPos.x = m_rcRegion.left;
		m_ptDrawPos.y = m_rcRegion.top;

		m_NewLineIndices.clear();	// 새로운 라인 인덱스 클리어

		// 글자 자르는 코드, 영역 밖으로 벗어나는 글자는 찍지 않는다.
		int iCX=0;//, iCY=0;
		int iCount = 0;

		// 우선 맨 처음 한줄이 들어갈 수 있는 크기인지 체크하기
		BOOL bFlag = m_pDFont->GetTextExtent("최", 2, &size);
		__ASSERT(bFlag, "cannot get size of dfont");
//		iCY += size.cy;
//		if (iCY > iRegionHeight)
		if (size.cy > iRegionHeight)
		{
			// NOTE: need to look into returning this back !!!

			//m_pDFont->SetText("글자 높이가 STRING control보다 큽니다.");
			//m_pDFont->SetText("Temp2");
			//return;
		}

		m_iLineCount = 1;	// 여기까지 오면 1줄은 찍힌다.
		m_NewLineIndices.push_back(0);	// 맨 첨 시작은 0

		while(iCount<iStrLen)
		{
			if ('\n' == szString[iCount])		// \n
			{
//				szNewBuff += '\n';
//				iCY += size.cy;
//				if (iCY > iRegionHeight) break;	// 세로 범위가 넘으면 더이상 글자를 찍지 않는다.
				++iCount;
				iCX = 0;
				if (iCount<iStrLen-1)
				{
					++m_iLineCount;	// 마지막 글자가 아닐경우 한줄 더하기 
					m_NewLineIndices.push_back(iCount);
				}
			}
			else
			{
				int iCC=0;
				if (0x80 & szString[iCount])	iCC = 2;	// 2BYTE 문자
				else iCC = 1;	// 1BYTE 문자

				BOOL bFlag = m_pDFont->GetTextExtent(&(szString[iCount]), iCC, &size);
				__ASSERT(bFlag, "cannot get size of dfont");
				if ((iCX+size.cx) > iRegionWidth)	// 가로 길이가 넘었으면
				{
//					szNewBuff += '\n';	// 다음줄로 내린다.
					iCX = 0;
//					iCY += size.cy;
//					if (iCY > iRegionHeight) break;	// 세로 범위가 넘으면 더이상 글자를 찍지 않는다.
					if (iCount<iStrLen-1)
					{
						++m_iLineCount;	// 마지막 글자가 아닐경우 한줄 더하기 
						m_NewLineIndices.push_back(iCount);
					}
				}
				// 글자 카피
//				szNewBuff += szString.substr(iCount, iCC);
				
				iCount += iCC;
				iCX += size.cx;
			}
		}
		SetStartLine(0);
	}
	//m_pDFont->SetText(szNewBuff);
}

void CN3UIString::SetStartLine(int iLine)
{
	if ((m_dwStyle & UISTYLE_STRING_SINGLELINE) || iLine >= m_iLineCount) return;
	m_iStartLine = iLine;

	SIZE size = {0,0};
	BOOL bFlag = m_pDFont->GetTextExtent("최", 2, &size);
	__ASSERT(bFlag, "cannot get size of dfont");
	if (0 == size.cy) return;

	int iEndLine = m_iStartLine + ((m_rcRegion.bottom - m_rcRegion.top)/size.cy);
	bool bMoreLine = true;
	if (iEndLine >= m_iLineCount)
	{
		iEndLine = m_iLineCount;
		bMoreLine = false;
	}
	int i, iCC;
	std::string strNew;
	for (i = m_iStartLine; i < iEndLine - 1; ++i)
	{
		iCC = m_NewLineIndices[i + 1] - m_NewLineIndices[i];
		if (iCC > 0)
		{
			strNew += m_szString.substr(m_NewLineIndices[i], iCC);
			if (strNew.size() > 0
				&& ('\n' != strNew[strNew.size() - 1]))
				strNew += "\n";
		}
	}

	// 마지막줄 처리
	if (bMoreLine)
	{
		if (iEndLine > 0)
		{
			iCC = m_NewLineIndices[iEndLine] - m_NewLineIndices[iEndLine - 1];
			if (iCC > 0)
				strNew += m_szString.substr(m_NewLineIndices[i], iCC);
		}
	}
	else
	{
		if (iEndLine > 0)
		{
			iCC = static_cast<int>(m_szString.size()) - m_NewLineIndices[iEndLine - 1];
			if (iCC > 0)
				strNew += m_szString.substr(m_NewLineIndices[i], iCC);
		}
	}

	m_pDFont->SetText(strNew);
}

bool CN3UIString::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	// font 정보
	int iStrLen = 0;
	file.Read(&iStrLen, sizeof(iStrLen));			// font 이름 길이 
	if (iStrLen>0)
	{
		std::string szFontName(iStrLen, '?');
		file.Read(&(szFontName[0]), iStrLen);				// string

		uint32_t dwFontFlags = 0, dwFontHeight = 0;
		file.Read(&dwFontHeight, sizeof(dwFontHeight));	// font height
		file.Read(&dwFontFlags, sizeof(dwFontFlags));	// font flag (bold, italic)

		SetFont(szFontName, dwFontHeight, dwFontFlags & D3DFONT_BOLD, dwFontFlags & D3DFONT_ITALIC);	// 글꼴 지정
	}
#ifdef _N3TOOL
	else
	{
		SetFont("굴림", 10, FALSE, FALSE);	// 임시로 글꼴 지정
		MessageBox(s_hWndBase, "폰트가 지정되지 않은 UIString이 있어서 굴림(10)으로 설정하였습니다.", "No font", MB_OK);
	}
#else
	__ASSERT(iStrLen>0, "No font name");
#endif

	// string
	file.Read(&m_Color, sizeof(m_Color));			// 글자 색
	file.Read(&iStrLen, sizeof(iStrLen));			// string 길이 
	if (iStrLen>0)
	{
		std::string szString(iStrLen, '?');
		file.Read(&(szString[0]), iStrLen);				// string
		SetString(szString);
	}

	// NOTE: testing UI string
	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
		file.Read(&m_iIdk0, sizeof(int));

	return true;
}

void CN3UIString::operator = (const CN3UIString& other)
{
	CN3UIBase::operator = (other);

	m_ptDrawPos = other.m_ptDrawPos;		// 실제 화면에 표시될 글자의 제일 왼쪽 상단 좌표
	m_Color = other.m_Color;			// 글자 색

	// 폰트 설정
	uint32_t dwFontFlags = other.GetFontFlags();
	SetFont(other.GetFontName(), other.GetFontHeight(), dwFontFlags & D3DFONT_BOLD, dwFontFlags & D3DFONT_ITALIC);

	// 글씨 설정
	this->SetString(other.m_szString); // m_szString = other.m_szString;			// string buffer
}

#ifdef _N3TOOL
bool CN3UIString::Save(File& file)
{
	if (!CN3UIBase::Save(file))
		return false;

	// font 정보
	char* pszFontName = nullptr;
	__ASSERT(m_pDFont, "no font");
	const std::string strFontName(m_pDFont->GetFontName());
	int iStrLen = static_cast<int>(strFontName.size());
	__ASSERT(iStrLen > 0, "No font name");
	file.Write(&iStrLen, sizeof(iStrLen));			// font 이름 길이 
	if (iStrLen > 0)
	{
		file.Write(strFontName.c_str(), iStrLen);				// string
		uint32_t dwFontFlags = 0, dwFontHeight = 0;

		if (m_pDFont != nullptr)
		{
			dwFontHeight = m_pDFont->GetFontHeight();
			dwFontFlags = m_pDFont->GetFontFlags();
		}

		file.Write(&dwFontHeight, sizeof(dwFontHeight));	// font height
		file.Write(&dwFontFlags, sizeof(dwFontFlags));	// font flag (bold, italic)
	}

	// string
	file.Write(&m_Color, sizeof(m_Color));				// 글자 색
	iStrLen = static_cast<int>(m_szString.size());
	file.Write(&iStrLen, sizeof(iStrLen));				// string 길이 
	if (iStrLen > 0)
		file.Write(m_szString.c_str(), iStrLen);			// string

	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
		file.Write(&m_iIdk0, sizeof(int));

	return true;
}

void CN3UIString::ChangeFont(const std::string& szFont)
{
	if(m_pDFont)
	{
		uint32_t dwFlag = m_pDFont->GetFontFlags();
		bool bBold = (dwFlag & D3DFONT_BOLD) ? true : false;
		bool bItalic = (dwFlag & D3DFONT_ITALIC) ? true : false;
		this->SetFont(szFont, m_pDFont->GetFontHeight(), bBold, bItalic);
	}

	CN3UIBase::ChangeFont(szFont);
}
#endif

int CN3UIString::GetStringRealWidth(int iNum) const
{
	SIZE size;
	BOOL bFlag = m_pDFont->GetTextExtent("가", lstrlen("가"), &size);
	__ASSERT(bFlag, "cannot get size of dfont");
	//int iLength = iNum/2;
	//if (iLength == 0) return 0;
	//return (size.cx*iLength); 
	return (size.cx*iNum) / 2;
}

int	CN3UIString::GetStringRealWidth(const std::string& szText) const
{
	if (szText.empty())
		return 0;

	int iRealWidth = 0;
	for (size_t i = 0; i < szText.size();)
	{
		char c = szText[i];

		SIZE size = { 0, 0 };
		if (c & 0x80)
		{
			m_pDFont->GetTextExtent(&szText[i], 2, &size);
			i += 2;
		}
		else
		{
			m_pDFont->GetTextExtent(&szText[i], 1, &size);
			i += 1;
		}

		iRealWidth += size.cx;
	}

	return iRealWidth;
}

void CN3UIString::SetStyle(uint32_t dwType, uint32_t dwStyleEx)
{
	if (dwType == UI_STR_TYPE_LINE)
	{
		uint32_t dwStyle = m_dwStyle;
		if (UISTYLE_STRING_SINGLELINE == dwStyleEx) dwStyle |= UISTYLE_STRING_SINGLELINE;
		else if (UISTYLE_STRING_MULTILINE == dwStyleEx) dwStyle &= (~UISTYLE_STRING_SINGLELINE);
		SetStyle(dwStyle);
	}
	else if (dwType == UI_STR_TYPE_HALIGN)
	{
		uint32_t dwStyle = m_dwStyle;
		dwStyle &= (~UISTYLE_STRING_ALIGNLEFT);
		dwStyle &= (~UISTYLE_STRING_ALIGNCENTER);
		dwStyle &= (~UISTYLE_STRING_ALIGNRIGHT);
		if (UISTYLE_STRING_ALIGNLEFT == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNLEFT;
		else if (UISTYLE_STRING_ALIGNCENTER == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNCENTER;
		else if (UISTYLE_STRING_ALIGNRIGHT == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNRIGHT;
		SetStyle(dwStyle);
	}
	else if (dwType == UI_STR_TYPE_VALIGN)
	{
		uint32_t dwStyle = m_dwStyle;
		dwStyle &= (~UISTYLE_STRING_ALIGNTOP);
		dwStyle &= (~UISTYLE_STRING_ALIGNVCENTER);
		dwStyle &= (~UISTYLE_STRING_ALIGNBOTTOM);
		if (UISTYLE_STRING_ALIGNTOP == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNTOP;
		else if (UISTYLE_STRING_ALIGNVCENTER == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNVCENTER;
		else if (UISTYLE_STRING_ALIGNBOTTOM == dwStyleEx) dwStyle |= UISTYLE_STRING_ALIGNBOTTOM;
		SetStyle(dwStyle);
	}
}

uint32_t CN3UIString::MouseProc(uint32_t dwFlags, const POINT &ptCur, const POINT &ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

#ifndef _REPENT
#ifdef _N3GAME
	if (s_bWaitFromServer)
		return dwRet;
#endif
#endif

	// 특정 이벤트에 대해 메시지 전송..
	if(IsIn(ptCur.x, ptCur.y) && (dwFlags & UI_MOUSE_LBCLICKED) )	
	{
		m_pParent->ReceiveMessage(this, UIMSG_STRING_LCLICK); // 부모에게 버튼 클릭 통지..
//		dwRet |= UI_MOUSEPROC_DONESOMETHING;
	}

	if(IsIn(ptCur.x, ptCur.y) && (dwFlags & UI_MOUSE_LBDBLCLK) )	
	{
		m_pParent->ReceiveMessage(this, UIMSG_STRING_LDCLICK); // 부모에게 버튼 클릭 통지..
//		dwRet |= UI_MOUSEPROC_DONESOMETHING;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

// ===== END N3Base/N3UIString.cpp =====

// ===== BEGIN N3Base/N3UIString.h =====
#line 1 "N3Base/N3UIString.h"
﻿// N3UIString.h: interface for the CN3UIString class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UISTRING_H__E3559B01_72AE_4651_804D_B96D22738ED8__INCLUDED_)
#define AFX_N3UISTRING_H__E3559B01_72AE_4651_804D_B96D22738ED8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <string>
#include <vector>
#include "N3UIBase.h"
#include "DFont.h"

class CDFont;
class CN3UIString : public CN3UIBase  
{
	friend class CN3UIEdit;
#ifdef _N3TOOL
friend class CPropertyView;	// 툴에서 각 변수들을 접근하기 위해서 
#endif

protected:
	CDFont*			m_pDFont;			// DFont(실제 글자를 화면에 찍어주는 클래스다)
	POINT			m_ptDrawPos;		// 실제 화면에 표시될 글자의 제일 왼쪽 상단 좌표
	std::string 	m_szString;			// string buffer
	D3DCOLOR		m_Color;			// 글자 색
	int				m_iLineCount;		// 현재 세팅된 글씨들의 line수
	std::vector<int>	m_NewLineIndices;	// multiline일경우 새로운 라인의 인덱스들
	int				m_iStartLine;		// multiline일경우 글씨가 찍히는 시작 라인번호
	int				m_iIdk0;

public:
	CN3UIString();
	virtual ~CN3UIString();

// Attributes
public:
	void				SetColor(D3DCOLOR color) { m_Color = color; }
	D3DCOLOR			GetColor() const { return m_Color; }
	const std::string&	GetString() { return m_szString; }
	int					GetLineCount() const {return m_iLineCount;}
	int					GetStartLine() const {return m_iStartLine;}
	int					GetStringRealWidth(int iNum) const;
	int					GetStringRealWidth(const std::string& szText) const;

	uint32_t		MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	void			Render() override;
	void			Release() override;
	void			Init(CN3UIBase* pParent) override;
	BOOL			MoveOffset(int iOffsetX, int iOffsetY) override;// 글씨찍는 위치도 바뀌어 준다.
	bool			Load(File& file) override;
	void			ClearOnlyStringBuffer() { m_szString.clear(); }	// string 버퍼만 지운다.
	void			SetStartLine(int iLine);	// multiline일경우 시작하는 라인 변경하기

	virtual void	operator = (const CN3UIString& other);

#ifdef _N3TOOL
	bool			Save(File& file) override;
	virtual void	ChangeFont(const std::string& szFont);
#endif
	
	void			SetRegion(const RECT& Rect) override;
	void			SetStyle(uint32_t dwStyle) override;
	virtual void	SetStyle(uint32_t dwType, uint32_t dwStyleEx);

	virtual void	SetString(const std::string& szString);
	virtual void	SetStringAsInt(int iVal);
	void			SetString_NoWordWrap(const std::string& szString);	// 글자 정렬 하지 않는다.
	virtual void	SetFont(const std::string& szFontName, uint32_t dwHeight, BOOL bBold, BOOL bItalic); // dwHeight는 point size이다.

	BOOL			GetTextExtent(const std::string& szString, int iStrLen, SIZE* pSize )
	{
		if (m_pDFont) return m_pDFont->GetTextExtent(szString, iStrLen, pSize);
		return FALSE;
	}

	uint32_t				GetFontColor() const {if (m_pDFont) return m_pDFont->GetFontColor(); return 0xffffffff;}
	const std::string&		GetFontName() const {if (m_pDFont) return m_pDFont->GetFontName(); return s_szStringTmp;} 
	uint32_t				GetFontHeight() const {if (m_pDFont) return m_pDFont->GetFontHeight(); return 0;} 
	uint32_t				GetFontFlags() const {if (m_pDFont) return m_pDFont->GetFontFlags(); return 0;}

protected:
	void				WordWrap();		// wordwrap
};

#endif // !defined(AFX_N3UISTRING_H__E3559B01_72AE_4651_804D_B96D22738ED8__INCLUDED_)

// ===== END N3Base/N3UIString.h =====

// ===== BEGIN N3Base/N3UITooltip.cpp =====
#line 1 "N3Base/N3UITooltip.cpp"
﻿// N3UITooltip.cpp: implementation of the CN3UITooltip class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UITooltip.h"
#include "N3UIString.h"
#include "N3UIStatic.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UITooltip::CN3UITooltip()
{
	m_eType = UI_TYPE_TOOLTIP;

	m_fHoverTime = 0.0f;
	m_bVisible = false;
	m_bSetText = false;
	memset(&m_ptCursor, 0, sizeof(m_ptCursor));
}

CN3UITooltip::~CN3UITooltip()
{
}

void CN3UITooltip::Release()
{
	CN3UIBase::Release();

	m_fHoverTime = 0.0f;
	m_bVisible = false;
	m_bSetText = false;
	memset(&m_ptCursor, 0, sizeof(m_ptCursor));
}

void CN3UITooltip::Render()
{
	if (!IsVisible()
		|| !m_bSetText)
		return;

	if (m_pImageBkGnd != nullptr)
	{
		CN3UIStatic::Render();
	}
	// 이미지가 없으면 디폴트로 그려주자
	else
	{
		__VertexTransformedColor pVB[8];

		constexpr WORD pIB[16]				= { 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4 };
		constexpr D3DCOLOR BkColor			= 0x80000000;
		constexpr D3DCOLOR BorderColorOut	= 0xff808080;
		constexpr D3DCOLOR BorderColorIn	= 0xffc0c0c0;

		pVB[0].Set(static_cast<float>(m_rcRegion.left),			static_cast<float>(m_rcRegion.top), UI_DEFAULT_Z, UI_DEFAULT_RHW, BkColor);
		pVB[1].Set(static_cast<float>(m_rcRegion.right),		static_cast<float>(m_rcRegion.top), UI_DEFAULT_Z, UI_DEFAULT_RHW, BkColor);
		pVB[2].Set(static_cast<float>(m_rcRegion.right),		static_cast<float>(m_rcRegion.bottom), UI_DEFAULT_Z, UI_DEFAULT_RHW, BkColor);
		pVB[3].Set(static_cast<float>(m_rcRegion.left),			static_cast<float>(m_rcRegion.bottom), UI_DEFAULT_Z, UI_DEFAULT_RHW, BkColor);
		pVB[4].Set(static_cast<float>(m_rcRegion.left) + 1,		static_cast<float>(m_rcRegion.top) + 1, UI_DEFAULT_Z, UI_DEFAULT_RHW, BorderColorIn);
		pVB[5].Set(static_cast<float>(m_rcRegion.right) - 1,	static_cast<float>(m_rcRegion.top) + 1, UI_DEFAULT_Z, UI_DEFAULT_RHW, BorderColorIn);
		pVB[6].Set(static_cast<float>(m_rcRegion.right) - 1,	static_cast<float>(m_rcRegion.bottom) - 1, UI_DEFAULT_Z, UI_DEFAULT_RHW, BorderColorIn);
		pVB[7].Set(static_cast<float>(m_rcRegion.left) + 1,		static_cast<float>(m_rcRegion.bottom) - 1, UI_DEFAULT_Z, UI_DEFAULT_RHW, BorderColorIn);

		// set texture stage state
		s_lpD3DDev->SetTexture(0, nullptr);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);

		// draw
		s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
		s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, pVB, sizeof(__VertexTransformedColor));	// 배경색 칠하기

		__VertexTransformedColor* pTemp = pVB;
		for (int i = 0; i < 4; ++i, ++pTemp)
			pTemp->color = BorderColorOut;	// 바깥 테두리 색을 바꾼다.

		s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_LINELIST, 0, 8, 8, pIB, D3DFMT_INDEX16, pVB, sizeof(__VertexTransformedColor));	// 테두리 칠하기

		// 글씨 그리기
		m_pBuffOutRef->Render();
	}
}

void CN3UITooltip::SetText(const std::string& szText, D3DCOLOR crTooltip)
{
	if (!m_bVisible)
		return;

	static std::string szPrevText;

	if (lstrcmpA(szPrevText.c_str(), szText.c_str()) != 0)
	{
		m_bSetText = false;
		m_fHoverTime = 0.0f;
	}

	if (m_bSetText)
		return;

	int iStrLen = static_cast<int>(szText.size());
	if (iStrLen == 0
		|| m_pBuffOutRef == nullptr)
		return;

	m_pBuffOutRef->ClearOnlyStringBuffer();

	SIZE size = {};
	if (m_pBuffOutRef->GetTextExtent(szText, iStrLen, &size))
	{
		int iRealWidth = m_pBuffOutRef->GetStringRealWidth(szText);
		if (size.cx < iRealWidth)
			size.cx = iRealWidth;

		bool offsetString = false;

		DWORD dwNewStyle;
		if (szText.find('\n') != std::string::npos)
		{
			dwNewStyle = UISTYLE_STRING_ALIGNLEFT | UISTYLE_STRING_ALIGNTOP;
		}
		else if (iStrLen < 25)
		{
			dwNewStyle = UISTYLE_STRING_SINGLELINE | UISTYLE_STRING_ALIGNCENTER | UISTYLE_STRING_ALIGNVCENTER;
		}
		// single line이므로 적당한 크기를 계산한다.
		else
		{
			SIZE CharSize = { 0, 0 };
			if (!m_pBuffOutRef->GetTextExtent("가", 2, &CharSize))
				return;

			constexpr int MAX_WIDTH = 500;
			int iLineCount = (size.cx / MAX_WIDTH) + 1;
			if (iLineCount > 1)
			{
				dwNewStyle = UISTYLE_STRING_ALIGNLEFT | UISTYLE_STRING_ALIGNTOP;
				size.cx = MAX_WIDTH;
				size.cy *= iLineCount;
				offsetString = true;
			}
			else
			{
				dwNewStyle = UISTYLE_STRING_SINGLELINE | UISTYLE_STRING_ALIGNCENTER | UISTYLE_STRING_ALIGNVCENTER;
			}
		}

		m_pBuffOutRef->SetStyle(dwNewStyle);

		constexpr int Padding = 12;
		size.cx += Padding;
		size.cy += Padding;
		SetSize(size.cx, size.cy);

		if (offsetString)
		{
			m_pBuffOutRef->SetPos(
				m_rcRegion.left + Padding / 2,
				m_rcRegion.top + (Padding / 2));
		}
	}

	m_pBuffOutRef->SetString(szText);
	m_pBuffOutRef->SetColor(crTooltip);

	// 위치 조정
	POINT ptNew = m_ptCursor;
	ptNew.x -= (m_rcRegion.right - m_rcRegion.left) / 2;
	ptNew.y -= (m_rcRegion.bottom - m_rcRegion.top) + 10;

	const D3DVIEWPORT9& vp = s_CameraData.vp;
	int iRegionWidth = m_rcRegion.right - m_rcRegion.left;
	int iRegionHeight = m_rcRegion.bottom - m_rcRegion.top;

	if (ptNew.x + iRegionWidth > static_cast<int>(vp.X + vp.Width))
		ptNew.x = static_cast<int>(vp.X + vp.Width) - iRegionWidth;

	if (ptNew.x < static_cast<int>(vp.X))
		ptNew.x = static_cast<int>(vp.X);

	if (ptNew.y + iRegionHeight > static_cast<int>(vp.Y + vp.Height))
		ptNew.y = static_cast<int>(vp.Y + vp.Height) - iRegionHeight;

	if (ptNew.y < static_cast<int>(vp.Y))
		ptNew.y = static_cast<int>(vp.Y);

	SetPos(ptNew.x, ptNew.y);

	m_bSetText = true;
}

void CN3UITooltip::Tick()
{
	int iOldTime = static_cast<int>(m_fHoverTime);
	m_fHoverTime += s_fSecPerFrm;

	constexpr float fDisplayTime = 0.3f;
	if (iOldTime < fDisplayTime && m_fHoverTime >= iOldTime)
		SetVisible(true);	// tool tip 표시
}

uint32_t CN3UITooltip::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!IsVisible())
		return dwRet;

	// 마우스를 움직이면 m_fHoverTime를 0으로 만들기
	if (ptCur.x != ptOld.x || ptCur.y != ptOld.y)
	{
		m_fHoverTime = 0.0f;
		m_bSetText = false;

		SetVisible(false); // tool tip을 없앤다.
	}
	// 안움직이면 커서 위치 저장
	else
	{
		m_ptCursor = ptCur;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

// ===== END N3Base/N3UITooltip.cpp =====

// ===== BEGIN N3Base/N3UITooltip.h =====
#line 1 "N3Base/N3UITooltip.h"
﻿// N3UITooltip.h: interface for the CN3UITooltip class.
// CN3UIBase에 EnableTooltip() 과 DestroyTooltip()함수가 아래 항목들을 관리해줍니다.
// 1. tooltip은 부모를 null로 해주고 따로 관리 해야 합니다.
// 2. Save/Load도 따로 관리합니다.
//
// 아래 항목들은 위의 항목 외에도 처리해주어야 할 것들입니다.
// 1. Render는 모든 UI를 다 그린후 Render해야 합니다.
// 2. MouseProc함수를 호출해줘야 합니다.
// 3. Tick함수도 호출해줘야 합니다.
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UITOOLTIP_H__7085B857_C8EE_410D_AB27_5332D26DF01A__INCLUDED_)
#define AFX_N3UITOOLTIP_H__7085B857_C8EE_410D_AB27_5332D26DF01A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIStatic.h"

class CN3UITooltip : public CN3UIStatic
{
public:
	CN3UITooltip();
	~CN3UITooltip() override;
	void Release() override;
	void Render() override;
	void SetText(const std::string& szText, D3DCOLOR crTooltip);
	void Tick() override;
	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;

protected:
	float	m_fHoverTime;	// 마우스가 한곳에서 정지하여 있는 시간(누적)
	bool	m_bSetText;		// 이미 text가 설정되었는가?
	POINT	m_ptCursor;		// 커서의 위치
};

#endif // !defined(AFX_N3UITOOLTIP_H__7085B857_C8EE_410D_AB27_5332D26DF01A__INCLUDED_)

// ===== END N3Base/N3UITooltip.h =====

// ===== BEGIN N3Base/N3UITrackBar.cpp =====
#line 1 "N3Base/N3UITrackBar.cpp"
﻿// N3UITrackBar.cpp: implementation of the CN3UITrackBar class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfxBase.h"
#include "N3UITrackBar.h"
#include "N3UIImage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UITrackBar::CN3UITrackBar()
{
	m_eType = UI_TYPE_TRACKBAR;

	m_pBkGndImageRef = nullptr;
	m_pThumbImageRef = nullptr;
	m_iMaxPos = 10;
	m_iMinPos = 0;
	m_iCurPos = 0;
	m_iPageSize = 2;
}

CN3UITrackBar::~CN3UITrackBar()
{
}

void CN3UITrackBar::Release()
{
	CN3UIBase::Release();
	m_pBkGndImageRef = nullptr;
	m_pThumbImageRef = nullptr;
	m_iMaxPos = 10;
	m_iMinPos = 0;
	m_iCurPos = 0;
	m_iPageSize = 2;
}

bool CN3UITrackBar::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;

	// ImageRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE != pChild->UIType()) continue;	// image만 골라내기
		int iImageType = (int)(pChild->GetReserved());
		if (IMAGETYPE_BKGND == iImageType)
		{
			m_pBkGndImageRef = (CN3UIImage*)pChild;
		}
		else if (IMAGETYPE_THUMB == iImageType)
		{
			m_pThumbImageRef = (CN3UIImage*)pChild;
		}
	}
	return true;
}

void CN3UITrackBar::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	if(m_pBkGndImageRef) m_pBkGndImageRef->SetRegion(m_rcRegion);	// 배경이미지는 같은 영역으로
	RECT rcThumb = m_pThumbImageRef->GetRegion();

	int iThumbWidth = rcThumb.right - rcThumb.left;		int iThumbHeight = rcThumb.bottom - rcThumb.top;
	int iBkWidth = Rect.right - Rect.left;			int iBkHeight = Rect.bottom - Rect.top;
	if (iBkWidth<=0 || iBkHeight<=0) return;
	
	if ( iThumbWidth<=0 && iThumbHeight<=0 )
	{	// thumb 이미지는 설정되어 있지 않다면 임으로 적당하게 설정
		RECT rc;
		if (UISTYLE_TRACKBAR_VERTICAL == m_dwStyle)
		{	// 세로
			rc.left = Rect.left;		rc.top = Rect.top + (int)(iBkHeight*0.3f);
			rc.right = Rect.right;	rc.bottom = rc.top + (int)(iBkHeight*0.3f);
		}
		else
		{	// 가로
			rc.left = Rect.left + (int)(iBkWidth*0.3f);		rc.top = Rect.top;
			rc.right = rc.left + (int)(iBkWidth*0.3f);			rc.bottom = Rect.bottom;
		}
		m_pThumbImageRef->SetRegion(rc);
	}
	UpdateThumbPos();	
}

uint32_t CN3UITrackBar::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;
	if (false == IsIn(ptCur.x, ptCur.y))	// 영역 밖이면
	{
		SetState(UI_STATE_COMMON_NONE);
		return dwRet;
	}
	dwRet |= UI_MOUSEPROC_INREGION;	// 이번좌표가 영역 안이다.

	if (UI_STATE_TRACKBAR_THUMBDRAG == m_eState)
	{
		if(dwFlags & UI_MOUSE_LBCLICKED)  // 왼쪽버튼 떼는 순간
		{
			SetState(UI_STATE_COMMON_NONE);		// drag 해제
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
		else if (dwFlags & UI_MOUSE_LBDOWN)
		{
			// thumb을 움직인다.
			if (UISTYLE_TRACKBAR_VERTICAL == m_dwStyle)	UpDownThumbPos(ptCur.y - ptOld.y);
			else UpDownThumbPos(ptCur.x - ptOld.x);
			// 부모에게 메세지를 보내자
			if (m_pParent) m_pParent->ReceiveMessage(this, UIMSG_TRACKBAR_POS);
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
	}
	else
	{
		if(dwFlags & UI_MOUSE_LBCLICK)  // 왼쪽버튼 눌르는 순간
		{
			if (m_pThumbImageRef->IsIn(ptCur.x, ptCur.y))	// thumb을 눌렀다.
			{
				SetState(UI_STATE_TRACKBAR_THUMBDRAG);
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
			else	// thumb위부분 또는 아래 부분(좌 또는 우 여백)을 눌렀따.
			{
				RECT rcThumb = m_pThumbImageRef->GetRegion();
				if (UISTYLE_TRACKBAR_VERTICAL == m_dwStyle)
				{
					if (ptCur.y <= rcThumb.top) SetCurrentPos(m_iCurPos-m_iPageSize);// 윗부분 클릭
					else SetCurrentPos(m_iCurPos+m_iPageSize);// 아래 부분 클릭
				}
				else
				{
					if (ptCur.x <= rcThumb.left) SetCurrentPos(m_iCurPos-m_iPageSize);// 왼쪽 부분 클릭
					else SetCurrentPos(m_iCurPos+m_iPageSize);// 오른쪽 부분 클릭
				}
				if (m_pParent) m_pParent->ReceiveMessage(this, UIMSG_TRACKBAR_POS);
				dwRet |= UI_MOUSEPROC_DONESOMETHING;
				return dwRet;
			}
		}
	}
	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

//void CN3UITrackBar::Render()
//{
//	if(!m_bVisible) return;
//	if (m_pBkGndImageRef) m_pBkGndImageRef->Render();
//	if (m_pThumbImageRef) m_pThumbImageRef->Render();
//}

void CN3UITrackBar::SetRange(int iMin, int iMax)
{
	if (m_iMaxPos == iMax && m_iMinPos == iMin) return;
	m_iMaxPos = iMax;		m_iMinPos = iMin;
	if (m_iCurPos>m_iMaxPos)	m_iCurPos = m_iMaxPos;
	if (m_iCurPos<m_iMinPos)	m_iCurPos = m_iMinPos;
	UpdateThumbPos();
}

void CN3UITrackBar::SetCurrentPos(int iPos)
{
	if (iPos == m_iCurPos) return;
	m_iCurPos = iPos;
	if (m_iCurPos>m_iMaxPos)	m_iCurPos = m_iMaxPos;
	if (m_iCurPos<m_iMinPos)	m_iCurPos = m_iMinPos;
	UpdateThumbPos();
}

// Pos수치로 Thumb의 위치를 조정
void CN3UITrackBar::UpdateThumbPos()
{
	if (nullptr == m_pThumbImageRef) return;
	float fDiff = (float)m_iMaxPos - (float)m_iMinPos;
	if (0.0f == fDiff) return;
	float fPercentage = (float)m_iCurPos/fDiff;
	RECT rcThumb = m_pThumbImageRef->GetRegion();

	if (UISTYLE_TRACKBAR_VERTICAL == m_dwStyle)
	{
		int iDY = (int)(fPercentage*((m_rcRegion.bottom - m_rcRegion.top) - (rcThumb.bottom - rcThumb.top)));
		m_pThumbImageRef->SetPos(	m_rcRegion.left, m_rcRegion.top + iDY);
	}
	else
	{
		int iDX = (int)(fPercentage*((m_rcRegion.right - m_rcRegion.left) - (rcThumb.right - rcThumb.left)));
		m_pThumbImageRef->SetPos( m_rcRegion.left + iDX, m_rcRegion.top );
	}
}

// thumb을 pixel단위로 위치 조정하고 thumb의 위치를 바탕으로 pos 수치를 계산하여 넣음
void CN3UITrackBar::UpDownThumbPos(int iDiff)
{
	if (nullptr == m_pThumbImageRef) return;
	RECT rcThumb = m_pThumbImageRef->GetRegion();

	if (UISTYLE_TRACKBAR_VERTICAL == m_dwStyle)		// 아래 움직일 대
	{
		int iRegionHeight = m_rcRegion.bottom - m_rcRegion.top;
		int iThumbHeight = rcThumb.bottom - rcThumb.top;
		if (0==iRegionHeight || 0==iThumbHeight) return;

		// 옮긴후 thumb의 위치 percentage 구하기
		float fPercentage = ((rcThumb.top-m_rcRegion.top)+iDiff) / (((float)(iRegionHeight)) - iThumbHeight);

		if (fPercentage>1.0f)	// 너무 아래로 내렸다.
		{
			m_pThumbImageRef->SetPos(rcThumb.left, rcThumb.bottom-iThumbHeight);
			m_iCurPos = m_iMaxPos;		// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
		else if (fPercentage<0.0f)	// 너무 위로 올렸다.
		{
			m_pThumbImageRef->SetPos(rcThumb.left, rcThumb.top);
			m_iCurPos = m_iMinPos;// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
		else
		{
			m_pThumbImageRef->SetPos(rcThumb.left, rcThumb.top+iDiff);
			m_iCurPos = static_cast<int>(m_iMinPos + (m_iMaxPos - m_iMinPos) * fPercentage);// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
	}
	else											// 좌우로 움직일 때
	{
		int iRegionWidth = m_rcRegion.right - m_rcRegion.left;
		int iThumbWidth = rcThumb.right - rcThumb.left;
		if (0==iRegionWidth || 0==iThumbWidth) return;

		// 옮긴후 thumb의 위치 percentage 구하기
		float fPercentage = ((rcThumb.left-m_rcRegion.left)+iDiff) / (((float)(iRegionWidth)) - iThumbWidth);

		if (fPercentage>1.0f)	// 너무 오른쪽으로 밀었다.
		{
			m_pThumbImageRef->SetPos(rcThumb.right-iThumbWidth, rcThumb.top);
			m_iCurPos = m_iMaxPos;// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
		else if (fPercentage<0.0f)	// 너무 왼쪽으로 밀었다
		{
			m_pThumbImageRef->SetPos(rcThumb.left, rcThumb.top);
			m_iCurPos = m_iMinPos;// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
		else
		{
			m_pThumbImageRef->SetPos(rcThumb.left+iDiff, rcThumb.top);
			m_iCurPos = static_cast<int>(m_iMinPos + (m_iMaxPos - m_iMinPos) * fPercentage);// SetCurrentPos함수를 호출하면 thumb위치를 다시 계산하기 때문에 직접 바꾸어줌.
		}
	}
}

#ifdef _N3TOOL
void CN3UITrackBar::operator = (const CN3UITrackBar& other)
{
	CN3UIBase::operator = (other);

	m_iMaxPos = other.m_iMaxPos;									// 최대
	m_iMinPos = other.m_iMinPos;									// 최소
	m_iCurPos = other.m_iCurPos;									// 현재 값
	m_iPageSize = other.m_iPageSize;								// page단위 이동할때 이동값

	// ImageRef 설정하기
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (UI_TYPE_IMAGE != pChild->UIType()) continue;	// image만 골라내기
		int iImageType = (int)(pChild->GetReserved());
		if (IMAGETYPE_BKGND == iImageType)
		{
			m_pBkGndImageRef = (CN3UIImage*)pChild;
		}
		else if (IMAGETYPE_THUMB == iImageType)
		{
			m_pThumbImageRef = (CN3UIImage*)pChild;
		}
	}
}

void CN3UITrackBar::CreateImages()
{
	__ASSERT(nullptr == m_pBkGndImageRef && nullptr == m_pThumbImageRef, "이미지가 이미 할당되어 있어여");
	m_pBkGndImageRef = new CN3UIImage();
	m_pBkGndImageRef->Init(this);
	m_pBkGndImageRef->SetReserved(IMAGETYPE_BKGND);

	m_pThumbImageRef = new CN3UIImage();
	m_pThumbImageRef->Init(this);
	m_pThumbImageRef->SetReserved(IMAGETYPE_THUMB);

	SetRegion(m_rcRegion);	// 영역 다시 설정
}

void CN3UITrackBar::DeleteBkImage()
{
	delete m_pBkGndImageRef;
	m_pBkGndImageRef = nullptr;
}

#endif

// ===== END N3Base/N3UITrackBar.cpp =====

// ===== BEGIN N3Base/N3UITrackBar.h =====
#line 1 "N3Base/N3UITrackBar.h"
﻿// N3UITrackBar.h: interface for the CN3UITrackBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UITRACKBAR_H__EB496B74_468B_4D7B_89A9_D3A5A1A3E538__INCLUDED_)
#define AFX_N3UITRACKBAR_H__EB496B74_468B_4D7B_89A9_D3A5A1A3E538__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIBase.h"

class CN3UITrackBar : public CN3UIBase
{
public:
	CN3UITrackBar();
	~CN3UITrackBar() override;

// Attributes
public:
	enum eIMAGE_TYPE
	{
		IMAGETYPE_BKGND = 0, IMAGETYPE_THUMB, NUM_IMAGETYPE
	};
protected:
	CN3UIImage*		m_pBkGndImageRef;		// 배경 이미지 reference (메모리 할당은 children list로 관리)
	CN3UIImage*		m_pThumbImageRef;		// 가운데 드레그 하여 옮길 수 있는 이미지 reference

	int				m_iMaxPos;									// 최대
	int				m_iMinPos;									// 최소
	int 			m_iCurPos;									// 현재 값
	int				m_iPageSize;								// page단위 이동할때 이동값
// Operations
public:
	void		Release() override;
	bool		Load(File& file) override;
	void		SetRegion(const RECT& Rect) override;
	uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;

	void		SetRange(int iMin, int iMax);
	void		SetCurrentPos(int iPos);

	void SetRangeMax(int iMax)
	{
		SetRange(m_iMinPos, iMax);
	}

	void SetRangeMin(int iMin)
	{
		SetRange(iMin, m_iMaxPos);
	}

	int GetPos() const
	{
		return m_iCurPos;
	}

	void SetPageSize(int iSize)
	{
		m_iPageSize = iSize;
	}

	int GetPageSize() const
	{
		return m_iPageSize;
	}

	int GetMaxPos() const
	{
		return m_iMaxPos;
	}

	int GetMinPos() const
	{
		return m_iMinPos;
	}

protected:
	void			UpdateThumbPos();							// m_iCurPos를 계산하여 Thumb위치 다시 계산하여 바꾸기
	void			UpDownThumbPos(int iDiff);					// Thumb위치를 아래 위로 iDiff pixel만큼 움직인 후 m_iCurPos 갱신하기

#ifdef _N3TOOL
// tool에서 쓰이는 함수
public:
	virtual void	operator = (const CN3UITrackBar& other);
	void			CreateImages();			// 이미지 생성
	void			DeleteBkImage();		// 배경이미지 삭제

	CN3UIImage* GetBkGndImgRef() const
	{
		return m_pBkGndImageRef;
	}

	CN3UIImage* GetThumbImgRef() const
	{
		return m_pThumbImageRef;
	}
#endif
};

#endif // !defined(AFX_N3UITRACKBAR_H__EB496B74_468B_4D7B_89A9_D3A5A1A3E538__INCLUDED_)

// ===== END N3Base/N3UITrackBar.h =====

// ===== BEGIN N3Base/N3VMesh.cpp =====
#line 1 "N3Base/N3VMesh.cpp"
﻿// N3VMesh.cpp: implementation of the C3DObject class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "N3VMesh.h"
#include "N3IMesh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3VMesh::CN3VMesh()
{
	m_dwType |= OBJ_MESH_VECTOR3;
	
	m_pVertices = nullptr; // 점 버퍼
	m_pwIndices = nullptr; // Index...

	m_nVC = 0;
	m_nIC = 0;

	m_vMin.Zero();
	m_vMax.Zero();
	m_fRadius = 0.0f; // 반지름
}

CN3VMesh::~CN3VMesh()
{
	if(m_nVC > 32768) ::GlobalFree((HGLOBAL)(m_pVertices));
	else delete [] m_pVertices;
	delete [] m_pwIndices; m_pwIndices = nullptr;
}

void CN3VMesh::Release()
{
	if(m_nVC > 32768) ::GlobalFree((HGLOBAL)(m_pVertices));
	else delete [] m_pVertices;
	m_pVertices = nullptr;
	m_nVC = 0;

	delete [] m_pwIndices; m_pwIndices = nullptr;
	m_nIC = 0;

	m_vMin.Zero();
	m_vMax.Zero();
	m_fRadius = 0.0f; // 반지름
}

bool CN3VMesh::Load(File& file)
{
	CN3BaseFileAccess::Load(file);

	int nVC;
	file.Read(&nVC, 4); // 점갯수 읽기..
	if (nVC > 0)
	{
		CreateVertices(nVC); // Vertex Buffer 생성 및 데이터 채우기
		file.Read(m_pVertices, nVC * sizeof(__Vector3));
	}

	int nIC;
	file.Read(&nIC, 4); // Index Count..
	if (nIC > 0)
	{
		CreateIndex(nIC); // Vertex Buffer 생성 및 데이터 채우기
		file.Read(m_pwIndices, nIC * 2);
	}

	FindMinMax(); // 최대 최소점과 중심점과 반지름을 계산해 준다..

	return true;
}

#ifdef _N3TOOL
bool CN3VMesh::Save(File& file)
{
	CN3BaseFileAccess::Save(file);

	file.Write(&m_nVC, 4); // 점갯수 읽기..
	if(m_nVC > 0) 
	{
		file.Write(m_pVertices, m_nVC * sizeof(__Vector3));
	}

	file.Write(&m_nIC, 4); // Index Count..
	if(m_nIC > 0)
	{
		file.Write(m_pwIndices, m_nIC * 2); // Index Buffer 데이터 쓰기..
	}

	return true;
}
#endif // end of _N3TOOL

void CN3VMesh::CreateVertices(int nVC)
{
	if(nVC <= 0) return;

	if(m_nVC > 32768) ::GlobalFree((HGLOBAL)(m_pVertices));
	else delete [] m_pVertices;

	m_pVertices = nullptr;

	if(nVC > 32768)
	{
		m_pVertices = (__Vector3*)(::GlobalAlloc(GMEM_FIXED, nVC * sizeof(__Vector3)));
	}
	else
	{
		m_pVertices = new __Vector3[nVC];
	}

	memset(m_pVertices, 0, nVC * sizeof(__Vector3)); // Vertex Buffer 생성
	m_nVC = nVC;
}

void CN3VMesh::CreateIndex(int nIC)
{
	__ASSERT(nIC > 0, "Index count is less than 0");
	
#ifdef _N3GAME
	if (nIC > 32768)
		CLogWriter::Write("N3VMesh creation warning ({}) - Too many Indices.", m_szFileName);
#endif

	delete [] m_pwIndices;
	m_pwIndices = new uint16_t[nIC];
	memset(m_pwIndices, 0, nIC * 2); // Index Buffer 생성
	m_nIC = nIC;
}

void CN3VMesh::CreateCube(const __Vector3 &vMin, const __Vector3 &vMax)
{
	this->CreateVertices(8);
	this->CreateIndex(36);

	m_pVertices[0].Set(vMin.x, vMax.y, vMin.z); 
	m_pVertices[1].Set(vMax.x, vMax.y, vMin.z); 
	m_pVertices[2].Set(vMax.x, vMin.y, vMin.z); 
	m_pVertices[3].Set(vMin.x, vMin.y, vMin.z); 

	m_pVertices[4].Set(vMax.x, vMax.y, vMax.z); 
	m_pVertices[5].Set(vMin.x, vMax.y, vMax.z); 
	m_pVertices[6].Set(vMin.x, vMin.y, vMax.z); 
	m_pVertices[7].Set(vMax.x, vMin.y, vMax.z); 

	m_pwIndices[0] = 0; m_pwIndices[1] = 1; m_pwIndices[2] = 2; 
	m_pwIndices[3] = 0; m_pwIndices[4] = 2; m_pwIndices[5] = 3; 
	m_pwIndices[6] = 1; m_pwIndices[7] = 4; m_pwIndices[8] = 7;
	m_pwIndices[9] = 1; m_pwIndices[10] = 7; m_pwIndices[11] = 2;
	m_pwIndices[12] = 4; m_pwIndices[13] = 5; m_pwIndices[14] = 6;
	m_pwIndices[15] = 4; m_pwIndices[16] = 6; m_pwIndices[17] = 7;
	m_pwIndices[18] = 5; m_pwIndices[19] = 0; m_pwIndices[20] = 3;
	m_pwIndices[21] = 5; m_pwIndices[22] = 3; m_pwIndices[23] = 6;
	m_pwIndices[24] = 5; m_pwIndices[25] = 4; m_pwIndices[26] = 1;
	m_pwIndices[27] = 5; m_pwIndices[28] = 1; m_pwIndices[29] = 0;
	m_pwIndices[30] = 3; m_pwIndices[31] = 2; m_pwIndices[32] = 7;
	m_pwIndices[33] = 3; m_pwIndices[34] = 7; m_pwIndices[35] = 6;

	this->FindMinMax(); // 중심점과 반지름을 계산해 준다..
}


void CN3VMesh::Render(D3DCOLOR crLine)
{
	if(m_nVC <= 0) return;

	DWORD dwLight, dwShade;
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwShade);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
	if(D3DFILL_WIREFRAME != dwShade) s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	s_lpD3DDev->SetTexture(0, nullptr);
	s_lpD3DDev->SetFVF(FVF_CV);

	__VertexColor vTs[3];
	if(m_nIC)
	{
		int nFC = m_nIC / 3;
		for(int i = 0; i < nFC; i++)
		{
			vTs[0].Set(m_pVertices[m_pwIndices[i*3+0]], crLine);
			vTs[1].Set(m_pVertices[m_pwIndices[i*3+1]], crLine);
			vTs[2].Set(m_pVertices[m_pwIndices[i*3+2]], crLine);

			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, vTs, sizeof(__VertexColor));
		}
	}
	else
	{
		int nFC = m_nVC / 3;
		for(int i = 0; i < nFC; i++)
		{
			vTs[0].Set(m_pVertices[i*3+0], crLine);
			vTs[1].Set(m_pVertices[i*3+1], crLine);
			vTs[2].Set(m_pVertices[i*3+2], crLine);

			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, vTs, sizeof(__VertexColor));
		}
	}

	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
	if(D3DFILL_WIREFRAME != dwShade) s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwShade);
}

void CN3VMesh::FindMinMax()
{
	m_vMin.Zero();
	m_vMax.Zero();
	m_fRadius = 0;

	if(m_nVC <= 0) return;

	m_vMin.Set(FLT_MAX, FLT_MAX, FLT_MAX);
	m_vMax.Set(-FLT_MAX, -FLT_MAX, -FLT_MAX);
	for(int i = 0; i < m_nVC; i++)
	{
		if(m_pVertices[i].x < m_vMin.x) m_vMin.x = m_pVertices[i].x;
		if(m_pVertices[i].y < m_vMin.y) m_vMin.y = m_pVertices[i].y;
		if(m_pVertices[i].z < m_vMin.z) m_vMin.z = m_pVertices[i].z;
		if(m_pVertices[i].x > m_vMax.x) m_vMax.x = m_pVertices[i].x;
		if(m_pVertices[i].y > m_vMax.y) m_vMax.y = m_pVertices[i].y;
		if(m_pVertices[i].z > m_vMax.z) m_vMax.z = m_pVertices[i].z;
	}

	// 최대 최소값을 갖고 반지름 계산한다..
	m_fRadius  = (m_vMax - m_vMin).Magnitude() * 0.5f;
}

bool CN3VMesh::CheckCollision(const __Matrix44& MtxWorld, const __Vector3& v0, const __Vector3& v1, __Vector3* pVCol, __Vector3* pVNormal)
{
	if(m_nVC <= 0)
		return false;

	static __Vector3 vPos0, vPos1, vDir, vColTmp;
	static __Matrix44 mtxWI, mtxWIRot, mtxRot;
	static float fT, fU, fV, fDistTmp, fDistClosest;
	fDistClosest = FLT_MAX;

	mtxWI = MtxWorld.Inverse(); // World Matrix Inverse
	mtxWIRot = mtxWI;
	mtxWIRot.PosSet(0,0,0);
	mtxRot = MtxWorld;
	mtxRot.PosSet(0,0,0);

	vPos0 = v0 * mtxWI;
	vPos1 = v1 * mtxWI;
	vDir = vPos1 - vPos0;

	int nFC = 0;
	if(m_nIC > 0) nFC = m_nIC / 3;
	else nFC = m_nVC / 3;

	int nCI0, nCI1, nCI2; // Collision polygon index
	for(int i = 0; i < nFC; i++)
	{
		if(m_nIC > 0) { nCI0 = m_pwIndices[i*3+0]; nCI1 = m_pwIndices[i*3+1]; nCI2 = m_pwIndices[i*3+2]; }
		else { nCI0 = i*3; nCI1 = i*3+1; nCI2 = i*3+2; }

		if(false == ::_IntersectTriangle(vPos0, vDir, m_pVertices[nCI0], m_pVertices[nCI1], m_pVertices[nCI2], fT, fU, fV, &vColTmp)) continue; // 첫째 벡터가 걸치면..
		if(false == ::_IntersectTriangle(vPos1, vDir, m_pVertices[nCI0], m_pVertices[nCI1], m_pVertices[nCI2])) // 둘째는 안 걸치면..
		{
			fDistTmp = (vPos0 - vColTmp).Magnitude(); // 거리를 재보고..
			if(fDistTmp < fDistClosest) 
			{
				fDistClosest = fDistTmp;
				
				if(pVCol) *pVCol = vColTmp * MtxWorld;

				// 법선 벡터 구하기..
				if(pVNormal)
				{
					(*pVNormal).Cross(m_pVertices[nCI1] - m_pVertices[nCI0], m_pVertices[nCI2] - m_pVertices[nCI1]);
					(*pVNormal) *= mtxRot;
					(*pVNormal).Normalize();
				}
			}
		}
	}
	if(fDistClosest != FLT_MAX) return true;

	//두점이 충돌메시 안에 있는 경우..by lynus..
	__Vector3 tmpNormal;
	float d;
	for(int i = 0; i < nFC; i++)
	{
		if(m_nIC > 0) { nCI0 = m_pwIndices[i*3+0]; nCI1 = m_pwIndices[i*3+1]; nCI2 = m_pwIndices[i*3+2]; }
		else { nCI0 = i*3; nCI1 = i*3+1; nCI2 = i*3+2; }

		tmpNormal.Cross(m_pVertices[nCI1] - m_pVertices[nCI0], m_pVertices[nCI2] - m_pVertices[nCI1]);
		d = -(tmpNormal.x*m_pVertices[nCI0].x) - (tmpNormal.y*m_pVertices[nCI0].y) - (tmpNormal.z*m_pVertices[nCI0].z);
		if( ((tmpNormal.x*vPos0.x)+(tmpNormal.y*vPos0.y)+(tmpNormal.z*vPos0.z)+d) > 0) return false;
	}

	
	return true;
}

bool CN3VMesh::Pick(const __Matrix44& MtxWorld, const __Vector3& vPos, const __Vector3& vDir, __Vector3* pVCol, __Vector3* pVNormal)
{
	if(m_nVC <= 0) return false;

	__Matrix44 mtxWI, mtxWIRot, mtxRot;
	mtxWI = MtxWorld.Inverse(); // World Matrix Inverse
	mtxWIRot = mtxWI;
	mtxWIRot.PosSet(0,0,0);
	mtxRot = MtxWorld;
	mtxRot.PosSet(0,0,0);
	__Vector3 vPos2 = vPos * mtxWI;
	__Vector3 vDir2 = vDir * mtxWIRot;

	int nFC = 0;
	if(m_nIC > 0) nFC = m_nIC / 3;
	else nFC = m_nVC / 3;

	int nCI0, nCI1, nCI2; // Collision polygon index
	for(int i = 0; i < nFC; i++)
	{
		if(m_nIC > 0) { nCI0 = m_pwIndices[i*3+0]; nCI1 = m_pwIndices[i*3+1]; nCI2 = m_pwIndices[i*3+2]; }
		else { nCI0 = i*3; nCI1 = i*3+1; nCI2 = i*3+2; }

		if(false == ::_IntersectTriangle(vPos2, vDir2, m_pVertices[nCI0], m_pVertices[nCI1], m_pVertices[nCI2])) continue;

		// 충돌이다..
		if(pVCol)
		{
			float fT, fU, fV;
			::_IntersectTriangle(vPos2, vDir2, m_pVertices[nCI0], m_pVertices[nCI1], m_pVertices[nCI2], fT, fU, fV, pVCol);
			(*pVCol) *= MtxWorld;
		}

		// 법선 벡터 구하기..
		if(pVNormal)
		{
			(*pVNormal).Cross(m_pVertices[nCI1] - m_pVertices[nCI0], m_pVertices[nCI2] - m_pVertices[nCI1]);
			(*pVNormal) *= mtxRot;
			(*pVNormal).Normalize();
		}

		return true;
	}

	return false;
}

#ifdef _N3TOOL
bool CN3VMesh::Import(CN3IMesh *pIMesh)
{
	if(nullptr == pIMesh) return false;
	__VertexT1* pvSrc = pIMesh->BuildVertexList();
	if(nullptr == pvSrc) return false;

	int nFC = pIMesh->FaceCount();
	this->Release();
	this->CreateVertices(nFC * 3);

	for(int i = 0; i < nFC; i++) // Normal 값 다시 세팅..
	{
		m_pVertices[i*3+0] = pvSrc[i*3+0];
		m_pVertices[i*3+1] = pvSrc[i*3+1];
		m_pVertices[i*3+2] = pvSrc[i*3+2];
	}

	m_szName = pIMesh->m_szName; // 이름..
	return true;
}
#endif // end of _N3TOOL

int	CN3VMesh::GetColIndexByiOrder(int iOrder)
{
	if(m_nIC)
	{
		return m_pwIndices[iOrder];
	}
	else
	{
		return iOrder;
	}
}

__Vector3 CN3VMesh::GetColVertexByIndex(int iIndex)
{
	return m_pVertices[iIndex];
}

void CN3VMesh::PartialColRender(int iCount, int* piIndices)
{
	if(m_nVC <= 0) return;

	DWORD dwLight, dwShade;
	s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwShade);
	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);
	if(D3DFILL_WIREFRAME != dwShade) s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	s_lpD3DDev->SetTexture(0, nullptr);
	s_lpD3DDev->SetFVF(FVF_CV);

	__VertexColor vTs[3];
	if(iCount)
	{
		int nFC = iCount / 3;
		for(int i = 0; i < nFC; i++)
		{
			vTs[0].Set(m_pVertices[piIndices[i*3+0]], 0xffffffff);
			vTs[1].Set(m_pVertices[piIndices[i*3+1]], 0xffffffff);
			vTs[2].Set(m_pVertices[piIndices[i*3+2]], 0xffffffff);

			s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 1, vTs, sizeof(__VertexColor));
		}
	}

	if(dwLight) s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
	if(D3DFILL_WIREFRAME != dwShade) s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwShade);
}

void CN3VMesh::PartialGetCollision(int iIndex, __Vector3& vec)
{
	if(m_nVC <= 0) return;

	vec = m_pVertices[iIndex];
}

// ===== END N3Base/N3VMesh.cpp =====

// ===== BEGIN N3Base/N3VMesh.h =====
#line 1 "N3Base/N3VMesh.h"
﻿// N3VMesh.h: interface for the C3DObject class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3VMesh_h__INCLUDED_)
#define AFX_N3VMesh_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3BaseFileAccess.h"

class CN3IMesh;

class CN3VMesh : public CN3BaseFileAccess
{
protected:
	__Vector3*	m_pVertices; // 점 버퍼
	int			m_nVC; // 점 갯수

	uint16_t*		m_pwIndices; // Index...
	int			m_nIC; // Index Count

	__Vector3	m_vMin;
	__Vector3	m_vMax;
	float		m_fRadius; // 반지름

public:
	__Vector3	Min() { return m_vMin; }
	__Vector3	Max() { return m_vMax; }
	bool		Pick(const __Matrix44& MtxWorld, const __Vector3& vPos, const __Vector3& vDir, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr);
	bool		CheckCollision(const __Matrix44& MtxWorld, const __Vector3& v0, const __Vector3& v1, __Vector3* pVCol = nullptr, __Vector3* pVNormal = nullptr); // Local 좌표를 통한 충돌 체크 판정..
	float		Radius() { return m_fRadius; }
	void		FindMinMax();
	void		Render(D3DCOLOR crLine);
	void		CreateVertices(int nVC);
	void		CreateIndex(int nIC);
	void		CreateCube(const __Vector3& vMin, const __Vector3& vMax);
	
	int			VertexCount() { return m_nVC; }
	__Vector3*	Vertices() { return m_pVertices; }

	int			IndexCount() { return m_nIC; }
	uint16_t*	Indices() { return m_pwIndices; }

	bool		Load(File& file) override;
#ifdef _N3TOOL
	bool		Import(CN3IMesh *pIMesh);
	bool		Save(File& file) override;
#endif // end of _N3TOOL
	
	void		Release() override;

	CN3VMesh();
	~CN3VMesh() override;

//	By : Ecli666 ( On 2002-08-09 오후 2:47:59 )
//
	int				GetColIndexByiOrder(int iOrder);
__Vector3	  GetColVertexByIndex(int iIndex); 
	void			PartialColRender(int iCount, int* piIndices);
	void			PartialGetCollision(int iIndex, __Vector3& vec);
//	~(By Ecli666 On 2002-08-09 오후 2:47:59 )
};

#endif // !defined(AFX_N3VMesh_h__INCLUDED_)

// ===== END N3Base/N3VMesh.h =====

// ===== BEGIN N3Base/Pick.cpp =====
#line 1 "N3Base/Pick.cpp"
﻿// Pick.cpp: implementation of the CPick class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfxBase.h"
#include "Pick.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPick::CPick()
{
}

CPick::~CPick()
{
}

void CPick::SetPickXY(long x, long y)
{
	LPDIRECT3DDEVICE9 lpD3DDev = CN3Base::s_lpD3DDev;

    // Get the pick ray from the mouse position
    __Matrix44 matProj;
	lpD3DDev->GetTransform(D3DTS_PROJECTION, matProj.toD3D());

    // Compute the vector of the pick ray in screen space
    __Vector3 v;
    v.x =  ( ( ( 2.0f * x ) / (CN3Base::s_CameraData.vp.Width) ) - 1 ) / matProj.m[0][0];
    v.y = -( ( ( 2.0f * y ) / (CN3Base::s_CameraData.vp.Height) ) - 1 ) / matProj.m[1][1];
    v.z =  1.0f;

    // Get the inverse view matrix
    __Matrix44 matView, m;
	lpD3DDev->GetTransform(D3DTS_VIEW, matView.toD3D());
	m = matView.Inverse();

    // Transform the screen space pick ray into 3D space
    m_vPickRayDir.x  = v.x*m.m[0][0] + v.y*m.m[1][0] + v.z*m.m[2][0];
    m_vPickRayDir.y  = v.x*m.m[0][1] + v.y*m.m[1][1] + v.z*m.m[2][1];
    m_vPickRayDir.z  = v.x*m.m[0][2] + v.y*m.m[1][2] + v.z*m.m[2][2];
    m_vPickRayOrig.x = m.m[3][0];
    m_vPickRayOrig.y = m.m[3][1];
    m_vPickRayOrig.z = m.m[3][2];
}

BOOL CPick::PickByBox(__Vector3 &vMin, __Vector3 &vMax, __Vector3& vIntersect)
{
	m_MeshBox.Create_Cube(vMin, vMax);

	__VertexT1* pVs = m_MeshBox.Vertices();
	if(pVs == nullptr) return FALSE;

	float fT, fU, fV;
	__Vector3 vTri[3];
	for(int j = 0; j < 12; j++)
	{
		vTri[0].Set(pVs[j*3+0].x, pVs[j*3+0].y, pVs[j*3+0].z);
		vTri[1].Set(pVs[j*3+1].x, pVs[j*3+1].y, pVs[j*3+1].z);
		vTri[2].Set(pVs[j*3+2].x, pVs[j*3+2].y, pVs[j*3+2].z);

		if(this->IntersectTriangle(vTri[0], vTri[1], vTri[2], fT, fU, fV, &vIntersect) == TRUE) return TRUE;
	}

	return FALSE;
}

// ===== END N3Base/Pick.cpp =====

// ===== BEGIN N3Base/Pick.h =====
#line 1 "N3Base/Pick.h"
﻿// Pick.h: interface for the CPick class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PICK_H__4FEE8165_3BBD_4CD4_9D42_6F13B8A30603__INCLUDED_)
#define AFX_PICK_H__4FEE8165_3BBD_4CD4_9D42_6F13B8A30603__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3Mesh.h"

class CPick
{
public:
	CPick();
	virtual ~CPick();

// Attributes
public:
	CN3Mesh m_MeshBox; // Picking Box

protected:
    __Vector3		m_vPickRayDir;			// 충돌 체크할 직선의 방향
    __Vector3		m_vPickRayOrig;			// 충돌 체크할 직선의 시작점

// Operations
public:
	BOOL PickByBox(__Vector3 &vMin, __Vector3 &vMax, __Vector3& vIntersect);
	void			SetPickXY(long x, long y); // 클라이언트 좌표를 넣어준다..

	// [in] v0, v1, v2 세점의 좌표
	// [out] t가 클수록 직선과 평면과 만나는 점이 멀다.	t*dir + orig 를 구하면 만나는 점을 구할 수 있다.
	// [out] uv 좌표  v0 (0,0), v1(1,0), v2(0,1) <괄호안은 (U, V)좌표> 이런식으로 어느 점에 가깝나 나타낸 것
	// v0 + (v1-v0)*u + (v2-v0)*v 를 구하면 만나는 점을 구할 수 있다.
	// [out] vPos 마우스로 찍은 곳의 3D 좌표
	// 리턴 값이 FALSE이면 세점이 이루는 삼각형 안에서 만나지 않는다는 뜻, t u v vPos 모두 무효한 값이므로 쓰면 안된다.
	bool IntersectTriangle(__Vector3& v0, __Vector3& v1, __Vector3& v2, float& t, float& u, float& v, __Vector3* pVPos)
	{
		return ::_IntersectTriangle( m_vPickRayOrig, m_vPickRayDir, v0, v1, v2, t, u, v, pVPos );
	}
};

#endif // !defined(AFX_PICK_H__4FEE8165_3BBD_4CD4_9D42_6F13B8A30603__INCLUDED_)

// ===== END N3Base/Pick.h =====

// ===== BEGIN N3Base/StdAfxBase.cpp =====
#line 1 "N3Base/StdAfxBase.cpp"
﻿#include "StdAfxBase.h"

// ===== END N3Base/StdAfxBase.cpp =====

// ===== BEGIN N3Base/StdAfxBase.h =====
#line 1 "N3Base/StdAfxBase.h"
﻿#pragma once

#include "My_3DStruct.h"
#include <filesystem>

#include <spdlog/fmt/bundled/format.h>

// ===== END N3Base/StdAfxBase.h =====

// ===== BEGIN N3Base/StreamSoundObj.h =====
#line 1 "N3Base/StreamSoundObj.h"
﻿//////////////////////////////////////////////////
//	Commented By : Lynus
//	Commented On 2001-04-12 오후 5:09:28
//
//	CStreamSoundObj class (SoundObj.h)
//
//	End Of Comment (By Lynus On 2001-04-12 오후 5:09:28 )
//////////////////////////////////////////////////

#ifndef __STREAMSOUNDOBJ_H_
#define __STREAMSOUNDOBJ_H_

#include "N3SndObj.h"

class CN3SndEng;

class CStreamSoundObj : public CN3SndObj
{
	private:
		int					m_PlayTime;		//wave파일의 전체 플레이 타임.
		int					m_FinalByte;
				
		DSBUFFERDESC		m_dsbd;
		uint32_t				m_BufferSize;
		uint32_t				m_BlockSize;	//buffer를 초단위로 나눈 것.
		
		int					m_CurrState;	//현재 어느 블럭에 있는지..
		int					m_PrevState;	//지금 바로 전에 어느 블럭에 있었는지..
		uint32_t				m_CurrPos;		//현재 버퍼에서의 위치 
		int					m_PastTime;		//전체 플레이 타임에서 남은 시간

		//related wave data
		WAVEFORMATEX		m_WaveFormat;
		uint32_t				m_WaveSize;
		LPSTR				m_pWaveMem;
		HGLOBAL				m_hWaveMem;
		MMCKINFO			mmCkInfoRIFF;
		MMCKINFO			mmCkInfoChunk;
		HMMIO				hMMIO;
		
	public:
		BOOL Create(CN3SndEng* pEng);

//		void Play(float delay = 0.0f, float fFadeInTime = 0.0f);
//		void Stop(float fFadeOutTime = 0.0f);		
		
		void Tick();		
		void Release();
		
		CStreamSoundObj();
		virtual ~CStreamSoundObj();
				
	private:
		void RealPlay();
		
		//void Stop();

		BOOL LoadWave(LPCSTR pFileName);
		BOOL WriteBuffer();
		BOOL InitWriteBuffer();
		void Reset();
};

#endif // #ifndef __STREAMSOUNDOBJ_H_
// ===== END N3Base/StreamSoundObj.h =====

// ===== BEGIN N3Base/WaveFile.cpp =====
#line 1 "N3Base/WaveFile.cpp"
﻿//////////////////////////////////////////////////
//	Commented By : Lynus
//	Commented On 2001-04-12 오후 1:52:29
//
//	CWave class(wave.cpp)
//
//	End Of Comment (By Lynus On 2001-04-12 오후 1:52:29 )
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//	Coded By : Lynus
//	Coded On 2001-04-12 오후 1:52:49
//

#include "StdAfxBase.h"
#include "WaveFile.h"

//-----------------------------------------------------------------------------
// Name: CWaveFile::CWaveFile()
// Desc: Constructs the class.  Call Open() to open a wave file for reading.  
//       Then call Read() as needed.  Calling the destructor or Close() 
//       will close the file.  
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_pwfx    = nullptr;
    m_hmmio   = nullptr;
    m_dwSize  = 0;
    m_bIsReadingFromMemory = FALSE;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::~CWaveFile()
// Desc: Destructs the class
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();

    if( !m_bIsReadingFromMemory )
	{
		if(m_pwfx)
		{
			delete[] m_pwfx;
			m_pwfx = nullptr;
		}
	}
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::Open()
// Desc: Opens a wave file for reading
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( LPCSTR strFileName, WAVEFORMATEX* pwfx, uint32_t dwFlags )
{
    HRESULT hr;

    m_dwFlags = dwFlags;
    m_bIsReadingFromMemory = FALSE;

    if( m_dwFlags == WAVEFILE_READ )
    {
        if( strFileName == nullptr )
            return E_INVALIDARG;
		if(m_pwfx)
		{
			delete[] m_pwfx;
			m_pwfx = nullptr;
		}

        m_hmmio = mmioOpen( (LPSTR)strFileName, nullptr, MMIO_ALLOCBUF | MMIO_READ );

        if( nullptr == m_hmmio )
        {
            HRSRC   hResInfo;
            HGLOBAL hResData;
            uint32_t   dwSize;
            VOID*   pvRes;

            // Loading it as a file failed, so try it as a resource
            if( nullptr == ( hResInfo = FindResource( nullptr, strFileName, TEXT("WAVE") ) ) )
            {
                if( nullptr == ( hResInfo = FindResource( nullptr, strFileName, TEXT("WAV") ) ) )
                    return E_FAIL;
            }

            if( nullptr == ( hResData = LoadResource( nullptr, hResInfo ) ) )
                return E_FAIL;

            if( 0 == ( dwSize = SizeofResource( nullptr, hResInfo ) ) ) 
                return E_FAIL;

            if( nullptr == ( pvRes = LockResource( hResData ) ) )
                return E_FAIL;

            CHAR* pData = new CHAR[ dwSize ];
            memcpy( pData, pvRes, dwSize );

            MMIOINFO mmioInfo;
            ZeroMemory( &mmioInfo, sizeof(mmioInfo) );
            mmioInfo.fccIOProc = FOURCC_MEM;
            mmioInfo.cchBuffer = dwSize;
            mmioInfo.pchBuffer = (CHAR*) pData;

            m_hmmio = mmioOpen( nullptr, &mmioInfo, MMIO_ALLOCBUF | MMIO_READ );
        }

        if( FAILED( hr = ReadMMIO() ) )
        {
            // ReadMMIO will fail if its an not a wave file
            mmioClose( m_hmmio, 0 );
            return hr;
        }

        if( FAILED( hr = ResetFile() ) )
            return hr;

        // After the reset, the size of the wav file is m_ck.cksize so store it now
        m_dwSize = m_ck.cksize;
    }
    else
    {
        m_hmmio = mmioOpen( (LPSTR)strFileName, nullptr, MMIO_ALLOCBUF  | 
                                                  MMIO_READWRITE | 
                                                  MMIO_CREATE );
        if( nullptr == m_hmmio )
            return E_FAIL;

        if( FAILED( hr = WriteMMIO( pwfx ) ) )
        {
            mmioClose( m_hmmio, 0 );
            return hr;
        }
                        
        if( FAILED( hr = ResetFile() ) )
            return hr;
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::OpenFromMemory()
// Desc: copy data to CWaveFile member variable from memory
//-----------------------------------------------------------------------------
HRESULT CWaveFile::OpenFromMemory( uint8_t* pbData, ULONG ulDataSize, 
                                   WAVEFORMATEX* pwfx, uint32_t dwFlags )
{
    m_pwfx       = pwfx;
    m_ulDataSize = ulDataSize;
    m_pbData     = pbData;
    m_pbDataCur  = m_pbData;
    m_bIsReadingFromMemory = TRUE;
    
    if( dwFlags != WAVEFILE_READ )
        return E_NOTIMPL;       
    
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::ReadMMIO()
// Desc: Support function for reading from a multimedia I/O stream.
//       m_hmmio must be valid before calling.  This function uses it to
//       update m_ckRiff, and m_pwfx. 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadMMIO()
{
    MMCKINFO        ckIn;           // chunk info. for general use.
    PCMWAVEFORMAT   pcmWaveFormat;  // Temp PCM structure to load in.       

    m_pwfx = nullptr;

    if( ( 0 != mmioDescend( m_hmmio, &m_ckRiff, nullptr, 0 ) ) )
        return E_FAIL;

    // Check to make sure this is a valid wave file
    if( (m_ckRiff.ckid != FOURCC_RIFF) ||
        (m_ckRiff.fccType != mmioFOURCC('W', 'A', 'V', 'E') ) )
        return E_FAIL; 

    // Search the input file for for the 'fmt ' chunk.
    ckIn.ckid = mmioFOURCC('f', 'm', 't', ' ');
    if( 0 != mmioDescend( m_hmmio, &ckIn, &m_ckRiff, MMIO_FINDCHUNK ) )
        return E_FAIL;

    // Expect the 'fmt' chunk to be at least as large as <PCMWAVEFORMAT>;
    // if there are extra parameters at the end, we'll ignore them
       if( ckIn.cksize < (LONG) sizeof(PCMWAVEFORMAT) )
           return E_FAIL;

    // Read the 'fmt ' chunk into <pcmWaveFormat>.
    if( mmioRead( m_hmmio, (HPSTR) &pcmWaveFormat, 
                  sizeof(pcmWaveFormat)) != sizeof(pcmWaveFormat) )
        return E_FAIL;

    // Allocate the waveformatex, but if its not pcm format, read the next
    // uint16_t, and thats how many extra bytes to allocate.
    if( pcmWaveFormat.wf.wFormatTag == WAVE_FORMAT_PCM )
    {
        m_pwfx = (WAVEFORMATEX*)new CHAR[ sizeof(WAVEFORMATEX) ];
        if( nullptr == m_pwfx )
            return E_FAIL;

        // Copy the bytes from the pcm structure to the waveformatex structure
        memcpy( m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat) );
        m_pwfx->cbSize = 0;
    }
    else
    {
        // Read in length of extra bytes.
        uint16_t cbExtraBytes = 0L;
        if( mmioRead( m_hmmio, (CHAR*)&cbExtraBytes, sizeof(uint16_t)) != sizeof(uint16_t) )
            return E_FAIL;

        m_pwfx = (WAVEFORMATEX*)new CHAR[ sizeof(WAVEFORMATEX) + cbExtraBytes ];
        if( nullptr == m_pwfx )
            return E_FAIL;

        // Copy the bytes from the pcm structure to the waveformatex structure
        memcpy( m_pwfx, &pcmWaveFormat, sizeof(pcmWaveFormat) );
        m_pwfx->cbSize = cbExtraBytes;

        // Now, read those extra bytes into the structure, if cbExtraAlloc != 0.
        if( mmioRead( m_hmmio, (CHAR*)(((uint8_t*)&(m_pwfx->cbSize))+sizeof(uint16_t)),
                      cbExtraBytes ) != cbExtraBytes )
        {
			if(m_pwfx)
			{
				delete m_pwfx;
				m_pwfx = nullptr;
			}
            return E_FAIL;
        }
    }

    // Ascend the input file out of the 'fmt ' chunk.
    if( 0 != mmioAscend( m_hmmio, &ckIn, 0 ) )
    {
		if(m_pwfx)
		{
			delete m_pwfx;
			m_pwfx = nullptr;
		}
        return E_FAIL;
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::GetSize()
// Desc: Retuns the size of the read access wave file 
//-----------------------------------------------------------------------------
uint32_t CWaveFile::GetSize()
{
    return m_dwSize;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::ResetFile()
// Desc: Resets the internal m_ck pointer so reading starts from the 
//       beginning of the file again 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ResetFile()
{
    if( m_bIsReadingFromMemory )
    {
        m_pbDataCur = m_pbData;
    }
    else 
    {
        if( m_hmmio == nullptr )
            return CO_E_NOTINITIALIZED;

        if( m_dwFlags == WAVEFILE_READ )
        {
            // Seek to the data
			if (-1 == mmioSeek(m_hmmio, m_ckRiff.dwDataOffset + sizeof(FOURCC),
				SEEK_SET))
				return S_FALSE;//DXTRACE_ERR( TEXT("mmioSeek"), E_FAIL );

            // Search the input file for the 'data' chunk.
            m_ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
			if (0 != mmioDescend(m_hmmio, &m_ck, &m_ckRiff, MMIO_FINDCHUNK))
				return S_FALSE;//DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );
        }
        else
        {
            // Create the 'data' chunk that holds the waveform samples.  
            m_ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
            m_ck.cksize = 0;

			if (0 != mmioCreateChunk(m_hmmio, &m_ck, 0))
				return S_FALSE;//DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );

			if (0 != mmioGetInfo(m_hmmio, &m_mmioinfoOut, 0))
				return S_FALSE;//DXTRACE_ERR( TEXT("mmioGetInfo"), E_FAIL );
        }
    }
    
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::Read()
// Desc: Reads section of data from a wave file into pBuffer and returns 
//       how much read in pdwSizeRead, reading not more than dwSizeToRead.
//       This uses m_ck to determine where to start reading from.  So 
//       subsequent calls will be continue where the last left off unless 
//       Reset() is called.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Read( uint8_t* pBuffer, DWORD dwSizeToRead, DWORD* pdwSizeRead )
{
    if( m_bIsReadingFromMemory )
    {
        if( m_pbDataCur == nullptr )
            return CO_E_NOTINITIALIZED;
        if( pdwSizeRead != nullptr )
            *pdwSizeRead = 0;

        if( (uint8_t*)(m_pbDataCur + dwSizeToRead) > 
            (uint8_t*)(m_pbData + m_ulDataSize) )
        {
            dwSizeToRead = m_ulDataSize - (uint32_t)(m_pbDataCur - m_pbData);
        }
        
        CopyMemory( pBuffer, m_pbDataCur, dwSizeToRead );
        
        if( pdwSizeRead != nullptr )
            *pdwSizeRead = dwSizeToRead;

        return S_OK;
    }
    else 
    {
        MMIOINFO mmioinfoIn; // current status of m_hmmio

        if( m_hmmio == nullptr )
            return CO_E_NOTINITIALIZED;
        if( pBuffer == nullptr || pdwSizeRead == nullptr )
            return E_INVALIDARG;

        if( pdwSizeRead != nullptr )
            *pdwSizeRead = 0;

		if (0 != mmioGetInfo(m_hmmio, &mmioinfoIn, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioGetInfo"), E_FAIL );
                
        UINT cbDataIn = dwSizeToRead;
        if( cbDataIn > m_ck.cksize ) 
            cbDataIn = m_ck.cksize;       

        m_ck.cksize -= cbDataIn;
    
        for( uint32_t cT = 0; cT < cbDataIn; cT++ )
        {
            // Copy the bytes from the io to the buffer.
            if( mmioinfoIn.pchNext == mmioinfoIn.pchEndRead )
            {
				if (0 != mmioAdvance(m_hmmio, &mmioinfoIn, MMIO_READ))
					return S_FALSE;//DXTRACE_ERR( TEXT("mmioAdvance"), E_FAIL );

				if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead)
					return S_FALSE;//DXTRACE_ERR( TEXT("mmioinfoIn.pchNext"), E_FAIL );
            }

            // Actual copy.
            *((uint8_t*)pBuffer+cT) = *((uint8_t*)mmioinfoIn.pchNext);
            mmioinfoIn.pchNext++;
        }

		if (0 != mmioSetInfo(m_hmmio, &mmioinfoIn, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioSetInfo"), E_FAIL );

        if( pdwSizeRead != nullptr )
            *pdwSizeRead = cbDataIn;

        return S_OK;
    }
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::Close()
// Desc: Closes the wave file 
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Close()
{
    if( m_dwFlags == WAVEFILE_READ )
    {
        mmioClose( m_hmmio, 0 );
        m_hmmio = nullptr;
    }
    else
    {
        m_mmioinfoOut.dwFlags |= MMIO_DIRTY;

        if( m_hmmio == nullptr )
            return CO_E_NOTINITIALIZED;

		if (0 != mmioSetInfo(m_hmmio, &m_mmioinfoOut, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioSetInfo"), E_FAIL );
    
        // Ascend the output file out of the 'data' chunk -- this will cause
        // the chunk size of the 'data' chunk to be written.
		if (0 != mmioAscend(m_hmmio, &m_ck, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
        // Do this here instead...
		if (0 != mmioAscend(m_hmmio, &m_ckRiff, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
        
        mmioSeek( m_hmmio, 0, SEEK_SET );

		if (0 != (INT)mmioDescend(m_hmmio, &m_ckRiff, nullptr, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioDescend"), E_FAIL );
    
        m_ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

        if( 0 == mmioDescend( m_hmmio, &m_ck, &m_ckRiff, MMIO_FINDCHUNK ) ) 
        {
            uint32_t dwSamples = 0;
            mmioWrite( m_hmmio, (HPSTR)&dwSamples, sizeof(uint32_t) );
            mmioAscend( m_hmmio, &m_ck, 0 ); 
        }
    
        // Ascend the output file out of the 'RIFF' chunk -- this will cause
        // the chunk size of the 'RIFF' chunk to be written.
		if (0 != mmioAscend(m_hmmio, &m_ckRiff, 0))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
        mmioClose( m_hmmio, 0 );
        m_hmmio = nullptr;
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::WriteMMIO()
// Desc: Support function for reading from a multimedia I/O stream
//       pwfxDest is the WAVEFORMATEX for this new wave file.  
//       m_hmmio must be valid before calling.  This function uses it to
//       update m_ckRiff, and m_ck.  
//-----------------------------------------------------------------------------
HRESULT CWaveFile::WriteMMIO( WAVEFORMATEX *pwfxDest )
{
    uint32_t    dwFactChunk; // Contains the actual fact chunk. Garbage until WaveCloseWriteFile.
    MMCKINFO ckOut1;
    
    dwFactChunk = (uint32_t)-1;

    // Create the output file RIFF chunk of form type 'WAVE'.
    m_ckRiff.fccType = mmioFOURCC('W', 'A', 'V', 'E');       
    m_ckRiff.cksize = 0;

	if (0 != mmioCreateChunk(m_hmmio, &m_ckRiff, MMIO_CREATERIFF))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
    // We are now descended into the 'RIFF' chunk we just created.
    // Now create the 'fmt ' chunk. Since we know the size of this chunk,
    // specify it in the MMCKINFO structure so MMIO doesn't have to seek
    // back and set the chunk size after ascending from the chunk.
    m_ck.ckid = mmioFOURCC('f', 'm', 't', ' ');
    m_ck.cksize = sizeof(PCMWAVEFORMAT);   

	if (0 != mmioCreateChunk(m_hmmio, &m_ck, 0))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
    // Write the PCMWAVEFORMAT structure to the 'fmt ' chunk if its that type. 
    if( pwfxDest->wFormatTag == WAVE_FORMAT_PCM )
    {
		if (mmioWrite(m_hmmio, (HPSTR)pwfxDest,
			sizeof(PCMWAVEFORMAT)) != sizeof(PCMWAVEFORMAT))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    }   
    else 
    {
        // Write the variable length size.
		if ((UINT)mmioWrite(m_hmmio, (HPSTR)pwfxDest,
			sizeof(*pwfxDest) + pwfxDest->cbSize) !=
			(sizeof(*pwfxDest) + pwfxDest->cbSize))
			return S_FALSE;//DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    }  
    
    // Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk.
	if (0 != mmioAscend(m_hmmio, &m_ck, 0))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
    
    // Now create the fact chunk, not required for PCM but nice to have.  This is filled
    // in when the close routine is called.
    ckOut1.ckid = mmioFOURCC('f', 'a', 'c', 't');
    ckOut1.cksize = 0;

	if (0 != mmioCreateChunk(m_hmmio, &ckOut1, 0))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioCreateChunk"), E_FAIL );
    
	if (mmioWrite(m_hmmio, (HPSTR)&dwFactChunk, sizeof(dwFactChunk)) !=
		sizeof(dwFactChunk))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioWrite"), E_FAIL );
    
    // Now ascend out of the fact chunk...
	if (0 != mmioAscend(m_hmmio, &ckOut1, 0))
		return S_FALSE;//DXTRACE_ERR( TEXT("mmioAscend"), E_FAIL );
       
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: CWaveFile::Write()
// Desc: Writes data to the open wave file
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Write( UINT nSizeToWrite, uint8_t* pbSrcData, UINT* pnSizeWrote )
{
    UINT cT;

    if( m_bIsReadingFromMemory )
        return E_NOTIMPL;
    if( m_hmmio == nullptr )
        return CO_E_NOTINITIALIZED;
    if( pnSizeWrote == nullptr || pbSrcData == nullptr )
        return E_INVALIDARG;

    *pnSizeWrote = 0;
    
    for( cT = 0; cT < nSizeToWrite; cT++ )
    {       
        if( m_mmioinfoOut.pchNext == m_mmioinfoOut.pchEndWrite )
        {
            m_mmioinfoOut.dwFlags |= MMIO_DIRTY;
			if (0 != mmioAdvance(m_hmmio, &m_mmioinfoOut, MMIO_WRITE))
				return S_FALSE;//DXTRACE_ERR( TEXT("mmioAdvance"), E_FAIL );
        }

        *((uint8_t*)m_mmioinfoOut.pchNext) = *((uint8_t*)pbSrcData+cT);
        (uint8_t*)m_mmioinfoOut.pchNext++;

        (*pnSizeWrote)++;
    }

    return S_OK;
}

//	End Of Code (By Lynus On 2001-04-12 오후 1:52:49 )
//////////////////////////////////////////////////

// ===== END N3Base/WaveFile.cpp =====

// ===== BEGIN N3Base/WaveFile.h =====
#line 1 "N3Base/WaveFile.h"
﻿//////////////////////////////////////////////////
//	Commented By : Lynus
//	Commented On 2001-04-12 오후 1:51:00
//
//	CWave Class (WaveFile.h)
//
//	End Of Comment (By Lynus On 2001-04-12 오후 1:51:00 )
//////////////////////////////////////////////////
//////////////////////////////////////////////////
//	Coded By : Lynus
//	Coded On 2001-04-12 오후 1:50:14
//

#ifndef __WAVE_H_
#define __WAVE_H_

#include <Windows.h>
#include <stdint.h>
#include <inttypes.h>

#include <mmsystem.h>
#include <mmreg.h>
#include <dxerr.h>

#pragma pack(push, 1)
struct WavFileHeader
{
	struct WavFormat
	{
		uint32_t	ID				= mmioFOURCC('f', 'm', 't', ' ');

		// Chunk size minus 8 bytes
		uint32_t	Size			= sizeof(WavFormat) - 8;

		// Audio format (1: PCM integer, 3: IEEE 754 float)
		uint16_t	AudioFormat		= 1;

		// Number of channels
		uint16_t	NumChannels		= 1;

		// Sample rate (in hertz)
		uint32_t	SampleRate		= 44100;

		// SampleRate * BytesPerBlock
		uint32_t	BytesPerSec		= 0;

		// Number of bytes per block (NumChannels * (BitsPerSample / 8))
		uint16_t	BytesPerBlock	= 0;

		// Number of bits per sample
		uint16_t	BitsPerSample	= 0;
	};

	struct WavData
	{
		uint32_t	ID				= mmioFOURCC('d', 'a', 't', 'a');

		// NumSamples * NumChannels * (BitsPerSample / 8)
		uint32_t	Size			= 0;
	};

	// RIFF file identifier
	uint32_t		FileTypeID		= mmioFOURCC('R', 'I', 'F', 'F');

	// Overall file size minus 8 bytes (append the data size)
	uint32_t		FileSize		= sizeof(WavFileHeader) - 8;

	// WAV file format identifier
	uint32_t		FileFormatID	= mmioFOURCC('W', 'A', 'V', 'E');

	WavFormat		Format			= {};
	WavData			Data			= {};
};
#pragma pack(pop)

#define WAVEFILE_READ	1
#define WAVEFILE_WRITE	0

class CWaveFile
{
public:
    WAVEFORMATEX* m_pwfx;        // Pointer to WAVEFORMATEX structure
    HMMIO         m_hmmio;       // MM I/O handle for the WAVE
    MMCKINFO      m_ck;          // Multimedia RIFF chunk
    MMCKINFO      m_ckRiff;      // Use in opening a WAVE file
    uint32_t      m_dwSize;      // The size of the wave file
    MMIOINFO      m_mmioinfoOut;
    uint32_t      m_dwFlags;
    BOOL          m_bIsReadingFromMemory;
    uint8_t*      m_pbData;
    uint8_t*      m_pbDataCur;
    ULONG         m_ulDataSize;

protected:
    HRESULT ReadMMIO();
    HRESULT WriteMMIO( WAVEFORMATEX *pwfxDest );

public:
    CWaveFile();
    ~CWaveFile();

    HRESULT Open( LPCSTR strFileName, WAVEFORMATEX* pwfx, uint32_t dwFlags );
    HRESULT OpenFromMemory( uint8_t* pbData, ULONG ulDataSize, WAVEFORMATEX* pwfx, uint32_t dwFlags );
    HRESULT Close();

    HRESULT Read( uint8_t* pBuffer, DWORD dwSizeToRead, DWORD* pdwSizeRead );
    HRESULT Write( UINT nSizeToWrite, uint8_t* pbData, UINT* pnSizeWrote );

    uint32_t   GetSize();
    HRESULT ResetFile();
    WAVEFORMATEX* GetFormat() { return m_pwfx; };
};

#endif // #ifndef __WAVE_H_
//	End Of Code (By Lynus On 2001-04-12 오후 1:50:14 )
//////////////////////////////////////////////////

// ===== END N3Base/WaveFile.h =====

// ===== BEGIN N3Base/WinCrypt.cpp =====
#line 1 "N3Base/WinCrypt.cpp"
﻿#include "StdAfxBase.h"
#include "WinCrypt.h"
#include "N3Base.h"

#include <FileIO/File.h>

CWinCrypt::CWinCrypt()
{
	m_bIsLoaded			= false;
	m_hCryptProvider	= 0;
	m_hCryptHash		= 0;
	m_hCryptKey			= 0;
}

bool CWinCrypt::Load()
{
	Release();

	// Try to acquire an existing key context
	// NOTE: Officially this passes 0, but this will require access to the persistent keystore used for
	// private keys.
	// If we use CRYPT_VERIFYCONTEXT instead, we don't need access to private keys, so we can avoid
	// requiring the extra privs.
	if (!CryptAcquireContext(&m_hCryptProvider, nullptr, Provider, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)
		// Create a new key context instead
		&& !CryptAcquireContext(&m_hCryptProvider, nullptr, Provider, PROV_RSA_FULL, CRYPT_NEWKEYSET))
		return false;

	if (!CryptCreateHash(m_hCryptProvider, CALG_SHA, 0, 0, &m_hCryptHash))
	{
		CryptReleaseContext(m_hCryptProvider, 0);
		return false;
	}

	if (!CryptHashData(m_hCryptHash, reinterpret_cast<const BYTE*>(Cipher), sizeof(Cipher) - 1, 0)
		|| !CryptDeriveKey(m_hCryptProvider, CALG_RC4, m_hCryptHash, 0x800000u, &m_hCryptKey))
	{
		CryptDestroyHash(m_hCryptHash);
		CryptReleaseContext(m_hCryptProvider, 0);
		return false;
	}

	m_bIsLoaded = TRUE;
	return true;
}

void CWinCrypt::Release()
{
	if (m_bIsLoaded)
	{
		CryptDestroyKey(m_hCryptKey);
		CryptDestroyHash(m_hCryptHash);
		CryptReleaseContext(m_hCryptProvider, 0);
	}

	m_bIsLoaded			= false;
	m_hCryptProvider	= 0;
	m_hCryptHash		= 0;
	m_hCryptKey			= 0;
}

bool CWinCrypt::ReadFile(File& file, void* buffer, size_t bytesToRead, size_t* bytesRead /*= nullptr*/)
{
	if (!file.Read(buffer, bytesToRead, bytesRead))
		return false;

	if (IsLoaded())
	{
		DWORD dwDataLen = static_cast<DWORD>(bytesToRead);
		if (!CryptDecrypt(
			m_hCryptKey,
			0,
			TRUE,
			0,
			static_cast<BYTE*>(buffer),
			&dwDataLen))
			return false;
	}

	return true;
}

CWinCrypt::~CWinCrypt()
{
	Release();
}

// ===== END N3Base/WinCrypt.cpp =====

// ===== BEGIN N3Base/WinCrypt.h =====
#line 1 "N3Base/WinCrypt.h"
﻿#pragma once

#include <wincrypt.h>

class File;
class CWinCrypt
{
public:
	constexpr const static TCHAR Provider[]	= MS_ENHANCED_PROV;
	constexpr const static char Cipher[]	= "owsd9012%$1as!wpow1033b%!@%12";

	inline bool IsLoaded() const {
		return m_bIsLoaded;
	}

	CWinCrypt();
	~CWinCrypt();
	bool Load();
	void Release();
	bool ReadFile(File& file, void* buffer, size_t bytesToRead, size_t* bytesRead = nullptr);

protected:
	bool		m_bIsLoaded;
	HCRYPTPROV	m_hCryptProvider;
	HCRYPTHASH	m_hCryptHash;
	HCRYPTKEY	m_hCryptKey;
};

// ===== END N3Base/WinCrypt.h =====

// ===== BEGIN Option/Option.cpp =====
#line 1 "Option/Option.cpp"
﻿// Option.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "Option.h"
#include "OptionDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionApp

BEGIN_MESSAGE_MAP(COptionApp, CWinApp)
	//{{AFX_MSG_MAP(COptionApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionApp construction

COptionApp::COptionApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COptionApp object

COptionApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COptionApp initialization

BOOL COptionApp::InitInstance()
{
	AfxEnableControlContainer();

	COptionDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

// ===== END Option/Option.cpp =====

// ===== BEGIN Option/Option.h =====
#line 1 "Option/Option.h"
﻿#pragma once

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// COptionApp:
// See Option.cpp for the implementation of this class
//

class COptionApp : public CWinApp
{
public:
	COptionApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(COptionApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

// ===== END Option/Option.h =====

// ===== BEGIN Option/OptionDlg.cpp =====
#line 1 "Option/OptionDlg.cpp"
﻿// OptionDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Option.h"
#include "OptionDlg.h"
#include <algorithm>
#include <set>
#include <vector>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionDlg dialog

COptionDlg::COptionDlg(CWnd* pParent /*=nullptr*/)
	: CDialog(COptionDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COptionDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

	m_Option.InitDefault(); // 옵션 초기화
}

void COptionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionDlg)
	DDX_Control(pDX, IDC_SLD_EFFECT_COUNT, m_SldEffectCount);
	DDX_Control(pDX, IDC_SLD_SOUND_DISTANCE, m_SldEffectSoundDist);
	DDX_Control(pDX, IDC_CB_COLORDEPTH, m_CB_ColorDepth);
	DDX_Control(pDX, IDC_CB_RESOLUTION, m_CB_Resolution);
	DDX_Control(pDX, IDC_SLD_VIEWING_DISTANCE, m_SldViewDist);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COptionDlg, CDialog)
	//{{AFX_MSG_MAP(COptionDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_B_APPLY_AND_EXECUTE, OnBApplyAndExecute)
	ON_WM_HSCROLL()
	ON_BN_CLICKED(IDC_B_VERSION, OnBVersion)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

struct Resolution
{
	uint32_t Width;
	uint32_t Height;
};

static std::vector<Resolution> s_supportedResolutions;

static Resolution DefaultResolutions[] =
{
	{ 1024, 768 },
	{ 1152, 864 },
	{ 1280, 768 },
	{ 1280, 800 },
	{ 1280, 960 },
	{ 1280, 1024 },
	{ 1360, 768 },
	{ 1366, 768 },
	{ 1600, 1200 }
};

// The game supports at minimum, a resolution of 1024x768.
// The UIs will not fit on anything smaller than this.
constexpr Resolution MIN_RESOLUTION = { 1024, 768 };

/*
 * LoadSupportedResolutions will load a vector of valid resolutions for the primary monitor.
 * If no resolutions are detectable for the primary monitor, falls back to the default, hardcoded list.
 */
void COptionDlg::LoadSupportedResolutions()
{
	// Get the primary monitor
	DISPLAY_DEVICE device = {};
	device.cb = sizeof(DISPLAY_DEVICE);

	// We point to the device name instead of copying it / using it directly
	// that way if we don't find a primary monitor, we pass nullptr as the first param into EnumDisplaySettings.
	TCHAR* primaryDeviceName = nullptr;
	int deviceNumber = 0;
	while (EnumDisplayDevices(nullptr, deviceNumber, &device, EDD_GET_DEVICE_INTERFACE_NAME))
	{
		if (device.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
		{
			// Primary monitor found; get a pointer to the name and break out of the loop
			primaryDeviceName = &device.DeviceName[0];
			break;
		}

		deviceNumber++;
	}

	// Order such that higher resolutions appear at the top of the drop down list.
	// With modern monitors, this list can get pretty long.
	// If we're going to send a user scrolling for a resolution, it should be one that most
	// users aren't looking for.
	auto cmp = [](const Resolution& a, const Resolution& b) -> bool
	{
		return a.Width > b.Width
			|| (a.Width == b.Width && a.Height > b.Height);
	};

	// The same resolution can be listed many times on a monitor depending on available refresh rates.
	// We should limit it to unique resolutions only.
	std::set<Resolution, decltype(cmp)> loadedResolutions(cmp);

	// Discover resolution settings
	DEVMODE devmode = {};
	devmode.dmSize = sizeof(DEVMODE);
	for (int iModeNum = 0; EnumDisplaySettings(primaryDeviceName, iModeNum, &devmode); iModeNum++)
	{
		// Only support 32-bit resolutions.
		// Officially the game supports 16-bit, but we only care about the resolutions themselves here.
		// We also just don't really bother to go out of our way to support that anymore anyway.
		if (devmode.dmBitsPerPel != 32)
			continue;

		Resolution resolution = { devmode.dmPelsWidth, devmode.dmPelsHeight };

		// Filter out resolutions with dimensions smaller than our minimum (1024x768)
		if (resolution.Width < MIN_RESOLUTION.Width
			|| resolution.Height < MIN_RESOLUTION.Height)
			continue;

		auto itr = loadedResolutions.insert(resolution);
		if (!itr.second)
			continue;

		s_supportedResolutions.push_back(
			std::move(resolution));
	}

	// We failed to dynamically pull available resolutions, fall back to the hardcoded list
	if (s_supportedResolutions.empty())
	{
		s_supportedResolutions.insert(
			s_supportedResolutions.begin(),
			std::begin(DefaultResolutions),
			std::end(DefaultResolutions));
	}

	// Sort the vector such that higher resolutions appear at the top of the drop down list.
	std::sort(
		s_supportedResolutions.begin(),
		s_supportedResolutions.end(),
		cmp);
}

/////////////////////////////////////////////////////////////////////////////
// COptionDlg message handlers

BOOL COptionDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != nullptr)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// 각종 컨트롤 초기화..
	m_SldEffectCount.SetRange(1000, 2000);
	m_SldViewDist.SetRange(256, 512);
	m_SldEffectSoundDist.SetRange(20, 48);

	LoadSupportedResolutions();

	int iAdd = 0;

	CString szResolution;
	for (const auto& resolution : s_supportedResolutions)
	{
		szResolution.Format(
			_T("%u X %u"),
			resolution.Width,
			resolution.Height);
		iAdd = m_CB_Resolution.AddString(szResolution);

		m_CB_Resolution.SetItemData(
			iAdd,
			MAKELPARAM(resolution.Height, resolution.Width));
	}

	iAdd = m_CB_ColorDepth.AddString(_T("16 Bit"));
	m_CB_ColorDepth.SetItemData(iAdd, 16);

	iAdd = m_CB_ColorDepth.AddString(_T("32 Bit"));
	m_CB_ColorDepth.SetItemData(iAdd, 32);

	TCHAR szBuff[_MAX_PATH] = {};
	GetCurrentDirectory(_countof(szBuff), szBuff);

	m_szInstalledPath = szBuff;

	// Version 표시
	CString szServerIniPath = m_szInstalledPath + _T("\\Server.Ini");
	DWORD dwVersion = GetPrivateProfileInt(_T("Version"), _T("Files"), 0, szServerIniPath);
	SetDlgItemInt(IDC_E_VERSION, dwVersion);

	// 세팅을 읽어온다..
	SettingLoad(m_szInstalledPath + _T("\\Option.ini"));
	SettingUpdate();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void COptionDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void COptionDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR COptionDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void COptionDlg::OnOK()
{
	SettingSave(m_szInstalledPath + _T("\\Option.ini"));

	CDialog::OnOK();
}

void COptionDlg::OnBApplyAndExecute()
{
	CString szExeFN = m_szInstalledPath + _T("\\"); // 실행 파일 이름 만들고..
	szExeFN += _T("Launcher.exe");

	ShellExecute(nullptr, _T("open"), szExeFN, _T(""), m_szInstalledPath, SW_SHOWNORMAL); // 게임 실행..

	OnOK();
}

void COptionDlg::SettingSave(CString szIniFile)
{
	if (szIniFile.GetLength() <= 0)
		return;

	CString szBuff;

	if (IsDlgButtonChecked(IDC_R_TEX_CHR_HIGH))
		m_Option.iTexLOD_Chr = 0;
	else if (IsDlgButtonChecked(IDC_R_TEX_CHR_LOW))
		m_Option.iTexLOD_Chr = 1;
	else
		m_Option.iTexLOD_Chr = 1;

	if (IsDlgButtonChecked(IDC_R_TEX_SHAPE_HIGH))
		m_Option.iTexLOD_Shape = 0;
	else if (IsDlgButtonChecked(IDC_R_TEX_SHAPE_LOW))
		m_Option.iTexLOD_Shape = 1;
	else
		m_Option.iTexLOD_Shape = 0;

	if (IsDlgButtonChecked(IDC_R_TEX_TERRAIN_HIGH))
		m_Option.iTexLOD_Terrain = 0;
	else if (IsDlgButtonChecked(IDC_R_TEX_TERRAIN_LOW))
		m_Option.iTexLOD_Terrain = 1;
	else
		m_Option.iTexLOD_Terrain = 1;

	if (IsDlgButtonChecked(IDC_C_SHADOW))
		m_Option.iUseShadow = 1;
	else
		m_Option.iUseShadow = 0;

	if (IsDlgButtonChecked(IDC_C_WINDOW_MODE))
		m_Option.bWindowMode = true;
	else
		m_Option.bWindowMode = false;

	if (IsDlgButtonChecked(IDC_C_SHOW_WEAPON_EFFECT))
		m_Option.bEffectVisible = true;
	else
		m_Option.bEffectVisible = false;

	int iSel = m_CB_Resolution.GetCurSel();

	m_Option.iViewWidth = 1024;
	m_Option.iViewHeight = 768;

	if (iSel >= 0
		&& iSel < (int) s_supportedResolutions.size())
	{
		const auto& resolution = s_supportedResolutions[iSel];
		m_Option.iViewWidth = resolution.Width;
		m_Option.iViewHeight = resolution.Height;
	}

	iSel = m_CB_ColorDepth.GetCurSel();
	if (CB_ERR != iSel)
	{
		m_Option.iViewColorDepth = static_cast<int>(m_CB_ColorDepth.GetItemData(iSel));
		if (m_Option.iViewColorDepth != 16
			&& m_Option.iViewColorDepth != 32)
			m_Option.iViewColorDepth = 16;
	}
	else
	{
		m_Option.iViewColorDepth = 16;
	}

	m_Option.iEffectCount = m_SldEffectCount.GetPos();
	if (m_Option.iEffectCount < 1000)
		m_Option.iEffectCount = 1000;
	else if (m_Option.iEffectCount > 2000)
		m_Option.iEffectCount = 2000;

	m_Option.iViewDist = m_SldViewDist.GetPos();
	if (m_Option.iViewDist < 256)
		m_Option.iViewDist = 256;
	else if (m_Option.iViewDist > 512)
		m_Option.iViewDist = 512;

	m_Option.iEffectSndDist = m_SldEffectSoundDist.GetPos();
	if (m_Option.iEffectSndDist < 20)
		m_Option.iEffectSndDist = 20;
	else if (m_Option.iEffectSndDist > 48)
		m_Option.iEffectSndDist = 48;

	szBuff.Format(_T("%d"), m_Option.iTexLOD_Chr);		WritePrivateProfileString(_T("Texture"),	_T("LOD_Chr"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iTexLOD_Shape);	WritePrivateProfileString(_T("Texture"),	_T("LOD_Shape"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iTexLOD_Terrain);	WritePrivateProfileString(_T("Texture"),	_T("LOD_Terrain"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iUseShadow);		WritePrivateProfileString(_T("Shadow"),		_T("Use"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iViewWidth);		WritePrivateProfileString(_T("ViewPort"),	_T("Width"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iViewHeight);		WritePrivateProfileString(_T("ViewPort"),	_T("Height"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iViewColorDepth);  WritePrivateProfileString(_T("ViewPort"),	_T("ColorDepth"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iViewDist);		WritePrivateProfileString(_T("ViewPort"),	_T("Distance"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iEffectSndDist);	WritePrivateProfileString(_T("Sound"),		_T("Distance"), szBuff, szIniFile);
	szBuff.Format(_T("%d"), m_Option.iEffectCount);		WritePrivateProfileString(_T("Effect"),		_T("Count"), szBuff, szIniFile);

	m_Option.bSoundBgm = (IsDlgButtonChecked(IDC_C_SOUND_BGM)) ? true : false;
	m_Option.bSoundBgm ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("Sound"), _T("Bgm"), szBuff, szIniFile);

	m_Option.bSoundEffect = (IsDlgButtonChecked(IDC_C_SOUND_EFFECT)) ? true : false;
	m_Option.bSoundEffect ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("Sound"), _T("Effect"), szBuff, szIniFile);

	m_Option.bSndDuplicated = (IsDlgButtonChecked(IDC_C_SOUND_DUPLICATE)) ? true : false;
	m_Option.bSndDuplicated ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("Sound"), _T("Duplicate"), szBuff, szIniFile);

	m_Option.bWindowCursor = (IsDlgButtonChecked(IDC_C_CURSOR_WINDOW)) ? true : false;
	m_Option.bWindowCursor ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("Cursor"), _T("WindowCursor"), szBuff, szIniFile);

	m_Option.bWindowMode = (IsDlgButtonChecked(IDC_C_WINDOW_MODE)) ? true : false;
	m_Option.bWindowMode ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("Screen"), _T("WindowMode"), szBuff, szIniFile);

	m_Option.bEffectVisible = (IsDlgButtonChecked(IDC_C_SHOW_WEAPON_EFFECT)) ? true : false;
	m_Option.bEffectVisible ? szBuff = "1" : szBuff = "0";
	WritePrivateProfileString(_T("WeaponEffect"), _T("EffectVisible"), szBuff, szIniFile);
}

void COptionDlg::SettingLoad(CString szIniFile)
{
	if (szIniFile.GetLength() <= 0)
		return;

	m_Option.iTexLOD_Chr		= GetPrivateProfileInt(_T("Texture"),		_T("LOD_Chr"), 0, szIniFile);
	m_Option.iTexLOD_Shape		= GetPrivateProfileInt(_T("Texture"),		_T("LOD_Shape"), 0, szIniFile);
	m_Option.iTexLOD_Terrain	= GetPrivateProfileInt(_T("Texture"),		_T("LOD_Terrain"), 0, szIniFile);
	m_Option.iUseShadow			= GetPrivateProfileInt(_T("Shadow"),		_T("Use"), 1, szIniFile);
	m_Option.iViewWidth			= GetPrivateProfileInt(_T("ViewPort"),		_T("Width"), 1024, szIniFile);
	m_Option.iViewHeight		= GetPrivateProfileInt(_T("ViewPort"),		_T("Height"), 768, szIniFile);
	m_Option.iViewColorDepth	= GetPrivateProfileInt(_T("ViewPort"),		_T("ColorDepth"), 16, szIniFile);
	m_Option.iViewDist			= GetPrivateProfileInt(_T("ViewPort"),		_T("Distance"), 512, szIniFile);
	m_Option.iEffectSndDist		= GetPrivateProfileInt(_T("Sound"),			_T("Distance"), 48, szIniFile);
	m_Option.iEffectCount		= GetPrivateProfileInt(_T("Effect"),		_T("Count"), 2000, szIniFile);

	m_Option.bSoundBgm			= GetPrivateProfileInt(_T("Sound"),			_T("Bgm"), 1, szIniFile) != 0;
	m_Option.bSoundEffect		= GetPrivateProfileInt(_T("Sound"),			_T("Effect"), 1, szIniFile) != 0;
	m_Option.bSndDuplicated		= GetPrivateProfileInt(_T("Sound"),			_T("Duplicate"), 0, szIniFile) != 0;
	m_Option.bWindowCursor		= GetPrivateProfileInt(_T("Cursor"),		_T("WindowCursor"), 1, szIniFile) != 0;
	m_Option.bWindowMode		= GetPrivateProfileInt(_T("Screen"),		_T("WindowMode"), 0, szIniFile) != 0;
	m_Option.bEffectVisible		= GetPrivateProfileInt(_T("WeaponEffect"),	_T("EffectVisible"), 1, szIniFile) != 0;
}

void COptionDlg::SettingUpdate()
{
	if (m_Option.iTexLOD_Chr != 0)
		CheckRadioButton(IDC_R_TEX_CHR_HIGH, IDC_R_TEX_CHR_LOW, IDC_R_TEX_CHR_LOW);
	else
		CheckRadioButton(IDC_R_TEX_CHR_HIGH, IDC_R_TEX_CHR_LOW, IDC_R_TEX_CHR_HIGH);

	if (m_Option.iTexLOD_Shape != 0)
		CheckRadioButton(IDC_R_TEX_SHAPE_HIGH, IDC_R_TEX_SHAPE_LOW, IDC_R_TEX_SHAPE_LOW);
	else
		CheckRadioButton(IDC_R_TEX_SHAPE_HIGH, IDC_R_TEX_SHAPE_LOW, IDC_R_TEX_SHAPE_HIGH);

	if (m_Option.iTexLOD_Terrain != 0)
		CheckRadioButton(IDC_R_TEX_TERRAIN_HIGH, IDC_R_TEX_TERRAIN_LOW, IDC_R_TEX_TERRAIN_LOW);
	else
		CheckRadioButton(IDC_R_TEX_TERRAIN_HIGH, IDC_R_TEX_TERRAIN_LOW, IDC_R_TEX_TERRAIN_HIGH);

	CheckDlgButton(IDC_C_SHADOW, m_Option.iUseShadow);

	int iSel = 0;
	for (int i = 0; i < (int) s_supportedResolutions.size(); i++)
	{
		const auto& resolution = s_supportedResolutions[i];
		if (m_Option.iViewWidth == resolution.Width
			&& m_Option.iViewHeight == resolution.Height)
		{
			iSel = i;
			break;
		}
	}

	m_CB_Resolution.SetCurSel(iSel);

	if (16 == m_Option.iViewColorDepth)
		iSel = 0;
	else if (32 == m_Option.iViewColorDepth)
		iSel = 1;
	m_CB_ColorDepth.SetCurSel(iSel);

	m_SldEffectCount.SetPos(m_Option.iEffectCount);
	m_SldViewDist.SetPos(m_Option.iViewDist);
	m_SldEffectSoundDist.SetPos(m_Option.iEffectSndDist);

	CheckDlgButton(IDC_C_SOUND_BGM, m_Option.bSoundBgm);
	CheckDlgButton(IDC_C_SOUND_EFFECT, m_Option.bSoundEffect);
	CheckDlgButton(IDC_C_SOUND_DUPLICATE, m_Option.bSndDuplicated);
	CheckDlgButton(IDC_C_CURSOR_WINDOW, m_Option.bWindowCursor);
	CheckDlgButton(IDC_C_WINDOW_MODE, m_Option.bWindowMode);
	CheckDlgButton(IDC_C_SHOW_WEAPON_EFFECT, m_Option.bEffectVisible);
}

void COptionDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if ((void*) pScrollBar == (void*) (&m_SldEffectCount))
		m_Option.iEffectCount = m_SldEffectCount.GetPos();
	else if ((void*) pScrollBar == (void*) (&m_SldViewDist))
		m_Option.iViewDist = m_SldViewDist.GetPos();
	else if ((void*) pScrollBar == (void*) (&m_SldEffectSoundDist))
		m_Option.iEffectSndDist = m_SldEffectSoundDist.GetPos();

	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

void COptionDlg::OnBVersion()
{
	CString szMsg;
	szMsg.LoadString(IDS_CONFIRM_WRITE_REGISRY);

	// 한번 물어본다..
	if (IDNO == MessageBox(szMsg, _T(""), MB_YESNO))
		return;

	DWORD dwVersion = GetDlgItemInt(IDC_E_VERSION);

	CString szVersion, szServerIniPath;
	szVersion.Format(_T("%d"), dwVersion);
	szServerIniPath = m_szInstalledPath + _T("\\Server.ini");
	WritePrivateProfileString(_T("Version"), _T("Files"), szVersion, szServerIniPath);
}

// ===== END Option/OptionDlg.cpp =====

// ===== BEGIN Option/OptionDlg.h =====
#line 1 "Option/OptionDlg.h"
﻿#pragma once

/////////////////////////////////////////////////////////////////////////////
// COptionDlg dialog
struct __GameOption
{
	int		iTexLOD_Chr;		// Texture LOD
	int		iTexLOD_Shape;		// Texture LOD
	int		iTexLOD_Terrain;	// Texture LOD
	int		iUseShadow;			// 그림자 사용 0 사용안함 1 사용
	int		iViewDist;			// 가시거리..
	int		iViewWidth;			// 화면 길이
	int		iViewHeight;		// 화면 너비
	int		iViewColorDepth;	// 색상수..
	int		iEffectSndDist;		// 이펙트 사운드 거리
	int		iEffectCount;
	bool	bSndDuplicated;		// 중복된 음원 사용
	bool	bSoundBgm;
	bool	bSoundEffect;
	bool	bWindowCursor;		// 윈도우 커서 사용
	bool	bWindowMode;
	bool	bEffectVisible;

	void InitDefault()
	{
		iUseShadow = 1;
		iTexLOD_Chr = 0;
		iTexLOD_Shape = 0;
		iTexLOD_Terrain = 0;
		iViewColorDepth = 16;
		iViewWidth = 1024;
		iViewHeight = 768;
		iViewDist = 512;
		iEffectSndDist = 48;
		bSndDuplicated = false;
		bSoundBgm = true;
		bSoundEffect = true;
		bWindowCursor = true;
		bWindowMode = false;
		bEffectVisible = true;
	}

	__GameOption() { InitDefault(); }
};

class COptionDlg : public CDialog
{
protected:
	CString m_szInstalledPath;
	__GameOption m_Option;

// Construction
public:
	static void LoadSupportedResolutions();
	void SettingUpdate();
	void SettingLoad(CString szIniFile);
	void SettingSave(CString szIniFile);
	COptionDlg(CWnd* pParent = nullptr);	// standard constructor

// Dialog Data
	//{{AFX_DATA(COptionDlg)
	enum { IDD = IDD_OPTION_DIALOG };
	CSliderCtrl	m_SldEffectCount;
	CSliderCtrl	m_SldEffectSoundDist;
	CComboBox	m_CB_ColorDepth;
	CComboBox	m_CB_Resolution;
	CSliderCtrl	m_SldViewDist;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(COptionDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnBApplyAndExecute();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnBVersion();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

// ===== END Option/OptionDlg.h =====

// ===== BEGIN Option/StdAfx.cpp =====
#line 1 "Option/StdAfx.cpp"
﻿// stdafx.cpp : source file that includes just the standard includes
//	Option.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"




// ===== END Option/StdAfx.cpp =====

// ===== BEGIN Option/StdAfx.h =====
#line 1 "Option/StdAfx.h"
﻿// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__171ABA59_147A_4DC9_8B22_AE96722E7AF1__INCLUDED_)
#define AFX_STDAFX_H__171ABA59_147A_4DC9_8B22_AE96722E7AF1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__171ABA59_147A_4DC9_8B22_AE96722E7AF1__INCLUDED_)

// ===== END Option/StdAfx.h =====

// ===== BEGIN Option/resource.h =====
#line 1 "Option/resource.h"
﻿//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Option.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_OPTION_DIALOG               102
#define IDS_PRODUCT                     102
#define IDS_ERR_REGISTRY_OPEN           110
#define IDS_ERR_REGISTRY_READ_VERSION   111
#define IDS_ERR_REGISTRY_READ_PATH      112
#define IDS_ERR_REGISTRY_READ_EXE       113
#define IDS_ERR_REGISTRY_READ_SERVICE   114
#define IDS_ERR_REGISTRY_WRITE_VERSION  115
#define IDS_CONFIRM_WRITE_REGISRY       116
#define IDR_MAINFRAME                   128
#define IDC_R_TEX_CHR_HIGH              1001
#define IDC_R_TEX_CHR_LOW               1002
#define IDC_SLD_VIEWING_DISTANCE        1003
#define IDC_CB_RESOLUTION               1004
#define IDC_B_APPLY_AND_EXECUTE         1005
#define IDC_CB_COLORDEPTH               1006
#define IDC_C_SHADOW                    1007
#define IDC_R_TEX_SHAPE_HIGH            1008
#define IDC_R_TEX_SHAPE_LOW             1009
#define IDC_R_TEX_TERRAIN_HIGH          1010
#define IDC_R_TEX_TERRAIN_LOW           1011
#define IDC_E_VERSION                   1012
#define IDC_B_VERSION                   1013
#define IDC_C_SOUND_ENABLE              1014
#define IDC_C_SOUND_DUPLICATE           1015
#define IDC_SLD_SOUND_DISTANCE          1016
#define IDC_C_CURSOR_WINDOW             1017
#define IDC_SLD_EFFECT_COUNT            1018
#define IDC_C_WINDOW_MODE               1019
#define IDC_C_SHOW_WEAPON_EFFECT        1020
#define IDC_C_SOUND_BGM                 1032
#define IDC_C_SOUND_EFFECT              1033

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

// ===== END Option/resource.h =====

// ===== BEGIN WarFare/APISocket.cpp =====
#line 1 "WarFare/APISocket.cpp"
﻿// APISocket.cpp: implementation of the CAPISocket class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "APISocket.h"
#include "ClientResourceFormatter.h"
#include <winsock.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//
static WSAData s_WSData;
int			CAPISocket::s_nInstanceCount = 0;


#ifdef _CRYPTION
BOOL		CAPISocket::s_bCryptionFlag = FALSE;			//0 : 비암호화 , 1 : 암호화
CJvCryption	CAPISocket::s_JvCrypt;
uint32_t	CAPISocket::s_wSendVal = 0;
uint32_t	CAPISocket::s_wRcvVal = 0;
#endif

const uint16_t PACKET_HEADER = 0XAA55;
const uint16_t PACKET_TAIL = 0X55AA;

#ifdef _N3GAME
#include <N3Base/LogWriter.h>
#endif

CAPISocket::CAPISocket()
{
	m_hSocket = (void *)INVALID_SOCKET;
	m_hWndTarget = nullptr;
	m_szIP.clear();
	m_dwPort = 0;

	if (s_nInstanceCount++ == 0)
		WSAStartup(0x0101, &s_WSData);

	m_iSendByteCount = 0;
	m_bConnected = FALSE;
	m_bEnableSend = TRUE; // 보내기 가능..?
}

CAPISocket::~CAPISocket()
{
	Release();

	s_nInstanceCount--;
	if (s_nInstanceCount==0)
	{
		WSACleanup();
	}
}

void CAPISocket::Release()
{
	this->Disconnect();

	while (!m_qRecvPkt.empty())
	{
		auto pkt = m_qRecvPkt.front();
		delete pkt;
		m_qRecvPkt.pop();
	}

	m_iSendByteCount = 0;
		
#ifdef _DEBUG
	memset(m_Statistics_Send_Sum, 0, sizeof(m_Statistics_Send_Sum));
	memset(m_Statistics_Recv_Sum, 0, sizeof(m_Statistics_Recv_Sum));
#endif
}

void CAPISocket::Disconnect()
{
	if ((SOCKET)m_hSocket != INVALID_SOCKET)
		closesocket((SOCKET)m_hSocket);
	
	m_hSocket = (void *)INVALID_SOCKET;
	m_hWndTarget = nullptr;
	m_szIP.clear();
	m_dwPort = 0;

	m_bConnected = FALSE;
	m_bEnableSend = TRUE; // 보내기 가능..?

#ifdef _CRYPTION
	InitCrypt(0); // 암호화 해제..
#endif // #ifdef _CRYPTION
}

int CAPISocket::Connect(HWND hWnd, const char* pszIP, uint32_t dwPort)
{	
	if (pszIP == nullptr || dwPort == 0)
		return -1;

	if ((SOCKET) m_hSocket != INVALID_SOCKET)
		this->Disconnect();

	//
	struct sockaddr_in far server;
	struct hostent far* hp;
  
	if ((pszIP[0] >= '0') && (pszIP[0] <= '9'))
	{
		memset(&server, 0, sizeof(server));
	   server.sin_family      = AF_INET;
	   server.sin_addr.s_addr = inet_addr(pszIP);
	   server.sin_port        = htons((u_short)dwPort);
	}
	else
	{
		hp = gethostbyname(pszIP);
		if (hp == nullptr)
		{
#ifdef _DEBUG
			std::string msg = fmt::format("Error: Connecting to {}.", pszIP);
			MessageBoxA(hWnd, msg.c_str(), "socket error", MB_OK | MB_ICONSTOP);
#endif
			return -1;
		}

		memset(&server, 0, sizeof(server));
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((u_short)dwPort);  
	}// else 

	// create socket 
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock == INVALID_SOCKET) 
	{
		int iErrCode = ::WSAGetLastError();
#ifdef _DEBUG
		char msg[] = "Error opening stream socket";
		MessageBoxA(hWnd, msg, "socket error", MB_OK | MB_ICONSTOP);
#endif
		return iErrCode;
	}

	m_hSocket = (void *)sock;

	// 소켓 옵션
	int iRecvBufferLen = RECEIVE_BUF_SIZE;
	int iErr = setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char*)&iRecvBufferLen, 4);
  
	if (connect(sock, (struct sockaddr far *)&server, sizeof(server)) != 0)
	{
		int iErrCode = ::WSAGetLastError();

		closesocket(sock);
		m_hSocket = (void *)INVALID_SOCKET;

		return iErrCode;
	}

	WSAAsyncSelect(sock, hWnd, WM_SOCKETMSG, FD_CONNECT | FD_READ | FD_CLOSE);

	m_hWndTarget = hWnd;
	m_szIP = pszIP;
	m_dwPort = dwPort;
	m_bConnected = TRUE;
	
#ifdef _DEBUG
	memset(m_Statistics_Send_Sum, 0, sizeof(m_Statistics_Send_Sum));
	memset(m_Statistics_Recv_Sum, 0, sizeof(m_Statistics_Recv_Sum));
#endif
	
	return 0;
}

int	CAPISocket::ReConnect()
{
	return Connect(m_hWndTarget, m_szIP.c_str(), m_dwPort);
}

void CAPISocket::Receive()
{
	if (INVALID_SOCKET == (SOCKET)m_hSocket || FALSE == m_bConnected)
		return;

	u_long	dwPktSize = 0;
	u_long	dwRead = 0;
	int		count = 0;

	ioctlsocket((SOCKET) m_hSocket, FIONREAD, &dwPktSize);
	while(dwRead < dwPktSize)
	{
		count = recv((SOCKET)m_hSocket, (char*)m_RecvBuf, RECEIVE_BUF_SIZE, 0);
		if (count == SOCKET_ERROR)
		{
			__ASSERT(0,"socket receive error!");
#ifdef _N3GAME
			int iErr = ::GetLastError();
			CLogWriter::Write("socket receive error! : {}", iErr);
			//TRACE("socket receive error! : %d\n", iErr);
#endif
			break;
		}
		if (count)
		{
			dwRead += count;
			m_CB.PutData(m_RecvBuf, count);
		}
	}

	// packet analysis.
	while(ReceiveProcess());
}

BOOL CAPISocket::ReceiveProcess()
{
	int iCount = m_CB.GetValidCount();
	BOOL bFoundTail = FALSE;
	if (iCount >=7 )
	{
		uint8_t *pData = new uint8_t[iCount];
		m_CB.GetData(pData, iCount);
		int head_inc_size = 0;

		if ( PACKET_HEADER == ntohs(*((uint16_t*)pData)) )
		{
			int16_t siCore = *((int16_t*)(pData+2));
			if ( siCore <= iCount )
			{
				if ( PACKET_TAIL == ntohs(*((uint16_t*)(pData+iCount-2))) ) // 패킷 꼬리 부분 검사..
				{
					Packet * pkt = new Packet();
					if (s_bCryptionFlag)
					{
						static uint8_t pTBuf[RECEIVE_BUF_SIZE];
						s_JvCrypt.JvDecryptionFast(siCore, pData + 4, pTBuf);

						uint16_t sig = *(uint16_t*)pTBuf;

						if (sig != 0x1EFC)
						{
							__ASSERT(0, "Crypt Error");
						}
						else
						{
							uint16_t sequence = *(uint16_t*)&pTBuf[2];
							uint8_t  empty = pTBuf[4];
							uint8_t* payload = &pTBuf[5];

							pkt->append(payload, siCore - 5);
						}
					}
					else
					{
						pkt->append(pData + 4, siCore);
					}

					m_qRecvPkt.push(pkt);
					m_CB.HeadIncrease(siCore + 6); // 환형 버퍼 인덱스 증가 시키기..
					bFoundTail = TRUE;
#ifdef _DEBUG
					uint8_t byCmd = pData[4];
					m_Statistics_Recv_Sum[byCmd].dwTime++;
					m_Statistics_Recv_Sum[byCmd].iSize += siCore;
#endif
				}
			}
		}
		else
		{
			// 패킷이 깨졌다??
			__ASSERT(0, "broken packet header.. skip!");
			m_CB.HeadIncrease(iCount); // 환형 버퍼 인덱스 증가 시키기..
		}

		delete[] pData, pData = nullptr;
	}

	return bFoundTail;
}

void CAPISocket::Send(uint8_t* pData, int nSize)
{
	if(!m_bEnableSend) return; // 보내기 가능..?
	if (INVALID_SOCKET == (SOCKET)m_hSocket || FALSE == m_bConnected)
		return;

#ifdef _CRYPTION
	DataPack DP;

	if (s_bCryptionFlag)
	{
		static uint8_t pTBuf[RECEIVE_BUF_SIZE];

		++s_wSendVal;

		memcpy(pTBuf, &s_wSendVal, sizeof(uint32_t));
		memcpy((pTBuf + 4), pData, nSize);

		*((uint32_t*)(pTBuf + (nSize + 4))) = crc32(pTBuf, (nSize + 4), -1);

		s_JvCrypt.JvEncryptionFast((nSize + 4 + 4), pTBuf, pTBuf);

		DP.m_Size = (nSize + 4 + 4);
		DP.m_pData = new uint8_t[DP.m_Size];
		memcpy(DP.m_pData, pTBuf, DP.m_Size);

		nSize = DP.m_Size;
		pData = DP.m_pData;
	}
#endif
	
	int nTotalSize = nSize+6;
	uint8_t *pSendData = m_RecvBuf;
	*((uint16_t*)pSendData) = htons(PACKET_HEADER);	pSendData+=2;
	*((uint16_t*)pSendData) = nSize;				pSendData+=2;
	memcpy(pSendData, pData, nSize);			pSendData += nSize;
	*((uint16_t*)pSendData) = htons(PACKET_TAIL);	pSendData+=2;

	int nSent = 0;
	int count = 0;
	while(nSent < nTotalSize)
	{
		count = send((SOCKET)m_hSocket, (char*)m_RecvBuf, nTotalSize, 0);
		if (count == SOCKET_ERROR)
		{
			__ASSERT(0,"socket send error!");
#ifdef _N3GAME
			int iErr = ::GetLastError();
			CLogWriter::Write("socket send error! : {}", iErr);
			//TRACE("socket send error! : %d\n", iErr);
			PostQuitMessage(-1);
#endif
			break;
		}
		if (count)
		{
			nSent += count;
		}
	}

#ifdef _DEBUG
	uint8_t byCmd = pData[0]; // 통계 넣기..

	m_Statistics_Send_Sum[byCmd].dwTime++;
	m_Statistics_Send_Sum[byCmd].iSize += nSize;
#endif

	m_iSendByteCount += nTotalSize;
}

// ===== END WarFare/APISocket.cpp =====

// ===== BEGIN WarFare/APISocket.h =====
#line 1 "WarFare/APISocket.h"
﻿// APISocket.h: interface for the CAPISocket class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_)
#define AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>
#include "GameDef.h"
#include "PacketDef.h"

#include <queue>
#include <string>

#define WM_SOCKETMSG	(WM_USER+1)
#define RECEIVE_BUF_SIZE	262144 // 최대 버퍼..

#define _CRYPTION		// 암호화 사용
#ifdef _CRYPTION
#include <shared/JvCryption.h>
#endif

class BB_CircularBuffer  
{
public:
	BB_CircularBuffer(int size=RECEIVE_BUF_SIZE)
	{
		__ASSERT(size>0, "1");
		m_iBufSize = size;
		m_pBuffer = new uint8_t[m_iBufSize];

		m_iHeadPos = 0;
		m_iTailPos = 0;
	}

	virtual ~BB_CircularBuffer()
	{
		__ASSERT(m_pBuffer,"1");
		if (m_pBuffer)
			delete[] m_pBuffer, m_pBuffer = nullptr;
	}

	void	PutData(uint8_t *pData, int len)
	{
		if (len<=0)
		{
	#ifdef _DEBUG
			//OutputDebugString("BB_CircularBuffer::PutData len is <= 0\n");
	#endif
			return;
		}
		while (IsOverFlowCondition(len)) BufferResize();
		if (IsIndexOverFlow(len))
		{
			int FirstCopyLen = m_iBufSize-m_iTailPos;
			int SecondCopyLen = len - FirstCopyLen;
			__ASSERT(FirstCopyLen, "1");
			CopyMemory(m_pBuffer+m_iTailPos, pData, FirstCopyLen);
			if (SecondCopyLen)
			{
				CopyMemory(m_pBuffer, pData+FirstCopyLen, SecondCopyLen);
				m_iTailPos = SecondCopyLen;
			}
			else m_iTailPos = 0;
		}
		else
		{
			CopyMemory(m_pBuffer+m_iTailPos, pData, len);
			m_iTailPos += len;
		}
	}
	void	GetData(uint8_t *pData, int len)
	{
		__ASSERT(len>0&&len<=GetValidCount(),"GetData error");
		if (len < m_iBufSize-m_iHeadPos)
			CopyMemory(pData, m_pBuffer+m_iHeadPos, len);
		else
		{
			int fc, sc;
			fc = m_iBufSize-m_iHeadPos;
			sc = len - fc;
			CopyMemory(pData, m_pBuffer+m_iHeadPos, fc);
			if (sc) CopyMemory(pData+fc, m_pBuffer, sc);
		}
	}
	int		GetOutData(uint8_t *pData) //HeadPos, 변화
	{
		int len = GetValidCount();
		int fc, sc;
		fc = m_iBufSize-m_iHeadPos;
		if (len>fc)
		{
			sc = len - fc;
			CopyMemory(pData, m_pBuffer+m_iHeadPos, fc);
			CopyMemory(pData+fc, m_pBuffer, sc);
			m_iHeadPos = sc;
			__ASSERT(m_iHeadPos==m_iTailPos, "1");
		}
		else
		{
			CopyMemory(pData, m_pBuffer+m_iHeadPos, len);
			m_iHeadPos += len;
			if (m_iHeadPos==m_iBufSize) m_iHeadPos = 0;
		}
		return len;
	}
	void	PutData(uint8_t& data)
	{
		int len = 1;
		while (IsOverFlowCondition(len)) BufferResize();
		m_pBuffer[m_iTailPos++] = data;
		if (m_iTailPos==m_iBufSize) m_iTailPos = 0;
	}
	uint8_t&	GetHeadData(){return m_pBuffer[m_iHeadPos];}
	//1 Byte Operation;
	//false : 모든데이터 다빠짐, TRUE: 정상적으로 진행중
	BOOL	HeadIncrease(int increasement=1)
	{
		__ASSERT(increasement<=GetValidCount(),"1");
		m_iHeadPos += increasement;
		m_iHeadPos %= m_iBufSize;
		return m_iHeadPos!=m_iTailPos;
	}
	void	SetEmpty() {m_iHeadPos=0; m_iTailPos=0;}

	int&	GetBufferSize() {return m_iBufSize;}
	int&	GetHeadPos() {return m_iHeadPos;}
	int&	GetTailPos() {return m_iTailPos;}
	int		GetValidCount()
	{
		int count = m_iTailPos-m_iHeadPos;
		if (count<0) count = m_iBufSize+count;
		return count;
	}
protected:
	//over flow 먼저 점검한 후 IndexOverFlow 점검
	BOOL	IsOverFlowCondition(int &len) {return (len >= m_iBufSize-GetValidCount()) ? TRUE: FALSE;}
	BOOL	IsIndexOverFlow(int &len) {return (len+m_iTailPos>=m_iBufSize) ? TRUE:FALSE;}
	void	BufferResize() //overflow condition 일때 size를 현재의 두배로 늘림
	{
		int prevBufSize = m_iBufSize;
		m_iBufSize <<= 1;
		uint8_t *pNewData = new uint8_t[m_iBufSize];
		CopyMemory(pNewData, m_pBuffer, prevBufSize);
		if (m_iTailPos<m_iHeadPos) 
		{
			CopyMemory(pNewData+prevBufSize, m_pBuffer, m_iTailPos);
			m_iTailPos += prevBufSize;
		}
		delete [] m_pBuffer;
		m_pBuffer = pNewData;
	}
protected:
	int		m_iBufSize;
	uint8_t	*m_pBuffer;

	int		m_iHeadPos;
	int		m_iTailPos;
};

class DataPack
{
public:
	int		m_Size;
	uint8_t*	m_pData;

public:
	DataPack()
	{
		m_Size = 0;
		m_pData = nullptr;
	}

	DataPack(int size, uint8_t *pData)
	{
		__ASSERT(size, "size is 0");		
		m_Size = size;
		m_pData = new uint8_t[size];
		memcpy(m_pData, pData, size);
	}

	virtual ~DataPack()
	{
		delete[] m_pData;
	}
};

#ifdef _DEBUG
struct __SocketStatisics
{
	uint32_t dwTime;
	int iSize;
};
#include <vector>
#include <string>
#endif

class CAPISocket  
{
protected:
	void *	m_hSocket;
	
	HWND		m_hWndTarget;
	std::string m_szIP;
	uint32_t		m_dwPort;

	uint8_t	m_RecvBuf[RECEIVE_BUF_SIZE];
	BOOL	m_bConnected;

	BB_CircularBuffer	m_CB;

#ifdef _DEBUG
	__SocketStatisics m_Statistics_Send_Sum[256];
	__SocketStatisics m_Statistics_Recv_Sum[256];
#endif

public:
	static int			s_nInstanceCount;
	
	int					m_iSendByteCount;
	std::queue<Packet *> m_qRecvPkt;

	BOOL	m_bEnableSend; // 보내기 가능..?
public:
	int		Connect(HWND hWnd, const char* pszIP, uint32_t port);
	void	Disconnect();
	BOOL	IsConnected() { return m_bConnected; }
	int		ReConnect();

	std::string GetCurrentIP() { return m_szIP; }
	uint32_t		GetCurrentPort() { return m_dwPort; }

	void	Release();	
	void	Receive();
	BOOL	ReceiveProcess();
	void	Send(uint8_t* pData, int nSize);

#ifdef _CRYPTION
protected:
	static BOOL			s_bCryptionFlag;			//0 : 비암호화 , 1 : 암호화
	static CJvCryption	s_JvCrypt;
	static uint32_t		s_wSendVal;
	static uint32_t		s_wRcvVal;
public:
	static void			InitCrypt(int64_t PublicKey)
	{
		s_JvCrypt.SetPublicKey(PublicKey);
		s_JvCrypt.Init();

		s_wSendVal = 0;
		s_wRcvVal = 0;
		if (0 != PublicKey) s_bCryptionFlag = TRUE;
		else s_bCryptionFlag = FALSE;
	}
#endif

	//패킷 만들기 함수
	static void MP_AddByte(uint8_t* dest, int& iOffset, uint8_t byte)
	{
		memcpy(dest + iOffset, &byte, 1);
		++iOffset;
	}

	static void MP_AddShort(uint8_t* dest, int& iOffset, int16_t value)
	{
		memcpy(dest + iOffset, &value, 2);
		iOffset += 2;
	}

	static void MP_AddWord(uint8_t* dest, int& offset, uint16_t value)
	{
		memcpy(dest + offset, &value, 2);
		offset += 2;
	}

	static void MP_AddDword(uint8_t* dest, int& iOffset, uint32_t dword)
	{
		memcpy(dest + iOffset, &dword, 4);
		iOffset += 4;
	}

	static void MP_AddFloat(uint8_t* dest, int& iOffset, float value)
	{
		memcpy(dest + iOffset, &value, 4);
		iOffset += 4;
	}

	static void MP_AddString(uint8_t* dest, int& iOffset, const std::string& szString)
	{
		if (szString.empty())
			return;

		memcpy(dest + iOffset, &szString[0], szString.size());
		iOffset += static_cast<int>(szString.size());
	}

	CAPISocket();
	virtual ~CAPISocket();
};

#endif // !defined(AFX_APISOCKET_H__31D58152_3B8D_4CBD_BEB9_6BE23C4F0FFB__INCLUDED_)

// ===== END WarFare/APISocket.h =====

// ===== BEGIN WarFare/Bird.cpp =====
#line 1 "WarFare/Bird.cpp"
﻿// Bird.cpp: implementation of the CBird class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Bird.h"
#include <N3Base/N3Shape.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// TESTING !@#$%@#$@#$

CBird::CBird()
{
	m_pSnd = nullptr;
	m_pShape = nullptr;

	Release();	
}

CBird::~CBird()
{
	Release();
}

void CBird::Release()
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd);
	if (m_pShape) {delete m_pShape; m_pShape = nullptr;}
	m_vPivot.Set(0,0,0);
	m_fRadius = 0.0f;
	m_fRadian = 0.0f;

	m_fFactor1 = m_fFactor2 = 0;
	m_fFactorSpeed1 = m_fFactorSpeed2 = 0;

	m_fRadiusY = m_fFactorY1 = m_fFactorY2 = 0;
	m_fFactorYSpeed1 = m_fFactorYSpeed2 = 0;
}

void CBird::Tick()
{
	if (m_pShape == nullptr) return;

	m_fRadian += (m_fRadianSpeed*s_fSecPerFrm);

	if (m_fRadian > 2*__PI) m_fRadian -= (2*__PI);
	
	m_fFactor1 += (m_fFactorSpeed1*s_fSecPerFrm);
	if (m_fFactor1 > 2*__PI) m_fFactor1 -= (2*__PI);
	
	m_fFactor2 += (m_fFactorSpeed2*s_fSecPerFrm);
	if (m_fFactor2 > 2*__PI) m_fFactor2 -= (2*__PI);

	m_fFactorY1 += (m_fFactorYSpeed1*s_fSecPerFrm);
	if (m_fFactorY1 > 2*__PI) m_fFactorY1 -= (2*__PI);
	
	m_fFactorY2 += (m_fFactorYSpeed2*s_fSecPerFrm);
	if (m_fFactorY2 > 2*__PI) m_fFactorY2 -= (2*__PI);

	// 위치계산
	__Vector3 vPos;
	 vPos.Set(	sinf(m_fFactor1)*m_fRadius*cosf(m_fRadian),
				m_fRadiusY*(sinf(m_fFactorY1)+cosf(m_fFactorY2))/2.0f,
				sinf(m_fFactor2)*m_fRadius*sinf(m_fRadian));

	 // 각도 계산
	 // 미분식을 이용하여 기울기 구하기
	float x = (m_fFactorSpeed1*cosf(m_fFactor1)*cosf(m_fRadian) - 
		 m_fRadianSpeed*sinf(m_fFactor1)*sinf(m_fRadian));
	float z = (m_fFactorSpeed2*cosf(m_fFactor2)*sinf(m_fRadian) + 
		 m_fRadianSpeed*sinf(m_fFactor2)*cosf(m_fRadian));
	float fRotY = atan2f(z, x)-(__PI/2);

	__Vector3 vAxis(0, 1, 0);	 
	__Quaternion qt;
	qt.RotationAxis(vAxis, -fRotY);

	__Vector3 vNewPos = m_vPivot+vPos;
	 
	m_pShape->RotSet(qt);
	m_pShape->PosSet(vNewPos);
	m_pShape->Tick(-1);

	m_fSndInterval += s_fSecPerFrm;

	if(m_pSnd && m_fSndInterval > 30.0f)
	{
		m_fSndInterval = (float)(-(rand()%20));
		m_pSnd->Play(&vNewPos);
	}
}

void CBird::Render()
{
	if (m_pShape == nullptr) return;
	m_pShape->Render();
}

int CBird::LoadBird(const std::string& szFN)
{
	Release();
	FILE* stream = fopen(szFN.c_str(), "r"); //text파일로 만든다 
	if(nullptr == stream)
	{
#if _DEBUG
		std::string szErr = fmt::format("failed to open file - {}", szFN);
		__ASSERT(stream, szErr.c_str());
#endif
		return false;
	}

	char szRrcName[_MAX_PATH];
	float	fSpeed = 0.0f;
	int result = fscanf(stream, "ResourceName = %s\n", szRrcName);			__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");
	result = fscanf(stream, "Pivot = %f %f %f\n", &(m_vPivot.x), &(m_vPivot.y), &(m_vPivot.z));	__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");
	result = fscanf(stream, "Radius = %f\n", &m_fRadius);					__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");
	result = fscanf(stream, "RadiusY = %f\n", &m_fRadiusY);					__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");
	result = fscanf(stream, "Speed = %f\n", &fSpeed);						__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");

	fclose(stream);

	__ASSERT(m_pShape == nullptr, "Bird memory leak 가능성");
	m_pShape = new CN3Shape;
	m_pShape->LoadFromFile(szRrcName);

	m_fRadianSpeed = fSpeed/m_fRadius;

	m_fFactorSpeed1 = 0.1f + ((rand()%2000)/10000.0f);
	m_fFactorSpeed2 = 0.02f + ((rand()%4000)/100000.0f);

	m_fFactorYSpeed1 = 0.35f + ((rand()%3000)/10000.0f);
	m_fFactorYSpeed2 = 0.18f + ((rand()%3500)/10000.0f);

	if(nullptr == m_pSnd) m_pSnd = CN3Base::s_SndMgr.CreateObj(1000);
	m_fSndInterval = 0.0f;

	return true;
}

// ===== END WarFare/Bird.cpp =====

// ===== BEGIN WarFare/Bird.h =====
#line 1 "WarFare/Bird.h"
﻿// Bird.h: interface for the CBird class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BIRD_H__409CEF6D_6577_4CFB_90C9_6A8AA710D298__INCLUDED_)
#define AFX_BIRD_H__409CEF6D_6577_4CFB_90C9_6A8AA710D298__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>

class CN3Shape;
class CN3SndObj;

class CBird : public CN3Base  
{
public:
	CBird();
	virtual ~CBird();

// Attributes
public:
protected:
	// 파일에서 읽어오는 정보
	CN3Shape*	m_pShape;		// Shape pointer
	__Vector3	m_vPivot;		// 중심점(중심점에서 반경 m_fRadius만큼 범위내에서 움직인다.
	float		m_fRadius;		// 반경

//	__Vector3	m_vVelocity;	// 현재 속도(스피드+방향)
	float		m_fRadianSpeed;		// 속력
	float		m_fRadian;		// 현재 타원의 위치각
	float		m_fFactor1,	m_fFactor2;
	float		m_fFactorSpeed1,	m_fFactorSpeed2;

	float		m_fRadiusY;		// 높이 반경
	float		m_fFactorY1, m_fFactorY2;	// 높이 변화 요소
	float		m_fFactorYSpeed1, m_fFactorYSpeed2;	// 높이 변화 요소 변화율..

	CN3SndObj*	m_pSnd;
	float		m_fSndInterval;

// Operations
public:
	virtual void Release();
	void	Tick();
	void	Render();

	int		LoadBird(const std::string& szFN);
protected:

};

#endif // !defined(AFX_BIRD_H__409CEF6D_6577_4CFB_90C9_6A8AA710D298__INCLUDED_)

// ===== END WarFare/Bird.h =====

// ===== BEGIN WarFare/BirdMng.cpp =====
#line 1 "WarFare/BirdMng.cpp"
﻿// BirdMng.cpp: implementation of the CBirdMng class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BirdMng.h"
#include "Bird.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBirdMng::CBirdMng()
{
	m_pBird = nullptr;
	Release();
}

CBirdMng::~CBirdMng()
{
	Release();
}

void CBirdMng::Release()
{
	if(m_pBird)
	{
		delete[] m_pBird;
		m_pBird = nullptr;
	}
	m_iBirdCount = 0;
}

void CBirdMng::LoadFromFile(const std::string& szFN)
{
	Release();

	if(szFN.empty()) return;
	FILE* stream = fopen(szFN.c_str(), "r"); //text파일로 만든다 
	if (stream == nullptr)
		return;

	int i;
	char szRrcName[_MAX_PATH];
	int result = fscanf(stream, "count = %d\n", &m_iBirdCount);			__ASSERT(result != EOF, "잘못된 Machine 세팅 파일");

	if(m_iBirdCount>0) m_pBird = new CBird[m_iBirdCount];

	for (i=0; i<m_iBirdCount; i++)
	{
		result = fscanf(stream, "%s\n", szRrcName);	__ASSERT(result != EOF, "잘못된 bird list 세팅 파일");
		m_pBird[i].LoadBird(szRrcName);		
	}
	fclose(stream);
}

void CBirdMng::Tick()
{
	for(int i=0; i<m_iBirdCount; i++)
	{
		m_pBird[i].Tick();
	}
}

void CBirdMng::Render()
{
	for(int i=0; i<m_iBirdCount; i++)
	{
		m_pBird[i].Render();
	}
}

// ===== END WarFare/BirdMng.cpp =====

// ===== BEGIN WarFare/BirdMng.h =====
#line 1 "WarFare/BirdMng.h"
﻿// BirdMng.h: interface for the CBirdMng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BIRDMNG_H__5307F307_1E9C_469B_BD46_52A408740383__INCLUDED_)
#define AFX_BIRDMNG_H__5307F307_1E9C_469B_BD46_52A408740383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>

typedef struct __TABLE_BIRD
{
	uint32_t dwID; // zone ID
	char* pszTerrainFN; // Terrain FileName - Terrain, Tile Map, ColorMap....
	char* pszColorMapFN;
	char* pszObjectPostDataFN; // Object 위치 정보 - 이안에 충돌 체크 데이터도 들어 있다.
} TABLE_BIRD;


class CBird;

class CBirdMng : public CN3Base  
{
public:
	CBirdMng();
	virtual ~CBirdMng();

// Attributes
protected:
	CBird*			m_pBird;
	int				m_iBirdCount;

// Operations
public:
	virtual void	Release();
	void			Tick();
	void			Render();
	void			LoadFromFile(const std::string& szFN);
protected:

};

#endif // !defined(AFX_BIRDMNG_H__5307F307_1E9C_469B_BD46_52A408740383__INCLUDED_)

// ===== END WarFare/BirdMng.h =====

// ===== BEGIN WarFare/Bitset.h =====
#line 1 "WarFare/Bitset.h"
﻿#if !defined(AFX_Bitset_h__INCLUDED_)
#define AFX_Bitset_h__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning(disable : 4786)

class CBitset 
{

public:

	// Initialize all the data members
    CBitset() : m_bits(0), m_size(0) {}

	// This is our deconstructor
	~CBitset() 
	{
		// If we have valid memory, get rid of it
		if(m_bits) 
		{
			delete m_bits;
			m_bits = nullptr;
		}
	}

	// This resizes our bitset to a size so each face has a bit associated with it
	void Resize(int count) 
	{ 
		// Get the size of integers we need
		m_size = count/32 + 1;

		// Make sure we haven't already allocated memory for the bits
        if(m_bits) 
		{
			delete m_bits;
			m_bits = 0;
		}

		// Allocate the bits and initialize them
		m_bits = new uint32_t[m_size];
		ClearAll();
	}

	// This does the binary math to set the desired bit
	void Set(int i) 
	{
		m_bits[i >> 5] |= (1 << (i & 31));
	}

	// This returns if the desired bit slot is a 1 or a 0
	int On(int i) 
	{
		return m_bits[i >> 5] & (1 << (i & 31 ));
	}

	// This clears a bit to 0
	void Clear(int i) 
	{
		m_bits[i >> 5] &= ~(1 << (i & 31));
	}

	// This initializes the bits to 0
	void ClearAll() 
	{
		memset(m_bits, 0, sizeof(uint32_t) * m_size);
	}

private:

	// Our private bit data that holds the bits and size
	uint32_t *m_bits;
	int m_size;
};

#endif // !defined(AFX_Bitset_h__INCLUDED_)
// ===== END WarFare/Bitset.h =====

// ===== BEGIN WarFare/ClientResourceFormatter.cpp =====
#line 1 "WarFare/ClientResourceFormatter.cpp"
﻿#include "StdAfx.h"
#include "ClientResourceFormatter.h"
#include "GameBase.h"

bool fmt::resource_helper::get_from_texts(uint32_t resourceId, std::string& fmtStr)
{
	__TABLE_TEXTS* text = CGameBase::s_pTbl_Texts.Find(resourceId);
	if (text == nullptr)
	{
#if defined(_N3GAME)
		CLogWriter::Write("get_from_texts({}) failed - resource missing in Texts TBL.",
			resourceId);
#endif

		return false;
	}

	fmtStr = text->szText;
	return true;
}

// ===== END WarFare/ClientResourceFormatter.cpp =====

// ===== BEGIN WarFare/ClientResourceFormatter.h =====
#line 1 "WarFare/ClientResourceFormatter.h"
﻿#pragma once

// TODO: Replace CLogWriter's implementation
// #include <spdlog/spdlog.h>
#include <N3Base/LogWriter.h>

#include <spdlog/fmt/bundled/format.h>
#include <spdlog/fmt/bundled/printf.h>

#include <cassert>
#include <string>
#include <string_view>

namespace fmt
{
	namespace resource_helper
	{
		bool get_from_texts(uint32_t resourceId, std::string& fmtStr);
	}

	template <typename... Args>
	inline std::string format_text_resource(uint32_t resourceId, Args&&... args)
	{
		std::string fmtStr;

		// NOTE: Let the implementation error accordingly
		if (!resource_helper::get_from_texts(resourceId, fmtStr))
			return {};

		if constexpr (sizeof...(Args) == 0)
		{
			return fmtStr;
		}
		else
		{
			try
			{
				return fmt::sprintf(fmtStr, std::forward<Args>(args)...);
			}
			catch (const fmt::format_error&)
			{
				assert(!"format_text_resource(): Invalid format string");

#if defined(_N3GAME)
				CLogWriter::Write("format_text_resource({}) failed - invalid args for format string.",
					resourceId);
#endif
			}

			return {};
		}
	}

	inline std::string format_text_resource(uint32_t resourceId, const std::string_view str)
	{
		return format_text_resource(resourceId, str);
	}
}

// ===== END WarFare/ClientResourceFormatter.h =====

// ===== BEGIN WarFare/CountableItemEditDlg.cpp =====
#line 1 "WarFare/CountableItemEditDlg.cpp"
﻿// CountableItemEditDlg.cpp: implementation of the CCountableItemEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "CountableItemEditDlg.h"

#include "GameProcedure.h"
#include "GameProcMain.h"
#include "UIInventory.h"
#include "UITransactionDlg.h"

#include "SubProcPerTrade.h"
#include "UIPerTradeDlg.h"
#include "UIWareHouseDlg.h"
#include "UIManager.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCountableItemEditDlg::CCountableItemEditDlg()
{
	m_eCallerWnd = UIWND_UNKNOWN;
	m_eCallerWndDistrict = UIWND_DISTRICT_UNKNOWN;
	m_pArea = nullptr;
	m_pImageOfIcon = nullptr;
	m_bLocked = false;
	m_pEdit	= nullptr;
	m_bWareGold = false;

	m_pBtnOk	 = nullptr;
	m_pBtnCancel = nullptr;
}

CCountableItemEditDlg::~CCountableItemEditDlg()
{

}

void CCountableItemEditDlg::Release()
{
	CN3UIBase::Release();

}

bool CCountableItemEditDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;
	if(IsVisible() == false) return false;
	if(m_eCallerWnd == UIWND_UNKNOWN) return false;
	if(m_eCallerWndDistrict == UIWND_DISTRICT_UNKNOWN) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtnOk)
		{
			switch (m_eCallerWnd)
			{
				case UIWND_TRANSACTION:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_TRADE_NPC:
						case UIWND_DISTRICT_TRADE_MY:
							CGameProcedure::s_pProcMain->m_pUITransactionDlg->ItemCountOK();
							break;
					}
					break;

				case UIWND_PER_TRADE:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_PER_TRADE_MY:
							CGameProcedure::s_pProcMain->m_pSubProcPerTrade->ItemCountOK();
							break;
					}
					break;
				case UIWND_WARE_HOUSE:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_TRADE_NPC:
							if (!m_bWareGold)
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->ItemCountOK();
							else
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->GoldCountFromWareOK();
							break;
						case UIWND_DISTRICT_TRADE_MY:
							if (!m_bWareGold)
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->ItemCountOK();
							else
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->GoldCountToWareOK();
							break;
					}
					break;
			}
		}

		if(pSender == m_pBtnCancel)
		{
			switch (m_eCallerWnd)
			{
				case UIWND_TRANSACTION:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_TRADE_NPC:
						case UIWND_DISTRICT_TRADE_MY:
							CGameProcedure::s_pProcMain->m_pUITransactionDlg->ItemCountCancel();
							break;
					}
					break;

				case UIWND_PER_TRADE:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_PER_TRADE_MY:
							CGameProcedure::s_pProcMain->m_pSubProcPerTrade->ItemCountCancel();
							break;
					}
					break;
				case UIWND_WARE_HOUSE:
					switch (m_eCallerWndDistrict)
					{
						case UIWND_DISTRICT_TRADE_NPC:
							if (!m_bWareGold)
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->ItemCountCancel();
							else
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->GoldCountFromWareCancel();
							break;
						case UIWND_DISTRICT_TRADE_MY:
							if (!m_bWareGold)
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->ItemCountCancel();
							else
								CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->GoldCountToWareCancel();
							break;
					}
					break;
			}
		}
	}

	return true;
}

void CCountableItemEditDlg::Open(e_UIWND eUW, e_UIWND_DISTRICT eUD, bool bCountGold, bool bWareGold)
{
	std::string szMsg;
	if (bCountGold)
		szMsg = fmt::format_text_resource(IDS_EDIT_BOX_GOLD);
	else
		szMsg = fmt::format_text_resource(IDS_EDIT_BOX_COUNT);

	CN3UIString* pString = nullptr;
	N3_VERIFY_UI_COMPONENT(pString, GetChildByID<CN3UIString>("String_PersonTradeEdit_Msg"));
	if (pString != nullptr)
		pString->SetString(szMsg);

	RECT rc, rcThis;
	int iCX, iCY;

	m_bLocked = true;
	this->SetQuantity(-1);

	SetVisible(true);

	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));
	if (pEdit != nullptr)
		pEdit->SetFocus();

	m_eCallerWnd = eUW;
	m_eCallerWndDistrict = eUD;
	m_bWareGold = bWareGold;

	switch (eUW)
	{
		case UIWND_TRANSACTION:
			rc = CGameProcedure::s_pProcMain->m_pUITransactionDlg->GetRegion();
			break;

		case UIWND_PER_TRADE:
			rc = CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_pUIPerTradeDlg->GetRegion();
			break;

		case UIWND_WARE_HOUSE:
			rc = CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->GetRegion();
			break;
	}

	if ( (eUW == UIWND_TRANSACTION) || (eUW == UIWND_PER_TRADE) || (eUW == UIWND_WARE_HOUSE) )
	{
		iCX = (rc.right+rc.left)/2;
		iCY = (rc.bottom+rc.top)/2;
		rcThis = GetRegion();
		SetPos(iCX-(rcThis.right-rcThis.left)/2, iCY-(rcThis.bottom-rcThis.top)/2);
	}
}

void CCountableItemEditDlg::Close()
{
	m_bLocked = false;
//	SetVisible(false);	//이거 쓰지 말고 SetVisibleWithNoSound 함수 써주세요...
	SetVisibleWithNoSound(false);

	CN3UIEdit* pEdit = GetFocusedEdit();
	if (pEdit) pEdit->KillFocus();
}

int	CCountableItemEditDlg::GetQuantity() // "edit_trade" Edit Control 에서 정수값을 얻오온다..
{
	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));

	return atoi(pEdit->GetString().c_str());
}

void CCountableItemEditDlg::SetQuantity(int iQuantity) // "edit_trade" Edit Control 에서 정수값을 문자열로 세팅한다..
{
	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));

	std::string buff;
	if (iQuantity != -1)
		buff = std::to_string(iQuantity);

	pEdit->SetString(buff);
}

//this_ui_add_start
void CCountableItemEditDlg::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CCountableItemEditDlg::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	if(bWork)
	{//여기서는 ReceiveMessage에서 유아이가 보이는지를 체크를 해서 일단 앞쪽에 둔다.
		ReceiveMessage(m_pBtnCancel, UIMSG_BUTTON_CLICK);
	}
	
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);
}

bool CCountableItemEditDlg::Load(File& file)
{
	if(false == CN3UIBase::Load(file)) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtnOk,		GetChildByID<CN3UIButton>("btn_ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtnCancel,	GetChildByID<CN3UIButton>("btn_cancel"));

	return true;
}

bool CCountableItemEditDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_RETURN:
		ReceiveMessage(m_pBtnOk, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtnCancel, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/CountableItemEditDlg.cpp =====

// ===== BEGIN WarFare/CountableItemEditDlg.h =====
#line 1 "WarFare/CountableItemEditDlg.h"
﻿// CountableItemEditDlg.h: interface for the CCountableItemEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COUNTABLEITEMEDITDLG_H__55E83755_6471_4A3D_84D7_857B0FF88833__INCLUDED_)
#define AFX_COUNTABLEITEMEDITDLG_H__55E83755_6471_4A3D_84D7_857B0FF88833__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3UIWndBase.h"

//////////////////////////////////////////////////////////////////////

class CCountableItemEditDlg : public CN3UIBase
{
	bool				m_bLocked;
	e_UIWND				m_eCallerWnd;
	e_UIWND_DISTRICT	m_eCallerWndDistrict;
	bool				m_bWareGold;

public:
	CN3UIArea*			m_pArea;
	CN3UIImage*			m_pImageOfIcon;
	CN3UIEdit*			m_pEdit;

	CN3UIButton*		m_pBtnOk;
	CN3UIButton*		m_pBtnCancel;

public:
	bool OnKeyPress(int iKey) override;
	bool Load(File& file) override;
	void				SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	void				SetVisible(bool bVisible) override;
	int					GetQuantity(); // "edit_trade" Edit Control 에서 정수값을 얻오온다..
	void				SetQuantity(int iQuantity); // "edit_trade" Edit Control 에서 정수값을 문자열로 세팅한다..

	CCountableItemEditDlg();
	virtual ~CCountableItemEditDlg();

	void		Release() override;
	bool		ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	virtual void		Open(e_UIWND eUW, e_UIWND_DISTRICT eUD, bool bCountGold, bool bWareGold = false);
	virtual void		Close();

	bool				IsLocked()	{	return m_bLocked;	}

	e_UIWND				GetCallerWnd()	{	return m_eCallerWnd;	}
	e_UIWND_DISTRICT	GetCallerWndDistrict()	{	return m_eCallerWndDistrict;	}
};

#endif // !defined(AFX_COUNTABLEITEMEDITDLG_H__55E83755_6471_4A3D_84D7_857B0FF88833__INCLUDED_)

// ===== END WarFare/CountableItemEditDlg.h =====

// ===== BEGIN WarFare/DungeonManager.cpp =====
#line 1 "WarFare/DungeonManager.cpp"
﻿// DungeonManager.cpp: implementation of the CDungeonManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DungeonManager.h"

#include "PlayerMySelf.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDungeonManager::CDungeonManager()
{

}

CDungeonManager::~CDungeonManager()
{

}

//////////////////////////////////////////////////////////////////////

void CDungeonManager::InitWorld(int iZoneID, const __Vector3& vPosPlayer)
{
	__TABLE_ZONE* pZone = s_pTbl_Zones.Find(s_pPlayer->m_InfoExt.iZoneCur);
	if(nullptr == pZone) { CLogWriter::Write("Null Zone data : {}", iZoneID); return; }
		
	m_pvsmgr.LoadFromFile(pZone->szTerrainFN);
}

void CDungeonManager::Tick()
{
	m_pvsmgr.Tick();
}

void CDungeonManager::RenderTerrain()
{
	m_pvsmgr.Render();
}

void CDungeonManager::RenderShape()
{
}

CN3Terrain* CDungeonManager::GetTerrainRef()
{
	return nullptr;
}

CN3SkyMng* CDungeonManager::GetSkyRef()
{
	return nullptr;
}

//////////////////////////////////////////////////////////////////////

// Terrain..
bool CDungeonManager::CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)	// Done..
{
	return m_pvsmgr.CheckCollisionCameraWithTerrain(vEyeResult, vAt, fNP);						
}

float CDungeonManager::GetHeightWithTerrain(float x, float z, bool bWarp)																	// Done..
{
	return m_pvsmgr.GetHeightWithTerrain(x, z, bWarp);																		
}

BOOL CDungeonManager::PickWideWithTerrain(int x, int y, __Vector3& vPick)																// Done..
{
	return m_pvsmgr.PickWideWithTerrain(x, y, vPick);
}

bool CDungeonManager::CheckCollisionWithTerrain(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol)
{
	return false;	
}

void CDungeonManager::GetNormalWithTerrain(float x, float z, __Vector3& vNormal)
{
}

float CDungeonManager::GetWidthByMeterWithTerrain()
{
	return 100.0f;
}

bool CDungeonManager::IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore)												// Done..
{
	return m_pvsmgr.IsInTerrainWithTerrain(x, z, vPosBefore);
}

bool CDungeonManager::CheckInclineWithTerrain(const __Vector3& vPos, const __Vector3& vDir, float fIncline)
{
	return false;
}

// Shapes..
bool CDungeonManager::CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)	  // Done..
{
	return m_pvsmgr.CheckCollisionCameraWithShape(vEyeResult, vAt, fNP);						
}

float CDungeonManager::GetHeightNearstPosWithShape(const __Vector3 &vPos, float fDist, __Vector3* pvNormal)		// Done..
{
	return m_pvsmgr.GetHeightNearstPosWithShape(vPos, fDist, pvNormal);							
}


void CDungeonManager::RenderCollisionWithShape(const __Vector3& vPos)																			// No need..
{
}


float CDungeonManager::GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal)
{
	return m_pvsmgr.GetHeightWithShape(fX, fZ, pvNormal);
}

bool CDungeonManager::CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
														const __Vector3& vDir,				   // 방향 벡터
														float fSpeedPerSec,					    // 초당 움직이는 속도
														__Vector3* pvCol,						 // 충돌 지점
														__Vector3* pvNormal,				  // 충돌한면의 법선벡터
														__Vector3* pVec)						// 충돌한 면 의 폴리곤 __Vector3[3]
{
	return m_pvsmgr.CheckCollisionWithShape(vPos, vDir, fSpeedPerSec, pvCol, pvNormal, pVec);
}

CN3Shape* CDungeonManager::ShapeGetByIDWithShape(int iID)
{
	return m_pvsmgr.ShapeGetByIDWithShape(iID);
}

CN3Shape* CDungeonManager::PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick)
{
	return m_pvsmgr.PickWithShape(iXScreen, iYScreen, bMustHaveEvent, pvPick);
}




// ===== END WarFare/DungeonManager.cpp =====

// ===== BEGIN WarFare/DungeonManager.h =====
#line 1 "WarFare/DungeonManager.h"
﻿// DungeonManager.h: interface for the CDungeonManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DUNGEONMANAGER_H__492B3E57_9A05_4F4D_B98C_63CB6ACC572E__INCLUDED_)
#define AFX_DUNGEONMANAGER_H__492B3E57_9A05_4F4D_B98C_63CB6ACC572E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3WorldBase.h"
#include "PvsMgr.h"

class CDungeonManager : public CN3WorldBase
{
	friend class CN3WorldManager;

	//..
	CPvsMgr	m_pvsmgr;

	// Function..
	void InitWorld(int iZoneID, const __Vector3& vPosPlayer);
	void Tick();

//////////////////////////////////////////////////////////////////////

	CN3Terrain* GetTerrainRef();
	CN3SkyMng* GetSkyRef();

	// Terrain..
	bool CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	float GetHeightWithTerrain(float x, float z, bool bWarp = false);
	BOOL PickWideWithTerrain(int x, int y, __Vector3& vPick);
	bool CheckCollisionWithTerrain(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol);
	void GetNormalWithTerrain(float x, float z, __Vector3& vNormal);
	float GetWidthByMeterWithTerrain(); 
	bool IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore = __Vector3());
	bool CheckInclineWithTerrain(const __Vector3& vPos, const __Vector3& vDir, float fIncline);

	// Shapes..
	bool CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	float GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr); 
	void RenderCollisionWithShape(const __Vector3& vPos);
	float GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal = nullptr); 
	CN3Shape* ShapeGetByIDWithShape(int iID);
	CN3Shape* PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr);
	bool CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
														const __Vector3& vDir,				   // 방향 벡터
														float fSpeedPerSec,					    // 초당 움직이는 속도
														__Vector3* pvCol = nullptr,			 // 충돌 지점
														__Vector3* pvNormal = nullptr,		 // 충돌한면의 법선벡터
														__Vector3* pVec = nullptr);			// 충돌한 면 의 폴리곤 __Vector3[3]

	// Rendering..
	void RenderTerrain();
	void RenderShape();	

public:
	CDungeonManager();
	virtual ~CDungeonManager();

};

#endif // !defined(AFX_DUNGEONMANAGER_H__492B3E57_9A05_4F4D_B98C_63CB6ACC572E__INCLUDED_)

// ===== END WarFare/DungeonManager.h =====

// ===== BEGIN WarFare/EventManager.cpp =====
#line 1 "WarFare/EventManager.cpp"
﻿// EventManager.cpp: implementation of the CEventManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EventManager.h"
#include "GameProcedure.h"
#include "PlayerMySelf.h"
#include "N3FXMgr.h"

#include <FileIO/FileReader.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

#define EVENT_TYPE_POISON	3

CEventCell::CEventCell()
{
	m_sEventType = 1;
	memset(&m_Rect, 0, sizeof(RECT));
}

CEventCell::~CEventCell()
{
}

void CEventCell::Load(File& file)
{
	file.Read(&m_Rect, sizeof(RECT));
	file.Read(&m_sEventType, sizeof(int16_t));
}

CEventManager::CEventManager()
{
	Release();
}

CEventManager::~CEventManager()
{
	Release();
}


bool CEventManager::LoadFromFile(const char* szFileName)
{
	Release();

	FileReader gevFile;
	if (!gevFile.OpenExisting(szFileName))
		return false;

	int nEventCellCount = 0;
	gevFile.Read(&nEventCellCount, sizeof(int));

	for(int i = 0; i < nEventCellCount; i++)
	{
		CEventCell* pEventCell = new CEventCell();
		pEventCell->Load(gevFile);
		m_lstEvents.push_back(pEventCell);
	}

	return true;
}

void CEventManager::Release()
{
	m_sEventType = -1;
	memset(&m_rcEvent, 0, sizeof(RECT));

	for (CEventCell* pEventCell : m_lstEvents)
		delete pEventCell;
	m_lstEvents.clear();
}

int16_t CEventManager::SetPos(float fX, float fZ)
{
	int x = (int) fX;
	int y = (int) fZ;

	if (PtInRect(x, y, m_rcEvent))
		return m_sEventType;

	for (CEventCell* pEventCell : m_lstEvents)
	{
		if (pEventCell == nullptr)
			continue;

		if (!PtInRect(x, y, pEventCell->m_Rect))
			continue;

		if (m_sEventType != pEventCell->m_sEventType)
			Behavior(pEventCell->m_sEventType, m_sEventType);

		m_rcEvent = pEventCell->m_Rect;
		m_sEventType = pEventCell->m_sEventType;
		return pEventCell->m_sEventType;
	}

	if (m_sEventType != -1)
	{
		Behavior(-1, m_sEventType);
		m_sEventType = -1;
		memset(&m_rcEvent, 0, sizeof(RECT));
	}

	return m_sEventType;
}

bool CEventManager::PtInRect(int x, int z, RECT rc)
{
	if (x < rc.left)	return false;
	if (x > rc.right)	return false;
	if (z < rc.top)		return false;
	if (z > rc.bottom)	return false;

	return true;
}

void CEventManager::Behavior(int16_t sEventType, int16_t sPreEventType)
{
	switch (sPreEventType)
	{
		case EVENT_TYPE_POISON:
		{
			int iID = CGameBase::s_pPlayer->IDNumber();
			int iFX = FXID_REGION_POISON;
			CGameProcedure::s_pFX->Stop(iID, iID, iFX, -1, true);
		}
		break;
	}

	switch (sEventType)
	{
		case EVENT_TYPE_POISON:
		{
			int iID = CGameBase::s_pPlayer->IDNumber();
			int iFX = FXID_REGION_POISON;
			CGameProcedure::s_pFX->TriggerBundle(iID, 0, iFX, iID, -1, FX_BUNDLE_REGION_POISON);
		}
		break;
	}
}

// ===== END WarFare/EventManager.cpp =====

// ===== BEGIN WarFare/EventManager.h =====
#line 1 "WarFare/EventManager.h"
﻿// EventManager.h: interface for the CEventManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENTMANAGER_H__7FB7F7FD_67B8_4F22_AE3E_C41581C16561__INCLUDED_)
#define AFX_EVENTMANAGER_H__7FB7F7FD_67B8_4F22_AE3E_C41581C16561__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>

class CEventCell
{
public:
	int16_t	m_sEventType;
	RECT	m_Rect;

	void	Load(File& file);
	CEventCell();
	virtual ~CEventCell();

};

typedef std::list<CEventCell*>		EventList;
typedef EventList::iterator			EventItor;

class CEventManager  
{
private:
	EventList	m_lstEvents;
	int16_t		m_sEventType;
	RECT		m_rcEvent;

public:
	void Behavior(int16_t sEventType, int16_t sPreEventType);
	bool PtInRect(int x, int z, RECT rc);
	int16_t SetPos(float fX, float fZ);
	void Release();
	bool LoadFromFile(const char* szFileName);
	CEventManager();
	virtual ~CEventManager();

};

#endif // !defined(AFX_EVENTMANAGER_H__7FB7F7FD_67B8_4F22_AE3E_C41581C16561__INCLUDED_)

// ===== END WarFare/EventManager.h =====

// ===== BEGIN WarFare/GameBase.cpp =====
#line 1 "WarFare/GameBase.cpp"
﻿// GameBase.cpp: implementation of the CGameBase class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "GameBase.h"
#include "N3WorldManager.h"
#include "PlayerOtherMgr.h"
#include "PlayerMySelf.h"

#include <N3Base/N3ShapeMgr.h>

#include <ranges>
#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3TableBase<__TABLE_TEXTS>				CGameBase::s_pTbl_Texts;
CN3TableBase<__TABLE_ZONE>				CGameBase::s_pTbl_Zones;
CN3TableBase<__TABLE_UI_RESRC>			CGameBase::s_pTbl_UI;
CN3TableBase<__TABLE_ITEM_BASIC>		CGameBase::s_pTbl_Items_Basic;
CN3TableBase<__TABLE_ITEM_EXT>			CGameBase::s_pTbl_Items_Exts[MAX_ITEM_EXTENSION];
CN3TableBase<__TABLE_PLAYER_LOOKS>		CGameBase::s_pTbl_UPC_Looks;
CN3TableBase<__TABLE_PLAYER_LOOKS>		CGameBase::s_pTbl_NPC_Looks;
CN3TableBase<__TABLE_UPC_SKILL>			CGameBase::s_pTbl_Skill;
CN3TableBase<__TABLE_EXCHANGE_QUEST>	CGameBase::s_pTbl_Exchange_Quest;
CN3TableBase<__TABLE_FX>				CGameBase::s_pTbl_FXSource;
CN3TableBase<__TABLE_QUEST_MENU>		CGameBase::s_pTbl_QuestMenu;
CN3TableBase<__TABLE_QUEST_TALK>		CGameBase::s_pTbl_QuestTalk;
CN3TableBase<__TABLE_QUEST_CONTENT>		CGameBase::s_pTbl_QuestContent;
CN3TableBase<__TABLE_HELP>				CGameBase::s_pTbl_Help;

CN3WorldManager*	CGameBase::s_pWorldMgr	= nullptr;	// Manages the current loaded zone
CPlayerOtherMgr*	CGameBase::s_pOPMgr		= nullptr;	// Manages other loaded characters and NPCs
CPlayerMySelf*		CGameBase::s_pPlayer	= nullptr;	// The local player instance
	
CGameBase::CGameBase()
{
}

CGameBase::~CGameBase()
{
}

void CGameBase::StaticMemberInit()
{
	std::string szLangTail = "_us.tbl";
	int iLangID = ::GetUserDefaultLangID();
	if (0x0404 == iLangID)
		szLangTail = "_TW.tbl"; // Taiwan Language

	std::string szFN;
	szFN = "Data\\Texts" + szLangTail;		s_pTbl_Texts.LoadFromFile(szFN);
	szFN = "Data\\Zones.tbl";				s_pTbl_Zones.LoadFromFile(szFN);
	szFN = "Data\\UIs" + szLangTail;		s_pTbl_UI.LoadFromFile(szFN);
	szFN = "Data\\UPC_DefaultLooks.tbl";	s_pTbl_UPC_Looks.LoadFromFile(szFN);
	szFN = "Data\\Item_Org" + szLangTail;	s_pTbl_Items_Basic.LoadFromFile(szFN);

	szFN = "Data\\Quest_Menu" + szLangTail;	s_pTbl_QuestMenu.LoadFromFile(szFN);
	szFN = "Data\\Quest_Talk" + szLangTail;	s_pTbl_QuestTalk.LoadFromFile(szFN);
	szFN = "Data\\Quest_Content" + szLangTail;	s_pTbl_QuestContent.LoadFromFile(szFN);
	szFN = "Data\\Help" + szLangTail;		s_pTbl_Help.LoadFromFile(szFN);

	std::string szFNTmp;
	for (int i = 0; i < MAX_ITEM_EXTENSION; i++)
	{
		szFNTmp = fmt::format("Data\\Item_Ext_{}", i);
		szFN = szFNTmp + szLangTail;
		s_pTbl_Items_Exts[i].LoadFromFile(szFN);
	}

	szFN = "Data\\NPC_Looks.tbl";					s_pTbl_NPC_Looks.LoadFromFile(szFN);
	szFN = "Data\\skill_magic_main" + szLangTail;	s_pTbl_Skill.LoadFromFile(szFN);
	szFN = "Data\\Exchange_Quest.tbl";				s_pTbl_Exchange_Quest.LoadFromFile(szFN);
	szFN = "Data\\fx.tbl";							s_pTbl_FXSource.LoadFromFile(szFN);

	s_pWorldMgr = new CN3WorldManager();
	s_pOPMgr = new CPlayerOtherMgr();
	s_pPlayer = new CPlayerMySelf();
}

void CGameBase::StaticMemberRelease()
{
	delete s_pPlayer;	s_pPlayer = nullptr;
	delete s_pOPMgr;	s_pOPMgr = nullptr;
	delete s_pWorldMgr;	s_pWorldMgr = nullptr;
}

bool CGameBase::GetTextByClass(e_Class eClass, std::string& szText)
{
	switch(eClass)
	{
		case CLASS_KINDOF_WARRIOR:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_WARRIOR);
			break;
		case CLASS_KINDOF_ROGUE:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_ROGUE);
			break;
		case CLASS_KINDOF_WIZARD:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_WIZARD);
			break;
		case CLASS_KINDOF_PRIEST:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_PRIEST);
			break;
		case CLASS_KINDOF_ATTACK_WARRIOR:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_ATTACK_WARRIOR);
			break;
		case CLASS_KINDOF_DEFEND_WARRIOR:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_DEFEND_WARRIOR);
			break;
		case CLASS_KINDOF_ARCHER:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_ARCHER);
			break;
		case CLASS_KINDOF_ASSASSIN:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_ASSASSIN);
			break;
		case CLASS_KINDOF_ATTACK_WIZARD:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_ATTACK_WIZARD);
			break;
		case CLASS_KINDOF_PET_WIZARD:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_PET_WIZARD);
			break;
		case CLASS_KINDOF_HEAL_PRIEST:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_HEAL_PRIEST);
			break;
		case CLASS_KINDOF_CURSE_PRIEST:
			szText = fmt::format_text_resource(IDS_CLASS_KINDOF_CURSE_PRIEST);
			break;

		case CLASS_EL_WARRIOR:
		case CLASS_KA_WARRIOR:
			szText = fmt::format_text_resource(IDS_CLASS_WARRIOR);
			break;
		case CLASS_EL_ROGUE:
		case CLASS_KA_ROGUE:
			szText = fmt::format_text_resource(IDS_CLASS_ROGUE);
			break;
		case CLASS_EL_WIZARD:
		case CLASS_KA_WIZARD:
			szText = fmt::format_text_resource(IDS_CLASS_WIZARD);
			break;
		case CLASS_EL_PRIEST:
		case CLASS_KA_PRIEST:
			szText = fmt::format_text_resource(IDS_CLASS_PRIEST);
			break;
		
		case CLASS_KA_BERSERKER:
			szText = fmt::format_text_resource(IDS_CLASS_KA_BERSERKER);
			break;
		case CLASS_KA_GUARDIAN:
			szText = fmt::format_text_resource(IDS_CLASS_KA_GUARDIAN);
			break;
		case CLASS_KA_HUNTER:
			szText = fmt::format_text_resource(IDS_CLASS_KA_HUNTER);
			break;
		case CLASS_KA_PENETRATOR:
			szText = fmt::format_text_resource(IDS_CLASS_KA_PENETRATOR);
			break;
		case CLASS_KA_SORCERER:
			szText = fmt::format_text_resource(IDS_CLASS_KA_SORCERER);
			break;
		case CLASS_KA_NECROMANCER:
			szText = fmt::format_text_resource(IDS_CLASS_KA_NECROMANCER);
			break;
		case CLASS_KA_SHAMAN:
			szText = fmt::format_text_resource(IDS_CLASS_KA_SHAMAN);
			break;
		case CLASS_KA_DARKPRIEST:
			szText = fmt::format_text_resource(IDS_CLASS_KA_DARKPRIEST);
			break;
		
		case CLASS_EL_BLADE:
			szText = fmt::format_text_resource(IDS_CLASS_EL_BLADE);
			break;
		case CLASS_EL_PROTECTOR:
			szText = fmt::format_text_resource(IDS_CLASS_EL_PROTECTOR);
			break;
		case CLASS_EL_RANGER:
			szText = fmt::format_text_resource(IDS_CLASS_EL_RANGER);
			break;
		case CLASS_EL_ASSASIN:
			szText = fmt::format_text_resource(IDS_CLASS_EL_ASSASIN);
			break;
		case CLASS_EL_MAGE:
			szText = fmt::format_text_resource(IDS_CLASS_EL_MAGE);
			break;
		case CLASS_EL_ENCHANTER:
			szText = fmt::format_text_resource(IDS_CLASS_EL_ENCHANTER);
			break;
		case CLASS_EL_CLERIC:
			szText = fmt::format_text_resource(IDS_CLASS_EL_CLERIC);
			break;
		case CLASS_EL_DRUID:
			szText = fmt::format_text_resource(IDS_CLASS_EL_DRUID);
			break;
		
		default:
			__ASSERT(0, "Invalid Class");
			szText = "Unknown Class";
			return false;
	}

	return true;
}

bool CGameBase::GetTextByKnightsDuty(e_KnightsDuty eDuty, std::string& szText)
{
	switch(eDuty)
	{
		case KNIGHTS_DUTY_UNKNOWN:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_UNKNOWN); break;
		case KNIGHTS_DUTY_PUNISH:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_PUNISH); break;
		case KNIGHTS_DUTY_TRAINEE:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_TRAINEE); break;
		case KNIGHTS_DUTY_KNIGHT:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_KNIGHT); break;
		case KNIGHTS_DUTY_OFFICER:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_OFFICER); break;
		case KNIGHTS_DUTY_VICECHIEF:	szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_VICECHIEF); break;
		case KNIGHTS_DUTY_CHIEF:		szText = fmt::format_text_resource(IDS_KNIGHTS_DUTY_CHIEF); break;
		default: __ASSERT(0, "Invalid Knights Duty"); szText = "Unknown Duty"; return false;
	}

	return true;
}

bool CGameBase::GetTextByItemClass(e_ItemClass eItemClass, std::string& szText)
{
	switch(eItemClass)
	{
		case ITEM_CLASS_DAGGER:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_DAGGER);
			break;
		case ITEM_CLASS_SWORD:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_SWORD);
			break;
		case ITEM_CLASS_SWORD_2H:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_SWORD_2H);
			break;
		case ITEM_CLASS_AXE:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_AXE);
			break;
		case ITEM_CLASS_AXE_2H:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_AXE_2H);
			break;
		case ITEM_CLASS_MACE:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_MACE);
			break;
		case ITEM_CLASS_MACE_2H:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_MACE_2H);
			break;
		case ITEM_CLASS_SPEAR:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_SPEAR);
			break;
		case ITEM_CLASS_POLEARM:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_POLEARM);
			break;

		case ITEM_CLASS_SHIELD:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_SHIELD);
			break;

		case ITEM_CLASS_BOW:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_BOW);
			break;
		case ITEM_CLASS_BOW_CROSS:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_BOW_CROSS);
			break;
		case ITEM_CLASS_BOW_LONG:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_BOW_LONG);
			break;

		case ITEM_CLASS_EARRING:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_EARRING);
			break;
		case ITEM_CLASS_AMULET:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_AMULET);
			break;
		case ITEM_CLASS_RING:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_RING);
			break;
		case ITEM_CLASS_BELT:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_BELT);
			break;
		case ITEM_CLASS_CHARM:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_CHARM);
			break;
		case ITEM_CLASS_JEWEL:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_JEWEL);
			break;
		case ITEM_CLASS_POTION:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_POTION);
			break;
		case ITEM_CLASS_SCROLL:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_SCROLL);
			break;

		case ITEM_CLASS_LAUNCHER:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_LAUNCHER);
			break; 
						
		case ITEM_CLASS_STAFF:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_STAFF);
			break;
		case ITEM_CLASS_ARROW:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_ARROW);
			break;
		case ITEM_CLASS_JAVELIN:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_JAVELIN);
			break;
		
		case ITEM_CLASS_ARMOR_WARRIOR:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_ARMOR_WARRIOR);
			break;
		case ITEM_CLASS_ARMOR_ROGUE:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_ARMOR_ROGUE);
			break;
		case ITEM_CLASS_ARMOR_MAGE:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_ARMOR_MAGE);
			break;
		case ITEM_CLASS_ARMOR_PRIEST:
			szText = fmt::format_text_resource(IDS_ITEM_CLASS_ARMOR_PRIEST); 
			break;
		default:
//			__ASSERT(0, "Invalid Item Class"); szText = "Unknown Item Class";
			return false;
	}

	return true;
}

bool CGameBase::GetTextByAttrib(e_ItemAttrib eAttrib, std::string& szAttrib)
{
	switch(eAttrib)
	{
		case ITEM_ATTRIB_GENERAL:		szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_GENERAL); break;
		case ITEM_ATTRIB_MAGIC:			szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_MAGIC); break;
		case ITEM_ATTRIB_LAIR:			szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_LAIR); break;
		case ITEM_ATTRIB_CRAFT:			szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_CRAFT); break;
		case ITEM_ATTRIB_UNIQUE:		szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_UNIQUE); break;
		case ITEM_ATTRIB_UPGRADE:		szAttrib = fmt::format_text_resource(IDS_ITEM_ATTRIB_UPGRADE); break;
		default:
			return false;
	}

	return true;
}

e_Class_Represent CGameBase::GetRepresentClass(e_Class eClass)
{
	switch(eClass)
	{
		case CLASS_KA_WARRIOR:
		case CLASS_KA_BERSERKER:
		case CLASS_KA_GUARDIAN:
		case CLASS_EL_WARRIOR:
		case CLASS_EL_BLADE:
		case CLASS_EL_PROTECTOR:
			return CLASS_REPRESENT_WARRIOR;

		case CLASS_KA_ROGUE:
		case CLASS_KA_HUNTER:
		case CLASS_KA_PENETRATOR:
		case CLASS_EL_ROGUE:
		case CLASS_EL_RANGER:
		case CLASS_EL_ASSASIN:
			return CLASS_REPRESENT_ROGUE;

		case CLASS_KA_WIZARD:
		case CLASS_KA_SORCERER:
		case CLASS_KA_NECROMANCER:
		case CLASS_EL_WIZARD:
		case CLASS_EL_MAGE:
		case CLASS_EL_ENCHANTER:
			return CLASS_REPRESENT_WIZARD;

		case CLASS_KA_PRIEST:
		case CLASS_KA_SHAMAN:
		case CLASS_KA_DARKPRIEST:
		case CLASS_EL_PRIEST:
		case CLASS_EL_CLERIC:
		case CLASS_EL_DRUID:
			return CLASS_REPRESENT_PRIEST;
	}

	return CLASS_REPRESENT_UNKNOWN;
}

bool CGameBase::GetTextByNation(e_Nation eNation, std::string& szText)
{
	switch(eNation)
	{
		case NATION_ELMORAD:	szText = fmt::format_text_resource(IDS_NATION_ELMORAD); break;
		case NATION_KARUS:		szText = fmt::format_text_resource(IDS_NATION_KARUS); break;
		default: szText = fmt::format_text_resource(IDS_NATION_UNKNOWN); return false;
	}

	return true;
}

bool CGameBase::GetTextByRace(e_Race eRace, std::string& szText)
{
	switch(eRace)
	{
		case RACE_EL_BABARIAN:
			szText = fmt::format_text_resource(IDS_RACE_EL_BABARIAN);
			break;
		case RACE_EL_MAN:
			szText = fmt::format_text_resource(IDS_RACE_EL_MAN);
			break;
		case RACE_EL_WOMEN:
			szText = fmt::format_text_resource(IDS_RACE_EL_WOMEN);
			break;

		case RACE_KA_ARKTUAREK:
			szText = fmt::format_text_resource(IDS_RACE_KA_ARKTUAREK);
			break;
		case RACE_KA_TUAREK:
			szText = fmt::format_text_resource(IDS_RACE_KA_TUAREK);
			break;
		case RACE_KA_WRINKLETUAREK:
			szText = fmt::format_text_resource(IDS_RACE_KA_WRINKLETUAREK);
			break;
		case RACE_KA_PURITUAREK:
			szText = fmt::format_text_resource(IDS_RACE_KA_PURITUAREK);
			break;
			
		default:
			szText = fmt::format_text_resource(IDS_NATION_UNKNOWN); 
			return false;
	}

	return true;
}

D3DCOLOR CGameBase::GetIDColorByLevelDifference(int iLevelDiff)
{
	// Returns a colour code based on level difference relative to a player:
	// Purple   = 8+ levels above
	// Red      = 5 to 7 levels above
	// Yellow   = 2 to 4 levels above
	// White    = within 1 level (+/-)
	// Blue     = 2 to 4 levels below
	// Green    = 5 to 7 levels below
	// Sky blue = 8+ levels below (no EXP gained)
	
	D3DCOLOR crID = 0xffffffff;
	if(iLevelDiff >= 8)			crID = D3DCOLOR_ARGB(255, 255, 0, 255);
	else if(iLevelDiff >= 5)	crID = D3DCOLOR_ARGB(255, 255, 0, 0);
	else if(iLevelDiff >= 2)	crID = D3DCOLOR_ARGB(255, 255, 255, 0);
	else if(iLevelDiff >= -1)	crID = D3DCOLOR_ARGB(255, 255, 255, 255);
	else if(iLevelDiff >= -4)	crID = D3DCOLOR_ARGB(255, 0, 0, 255);
	else if(iLevelDiff >= -7)	crID = D3DCOLOR_ARGB(255, 0, 255, 0);
	else crID = D3DCOLOR_ARGB(255, 0, 255, 255);

	return crID;
}

// Generate requested resource filenames using the given item data
e_ItemType CGameBase::MakeResrcFileNameForUPC(	__TABLE_ITEM_BASIC* pItem,
												__TABLE_ITEM_EXT* pItemExt,
												std::string* pszResrcFN,
												std::string* pszIconFN,
												e_PartPosition& ePartPosition,
												e_PlugPosition& ePlugPosition,
												e_Race eRace /*= RACE_UNKNOWN*/)
{	
	ePartPosition = PART_POS_UNKNOWN;
	ePlugPosition = PLUG_POS_UNKNOWN;
	if(pszResrcFN) *pszResrcFN = "";
	if(pszIconFN) *pszIconFN = "";

	if(nullptr == pItem) return ITEM_TYPE_UNKNOWN;
	
	e_ItemType eType	= ITEM_TYPE_UNKNOWN;
	e_ItemPosition ePos	= (e_ItemPosition)pItem->byAttachPoint;

	int iPos = 0;
	std::string szExt; // File extension
	
	if(ePos >= ITEM_POS_DUAL && ePos <= ITEM_POS_TWOHANDLEFT)
	{
		if(ITEM_POS_DUAL == ePos || ITEM_POS_RIGHTHAND == ePos || ITEM_POS_TWOHANDRIGHT == ePos) ePlugPosition = PLUG_POS_RIGHTHAND;
		else if(ITEM_POS_LEFTHAND == ePos || ITEM_POS_TWOHANDLEFT == ePos) ePlugPosition = PLUG_POS_LEFTHAND;

		eType = ITEM_TYPE_PLUG;
		szExt = ".n3cplug";
	}
	else if(ePos >= ITEM_POS_UPPER && ePos <= ITEM_POS_SHOES)
	{
		if(ITEM_POS_UPPER == ePos)			ePartPosition = PART_POS_UPPER;
		else if(ITEM_POS_LOWER == ePos)		ePartPosition = PART_POS_LOWER;
		else if(ITEM_POS_HEAD == ePos)		ePartPosition = PART_POS_HAIR_HELMET;
		else if(ITEM_POS_GLOVES == ePos)	ePartPosition = PART_POS_HANDS;
		else if(ITEM_POS_SHOES == ePos)		ePartPosition = PART_POS_FEET;
		else { __ASSERT(0, "lll"); }
		
		eType = ITEM_TYPE_PART;
		szExt = ".n3cpart";
		iPos = ePartPosition + 1;
	}
	else if(ePos >= ITEM_POS_EAR && ePos <= ITEM_POS_INVENTORY)
	{
		eType = ITEM_TYPE_ICONONLY;
		szExt = ".dxt";
	}
	else if(ePos == ITEM_POS_GOLD)
	{
		eType = ITEM_TYPE_GOLD;
		szExt = ".dxt";
	}
	else if(ePos == ITEM_POS_SONGPYUN)
	{
		eType = ITEM_TYPE_SONGPYUN;
		szExt = ".dxt";
	}
	else
	{
		__ASSERT(0, "Invalid Item Position");
	}

	// replace icon/resource IDs if they're overridden by the item
	int iIDResrc = 0, iIDIcon = 0;
	
	if (pItemExt != nullptr && pItemExt->dwIDResrc != 0)
		iIDResrc = pItemExt->dwIDResrc;
	else
		iIDResrc = pItem->dwIDResrc;

	if (pItemExt != nullptr && pItemExt->dwIDIcon != 0)
		iIDIcon = pItemExt->dwIDIcon;
	else
		iIDIcon = pItem->dwIDIcon;

	if (pszResrcFN)
	{
		if (pItem->dwIDResrc)
		{
			// NOTE: no idea but perhaps this will work for now
			if (eRace != RACE_UNKNOWN && ePos >= /*ITEM_POS_DUAL*/ITEM_POS_UPPER && ePos <= ITEM_POS_SHOES)
			{
				*pszResrcFN = fmt::format("Item\\{:01}_{:04}_{:02}_{:01}{}",
					(iIDResrc / 10000000),
					((iIDResrc / 1000) % 10000) + eRace,
					(iIDResrc / 10) % 100,
					iIDResrc % 10,
					szExt);
			}
			else
			{
				*pszResrcFN = fmt::format("Item\\{:01}_{:04}_{:02}_{:01}{}",
					(iIDResrc / 10000000),
					(iIDResrc / 1000) % 10000,
					(iIDResrc / 10) % 100,
					iIDResrc % 10,
					szExt);
			}
		}
		// Some items don't have models -- only icons.
		else
		{
			pszResrcFN->clear();
		}
	}

	if (pszIconFN)
	{
		*pszIconFN = fmt::format("UI\\ItemIcon_{:01}_{:04}_{:02}_{:01}.dxt",
			(iIDIcon / 10000000),
			(iIDIcon / 1000) % 10000,
			(iIDIcon / 10) % 100,
			iIDIcon % 10);
	}
	
	return eType;
}

bool CGameBase::IsValidCharacter(CPlayerBase* pCharacter)
{
	if (pCharacter == nullptr)
		return false;

	// Requested character is the lcoal player.
	if (pCharacter == s_pPlayer)
		return true;

	// Verify that the player exists.
	// NOTE: The original comment claimed to check if they're alive,
	// but it does no such thing.
	return s_pOPMgr->IsValidCharacter(pCharacter);
}

CPlayerBase* CGameBase::CharacterGetByID(int iID, bool bFromAlive)
{
	if(iID < 0) return nullptr;
	if(iID == s_pPlayer->IDNumber()) return s_pPlayer;
	return s_pOPMgr->CharacterGetByID(iID, bFromAlive);
}

std::string CGameBase::FormatNumber(int iNumber)
{
	// Original unformatted number in string form
	const std::string szOrigNum = std::to_string(iNumber);

	// Where the digits actually start - if it has a sign, this will be at 1.
	// Otherwise, it will start at 0.
	size_t nDigitStart = (iNumber < 0 ? 1 : 0);

	// Full number of digits (excluding the sign).
	size_t nDigitCount = szOrigNum.size() - nDigitStart;

	// Number of commas that will be generated.
	size_t nCommaCount = (nDigitCount - 1) / 3;

	// Number of leading digits. 
	size_t nLeadingDigits = nDigitCount % 3;
	if (nLeadingDigits == 0)
		nLeadingDigits = 3;

	// Pre-reserve the buffer for us to append to.
	std::string szFormattedNum;
	szFormattedNum.reserve(szOrigNum.size() + nCommaCount);

	// Append sign (if applicable) and variable number of leading digits.
	size_t nStartPos = nDigitStart + nLeadingDigits;
	szFormattedNum.append(szOrigNum, 0, nStartPos);

	// The remaining groups of 3 are guaranteed, so we can append them in their full 3s.
	for (size_t i = nStartPos; i < szOrigNum.size(); i += 3)
	{
		szFormattedNum += ',';
		szFormattedNum.append(szOrigNum, i, 3);
	}

	return szFormattedNum;
}

std::string CGameBase::UnformatNumber(const std::string& input)
{
	std::string result = input;
	result.erase(std::remove(result.begin(), result.end(), ','), result.end());
	return result;
}

void CGameBase::ConvertPipesToNewlines(std::string& input)
{
	std::ranges::replace(input, '|', '\n');
}

bool CGameBase::IsItemClassWeapon(e_ItemClass itemClass)
{
	switch (itemClass)
	{
		case ITEM_CLASS_DAGGER:
		case ITEM_CLASS_SWORD:
		case ITEM_CLASS_SWORD_2H:
		case ITEM_CLASS_AXE:
		case ITEM_CLASS_AXE_2H:
		case ITEM_CLASS_MACE:
		case ITEM_CLASS_MACE_2H:
		case ITEM_CLASS_SPEAR:
		case ITEM_CLASS_POLEARM:
		case ITEM_CLASS_BOW:
		case ITEM_CLASS_BOW_CROSS:
		case ITEM_CLASS_BOW_LONG:
		case ITEM_CLASS_STAFF:
		case ITEM_CLASS_JAVELIN:
			return true;
	}

	return false;
}

e_ZoneAbilityType CGameBase::GetCurrentZoneAbilityType()
{
	return s_pPlayer->m_InfoExt.eZoneAbilityType;
}

// ===== END WarFare/GameBase.cpp =====

// ===== BEGIN WarFare/GameBase.h =====
#line 1 "WarFare/GameBase.h"
﻿#pragma once

#include <N3Base/N3Base.h>
#include <N3Base/N3TableBase.h>

#include "GameDef.h"

class CGameBase : public CN3Base
{
#define ACT_WORLD s_pWorldMgr->GetActiveWorld()

public:
	static CN3TableBase<__TABLE_TEXTS>				s_pTbl_Texts;			// Main string resources
	static CN3TableBase<__TABLE_ZONE>				s_pTbl_Zones;			// Zone data (filenames and settings)
	static CN3TableBase<__TABLE_UI_RESRC>			s_pTbl_UI;				// Maps UI filenames per-nation
	static CN3TableBase<__TABLE_ITEM_BASIC>			s_pTbl_Items_Basic;		// Base item data
	static CN3TableBase<__TABLE_ITEM_EXT>			s_pTbl_Items_Exts[MAX_ITEM_EXTENSION];	// Extended item data for a base item
	static CN3TableBase<__TABLE_PLAYER_LOOKS>		s_pTbl_UPC_Looks;		// Default model information for player characters
	static CN3TableBase<__TABLE_PLAYER_LOOKS>		s_pTbl_NPC_Looks;		// Default model information for NPCs/monsters
	static CN3TableBase<__TABLE_UPC_SKILL>			s_pTbl_Skill;			// Base skill data
	static CN3TableBase<__TABLE_EXCHANGE_QUEST>		s_pTbl_Exchange_Quest;	// Old officially unused data for what were originally 'exchange quests'
	static CN3TableBase<__TABLE_FX>					s_pTbl_FXSource;		// Effect data (filename and settings)
	static CN3TableBase<__TABLE_QUEST_MENU>			s_pTbl_QuestMenu;		// Quest menu button resources
	static CN3TableBase<__TABLE_QUEST_TALK>			s_pTbl_QuestTalk;		// Quest dialogue resources
	static CN3TableBase<__TABLE_QUEST_CONTENT>		s_pTbl_QuestContent;
	static CN3TableBase<__TABLE_HELP>				s_pTbl_Help;

	static class CN3WorldManager*		s_pWorldMgr;						// Manages the current loaded zone
	static class CPlayerOtherMgr*		s_pOPMgr;							// Manages other loaded characters and NPCs
	static class CPlayerMySelf*			s_pPlayer;							// The local player instance
	
protected:
	// Initializes base game resources - table data, the world manager, character management, and more.
	static void StaticMemberInit();

	// Releases base game resources - table data, the world manager, character management, and more.
	static void StaticMemberRelease();

public:
	static bool	GetTextByAttrib(e_ItemAttrib eAttrib, std::string& szAttrib);
	static bool GetTextByClass(e_Class eClass, std::string& szText);
	static bool GetTextByItemClass(e_ItemClass eItemClass, std::string& szText);
	static bool GetTextByKnightsDuty(e_KnightsDuty eDuty, std::string& szText);
	static bool GetTextByNation(e_Nation eNation, std::string& szText);
	static bool GetTextByRace(e_Race eRace, std::string& szText);

	// Returns a colour code based on level difference relative to a player
	static D3DCOLOR				GetIDColorByLevelDifference(int iLevelDiff);

	// Returns the representative class for a given player class.
	static e_Class_Represent	GetRepresentClass(e_Class eClass);

	static e_ItemType MakeResrcFileNameForUPC(	__TABLE_ITEM_BASIC* pItem,
												__TABLE_ITEM_EXT* pItemExt,
												std::string* szResrcFN,
												std::string* szIconFN,
												e_PartPosition& ePartPosition,
												e_PlugPosition& ePlugPosition,
												e_Race eRace = RACE_UNKNOWN);

	class CPlayerBase*	CharacterGetByID(int iID, bool bFromAlive);
	bool				IsValidCharacter(CPlayerBase* pCharacter);
	static std::string	FormatNumber(int iNumber);
	static std::string	UnformatNumber(const std::string& input);
	static void			ConvertPipesToNewlines(std::string& input);

	static bool			IsItemClassWeapon(e_ItemClass itemClass);

	static e_ZoneAbilityType GetCurrentZoneAbilityType();

	CGameBase();
	virtual ~CGameBase();
};

// ===== END WarFare/GameBase.h =====

// ===== BEGIN WarFare/GameCursor.cpp =====
#line 1 "WarFare/GameCursor.cpp"
﻿// GameCursor.cpp: implementation of the CGameCursor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcedure.h"
#include "LocalInput.h"
#include "GameCursor.h"
#include "UIManager.h"
#include "ClientResourceFormatter.h"

#include <N3Base/N3UIImage.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameCursor::CGameCursor()
{
	m_bCursorLocked		= false;
	m_eCurGameCursor	= CURSOR_EL_NORMAL;
	m_ePrevGameCursor	= CURSOR_EL_NORMAL;
	m_hCursor			= nullptr;

	for(int i = 0 ; i < CURSOR_COUNT; i++)
	{
		m_pImageCursor[i] = nullptr;
	}
}

CGameCursor::~CGameCursor()
{
	if(m_hCursor) ::SetCursor(m_hCursor);
}

bool CGameCursor::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	m_hCursor = ::GetCursor();
	::SetCursor(nullptr);

	std::string szID;
	for (int i = 0; i < CURSOR_COUNT; i++)
	{
		szID = fmt::format("Image_Cursor{:02}", i);
		N3_VERIFY_UI_COMPONENT(m_pImageCursor[i], GetChildByID<CN3UIImage>(szID));
	}

	return true;
}

void CGameCursor::SetGameCursor(e_Cursor eCursor, bool bLocked)
{
	if ((m_bCursorLocked) && (!bLocked) ) return;
	else if ( ((m_bCursorLocked) && bLocked) || ((!m_bCursorLocked) && !bLocked) )
	{
		m_eCurGameCursor = eCursor;
		return;
	}
	else if ((!m_bCursorLocked) && bLocked)
	{
		m_ePrevGameCursor = m_eCurGameCursor;
		m_bCursorLocked = true;
		m_eCurGameCursor = eCursor;
	}
}

void CGameCursor::RestoreGameCursor()
{
	if (m_bCursorLocked) 
		m_bCursorLocked = false;

	m_eCurGameCursor = m_ePrevGameCursor;
}

void CGameCursor::Render()
{
	if(m_eCurGameCursor >= CURSOR_COUNT) return;

	if(m_pImageCursor[m_eCurGameCursor])
	{
		CGameProcedure::s_pUIMgr->RenderStateSet();
		DWORD dwZ;
		CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
		CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);

		m_pImageCursor[m_eCurGameCursor]->Render();
		CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
		CGameProcedure::s_pUIMgr->RenderStateRestore();

	}
}

void CGameCursor::Tick()
{
	HCURSOR hCursor = ::GetCursor();
	if(hCursor)	::SetCursor(nullptr);

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	for(int i = 0 ; i < CURSOR_COUNT; i++)
	{
		if(m_pImageCursor[i]) m_pImageCursor[i]->SetPos(ptCur.x, ptCur.y);
	}
}

// ===== END WarFare/GameCursor.cpp =====

// ===== BEGIN WarFare/GameCursor.h =====
#line 1 "WarFare/GameCursor.h"
﻿// GameCursor.h: interface for the CGameCursor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMECURSOR_H__3BC4F8E1_6DEC_4848_A6EB_0352007AC780__INCLUDED_)
#define AFX_GAMECURSOR_H__3BC4F8E1_6DEC_4848_A6EB_0352007AC780__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include <N3Base/N3UIBase.h>

class CGameCursor : public CN3UIBase
{
private:
	class		CN3UIImage* m_pImageCursor[CURSOR_COUNT];
	bool		m_bCursorLocked;
	e_Cursor	m_ePrevGameCursor;
	e_Cursor	m_eCurGameCursor;
	HCURSOR		m_hCursor;

public:
	void Tick() override;
	void Render() override;
	void RestoreGameCursor();
	void SetGameCursor(e_Cursor eCursor, bool bLocked = false);
	bool Load(File& file) override;
	CGameCursor();
	~CGameCursor() override;
};

#endif // !defined(AFX_GAMECURSOR_H__3BC4F8E1_6DEC_4848_A6EB_0352007AC780__INCLUDED_)

// ===== END WarFare/GameCursor.h =====

// ===== BEGIN WarFare/GameDef.h =====
#line 1 "WarFare/GameDef.h"
﻿#ifndef __GAME_DEF_H_
#define __GAME_DEF_H_

#include <string>
#include <dinput.h>
#include <stdint.h>
#include <inttypes.h>

#include <shared/version.h>

// TODO: Shift this logic into a separate header and generally clean this shared logic up
#ifndef ASSERT
#if defined(_DEBUG)
#define ASSERT assert
#include <assert.h>
#else
#define ASSERT
#endif
#endif

#include <shared/Packet.h>

#include <shared/globals.h>

constexpr int CURRENT_VERSION = 1298;

// This is the maximum time we must wait after sending the WIZ_VERSION_CHECK packet on the login scene, before we're allowed
// to attempt to re-establish a connection to the game server.
// We'll use 5 seconds here as it's a more than reasonable enough time for it to receive a packet, even with lag, while not being
// too excessive.
// If the client disconnects in this time, this timer will be reset, so there's no need to account for this.
// Officially it Sleep()s for 1 second prior to even sending WIZ_VERSION_CHECK packet we need to wait for, so there's not really
// a comparable official limit. All this accomplishes is reducing the number of connection attempts, not preventing overlaps.
constexpr float TIME_UNTIL_NEXT_GAME_CONNECTION_ATTEMPT = 5.0f;

constexpr float PACKET_INTERVAL_MOVE = 1.5f;				// Interval between regularly sent player/NPC movement packets.
constexpr float PACKET_INTERVAL_ROTATE = 4.0f;				// Interval between regularly sent player rotation packets.
constexpr float PACKET_INTERVAL_REQUEST_TARGET_HP = 2.0f;

#define N3_FORMAT_VER_1068 0x00000001
#define N3_FORMAT_VER_1298 0x00000002

enum e_ExitType
{
	EXIT_TYPE_NONE			= 0,
	EXIT_TYPE_CHR_SELECT	= 1,
	EXIT_TYPE_QUIT			= 2,
};

constexpr int EXIT_TIME_AFTER_BATTLE	= 10;

// 단축키 지정해 놓은 부분..
enum eKeyMap {	KM_HOTKEY1 = DIK_1, 
				KM_HOTKEY2 = DIK_2, 
				KM_HOTKEY3 = DIK_3, 
				KM_HOTKEY4 = DIK_4, 
				KM_HOTKEY5 = DIK_5, 
				KM_HOTKEY6 = DIK_6, 
				KM_HOTKEY7 = DIK_7, 
				KM_HOTKEY8 = DIK_8, 
				KM_TOGGLE_RUN = DIK_T, 
				KM_TOGGLE_MOVE_CONTINOUS = DIK_E, 
				KM_TOGGLE_ATTACK = DIK_R, 
				KM_TOGGLE_SITDOWN = DIK_C, 
				KM_TOGGLE_INVENTORY = DIK_I, 
				KM_TOGGLE_SKILL = DIK_K, 
				KM_TOGGLE_STATE = DIK_U, 
				KM_TOGGLE_MINIMAP = DIK_M, 
				KM_TOGGLE_HELP = DIK_F10,
				KM_TOGGLE_CMDLIST = DIK_H,
				KM_CAMERA_CHANGE = DIK_F9, 
				KM_DROPPED_ITEM_OPEN = DIK_F, 
				KM_MOVE_FOWARD = DIK_W, 
				KM_MOVE_BACKWARD = DIK_S, 
				KM_ROTATE_LEFT = DIK_A, 
				KM_ROTATE_RIGHT = DIK_D, 
				KM_TARGET_NEAREST_ENEMY = DIK_Z, 
				KM_TARGET_NEAREST_PARTY = DIK_X, 
				KM_TARGET_NEAREST_FRIEND = DIK_V, 
				KM_TARGET_NEAREST_NPC = DIK_B,
				KM_SKILL_PAGE_1 = DIK_F1, 
				KM_SKILL_PAGE_2 = DIK_F2,
				KM_SKILL_PAGE_3 = DIK_F3,
				KM_SKILL_PAGE_4 = DIK_F4,
				KM_SKILL_PAGE_5 = DIK_F5,
				KM_SKILL_PAGE_6 = DIK_F6,
				KM_SKILL_PAGE_7 = DIK_F7,
				KM_SKILL_PAGE_8 = DIK_F8 };

enum e_PlayerType { PLAYER_BASE = 0, PLAYER_NPC = 1, PLAYER_OTHER = 2, PLAYER_MYSELF = 3 };

enum e_Race {	RACE_ALL = 0,
				RACE_KA_ARKTUAREK = 1, RACE_KA_TUAREK = 2, RACE_KA_WRINKLETUAREK = 3, RACE_KA_PURITUAREK = 4, 
				RACE_EL_BABARIAN = 11, RACE_EL_MAN = 12, RACE_EL_WOMEN = 13,
				//RACE_KA_NORMAL = 11, RACE_KA_WARRIOR = 12, RACE_KA_ROGUE = 13, RACE_KA_MAGE = 14,
				RACE_NPC = 100,
				RACE_UNKNOWN = 0xffffffff };

enum e_Class_Represent { CLASS_REPRESENT_WARRIOR = 0, CLASS_REPRESENT_ROGUE, CLASS_REPRESENT_WIZARD, CLASS_REPRESENT_PRIEST, CLASS_REPRESENT_UNKNOWN = 100 };

constexpr float WEAPON_WEIGHT_STAND_SWORD = 5.0f;	// Standard weight of swords
constexpr float WEAPON_WEIGHT_STAND_AXE = 5.0f;		// Standard weight of axes
constexpr float WEAPON_WEIGHT_STAND_BLUNT = 8.0f;	// Standard weight of blunt type weapons

enum e_Ani {	ANI_BREATH = 0, ANI_WALK, ANI_RUN, ANI_WALK_BACKWARD, ANI_STRUCK0, ANI_STRUCK1, ANI_STRUCK2, ANI_GUARD,
				ANI_DEAD_NEATLY = 8, ANI_DEAD_KNOCKDOWN, ANI_DEAD_ROLL, ANI_SITDOWN, ANI_SITDOWN_BREATH, ANI_STANDUP,
				ANI_ATTACK_WITH_WEAPON_WHEN_MOVE = 14, ANI_ATTACK_WITH_NAKED_WHEN_MOVE, 

				ANI_SPELLMAGIC0_A = 16, ANI_SPELLMAGIC0_B, 
				ANI_SPELLMAGIC1_A = 18, ANI_SPELLMAGIC1_B, 
				ANI_SPELLMAGIC2_A = 20, ANI_SPELLMAGIC2_B, 
				ANI_SPELLMAGIC3_A = 22, ANI_SPELLMAGIC3_B, 
				ANI_SPELLMAGIC4_A = 24, ANI_SPELLMAGIC4_B, 
				
				ANI_SHOOT_ARROW_A = 26, ANI_SHOOT_ARROW_B, 
				ANI_SHOOT_QUARREL_A = 28, ANI_SHOOT_QUARREL_B, 
				ANI_SHOOT_JAVELIN_A = 30, ANI_SHOOT_JAVELIN_B, 
				
				ANI_SWORD_BREATH_A = 32,	ANI_SWORD_ATTACK_A0, ANI_SWORD_ATTACK_A1,
				ANI_SWORD_BREATH_B,			ANI_SWORD_ATTACK_B0, ANI_SWORD_ATTACK_B1,		// One-handed swords
				
				ANI_DAGGER_BREATH_A = 38,	ANI_DAGGER_ATTACK_A0, ANI_DAGGER_ATTACK_A1,
				ANI_DAGGER_BREATH_B,		ANI_DAGGER_ATTACK_B0, ANI_DAGGER_ATTACK_B1,		// Daggers
				
				ANI_DUAL_BREATH_A = 44,		ANI_DUAL_ATTACK_A0, ANI_DUAL_ATTACK_A1, 
				ANI_DUAL_BREATH_B,			ANI_DUAL_ATTACK_B0, ANI_DUAL_ATTACK_B1,			// Dual wielded items
				
				ANI_SWORD2H_BREATH_A = 50,	ANI_SWORD2H_ATTACK_A0, ANI_SWORD2H_ATTACK_A1, 
				ANI_SWORD2H_BREATH_B,		ANI_SWORD2H_ATTACK_B0, ANI_SWORD2H_ATTACK_B1,	// Two-handed swords
				
				ANI_BLUNT_BREATH_A = 56,	ANI_BLUNT_ATTACK_A0, ANI_BLUNT_ATTACK_A1, 
				ANI_BLUNT_BREATH_B,			ANI_BLUNT_ATTACK_B0, ANI_BLUNT_ATTACK_B1,		// Blunt weapons – maces
				
				ANI_BLUNT2H_BREATH_A = 62,	ANI_BLUNT2H_ATTACK_A0, ANI_BLUNT2H_ATTACK_A1, 
				ANI_BLUNT2H_BREATH_B,		ANI_BLUNT2H_ATTACK_B0, ANI_BLUNT2H_ATTACK_B1,	// Two-handed blunt weapons (maces), and axes.
				
				ANI_AXE_BREATH_A = 68,		ANI_AXE_ATTACK_A0, ANI_AXE_ATTACK_A1, 
				ANI_AXE_BREATH_B,			ANI_AXE_ATTACK_B0, ANI_AXE_ATTACK_B1,			// One-handed axes
				
				ANI_SPEAR_BREATH_A = 74,	ANI_SPEAR_ATTACK_A0, ANI_SPEAR_ATTACK_A1, 
				ANI_SPEAR_BREATH_B,			ANI_SPEAR_ATTACK_B0, ANI_SPEAR_ATTACK_B1,		// Spears – just a simple spear with no cutting edge.
				
				ANI_POLEARM_BREATH_A = 80,	ANI_POLEARM_ATTACK_A0, ANI_POLEARM_ATTACK_A1, 
				ANI_POLEARM_BREATH_B,		ANI_POLEARM_ATTACK_B0, ANI_POLEARM_ATTACK_B1,	// Two-handed bladed spears – something like a "Cheongryongdo" (Blue Dragon Sword)?
				
				ANI_NAKED_BREATH_A = 86,	ANI_NAKED_ATTACK_A0, ANI_NAKED_ATTACK_A1, 
				ANI_NAKED_BREATH_B,			ANI_NAKED_ATTACK_B0, ANI_NAKED_ATTACK_B1,		// Bare-handed??
				
				ANI_BOW_BREATH = 92,		ANI_CROSS_BOW_BREATH, ANI_LAUNCHER_BREATH, 
				ANI_BOW_BREATH_B,			ANI_BOW_ATTACK_B0, ANI_BOW_ATTACK_B1,			// Bow attacks
				
				ANI_SHIELD_BREATH_A = 98,	ANI_SHIELD_ATTACK_A0, ANI_SHIELD_ATTACK_A1, 
				ANI_SHIELD_BREATH_B,		ANI_SHIELD_ATTACK_B0, ANI_SHIELD_ATTACK_B1,		// Shield attacks

				ANI_GREETING0 = 104, ANI_GREETING1, ANI_GREETING2, 
				ANI_WAR_CRY0 = 107, ANI_WAR_CRY1, ANI_WAR_CRY2, ANI_WAR_CRY3, ANI_WAR_CRY4, 

				ANI_SKILL_AXE0 = 112, ANI_SKILL_AXE1, ANI_SKILL_AXE2, ANI_SKILL_AXE3, 
				ANI_SKILL_DAGGER0 = 116, ANI_SKILL_DAGGER1,
				ANI_SKILL_DUAL0 = 118, ANI_SKILL_DUAL1,
				ANI_SKILL_BLUNT0 = 120, ANI_SKILL_BLUNT1, ANI_SKILL_BLUNT2, ANI_SKILL_BLUNT3, 
				ANI_SKILL_POLEARM0 = 124, ANI_SKILL_POLEARM1,
				ANI_SKILL_SPEAR0 = 126, ANI_SKILL_SPEAR1,
				ANI_SKILL_SWORD0 = 128, ANI_SKILL_SWORD1, ANI_SKILL_SWORD2, ANI_SKILL_SWORD3, 
				ANI_SKILL_AXE2H0 = 132, ANI_SKILL_AXE2H1,
				ANI_SKILL_SWORD2H0 = 134, ANI_SKILL_SWORD2H1,

				// From here on: NPC Animation
				ANI_NPC_BREATH = 0, ANI_NPC_WALK, ANI_NPC_RUN, ANI_NPC_WALK_BACKWARD,
				ANI_NPC_ATTACK0 = 4, ANI_NPC_ATTACK1, ANI_NPC_STRUCK0, ANI_NPC_STRUCK1, ANI_NPC_STRUCK2, ANI_NPC_GUARD, 
				ANI_NPC_DEAD0 = 10, ANI_NPC_DEAD1, ANI_NPC_TALK0, ANI_NPC_TALK1, ANI_NPC_TALK2, ANI_NPC_TALK3, 
				ANI_NPC_SPELLMAGIC0 = 16, ANI_NPC_SPELLMAGIC1, 

				ANI_UNKNOWN = 0xffffffff };


// MAX_INCLINE_CLIMB = sqrt(1 - sin(90 - Maximum slope angle)^2)
constexpr float MAX_INCLINE_CLIMB = 0.6430f; // Maximum climbable slope value = 40 degrees

enum e_MoveDirection { MD_STOP, MD_FORWARD, MD_BACKWARD, MD_UNKNOWN = 0xffffffff };

constexpr float MOVE_DELTA_WHEN_RUNNING = 3.0f;	// Movement multiplier for running.
constexpr float MOVE_SPEED_WHEN_WALK = 1.5f;	// Standard player walking speed.

// 현재 상태...
enum e_StateMove {	PSM_STOP = 0,
					PSM_WALK,
					PSM_RUN,
					PSM_WALK_BACKWARD,
					PSM_COUNT };

enum e_StateAction {	PSA_BASIC = 0,		// Idle
						PSA_ATTACK,			// Attacking.
						PSA_GUARD,			// Successfully defended - attack blocked.
						PSA_STRUCK,			// Taking heavy damage.
						PSA_DYING,			// In the process of dying (collapsing)
						PSA_DEATH,			// Dead and lying down/knocked out.
						PSA_SPELLMAGIC,		// Casting a spell.
						PSA_SITDOWN, 		// Sitting down.
						PSA_COUNT }; 

enum e_StateDying {		PSD_DISJOINT = 0,	// Dies with a twisting/rolling death animation. NOTE: The original comment indicated the body physically breaking apart, but this is misleading -- the actual animations for players and NPCs simply twist and roll.
						PSD_KNOCK_DOWN,		// Dies while being knocked back.
						PSD_KEEP_POSITION,	// Dies posing in place.
						PSD_COUNT,

						PSD_UNKNOWN = 0xffffffff };

enum e_StateParty {	PSP_NORMAL = 0,
					PSP_POISONING = 1,
					PSP_CURSED = 2,
					PSP_MAGIC_TAKEN = 4,
					PSP_BLESSED = 8,
					PSP_UNKNOWN = 0xffffffff };

enum e_PartPosition	{	PART_POS_UPPER = 0,
						PART_POS_LOWER,
						PART_POS_FACE,
						PART_POS_HANDS,
						PART_POS_FEET, 
						PART_POS_HAIR_HELMET,
						PART_POS_COUNT,
						PART_POS_UNKNOWN = 0xffffffff };

enum e_PlugPosition {	PLUG_POS_RIGHTHAND = 0,
						PLUG_POS_LEFTHAND, 
						PLUG_POS_BACK, 
						PLUG_POS_KNIGHTS_GRADE, 
						PLUG_POS_COUNT,
						PLUG_POS_UNKNOWN = 0xffffffff };

enum e_ItemAttrib	{
						ITEM_ATTRIB_GENERAL = 0,
						ITEM_ATTRIB_MAGIC	= 1,
						ITEM_ATTRIB_LAIR	= 2,
						ITEM_ATTRIB_CRAFT	= 3,
						ITEM_ATTRIB_UNIQUE	= 4,
						ITEM_ATTRIB_UPGRADE	= 5,
						ITEM_ATTRIB_UNIQUE_REVERSE = 11,
						ITEM_ATTRIB_UPGRADE_REVERSE = 12,
						ITEM_ATTRIB_UNKNOWN = 0xffffffff };	

enum e_ItemClass	{	ITEM_CLASS_DAGGER = 11, // dagger
						ITEM_CLASS_SWORD = 21, // onehandsword
						ITEM_CLASS_SWORD_2H = 22, // 3 : twohandsword
						ITEM_CLASS_AXE = 31, // onehandaxe
						ITEM_CLASS_AXE_2H = 32, // twohandaxe
						ITEM_CLASS_MACE = 41, // mace
						ITEM_CLASS_MACE_2H = 42, // twohandmace
						ITEM_CLASS_SPEAR = 51, // spear
						ITEM_CLASS_POLEARM = 52, // polearm
						
						ITEM_CLASS_SHIELD = 60, // shield

						ITEM_CLASS_BOW = 70, //  Shortbow
						ITEM_CLASS_BOW_CROSS = 71, // crossbow
						ITEM_CLASS_BOW_LONG = 80, // longbow

						ITEM_CLASS_EARRING = 91, // Earring
						ITEM_CLASS_AMULET = 92, // Necklace
						ITEM_CLASS_RING = 93, // Ring
						ITEM_CLASS_BELT = 94, // Belt
						ITEM_CLASS_CHARM = 95, // Items carried in inventory
						ITEM_CLASS_JEWEL = 96, // Jewels/gems
						ITEM_CLASS_POTION = 97, // Potion / consumable
						ITEM_CLASS_SCROLL = 98, // Scroll

						ITEM_CLASS_LAUNCHER = 100, // Item used when throwing a spear.
						
						ITEM_CLASS_STAFF = 110, // Staff
						ITEM_CLASS_ARROW = 120, // Arrow
						ITEM_CLASS_JAVELIN = 130, // Javelin
						
						ITEM_CLASS_ARMOR_WARRIOR = 210, // Warrior armor
						ITEM_CLASS_ARMOR_ROGUE = 220, // Rogue armor
						ITEM_CLASS_ARMOR_MAGE = 230, // Mage armor
						ITEM_CLASS_ARMOR_PRIEST = 240, // Priest armor

						ITEM_CLASS_ETC = 251, // Miscellaneous
						ITEM_CLASS_CONSUMABLE = 255, // Consumable items with 'charges' that use the durability/duration instead of stacks

						ITEM_CLASS_UNKNOWN = 0xffffffff }; // 

enum e_ItemGrade
{
	ITEM_GRADE_LOW_CLASS = 1,
	ITEM_GRADE_MIDDLE_CLASS = 2,
	ITEM_GRADE_HIGH_CLASS = 3
};

enum e_Nation { NATION_NOTSELECTED = 0, NATION_KARUS, NATION_ELMORAD, NATION_UNKNOWN = 0xffffffff };

struct __TABLE_ITEM_BASIC;
struct __TABLE_ITEM_EXT;
struct __TABLE_PLAYER;

struct __InfoPlayerOther
{
	int			iFace;			// Face type
	int			iHair;			// Hair type

	int			iCity;			// Affiliated city
	std::string szKnights;		// Clan name
	int			iKnightsGrade;	// Clan grade
	int			iKnightsRank;	// Clan ranking

	int			iRank;			// Noble rank - used to identify high-ranking titles like King [1], Senator [2].
	int			iTitle;			// Bitmask representing various titles/roles including:
								// Clan Leader, Clan Assistant, Castle Lord, Feudal Lord, King, Emperor, Party leader, Solo player

	void Init()
	{
		iFace = 0;
		iHair = 0;
		iCity;
		szKnights.clear();
		iKnightsGrade = 0;
		iKnightsRank = 0;
		iTitle = 0;
	}
};

// Clan member position/role/duty
enum e_KnightsDuty {	KNIGHTS_DUTY_UNKNOWN = 0,		// Unknown - probably kicked out.
						KNIGHTS_DUTY_CHIEF = 1,			// Clan Leader
						KNIGHTS_DUTY_VICECHIEF = 2,		// Assistant
						KNIGHTS_DUTY_PUNISH = 3,		// Under punishment.
						KNIGHTS_DUTY_TRAINEE = 4,		// Trainee/apprentice
						KNIGHTS_DUTY_KNIGHT = 5,		// Regular member
						KNIGHTS_DUTY_OFFICER = 6		// Officer
					};

constexpr int VICTORY_ABSENCE	= 0;
constexpr int VICTORY_KARUS		= 1;
constexpr int VICTORY_ELMORAD	= 2;

struct __InfoPlayerMySelf : public __InfoPlayerOther
{
	int					iBonusPointRemain;		// Bonus points remaining to assign
	int					iLevelPrev;				// Previous level

	int					iMSPMax; 
	int					iMSP; 
			
	int					iTargetHPPercent;
	int					iGold;
	int64_t				iExpNext;
	int64_t				iExp;
	int					iRealmPoint;			// National Points
	int					iRealmPointMonthly;		// Monthly National Points
	e_KnightsDuty		eKnightsDuty;			// Clan member position/role/duty
	int					iWeightMax;				// Max weight
	int					iWeight;				// Current weight
	int					iStrength;				// Strength
	int					iStrength_Delta;		// Bonus strength
	int					iStamina;				// Stamina
	int					iStamina_Delta;			// Bonus stamina
	int					iDexterity;				// Dexterity
	int					iDexterity_Delta;		// Bonus dexterity
	int					iIntelligence;			// Intelligence
	int					iIntelligence_Delta;	// Bonus intelligence
	int 				iMagicAttak;			// Charisma/Magic Power
	int 				iMagicAttak_Delta;		// Bonus Charisma/Magic Power
	
	int 				iAttack;				// Attack Power
	int 				iAttack_Delta;			// Bonus Attack Power
	int 				iGuard;					// Defense
	int 				iGuard_Delta;			// Bonus Defense

	int 				iRegistFire;			// Fire resistance
	int 				iRegistFire_Delta;		// Bonus fire resistance
	int 				iRegistCold;			// Cold resistance
	int 				iRegistCold_Delta;		// Bonus cold resistance
	int 				iRegistLight;			// Lightning resistance
	int 				iRegistLight_Delta;		// Bonus lightning resistance
	int 				iRegistMagic;			// Magic resistance
	int 				iRegistMagic_Delta;		// Bonus magic resistance
	int 				iRegistCurse;			// Curse resistance
	int 				iRegistCurse_Delta;		// Bonus curse resistance
	int 				iRegistPoison;			// Poison resistance
	int 				iRegistPoison_Delta;	// Bonus poison resistance

	int					iZoneInit;				// Initial Zone ID received from the server
	int					iZoneCur;				// Current zone ID
	int					iVictoryNation;			// Last war outcome - 0: Draw, 1: El Morad victory, 2: Karus victory

	e_ZoneAbilityType	eZoneAbilityType;
	bool				bCanTradeWithOtherNation;
	bool				bCanTalkToOtherNation;
	int16_t				sZoneTariff;

	void Init()
	{
		__InfoPlayerOther::Init();

		iBonusPointRemain = 0;
		iLevelPrev = 0;

		iMSPMax = 0;
		iMSP = 0;

		iTargetHPPercent = 0;
		iGold = 0;
		iExpNext = 0;
		iExp = 0;
		iRealmPoint = 0;
		iRealmPointMonthly = 0;
		eKnightsDuty = KNIGHTS_DUTY_UNKNOWN;
		iWeightMax = 0;
		iWeight = 0;
		iStrength = 0;
		iStrength_Delta = 0;
		iStamina = 0;
		iStamina_Delta = 0;
		iDexterity = 0;
		iDexterity_Delta = 0;
		iIntelligence = 0;
		iIntelligence_Delta = 0;
		iMagicAttak = 0;
		iMagicAttak_Delta = 0;

		iAttack = 0;
		iAttack_Delta = 0;
		iGuard = 0;
		iGuard_Delta = 0;

		iRegistFire = 0;
		iRegistFire_Delta = 0;
		iRegistCold = 0;
		iRegistCold_Delta = 0;
		iRegistLight = 0;
		iRegistLight_Delta = 0;
		iRegistMagic = 0;
		iRegistMagic_Delta = 0;
		iRegistCurse = 0;
		iRegistCurse_Delta = 0;
		iRegistPoison = 0;
		iRegistPoison_Delta = 0;

		iZoneInit = 1;
		iZoneCur = 0;
		iVictoryNation = -1;

		eZoneAbilityType = ZONE_ABILITY_PVP;
		bCanTradeWithOtherNation = false;
		bCanTalkToOtherNation = false;
	}
};

constexpr int MAX_PARTY_OR_FORCE = 8;

struct __InfoPartyOrForce
{
	int			iID;				// Player's ID
	int			iLevel;				// Level
	e_Class		eClass;				// Class
	int			iHP;				// Hit Points
	int			iHPMax;				// Max Hit Points
	int			iMP;				// Mana Points
	int			iMPMax;				// Max Mana Points
	bool		bSufferDown_HP;		// Status - HP debuffed.
	bool		bSufferDown_Etc;	// Status - Cursed.
	std::string szID;				// Player's name

	void Init()
	{
		iID = -1;
		iLevel = 0;
		eClass = CLASS_UNKNOWN;
		iHP = 0;
		iHPMax = 0;
		iMP = 0;
		iMPMax = 0;
		szID.clear();

		bSufferDown_HP = false;			
		bSufferDown_Etc = false;		
	}

	__InfoPartyOrForce()
	{
		Init();
	}
};

enum e_PartyStatus { PARTY_STATUS_DOWN_HP = 1, PARTY_STATUS_DOWN_ETC = 2 };

// Seeking party board entry
struct __InfoPartyBBS
{
	std::string szID;			// Player's name
	int			iID;			// Player's ID
	int			iLevel;			// Level
	e_Class		eClass;			// Class
	int			iMemberCount;

	void Init()
	{
		szID.clear();
		iID = -1;
		iLevel = 0;
		eClass = CLASS_UNKNOWN;
		iMemberCount = 0;
	}

	__InfoPartyBBS()
	{
		Init();
	}
};

struct __TABLE_TEXTS
{
	uint32_t	dwID;
	std::string	szText;
};

struct __TABLE_ZONE
{
	uint32_t	dwID;					// 01 Zone ID
	std::string	szTerrainFN;			// 02 GTD
	std::string	szName;					// 03	
	std::string	szColorMapFN;			// 04 TCT
	std::string	szLightMapFN;			// 05 TLT
	std::string	szObjectPostDataFN;		// 06 OPD
	std::string	szOpdExtFN;				// 07 OPDEXT
	std::string	szMiniMapFN;			// 08 DXT
	std::string	szSkySetting;			// 09 N3Sky
	int			bIndicateEnemyPlayer;	// 10 Int32 (BOOL)
	int			iFixedSundDirection;	// 11 Int32
	std::string	szLightObjFN;			// 12 GLO
	std::string	szGevFN;				// 13 GEV
	int			iIdk0;					// 14 idk
	std::string	szEnsFN;				// 15 ENS
	float		fIdk1;					// 16 idk
	std::string	szFlagFN;				// 17 FLAG
	uint32_t	iIdk2;					// 18	
	uint32_t	iIdk3;					// 19	
	uint32_t	iIdk4;					// 20	
	uint32_t	iIdk5;					// 21
	std::string	szOpdSubFN;				// 22 OPDSUB
	int			iIdk6;					// 23
	std::string	szEvtSub;				// 24 EVTSUB
};

struct __TABLE_UI_RESRC
{
	uint32_t dwID;						// 01 (Karus/Human)
	std::string szLogIn;				// 02
	std::string szCmd;					// 03
	std::string szChat;					// 04
	std::string szMsgOutput;			// 05
	std::string szStateBar;				// 06
	std::string szVarious;				// 07
	std::string szState;				// 08
	std::string szKnights;				// 09
	std::string szQuest;				// 10
	std::string szFriends;				// 11 
	std::string szInventory;			// 12
	std::string szTransaction;			// 13
	std::string szDroppedItem;			// 14
	std::string szTargetBar;			// 15
	std::string szTargetSymbolShape;	// 16
	std::string szSkillTree;			// 17
	std::string szHotKey;				// 18
	std::string szMiniMap;				// 19
	std::string szPartyOrForce;			// 20
	std::string szPartyBBS;				// 21
	std::string szHelp;					// 22
	std::string szNotice;				// 23
	std::string szCharacterCreate;		// 24
	std::string szCharacterSelect;		// 25
	std::string szToolTip;				// 26
	std::string szMessageBox;			// 27
	std::string szLoading;				// 28
	std::string szItemInfo;				// 29
	std::string szPersonalTrade;		// 30
	std::string szPersonalTradeEdit;	// 31
	std::string szNpcEvent;				// 32
	std::string szZoneChangeOrWarp;		// 33
	std::string szExchangeRepair;		// 34
	std::string szRepairTooltip;		// 35
	std::string szNpcTalk;				// 36
	std::string szNpcExchangeList;		// 37
	std::string szKnightsOperation;		// 38
	std::string szClassChange;			// 39
	std::string szEndingDisplay;		// 40
	std::string szWareHouse;			// 41
	std::string szChangeClassInit;		// 42
	std::string szChangeInitBill;		// 43
	std::string szInn;					// 44
	std::string szInputClanName;		// 45
	std::string szTradeBBS;				// 46
	std::string szTradeBBSSelector;		// 47
	std::string szTradeExplanation;		// 48
	std::string szTradeMemolist;		// 49
	std::string szQuestMenu;			// 50
	std::string szQuestTalk;			// 51
	std::string szQuestEdit;			// 52
	std::string szDead;					// 53
	std::string szElLoading;			// 54
	std::string szKaLoading;			// 55
	std::string szNationSelect;			// 56
	std::string szChat2;				// 57
	std::string szMsgOutput2;			// 58
	std::string szItemUpgrade;			// 59
	std::string szDuelCreate;			// 60
	std::string szDuelList;				// 61
	std::string szDuelMsg;				// 62
	std::string szDuelMsgEdit;			// 63
	std::string szDuelLobby;			// 64
	std::string szQuestContent;			// 65
	std::string szDuelItemCnt;			// 66
	std::string szTradeInv;				// 67
	std::string szTradeBuyInv;			// 68
	std::string szTradeItemDisplay;		// 69
	std::string szTradePrice;			// 70
	std::string szTradeCnt;				// 71
	std::string szTradeMsgBox;			// 72
	std::string szClanPage;				// 73
	std::string szAllyPage;				// 74
	std::string szAlly2Page;			// 75
	std::string szCmdList;				// 76
	std::string szCmdEdit;				// 77
	std::string szClanLogo;				// 78
	std::string szShopMall;				// 79
	std::string szLvlGuide;				// 80
	std::string szCSWNpc;				// 81
	std::string szKCSWPetition;			// 82
	std::string szCSWAlly;				// 83
	std::string szCSWSchedule;			// 84
	std::string szExitMenu;				// 85
	std::string szResurrect;			// 86
	std::string szNameChange;			// 87
	std::string szNameEditBox;			// 88
	std::string szNameCheck;			// 89
	std::string szCSWAdmin;				// 90
	std::string szCSWTax;				// 91
	std::string szCSWCapeList;			// 92
	std::string szKnightCapeShop;		// 93
	std::string szCSWTaxCollection;		// 94
	std::string szCSWTaxRate;			// 95
	std::string szCSWTaxRateMsg;		// 96
	std::string szCatapult;				// 97
	std::string szDisguiseRing;			// 98
	std::string szMsgBoxOk;				// 99
	std::string szMsgBoxOkCancel;		// 100
	std::string szOpenChat;				// 101
	std::string szCloseChat;			// 102
	std::string szChrClanLogo;			// 103
	std::string szWarning;				// 104
	std::string szConvo;				// 105
	std::string szBlog;					// 106
	std::string szInnPass;				// 107
	std::string szNoviceTips;			// 108
	std::string szWebpage;				// 109
	std::string szPartyMsgBox;			// 110
	std::string szClanLogo2;			// 111
	std::string szRentalNpc;			// 112
	std::string szRentalTransaction;	// 113
	std::string szRentalEntry;			// 114
	std::string szRentalItem;			// 115
	std::string szRentalMsg;			// 116
	std::string szRentalCnt;			// 117
	std::string szNetDIO;				// 118
	std::string szLoginIntro;			// 119
	std::string szSubLoginIntro;		// 120
	std::string szCharSelect;			// 121
	std::string szCharCreate;			// 122
	std::string szOtherState;			// 123
	std::string szPPCardBegin;			// 124
	std::string szPPCardList;			// 125
	std::string szPPCardReg;			// 126
	std::string szPPCardMsg;			// 127
	std::string szPPCardBuyList;		// 128
	std::string szPPCardMyInfo;			// 129
	std::string szNationSelectNew;		// 130
	std::string szUSALogo;				// 131
	std::string szMonster;				// 132
	std::string szNationTaxNPC;			// 133
	std::string szNationTaxRate;		// 134
	std::string szKingMsgBoxOk;			// 135
	std::string szKingMsgBoxOkCancel;	// 136
	std::string szKingElectionBoard;	// 137
	std::string szKingElectionList;		// 138
	std::string szKingElectionMain;		// 139
	std::string szKingNominate;			// 140
	std::string szKingRegister;			// 141
	std::string szUpgradeRing;			// 142
	std::string szUpgradeSelect;		// 143
	std::string szTradeMsg;				// 144
	std::string szShowIcon;				// 145
};

struct __TABLE_ITEM_BASIC
{
	uint32_t	dwID;					// 01 Encoded item number: first 2 digits = item type, next 2 digits = equip position (used to determine Plugs or Parts), last 4 digits = item index

	uint8_t		byExtIndex;				// 02 Extension index (i.e. Item_Ext_<extension index>.tbl)
	std::string	szName;					// 03 Name
	std::string	szRemark;				// 04 Item Description

	uint32_t	dwIDK0;					// 05
	uint8_t		byIDK1;					// 06

	uint32_t	dwIDResrc;				// 07 Encoded resource ID
	uint32_t	dwIDIcon;				// 08 Encoded icon resource ID
	uint32_t	dwSoundID0;				// 09 Sound ID - set to 0 for no sound
	uint32_t	dwSoundID1;				// 10 Sound ID - set to 0 for no sound

	uint8_t		byClass;				// 11 Item type — see e_ItemClass enum for reference.
	uint8_t		byIsRobeType;			// 12 Robe-type item that replaces both upper and lower equipment slots, showing only this.
	uint8_t		byAttachPoint;			// 13 Equip position — identifies the specific slot on the character's body where this item is equipped
	uint8_t		byNeedRace;				// 14 Required race
	uint8_t		byNeedClass;			// 15 Required class

	int16_t		siDamage;				// 16 Weapon damage
	int16_t		siAttackInterval;		// 17 Attack speed (100 units = 1 second)
	int16_t		siAttackRange;			// 18 Effective attack range (in 0.1 meter units)
	int16_t		siWeight;				// 19 Weight (in 0.1 units)
	int16_t		siMaxDurability;		// 20 Max durability
	int			iPrice;					// 21 Purchase price
	int			iSaleType;				// 22 Sale type (see e_ItemSaleType)
	int16_t		siDefense;				// 23 Defense
	uint8_t		byContable;				// 24 Is the item countable/stackable?

	uint32_t	dwEffectID1;			// 25 Magic effect ID 1
	uint32_t	dwEffectID2;			// 26 Magic effect ID 2

	char		cNeedLevel;				// 27 Required level — player's iLevel (can be negative)

	char		cIDK2;					// 28

	uint8_t		byNeedRank;				// 29 Required rank — player's iRank
	uint8_t		byNeedTitle;			// 30 Required title — player's iTitle
	uint8_t		byNeedStrength;			// 31 Required strength — player's iStrength
	uint8_t		byNeedStamina;			// 32 Required stamina — player's iStamina
	uint8_t		byNeedDexterity;		// 33 Required dexterity — player's iDexterity
	uint8_t		byNeedInteli;			// 34 Required intelligence — player's iIntelligence
	uint8_t		byNeedMagicAttack;		// 35 Required charisma/magic power — player's iMagicAttack

	uint8_t		bySellGroup;			// 36 Selling group associated with vendor NPC

	uint8_t		byGrade;				// 37
};

constexpr int MAX_ITEM_EXTENSION	= 24; // Number of item extension tables. (Item_Ext_0..23.tbl is a total of 24)
constexpr int LIMIT_FX_DAMAGE		= 64;
constexpr int ITEM_LIMITED_EXHAUST	= 17;

struct __TABLE_ITEM_EXT
{
	uint32_t	dwID;						// 01 Encoded item number: first 2 digits = item type, next 2 digits = equip position (used to determine Plugs or Parts), last 4 digits = item index
	std::string	szHeader;					// 02 Name prefix

	uint32_t	dwBaseID;					// 03

	std::string	szRemark;					// 04 Item description

	uint32_t	dwIDK0;						// 05 TODO: will need to implement this one
	uint32_t	dwIDResrc;					// 06
	uint32_t	dwIDIcon;					// 07

	uint8_t		byMagicOrRare;				// 08 Item attribute (see e_ItemAttrib enum). Is it a magic, rare item, etc.

	int16_t		siDamage;					// 09 Weapon damage
	int16_t		siAttackIntervalPercentage;	// 10 Attack speed (percentage: 100% = normal speed)
	int16_t		siHitRate;					// 11 Hit rate/accuracy (percentage modifier: 20% = 120% chance to hit)
	int16_t		siEvationRate;				// 12 Evasion rate/dodge (percentage modifier: 20% = 120% chance to dodge)

	int16_t		siMaxDurability;			// 13 Maximum durability
	int16_t		siPriceMultiply;			// 14 Purchase price multiplier
	int16_t		siDefense;					// 15 Defense

	int16_t		siDefenseRateDagger;		// 16 Defense against daggers (percentage modifier: 20% = 120% defense)
	int16_t		siDefenseRateSword;			// 17 Defense against swords (percentage modifier: 20% = 120% defense)
	int16_t		siDefenseRateBlow;			// 18 Defense against blunt weapons [maces/clubs] (percentage modifier: 20% = 120% defense)
	int16_t		siDefenseRateAxe;			// 19 Defense against axes (percentage modifier: 20% = 120% defense)
	int16_t		siDefenseRateSpear;			// 20 Defense against spears (percentage modifier: 20% = 120% defense)
	int16_t		siDefenseRateArrow;			// 21 Defense against arrows (percentage modifier: 20% = 120% defense)

	uint8_t		byDamageFire;				// 22 Bonus fire damage
	uint8_t		byDamageIce;				// 23 Bonus ice damage
	uint8_t		byDamageThuner;				// 24 Bonus thunder damage
	uint8_t		byDamagePoison;				// 25 Bonus poison damage

	uint8_t		byStillHP;					// 26 HP drain ("still HP = steal HP")
	uint8_t		byDamageMP;					// 27 MP damage
	uint8_t		byStillMP;					// 28 MP drain
	uint8_t		byReturnPhysicalDamage;		// 29 Physical damage reflection

	uint8_t		bySoulBind;					// 30 Soul bind — percentage chance of dropping this item upon death in one-on-one combat; not currently in use.

	int16_t		siBonusStr;					// 31 Bonus strength
	int16_t		siBonusSta;					// 32 Bonus stamina
	int16_t		siBonusDex;					// 33 Bonus dexterity
	int16_t		siBonusInt;					// 34 Bonus intelligence
	int16_t		siBonusMagicAttak;			// 35 Bonus charisma/magic power
	int16_t		siBonusHP;					// 36 Bonus HP
	int16_t		siBonusMSP;					// 37 Bonus MSP

	int16_t		siRegistFire;				// 38 Fire damage resistance
	int16_t		siRegistIce;				// 39 Ice damage resistance
	int16_t		siRegistElec;				// 40 Electric damage resistance
	int16_t		siRegistMagic;				// 41 Magic damage resistance
	int16_t		siRegistPoison;				// 42 Poison damage resistance
	int16_t		siRegistCurse;				// 43 Curse damage resistance

	uint32_t	dwEffectID1;				// 44 Magic effect ID 1
	uint32_t	dwEffectID2;				// 45 Magic effect ID 2

	int16_t		siNeedLevel;				// 46 Required level (player's iLevel)
	int16_t		siNeedRank;					// 47 Required rank (player's iRank)
	int16_t		siNeedTitle;				// 48 Required title (player's iTitle)
	int16_t		siNeedStrength;				// 49 Required strength
	int16_t		siNeedStamina;				// 50 Required Stamina
	int16_t		siNeedDexterity;			// 51 Required Dexterity
	int16_t		siNeedInteli;				// 52 Required Intelligence
	int16_t		siNeedMagicAttack;			// 53 Required Charisma/Magic power
};

constexpr int MAX_NPC_SHOP_ITEM = 30;
struct __TABLE_NPC_SHOP
{
	uint32_t	dwNPCID;
	std::string	szName;
	uint32_t	dwItems[MAX_NPC_SHOP_ITEM];
};

enum e_ItemType { ITEM_TYPE_PLUG = 1, ITEM_TYPE_PART, ITEM_TYPE_ICONONLY, ITEM_TYPE_GOLD = 9, ITEM_TYPE_SONGPYUN = 10, ITEM_TYPE_UNKNOWN = 0xffffffff };

enum e_ItemPosition {	ITEM_POS_DUAL = 0,	ITEM_POS_RIGHTHAND, ITEM_POS_LEFTHAND,	ITEM_POS_TWOHANDRIGHT,	ITEM_POS_TWOHANDLEFT,
						ITEM_POS_UPPER = 5, ITEM_POS_LOWER,		ITEM_POS_HEAD,		ITEM_POS_GLOVES,		ITEM_POS_SHOES,
						ITEM_POS_EAR = 10,	ITEM_POS_NECK,		ITEM_POS_FINGER,	ITEM_POS_SHOULDER,		ITEM_POS_BELT,
						ITEM_POS_INVENTORY = 15, ITEM_POS_GOLD = 16, ITEM_POS_SONGPYUN = 17,
						ITEM_POS_UNKNOWN = 0xffffffff };
					
enum e_ItemSlot {	ITEM_SLOT_EAR_RIGHT = 0,	ITEM_SLOT_HEAD	= 1,	ITEM_SLOT_EAR_LEFT	= 2,
					ITEM_SLOT_NECK = 3,			ITEM_SLOT_UPPER	= 4,	ITEM_SLOT_SHOULDER	= 5,
					ITEM_SLOT_HAND_RIGHT = 6,	ITEM_SLOT_BELT	= 7,	ITEM_SLOT_HAND_LEFT = 8,
					ITEM_SLOT_RING_RIGHT = 9,	ITEM_SLOT_LOWER = 10,	ITEM_SLOT_RING_LEFT = 11,
					ITEM_SLOT_GLOVES = 12,		ITEM_SLOT_SHOES = 13, 
					ITEM_SLOT_COUNT = 14, ITEM_SLOT_UNKNOWN = 0xffffffff };

// Manages NPC/mob/player appearance
struct __TABLE_PLAYER_LOOKS
{
	uint32_t	dwID;			// NPC resource ID
	std::string	szName;			// Model name
	std::string	szJointFN;		// Joint filename
	std::string	szAniFN;		// Animation filename
	std::string	szPartFNs[10];	// Each character part — upper body, lower body, head, arms, legs, hair, cape
	std::string	szSkinFN;
	std::string	szChrFN;
	std::string	szFXPlugFN;

	int			iIdk1;

	int			iJointRH;		// Joint index for tip of right hand
	int			iJointLH;		// Joint index for tip of left hand
	int			iJointLH2;		// Joint index for left forearm
	int			iJointCloak;	// Joint index for cape attachment

	int			iSndID_Move;
	int			iSndID_Attack0;
	int			iSndID_Attack1;
	int			iSndID_Struck0;
	int			iSndID_Struck1;
	int			iSndID_Dead0;
	int			iSndID_Dead1;
	int			iSndID_Breathe0;
	int			iSndID_Breathe1;
	int			iSndID_Reserved0;
	int			iSndID_Reserved1;

	int			iIdk2;
	int			iIdk3;
	uint8_t		byIdk4;
	uint8_t		byIdk5;
	uint8_t		byIdk6;
};

struct __TABLE_EXCHANGE_QUEST
{
	uint32_t	dwID;				// 01 Quest ID
	uint32_t	dwNpcNum;			// 02 NPC ID
	std::string	szDesc;				// 03 Description
	int			iCondition0;		// 04 Condition 1
	int			iCondition1;		// 05 Condition 2
	int			iCondition2;		// 06 Condition 3
	int			iCondition3;		// 07 Condition 4
	int			iNeedGold;			// 08 Required Gold
	uint8_t		bNeedLevel;			// 09 Required Level
	uint8_t		bNeedClass;			// 10 Required Class
	uint8_t		bNeedRank;			// 11 Required Rank
	uint8_t		bNeedExtra1;		// 12 Required Extra 1
	uint8_t		bNeedExtra2;		// 13 Required Extra 2
	uint8_t		bCreatePercentage;	// 14 Spawn chance (%)
	int			iArkTuarek;			// 15 Arch Tuarek
	int			iTuarek;			// 16 Tuarek
	int			iRinkleTuarek;		// 17 Wrinkle Tuarek
	int			iBabarian;			// 18 Barbarian
	int			iMan;				// 19 Man
	int			iWoman;				// 20 Woman
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Magic Table

struct __TABLE_UPC_SKILL
{
	uint32_t	dwID;				// 01 Skill ID
	std::string	szEngName;			// 02 English name
	std::string	szName;				// 03 Korean name
	std::string	szDesc;				// 04 Description
	int			iSelfAnimID1;		// 05 Start animation (caster)
	int			iSelfAnimID2;		// 06 End animation (caster)

	int			idwTargetAnimID;	// 07 Target animation
	int			iSelfFX1;			// 08 Effect on caster (1)
	int			iSelfPart1;			// 09 Effect position for iSelfFX1
	int			iSelfFX2;			// 10 Effect on caster (2)
	int			iSelfPart2;			// 11 Effect position for iSelfFX2
	int			iFlyingFX;			// 12 Flying effect
	int			iTargetFX;			// 13 Target effect
	int			iTargetPart;		// 14 Effect position for iTargetFX

	int			iTarget;			// 15 Target type/"moral"
	int			iNeedLevel;			// 16 Required player level
	int			iNeedSkill;			// 17 Required skill

	int			iExhaustMSP;		// 18 MSP consumed
	int			iExhaustHP;			// 19 HP consumed

	uint32_t	dwNeedItem;			// 20 Required item (refer to e_ItemClass enum - divide value by 10)
	uint32_t	dwExhaustItem;		// 21 Item consumed
	int			iCastTime;			// 22 Cast time
	int			iReCastTime;		// 23 Cooldown time

	float		fIDK0;				// 24 TODO: will need to implement this...?
	float		fIDK1;				// 25 1298 (unknown purpose)

	int			iPercentSuccess;	// 26 Success rate
	uint32_t	dw1stTableType;		// 27 Primary skill type
	uint32_t	dw2ndTableType;		// 28 Secondary skill type
	int			iValidDist;			// 29 Effective skill range

	int			iIDK2;				// 30 1298 (unknown purpose)
};

struct __TABLE_UPC_SKILL_TYPE_1
{
	uint32_t	dwID;				// 01 Skill ID
	int			iSuccessType;		// 02 Success type
	int			iSuccessRatio;		// 03 Success ratio (%)
	int			iPower;				// 04 Attack power
	int			iDelay;				// 05 Skill delay (time before next action)
	int			iComboType;			// 06 Combo type
	int			iNumCombo;			// 07 Number of hits in combo
	int			iComboDamage;		// 08 Damage per combo hit
	int			iValidAngle;		// 09 Attack radius
	int			iAct[3];			// 10
};

struct __TABLE_UPC_SKILL_TYPE_2
{
	uint32_t	dwID;				// 01 Skill ID
	int			iSuccessType;		// 02 Success type
	int			iPower;				// 03 Attack power
	int			iAddDamage;			// 04 Bonus damage
	int			iAddDist;			// 05 Distance increase
	int			iNumArrow;			// 06 Number of arrows used
};

struct __TABLE_UPC_SKILL_TYPE_3
{
	uint32_t	dwID;				// 01 Skill ID
	int			iRadius;			// 02 Skill radius
	int			iDDType;			// 03 Is this a DoT or a HoT
	int			iStartDamage;		// 04 Initial damage
	int			iDuraDamage;		// 05 Duration damage (e.g. DoT or HoT tick damage)
	int			iDurationTime;		// 06 Effect duration (in seconds)
	int			iAttribute;			// 07 Elemental type
};

struct __TABLE_UPC_SKILL_TYPE_4
{
	uint32_t	dwID;				// 01 Skill ID

	int			iBuffType;			// 02 Buff type
	int			iRadius;			// 03 Buff radius
	int			iDuration;			// 04 Buff duration
	int			iAttackSpeed;		// 05 Attack speed percentage (100% = base attack speed)
	int			iMoveSpeed;			// 06 Movement speed percentage (100% = base movement speed)
	int			iAC;				// 07 Flat defense modifier; mutually exclusive with iACPct.
	int			iACPct;				// 08 Defense percentage (100% = base defense); mutually exclusive with iAC.
	int			iAttack;			// 09 Attack power percentage (100% = base attack power)
	int			iMagicAttack;		// 10 Magic attack power percentage (100% = base magic attack power)
	int			iMaxHP;				// 11 Flat maximum HP modifier; mutually exclusive with iMaxHPPct.
	int			iMaxHPPct;			// 12 Maximum HP percentage (100% = base maximum HP); mutually exclusive with iMaxHP.
	int			iMaxMP;				// 13 Flat maximum MP modifier; mutually exclusive with iMaxMPPct.
	int			iMaxMPPct;			// 14 Maximum MP percentage (100% = base maximum MP); mutually exclusive with iMaxMP.
	int			iStr;				// 15 Flat strength modifier
	int			iSta;				// 16 Flat stamina modifier
	int			iDex;				// 17 Flat dexterity modifier
	int			iInt;				// 18 Flat intelligence modifier
	int			iMAP;				// 19 Flat charisma/magic power modifier
	int			iFireResist;		// 20 Flat fire resistance modifier
	int			iColdResist;		// 21 Flat cold resistance modifier
	int			iLightningResist;	// 22 Flat lightning resistance modifier
	int			iMagicResist;		// 23 Flat magic resistance modifier
	int			iDeseaseResist;		// 24 Flat disease/curse resistance modifier
	int			iPoisonResist;		// 25 Flat poison resistance modifier

	int			iExpPct;			// 26 Experience gain percentage (100% = base experience gain)
};

struct __TABLE_UPC_SKILL_TYPE_6
{
	uint32_t		dwID;				// 01 Skill ID
	std::string		szEngName;			// 02 Transformation name (English)
	std::string		szName;				// 03 Transformation name (Korean)
	int32_t			iSize;				// 04 Size (%)
	int32_t			iTransformID;		// 05 Model ID
	int32_t			iDuration;			// 06 Duration (in seconds)
	int32_t			iMaxHP;				// 07 Flat max HP - 0 if unused
	int32_t			iMaxMP;				// 08 Flat max MP - 0 if unused
	int32_t			iSpeed;				// 09 Movement speed - 0 if unused
	int32_t			iAttackSpeed;		// 10 Attack speed - 0 if unused
	int32_t			iAttack;			// 11 Attack damage - 0 if unused
	int32_t			iAC;				// 12 Defense - 0 if unused
	int32_t			iHitRate;			// 13 Hit rate (accuracy) - 0 if unused
	int32_t			iEvasionRate;		// 14 Evasion rate (dodge) - 0 if unused
	int32_t			iFireResist;		// 15 Flat fire resistance modifier
	int32_t			iColdResist;		// 16 Flat cold resistance modifier
	int32_t			iLightningResist;	// 17 Flat lightning resistance modifier
	int32_t			iMagicResist;		// 18 Flat magic resistance modifier
	int32_t			iCurseResist;		// 19 Flat disease/curse resistance modifier
	int32_t			iPoisonResist;		// 20 Flat poison resistance modifier
	uint8_t			byNeedItem;			// 21 Item type required for transformation
	uint32_t		dwClass;			// 22 Classes allowed for transformation
	uint32_t		dwUserSkillUse;		// 23
	uint32_t		dwSkillSuccessRate;	// 24 NOTE: These columns may be shuffled slightly, the naming is based on the server data
	uint32_t		dwMonsterFriendly;	// 25
	uint8_t			byNation;			// 26
	uint32_t		dwRightHand;		// 27 
	uint32_t		dwLeftHand;			// 28
};

struct __TABLE_UPC_SKILL_TYPE_7
{
	uint32_t	dwID;					// 01 Skill ID
	int32_t		iRadius;				// 02 Radius
};

struct __TABLE_UPC_SKILL_TYPE_9
{
	uint32_t		dwID;				// 01 ID
	// TODO: Fill out this struct
};

// Magic Table
///////////////////////////////////////////////////////////////////////////////////////////////////////////

struct __TABLE_QUEST_MENU
{
	uint32_t	dwID;		// 01 ID
	std::string szMenu;		// 02 Menu text
};

struct __TABLE_QUEST_TALK
{
	uint32_t	dwID;		// 01 ID
	std::string szTalk;		// 02 Dialogue text
};

struct __TABLE_QUEST_CONTENT
{
	uint32_t		dwID;
	int				iReqLevel;
	int				iReqClass;
	std::string		szName;
	std::string		szDesc;
	std::string		szReward;
};

struct __TABLE_HELP
{
	DWORD		dwID;
	int			iMinLevel;
	int			iMaxLevel;
	int			iReqClass;
	std::string	szQuestName;
	std::string	szQuestDesc;
};

constexpr int MAX_ITEM_SLOT_OPC				= 8;	// Max equipment slots for other players (including NPCs): 0-4 = upper body, lower body, helmet, arms, legs; 5 = cloak; 6 = right hand; 7 = left hand

constexpr int MAX_ITEM_INVENTORY			= 28;	// Max items a player can hold in their inventory
constexpr int MAX_ITEM_TRADE				= 24;	// Max items per page in NPC trades
constexpr int MAX_ITEM_TRADE_PAGE			= 12;
constexpr int MAX_ITEM_WARE_PAGE			= 8;
constexpr int MAX_ITEM_PER_TRADE			= 12;	// Max items in a player trading window
constexpr int MAX_ITEM_BUNDLE_DROP_PIECE	= 6;
constexpr int MAX_ITEM_EX_RE_NPC			= 4;	// Max items in the (outdated, unused) NPC exchange/repair UI.

constexpr int MAX_SKILL_FROM_SERVER			= 9;	// Max number of skill point slots received from the server.

constexpr int MAX_SKILL_KIND_OF				= 5;	// Total skill types: 1 - base skills, 4 - specialized skills
constexpr int MAX_SKILL_IN_PAGE				= 6;	// Max number of of skill icons per page
constexpr int MAX_SKILL_PAGE_NUM			= 7;	// Max number of pages per skill category

constexpr int MAX_SKILL_HOTKEY_PAGE			= 8;	// Max pages for a skill bar (CUIHotKeyDlg).
constexpr int MAX_SKILL_IN_HOTKEY			= 8;	// Max number of skill icons per page for a skill bar (CUIHotKeyDlg).

constexpr int MAX_AVAILABLE_CHARACTER		= 3;	// Max character slots available per server

// Sound IDs
constexpr int ID_SOUND_ITEM_ETC_IN_INVENTORY	= 2000;
constexpr int ID_SOUND_ITEM_IN_REPAIR			= 2001;
constexpr int ID_SOUND_ITEM_WEAPON_IN_INVENTORY = 2002;
constexpr int ID_SOUND_ITEM_ARMOR_IN_INVENTORY	= 2003;
constexpr int ID_SOUND_GOLD_IN_INVENTORY		= 3000;
constexpr int ID_SOUND_SKILL_THROW_ARROW		= 5500;
constexpr int ID_SOUND_BGM_TOWN					= 20000;
constexpr int ID_SOUND_BGM_KA_BATTLE			= 20002;
constexpr int ID_SOUND_BGM_EL_BATTLE			= 20003;
constexpr int ID_SOUND_CHR_SELECT_ROTATE		= 2501;

constexpr float SOUND_RANGE_TO_SET				= 10.0f;
constexpr float SOUND_RANGE_TO_RELEASE			= 20.0f;

constexpr float STUN_TIME						= 3.0f;

enum e_Behavior {	BEHAVIOR_NOTHING = 0,
					BEHAVIOR_EXIT,						// Exit the game
					BEHAVIOR_RESTART_GAME,				// Return to character selection
					BEHAVIOR_REGENERATION,				// Respawn/revive character
					BEHAVIOR_PERSONAL_TRADE_CANCEL,		// Private trade: Cancel a request (outdated & unused)

					BEHAVIOR_PARTY_PERMIT,				// Accept a party invite from another player.
					BEHAVIOR_PARTY_DISBAND,				// Leave/disband party
					BEHAVIOR_FORCE_PERMIT,				// Accept a force/squad invite from another player
					BEHAVIOR_FORCE_DISBAND,				// Leave/disband force/squad

					BEHAVIOR_REQUEST_BINDPOINT,			// Return to binding point

					BEHAVIOR_DELETE_CHR,

					BEHAVIOR_KNIGHTS_CREATE,
					BEHAVIOR_KNIGHTS_DESTROY,			// Disband clan
					BEHAVIOR_KNIGHTS_WITHDRAW,			// Leave clan

					BEHAVIOR_PERSONAL_TRADE_FMT_WAIT,	// Private trade: Wait for other player to accept our trade request [does nothing].
					BEHAVIOR_PERSONAL_TRADE_PERMIT,		// Private trade: Accept a trade request from another player.

					BEHAVIOR_MGAME_LOGIN,
					
					BEHAVIOR_CLAN_JOIN,
					BEHAVIOR_PARTY_BBS_REGISTER,		// Register on party bulletin board (i.e. seeking party board)
					BEHAVIOR_PARTY_BBS_REGISTER_CANCEL, // Unregister from party bulletin board (i.e. seeking party board)

					BEHAVIOR_EXECUTE_OPTION,			// Exit game and open options.
				
					BEHAVIOR_UNKNOWN = 0xffffffff
				};

enum e_SkillMagicTaget	{	SKILLMAGIC_TARGET_SELF = 1,					// Targets myself
							SKILLMAGIC_TARGET_FRIEND_WITHME = 2,		// Targets an ally (includes myself)
							SKILLMAGIC_TARGET_FRIEND_ONLY = 3,			// Targets an ally (excludes myself)
							SKILLMAGIC_TARGET_PARTY = 4,				// Targets a party member (includes myself)
							SKILLMAGIC_TARGET_NPC_ONLY = 5,				// Targets an NPC only
							SKILLMAGIC_TARGET_PARTY_ALL = 6,			// Targets the entire party (includes myself)
							SKILLMAGIC_TARGET_ENEMY_ONLY = 7,			// Targets only enemies (anything hostile, including NPCs)
							SKILLMAGIC_TARGET_ALL = 8,					// Targets anyone (includes myself)
							
							SKILLMAGIC_TARGET_AREA_ENEMY = 10,			// Targets enemies in an area
							SKILLMAGIC_TARGET_AREA_FRIEND = 11,			// Targets allies in an area
							SKILLMAGIC_TARGET_AREA_ALL = 12,			// Targets anyone in an area
							SKILLMAGIC_TARGET_AREA = 13,				// Targets anyone in an area centered around myself
							SKILLMAGIC_TARGET_DEAD_FRIEND_ONLY = 25,	// Targets dead allies (excluding myself)
							
							SKILLMAGIC_TARGET_UNKNOWN = 0xffffffff
						};

// define fx...
struct __TABLE_FX
{
	uint32_t		dwID;		// 01 ID
	std::string		szName;		// 02 Effect name
	std::string		szFN;		// 03 Effect filename
	uint32_t		dwSoundID;	// 04 Sound ID
	uint8_t			byAOE;		// 05 AOE ??
};

constexpr int	MAX_COMBO = 3;

constexpr int   FXID_CLASS_CHANGE				= 603;
constexpr int	FXID_BLOOD						= 10002;
constexpr int	FXID_LEVELUP_KARUS				= 10012;
constexpr int	FXID_LEVELUP_ELMORAD			= 10018;
constexpr int	FXID_REGEN_ELMORAD				= 10019;
constexpr int	FXID_REGEN_KARUS				= 10020;
constexpr int	FXID_SWORD_FIRE_MAIN			= 10021;
constexpr int	FXID_SWORD_FIRE_TAIL			= 10022;
constexpr int	FXID_SWORD_FIRE_TARGET			= 10031;
constexpr int	FXID_SWORD_ICE_MAIN				= 10023;
constexpr int	FXID_SWORD_ICE_TAIL				= 10024;
constexpr int	FXID_SWORD_ICE_TARGET			= 10032;
constexpr int	FXID_SWORD_LIGHTNING_MAIN		= 10025;
constexpr int	FXID_SWORD_LIGHTNING_TAIL		= 10026;
constexpr int	FXID_SWORD_LIGHTNING_TARGET		= 10033;
constexpr int	FXID_SWORD_POISON_MAIN			= 10027;
constexpr int	FXID_SWORD_POISON_TAIL			= 10028;
constexpr int	FXID_SWORD_POISON_TARGET		= 10034;
//constexpr int	FXID_GROUND_TARGET = 10035;
constexpr int	FXID_REGION_TARGET_EL_ROGUE		= 10035;
constexpr int	FXID_REGION_TARGET_EL_WIZARD	= 10036;
constexpr int	FXID_REGION_TARGET_EL_PRIEST	= 10037;
constexpr int	FXID_REGION_TARGET_KA_ROGUE		= 10038;
constexpr int	FXID_REGION_TARGET_KA_WIZARD	= 10039;
constexpr int	FXID_REGION_TARGET_KA_PRIEST	= 10040;
constexpr int	FXID_CLAN_RANK_1				= 10041;
constexpr int	FXID_WARP_KARUS					= 10046;
constexpr int	FXID_WARP_ELMORAD				= 10047;
constexpr int	FXID_REGION_POISON				= 10100;
constexpr int	FXID_TARGET_POINTER				= 30001;
constexpr int	FXID_ZONE_POINTER				= 30002;

enum e_SkillMagicType4	{	BUFFTYPE_MAXHP = 1,				// Max HP
							BUFFTYPE_AC = 2,				// Defense
							BUFFTYPE_RESIZE = 3,			// Character size
							BUFFTYPE_ATTACK = 4,			// Attack power
							BUFFTYPE_ATTACKSPEED = 5,		// Attack speed
							BUFFTYPE_SPEED = 6,				// Movement speed
							BUFFTYPE_ABILITY = 7,			// Base stats (str, sta, dex, int, cha)
							BUFFTYPE_RESIST = 8,			// Resistances (fire, ice, lightning, etc.)
							BUFFTYPE_HITRATE_AVOIDRATE = 9,	// Hit rate / evasion rate
							BUFFTYPE_TRANS = 10,			// Transformation/invisibility
							BUFFTYPE_SLEEP = 11,			// Puts to sleep
							BUFFTYPE_EYE = 12				// Vision-related							
};

enum e_SkillMagicType3	{	DDTYPE_TYPE3_DUR_OUR = 100,
							DDTYPE_TYPE3_DUR_ENEMY = 200
};

// Special items associated with skill usage
constexpr uint32_t ITEM_ID_MASTER_SCROLL_WARRIOR	= 379063000;
constexpr uint32_t ITEM_ID_MASTER_SCROLL_ROGUE		= 379064000;
constexpr uint32_t ITEM_ID_MASTER_SCROLL_MAGE		= 379065000;
constexpr uint32_t ITEM_ID_MASTER_SCROLL_PRIEST		= 379066000;

constexpr uint32_t ITEM_ID_STONE_OF_WARRIOR			= 379059000;
constexpr uint32_t ITEM_ID_STONE_OF_ROGUE			= 379060000;
constexpr uint32_t ITEM_ID_STONE_OF_MAGE			= 379061000;
constexpr uint32_t ITEM_ID_STONE_OF_PRIEST			= 379062000;

//definitions related clan....
constexpr int	CLAN_LEVEL_LIMIT		= 20;
constexpr int	CLAN_COST				= 500000;
constexpr uint32_t KNIGHTS_FONT_COLOR	= 0xffff0000; // Clan name font color

enum e_Cursor		{	CURSOR_ATTACK,
						CURSOR_EL_NORMAL,
						CURSOR_EL_CLICK,
						CURSOR_KA_NORMAL,
						CURSOR_KA_CLICK,
						CURSOR_PRE_REPAIR,
						CURSOR_NOW_REPAIR,
						CURSOR_COUNT,
						CURSOR_UNKNOWN = 0xffffffff
					};

#endif // end of #define __GAME_DEF_H_

// ===== END WarFare/GameDef.h =====

// ===== BEGIN WarFare/GameEng.cpp =====
#line 1 "WarFare/GameEng.cpp"
﻿// GameEng.cpp: implementation of the CGameEng class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameEng.h"
#include "GameBase.h"
#include "N3WorldManager.h"

#include <N3Base/N3Camera.h>
#include <N3Base/N3Light.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

const float LIGHTNING_DURATION = 2.0f;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CGameEng::CGameEng()
{
	m_pActiveCam	= nullptr;

	// 프로그램이 실행된 경로..
	char szBuf[_MAX_PATH];
	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
	::GetModuleFileName(nullptr, szBuf, _MAX_PATH);
	_splitpath(szBuf, szDrive, szDir, nullptr, nullptr);
	_makepath(szBuf, szDrive, szDir, nullptr, nullptr);

	///////////////////////////////////////////////////////////////
	// 기본 카메라 세팅..
	CN3Camera* pCamera			= new CN3Camera();
	pCamera->m_bFogUse			= TRUE;
	pCamera->m_Data.fFOV		= DegreesToRadians(70);
	pCamera->m_Data.fNP			= 0.7f;
	pCamera->m_Data.fFP			= 512.0f;
	this->CameraAdd(pCamera);
	this->SetActiveCamera(pCamera);

	m_vEyeToReach = pCamera->EyePos();
	m_vAtToReach = pCamera->AtPos();

//	m_eViewPoint = VP_BACKWARD; // 기본은 1.5인칭(플레이어 뒤에서 바라본 모습)으로 시작.
	m_eViewPoint = VP_THIRD_PERSON; // 기본은 3인칭으로 시작.
	m_fRotPitchFirstPerson = 0.0f; // 일인칭 시점일때 카메라 피치 각도.
	m_fRotPitchBackward = 0.0f; // 삼인칭 시점일때 카메라 피치 각도.
	m_fRotPitchFoward = 0.0f; // 앞에서 본 시점일때  카메라 피치 각도.
	m_fRotPitchThirdFirson = DegreesToRadians(25.0f);
	m_fOffsetVPGod = 7.0f; // 위에서 본시점일때 카메라 거리..
	m_fRotYawVPGod = 0.0f; // 위에서 바라본 시점일 경우에 카메라 회전각도..
	m_fZoomBackwardOrFoward = 1.0f; // 1.5인칭, 앞에서 본 시점일때 카메라 Zoom 1.0f 가 기준이다.
	// 기본 카메라 세팅..
	///////////////////////////////////////////////////////////////

	m_fLightningTimeRemain = 0.0f; // 번개 칠때 타이머..

	///////////////////////////////////////////////////////////////
	// 기본 라이트 세팅
	/*
	D3DCOLORVALUE crLgt;

	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.8f;
	CN3Light* pLightGlobal = new CN3Light(); // 전체를 비출 라이트..
	pLightGlobal->m_Data.InitDirection(0, __Vector3(0,-1,0), crLgt);
	this->LightAdd(pLightGlobal);

	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.5f;
	CN3Light* pLightGlobal2 = new CN3Light(); // 반대 편에서 전체를 비출 라이트..
	pLightGlobal2->m_Data.InitDirection(1, __Vector3(0,1,0), crLgt);
	this->LightAdd(pLightGlobal2);

	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.3f;
	CN3Light* pLight = new CN3Light(); // 카메라와 붙어 다닌다...
	pLight->m_Data.InitPoint(2, __Vector3(0,0,0), crLgt, 32.0f);
	this->LightAdd(pLight);
	*/
	// 기본 라이트 세팅
	///////////////////////////////////////////////////////////////
	m_pRefLightSun = nullptr;
	m_pRefLightSupport = nullptr;
	m_pRefLightCam = nullptr;

	m_fFPDeltaCur = 1.0f; // 현재 
	m_fFPDeltaToReach = 1.0f; // 이값을 목표로 해서 변한다.

//	m_fLightDeltaCur = 1.0f;
//	m_fLightDeltaToReach = 1.0f; // 이값을 목표로 해서 변한다.
}

CGameEng::~CGameEng()
{
	for (CN3Camera* pCamera : m_Cameras)
		delete pCamera;
	m_Cameras.clear();

/*	it_Light itLgt = m_Lights.begin();
	iSize = m_Lights.size();
	for(i = 0; i < iSize; i++, itLgt++)
	{
		delete *itLgt; 
	}
	m_Lights.clear();

	itLgt = m_LightsBackup.begin();
	iSize = m_LightsBackup.size();
	for(i = 0; i < iSize; i++, itLgt++)
	{
		delete *itLgt; 
	}
	m_LightsBackup.clear();
*/
}

/*
void CGameEng::RestoreLighting()
{
	m_Lights.clear();	
	it_Light itLgt = m_LightsBackup.begin();
	while( itLgt != m_LightsBackup.end() )
	{
		CN3Light* pLgt = *itLgt++;
		m_Lights.push_back(pLgt);
	}
	m_LightsBackup.clear();
}

void CGameEng::BackupReleaseLighting()
{
	m_LightsBackup.clear();
	it_Light itLgt = m_Lights.begin();
	while( itLgt != m_Lights.end() )
	{
		CN3Light* pLgt = *itLgt++;
		m_LightsBackup.push_back(pLgt);
	}
	m_Lights.clear();
}
*/

void CGameEng::SetDefaultLight(CN3Light* pSun, CN3Light* pSupport, CN3Light* pCam)
{
	m_pRefLightSun = pSun;
	m_pRefLightSupport = pSupport;
	m_pRefLightCam = pCam;
}

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

void CGameEng::Tick(const D3DCOLOR* crDiffuses,			// Diffuse 라이트 색깔.. 3 개 쓴다.
					const D3DCOLOR* crAmbients,			// Ambient 라이트 색깔.. 3 개 쓴다.
					const D3DCOLOR crFog,				// 안개 색깔..
					const __Vector3& vPosPlayer,		// 플레이어 위치
					const __Quaternion& qtPlayer,		// 회전 쿼터니언
					float fHeightPlayer,				// 키를 인수로 넣으면 카메라와 라이트 처리..
					float fSunRadianZ)					// 해의 Z 각도..
{
	if(nullptr == m_pActiveCam) return;

	float fRadius = fHeightPlayer * 2.0f;
	float fYaw = 0;
	__Quaternion qtRot = qtPlayer;
	__Vector3 vAxis(0,1,0);
	qtRot.AxisAngle(vAxis, fYaw);
	
	if(vAxis.y < 0) // 회전축이 음수이면.
	{
		vAxis.y *= -1.0f;
		fYaw *= -1.0f;
	}

	switch(m_eViewPoint)
	{
		case VP_BACKWARD:
		{
			qtRot.RotationYawPitchRoll(fYaw, m_fRotPitchBackward, 0);
			__Matrix44 mtxRot = qtRot;

			m_vEyeToReach.Set(0, 0, -(fRadius / s_CameraData.fFOV) * m_fZoomBackwardOrFoward);
			m_vAtToReach = vPosPlayer; m_vAtToReach.y += fHeightPlayer * 0.8f;
			m_vEyeToReach = m_vAtToReach + (m_vEyeToReach * mtxRot);
		}
		break;
		case VP_FIRST_PERSON:
		{
			qtRot.RotationYawPitchRoll(fYaw, m_fRotPitchFirstPerson, 0);
			__Matrix44 mtxRot = qtRot;

			m_vEyeToReach = vPosPlayer; m_vEyeToReach.y += fHeightPlayer - 0.1f;
			m_vAtToReach.Set(0,0,1);
			m_vAtToReach = m_vEyeToReach + (m_vAtToReach * mtxRot);
		}
		break;
		case VP_FOWARD:
		{
			qtRot.RotationYawPitchRoll(fYaw, -m_fRotPitchFoward, 0);
			__Matrix44 mtxRot = qtRot;

			m_vEyeToReach.Set(0, 0, fRadius * m_fZoomBackwardOrFoward);
			m_vAtToReach = vPosPlayer; m_vAtToReach.y += fHeightPlayer * 0.8f;
			m_vEyeToReach = m_vAtToReach + (m_vEyeToReach * mtxRot);
		}
		break;
		case VP_THIRD_PERSON:
		{
			qtRot.RotationYawPitchRoll(m_fRotYawVPGod, m_fRotPitchThirdFirson, 0);
			__Matrix44 mtxRot = qtRot;

			m_vAtToReach = vPosPlayer; m_vAtToReach.y += fHeightPlayer * 0.8f;
			m_vEyeToReach.Set(0,0,-m_fOffsetVPGod);
			m_vEyeToReach = m_vAtToReach + (m_vEyeToReach * mtxRot);
		}
		break;
	}

	////////////////////////////////////////////////////////////////////////////////////
	// 카메라 충돌 체크...
	if(VP_FIRST_PERSON == m_eViewPoint) // 일인칭때는 충돌체크 안한다.
	{
		m_pActiveCam->LookAt(m_vEyeToReach, m_vAtToReach, __Vector3(0,1,0)); // 처다본다..
	}
	else
	{
		__Vector3 vEyeResult = m_vEyeToReach;
		float fNP = m_pActiveCam->m_Data.fNP;
		CGameBase::ACT_WORLD->CheckCollisionCameraWithTerrain(vEyeResult, m_vAtToReach, fNP); // 지형과 충돌체크
		CGameBase::ACT_WORLD->CheckCollisionCameraWithShape(vEyeResult, m_vAtToReach, fNP); // 오브젝트와 충돌체크..
		m_pActiveCam->LookAt(vEyeResult, m_vAtToReach, __Vector3(0,1,0)); // 처다본다..
	}
	// 카메라 충돌 체크...
	////////////////////////////////////////////////////////////////////////////////////


	// 파 플레인 값을 조정..
	// ApplyCameraAndLight 에서 실제로 안개등의 값을 조절한다.
	if(m_fFPDeltaCur != m_fFPDeltaToReach)
	{
		float fFPChange = (m_fFPDeltaToReach - m_fFPDeltaCur) * s_fSecPerFrm / 5.0f; // 5초동안 변하게 한다.
		m_fFPDeltaCur += fFPChange;

		if(fFPChange < 0 && m_fFPDeltaCur < m_fFPDeltaToReach) m_fFPDeltaCur = m_fFPDeltaToReach;
		if(fFPChange > 0 && m_fFPDeltaCur > m_fFPDeltaToReach) m_fFPDeltaCur = m_fFPDeltaToReach;
	}
	float fFPToRestore = m_pActiveCam->m_Data.fFP;
	m_pActiveCam->m_Data.fFP = s_Options.iViewDist * m_fFPDeltaCur;
	
	m_pActiveCam->m_FogColor = crFog; // 안개색을 맞춘다..
	m_pActiveCam->Tick(); // 적용및 사면체등등의 값들을 계산..

	__Matrix44 mtxRotSun;
	mtxRotSun.RotationZ(fSunRadianZ); // 해의 각도에 맞춘다..

	/*
	it_Light itLgt = m_Lights.begin();
	int iSize = m_Lights.size();
	for(int i = 0; i < iSize; i++, itLgt++)
	{
		CN3Light* pLight = *itLgt;
		__ASSERT(pLight, "Light pointer is NULL!!!");
		
		if(0 == pLight->m_Data.nNumber) // 기본 디렉셔널 라이트
		{
			// View Matrix 각도와 방향을 맞춘다..
//			__Vector3 vDir(0.0f,-1.5f,1.0f);
//			vDir.Normalize();
//			__Matrix44 mtxVI = s_CameraData.mtxViewInverse;
//			mtxVI.PosSet(0,0,0);
//			pLight->m_Data.Direction = vDir * mtxVI;

			// 해와 방향을 맞춘다..
			__Matrix44 mtxRot; mtxRot.RotationZ(fSunRadianZ);
			__Vector3 vDir(-1,0,1);
			vDir *= mtxRot;
			vDir.Normalize();
			pLight->m_Data.Direction = vDir;
			
			// 라이트 컬러 적용..
			pLight->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[0]);
			pLight->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[0]);
		}
		else if(1 == pLight->m_Data.nNumber)
		{
			__Vector3 vDir(2,-3, 2); // 위에서 아래로 ...
			vDir.Normalize();
			pLight->m_Data.Direction = vDir;
			
			// 라이트 컬러 적용..
			pLight->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[1]);
			pLight->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[1]);
		}
		else if(2 == pLight->m_Data.nNumber)
		{
			__Vector3 vPos = s_CameraData.vEye;
			vPos.y += 16.0f;
			pLight->PosSet(vPos); // 카메라 위에 가게 한다..
			
			// 라이트 컬러 적용..
			pLight->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[2]);
			pLight->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[2]);
		}


		// 번개 처리..
		if(m_fLightningTimeRemain > 0)
		{
			float fLightningDelta = 0;

			if(m_fLightningTimeRemain > LIGHTNING_DURATION * 0.8f)
				fLightningDelta = (m_fLightningTimeRemain - LIGHTNING_DURATION * 0.8f) / (LIGHTNING_DURATION * 0.2f);
			else
				fLightningDelta = m_fLightningTimeRemain / (LIGHTNING_DURATION * 0.8f);

			pLight->m_Data.Diffuse.r += (1.0f - pLight->m_Data.Diffuse.r) * fLightningDelta * 0.4f;
			pLight->m_Data.Diffuse.g += (1.0f - pLight->m_Data.Diffuse.g) * fLightningDelta * 0.5f;
			pLight->m_Data.Diffuse.b += (1.0f - pLight->m_Data.Diffuse.b) * fLightningDelta;

			m_fLightningTimeRemain -= CN3Base::s_fSecPerFrm;
			if(m_fLightningTimeRemain < 0) m_fLightningTimeRemain = 0;
		}

		pLight->Tick();
	}
	*/
	if(m_pRefLightSun)
	{
		// 해와 방향을 맞춘다..
		__Matrix44 mtxRot; mtxRot.RotationZ(fSunRadianZ);
		__Vector3 vDir(-1,0,1);
		vDir *= mtxRot;
		vDir.Normalize();
		m_pRefLightSun->m_Data.Direction = vDir;
		
		// 라이트 컬러 적용..
		m_pRefLightSun->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[0]);
		m_pRefLightSun->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[0]);

		// 번개 처리..
		if(m_fLightningTimeRemain > 0)
		{
			float fLightningDelta = 0;

			if(m_fLightningTimeRemain > LIGHTNING_DURATION * 0.8f)
				fLightningDelta = (m_fLightningTimeRemain - LIGHTNING_DURATION * 0.8f) / (LIGHTNING_DURATION * 0.2f);
			else
				fLightningDelta = m_fLightningTimeRemain / (LIGHTNING_DURATION * 0.8f);

			m_pRefLightSun->m_Data.Diffuse.r += (1.0f - m_pRefLightSun->m_Data.Diffuse.r) * fLightningDelta * 0.4f;
			m_pRefLightSun->m_Data.Diffuse.g += (1.0f - m_pRefLightSun->m_Data.Diffuse.g) * fLightningDelta * 0.5f;
			m_pRefLightSun->m_Data.Diffuse.b += (1.0f - m_pRefLightSun->m_Data.Diffuse.b) * fLightningDelta;

			m_fLightningTimeRemain -= CN3Base::s_fSecPerFrm;
			if(m_fLightningTimeRemain < 0) m_fLightningTimeRemain = 0;
		}
	}
	if(m_pRefLightSupport)
	{
		__Vector3 vDir(2,-3, 2); // 위에서 아래로 ...
		vDir.Normalize();
		m_pRefLightSupport->m_Data.Direction = vDir;
		
		// 라이트 컬러 적용..
		m_pRefLightSupport->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[1]);
		m_pRefLightSupport->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[1]);

		// 번개 처리..
		if(m_fLightningTimeRemain > 0)
		{
			float fLightningDelta = 0;

			if(m_fLightningTimeRemain > LIGHTNING_DURATION * 0.8f)
				fLightningDelta = (m_fLightningTimeRemain - LIGHTNING_DURATION * 0.8f) / (LIGHTNING_DURATION * 0.2f);
			else
				fLightningDelta = m_fLightningTimeRemain / (LIGHTNING_DURATION * 0.8f);

			m_pRefLightSupport->m_Data.Diffuse.r += (1.0f - m_pRefLightSupport->m_Data.Diffuse.r) * fLightningDelta * 0.4f;
			m_pRefLightSupport->m_Data.Diffuse.g += (1.0f - m_pRefLightSupport->m_Data.Diffuse.g) * fLightningDelta * 0.5f;
			m_pRefLightSupport->m_Data.Diffuse.b += (1.0f - m_pRefLightSupport->m_Data.Diffuse.b) * fLightningDelta;

			m_fLightningTimeRemain -= CN3Base::s_fSecPerFrm;
			if(m_fLightningTimeRemain < 0) m_fLightningTimeRemain = 0;
		}
	}
	if(m_pRefLightCam)
	{
		__Vector3 vPos = s_CameraData.vEye;
		vPos.y += 16.0f;
		m_pRefLightCam->PosSet(vPos); // 카메라 위에 가게 한다..
		
		// 라이트 컬러 적용..
		m_pRefLightCam->m_Data.Diffuse = ::_D3DCOLOR_To_D3DCOLORVALUE(crDiffuses[2]);
		m_pRefLightCam->m_Data.Ambient = ::_D3DCOLOR_To_D3DCOLORVALUE(crAmbients[2]);

		// 번개 처리..
		if(m_fLightningTimeRemain > 0)
		{
			float fLightningDelta = 0;

			if(m_fLightningTimeRemain > LIGHTNING_DURATION * 0.8f)
				fLightningDelta = (m_fLightningTimeRemain - LIGHTNING_DURATION * 0.8f) / (LIGHTNING_DURATION * 0.2f);
			else
				fLightningDelta = m_fLightningTimeRemain / (LIGHTNING_DURATION * 0.8f);

			m_pRefLightCam->m_Data.Diffuse.r += (1.0f - m_pRefLightCam->m_Data.Diffuse.r) * fLightningDelta * 0.4f;
			m_pRefLightCam->m_Data.Diffuse.g += (1.0f - m_pRefLightCam->m_Data.Diffuse.g) * fLightningDelta * 0.5f;
			m_pRefLightCam->m_Data.Diffuse.b += (1.0f - m_pRefLightCam->m_Data.Diffuse.b) * fLightningDelta;

			m_fLightningTimeRemain -= CN3Base::s_fSecPerFrm;
			if(m_fLightningTimeRemain < 0) m_fLightningTimeRemain = 0;
		}
	}
}


void CGameEng::ApplyCameraAndLight()
{
	if(m_pActiveCam)
	{
		m_pActiveCam->Apply(); // 위의 거 대신에 하나만 쓴다...
	}
/*
	for(it_Light it = m_Lights.begin(), itEnd = m_Lights.end(); it != itEnd; it++)
	{
		CN3Light* pLight = *it;
		__ASSERT(pLight, "Light pointer is NULL!!!");
		
		pLight->Apply();
	}
*/
}

void CGameEng::ViewPointChange(e_ViewPoint eVP)
{
	if(eVP < VP_BACKWARD || eVP > VP_THIRD_PERSON)
	{
		if(m_eViewPoint < VP_BACKWARD) m_eViewPoint = VP_BACKWARD;
		if(m_eViewPoint >= VP_THIRD_PERSON) m_eViewPoint = VP_THIRD_PERSON;

		int iVP = (int)(m_eViewPoint) + 1;
		if ( iVP > (VP_THIRD_PERSON) ) iVP = VP_BACKWARD;
		m_eViewPoint = (e_ViewPoint)iVP;						// 시점 증가..
	}
	else
	{
		m_eViewPoint = eVP;						// 시점 증가..
	}
}

void CGameEng::CameraPitchAdd(float fRotXPerSec)
{
	if(nullptr == m_pActiveCam) return;
	float fPitchMax = DegreesToRadians(70.0f);
	float fPitchMin = -DegreesToRadians(50.0f);
	if(VP_BACKWARD == m_eViewPoint)
	{
		m_fRotPitchBackward += fRotXPerSec * s_fSecPerFrm;
		if(m_fRotPitchBackward > fPitchMax) m_fRotPitchBackward = fPitchMax; // 아래 보는값
		else if(m_fRotPitchBackward < fPitchMin) m_fRotPitchBackward = fPitchMin; // 위보는 값..
	}
	else if(VP_FIRST_PERSON == m_eViewPoint)
	{
		m_fRotPitchFirstPerson += fRotXPerSec * s_fSecPerFrm;
		if(m_fRotPitchFirstPerson > fPitchMax) m_fRotPitchFirstPerson = fPitchMax; // 아래 보는값
		else if(m_fRotPitchFirstPerson < fPitchMin) m_fRotPitchFirstPerson = fPitchMin; // 위보는 값..
	}
	else if(VP_FOWARD == m_eViewPoint)
	{
		m_fRotPitchFoward += fRotXPerSec * s_fSecPerFrm;
		if(m_fRotPitchFoward > fPitchMax) m_fRotPitchFoward = fPitchMax; // 아래 보는값
		else if(m_fRotPitchFoward < fPitchMin) m_fRotPitchFoward = fPitchMin; // 위보는 값..
	}
	else if(VP_THIRD_PERSON == m_eViewPoint) // 위에서 보는 건 거리만 늘였다 줄였다 한다..
	{
		fPitchMin = DegreesToRadians(10.0f); // 젤 밑에값 한계

		m_fRotPitchThirdFirson += fRotXPerSec * s_fSecPerFrm;
		if(m_fRotPitchThirdFirson > fPitchMax) m_fRotPitchThirdFirson = fPitchMax; // 아래 보는값
		else if(m_fRotPitchThirdFirson < fPitchMin) m_fRotPitchThirdFirson = fPitchMin; // 위보는 값..
	}
}

void CGameEng::CameraYawAdd(float fRotYPerSec)
{
	if(VP_THIRD_PERSON == m_eViewPoint) // 위에서 보는 건 ..
	{
		m_fRotYawVPGod += fRotYPerSec * s_fSecPerFrm; // 위에서 바라본 시점일 경우에 카메라 회전각도..
		return; // 돌아간다!
	}
}

void CGameEng::CameraZoom(float fDelta)
{
	if(nullptr == m_pActiveCam) return;
	if(VP_BACKWARD == m_eViewPoint || VP_FOWARD == m_eViewPoint)
	{
		m_fZoomBackwardOrFoward -= fDelta * s_fSecPerFrm; // 1.5인칭, 앞에서 본 시점일때 카메라 Zoom 1.0f 가 기준이다.
		if(m_fZoomBackwardOrFoward < 0.4f) m_fZoomBackwardOrFoward = 0.4f; // 아래 보는값
		else if(m_fZoomBackwardOrFoward >= 1.6f) m_fZoomBackwardOrFoward = 1.6f;
	}
	else if(VP_THIRD_PERSON == m_eViewPoint) // 위에서 보는 건 거리만 늘였다 줄였다 한다..
	{
		// NOTE (zoom way back): search for "zoom way back" to get here

		m_fOffsetVPGod -= 4.0f * fDelta * s_fSecPerFrm;
		if(m_fOffsetVPGod < 2.0f) m_fOffsetVPGod = 2.0f; // 너무작아지면 멈추고..
		else if(m_fOffsetVPGod > 10.0f) m_fOffsetVPGod = 10.0f; // 너무 커져도 멈추고..
		return; // 돌아간다!
	}
}

void CGameEng::FarPlaneDeltaSet(float fFPDelta, bool bUpdateImmediately)
{
	if(fFPDelta < 0.25f) fFPDelta = 0.25f;
	if(fFPDelta > 1.0f) fFPDelta = 1.0f;

	m_fFPDeltaToReach = fFPDelta;
	if(bUpdateImmediately) m_fFPDeltaCur = fFPDelta;
}

//void CGameEng::LightDeltaSet(float fLightDelta, bool bUpdateImmediately)
//{
//	if(fLightDelta < 0.25f) fLightDelta = 0.25f;
//	if(fLightDelta > 1.0f) fLightDelta = 1.0f;
//
//	m_fLightDeltaToReach = fLightDelta;
//	if(bUpdateImmediately) m_fLightDeltaCur = fLightDelta;
//}

void CGameEng::Lightning()
{
	m_fLightningTimeRemain = LIGHTNING_DURATION; // 번개 칠때 타이머..
}

// ===== END WarFare/GameEng.cpp =====

// ===== BEGIN WarFare/GameEng.h =====
#line 1 "WarFare/GameEng.h"
﻿// GameEng.h: interface for the CGameEng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMEENG_H__5422B19E_D43E_4252_B79B_69323824F3F9__INCLUDED_)
#define AFX_GAMEENG_H__5422B19E_D43E_4252_B79B_69323824F3F9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Eng.h>
#include <list>

typedef std::list<class CN3Light*>::iterator		it_Light;
typedef std::list<class CN3Camera*> ::iterator	it_Camera;

// 카메라 시점
enum e_ViewPoint		{	VP_BACKWARD = 0,			// 플레이어 등 뒤에서 바라본 모습 1.5인칭
							VP_FIRST_PERSON = 1,		// 일인칭
							VP_FOWARD = 2,				// 플레이어 앞에서 바라봄..
							VP_THIRD_PERSON = 3,		// 삼인칭 모드 .. 마우스도 동작함..
							VP_UNKNOWN = 0xffffffff };  // 개발을 위해 카메라만 빠르게....

const float CAMERA_MOVE_SPEED = 5.0f;

class CGameEng : public CN3Eng  
{
protected:
	CN3Light*				m_pRefLightSun;
	CN3Light*				m_pRefLightSupport;
	CN3Light*				m_pRefLightCam;
	//std::list<CN3Light*>	m_Lights;
	//std::list<CN3Light*>	m_LightsBackup;
	std::list<CN3Camera*>	m_Cameras;
	CN3Camera*				m_pActiveCam;

	__Vector3		m_vEyeToReach;
	__Vector3		m_vAtToReach;

	float			m_fFPDeltaCur; // 현재 
	float			m_fFPDeltaToReach; // 이값을 목표로 해서 변한다.

	float			m_fRotPitchBackward; // 1.5인칭 시점일때 카메라 피치 각도.
	float			m_fRotPitchFirstPerson; // 일인칭 시점일때 카메라 피치 각도.
	float			m_fRotPitchFoward; // 앞에서 본 시점일때  카메라 피치 각도.
	float			m_fRotPitchThirdFirson; // 삼인칭 시점 카메라 피치 각도
	
	float			m_fOffsetVPGod; // 위에서 바라본 시점일 경우에 거리..
	float			m_fRotYawVPGod; // 위에서 바라본 시점일 경우에 카메라 회전각도..

	float			m_fZoomBackwardOrFoward; // 1.5인칭, 앞에서 본 시점일때 카메라 Zoom 1.0f 가 기준이다.
	float			m_fLightningTimeRemain; // 번개 칠때 타이머..

	e_ViewPoint		m_eViewPoint; // 카메라 시점.

public:
	void			SetDefaultLight(CN3Light* pSun, CN3Light* pSupport, CN3Light* pCam);
	void			RestoreLighting();
	void			BackupReleaseLighting();
	void			Lightning(); // 번개 치며 라이트 조절하기.
	float			FarPlaneDeltaCur() { return m_fFPDeltaCur; }
	float			FarPlaneDeltaToReach() { return m_fFPDeltaToReach; }
	void			FarPlaneDeltaSet(float fFPDelta, bool bUpdateImmediately);

	// Light 함수들
	//void			LightAdd(CN3Light* pLight) { m_Lights.push_back(pLight); }
	//int				LightCount() { return m_Lights.size(); }
	//CN3Light*		Light(int index);

	// Camera 함수들
	int	CameraCount() const
	{
		return static_cast<int>(m_Cameras.size());
	}

	void CameraSetActiveByIndex(int index)
	{
		CN3Camera* pCam = Camera(index);
		if (pCam != nullptr)
			m_pActiveCam = pCam;
	}

	CN3Camera* CameraGetActive()
	{
		return m_pActiveCam;
	}

	void CameraAdd(CN3Camera* pCamera)
	{
		m_Cameras.push_back(pCamera);
	}

	CN3Camera*		Camera(int index);

	// 추가한것..
	void			ViewPointChange(e_ViewPoint eVP = VP_UNKNOWN);
	e_ViewPoint		ViewPoint() { return m_eViewPoint; } // 시점..
	void			CameraPitchAdd(float fRotXPerSec);
	void			CameraYawAdd(float fRotYPerSec);
	void			CameraZoom(float fDelta);
	float			CameraYaw() { return m_fRotYawVPGod; } // 위에서 바라본 시점일 경우에 카메라 회전각도..
	void			SetActiveCamera(CN3Camera* pCamera) { m_pActiveCam = pCamera; }
	void			Tick(const D3DCOLOR* crDiffuses,			// Diffuse 라이트 색깔..
						const D3DCOLOR* crAmbients,			// Ambient 라이트 색깔..
						const D3DCOLOR crFog,				// 안개 색깔..
						const __Vector3& vPosPlayer,		// 플레이어 위치
						const __Quaternion& qtPlayer,		// 회전 쿼터니언
						float fHeightPlayer,				// 키를 인수로 넣으면 카메라와 라이트 처리..
						float fSunRadianZ);					// 해의 Z 각도..
	void			ApplyCameraAndLight(); // 카메라와 라이트에 세팅된 값 적용. 라이트는 해의 각도에 따라 다르게 한다.

	CGameEng();
	virtual ~CGameEng();

};

/*
inline CN3Light* CGameEng::Light(int index)
{
	if(index < 0 || index >= m_Lights.size()) return nullptr;
	it_Light itLgt = m_Lights.begin();
	for(int i = 0; i < index; i++, itLgt++);

	return *itLgt;
}
*/

inline CN3Camera* CGameEng::Camera(int index)
{
	if (index < 0
		|| index >= static_cast<int>(m_Cameras.size()))
		return nullptr;

	auto it = m_Cameras.begin();
	std::advance(it, index);
	return *it;
}


#endif // !defined(AFX_GAMEENG_H__5422B19E_D43E_4252_B79B_69323824F3F9__INCLUDED_)

// ===== END WarFare/GameEng.h =====

// ===== BEGIN WarFare/GameProcCharacterCreate.cpp =====
#line 1 "WarFare/GameProcCharacterCreate.cpp"
﻿// GameProcCharacterCreate.cpp: implementation of the CGameProcCharacterCreate class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcCharacterCreate.h"
#include "GameEng.h"
#include "UICharacterCreate.h"
#include "UIMessageBox.h"
#include "UIMessageBoxManager.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameCursor.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CGameProcCharacterCreate::CGameProcCharacterCreate()
{
	m_pUICharacterCreate = nullptr;

	s_pPlayer->m_InfoBase.eRace = RACE_UNKNOWN;
	s_pPlayer->m_InfoBase.eClass = CLASS_UNKNOWN;
}

CGameProcCharacterCreate::~CGameProcCharacterCreate()
{
	delete m_pUICharacterCreate;
}

void CGameProcCharacterCreate::Release()
{
	CGameProcedure::Release();

	delete m_pUICharacterCreate; m_pUICharacterCreate = nullptr;

	SetRect(&m_rcChr, 0, 0, 0, 0);
	m_Tbl_InitValue.Release();

	s_pPlayer->m_ChrInv.Release();
	s_pPlayer->m_ChrInv.PartAlloc(PART_POS_COUNT);
	s_pPlayer->m_ChrInv.PlugAlloc(PLUG_POS_COUNT);
}

void CGameProcCharacterCreate::Init()
{
	CGameProcedure::Init();

	SetRect(&m_rcChr, 0, 0, 0, 0);

	m_Tbl_InitValue.LoadFromFile("Data\\NewChrValue.tbl");

	s_pPlayer->m_InfoBase.eRace = RACE_UNKNOWN;
	s_pPlayer->m_InfoBase.eClass = CLASS_UNKNOWN;
	s_pPlayer->m_ChrInv.Release();
	s_pPlayer->m_ChrInv.PartAlloc(PART_POS_COUNT);
	s_pPlayer->m_ChrInv.PlugAlloc(PLUG_POS_COUNT);

	__TABLE_UI_RESRC* pTblUI = s_pTbl_UI.Find(s_pPlayer->m_InfoBase.eNation);
	m_pUICharacterCreate = new CUICharacterCreate();
	m_pUICharacterCreate->Init(s_pUIMgr);
	if(pTblUI) m_pUICharacterCreate->LoadFromFile(pTblUI->szCharacterCreate);
}

void CGameProcCharacterCreate::Render()
{
	s_pEng->Clear(0); // 클리어..
	s_pEng->s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...

	s_pUIMgr->Render();

	s_pPlayer->InventoryChrRender(m_rcChr); // 캐릭터 그리기..

	s_pMsgBoxMgr->Render(); //MessageBox를 그려준다.
	if(s_pGameCursor) s_pGameCursor->Render();

	s_pEng->s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	s_pEng->Present(CN3Base::s_hWndBase);
}

void CGameProcCharacterCreate::SetChr()
{
	__InfoPlayerBase*	pInfoBase = &(s_pPlayer->m_InfoBase);

	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(s_pPlayer->m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..;
	if(nullptr == pLooks) return;

	s_pPlayer->InitChr(pLooks);
	s_pPlayer->m_ChrInv.ScaleSet(1,1,1); // 스케일을 원래대로 돌린다.

	if(pLooks) // 파트 세팅..
	{
		for(int i = 0; i < PART_POS_COUNT; i++)
		{
			if(i == PART_POS_FACE) { s_pPlayer->InitFace(); continue; }
			if(i == PART_POS_HAIR_HELMET) { s_pPlayer->InitHair(); continue; }
			s_pPlayer->PartSet((e_PartPosition)i, pLooks->szPartFNs[i], nullptr, nullptr);
		}
	}
	
	m_pUICharacterCreate->Reset();
	m_pUICharacterCreate->UpdateRaceAndClassButtons(pInfoBase->eRace);
	m_pUICharacterCreate->UpdateClassButtons(pInfoBase->eClass);

	s_pPlayer->InventoryChrAnimationInitialize();
	s_pPlayer->Action(PSA_BASIC, true, nullptr, true);
}

void CGameProcCharacterCreate::SetStats()
{
	__InfoPlayerBase*	pInfoBase = &(s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf*	pInfoExt = &(s_pPlayer->m_InfoExt);
	__TABLE_NEW_CHR* pTbl = nullptr;
	// dwID of InitValue is a concatenation of the race and the class
	uint32_t dwID = pInfoBase->eRace * 10000 + pInfoBase->eClass;
	
	pTbl = m_Tbl_InitValue.Find(dwID);
	if (pTbl)
	{
		pInfoExt->iStrength = pTbl->iStr;
		pInfoExt->iStamina = pTbl->iSta;
		pInfoExt->iDexterity = pTbl->iDex;
		pInfoExt->iIntelligence = pTbl->iInt;
		pInfoExt->iMagicAttak = pTbl->iMAP;
		m_pUICharacterCreate->m_iBonusPoint = pTbl->iBonus;
		m_pUICharacterCreate->m_iMaxBonusPoint = pTbl->iBonus;
	}

	m_pUICharacterCreate->UpdateStats();
}

void CGameProcCharacterCreate::Tick()
{
//	s_pLocalInput->Tick(); // 키보드와 마우스로부터 입력을 받는다.
//	if(dwMouseFlags & MOUSE_LBDOWN) SetCursor(s_hCursorClick);
//	else SetCursor(s_hCursorNormal);

	CGameProcedure::Tick();

	uint32_t dwMouseFlags = s_pLocalInput->MouseGetFlag();
	m_pUICharacterCreate->Tick();
	m_pUICharacterCreate->MouseProc(dwMouseFlags, s_pLocalInput->MouseGetPos(), s_pLocalInput->MouseGetPosOld());

	s_pEng->s_SndMgr.Tick(); // Sound Engine...

	while (!s_pSocket->m_qRecvPkt.empty())
	{
		auto pkt = s_pSocket->m_qRecvPkt.front();
		if (!ProcessPacket(*pkt))
			break;

		delete pkt;
		s_pSocket->m_qRecvPkt.pop();
	}

	s_pPlayer->InventoryChrTick();
}

bool CGameProcCharacterCreate::MsgSendCharacterCreate()
{
	e_ErrorCharacterCreate eErrCode = ERROR_CHARACTER_CREATE_SUCCESS;
	const std::string& szID = s_pPlayer->IDString();

	if (szID.empty())
	{
		eErrCode = ERROR_CHARACTER_CREATE_INVALID_NAME;
	}
	else if(RACE_UNKNOWN == s_pPlayer->m_InfoBase.eRace)
	{
		eErrCode = ERROR_CHARACTER_CREATE_INVALID_RACE;
	}
//	else if(RACE_KA_WRINKLETUAREK == s_pPlayer->m_InfoBase.eRace) // 마법사는 선택 불가능..
//	{
//		eErrCode = ERROR_CHARACTER_CREATE_NOT_SUPPORTED_RACE;
//	}
	else if(CLASS_UNKNOWN == s_pPlayer->m_InfoBase.eClass)
	{
		eErrCode = ERROR_CHARACTER_CREATE_INVALID_CLASS;
	}
	else if(m_pUICharacterCreate->m_iBonusPoint > 0)
	{
		eErrCode = ERROR_CHARACTER_CREATE_REMAIN_BONUS_POINT;
	}
	else
	{
		// 이름에 빈칸이나 특수문자가 들어 있는지 확인
		bool bHasSpecialLetter = false;
		for (char c : szID)
		{
			// CompadmreString(LOCALE_USER_DEFAULT, NORM_IGNOREWIDTH, id, strlen(id), pUser->m_UserId, strlen(pUser->m_UserId) ) == CSTR_EQUAL )
			if(	'~' == c || 
				'`' == c || 
				'!' == c || 
				'@' == c || 
				'#' == c || 
				'$' == c || 
				'%' == c || 
				'^' == c || 
				'&' == c || 
				'*' == c || 
				'(' == c || 
				')' == c || 
//				'_' == c || 
				'-' == c || 
				'+' == c || 
				'=' == c || 
				'|' == c || 
				'\\' == c || 
				'<' == c || 
				'>' == c || 
				',' == c || 
				'.' == c || 
				'?' == c || 
				'/' == c || 
				'{' == c || 
				'[' == c || 
				'}' == c || 
				']' == c ||
				'\"' == c ||
				'\'' == c ||
				' ' == c ) 
			{
				bHasSpecialLetter = true;
				eErrCode = ERROR_CHARACTER_CREATE_INVALID_NAME_HAS_SPECIAL_LETTER;
				break; 
			}
		}

		if(false == bHasSpecialLetter)
		{

			__InfoPlayerBase*	pInfoBase = &(s_pPlayer->m_InfoBase);
			__InfoPlayerMySelf*	pInfoExt = &(s_pPlayer->m_InfoExt);

			uint8_t byBuff[64];
			int iOffset = 0;
			CAPISocket::MP_AddByte(byBuff, iOffset,  WIZ_NEW_CHAR);						// 커멘드.
			CAPISocket::MP_AddByte(byBuff, iOffset, CGameProcedure::s_iChrSelectIndex);	// 캐릭터 인덱스 b
			CAPISocket::MP_AddShort(byBuff, iOffset, static_cast<int16_t>(szID.length())); // Id 길이 s
			CAPISocket::MP_AddString(byBuff, iOffset, s_pPlayer->IDString());			// ID 문자열 str
			CAPISocket::MP_AddByte(byBuff, iOffset, s_pPlayer->m_InfoBase.eRace);		// 종족 b
			CAPISocket::MP_AddShort(byBuff, iOffset, s_pPlayer->m_InfoBase.eClass);		// 직업 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iFace);					// 얼굴모양 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iHair);					// 머리모양 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iStrength);				// 힘 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iStamina);				// 지구력 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iDexterity);				// 민첩 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iIntelligence);			// 지능 b
			CAPISocket::MP_AddByte(byBuff, iOffset, pInfoExt->iMagicAttak);				// 마력 b

			s_pSocket->Send(byBuff, iOffset);								// 보낸다
			
			s_pUIMgr->EnableOperationSet(false); // 패킷이 들어올때까지 UI 를 Disable 시킨다...
			
			return true;
		}
	}

	ReportErrorCharacterCreate(eErrCode); // 에러 보고...

	return false;
}

void CGameProcCharacterCreate::ReportErrorCharacterCreate(e_ErrorCharacterCreate eErrCode)
{
	std::string szErr;

	if (ERROR_CHARACTER_CREATE_NO_MORE_CHARACTER == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_NO_MORE_CHARACTER);
	else if(ERROR_CHARACTER_CREATE_INVALID_NATION_AND_INVALID_RACE == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_INVALID_NATION_RACE);
	else if(ERROR_CHARACTER_CREATE_OVERLAPPED_ID == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_OVERLAPPED_ID);
	else if(ERROR_CHARACTER_CREATE_DB_CREATE == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_DB_CREATE);
	else if(ERROR_CHARACTER_CREATE_INVALID_NAME == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_INVALID_NAME);
	else if(ERROR_CHARACTER_CREATE_INVALID_NAME_HAS_SPECIAL_LETTER == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_INVALID_NAME_HAS_SPECIAL_LETTER);
	else if(ERROR_CHARACTER_CREATE_INVALID_RACE == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_INVALID_RACE);
	else if(ERROR_CHARACTER_CREATE_NOT_SUPPORTED_RACE == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_NOT_SUPPORTED_RACE);
	else if(ERROR_CHARACTER_CREATE_INVALID_CLASS == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_INVALID_CLASS);
	else if(ERROR_CHARACTER_CREATE_REMAIN_BONUS_POINT == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_REMAIN_BONUS_POINT);
	else // if (ERROR_CHARACTER_CREATE_INVALID_STAT_POINT == eErrCode)
		szErr = fmt::format_text_resource(IDS_ERR_UNKNOWN);
	
	std::string szTitle = fmt::format_text_resource(IDS_ERR_CHARACTER_CREATE);
	MessageBoxPost(szErr, szTitle, MB_OK);
}

bool CGameProcCharacterCreate::ProcessPacket(Packet& pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	switch ( iCmd )										// 커멘드에 다라서 분기..
	{
		case WIZ_NEW_CHAR:				// 캐릭터 선택 메시지..
		{
			uint8_t bySuccess = pkt.read<uint8_t>();	// 커멘드 파싱..
			if(0 == bySuccess) 
			{
				ProcActiveSet((CGameProcedure*)s_pProcCharacterSelect); // 캐릭터 선택창으로 가기..
			}
			else // 실패하면.. 이유가 0 이 아닌 값으로 온다..
			{
				this->ReportErrorCharacterCreate((e_ErrorCharacterCreate)bySuccess); // 에러 메시지 띄움..
				s_pUIMgr->EnableOperationSet(false); // UI 조작 가능하게 한다... 다시 캐릭터 만들어야 한다..
			}
			s_pUIMgr->EnableOperationSet(false); // 패킷이 들어올때까지 UI 를 Disable 시킨다...
		}
		return true;
	}
	
	return false;
}

// ===== END WarFare/GameProcCharacterCreate.cpp =====

// ===== BEGIN WarFare/GameProcCharacterCreate.h =====
#line 1 "WarFare/GameProcCharacterCreate.h"
﻿// GameProcCharacterCreate.h: interface for the CGameProcCharacterCreate class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMEPROCCHARACTERCREATE_H__DC02405A_668C_4A6F_A2A5_A050431CF900__INCLUDED_)
#define AFX_GAMEPROCCHARACTERCREATE_H__DC02405A_668C_4A6F_A2A5_A050431CF900__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameProcedure.h"

enum e_ChrValue { CVAL_STR=0, CVAL_STA=1, CVAL_DEX=2, CVAL_INT=3, CVAL_CHA=4, CVAL_BONUS=5, CVAL_NUM=6 }; 
enum e_ErrorCharacterCreate {	ERROR_CHARACTER_CREATE_SUCCESS = 0,
								ERROR_CHARACTER_CREATE_NO_MORE_CHARACTER = 1,
								ERROR_CHARACTER_CREATE_INVALID_NATION_AND_INVALID_RACE = 2,
								ERROR_CHARACTER_CREATE_OVERLAPPED_ID = 3,
								ERROR_CHARACTER_CREATE_DB_CREATE = 4,
								ERROR_CHARACTER_CREATE_INVALID_NAME_HAS_SPECIAL_LETTER = 5, 
								ERROR_CHARACTER_CREATE_INVALID_NAME,
								ERROR_CHARACTER_CREATE_INVALID_RACE,
								ERROR_CHARACTER_CREATE_NOT_SUPPORTED_RACE,
								ERROR_CHARACTER_CREATE_INVALID_CLASS,
								ERROR_CHARACTER_CREATE_REMAIN_BONUS_POINT,
								ERROR_CHARACTER_CREATE_INVALID_STAT_POINT };
					

typedef struct __TABLE_NEW_CHR
{
	uint32_t		dwID;	// NPC 고유 ID
	std::string	szName;	// 종족이름..
	int			iStr;
	int			iSta;
	int			iDex;
	int			iInt;
	int			iMAP; // 마법 공격력 Magic Attack Point
	int			iBonus;
	uint32_t	dwIDK[12];
} TABLE_NEW_CHR;

const int TRIBE_NUM = 8;

class CGameProcCharacterCreate : public CGameProcedure  
{
public:
	class CUICharacterCreate*		m_pUICharacterCreate;
	RECT							m_rcChr;
	CN3TableBase<__TABLE_NEW_CHR>	m_Tbl_InitValue; // 사운드 소스 정보 테이블..
	
//	int						m_InitValue[TRIBE_NUM][CVAL_NUM];

protected:
	virtual bool ProcessPacket(Packet& pkt);

public:
	void ReportErrorCharacterCreate(e_ErrorCharacterCreate eErr);
	bool MsgSendCharacterCreate();
	void RenderChr();
	void SetChr();
	void SetStats();
	
	void Release();
	void Init();
	void Tick();
	void Render();

	CGameProcCharacterCreate();
	virtual ~CGameProcCharacterCreate();
};

#endif // !defined(AFX_GAMEPROCCHARACTERCREATE_H__DC02405A_668C_4A6F_A2A5_A050431CF900__INCLUDED_)

// ===== END WarFare/GameProcCharacterCreate.h =====

// ===== BEGIN WarFare/GameProcCharacterSelect.cpp =====
#line 1 "WarFare/GameProcCharacterSelect.cpp"
﻿// GameProcCharacterSelect.cpp: implementation of the CGameProcCharacterSelect class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcCharacterSelect.h"
#include "GameProcedure.h"
#include "text_resources.h"
#include "PacketDef.h"
#include "GameEng.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "UICharacterSelect.h"
#include "UIMessageBox.h"
#include "UILoading.h"

#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3Shape.h>
#include <N3Base/N3Camera.h>
#include <N3Base/N3Light.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcCharacterSelect::CGameProcCharacterSelect()
{
	m_pCamera = nullptr;
	for ( int i = 0; i < 8; i++ ) m_pLights[i] = nullptr;
	for ( int i = 0; i < MAX_AVAILABLE_CHARACTER; i++ )	{ m_pChrs[i] = nullptr; }
	m_pActiveBg = nullptr;

	m_eCurPos = POS_CENTER;
	m_eDestPos = POS_CENTER;
	m_eCurProcess = PROCESS_PRESELECT;
	m_fCurTheta = 0.0f;
	m_fFadeOut = 0.0f;
	m_bFadeOutRender = false;

	m_bReceivedCharacterSelect = false;
	m_pUICharacterSelect = nullptr;

	m_pSnd_Rotate = nullptr;
}

CGameProcCharacterSelect::~CGameProcCharacterSelect()
{
	delete m_pCamera;
	for ( int i = 0; i < 8; i++ ) delete m_pLights[i];
	for ( int i = 0; i < MAX_AVAILABLE_CHARACTER; i++ ) delete m_pChrs[i];
	delete m_pActiveBg;
	delete m_pUICharacterSelect;

	::ShowCursor(TRUE);
}

void CGameProcCharacterSelect::Release()
{
	CGameProcedure::Release();

	delete m_pCamera; m_pCamera = nullptr;
	for ( int i = 0; i < 8; i++ ) { delete m_pLights[i]; m_pLights[i] = nullptr; }
	for ( int i = 0; i < MAX_AVAILABLE_CHARACTER; i++ )
	{
		delete m_pChrs[i]; m_pChrs[i] = nullptr;
		m_InfoChrs[i].clear();
	}

	delete m_pActiveBg; m_pActiveBg = nullptr;
	delete m_pUICharacterSelect; m_pUICharacterSelect = nullptr;
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Rotate);
	
	::ShowCursor(TRUE);
}

void CGameProcCharacterSelect::Init()
{
//..
	m_pCamera = nullptr;
	for ( int i = 0; i < 8; i++ ) m_pLights[i] = nullptr;
	for ( int i = 0; i < MAX_AVAILABLE_CHARACTER; i++ )	{ m_pChrs[i] = nullptr; }
	m_pActiveBg = nullptr;

	m_eCurPos = POS_CENTER;
	m_eDestPos = POS_CENTER;
	m_eCurProcess = PROCESS_PRESELECT;
	m_fCurTheta = 0.0f;
	m_fFadeOut = 0.0f;
	m_bFadeOutRender = false;

	m_bReceivedCharacterSelect = false;
	m_pUICharacterSelect = nullptr;

	m_pSnd_Rotate = nullptr;
//..

	CGameProcedure::Init();
//	CGameProcedure::s_pEng->BackupReleaseLighting();

	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Rotate);
	m_pSnd_Rotate = CN3Base::s_SndMgr.CreateObj(ID_SOUND_CHR_SELECT_ROTATE);
	s_pUIMgr->EnableOperationSet(false); // 기존의 캐릭터 정보 패킷이 들어올때까지 UI 를 Disable 시킨다...

	m_pCamera = new CN3Camera();
	for ( int i = 0; i < 8; i++ ) m_pLights[i] = new CN3Light();
	for ( int i = 0; i < MAX_AVAILABLE_CHARACTER; i++ )	m_pChrs[i] = nullptr;

	m_eCurPos = POS_CENTER;
	m_eDestPos = POS_CENTER;
	m_eCurProcess = PROCESS_PRESELECT;
	m_fCurTheta = 0.0f;

	CGameProcedure::s_iChrSelectIndex = 0;

	e_Nation eNation = s_pPlayer->m_InfoBase.eNation;
	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(eNation);

	m_pUICharacterSelect = new CUICharacterSelect();
	m_pUICharacterSelect->Init(s_pUIMgr);
	if(pTbl) m_pUICharacterSelect->LoadFromFile(pTbl->szCharacterSelect); // UI Manager 에 넣지 않고 따로 처리한다... 이유가 있다..
	m_pUICharacterSelect->SetPos(0,0);
	s_pUIMgr->SetFocusedUI((CN3UIBase*)m_pUICharacterSelect);

	switch ( eNation )
	{
		case NATION_KARUS:
			m_vEye.Set(0.0f, -0.2f, 7.4f); m_vAt.Set(0.0f, -0.4f, -0.0f); m_vUp.Set(0.0f, 1.0f,0.0f);
			break;

		case NATION_ELMORAD:
			m_vEye.Set(0.0f, -0.2f, 7.0f), m_vAt.Set(0.0f, -0.4f, -0.0f), m_vUp.Set(0.0f, 1.0f,0.0f);
			break;
	}

	m_vEyeBackup = m_vEye;

	// 배경..
	m_pActiveBg = new CN3Shape;	
	memset(&m_lgt[0], 0, sizeof(__D3DLight9));
	memset(&m_lgt[1], 0, sizeof(__D3DLight9));
	memset(&m_lgt[2], 0, sizeof(__D3DLight9));

	// 0가운데.. 1왼쪽..
	m_lgt[2].Type = m_lgt[1].Type = m_lgt[0].Type = D3DLIGHT_SPOT;
	m_lgt[2].Attenuation0 = m_lgt[1].Attenuation0 = m_lgt[0].Attenuation0 = 0.1f;
	m_lgt[2].Attenuation1 = m_lgt[1].Attenuation1 = m_lgt[0].Attenuation1 = 0.0f;
	m_lgt[2].Attenuation2 = m_lgt[1].Attenuation2 = m_lgt[0].Attenuation2 = 0.0f;
	m_lgt[2].Range = m_lgt[1].Range = m_lgt[0].Range = 6.0f;
	m_lgt[2].Diffuse.r = m_lgt[1].Diffuse.r = m_lgt[0].Diffuse.r = 255/255.0f; 
	m_lgt[2].Diffuse.g = m_lgt[1].Diffuse.g = m_lgt[0].Diffuse.g = 255/255.0f; 
	m_lgt[2].Diffuse.b = m_lgt[1].Diffuse.b = m_lgt[0].Diffuse.b = 255/255.0f;
	m_lgt[2].Falloff = m_lgt[1].Falloff = m_lgt[0].Falloff = 20.0f;


	__Vector3 vTemp; 
	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			m_pActiveBg->LoadFromFile("ChrSelect\\ka_chairs.n3shape");
//			m_pActiveBg->LoadFromFile("Misc\\itembox.n3shape");

			// Light..
			m_pLights[0]->LoadFromFile("ChrSelect\\ka_light_0.n3light");	
			m_pLights[1]->LoadFromFile("ChrSelect\\ka_light_1.n3light");	
			m_pLights[2]->LoadFromFile("ChrSelect\\ka_light_2.n3light");	

			m_lgt[0].Position = m_vEye;	// 카루스
			m_lgt[0].Position.y += 2.0f;	// 카루스
			vTemp = { 0.0f, 0.0f, 3.5f };
			vTemp -= m_lgt[0].Position;
			m_lgt[0].Direction = vTemp;
			m_lgt[0].Phi   = 0.6f;

			m_lgt[1].Position = { 5.87f, 2.4f, 4.73f };	// 카루스
			vTemp = { 2.32f, 0.0f, 2.54f };
			vTemp -= m_lgt[1].Position;
			m_lgt[1].Direction = vTemp;
			m_lgt[1].Phi   = 0.6f;

			m_lgt[2].Position = { -5.87f, 2.4f, 4.73f };	// 카루스
			vTemp = { -2.32f, 0.0f, 2.54f };
			vTemp -= m_lgt[2].Position;
			m_lgt[2].Direction = vTemp;
			m_lgt[2].Phi   = 0.6f;
			break;

		case NATION_ELMORAD:
			m_pActiveBg->LoadFromFile("ChrSelect\\el_chairs.n3shape");

			// Light..
			m_pLights[0]->LoadFromFile("ChrSelect\\el_light_0.n3light");	
			m_pLights[1]->LoadFromFile("ChrSelect\\el_light_1.n3light");	
			m_pLights[2]->LoadFromFile("ChrSelect\\el_light_2.n3light");	

			m_lgt[0].Position = m_vEye;	// 카루스
			m_lgt[0].Position.y += 2.0f;	// 카루스
			vTemp = { 0.0f, -0.1f, 3.0f };
			vTemp -= m_lgt[0].Position;
			m_lgt[0].Direction = vTemp;
			m_lgt[0].Phi   = 0.45f;

			m_lgt[1].Position = { 5.6f, 2.4f, 4.68f };	// 카루스
			vTemp = { 2.2f, -0.1f, 2.36f };
			vTemp -= m_lgt[1].Position;
			m_lgt[1].Direction = vTemp;
			m_lgt[1].Phi   = 0.45f;

			m_lgt[2].Position = { -5.6f, 2.4f, 4.68f };	// 카루스
			vTemp = { -2.4f, -0.1f, 2.23f };
			vTemp -= m_lgt[2].Position;
			m_lgt[2].Direction = vTemp;
			m_lgt[2].Phi   = 0.45f;
			break;
	}

	if (s_bIsRestarting)
		MsgSend_VersionCheck();
	else
		MsgSend_RequestAllCharacterInfo(); // 캐릭터 정보 요청..
}

void CGameProcCharacterSelect::Tick()
{
	CGameProcedure::Tick();	// 키, 마우스 입력 등등..

	__Vector3 vDir = CN3Base::s_CameraData.vAt - CN3Base::s_CameraData.vEye; vDir.Normalize();
	__Vector3 vEye = CN3Base::s_CameraData.vEye; 
	__Vector3 vUp(0,1,0);
	CN3SndObj::SetListenerPos(&vEye);
	CN3SndObj::SetListenerOrientation(&vDir, &vUp);

// 배경..
	m_pActiveBg->Tick();

	if(s_pUIMgr->m_bDoneSomething == false && s_pUIMgr->EnableOperation()) // 패킷을 받기 전에 아무짓도 못하게 한다.
	{
		s_pUIMgr->SetFocusedUI(m_pUICharacterSelect);
		int nMFlags = s_pLocalInput->MouseGetFlag();					// Mouse 상태 플래그..
		if(nMFlags & MOUSE_LBCLICK) // 누르는 순간..
		{
			if (m_eCurProcess == PROCESS_ROTATEING)
				goto NowRotating;

			D3DVIEWPORT9 vp;
			CN3Base::s_lpD3DDev->GetViewport(&vp);
			
			RECT rc = { (int)(vp.Width * 0.36f), (int)(vp.Height * 0.44f), (int)(vp.Width * 0.64f), (int)(vp.Height * 0.86f) };
			POINT pt = s_pLocalInput->MouseGetPos();

			if ( ::PtInRect(&rc, pt) )
			{
				CharacterSelectOrCreate();
			}
		}
	}

NowRotating:

// 라이트..
	for(int i = 0; i < 8; i++) s_pEng->s_lpD3DDev->LightEnable(i, FALSE); // 일단 라이트 다 끄고..
	
	for(int i = 0; i < 2; i++)
	{
		m_pLights[i]->Tick(m_pLights[i]->m_fFrmCur);
		m_pLights[i]->Apply(); // 라이트 적용
	}
	
	CheckJobState();

	if (!IsUIKeyOperated())
	{
		if ( s_pLocalInput->IsKeyPress(DIK_RETURN) )									 
			ProcessOnReturn();
	}
}

void CGameProcCharacterSelect::Render()
{
	D3DCOLOR crEnv = 0x00000000;
	s_pEng->Clear(crEnv); // 배경은 검은색
	s_pEng->s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...

	__Matrix44 mtxWorld;
	mtxWorld.Identity();
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D()); 

	m_pCamera->EyePosSet(m_vEye);
	m_pCamera->AtPosSet(m_vAt);
	m_pCamera->UpVectorSet(0,1,0);
	m_pCamera->m_Data.fNP = 0.1f;
	m_pCamera->m_Data.fFP = 100.0f;
	m_pCamera->m_Data.fFOV = 0.96f;

	m_pCamera->Tick();
	m_pCamera->Apply();

// 배경..
	m_pActiveBg->Render();

// 캐릭터..
	if ( m_pChrs[0] )
	{
		m_pChrs[0]->m_nLOD = 0;
		m_pChrs[0]->Render();
	}
	if ( m_pChrs[1] )
	{
		m_pChrs[1]->m_nLOD = 0;
		m_pChrs[1]->Render();
	}
	if ( m_pChrs[2] )
	{
		m_pChrs[2]->m_nLOD = 0;
		m_pChrs[2]->Render();
	}

	CUIManager::RenderStateSet();
	m_pUICharacterSelect->Render();
	CUIManager::RenderStateRestore();

	CGameProcedure::Render(); // UI 나 그밖의 기본적인 것들 렌더링..

	if (m_bFadeOutRender) FadeOutRender();

	s_pEng->s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	s_pEng->Present(CN3Base::s_hWndBase);
}

void CGameProcCharacterSelect::AddChr(e_ChrPos eCP, __CharacterSelectInfo* pInfo)
{
	int	iPosIndex;
	switch( eCP )
	{
		case POS_CENTER:
			iPosIndex = 0;
			break;

		case POS_LEFT:
			iPosIndex = 1;
			break;

		case POS_RIGHT:
			iPosIndex = 2;
			break;
	}

	if(nullptr == m_pChrs[iPosIndex])
		m_pChrs[iPosIndex] = new CN3Chr();
	else
		m_pChrs[iPosIndex]->Release();

	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(pInfo->eRace);	// User Player Character Skin 구조체 포인터..
	__ASSERT(pLooks, "Table 에서 기본 리소스 찾기 실패.");

	m_pChrs[iPosIndex]->PartAlloc(PART_POS_COUNT);
	m_pChrs[iPosIndex]->PlugAlloc(PLUG_POS_COUNT);
	std::string szJointFN, szAniFN, szPlug0FN, szPlug1FN;

	switch ( pInfo->eRace )
	{
		case RACE_EL_BABARIAN:
			// 남자 바바리안은 직업이 하나..
			szJointFN	= "ChrSelect\\upc_el_ba_wa.n3joint"; // 관절 세팅..
			szAniFN		= "ChrSelect\\upc_el_ba_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
			szPlug0FN	= "ChrSelect\\wea_el_great_sword.n3cplug";
			szPlug1FN	= "";
			break;
		case RACE_EL_WOMEN:
			// 엘모 여자는 직업이 현재 세개(전사, 로그, 성직자).. 성직자는 그래픽이 없다..
			switch ( pInfo->eClass )
			{
				case CLASS_EL_WARRIOR:
				case CLASS_EL_BLADE:
				case CLASS_EL_PROTECTOR:
					szJointFN	= "ChrSelect\\upc_el_rf_wa.n3joint";
					szAniFN		= "ChrSelect\\upc_el_rf_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
					szPlug0FN	= "ChrSelect\\wea_el_long_sword_left.n3cplug"; // 왼손에 검을 찬다..
					szPlug1FN	= "";
					break;
				case CLASS_EL_ROGUE:
				case CLASS_EL_RANGER:
				case CLASS_EL_ASSASIN:
					szJointFN	= "ChrSelect\\upc_el_rf_rog.n3joint"; // 관절 세팅..
					szAniFN		= "ChrSelect\\upc_el_rf_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
					szPlug0FN	= "ChrSelect\\wea_el_rf_rog_bow.n3cplug";
					szPlug1FN	= "ChrSelect\\wea_el_quiver.n3cplug";
					break;
				case CLASS_EL_WIZARD:
				case CLASS_EL_MAGE:
				case CLASS_EL_ENCHANTER:
					szJointFN	= "ChrSelect\\upc_el_rf_wiz.n3joint"; // 관절 세팅..
					szAniFN		= "ChrSelect\\upc_el_rf_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
					szPlug0FN	= "ChrSelect\\upc_el_rf_wiz.n3cplug";
					szPlug1FN	= "";
					break;
				case CLASS_EL_PRIEST:	
				case CLASS_EL_CLERIC:
				case CLASS_EL_DRUID:
					szJointFN	= "ChrSelect\\upc_el_rf_pri.n3joint"; // 관절 세팅..
					szAniFN		= "ChrSelect\\upc_el_rf_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
					szPlug0FN	= "ChrSelect\\wea_el_wand.n3cplug";
					szPlug1FN	= "";
					break;
			}
			break;
		case RACE_EL_MAN:
			// 엘모 남자는 현재 직업이 세개..(로그, 성직자, 전사)
			switch ( pInfo->eClass )
			{
				case CLASS_EL_WARRIOR:
				case CLASS_EL_BLADE:
				case CLASS_EL_PROTECTOR:
					szJointFN	= "ChrSelect\\upc_el_rm_wa.n3joint";
					szAniFN		= "ChrSelect\\upc_el_rm_wa.n3anim";
					szPlug0FN	= "ChrSelect\\wea_el_long_sword.n3cplug";
					break;
				case CLASS_EL_ROGUE:
				case CLASS_EL_RANGER:
				case CLASS_EL_ASSASIN:
					szJointFN	= "ChrSelect\\upc_el_rm_rog.n3joint";
					szAniFN		= "ChrSelect\\upc_el_rm_rog.n3anim";
					szPlug0FN	= "ChrSelect\\upc_el_rm_rog_bow.n3cplug";
					szPlug1FN	= "ChrSelect\\wea_el_quiver.n3cplug";
					break;
				case CLASS_EL_WIZARD:
				case CLASS_EL_MAGE:
				case CLASS_EL_ENCHANTER:
					szJointFN	= "ChrSelect\\upc_el_rm_ma.n3joint";
					szAniFN		= "ChrSelect\\upc_el_rm_rog.n3anim";
					szPlug0FN	= "ChrSelect\\upc_el_rm_wiz.n3cplug";
					szPlug1FN	= "";
					break;
				case CLASS_EL_PRIEST:
				case CLASS_EL_CLERIC:
				case CLASS_EL_DRUID:
					szJointFN	= "ChrSelect\\upc_el_rm_pri.n3joint";
					szAniFN		= "ChrSelect\\upc_el_rm_rog.n3anim";
					szPlug0FN	= "ChrSelect\\wea_el_wand.n3cplug";
					szPlug1FN	= "";
					break;
			}
			break;
		case RACE_KA_ARKTUAREK:
			// 카루스 직업 하나.. 온리 전사..
			szJointFN	= "ChrSelect\\upc_ka_at_wa.n3joint";
			szAniFN		= "ChrSelect\\upc_ka_at_wa.n3anim";
			szPlug0FN	= "ChrSelect\\wea_ka_great_axe.n3cplug";
			szPlug1FN	= "";
			break;
		case RACE_KA_TUAREK:
			switch( pInfo->eClass )
			{
				case CLASS_KA_ROGUE:
				case CLASS_KA_HUNTER:
				case CLASS_KA_PENETRATOR:
					szJointFN	= "ChrSelect\\upc_ka_tu_rog.n3joint";
					szAniFN		= "ChrSelect\\upc_ka_at_wa.n3anim";
					szPlug0FN	= "ChrSelect\\wea_ka_bow.n3cplug";
					szPlug1FN	= "ChrSelect\\wea_ka_quiver.n3cplug";
					break;
				case CLASS_KA_PRIEST:
				case CLASS_KA_SHAMAN:
				case CLASS_KA_DARKPRIEST:
					szJointFN	= "ChrSelect\\upc_ka_tu_pri.n3joint";
					szAniFN		= "ChrSelect\\upc_ka_at_wa.n3anim";
					szPlug0FN	= "ChrSelect\\wea_ka_mace.n3cplug";
					szPlug1FN	= "";
					break;
			}
			break;
		case RACE_KA_WRINKLETUAREK:	
			szJointFN	= "ChrSelect\\upc_ka_wt_ma.n3joint";
			szAniFN		= "ChrSelect\\upc_ka_at_wa.n3anim";
			szPlug0FN	= "ChrSelect\\wea_ka_staff.n3cplug";
			szPlug1FN	= "";
			break;
		case RACE_KA_PURITUAREK:
			szJointFN	= "ChrSelect\\upc_el_rf_pri.n3joint"; // 관절 세팅..
			szAniFN		= "ChrSelect\\upc_el_rf_wa.n3anim"; // 에니메이션 파일 이름.. :-D;
			szPlug0FN	= "ChrSelect\\wea_ka_mace.n3cplug";
			szPlug1FN	= "";
			break;
		default:
			return;
	}

	m_pChrs[iPosIndex]->JointSet(szJointFN); // 관절 세팅..
	m_pChrs[iPosIndex]->AniCtrlSet(szAniFN); // 에니메이션 파일 이름.. :-D;
	m_pChrs[iPosIndex]->PlugSet(0, szPlug0FN);
	m_pChrs[iPosIndex]->PlugSet(1, szPlug1FN);

	// 상체..
	this->AddChrPart(iPosIndex, pLooks, PART_POS_UPPER, pInfo->dwItemUpper, pInfo->iItemUpperDurability);
	// 하체
	__TABLE_ITEM_BASIC* pItemUpper = this->s_pTbl_Items_Basic.Find(pInfo->dwItemUpper);
	if(pItemUpper && pItemUpper->byIsRobeType) m_pChrs[iPosIndex]->PartSet(PART_POS_LOWER, ""); // 하체일 경우 상체에 로브를 입었으면 ..
	else this->AddChrPart(iPosIndex, pLooks, PART_POS_LOWER, pInfo->dwItemLower, pInfo->iItemLowerDurability); //아님 입히고...
	// 팔
	this->AddChrPart(iPosIndex, pLooks, PART_POS_HANDS, pInfo->dwItemGloves, pInfo->iItemGlovesDurability);
	// 다리
	this->AddChrPart(iPosIndex, pLooks, PART_POS_FEET, pInfo->dwItemShoes, pInfo->iItemShoesDurability);

	std::string szResrcFN;

	// 얼굴 - 
	if(!pLooks->szPartFNs[PART_POS_FACE].empty())
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pLooks->szPartFNs[PART_POS_FACE].c_str(), nullptr, szDir, szFName, szExt);
		szResrcFN = fmt::format("{}{}{:02}{}", szDir, szFName, pInfo->iFace, szExt);
		m_pChrs[iPosIndex]->PartSet(PART_POS_FACE, szResrcFN);
	}

	// 머리카락 혹은 헬멧 - 
	__TABLE_ITEM_BASIC* pItemHelmet = this->s_pTbl_Items_Basic.Find(pInfo->dwItemHelmet);
	if(pItemHelmet && pItemHelmet->dwIDResrc) // 헬멧아이템의 리소스(그림이 있는거면..)
	{
		this->AddChrPart(iPosIndex, pLooks, PART_POS_HAIR_HELMET, pInfo->dwItemHelmet, pInfo->iItemHelmetDurability);
	}
	else if(!pLooks->szPartFNs[PART_POS_HAIR_HELMET].empty()) // 아이템이 없으면 기본 머리..
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pLooks->szPartFNs[PART_POS_HAIR_HELMET].c_str(), nullptr, szDir, szFName, szExt);
		szResrcFN = fmt::format("{}{}{:02}{}", szDir, szFName, pInfo->iHair, szExt);
		m_pChrs[iPosIndex]->PartSet(PART_POS_HAIR_HELMET, szResrcFN);
	}
	else 
	{
		m_pChrs[iPosIndex]->PartSet(PART_POS_HAIR_HELMET, ""); // 헬멧도 아니고 머리카락도 없으면.. 대머리다!
	}


	__Quaternion qt;

	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			switch ( iPosIndex )
			{
				case 0:
					m_pChrs[0]->PosSet(0.0f, -1.16f, 2.72f);		// ok..
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(0.0f));
					m_pChrs[0]->RotSet(qt);
					break;

				case 1:
					m_pChrs[1]->PosSet(1.86f, -1.16f, 2.1f);		// ok..		
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(42.0f));
					m_pChrs[1]->RotSet(qt);
					break;

				case 2:
					m_pChrs[2]->PosSet(-1.9f, -1.16f, 2.1f);		// ok..
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(-42.0f));
					m_pChrs[2]->RotSet(qt);
					break;
			};
			break;

		case NATION_ELMORAD:
			switch ( iPosIndex )
			{
				case 0:
					m_pChrs[0]->PosSet(0.0f, -1.20f, 2.74f);		// ok..
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(0.0f));
					m_pChrs[0]->RotSet(qt);
					break;

				case 1:
					m_pChrs[1]->PosSet(1.86f, -1.20f, 2.0f);		// ok
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(42.0f));
					m_pChrs[1]->RotSet(qt);
					break;

				case 2:
					m_pChrs[2]->PosSet(-1.9f, -1.20f, 2.0f);		// ok
					qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(-46.0f));
					m_pChrs[2]->RotSet(qt);
					break;
			};
			break;
	}

	for(int i = 0; i < 3; i++ )
	{
		if ( m_pChrs[i] )
		{
			m_pChrs[i]->AniCurSet(SELECT_ANIM_PRE_SELECT, true, 0);
			m_pChrs[i]->Tick();
		}
	}
}

void CGameProcCharacterSelect::AddChrPart(	int iPosIndex,
											const __TABLE_PLAYER_LOOKS* pLooks,
											e_PartPosition ePartPos,
											uint32_t dwItemID,
											int iItemDurability)
{
	if(nullptr == m_pChrs[iPosIndex] || nullptr == pLooks)
	{
		__ASSERT(0, "Invalid Chr Part");
		return;
	}

	__TABLE_ITEM_BASIC* pItem = s_pTbl_Items_Basic.Find(dwItemID/1000*1000);
	if(dwItemID && nullptr == pItem)
	{
		__ASSERT(0, "NULL Item!!!");
		return;
	}

	std::string szResrcFN;
	CN3CPart* pPart = nullptr;
	e_PartPosition ePartPosTmp = PART_POS_UNKNOWN;
	e_PlugPosition ePlugPosTmp = PLUG_POS_UNKNOWN;
	
	__TABLE_ITEM_EXT* pItemExt = nullptr;
	if(pItem != nullptr)
		pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(dwItemID % 1000);

	MakeResrcFileNameForUPC(pItem, pItemExt, &szResrcFN, nullptr, ePartPosTmp, ePlugPosTmp, m_InfoChrs[iPosIndex].eRace);
	if(szResrcFN.empty()) pPart = m_pChrs[iPosIndex]->PartSet(ePartPos, pLooks->szPartFNs[ePartPos]);	// 기본 파트
	else pPart = m_pChrs[iPosIndex]->PartSet(ePartPos, szResrcFN);
	if(pPart && pItem && pItem->siMaxDurability > 0)
	{
		int iPercentage = iItemDurability * 100 / pItem->siMaxDurability;
		if(iPercentage <= 30) pPart->TexOverlapSet("Misc\\Dust_Hard.dxt");
		else if(iPercentage <= 70) pPart->TexOverlapSet("Misc\\Dust_Soft.dxt");
		else pPart->TexOverlapSet("");
	}
}

void CGameProcCharacterSelect::MsgRecv_DeleteChr(Packet& pkt)
{
	uint8_t byResult, byIndex; 
	byResult = pkt.read<uint8_t>();
	byIndex  = pkt.read<uint8_t>();
	
	if ( byResult == 0x01 )
	{
		if ( m_pChrs[byIndex] != nullptr )
		{
			m_pChrs[byIndex]->Release();
			delete m_pChrs[byIndex];
			m_pChrs[byIndex] = nullptr;
			m_InfoChrs[byIndex].clear();
		}

		if ( (m_pChrs[0] == nullptr) && (m_pChrs[1] == nullptr) && (m_pChrs[2] == nullptr) )
			CGameProcedure::ProcActiveSet((CGameProcedure*)s_pProcNationSelect); // 국가 선택으로 간다..
	}
}

int	CGameProcCharacterSelect::MsgRecv_VersionCheck(Packet& pkt) // virtual
{
	int iVersion = CGameProcedure::MsgRecv_VersionCheck(pkt);
	if(iVersion == CURRENT_VERSION)
	{
		if (s_bIsRestarting)
			MsgSend_GameServerLogIn();
		else
			MsgSend_CharacterSelect(); // 게임 서버에 로그인..
	}

	return iVersion;
}

int CGameProcCharacterSelect::MsgRecv_GameServerLogIn(Packet& pDataPack)
{
	int iNation = CGameProcedure::MsgRecv_GameServerLogIn(pDataPack);
	if (0xff == iNation)
	{
		std::string szMsg = fmt::format_text_resource(IDS_FMT_GAME_SERVER_LOGIN_ERROR, "Current", iNation);
		MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_EXIT);
	}
	else
	{
		MsgSend_RequestAllCharacterInfo();
		s_bIsRestarting = false;
	}

	return iNation;
}

bool CGameProcCharacterSelect::MsgRecv_CharacterSelect(Packet& pkt) // virtual
{
	bool bSuccess = CGameProcedure::MsgRecv_CharacterSelect(pkt);
	s_bIsRestarting = false;

	if(bSuccess) this->CharacterSelect(); // 캐릭터를 일으킨다..
	else this->CharacterSelectFailed();

	return bSuccess;
}

void CGameProcCharacterSelect::ProcessOnReturn()
{
	if(!m_bReceivedCharacterSelect) return;
	//엔터키 눌렸을때 라이트 때문에 깜빡이는것 없애기 위해...

	if ( m_eCurProcess != PROCESS_ROTATEING )
	{
		int iIndex;
		switch ( m_eCurPos )
		{
			case POS_CENTER:
				iIndex = 0;
				break;

			case POS_LEFT:
				iIndex = 1;
				break;

			case POS_RIGHT:
				iIndex = 2;
				break;
		}

		// Light..
		switch ( s_pPlayer->m_InfoBase.eNation )
		{
			case NATION_KARUS:
				m_lgt[iIndex].Theta = KARUS_THETA_MAX;

				s_pEng->s_lpD3DDev->LightEnable(iIndex+4, TRUE);
				s_pEng->s_lpD3DDev->SetLight(iIndex+4, m_lgt[iIndex].toD3D());
				break;

			case NATION_ELMORAD:
				m_lgt[iIndex].Theta = ELMORAD_THERA_MAX;

				s_pEng->s_lpD3DDev->LightEnable(iIndex+4, TRUE);
				s_pEng->s_lpD3DDev->SetLight(iIndex+4, m_lgt[iIndex].toD3D());
				break;
		}

		s_SndMgr.ReleaseStreamObj(&(CGameProcedure::s_pSnd_BGM));
		CGameProcedure::ProcActiveSet((CGameProcedure*)s_pProcMain); // 캐릭터 고르기에 성공하면.. 메인으로 가자!!
//		CGameProcedure::s_pEng->RestoreLighting();
		this->s_pUILoading->Render("Loading data...", 0);
	}
}

bool CGameProcCharacterSelect::CheckRotateLeft()
{
	__Matrix44 mtxrot; mtxrot.Identity();
	__Vector3 vOffs, v1, v2;
	__Vector3 vEyeTemp;
	bool	bReturn = false; 

	vEyeTemp = m_vEye;
	mtxrot.RotationY(0.01f);
	vOffs = vEyeTemp - m_vAt;	
	vOffs *= mtxrot;
	vEyeTemp = vOffs + m_vAt;

	v1 = m_vEyeBackup - m_vAt;
	v2 = vEyeTemp - m_vAt;
	v1.Normalize(); v2.Normalize();

	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			if ( v1.Dot(v2) < 0.75f )
			{
				bReturn = true;
				m_eCurProcess = PROCESS_PRESELECT;
			}
			break;

		case NATION_ELMORAD:
			if ( v1.Dot(v2) < 0.74f )
			{
				bReturn = true;
				m_eCurProcess = PROCESS_PRESELECT;
			}
			break;
	}

	return bReturn;
}

bool CGameProcCharacterSelect::CheckRotateCenterToRight()
{
	if ( m_vEye.x <= 0.0f )
	{
		m_vEye = m_vEyeBackup;
		m_eCurProcess = PROCESS_PRESELECT;
		return true;
	}
	else
		return false;
}

bool CGameProcCharacterSelect::CheckRotateCenterToLeft()
{
	if ( m_vEye.x >= 0.0f )
	{
		m_vEye = m_vEyeBackup;
		m_eCurProcess = PROCESS_PRESELECT;
		return true;
	}
	else
		return false;}


bool CGameProcCharacterSelect::CheckRotateRight()
{
	__Matrix44 mtxrot; mtxrot.Identity();
	__Vector3 vOffs, v1, v2;
	__Vector3 vEyeTemp;
	bool	bReturn = false; 

	vEyeTemp = m_vEye;
	mtxrot.RotationY(-0.01f);
	vOffs = vEyeTemp - m_vAt;	
	vOffs *= mtxrot;
	vEyeTemp = vOffs + m_vAt;

	v1 = m_vEyeBackup - m_vAt;
	v2 = vEyeTemp - m_vAt;
	v1.Normalize(); v2.Normalize();

	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			if ( v1.Dot(v2) < 0.77f )
			{
				bReturn = true;
				m_eCurProcess = PROCESS_PRESELECT;
			}
			break;

		case NATION_ELMORAD:
			if ( v1.Dot(v2) < 0.73f )
			{
				bReturn = true;
				m_eCurProcess = PROCESS_PRESELECT;
			}
			break;
	}

	return bReturn;
}

void CGameProcCharacterSelect::DoJobLeft()
{
	if ( m_eCurPos != POS_LEFT )
	{
		if ( m_eCurProcess == PROCESS_ROTATEING )
			return;
		else
			m_eCurProcess = PROCESS_ROTATEING;
	}

	switch ( m_eCurPos )
	{
		case POS_CENTER:
			m_eDestPos = POS_LEFT;
			CGameProcedure::s_iChrSelectIndex = 1;
			break;

		case POS_RIGHT:
			m_eDestPos = POS_CENTER;
			CGameProcedure::s_iChrSelectIndex = 0;
			break;
	}

	if ( (m_eCurPos != POS_LEFT) && m_pSnd_Rotate) m_pSnd_Rotate->Play();
}


void CGameProcCharacterSelect::DojobRight()
{
	if ( m_eCurPos != POS_RIGHT )
	{
		if ( m_eCurProcess == PROCESS_ROTATEING )
			return;
		else
			m_eCurProcess = PROCESS_ROTATEING;
	}

	switch ( m_eCurPos )
	{
		case POS_CENTER:
			m_eDestPos = POS_RIGHT;
			CGameProcedure::s_iChrSelectIndex = 2;
			break;

		case POS_LEFT:
			m_eDestPos = POS_CENTER;
			CGameProcedure::s_iChrSelectIndex = 0;
			break;
	}

	if ( (m_eCurPos != POS_RIGHT) && m_pSnd_Rotate) m_pSnd_Rotate->Play();
}

void CGameProcCharacterSelect::MsgSend_DeleteChr(const std::string& szKey)
{
	if(szKey.empty() || szKey.size() >= 32) return;

	// 현재 상태가 캐릭터를 선택하지 않은 상태..
	if ( m_eCurProcess != PROCESS_PRESELECT )
		return;

	int iIndex = -1;
	switch ( m_eCurPos )
	{
		case POS_CENTER: iIndex = 0; break;
		case POS_LEFT: iIndex = 1; break;
		case POS_RIGHT: iIndex = 2; break;
		default: return;
	}

	uint8_t byBuff[64];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_DEL_CHAR);		// 커멘드.
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)iIndex);				// 인덱스 - b
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_InfoChrs[iIndex].szID.size());		// 아이디 길이
	CAPISocket::MP_AddString(byBuff, iOffset, m_InfoChrs[iIndex].szID); // 아이디 문자열
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szKey.size());				// 주민등록번호 길이
	CAPISocket::MP_AddString(byBuff, iOffset, szKey);					// 주민등록번호 문자열
	
	s_pSocket->Send(byBuff, iOffset);								// 보낸다
}

void CGameProcCharacterSelect::CheckJobState()
{
	switch ( m_eCurProcess )
	{
		case PROCESS_ROTATEING:
			if ( m_eDestPos == m_eCurPos )
				return;

			switch ( m_eCurPos )
			{
				case POS_CENTER:
					switch ( m_eDestPos )
					{
						case POS_LEFT:
							// Check..
							if ( !CheckRotateLeft() )
								RotateLeft();
							else
								m_eCurPos = m_eDestPos;
							break;

						case POS_RIGHT:
							// Check..
							if ( !CheckRotateRight() )
								RotateRight();
							else
								m_eCurPos = m_eDestPos;
							break;
					}
					break;

				case POS_LEFT:
					if ( m_eDestPos == POS_CENTER )
					{
						// Check..
						if ( !CheckRotateCenterToRight() )
							RotateRight();
						else
							m_eCurPos = m_eDestPos;
					}
					break;

				case POS_RIGHT:
					if ( m_eDestPos == POS_CENTER )
					{
						// Check..
						if ( !CheckRotateCenterToLeft() )
							RotateLeft();
						else
							m_eCurPos = m_eDestPos;
					}
					break;
			}
			break;

		case PROCESS_PRESELECT:
			DoProcPreselect();
			break;

		case PROCESS_SELECTED:
			DoSelectedChrProc();
			break;
	}
}

void CGameProcCharacterSelect::RotateLeft()
{
	__Matrix44 mtxrot; mtxrot.Identity();
	__Vector3 vOffs;

	mtxrot.RotationY(CN3Base::s_fSecPerFrm*1.2f);
	vOffs = m_vEye - m_vAt;	
	vOffs *= mtxrot;
	m_vEye = vOffs + m_vAt;
}

void CGameProcCharacterSelect::RotateRight()
{
	__Matrix44 mtxrot; mtxrot.Identity();
	__Vector3 vOffs;

	mtxrot.RotationY(-CN3Base::s_fSecPerFrm*1.2f);
	vOffs = m_vEye - m_vAt;	
	vOffs *= mtxrot;
	m_vEye = vOffs + m_vAt;
}

void CGameProcCharacterSelect::CharacterSelect()
{
	int iIndex;
	switch ( m_eCurPos )
	{
		case POS_CENTER:
			iIndex = 0;
			break;

		case POS_LEFT:
			iIndex = 1;
			break;

		case POS_RIGHT:
			iIndex = 2;
			break;
	}

	if ( m_eCurProcess == PROCESS_PRESELECT )
	{
		if ( m_pChrs[iIndex] )
		{
			m_eCurProcess = PROCESS_SELECTED;
			m_pChrs[iIndex]->AniCurSet(SELECT_ANIM_SELECTED, true, 0.6f);
			m_pChrs[iIndex]->Tick();

			switch ( s_pPlayer->m_InfoBase.eNation )
			{
				case NATION_KARUS:
					m_fCurTheta = KARUS_THETA_MAX;
					break;

				case NATION_ELMORAD:
					m_fCurTheta = ELMORAD_THERA_MAX;
					break;
			}

			m_lgt[iIndex].Theta = m_fCurTheta;	
			s_pEng->s_lpD3DDev->LightEnable(iIndex+4, TRUE);
			s_pEng->s_lpD3DDev->SetLight(iIndex+4, m_lgt[iIndex].toD3D());
		}
	}

	m_bReceivedCharacterSelect = true; // 캐릭터 고르기 완료..
	s_pUIMgr->EnableOperationSet(false); // 일단 고르면 UI 안되게 한다...
}

void CGameProcCharacterSelect::CharacterSelectFailed()
{
	m_bReceivedCharacterSelect = false; // 캐릭터 고르기 실패..
	std::string szErr = fmt::format_text_resource(IDS_ERR_CHARACTER_SELECT);
	MessageBoxPost(szErr, "", MB_OK, BEHAVIOR_EXIT);
	s_pUIMgr->EnableOperationSet(true);
}

void CGameProcCharacterSelect::DoSelectedChrProc()
{
	int iIndex;
	switch ( m_eCurPos )
	{
		case POS_CENTER:
			iIndex = 0;
			break;

		case POS_LEFT:
			iIndex = 1;
			break;

		case POS_RIGHT:
			iIndex = 2;
			break;
	}

	// Light..
	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			s_pEng->s_lpD3DDev->LightEnable(iIndex+4, TRUE);
			s_pEng->s_lpD3DDev->SetLight(iIndex+4, m_lgt[iIndex].toD3D());
			break;

		case NATION_ELMORAD:
			s_pEng->s_lpD3DDev->LightEnable(iIndex+4, TRUE);
			s_pEng->s_lpD3DDev->SetLight(iIndex+4, m_lgt[iIndex].toD3D());
			break;
	}

	if ( !m_pChrs[iIndex]->IsAnimEnd() )
	{
		m_pChrs[iIndex]->AniCurSet(SELECT_ANIM_SELECTED, true, 0.6f);
		m_pChrs[iIndex]->Tick();
		m_bFadeOutRender = true;
		FadeOutProcess();
	}
	else
	{
		s_SndMgr.ReleaseStreamObj(&(CGameProcedure::s_pSnd_BGM));
		CGameProcedure::ProcActiveSet((CGameProcedure*)s_pProcMain); // 캐릭터 받았고.. 에니메이션도 끝났으면 메인으로 넘어가자..!!
//		CGameProcedure::s_pEng->RestoreLighting();
	}
}

void CGameProcCharacterSelect::FadeOutProcess()
{
	m_fFadeOut += (30.0f/CN3Base::s_fFrmPerSec)*1.5f;

	if ( m_fFadeOut > 255 )
		m_fFadeOut = 255;
}

void CGameProcCharacterSelect::FadeOutRender()
{
    __VertexTransformedColor pVertices[4];

	pVertices[0].Set( 0.0f, 0.0f, 0.000002f, 0.99f, D3DCOLOR_ARGB((uint8_t)m_fFadeOut,0x00,0x00,0x00) );
	pVertices[1].Set( (float)s_CameraData.vp.Width, 0.0f, 0.000002f, 0.99f, D3DCOLOR_ARGB((uint8_t)m_fFadeOut,0x00,0x00,0x00) );
	pVertices[2].Set( (float)s_CameraData.vp.Width, (float)s_CameraData.vp.Height, 0.000002f, 0.99f, 	D3DCOLOR_ARGB((uint8_t)m_fFadeOut,0x00,0x00,0x00) );
	pVertices[3].Set( 0.0f, (float)s_CameraData.vp.Height, 0.000002f, 0.99f, D3DCOLOR_ARGB((uint8_t)m_fFadeOut,0x00,0x00,0x00) );

	DWORD dwUsefog = TRUE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_FOGENABLE , &dwUsefog );

	DWORD dwUseLighting=TRUE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwUseLighting );

	DWORD dwUseColorVertex=FALSE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_COLORVERTEX , &dwUseColorVertex );

	DWORD  bUseAlphaBlend=TRUE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE,	&bUseAlphaBlend );

	int	bLight[8];
	for ( int i = 0; i < 8; i++ )	CN3Base::s_lpD3DDev->GetLightEnable(i, &bLight[i]);

	if (bUseAlphaBlend == FALSE) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
	if (dwUseLighting) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE );
	if (dwUsefog) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, FALSE );
	// set render states
	if (dwUseColorVertex == FALSE) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_COLORVERTEX, TRUE );
	for ( int i = 0; i < 8; i++ )	CN3Base::s_lpD3DDev->LightEnable(i, FALSE);

	DWORD dwTexStageCO, dwTexStageCARG1, dwTexStageAO, dwTexStageAARG1, dwRSSB, dwRSDB;

	s_pEng->s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwTexStageCO);
	s_pEng->s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwTexStageCARG1);
	s_pEng->s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwTexStageAO);
	s_pEng->s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwTexStageAARG1);
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwRSSB );
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwRSDB );

	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,				D3DBLEND_SRCALPHA );
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,				D3DBLEND_INVSRCALPHA );

	CN3Base::s_lpD3DDev->SetTexture(0, nullptr);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, pVertices, sizeof(__VertexTransformedColor));

	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwTexStageCO);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwTexStageCARG1);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwTexStageAO);
	s_pEng->s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwTexStageAARG1);
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, dwRSSB );
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, dwRSDB );

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_COLORVERTEX, dwUseColorVertex);
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE,		bUseAlphaBlend );
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwUseLighting );
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE , dwUsefog );
	for ( int i = 0; i < 8; i++ )	CN3Base::s_lpD3DDev->LightEnable(i, bLight[i]);
}


void CGameProcCharacterSelect::DoProcPreselect()
{
	D3DVIEWPORT9 vp;
	CN3Base::s_lpD3DDev->GetViewport(&vp);
	
	float left, right, top, bottom;
	left = vp.Width * 0.36f;
	right = vp.Width * 0.64f;
	top = vp.Height * 0.44f;
	bottom = vp.Height * 0.86f;

	POINT pt = s_pLocalInput->MouseGetPos(); 

	int	iPosIndex;
	switch( m_eCurPos )
	{
		case POS_CENTER:
			iPosIndex = 0;
			break;

		case POS_LEFT:
			iPosIndex = 1;
			break;

		case POS_RIGHT:
			iPosIndex = 2;
			break;
	}

	if ( (pt.x > left) && (pt.x < right) && (pt.y < bottom) && (pt.y > top) )
	{
		// Doing..
		if ( m_pChrs[iPosIndex] )
		{
			m_pChrs[iPosIndex]->AniCurSet(SELECT_ANIM_PRE_SELECT, true);
			m_pChrs[iPosIndex]->Tick();
		}

		IncreseLightFactor();

		m_pUICharacterSelect->DisplayChrInfo(&m_InfoChrs[iPosIndex]);
	}
	else
	{
		// Doing..
		if ( m_pChrs[iPosIndex] )
		{
			m_pChrs[iPosIndex]->AniCurSet(SELECT_ANIM_DUMMY, true);
			m_pChrs[iPosIndex]->Tick();
		}

		DecreseLightFactor();

		m_pUICharacterSelect->DontDisplayInfo();
	}

	// Light..
	for( int i = 0; i < 3; i++ ) m_lgt[i].Theta   = 0.0f;
	m_lgt[iPosIndex].Theta = m_fCurTheta;	

	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			if ( m_lgt[iPosIndex].Theta != 0.0f ) 
			{
				s_pEng->s_lpD3DDev->LightEnable(iPosIndex+4, TRUE);
				s_pEng->s_lpD3DDev->SetLight(iPosIndex+4, m_lgt[iPosIndex].toD3D());
			}
			else
				s_pEng->s_lpD3DDev->LightEnable(iPosIndex+4, FALSE);
			break;

		case NATION_ELMORAD:
			if ( m_lgt[iPosIndex].Theta != 0.0f ) 
			{
				s_pEng->s_lpD3DDev->LightEnable(iPosIndex+4, TRUE);
				s_pEng->s_lpD3DDev->SetLight(iPosIndex+4, m_lgt[iPosIndex].toD3D());
			}
			else
				s_pEng->s_lpD3DDev->LightEnable(iPosIndex+4, FALSE);
			break;
	}
}

void CGameProcCharacterSelect::IncreseLightFactor()
{
	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			m_fCurTheta += KARUS_INCRESE_OFFSET;
			if ( m_fCurTheta > KARUS_THETA_MAX )
				m_fCurTheta = KARUS_THETA_MAX;
			break;

		case NATION_ELMORAD:
			m_fCurTheta += ELMORAD_INCRESE_OFFSET;
			if ( m_fCurTheta > ELMORAD_THERA_MAX )
				m_fCurTheta = ELMORAD_THERA_MAX;
			break;
	}
}

void CGameProcCharacterSelect::DecreseLightFactor()
{
	switch ( s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_KARUS:
			m_fCurTheta -= KARUS_INCRESE_OFFSET;
			if ( m_fCurTheta < 0.0f )
				m_fCurTheta = 0.0f;
			break;

		case NATION_ELMORAD:
			m_fCurTheta -= ELMORAD_INCRESE_OFFSET;
			if ( m_fCurTheta < 0.0f )
				m_fCurTheta = 0.0f;
			break;
	}
}

void CGameProcCharacterSelect::MsgRecv_AllCharacterInfo(Packet& pkt)
{
	int iResult = pkt.read<uint8_t>(); // 결과..
	if(0x1 == iResult)
	{
		for(int i = 0; i < MAX_AVAILABLE_CHARACTER; i++)
		{
			int iIDLength = pkt.read<int16_t>(); // 캐릭터 아이디 길이 s,

			pkt.readString(m_InfoChrs[i].szID, iIDLength);// 캐릭터 아이디 문자열 str

			m_InfoChrs[i].eRace			= (e_Race)(pkt.read<uint8_t>()); // 종족 b
			m_InfoChrs[i].eClass		= (e_Class)(pkt.read<int16_t>()); // 직업 b
			m_InfoChrs[i].iLevel		= pkt.read<uint8_t>(); // 레벨 b
			m_InfoChrs[i].iFace			= pkt.read<uint8_t>(); // 얼굴모양 b
			m_InfoChrs[i].iHair			= pkt.read<uint8_t>(); // 머리모양 b
			m_InfoChrs[i].iZone			= pkt.read<uint8_t>(); // zone number

			m_InfoChrs[i].dwItemHelmet				= pkt.read<uint32_t>(); // 투구 dw
			m_InfoChrs[i].iItemHelmetDurability		= pkt.read<int16_t>(); // 내구성값
			m_InfoChrs[i].dwItemUpper				= pkt.read<uint32_t>(); // 상체 dw
			m_InfoChrs[i].iItemUpperDurability		= pkt.read<int16_t>(); // 내구성값
			m_InfoChrs[i].dwItemCloak				= pkt.read<uint32_t>(); // 어깨(망토) dw
			m_InfoChrs[i].iItemCloakDurability		= pkt.read<int16_t>(); // 내구성값

			// NOTE(srmeier): this was added for 1298
			uint32_t dwRightHand = pkt.read<uint32_t>();
			int iItemRightHandDurability = pkt.read<int16_t>();
			uint32_t dwLeftHand = pkt.read<uint32_t>();
			int iItemLeftHandDurability = pkt.read<int16_t>();

			m_InfoChrs[i].dwItemLower				= pkt.read<uint32_t>(); // 하체 dw
			m_InfoChrs[i].iItemLowerDurability		= pkt.read<int16_t>(); // 내구성값
			m_InfoChrs[i].dwItemGloves				= pkt.read<uint32_t>(); // 장갑 dw
			m_InfoChrs[i].iItemGlovesDurability		= pkt.read<int16_t>(); // 내구성값
			m_InfoChrs[i].dwItemShoes				= pkt.read<uint32_t>(); // 신발 dw
			m_InfoChrs[i].iItemShoesDurability		= pkt.read<int16_t>(); // 내구성값
		}

		// 캐릭터 추가..
		if ( m_InfoChrs[0].szID.size() > 0 )		AddChr(POS_CENTER, &(m_InfoChrs[0]));
		if ( m_InfoChrs[1].szID.size() > 0 )		AddChr(POS_LEFT, &(m_InfoChrs[1]));
		if ( m_InfoChrs[2].szID.size() > 0 )		AddChr(POS_RIGHT, &(m_InfoChrs[2]));
	}
	else
	{
		this->MsgSend_RequestAllCharacterInfo(); // 다시 정보 요청..
		return;
	}
}

void CGameProcCharacterSelect::MsgSend_RequestAllCharacterInfo()
{
	uint8_t byBuff[4];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ALLCHAR_INFO_REQ);	// 커멘드.
	s_pSocket->Send(byBuff, iOffset);								// 보낸다
}

void CGameProcCharacterSelect::MsgSend_CharacterSelect() // virtual
{
	CGameProcedure::MsgSend_CharacterSelect();
	s_pUIMgr->EnableOperationSet(false); // UI 를 조작 못하게 한다..
}

bool CGameProcCharacterSelect::ProcessPacket(Packet& pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	switch ( iCmd )										// 커멘드에 다라서 분기..
	{
		case WIZ_ALLCHAR_INFO_REQ:				// 캐릭터 선택 메시지..
			this->MsgRecv_AllCharacterInfo(pkt);
			s_pUIMgr->EnableOperationSet(true); // 캐릭터 정보가 다오면 UI 조작하게 한다..
			return true;
		case WIZ_DEL_CHAR:
			this->MsgRecv_DeleteChr(pkt);
			return true;
	}
	
	return false;
}

void CGameProcCharacterSelect::CharacterSelectOrCreate()
{
	CGameProcedure::MessageBoxClose(-1);

	int iIndex = CGameProcedure::s_iChrSelectIndex;
	if(nullptr == m_pChrs[iIndex]) // 캐릭터가 없으면..
	{
		CGameProcedure::ProcActiveSet((CGameProcedure*)s_pProcCharacterCreate); // 캐릭터 생성 프로시저를 호출한다..
	}
	else
	{
		s_pPlayer->m_InfoExt.iZoneInit = 0x01;
		s_pPlayer->m_InfoExt.iZoneCur = m_InfoChrs[iIndex].iZone;
		s_pPlayer->IDSet(-1, m_InfoChrs[iIndex].szID, 0xffffffff);
		this->MsgSend_CharacterSelect();
	}
}

// ===== END WarFare/GameProcCharacterSelect.cpp =====

// ===== BEGIN WarFare/GameProcCharacterSelect.h =====
#line 1 "WarFare/GameProcCharacterSelect.h"
﻿// GameProcCharacterSelect.h: interface for the CGameProcCharacterSelect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMEPROCCHARACTERSELECT_H__FA8E7800_AE8D_4469_8D6A_7F409EED8C86__INCLUDED_)
#define AFX_GAMEPROCCHARACTERSELECT_H__FA8E7800_AE8D_4469_8D6A_7F409EED8C86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameProcedure.h"

enum e_ChrPos {	POS_CENTER = 1, POS_LEFT, POS_RIGHT };
enum e_DoProcProcess { PROCESS_ROTATEING = 1, PROCESS_PRESELECT, PROCESS_SELECTED, PROCESS_COMPLETE };
enum e_ChrClass { CLASS_WAR = 1, CLASS_ROG, CLASS_PRIST, CLASS_WIZARD };
const int CS_El_rf_wa = 65500;

const int	SELECT_ANIM_PRE_SELECT = 0;
const int	SELECT_ANIM_SELECTED = 1;
const int	SELECT_ANIM_DUMMY = 2;

const float	KARUS_THETA_MAX = 0.5f;
const float	ELMORAD_THERA_MAX = 0.38f;
const float KARUS_INCRESE_OFFSET = 0.02f;
const float ELMORAD_INCRESE_OFFSET = 0.015f;

class CUIManager;
class CUICharacterSelect;

struct __CharacterSelectInfo
{
	std::string szID; // 캐릭터 아이디 문자열 str
	e_Race		eRace; // 종족 b
	e_Class		eClass; // 직업 b
	int			iLevel ; // 레벨 b
	int			iFace; // 얼굴모양 b
	int			iHair; // 머리모양 b
	int			iZone; //zone number
	uint32_t		dwItemUpper; // 상체 dw
	int			iItemUpperDurability;
	uint32_t		dwItemLower; // 하체 dw
	int			iItemLowerDurability;
	uint32_t		dwItemHelmet; // 투구 dw
	int			iItemHelmetDurability;
	uint32_t		dwItemCloak; // 어깨(망토) dw
	int			iItemCloakDurability;
	uint32_t		dwItemGloves; // 장갑 dw
	int			iItemGlovesDurability;
	uint32_t		dwItemShoes; // 신발 dw
	int			iItemShoesDurability;

	void clear()
	{
		szID			= "";
		eRace			= RACE_UNKNOWN; // 종족 b
		eClass			= CLASS_UNKNOWN; // 직업 b
		iLevel			= 0; // 레벨 b
		iFace			= 0; // 얼굴모양 b
		iHair			= 0; // 머리모양 b
		iZone			= 0; //zone number
		dwItemUpper		= 0; // 상체 dw
		dwItemLower		= 0; // 하체 dw
		dwItemHelmet	= 0; // 투구 dw
		dwItemCloak		= 0; // 어깨(망토) dw
		dwItemGloves		= 0; // 장갑 dw
		dwItemShoes		= 0; // 신발 dw
	}

	
	__CharacterSelectInfo() { clear(); }
	~__CharacterSelectInfo() { }
};

class CGameProcCharacterSelect : public CGameProcedure  
{
	CN3SndObj*				m_pSnd_Rotate;

public:
	class CN3Shape*			m_pActiveBg;

	class CN3Chr*			m_pChrs[MAX_AVAILABLE_CHARACTER];
	__CharacterSelectInfo	m_InfoChrs[MAX_AVAILABLE_CHARACTER]; // 이미 만들어진 캐릭터 정보..

	class CN3Camera*		m_pCamera;
	class CN3Light*			m_pLights[8];
	__Vector3				m_vEye;
	__Vector3				m_vEyeBackup;
	__Vector3				m_vAt;
	__Vector3				m_vUp;
	__D3DLight9				m_lgt[3];

	CUICharacterSelect*		m_pUICharacterSelect;

	e_ChrPos				m_eCurPos;	
	e_ChrPos				m_eDestPos;	

	e_DoProcProcess			m_eCurProcess;
	float					m_fCurTheta;
	float					m_fFadeOut;
	bool					m_bFadeOutRender;

	bool					m_bReceivedCharacterSelect;
public:
	void	CharacterSelectOrCreate();
	void	MsgSend_RequestAllCharacterInfo();
	void	MsgSend_DeleteChr(const std::string& szKey);
	void	MsgSend_CharacterSelect(); // virtual

	int		MsgRecv_VersionCheck(Packet& pkt); // virtual
	int		MsgRecv_GameServerLogIn(Packet& pDataPack) override;
	bool	MsgRecv_CharacterSelect(Packet& pkt); // virtual
	void	MsgRecv_AllCharacterInfo(Packet& pkt);
	void	MsgRecv_DeleteChr(Packet& pkt);

	void	Release();
	void	Init();
	void	Tick();
	void	Render();

	CGameProcCharacterSelect();
	virtual ~CGameProcCharacterSelect();

	void	RotateLeft();
	void	RotateRight();

	void	AddChr(e_ChrPos eCP, __CharacterSelectInfo* pInfo);
	void	AddChrPart(int iPosIndex, const __TABLE_PLAYER_LOOKS* pItemBasic, e_PartPosition ePartPos, uint32_t dwItemID, int iItemDurability);

	void	DoJobLeft();
	void	DojobRight();
	void	CheckJobState();
	bool	CheckRotateLeft();
	bool	CheckRotateCenterToRight();
	bool	CheckRotateCenterToLeft();
	bool	CheckRotateRight();
	
	void	CharacterSelect();
	void	CharacterSelectFailed();

	void	DoSelectedChrProc();
	void	DoProcPreselect();
	void	IncreseLightFactor();
	void	DecreseLightFactor();
	void	ProcessOnReturn();
	void	FadeOutProcess();
	void	FadeOutRender();
protected:
	virtual bool ProcessPacket(Packet& pkt);
};

#endif // !defined(AFX_GAMEPROCCHARACTERSELECT_H__FA8E7800_AE8D_4469_8D6A_7F409EED8C86__INCLUDED_)

// ===== END WarFare/GameProcCharacterSelect.h =====

// ===== BEGIN WarFare/GameProcLogIn.h =====
#line 1 "WarFare/GameProcLogIn.h"
﻿#pragma once

#if defined(LOGIN_SCENE_VERSION) && LOGIN_SCENE_VERSION == 1098
#include "GameProcLogIn_1098.h"
#elif !defined(LOGIN_SCENE_VERSION) || LOGIN_SCENE_VERSION == 1298
#include "GameProcLogIn_1298.h"
#else
#pragma error LOGIN_SCENE_VERSION value is unsupported. Expected values: 1098, 1298
#endif

// ===== END WarFare/GameProcLogIn.h =====

// ===== BEGIN WarFare/GameProcLogIn_1098.cpp =====
#line 1 "WarFare/GameProcLogIn_1098.cpp"
﻿#include "stdafx.h"

#if defined(LOGIN_SCENE_VERSION) && LOGIN_SCENE_VERSION == 1098
#include "GameProcLogIn_1098.h"
#include "GameEng.h"
#include "UILogIn_1098.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "PacketDef.h"
#include "text_resources.h"

#include <N3Base/N3Camera.h>
#include <N3Base/N3Light.h>
#include <N3Base/N3Chr.h>
#include <N3Base/N3SndObj.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3SndMgr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

using __GameServerInfo = CUILogIn_1098::__GameServerInfo;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcLogIn_1098::CGameProcLogIn_1098()
{
	m_pUILogIn	= nullptr;
	m_pChr		= nullptr;
	m_pTexBkg	= nullptr;

	m_pCamera = nullptr;
	for (int i = 0; i < 3; i++)
		m_pLights[i] = nullptr;

	m_bLogIn = false; // 로그인 중복 방지..
	m_fTimeUntilNextGameConnectionAttempt = 0.0f;
}

CGameProcLogIn_1098::~CGameProcLogIn_1098()
{
	delete m_pUILogIn;
	delete m_pChr;
	delete m_pTexBkg;

	delete m_pCamera;
	for (int i = 0; i < 3; i++)
		delete m_pLights[i];
}

void CGameProcLogIn_1098::Release()
{
	CGameProcedure::Release();

	delete m_pUILogIn;
	m_pUILogIn = nullptr;

	delete m_pChr;
	m_pChr = nullptr;

	delete m_pTexBkg;
	m_pTexBkg = nullptr;

	delete m_pCamera;
	m_pCamera = nullptr;

	for (int i = 0; i < 3; i++)
	{
		delete m_pLights[i];
		m_pLights[i] = nullptr;
	}
}

void CGameProcLogIn_1098::Init()
{
	CGameProcedure::Init();

	m_pTexBkg = new CN3Texture();
	m_pTexBkg->LoadFromFile("Intro\\Moon.dxt");

	m_pChr = new CN3Chr();
	m_pChr->LoadFromFile("Intro\\Intro.N3Chr");
	m_pChr->AniCurSet(0); // 루핑 에니메이션..
	
	m_pCamera = new CN3Camera();
	m_pCamera->EyePosSet(0.22f, 0.91f, -1.63f);
	m_pCamera->AtPosSet(-0.19f, 1.1f, 0.09f);
	m_pCamera->m_Data.fNP = 0.1f;
	m_pCamera->m_Data.fFP = 32.0f;
	m_pCamera->m_bFogUse = false;

	for(int i = 0; i < 3; i++)
		m_pLights[i] = new CN3Light();

	m_pLights[0]->LoadFromFile("Intro\\0.N3Light");
	m_pLights[1]->LoadFromFile("Intro\\1.N3Light");
	m_pLights[2]->LoadFromFile("Intro\\2.N3Light");

	s_pEng->s_SndMgr.ReleaseStreamObj(&s_pSnd_BGM);
	s_pSnd_BGM = s_pEng->s_SndMgr.CreateStreamObj(35);	//몬스터 울부짖는 26초짜리 소리..

	m_pUILogIn = new CUILogIn_1098();
	m_pUILogIn->Init(s_pUIMgr);
	
	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.GetIndexedData(0); // 국가 기준이 없기 때문이다...
	if (pTbl != nullptr)
		m_pUILogIn->LoadFromFile(pTbl->szLogIn);

	RECT rc = m_pUILogIn->GetRegion();
	int iX = (CN3Base::s_CameraData.vp.Width - (rc.right - rc.left))/2;
	int iY = CN3Base::s_CameraData.vp.Height - (rc.bottom - rc.top);
	m_pUILogIn->SetPos(iX, iY);
	m_pUILogIn->RecalcGradePos();
	rc.left = 0; rc.top = 0; rc.right = CN3Base::s_CameraData.vp.Width; rc.bottom = CN3Base::s_CameraData.vp.Height;
	m_pUILogIn->SetRegion(rc); // 이걸 꼭 해줘야 UI 처리가 제대로 된다..
	s_pUIMgr->SetFocusedUI((CN3UIBase*)m_pUILogIn);

	// 소켓 접속..
	char szIniPath[_MAX_PATH] = {};
	lstrcpy(szIniPath, CN3Base::PathGet().c_str());
	lstrcat(szIniPath, "Server.Ini");

	char szRegistrationSite[_MAX_PATH] = {};
	GetPrivateProfileString("Join", "Registration site", "", szRegistrationSite, _MAX_PATH, szIniPath);
	m_szRegistrationSite = szRegistrationSite;

	int iServerCount = GetPrivateProfileInt("Server", "Count", 0, szIniPath);

	char szIPs[256][32] = {};
	for (int i = 0; i < iServerCount; i++)
	{
		std::string key = fmt::format("IP{}", i);
		GetPrivateProfileString("Server", key.c_str(), "", szIPs[i], 32, szIniPath);
	}

	int iServer = -1;
	if (iServerCount > 0)
		iServer = rand() % iServerCount;
	
	if (iServer >= 0
		&& lstrlen(szIPs[iServer]) > 0)
	{
		const char* ip = szIPs[iServer];
		int port = SOCKET_PORT_LOGIN;

		s_bNeedReportConnectionClosed = false; // Should I report that the server connection was lost?
		int iErr = s_pSocket->Connect(s_hWndBase, ip, port);
		s_bNeedReportConnectionClosed = true;

		if (iErr != 0)
		{
#if defined(_DEBUG)
			std::string errorMessage = fmt::format(
				"{}:{} (errorCode: {})\n"
				"From config: Server.ini (client)",
				ip, port, iErr);
			MessageBoxPost(errorMessage, "Failed to connect to login server", MB_OK, BEHAVIOR_EXIT);
#else
			ReportServerConnectionFailed("LogIn Server", iErr, true);
#endif
		}
		else
		{
			m_pUILogIn->FocusToID(); // 아이디 입력창에 포커스를 맞추고..

			// 게임 서버 리스트 요청..
			int iOffset = 0;
			uint8_t byBuffs[4];
			CAPISocket::MP_AddByte(byBuffs, iOffset, LS_SERVERLIST);					// 커멘드.
			s_pSocket->Send(byBuffs, iOffset);											// 보낸다
		}
	}
	else
	{
		MessageBoxPost("No server list", "LogIn Server fail", MB_OK, BEHAVIOR_EXIT); // 끝낸다.
	}

	// 게임 계정으로 들어 왔으면..
	if (LIC_KNIGHTONLINE != s_eLogInClassification)
	{
		MsgSend_AccountLogIn(s_eLogInClassification); // 로그인..
	}

	// Re-entered the scene; we can reset any existing timer.
	// The point of this delay is to prevent the user from intentionally or otherwise spamming connections
	// to the game server, in the small window where we're still on the login scene and are waiting for the
	// game server to respond.
	// Once we've changed scenes, this timer doesn't matter anymore; we can't continue to spam it.
	// Returning back to this scene, then, means we're fine to have it reset.
	ResetGameConnectionAttemptTimer();
}

void CGameProcLogIn_1098::Tick() // 프로시져 인덱스를 리턴한다. 0 이면 그대로 진행
{
	CGameProcedure::Tick();	// 키, 마우스 입력 등등..

	if (m_fTimeUntilNextGameConnectionAttempt > 0.0f)
	{
		m_fTimeUntilNextGameConnectionAttempt -= s_fSecPerFrm;
		if (m_fTimeUntilNextGameConnectionAttempt < 0.0f)
			m_fTimeUntilNextGameConnectionAttempt = 0.0f;
	}

	for (int i = 0; i < 3; i++)
		m_pLights[i]->Tick();

	m_pChr->Tick();

	static float fTmp = 0;
	if (fTmp == 0)
	{
		if (s_pSnd_BGM != nullptr)
			s_pSnd_BGM->Play(); // 음악 시작..
	}

	fTmp += CN3Base::s_fSecPerFrm;
	if (fTmp > 21.66f)
	{
		fTmp = 0;
		if (s_pSnd_BGM != nullptr)
			s_pSnd_BGM->Stop();
	}
}

void CGameProcLogIn_1098::Render()
{
	D3DCOLOR crEnv = 0x00000000;
	s_pEng->Clear(crEnv); // 배경은 검은색
	s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...

	 // 카메라 잡기..
	m_pCamera->Tick();
	m_pCamera->Apply();

	for (int i = 0; i < 8; i++)
		s_lpD3DDev->LightEnable(i, FALSE);

	for (int i = 0; i < 3; i++)
		m_pLights[i]->Apply();

	////////////////////////////////////////////
	// 달그리기..
	D3DVIEWPORT9 vp;
	s_lpD3DDev->GetViewport(&vp);

	float fMW = (m_pTexBkg->Width() * vp.Width / 1024.0f)*1.3f;
	float fMH = (m_pTexBkg->Height() * vp.Height / 768.0f)*1.3f;
	float fX = 100.0f * vp.Width / 1024.0f;
	float fY = 50.0f * vp.Height / 768.0f;

	float fRHW = 1.0f;
	__VertexTransformed vMoon[4];
	vMoon[0].Set(fX,     fY,     0, fRHW, 0xffffffff, 0.0f, 0.0f);
	vMoon[1].Set(fX+fMW, fY,     0, fRHW, 0xffffffff, 1.0f, 0.0f);
	vMoon[2].Set(fX+fMW, fY+fMH, 0, fRHW, 0xffffffff, 1.0f, 1.0f);
	vMoon[3].Set(fX,     fY+fMH, 0, fRHW, 0xffffffff, 0.0f, 1.0f);
	
	DWORD dwZWrite;
	s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &dwZWrite);
	s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetTexture(0, m_pTexBkg->Get());
	s_lpD3DDev->SetFVF(FVF_TRANSFORMED);
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vMoon, sizeof(__VertexTransformed));

	s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWrite);
	// 달그리기..
	////////////////////////////////////////////

	m_pChr->Render(); // 캐릭터 그리기...

	CGameProcedure::Render(); // UI 나 그밖의 기본적인 것들 렌더링..

	s_pEng->s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	s_pEng->Present(CN3Base::s_hWndBase);
}

bool CGameProcLogIn_1098::MsgSend_AccountLogIn(e_LogInClassification eLIC)
{
	if (LIC_KNIGHTONLINE == eLIC)
	{
		m_pUILogIn->AccountIDGet(s_szAccount); // 계정 기억..
		m_pUILogIn->AccountPWGet(s_szPassWord); // 비밀번호 기억..
	}

	if (s_szAccount.empty()
		|| s_szPassWord.empty()
		|| s_szAccount.size() >= 20
		|| s_szPassWord.size() >= 12)
		return false;

	m_pUILogIn->SetVisibleLogInUIs(false); // 패킷이 들어올때까지 UI 를 Disable 시킨다...
	m_pUILogIn->SetRequestedLogIn(true);
	m_bLogIn = true; // 로그인 시도..

	uint8_t byBuff[256];										// 패킷 버퍼..
	int iOffset = 0;										// 버퍼의 오프셋..

	uint8_t byCmd = LS_LOGIN_REQ;
	if (eLIC == LIC_MGAME)
		byCmd = LS_MGAME_LOGIN;

	CAPISocket::MP_AddByte(byBuff, iOffset, byCmd);				// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_szAccount.size());	// 아이디 길이..
	CAPISocket::MP_AddString(byBuff, iOffset, s_szAccount);		// 실제 아이디..
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_szPassWord.size());	// 패스워드 길이
	CAPISocket::MP_AddString(byBuff, iOffset, s_szPassWord);		// 실제 패스워드

	s_pSocket->Send(byBuff, iOffset);								// 보낸다

	return true;
}

void CGameProcLogIn_1098::MsgRecv_GameServerGroupList(Packet& pkt)
{
	int iServerCount = pkt.read<uint8_t>();	// 서버 갯수
	for (int i = 0; i < iServerCount; i++)
	{
		int iLen = 0;
		__GameServerInfo GSI;
		iLen = pkt.read<int16_t>();
		pkt.readString(GSI.szIP, iLen);
		iLen = pkt.read<int16_t>();
		pkt.readString(GSI.szName, iLen);
		GSI.iConcurrentUserCount = pkt.read<int16_t>(); // 현재 동시 접속자수..
		
		m_pUILogIn->ServerInfoAdd(GSI); // ServerList
	}

	m_pUILogIn->ServerInfoUpdate();
}

void CGameProcLogIn_1098::MsgRecv_AccountLogIn(int iCmd, Packet& pkt)
{
	int iResult = pkt.read<uint8_t>(); // Recv - b1(0:실패 1:성공 2:ID없음 3:PW틀림 4:서버점검중)
	if (1 == iResult) // 접속 성공..
	{
		// 모든 메시지 박스 닫기..
		MessageBoxClose(-1);
		m_pUILogIn->OpenServerList(); // 서버 리스트 읽기..
	}
	else if (2 == iResult) // ID 가 없어서 실패한거면..
	{
		if (iCmd == LS_LOGIN_REQ)
		{
			std::string szMsg = fmt::format_text_resource(IDS_NOACCOUNT_RETRY_MGAMEID);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);

			MessageBoxPost(szMsg, szTmp, MB_YESNO, BEHAVIOR_MGAME_LOGIN); // MGame ID 로 접속할거냐고 물어본다.
		}
		else
		{
			std::string szMsg = fmt::format_text_resource(IDS_NO_MGAME_ACCOUNT);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);

			MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
		}
	}
	else if (3 == iResult) // PassWord 실패
	{
		std::string szMsg = fmt::format_text_resource(IDS_WRONG_PASSWORD);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}
	else if (4 == iResult) // 서버 점검 중??
	{
		std::string szMsg = fmt::format_text_resource(IDS_SERVER_CONNECT_FAIL);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}
	else if (5 == iResult) // 어떤 넘이 접속해 있다. 서버에게 끊어버리라고 하자..
	{
		int iLen = pkt.read<int16_t>();
		if (iLen > 0)
		{
			std::string szIP;
			pkt.readString(szIP, iLen);
			uint32_t dwPort = pkt.read<int16_t>();

			CAPISocket socketTmp;
			s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
			if (0 == socketTmp.Connect(s_hWndBase, szIP.c_str(), dwPort))
			{
				// 로그인 서버에서 받은 겜서버 주소로 접속해서 짤르라고 꼰지른다.
				int iOffset2 = 0;
				uint8_t Buff[32];
				CAPISocket::MP_AddByte(Buff, iOffset2, WIZ_KICKOUT); // Recv s1, str1(IP) s1(port) | Send s1, str1(ID)
				CAPISocket::MP_AddShort(Buff, iOffset2, (int16_t) s_szAccount.size());
				CAPISocket::MP_AddString(Buff, iOffset2, s_szAccount); // Recv s1, str1(IP) s1(port) | Send s1, str1(ID)

				socketTmp.Send(Buff, iOffset2);
				socketTmp.Disconnect(); // 짜른다..
			}
			s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

			std::string szMsg = fmt::format_text_resource(IDS_LOGIN_ERR_ALREADY_CONNECTED_ACCOUNT);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
			MessageBoxPost(szMsg, szTmp, MB_OK); // 다시 접속 할거냐고 물어본다.
		}
	}
	else
	{
		std::string szMsg = fmt::format_text_resource(IDS_CURRENT_SERVER_ERROR);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}

	if (1 != iResult) // 로그인 실패..
	{
		m_pUILogIn->SetVisibleLogInUIs(true); // 접속 성공..UI 조작 불가능..
		m_pUILogIn->SetRequestedLogIn(false);
		m_bLogIn = false; // 로그인 시도..
	}
}

int CGameProcLogIn_1098::MsgRecv_VersionCheck(Packet & pkt) // virtual
{
	int iVersion = CGameProcedure::MsgRecv_VersionCheck(pkt);
	if (iVersion == CURRENT_VERSION)
	{
		CGameProcedure::MsgSend_GameServerLogIn(); // 게임 서버에 로그인..
		m_pUILogIn->ConnectButtonSetEnable(false);
	}

	return iVersion;
}

int CGameProcLogIn_1098::MsgRecv_GameServerLogIn(Packet & pkt) // virtual - 국가번호를 리턴한다.
{
	int iNation = CGameProcedure::MsgRecv_GameServerLogIn(pkt); // 국가 - 0 없음 0xff - 실패..

	if (0xff == iNation)
	{
		__GameServerInfo GSI;
		m_pUILogIn->ServerInfoGetCur(GSI);

		std::string szMsg = fmt::format_text_resource(IDS_FMT_GAME_SERVER_LOGIN_ERROR,
			GSI.szName, iNation);
		MessageBoxPost(szMsg, "", MB_OK);
		m_pUILogIn->ConnectButtonSetEnable(true); // 실패
	}
	else
	{
		if (0 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_NOTSELECTED;
		else if (1 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_KARUS;
		else if (2 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_ELMORAD;
	}

	if (NATION_NOTSELECTED == s_pPlayer->m_InfoBase.eNation)
	{
		s_SndMgr.ReleaseStreamObj(&s_pSnd_BGM);

		s_pSnd_BGM = s_pEng->s_SndMgr.CreateStreamObj(ID_SOUND_BGM_EL_BATTLE);
		if (s_pSnd_BGM != nullptr)
		{
			s_pSnd_BGM->Looping(true);
			s_pSnd_BGM->Play();
		}

		ProcActiveSet((CGameProcedure*) s_pProcNationSelect);
	}
	else if (NATION_KARUS == s_pPlayer->m_InfoBase.eNation
		|| NATION_ELMORAD == s_pPlayer->m_InfoBase.eNation)
	{
		s_SndMgr.ReleaseStreamObj(&s_pSnd_BGM);

		s_pSnd_BGM = s_SndMgr.CreateStreamObj(ID_SOUND_BGM_EL_BATTLE);
		if (s_pSnd_BGM != nullptr)
		{
			s_pSnd_BGM->Looping(true);
			s_pSnd_BGM->Play();
		}

		ProcActiveSet((CGameProcedure*) s_pProcCharacterSelect);
	}

	return iNation;
}

bool CGameProcLogIn_1098::ProcessPacket(Packet & pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	s_pPlayer->m_InfoBase.eNation = NATION_UNKNOWN;
	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	s_pPlayer->m_InfoBase.eNation = NATION_UNKNOWN;
	switch (iCmd)										// 커멘드에 다라서 분기..
	{
		case LS_SERVERLIST: // 접속하면 바로 보내준다..
			MsgRecv_GameServerGroupList(pkt);
			return true;

		case LS_LOGIN_REQ: // 계정 접속 성공..
		case LS_MGAME_LOGIN: // MGame 계정 접속 성공..
			MsgRecv_AccountLogIn(iCmd, pkt);
			return true;

		case LS_NEWS:
			// act as if it's handled
			return true;
	}

	return false;
}

void CGameProcLogIn_1098::ConnectToGameServer() // 고른 게임 서버에 접속
{
	if (m_fTimeUntilNextGameConnectionAttempt > 0.0f)
		return;

	__GameServerInfo GSI;
	if (!m_pUILogIn->ServerInfoGetCur(GSI))
		return; // 서버를 고른다음..

	const char* ip = GSI.szIP.c_str();
	int port = SOCKET_PORT_GAME;

	s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
	int iErr = s_pSocket->Connect(s_hWndBase, ip, port); // 게임서버 소켓 연결
	s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

	if (iErr != 0)
	{
#if defined(_DEBUG)
		std::string errorMessage = fmt::format(
			"{}:{} (errorCode: {})\n"
			"From config: Version.ini (server)",
			ip, port, iErr);
		MessageBoxPost(errorMessage, "Failed to connect to game server", MB_OK);
#else
		ReportServerConnectionFailed(GSI.szName, iErr, false);
#endif

		m_pUILogIn->ConnectButtonSetEnable(true);
	}
	else
	{
		s_szServer = GSI.szName;
		m_fTimeUntilNextGameConnectionAttempt = TIME_UNTIL_NEXT_GAME_CONNECTION_ATTEMPT;

		MsgSend_VersionCheck();
	}
}
#endif

// ===== END WarFare/GameProcLogIn_1098.cpp =====

// ===== BEGIN WarFare/GameProcLogIn_1098.h =====
#line 1 "WarFare/GameProcLogIn_1098.h"
﻿#pragma once

#if defined(LOGIN_SCENE_VERSION) && LOGIN_SCENE_VERSION == 1098

#include "GameProcedure.h"

class CGameProcLogIn_1098 : public CGameProcedure
{
public:
	class CN3Chr*			m_pChr;
	class CN3Texture*		m_pTexBkg;
	class CUILogIn_1098*	m_pUILogIn;

	class CN3Camera*		m_pCamera;
	class CN3Light*			m_pLights[3];

	bool					m_bLogIn; // 로그인 중복 방지..
	std::string				m_szRegistrationSite;

	float					m_fTimeUntilNextGameConnectionAttempt;

public:
	inline void ResetGameConnectionAttemptTimer()
	{
		m_fTimeUntilNextGameConnectionAttempt = 0.0f;
	}

	void MsgRecv_GameServerGroupList(Packet& pkt);
	void MsgRecv_AccountLogIn(int iCmd, Packet& pkt);
	int	 MsgRecv_VersionCheck(Packet& pkt) override;
	int	 MsgRecv_GameServerLogIn(Packet& pkt) override; // 국가 번호를 리턴한다.

	bool MsgSend_AccountLogIn(enum e_LogInClassification eLIC);

	void Release() override;
	void Init() override;
	void Tick() override;
	void Render() override;

protected:
	bool ProcessPacket(Packet& pkt) override;

public:
	void ConnectToGameServer(); // 고른 게임 서버에 접속
	CGameProcLogIn_1098();
	~CGameProcLogIn_1098() override;
};

class CGameProcLogIn : public CGameProcLogIn_1098 {};

#endif

// ===== END WarFare/GameProcLogIn_1098.h =====

// ===== BEGIN WarFare/GameProcLogIn_1298.cpp =====
#line 1 "WarFare/GameProcLogIn_1298.cpp"
﻿#include "stdafx.h"

#if !defined(LOGIN_SCENE_VERSION) || LOGIN_SCENE_VERSION == 1298
#include "GameProcLogIn_1298.h"
#include "GameEng.h"
#include "UILogIn_1298.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "PacketDef.h"
#include "text_resources.h"

#include <N3Base/N3SndObj.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3SndMgr.h>

#include <ctime>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

using __GameServerInfo = CUILogIn_1298::__GameServerInfo;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcLogIn_1298::CGameProcLogIn_1298()
{
	m_pUILogIn	= nullptr;
	m_bLogIn	= false; // 로그인 중복 방지..
	m_fTimeUntilNextGameConnectionAttempt = 0.0f;
}

CGameProcLogIn_1298::~CGameProcLogIn_1298()
{
	delete m_pUILogIn;
}

void CGameProcLogIn_1298::Release()
{
	CGameProcedure::Release();

	delete m_pUILogIn;
	m_pUILogIn = nullptr;
}

void CGameProcLogIn_1298::Init()
{
	CGameProcedure::Init();
	
	srand((uint32_t) time(nullptr));

	// Random elmorad or karus background
	int iRandomNation = 1 + (rand() % 2);

	m_pUILogIn = new CUILogIn_1298();
	m_pUILogIn->Init(s_pUIMgr);

	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(iRandomNation);
	if (pTbl != nullptr)
		m_pUILogIn->LoadFromFile(pTbl->szLoginIntro);

	m_pUILogIn->SetPosCenter();

	RECT rc;
	rc.left = 0;
	rc.top = 0;
	rc.right = static_cast<int>(s_CameraData.vp.Width);
	rc.bottom = static_cast<int>(s_CameraData.vp.Height);
	m_pUILogIn->SetRegion(rc);
	m_pUILogIn->PositionGroups();

	s_SndMgr.ReleaseStreamObj(&s_pSnd_BGM);

	std::string szFN = "Snd\\Intro_Sound.mp3";
	s_pSnd_BGM = s_SndMgr.CreateStreamObj(szFN);

	if (s_pSnd_BGM != nullptr)
	{
		s_pSnd_BGM->Looping(true);
		s_pSnd_BGM->Play();
	}

	s_pUIMgr->SetFocusedUI(m_pUILogIn);

	// Socket connection..
	char szIniPath[_MAX_PATH] = {};
	lstrcpy(szIniPath, CN3Base::PathGet().c_str());
	lstrcat(szIniPath, "Server.Ini");

	char szRegistrationSite[_MAX_PATH] = {};
	GetPrivateProfileString("Join", "Registration site", "", szRegistrationSite, _MAX_PATH, szIniPath);
	m_szRegistrationSite = szRegistrationSite;

	int iServerCount = GetPrivateProfileInt("Server", "Count", 0, szIniPath);

	char szIPs[256][32] = {};
	for (int i = 0; i < iServerCount; i++)
	{
		std::string key = fmt::format("IP{}", i);
		GetPrivateProfileString("Server", key.c_str(), "", szIPs[i], 32, szIniPath);
	}

	int iServer = -1;
	if (iServerCount > 0)
		iServer = rand() % iServerCount;

	if (iServer >= 0
		&& lstrlen(szIPs[iServer]) > 0)
	{
		const char* ip = szIPs[iServer];
		int port = SOCKET_PORT_LOGIN;

		s_bNeedReportConnectionClosed = false; // Should I report that the server connection was lost?
		int iErr = s_pSocket->Connect(s_hWndBase, ip, port);
		s_bNeedReportConnectionClosed = true;

		if (iErr != 0)
		{
#if defined(_DEBUG)
			std::string errorMessage = fmt::format(
				"{}:{} (errorCode: {})\n"
				"From config: Server.ini (client)",
				ip, port, iErr);
			MessageBoxPost(errorMessage, "Failed to connect to login server", MB_OK, BEHAVIOR_EXIT);
#else
			ReportServerConnectionFailed("LogIn Server", iErr, true);
#endif
		}
		else
		{
			m_pUILogIn->FocusToID(); // Focus on the ID input box..

			// 게임 서버 리스트 요청..
			int iOffset = 0;
			uint8_t byBuffs[4];
			CAPISocket::MP_AddByte(byBuffs, iOffset, LS_SERVERLIST);					// 커멘드.
			s_pSocket->Send(byBuffs, iOffset);											// 보낸다
		}
	}
	else
	{
		MessageBoxPost("No server list", "LogIn Server fail", MB_OK, BEHAVIOR_EXIT); // 끝낸다.
	}

	// 게임 계정으로 들어 왔으면..
	if (LIC_KNIGHTONLINE != s_eLogInClassification)
	{
		MsgSend_AccountLogIn(s_eLogInClassification); // 로그인..
	}

	// Re-entered the scene; we can reset any existing timer.
	// The point of this delay is to prevent the user from intentionally or otherwise spamming connections
	// to the game server, in the small window where we're still on the login scene and are waiting for the
	// game server to respond.
	// Once we've changed scenes, this timer doesn't matter anymore; we can't continue to spam it.
	// Returning back to this scene, then, means we're fine to have it reset.
	ResetGameConnectionAttemptTimer();
}

void CGameProcLogIn_1298::Tick()
{
	CGameProcedure::Tick();

	if (m_fTimeUntilNextGameConnectionAttempt > 0.0f)
	{
		m_fTimeUntilNextGameConnectionAttempt -= s_fSecPerFrm;
		if (m_fTimeUntilNextGameConnectionAttempt < 0.0f)
			m_fTimeUntilNextGameConnectionAttempt = 0.0f;
	}
}

void CGameProcLogIn_1298::Render()
{
	D3DCOLOR crEnv = 0x00000000;
	s_pEng->Clear(crEnv);						// background color black
	s_lpD3DDev->BeginScene();			// scene render start

	D3DVIEWPORT9 vp;
	s_lpD3DDev->GetViewport(&vp);
	
	DWORD dwZWrite;
	s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &dwZWrite);
	s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetFVF(FVF_TRANSFORMED);
	s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWrite);
	CGameProcedure::Render(); // Render UI and other basic elements.

	s_lpD3DDev->EndScene();	// Starting scene rendering...

	s_pEng->Present(CN3Base::s_hWndBase);
}

bool CGameProcLogIn_1298::MsgSend_AccountLogIn(e_LogInClassification eLIC)
{
	if (LIC_KNIGHTONLINE == eLIC)
	{
		m_pUILogIn->AccountIDGet(s_szAccount); // 계정 기억..
		m_pUILogIn->AccountPWGet(s_szPassWord); // 비밀번호 기억..
	}

	if (s_szAccount.empty()
		|| s_szPassWord.empty()
		|| s_szAccount.size() >= 20
		|| s_szPassWord.size() >= 12)
		return false;

	m_pUILogIn->SetVisibleLogInUIs(false); // 패킷이 들어올때까지 UI 를 Disable 시킨다...
	m_pUILogIn->SetRequestedLogIn(true);
	m_bLogIn = true; // 로그인 시도..

	uint8_t byBuff[256];										// 패킷 버퍼..
	int iOffset = 0;										// 버퍼의 오프셋..

	uint8_t byCmd = LS_LOGIN_REQ;
	if (eLIC == LIC_MGAME)
		byCmd = LS_MGAME_LOGIN;

	CAPISocket::MP_AddByte(byBuff, iOffset, byCmd);				// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_szAccount.size());	// 아이디 길이..
	CAPISocket::MP_AddString(byBuff, iOffset, s_szAccount);		// 실제 아이디..
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_szPassWord.size());	// 패스워드 길이
	CAPISocket::MP_AddString(byBuff, iOffset, s_szPassWord);		// 실제 패스워드

	s_pSocket->Send(byBuff, iOffset);								// 보낸다

	return true;
}

bool CGameProcLogIn_1298::MsgSend_NewsReq()
{
	uint8_t byBuff[2];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, LS_NEWS);
	s_pSocket->Send(byBuff, iOffset);

	return true;
}

void CGameProcLogIn_1298::MsgRecv_News(Packet& pkt)
{
	uint16_t strLen = pkt.read<uint16_t>();
	std::string strLabel;
	pkt.readString(strLabel, strLen);

	if (strLabel != "Login Notice")
		return;

	// check limits
	uint16_t wSize = pkt.read<uint16_t>();
	if (wSize == 0
		|| wSize >= 4096)
		return;

	// read content
	std::string strContent;
	pkt.readString(strContent, wSize);

	m_pUILogIn->AddNews(strContent);
}

void CGameProcLogIn_1298::MsgRecv_GameServerGroupList(Packet& pkt)
{
	int iServerCount = pkt.read<uint8_t>();	// 서버 갯수
	for (int i = 0; i < iServerCount; i++)
	{
		int iLen = 0;
		__GameServerInfo GSI;
		iLen = pkt.read<int16_t>();
		pkt.readString(GSI.szIP, iLen);
		iLen = pkt.read<int16_t>();
		pkt.readString(GSI.szName, iLen);
		GSI.iConcurrentUserCount = pkt.read<int16_t>(); // 현재 동시 접속자수..
		
		m_pUILogIn->ServerInfoAdd(GSI); // ServerList
	}

	m_pUILogIn->ServerInfoUpdate();
}

void CGameProcLogIn_1298::MsgRecv_AccountLogIn(int iCmd, Packet& pkt)
{
	// Recv - b1 (0: Failure, 1: Success, 2: ID Not Found, 3: Incorrect Password,
	// 4: Server Under Maintenance)
	
	int iResult = pkt.read<uint8_t>();

	// Connection successful
	if (1 == iResult)
	{
		// request news from server
		MsgSend_NewsReq();

		// Close all message boxes..
		MessageBoxClose(-1);
		
		m_pUILogIn->OpenNews();
	}
	// ID not found
	else if (2 == iResult)
	{
		if (iCmd == LS_LOGIN_REQ)
		{
			std::string szMsg = fmt::format_text_resource(IDS_NOACCOUNT_RETRY_MGAMEID);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);

			MessageBoxPost(szMsg, szTmp, MB_YESNO, BEHAVIOR_MGAME_LOGIN); // MGame ID 로 접속할거냐고 물어본다.
		}
		else
		{
			std::string szMsg = fmt::format_text_resource(IDS_NO_MGAME_ACCOUNT);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);

			MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
		}
	}
	else if (3 == iResult) // PassWord 실패
	{
		std::string szMsg = fmt::format_text_resource(IDS_WRONG_PASSWORD);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}
	else if (4 == iResult) // 서버 점검 중??
	{
		std::string szMsg = fmt::format_text_resource(IDS_SERVER_CONNECT_FAIL);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}
	else if (5 == iResult) // 어떤 넘이 접속해 있다. 서버에게 끊어버리라고 하자..
	{
		int iLen = pkt.read<int16_t>();
		if (iLen > 0)
		{
			std::string szIP;
			pkt.readString(szIP, iLen);
			uint32_t dwPort = pkt.read<int16_t>();

			CAPISocket socketTmp;
			s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
			if (0 == socketTmp.Connect(s_hWndBase, szIP.c_str(), dwPort))
			{
				// 로그인 서버에서 받은 겜서버 주소로 접속해서 짤르라고 꼰지른다.
				int iOffset2 = 0;
				uint8_t Buff[32];
				CAPISocket::MP_AddByte(Buff, iOffset2, WIZ_KICKOUT); // Recv s1, str1(IP) s1(port) | Send s1, str1(ID)
				CAPISocket::MP_AddShort(Buff, iOffset2, (int16_t) s_szAccount.size());
				CAPISocket::MP_AddString(Buff, iOffset2, s_szAccount); // Recv s1, str1(IP) s1(port) | Send s1, str1(ID)

				socketTmp.Send(Buff, iOffset2);
				socketTmp.Disconnect(); // 짜른다..
			}
			s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

			std::string szMsg = fmt::format_text_resource(IDS_LOGIN_ERR_ALREADY_CONNECTED_ACCOUNT);
			std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
			MessageBoxPost(szMsg, szTmp, MB_OK); // 다시 접속 할거냐고 물어본다.
		}
	}
	else
	{
		std::string szMsg = fmt::format_text_resource(IDS_CURRENT_SERVER_ERROR);
		std::string szTmp = fmt::format_text_resource(IDS_CONNECT_FAIL);
		MessageBoxPost(szMsg, szTmp, MB_OK); // MGame ID 로 접속할거냐고 물어본다.
	}

	// 로그인 실패..
	if (1 != iResult)
	{
		m_pUILogIn->SetVisibleLogInUIs(true); // 접속 성공..UI 조작 불가능..
		m_pUILogIn->SetRequestedLogIn(false);
		m_bLogIn = false; // 로그인 시도..
	}
}

int CGameProcLogIn_1298::MsgRecv_VersionCheck(Packet & pkt) // virtual
{
	int iVersion = CGameProcedure::MsgRecv_VersionCheck(pkt);
	if (iVersion == CURRENT_VERSION)
	{
		CGameProcedure::MsgSend_GameServerLogIn(); // 게임 서버에 로그인..
		m_pUILogIn->ConnectButtonSetEnable(false);
	}

	return iVersion;
}

int CGameProcLogIn_1298::MsgRecv_GameServerLogIn(Packet & pkt) // virtual - 국가번호를 리턴한다.
{
	int iNation = CGameProcedure::MsgRecv_GameServerLogIn(pkt); // 국가 - 0 없음 0xff - 실패..

	if (0xff == iNation)
	{
		__GameServerInfo GSI;
		m_pUILogIn->ServerInfoGetCur(GSI);

		std::string szMsg = fmt::format_text_resource(IDS_FMT_GAME_SERVER_LOGIN_ERROR,
			GSI.szName, iNation);
		MessageBoxPost(szMsg, "", MB_OK);
		m_pUILogIn->ConnectButtonSetEnable(true); // 실패
	}
	else
	{
		if (0 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_NOTSELECTED;
		else if (1 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_KARUS;
		else if (2 == iNation)
			s_pPlayer->m_InfoBase.eNation = NATION_ELMORAD;
	}

	if (NATION_NOTSELECTED == s_pPlayer->m_InfoBase.eNation)
	{
		ProcActiveSet((CGameProcedure*) s_pProcNationSelect);
	}
	else if (NATION_KARUS == s_pPlayer->m_InfoBase.eNation
		|| NATION_ELMORAD == s_pPlayer->m_InfoBase.eNation)
	{
		ProcActiveSet((CGameProcedure*) s_pProcCharacterSelect);
	}

	return iNation;
}

bool CGameProcLogIn_1298::ProcessPacket(Packet & pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	s_pPlayer->m_InfoBase.eNation = NATION_UNKNOWN;
	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	s_pPlayer->m_InfoBase.eNation = NATION_UNKNOWN;
	switch (iCmd)										// 커멘드에 다라서 분기..
	{
		case LS_SERVERLIST: // 접속하면 바로 보내준다..
			MsgRecv_GameServerGroupList(pkt);
			return true;

		case LS_LOGIN_REQ: // 계정 접속 성공..
		case LS_MGAME_LOGIN: // MGame 계정 접속 성공..
			MsgRecv_AccountLogIn(iCmd, pkt);
			return true;
	
		case LS_NEWS:
			MsgRecv_News(pkt);
			return true;
	}

	return false;
}

void CGameProcLogIn_1298::ConnectToGameServer() // 고른 게임 서버에 접속
{
	if (m_fTimeUntilNextGameConnectionAttempt > 0.0f)
		return;

	__GameServerInfo GSI;
	if (!m_pUILogIn->ServerInfoGetCur(GSI))
		return; // 서버를 고른다음..

	const char* ip = GSI.szIP.c_str();
	int port = SOCKET_PORT_GAME;

	s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
	int iErr = s_pSocket->Connect(s_hWndBase, ip, port); // 게임서버 소켓 연결
	s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

	if (iErr != 0)
	{
#if defined(_DEBUG)
		std::string errorMessage = fmt::format(
			"{}:{} (errorCode: {})\n"
			"From config: Version.ini (server)",
			ip, port, iErr);
		MessageBoxPost(errorMessage, "Failed to connect to game server", MB_OK);
#else
		ReportServerConnectionFailed(GSI.szName, iErr, false);
#endif

		m_pUILogIn->ConnectButtonSetEnable(true);
	}
	else
	{
		s_szServer = GSI.szName;
		m_fTimeUntilNextGameConnectionAttempt = TIME_UNTIL_NEXT_GAME_CONNECTION_ATTEMPT;

		MsgSend_VersionCheck();
	}
}
#endif

// ===== END WarFare/GameProcLogIn_1298.cpp =====

// ===== BEGIN WarFare/GameProcLogIn_1298.h =====
#line 1 "WarFare/GameProcLogIn_1298.h"
﻿#pragma once

#if !defined(LOGIN_SCENE_VERSION) || LOGIN_SCENE_VERSION == 1298

#include "GameProcedure.h"

class CUILogIn_1298;
class CGameProcLogIn_1298 : public CGameProcedure
{
public:
	CUILogIn_1298*	m_pUILogIn;
	
	bool			m_bLogIn; // 로그인 중복 방지..
	std::string		m_szRegistrationSite;

	float			m_fTimeUntilNextGameConnectionAttempt;

public:
	inline void ResetGameConnectionAttemptTimer()
	{
		m_fTimeUntilNextGameConnectionAttempt = 0.0f;
	}

	void MsgRecv_GameServerGroupList(Packet& pkt);
	void MsgRecv_AccountLogIn(int iCmd, Packet& pkt);
	int MsgRecv_VersionCheck(Packet& pkt) override;
	int MsgRecv_GameServerLogIn(Packet& pkt) override; // 국가 번호를 리턴한다.
	void MsgRecv_News(Packet& pkt);

	bool MsgSend_AccountLogIn(enum e_LogInClassification eLIC);
	bool MsgSend_NewsReq();

	void Release() override;
	void Init() override;
	void Tick() override;
	void Render() override;

protected:
	bool ProcessPacket(Packet& pkt) override;

public:
	void ConnectToGameServer(); // 고른 게임 서버에 접속
	CGameProcLogIn_1298();
	~CGameProcLogIn_1298() override;
};

class CGameProcLogIn : public CGameProcLogIn_1298 {};

#endif

// ===== END WarFare/GameProcLogIn_1298.h =====

// ===== BEGIN WarFare/GameProcMain.cpp =====
#line 1 "WarFare/GameProcMain.cpp"
﻿// GameProcMain.cpp: implementation of the CGameProcMain class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "GameProcMain.h"

#include "GameEng.h"
#include "LocalInput.h"

#include "APISocket.h"
#include "PacketDef.h"

#include "PlayerMySelf.h"
#include "PlayerOtherMgr.h"
#include "ServerMesh.h"
#include "N3FXMgr.h"

#include "UIManager.h"
#include "UILoading.h"
#include "UIChat.h"
#include "UIInventory.h"
#include "UICmd.h"
#include "UIVarious.h"
#include "UIStateBar.h"
#include "UITargetBar.h"
#include "UITransactionDlg.h"
#include "UIExitMenu.h"
#include "UIHelp.h"
#include "UIMessageWnd.h"
#include "UINotice.h"
#include "UIDroppedItemDlg.h"
#include "UIPerTradeDlg.h"
#include "UIPartyOrForce.h"
#include "UISkillTreeDlg.h"
#include "UICmdList.h"
#include "UICmdEdit.h"
#include "UIHotKeyDlg.h"
#include "UIClassChange.h"
#include "UINpcEvent.h"
#include "UIRepairTooltipDlg.h"
#include "UIKnightsOperation.h"
#include "UIPartyBBS.h"
#include "UIWareHouseDlg.h"
#include "UINPCChangeEvent.h"
#include "UIWarp.h"
#include "UIInn.h"
#include "UICreateClanName.h"
#include "UITradeSellBBS.h"
#include "UITradeBBSSelector.h"
#include "UITradeBBSEditDlg.h"
#include "UIQuestMenu.h"
#include "UIQuestTalk.h"
#include "UIDead.h"
#include "UIUpgradeSelect.h"
#include "UILevelGuide.h"
#include "UIMsgBoxOkCancel.h"

#include "SubProcPerTrade.h"
#include "CountableItemEditDlg.h"
#include "MagicSkillMng.h"
#include "WarMessage.h"
#include "GameCursor.h"
#include "N3WorldManager.h"
#include "LightMgr.h"
#include "text_resources.h"

#include <N3Base/N3SkyMng.h>
#include <N3Base/N3ShapeExtra.h>
#include <N3Base/N3Camera.h>
#include <N3Base/N3SndObj.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3SndMgr.h>

#include <N3Base/N3UIButton.h>

#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

std::string g_szCmdMsg[CMD_COUNT]; // 게임상 명령어

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcMain::CGameProcMain()				// r기본 생성자.. 각 변수의 역활은 헤더 참조..
{	
	m_fMBRotateTime = -1.0f;
	m_fExitTimer = -1.0f;
	m_fLBClickTime = 0.0f;
	m_bLoadComplete	= FALSE;
	m_fRequestGameSave = 300.0f;

	//sound obj...
	m_pSnd_Town = nullptr;
	m_pSnd_Battle = nullptr;

	m_iJoinReqClan = 0;
	m_iJoinReqClanRequierID = 0;

	m_bIsExitCanceled = FALSE;
	m_eExitType = EXIT_TYPE_NONE;
	m_iExitTimeRemaining = EXIT_TIME_AFTER_BATTLE;

	//UI
	m_pUIMsgDlg = new CUIMessageWnd();
	m_pUIMsgDlg2 = new CUIMessageWnd2();
	m_pUIChatDlg = new CUIChat();
	m_pUIChatDlg2 = new CUIChat2();
	m_pUIStateBarAndMiniMap = new CUIStateBar();
	m_pUIVar = new CUIVarious();
	m_pUICmd = new CUICmd();
	m_pUITargetBar = new CUITargetBar();
	m_pUIExitMenu = new CUIExitMenu();
	m_pUIHelp = new CUIHelp();
	m_pUINotice = new CUINotice();
	m_pUIClassChange = new CUIClassChange();
	m_pUINpcEvent = new CUINPCEvent();
	m_pUIRepairTooltip = new CUIRepairTooltipDlg();
	m_pUIDroppedItemDlg = new CUIDroppedItemDlg();
	m_pUITransactionDlg = new CUITransactionDlg();
	m_pUIInventory = new CUIInventory();
	m_pUIPartyOrForce = new CUIPartyOrForce();
	m_pUISkillTreeDlg = new CUISkillTreeDlg();
	m_pUICmdList = new CUICmdList();
	m_pUICmdEdit = new CUICmdEdit();
	m_pUIHotKeyDlg = new CUIHotKeyDlg();
	m_pUIKnightsOp = new CUIKnightsOperation();			// 기사단 리스트 보기, 가입, 등...
	m_pUIPartyBBS = new CUIPartyBBS(); // 파티 지원 시스템 게시판??..
	m_pUIWareHouseDlg = new CUIWareHouseDlg();
	m_pUINpcChange = new CUINPCChangeEvent();	
	m_pUIWarp = new CUIWarp();
	m_pUIInn = new CUIInn();
	m_pUICreateClanName = new CUICreateClanName();
	m_pUITradeBBS = new CUITradeSellBBS();
	m_pUITradeBBSSelector = new CUITradeBBSSelector();	
	m_pUITradeBBSEdit = new CUITradeBBSEditDlg();
	m_pUIQuestMenu = new CUIQuestMenu();
	m_pUIQuestTalk = new CUIQuestTalk();
	m_pUIDead = new CUIDead();
	m_pUIUpgradeSelect = new CUIUpgradeSelect();
	m_pUILevelGuide = new CUILevelGuide();

	m_pSubProcPerTrade = new CSubProcPerTrade();
	m_pMagicSkillMng = new CMagicSkillMng(this);
	m_pTargetSymbol = new CN3Shape(); // 플레이어가 타겟으로 잡은 캐릭터의 위치위에 그리면 된다..
	m_pWarMessage = new CWarMessage;

	m_pLightMgr = new CLightMgr;
}

CGameProcMain::~CGameProcMain()
{
	this->Release();

	//UI
	delete m_pUIMsgDlg;
	delete m_pUIMsgDlg2;
	delete m_pUIChatDlg;
	delete m_pUIChatDlg2;
	delete m_pUIStateBarAndMiniMap;
	delete m_pUIVar;
	delete m_pUICmd;
	delete m_pUITargetBar;
	delete m_pUIExitMenu;
	delete m_pUIHelp;
	delete m_pUINotice;
	delete m_pUIClassChange;
	delete m_pUINpcEvent;
	delete m_pUIDroppedItemDlg;
	delete m_pUITransactionDlg;
	delete m_pUIInventory;
	delete m_pUIPartyOrForce;
	delete m_pUISkillTreeDlg;
	delete m_pUICmdList;
	delete m_pUICmdEdit;
	delete m_pUIHotKeyDlg;
	delete m_pUIKnightsOp;
	delete m_pUIPartyBBS;
	delete m_pUIWareHouseDlg;
	delete m_pUINpcChange;
	delete m_pUIWarp;
	delete m_pUIInn;
	delete m_pUICreateClanName;
	delete m_pUITradeBBS;
	delete m_pUITradeBBSSelector;
	delete m_pUITradeBBSEdit;
	delete m_pUIQuestMenu;
	delete m_pUIQuestTalk;
	delete m_pUIDead;
	delete m_pUIUpgradeSelect;
	delete m_pUILevelGuide;

	delete m_pSubProcPerTrade;
	delete m_pMagicSkillMng;
	delete m_pWarMessage;
	delete m_pTargetSymbol; // 플레이어가 타겟으로 잡은 캐릭터의 위치위에 그리면 된다..

	delete m_pLightMgr;
}

void CGameProcMain::Release()
{
	this->ReleaseSound();
	this->ReleaseUIs();

	m_pSubProcPerTrade->Release();
	m_pMagicSkillMng->Release();
	m_pWarMessage->Release();
	m_pTargetSymbol->Release();
	m_pLightMgr->Release();

	CGameProcedure::Release();
}

void CGameProcMain::ReleaseUIs()
{
	m_pUIChatDlg->Release();
	m_pUIChatDlg2->Release();
	m_pUIMsgDlg->Release();
	m_pUIMsgDlg2->Release();
	m_pUICmd->Release();
	m_pUIVar->Release();
	m_pUIStateBarAndMiniMap->Release();
	m_pUITargetBar->Release();
	m_pUIExitMenu->Release();
	m_pUIHelp->Release();
	m_pUINotice->Release();
	m_pUIClassChange->Release();
	m_pUINpcEvent->Release();
	m_pUIRepairTooltip->Release();
	m_pUIPartyOrForce->Release();
	m_pUISkillTreeDlg->Release();
	m_pUICmdList->Release();
	m_pUICmdEdit->Release();
	m_pUIHotKeyDlg->Release();
	m_pUIKnightsOp->Release();			// 기사단 리스트 보기, 가입, 등...
	m_pUIPartyBBS->Release();
	m_pUIWareHouseDlg->Release();
	m_pUINpcChange->Release();
	m_pUIWarp->Release();
	m_pUIInn->Release();
	m_pUICreateClanName->Release();
	m_pUIUpgradeSelect->Release();
	m_pUILevelGuide->Release();

	CN3UIBase::DestroyTooltip();
}

void CGameProcMain::Init()
{
	CGameProcedure::Init();
	m_pLightMgr->Release();
	s_pEng->SetDefaultLight(m_pLightMgr->Light(0), m_pLightMgr->Light(1), m_pLightMgr->Light(2));

	// Reset lighting from previous scenes.
	// Our scene will setup lighting as needed.
	for (int i = 0; i < 8; i++)
		s_lpD3DDev->LightEnable(i, FALSE);

	int i = 0;
	for (uint32_t resource = IDS_CMD_WHISPER; resource <= IDS_CMD_INDIVIDUAL_BATTLE; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_TRADE; resource <= IDS_CMD_MERCHANT; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_PARTY; resource <= IDS_CMD_PERMITPARTY; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_JOINCLAN; resource <= IDS_CMD_CLAN_BATTLE; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_CONFEDERACY; resource <= IDS_CMD_DECLARATION; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_VISIBLE; resource <= IDS_CMD_PLC; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_HIDE; resource <= IDS_CMD_DESTROY; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	for (uint32_t resource = IDS_CMD_ROYALORDER; resource <= IDS_CMD_REWARD; resource++)
		g_szCmdMsg[i++] = fmt::format_text_resource(resource);

	s_SndMgr.ReleaseStreamObj(&s_pSnd_BGM);

	if (m_pWarMessage != nullptr)
		m_pWarMessage->InitFont();

	InitUI(); // 국가에 따라 다른 UI 로딩...
	InitZone(s_pPlayer->m_InfoExt.iZoneCur, s_pPlayer->Position()); // 존 로딩..

	//sound obj...
	if (m_pSnd_Battle == nullptr)
	{
		int iIDSndBattle = ((NATION_KARUS == s_pPlayer->m_InfoBase.eNation) ? ID_SOUND_BGM_KA_BATTLE : ID_SOUND_BGM_EL_BATTLE);
		m_pSnd_Battle = s_pEng->s_SndMgr.CreateStreamObj(iIDSndBattle);	// 전투음악 ID
		if (m_pSnd_Battle)
		{
			m_pSnd_Battle->Looping(true);
			m_pSnd_Battle->Stop();
		}
	}

	if (m_pSnd_Town == nullptr)
	{
		m_pSnd_Town = s_pEng->s_SndMgr.CreateStreamObj(ID_SOUND_BGM_TOWN);	// 마을음악 ID
		if (m_pSnd_Town)
		{
			m_pSnd_Town->Looping(true);
			m_pSnd_Town->Play(nullptr, 3.0f);
		}
	}

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data...", 0);

	// 경로 기억..
	char szPathOld[_MAX_PATH], szPathFind[_MAX_PATH];
	::GetCurrentDirectory(_MAX_PATH, szPathOld);

	_finddata_t fi;
	intptr_t hFind = 0;

	// 리소스 다 읽기..
	// 에니메이션 다 읽기..
	lstrcpy(szPathFind, szPathOld);
	lstrcat(szPathFind, "\\Chr");
	::SetCurrentDirectory(szPathFind);
	hFind = _findfirst("*.N3Anim", &fi);
	if (hFind)
	{
		std::string szFN = "Chr\\";
		szFN += fi.name;
		CN3AnimControl* pObjTmp = s_MngAniCtrl.Get(szFN);
		while (_findnext(hFind, &fi) != -1)
		{
			szFN = "Chr\\";
			szFN += fi.name;
			pObjTmp = s_MngAniCtrl.Get(szFN);
		}
	}
	_findclose(hFind);

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data... 10 %", 10);

	// 리소스 다 읽기..
	// 텍스처 다 읽기..
	lstrcpy(szPathFind, szPathOld);
	lstrcat(szPathFind, "\\Item");
	::SetCurrentDirectory(szPathFind);
	hFind = _findfirst("*.dxt", &fi);
	if (hFind)
	{
		std::string szFN = "Item\\";
		szFN += fi.name;
		CN3Texture* pObjTmp = s_MngTex.Get(szFN);
		while (_findnext(hFind, &fi) != -1)
		{
			szFN = "Item\\";
			szFN += fi.name;
			pObjTmp = s_MngTex.Get(szFN);
		}
	}
	_findclose(hFind);

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data... 25 %", 25);

	// 리소스 다 읽기..
	// 조인트 다 읽기..
	lstrcpy(szPathFind, szPathOld);
	lstrcat(szPathFind, "\\Chr");
	::SetCurrentDirectory(szPathFind);
	hFind = _findfirst("*.N3Joint", &fi);
	if (hFind)
	{
		std::string szFN = "Chr\\";
		szFN += fi.name;
		CN3Joint* pObjTmp = s_MngJoint.Get(szFN);
		while (_findnext(hFind, &fi) != -1)
		{
			szFN = "Chr\\";
			szFN += fi.name;
			pObjTmp = s_MngJoint.Get(szFN);
		}
	}
	_findclose(hFind);

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data... 50 %", 50);

	// 리소스 다 읽기..
	// 스킨 읽기..
	lstrcpy(szPathFind, szPathOld);
	lstrcat(szPathFind, "\\Item");
	::SetCurrentDirectory(szPathFind);
	hFind = _findfirst("*.N3CSkins", &fi);
	if (hFind)
	{
		std::string szFN = "Item\\";
		szFN += fi.name;
		CN3CPartSkins* pObjTmp = s_MngSkins.Get(szFN);
		while (_findnext(hFind, &fi) != -1)
		{
			szFN = "Item\\";
			szFN += fi.name;
			pObjTmp = s_MngSkins.Get(szFN);
		}
	}
	_findclose(hFind);

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data... 75 %", 75);

	// 리소스 다 읽기..
	// PMesh 읽기..
	lstrcpy(szPathFind, szPathOld);
	lstrcat(szPathFind, "\\Item");
	::SetCurrentDirectory(szPathFind);
	hFind = _findfirst("*.N3PMesh", &fi);
	if (hFind)
	{
		std::string szFN = "Item\\";
		szFN += fi.name;
		CN3PMesh* pObjTmp = s_MngPMesh.Get(szFN);
		while (_findnext(hFind, &fi) != -1)
		{
			szFN = "Item\\";
			szFN += fi.name;
			pObjTmp = s_MngPMesh.Get(szFN);
		}
	}
	_findclose(hFind);

	if (s_pUILoading != nullptr)
		s_pUILoading->Render("Loading Character Data... 100 %", 100);

	MsgSend_GameStart();

	// 경로 돌리기..
	::SetCurrentDirectory(szPathOld);
}

void CGameProcMain::InitPlayerPosition(const __Vector3& vPos) // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
{
	__Vector3 vPosFinal = vPos;
	float fYTerrain = ACT_WORLD->GetHeightWithTerrain(vPos.x, vPos.z);	// 지형의 높이값 얻기..
	float fYObject = ACT_WORLD->GetHeightNearstPosWithShape(vPos, 1.0f); // 오브젝트에서 가장 가까운 높이값 얻기..
	if (!s_pWorldMgr->IsIndoor())
	{
		if (std::abs(vPos.y - fYObject) < std::abs(vPos.y - fYTerrain)) vPosFinal.y = fYObject; // 좀더 가까운 곳에 놓는다..
		else vPosFinal.y = fYTerrain;
	}
	else
	{
		if (fYObject > fYTerrain)
			vPosFinal.y = fYObject;
		else
			vPosFinal.y = fYTerrain;
	}

	s_pPlayer->PositionSet(vPosFinal, true);	// 캐릭터 위치 셋팅..	
	s_pPlayer->m_vPosFromServer = vPos;
	m_vPlayerPosSended = vPos;					// 최근에 보낸 위치 세팅..
	m_fMsgSendTimeMove = 0;						// 시간을 기록한다..

	this->CommandSitDown(false, false, true); // 일으켜 세운다.. 앉아있는 상태에서 워프하면.. 버그가 있다..
	this->TargetSelect(-1, false); // 타겟 해제..
	this->UpdateCameraAndLight(); // 카메라와 라이트 다시 계산..

	s_pPlayer->Action(PSA_BASIC, true, nullptr, true); // 강제로 기본 자세..
}

void CGameProcMain::Tick()
{
	CGameProcedure::Tick();	// 키, 마우스 입력 등등..

	if ( FALSE == m_bLoadComplete ) return;				// 로딩이 안되었으면.. 돌아간다.
	if(!s_pSocket->IsConnected()) return;

#ifdef _DEBUG
	if(s_pLocalInput->IsKeyPressed(DIK_F11))
	{
		uint8_t byBuff[32];
		int iOffset = 0;
		CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_TEST_PACKET);
		s_pSocket->Send(byBuff, iOffset);


		CLogWriter::Write("NPC Region Test : {}", s_pOPMgr->m_NPCs.size());
		it_NPC it = s_pOPMgr->m_NPCs.begin(), itEnd = s_pOPMgr->m_NPCs.end();
		for (; it != itEnd; it++)
		{
			CPlayerNPC* pNPC = it->second;

			CLogWriter::Write("    ID({}) Name({}) Pos({:.1f}, {:.1f})",
				pNPC->IDNumber(), pNPC->IDString(),
				pNPC->m_vPosFromServer.x, pNPC->m_vPosFromServer.z);
		}

	}
#endif

	uint32_t dwMouseFlags = s_pLocalInput->MouseGetFlag();	// 마우스 버튼 플래그 - LocalInput.h 참조
	this->ProcessLocalInput(dwMouseFlags);					// 키보드나 마우스 입력은 UI 다음에 처리...

	MsgSend_Continous();									// 일정 시간마다 움직임과 회전값, 공격등을 체크해서 패킷 만들어 보냄..

	s_pPlayer->Tick();									// 플레이어 틱(갱신)
	s_pWorldMgr->Tick();
	s_pOPMgr->Tick(s_pPlayer->Position());				// 다른 유저 관리자 틱(갱신)
//	s_pFX->Tick(); //내부에서 카메라 값을 쓸 경우 위치가 오차가 생겨 Render()함수 안으로 옮김...

	__Vector3 ListenerPos = s_pPlayer->Position();
	__Vector3 ListenerDir = s_pPlayer->Direction();
	__Vector3 ListenerUp(0,1,0);

	// Sound Tick...
	CN3SndObj::SetListenerPos(&ListenerPos);
	CN3SndObj::SetListenerOrientation(&ListenerDir, &ListenerUp);

	this->UpdateUI_MiniMap(); // 미니맵 업데이트..
	this->UpdateUI_TargetBar(); // 타겟바 처리..
	this->UpdateBGM(); // 배경음악을 상황에 따라 처리..
	this->UpdateCameraAndLight(); // 카메라와 라이트 처리..
	
//	ProcessPlayerInclination();							// 경사 처리..(가만히 있어도 경사가 급하면 미끄러짐..).
#ifdef _N3_64GRID_
	m_SMesh.Tick(s_pPlayer, &m_Terrain);				// 서버 메시 틱.(갱신)
#endif

	m_pUIStateBarAndMiniMap->UpdatePosition(s_pPlayer->Position(), s_pPlayer->Yaw()); // 위치 업데이트.

	if(m_pMagicSkillMng) m_pMagicSkillMng->Tick();
	if(m_pWarMessage) m_pWarMessage->Tick();
	if(m_pLightMgr) m_pLightMgr->Tick();
	
	float fTime = CN3Base::TimeGet();
	static float fTimePrev = fTime;
	
	if (m_bIsExitCanceled
		&& m_fExitTimer != -1.0f)
	{
		if (m_fExitTimer < (float) EXIT_TIME_AFTER_BATTLE)
		{
			m_fExitTimer += fTime - fTimePrev;
		}
		else
		{
			m_fExitTimer = -1.0f;
			m_bIsExitCanceled = FALSE;
		}
	}

	if (m_eExitType != EXIT_TYPE_NONE)
	{
		int secondsRemaining = (int) (EXIT_TIME_AFTER_BATTLE - m_fExitTimer);
		if (m_iExitTimeRemaining > secondsRemaining)
		{
			m_iExitTimeRemaining = secondsRemaining;

			if (m_pUIChatDlg != nullptr)
			{
				std::string szMsg = fmt::format_text_resource(IDS_EXITING_GAME_IN_X_SECONDS,
					m_iExitTimeRemaining);
				m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
			}

			if (secondsRemaining <= 0)
			{
				if (m_eExitType == EXIT_TYPE_QUIT)
				{
					PostQuitMessage(0);
				}
				else if (m_eExitType == EXIT_TYPE_CHR_SELECT
					&& m_pUIExitMenu != nullptr)
				{
					m_eExitType = EXIT_TYPE_NONE;
					m_iExitTimeRemaining = EXIT_TIME_AFTER_BATTLE;
					m_bIsExitCanceled = FALSE;
					m_fExitTimer = -1.0f;
#if 0
					m_bIsSeekingPartyChatEnabled = false;
#endif
					m_pUIExitMenu->ReturnToCharacterSelection();
				}
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////
	// 타이머 비슷한 루틴..
	static float fInterval2 = 0, fInterval3 = 0, fInterval4 = 0, fInterval5 = 0;
	fInterval2 += fTime - fTimePrev;
	fInterval3 += fTime - fTimePrev;
	fInterval4 += fTime - fTimePrev;
	fInterval5 += fTime - fTimePrev;
	m_fRequestGameSave += fTime - fTimePrev;
	if(fInterval2 > 1200.0f) // 저장 요청..
	{
		uint8_t byBuff[4];												// 버퍼.. 
		int iOffset=0;												// 옵셋..
		s_pSocket->MP_AddByte(byBuff, iOffset, WIZ_DATASAVE);	// 저장 요청 커멘드..
		s_pSocket->Send(byBuff, iOffset);				// 보냄..

		fInterval2 = 0.0f;
	}
	if(fInterval3 > 10.0f) // 스피드핵 체크.. 
	{
		MsgSend_SpeedCheck();										// 스피드핵 체크 하기

		fInterval3 = 0.0f;
	}
	if(s_pPlayer->m_InfoBase.iLevel < 12 && fInterval4 > 20.0f) // 시간이 지나면 팁 하나씩 표시..
	{
		std::string szMsg = fmt::format_text_resource(IDS_HELP_TIP_ALL);
		m_pUIMsgDlg->AddMsg(szMsg, 0xffffff00);

		szMsg = fmt::format_text_resource(IDS_HELP_TIP1 + (rand() % 33));
		m_pUIMsgDlg->AddMsg(szMsg, 0xffffff00); // 헬프 표시..
		fInterval4 = 0;
	}
	if(fInterval5 > 5.0f) // 시간이 지나면 팁 하나씩 표시..
	{
//		m_pUIChatDlg->ChangeChattingMode(N3_CHAT_CONTINUE); // 채팅모드 강제로 바꾸기...
		m_pUIChatDlg->ShowContinueMsg();
		fInterval5 = 0;
	}
	fTimePrev = fTime;
	// 타이머 비슷한 루틴..
	////////////////////////////////////////////////////////////////////////////////////

	if (m_fMBRotateTime >= 0.0f
		&& !s_pUIMgr->m_bDoneSomething)
	{
		float fRadian = s_fSecPerFrm * __PI2;
		m_fMBRotateTime += fRadian;

		if (m_fMBRotateTime > __PI)
		{
			fRadian -= (m_fMBRotateTime - __PI);
			m_fMBRotateTime = -1.0f;
		}

		if (fRadian != 0.0f
			&& s_pPlayer->IsAlive())
		{
			float fRot = fRadian / s_fSecPerFrm;
			if (s_pEng->ViewPoint() == VP_THIRD_PERSON)
				s_pEng->CameraYawAdd(fRot);
			else if (!s_pPlayer->m_bStun)
				s_pPlayer->RotAdd(fRot);
		}
	}
}

void CGameProcMain::Render()
{
	if ( FALSE == m_bLoadComplete )	return; 		// 로딩이 끝났냐??

	D3DCOLOR crSky = ACT_WORLD->GetSkyColorWithSky();
	s_pEng->Clear(crSky); // 안개 색깔을 넣어서 클리어.. -> 하늘색깔로 클리어 해야 하늘이 제대로 나온다..
	s_pEng->s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...
	
	ACT_WORLD->RenderSky();								// 하늘 렌더링..
	float fSunAngle = ACT_WORLD->GetSunAngleByRadinWithSky(); // 해의 각도를 가져오고..

	uint32_t dwFilter = D3DTEXF_LINEAR;
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, dwFilter);
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, dwFilter);
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, dwFilter);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MINFILTER, dwFilter);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MAGFILTER, dwFilter);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MIPFILTER, dwFilter);

	ACT_WORLD->RenderTerrain();						// 지형 렌더..
	ACT_WORLD->RenderShape();						// 물체 렌더..
	s_pOPMgr->Render(fSunAngle);				// 다른 플레이어 렌더..
	s_pPlayer->Render(fSunAngle);			// 플레이어 렌더..

	// NOTE(srmeier): uncomment to render the collision meshes
#ifdef _DEBUG
	ACT_WORLD->RenderCollisionWithShape(s_pPlayer->Position());				// 충돌 메쉬 렌더..
#endif

#ifdef _N3_64GRID_
	m_SMesh.Render();							// 서버 메쉬 렌더..
#endif

	this->RenderTarget();						// 타겟으로 잡은 캐릭터 혹은 오브젝트 렌더링..

	ACT_WORLD->RenderGrass();						//	풀 렌더 (asm)
	s_pFX->Tick();
	s_pFX->Render();
	ACT_WORLD->RenderBirdMgr();

	CN3Base::s_AlphaMgr.Render(); // 알파 정렬된 폴리곤들 렌더링..
	
	ACT_WORLD->RenderSkyWeather();							// 하늘 렌더링..
	
	CGameProcedure::Render(); // UI 나 그밖의 기본적인 것들 렌더링..
	if(m_pWarMessage) m_pWarMessage->RenderMessage();
	if(s_pGameCursor) s_pGameCursor->Render();

	s_pEng->s_lpD3DDev->EndScene();
	s_pEng->Present(CN3Base::s_hWndBase);
}

void CGameProcMain::RenderTarget()
{
	if(nullptr == m_pTargetSymbol) return;

	// 플레이어가 타겟으로 잡은 캐릭터의 위치위에 그리면 된다..
	CPlayerBase* pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, false);//시체로 판정되기 전까지의 캐릭은 포커스를 준다.
	if(nullptr == pTarget && nullptr == s_pPlayer->m_pObjectTarget) return;

	float fScale = 1;
	float fYScale = 1;
	__Vector3 vPos(0,0,0);

	if(pTarget)
	{
		fYScale = pTarget->Height() * 1.3f;
		fScale = pTarget->Radius() * 2.0f;
		vPos = pTarget->Position();
	}
	else 
	{
		__Vector3 vTmp = s_pPlayer->m_pObjectTarget->Max() - s_pPlayer->m_pObjectTarget->Min();
		fYScale = vTmp.y;
		vTmp.y = 0;
		fScale = vTmp.Magnitude();
		vPos = s_pPlayer->m_pObjectTarget->Pos();
	}

	m_pTargetSymbol->ScaleSet(fScale, fYScale, fScale);
	m_pTargetSymbol->PosSet(vPos);
	m_pTargetSymbol->Tick();
	if(m_pTargetSymbol->Part(1)) // 바닥의 심벌을 땅바닥 위로 맞춘다..
	{
		CN3PMesh* pPMesh = m_pTargetSymbol->Part(1)->Mesh();
		if(pPMesh && pPMesh->GetMaxNumVertices() == 4)
		{
			__VertexT1* pVs = m_pTargetSymbol->Part(1)->Mesh()->GetVertices();
			for(int i = 0; i < 4; i++)
			{
				pVs[i].y =	ACT_WORLD->GetHeightWithTerrain(vPos.x + (pVs[i].x * fYScale), vPos.z + (pVs[i].z * fYScale));
				pVs[i].y -= vPos.y;
				pVs[i].y /= fYScale;
				pVs[i].y += 0.1f / fYScale;
			}
		}
	}
	m_pTargetSymbol->Render();

	// NOTE(srmeier): uncomment to render the collision meshes
#ifdef _DEBUG
	if(pTarget) pTarget->RenderCollisionMesh();
	if(s_pPlayer->m_pObjectTarget) s_pPlayer->m_pObjectTarget->RenderCollisionMesh();
#endif
}

bool CGameProcMain::ProcessPacket(Packet& pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	int iCmd = pkt.read<uint8_t>();		// 커멘드 파싱..

	switch ( iCmd )										// 커멘드에 다라서 분기..
	{
#ifdef _DEBUG
	case WIZ_TEST_PACKET:
		{
			int iNPC = pkt.read<int16_t>();
			std::string szLog = fmt::format("NPC Region Test : {} -> ", iNPC);
			for(int i = 0; i < iNPC; i++)
			{
				int iID = pkt.read<int16_t>();
				szLog += fmt::format("%d, ", iID);
			}
			CLogWriter::Write(szLog);
		}
		return true;
#endif
	case WIZ_ZONEABILITY:
		MsgRecv_ZoneAbility(pkt);
		return true;

		case WIZ_DEBUG_STRING_PACKET: {
			// NOTE(srmeier): testing this debug string functionality

			int iLen = pkt.read<int16_t>();

			std::string szDebugString;
			pkt.readString(szDebugString, iLen);

			MsgOutput("DEBUG: "+szDebugString, D3DCOLOR_ARGB(255, 255, 255, 0));

		} return true;

		case WIZ_EVENT:
		case WIZ_MERCHANT_INOUT: {
			// need to implement these
		} return true;

		case WIZ_GAMESTART: {
			// NOTE(srmeier): send for the second half of the gamestart process

			uint8_t byBuff[32];
			int iOffset = 0;

			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_GAMESTART);
			CAPISocket::MP_AddByte(byBuff, iOffset, 0x02);

			s_pSocket->Send(byBuff, iOffset);

		} return true;

		case WIZ_MYINFO:									// 나의 정보 메시지..
			this->MsgRecv_MyInfo_All(pkt);
			return true;
		case WIZ_HP_CHANGE:
			this->MsgRecv_MyInfo_HP(pkt);
			return true;
		case WIZ_MSP_CHANGE:
			this->MsgRecv_MyInfo_MSP(pkt);
			return true;
		case WIZ_EXP_CHANGE:
			this->MsgRecv_MyInfo_EXP(pkt);
			return true;
		case WIZ_LOYALTY_CHANGE:
			this->MsgRecv_MyInfo_RealmPoint(pkt);
			return true;
		case WIZ_LEVEL_CHANGE:
			this->MsgRecv_MyInfo_LevelChange(pkt);
			return true;
		case WIZ_POINT_CHANGE:
			this->MsgRecv_MyInfo_PointChange(pkt);
			return true;
		case WIZ_CHAT:														// 채팅 메시지..	
			this->MsgRecv_Chat(pkt);
			return true;
		case WIZ_WARP:
			{
				float fX = (pkt.read<uint16_t>())/10.0f;
				float fZ = (pkt.read<uint16_t>())/10.0f;

				float fY = ACT_WORLD->GetHeightWithTerrain(fX, fZ, true);
				float fYObject = ACT_WORLD->GetHeightWithShape(fX, fZ);
				if(fYObject > fY) fY = fYObject;
				this->InitPlayerPosition(__Vector3(fX, fY, fZ)); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
				s_pFX->TriggerBundle(
					s_pPlayer->IDNumber(),
					-1,
					s_pPlayer->m_InfoBase.eNation == NATION_KARUS
						? FXID_WARP_KARUS
						: FXID_WARP_ELMORAD,
					s_pPlayer->IDNumber(),
					-1,
					0);
			}
			return true;
		case WIZ_MOVE:
			this->MsgRecv_UserMove(pkt);
			return true;
		case WIZ_ROTATE:												// 회전 커멘드..
			this->MsgRecv_Rotation(pkt);
			return true;
		case WIZ_REGENE:
			{
//				if(m_pUIDead) m_pUIDead->MsgRecv_Revival(pkt);
				this->MsgRecv_Regen(pkt);
				std::string szMsg = "Press OK to teleport back to the re-spawn point."; //IDS_REGENERATION (3701) in 1.298 client.
				MessageBoxClose(szMsg);
				m_pUITargetBar->SetVisible(false);
			}
			return true;
		case WIZ_DEAD:
			this->MsgRecv_Dead(pkt);
			return true;
		case WIZ_TIME:
			this->MsgRecv_Time(pkt);
			return true;
		case WIZ_WEATHER:
			this->MsgRecv_Weather(pkt);
			return true;
		case WIZ_USER_INOUT:												// 다른 유저 인/아웃..
			this->MsgRecv_UserInOut(pkt);
			return true;
		case WIZ_REGIONCHANGE:										// 첨에 로그온하면 그 주변 지역의 캐릭터들 업데이트...
			this->MsgRecv_UserInAndRequest(pkt);
			return true;
		case WIZ_REQ_USERIN:										// 서버에 요청한 UserIn 에 대한 자세한 정보 받기..
			this->MsgRecv_UserInRequested(pkt);						// 
			return true;
		case WIZ_NPC_REGION:										// 첨에 로그온하면 그 주변 지역의 캐릭터들 업데이트...
			this->MsgRecv_NPCInAndRequest(pkt);
			return true;
		case WIZ_REQ_NPCIN:											// 서버에 요청한 UserIn 에 대한 자세한 정보 받기..
			this->MsgRecv_NPCInRequested(pkt);						// 
			return true;
		case WIZ_NPC_INOUT:												// NPC 인/아웃..
			this->MsgRecv_NPCInOut(pkt);
			return true;
		case WIZ_ATTACK:
			this->MsgRecv_Attack(pkt);
			return true;
		case WIZ_NPC_MOVE:												// NPC 움직임 패킷..
			this->MsgRecv_NPCMove(pkt);
			return true;
		case WIZ_TARGET_HP:
			this->MsgRecv_TargetHP(pkt);
			return true;
		case WIZ_ITEM_MOVE:
			this->MsgRecv_ItemMove(pkt);				// Item Move에 대한 응답..
			return true;
		case WIZ_ITEM_DROP:
			this->MsgRecv_ItemBundleDrop(pkt);
			return true;
		case WIZ_BUNDLE_OPEN_REQ:
			this->MsgRecv_ItemBundleOpen(pkt);
			return true;
		case WIZ_TRADE_NPC:
			this->MsgRecv_ItemTradeStart(pkt);
			return true;
		case WIZ_ITEM_TRADE:
			this->MsgRecv_ItemTradeResult(pkt);
			return true;
		case WIZ_ITEM_GET:
			this->MsgRecv_ItemDroppedGetResult(pkt);					// 땅에 떨어진 아이템 먹기 결과..
			return true;
		case WIZ_REPAIR_NPC:
			this->MsgRecv_NpcEvent(pkt);
			return true;
		case WIZ_ITEM_REPAIR:
			this->MsgRecv_ItemRepair(pkt);
			return true;
		case WIZ_ITEM_COUNT_CHANGE:
			this->MsgRecv_ItemCountChange(pkt);
			return true;
		case WIZ_ITEM_REMOVE:
			this->MsgRecv_ItemDestroy(pkt);
			return true;
		case WIZ_WEIGHT_CHANGE:
			this->MsgRecv_ItemWeightChange(pkt);
			return true;
		case WIZ_USERLOOK_CHANGE:
			this->MsgRecv_UserLookChange(pkt);
			return true;
		case WIZ_ZONE_CHANGE:
			this->MsgRecv_ZoneChange(pkt);
			return true;
		case WIZ_STATE_CHANGE:
			this->MsgRecv_UserState(pkt);
			return true;
		case WIZ_NOTICE:
			this->MsgRecv_Notice(pkt);
			return true;
		case WIZ_PARTY:
			this->MsgRecv_PartyOrForce(pkt);
			return true;
		case WIZ_EXCHANGE:
			this->MsgRecv_PerTrade(pkt);
			return true;
		case WIZ_SKILLPT_CHANGE:
			this->MsgRecv_SkillChange(pkt);
			return true;
		case WIZ_MAGIC_PROCESS:
			this->MsgRecv_MagicProcess(pkt);
			return true;
		case WIZ_CLASS_CHANGE:
			this->MsgRecv_NpcChangeOpen(pkt);
			return true;
		case WIZ_OBJECT_EVENT:
			this->MsgRecv_ObjectEvent(pkt);
			return true;
		case WIZ_CHAT_TARGET:
			{
				uint8_t type = pkt.read<uint8_t>();
				int err = pkt.read<int16_t>();

				std::string szID, szMsg;
				int iLen = pkt.read<int16_t>();		
				pkt.readString(szID, iLen);	

				e_ChatMode eCM = N3_CHAT_UNKNOWN;
				if(szID.empty())
				{
					szMsg = fmt::format_text_resource(IDS_CHAT_SELECT_TARGET_FAIL);
					eCM = N3_CHAT_NORMAL;
				}
				else
				{
					szMsg = fmt::format_text_resource(IDS_CHAT_SELECT_TARGET_SUCCESS);
					eCM = N3_CHAT_PRIVATE;
				}
				
				this->MsgOutput(szID + " " + szMsg, 0xffffff00);
				m_pUIChatDlg->ChangeChattingMode(eCM); 
			}
			return true;
		case WIZ_CONCURRENTUSER: // 동시 접속자수 ...
			{
				int iUserCount = pkt.read<int16_t>();		// ID 문자열 길이..

				std::string szMsg = fmt::format_text_resource(IDS_FMT_CONCURRENT_USER_COUNT,
					iUserCount);
				MsgOutput(szMsg, D3DCOLOR_ARGB(255,255,255,0));
			}
			return true;
		case WIZ_DURATION:
			this->MsgRecv_DurabilityChange(pkt);
			return true;
		case WIZ_KNIGHTS_PROCESS:
			this->MsgRecv_Knights(pkt);
			return true;
		case WIZ_KNIGHTS_LIST:
			this->MsgRecv_KnightsListBasic(pkt);
			return true;
		case WIZ_CONTINOUS_PACKET: // 압축된 데이터 이다... 한번 더 파싱해야 한다!!!
			this->MsgRecv_ContinousPacket(pkt);
			return true;
		case WIZ_WAREHOUSE:	// 보관함..
			this->MsgRecv_WareHouse(pkt);			// 보관함 관련 패킷..
			return true;
		case WIZ_FRIEND_PROCESS:
			if(m_pUIVar->m_pPageFriends) m_pUIVar->m_pPageFriends->MsgRecv_MemberInfo(pkt);
			return true;
		case WIZ_GOLD_CHANGE:
			this->MsgRecv_NoahChange(pkt);
			return true;
		case WIZ_WARP_LIST:
			this->MsgRecv_WarpList(pkt);
			return true;
//		case WIZ_VIRTUAL_SERVER:
//			this->MsgRecv_ServerCheckAndRequestConcurrentUserCount(pkt);
//			return true;
//		case WIZ_ZONE_CONCURRENT:
//			this->MsgRecv_ConcurrentUserCountAndSendServerCheck(pkt);
//			return true;
		case WIZ_CORPSE: //regen을 하여 주위 유저에게 시체임을 알린다.
			this->MsgRecv_Corpse(pkt);
			return true;
		case WIZ_PARTY_BBS:
			if(m_pUIPartyBBS) m_pUIPartyBBS->MsgRecv_RefreshData(pkt);
			return true;
		case WIZ_MARKET_BBS:
			if(m_pUITradeBBS) m_pUITradeBBS->MsgRecv_TradeBBS(pkt);
			return true;
		case WIZ_SELECT_MSG:
			if(m_pUIQuestMenu) m_pUIQuestMenu->Open(pkt);
			return true;
		case WIZ_NPC_SAY:
			if(m_pUIQuestTalk) m_pUIQuestTalk->Open(pkt);
			return true;
//		case N3_CLAN:
//			this->MsgRecv_Clan(pkt);
//			return true;
		case WIZ_QUEST:
		{
			uint8_t start = pkt.read<uint8_t>();
			uint16_t questId = pkt.read<uint16_t>();
			uint8_t state = pkt.read<uint8_t>();
			if (state == 1)
			{				
				std::string buff = fmt::format("You have started quest: {}", questId);
				MsgOutput(buff, D3DCOLOR_ARGB(255, 255, 255, 255));
				return true;
			}
		} break;
		case WIZ_ITEM_UPGRADE:
			MsgRecv_ItemUpgrade(pkt);
			return true;
	}

#ifdef _DEBUG
	if (!m_pUIChatDlg)
		return false;

	std::string szMsg = fmt::format("Unhandled packet. Opcode: 0x{:02x}", iCmd);
	m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xffff0000);
#endif
	return false;
}

// 키보드와 마우스 눌린것을 처리한다..
void CGameProcMain::ProcessLocalInput(uint32_t dwMouseFlags)
{
	// Loading이 된 후..
	if ( FALSE == m_bLoadComplete ) return; 

	if (m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE)
		return;

	if (!s_bIsWindowInFocus)
		return;

	POINT ptPrev = s_pLocalInput->MouseGetPosOld();
	POINT ptCur = s_pLocalInput->MouseGetPos();

	OnMouseMove(ptCur, ptPrev);

	//static POINT ptPrev_RB ={};

	// NOTE: right click on NPCs, interactable shapes, item boxes, etc.
	if (dwMouseFlags & MOUSE_RBCLICK)
		OnMouseRBtnPress(ptCur, ptPrev);

	// NOTE: this is where the right click rotation and zoom out occur
	if (dwMouseFlags & MOUSE_RBDOWN)
		OnMouseRbtnDown(ptCur, ptPrev);

	if (dwMouseFlags & MOUSE_RBCLICK)
		OnMouseRBtnPressd(ptCur, ptPrev);

	if (dwMouseFlags & MOUSE_RBDBLCLK)
		OnMouseRDBtnPress(ptCur, ptPrev);

	// NOTE: move on click
	if (dwMouseFlags & MOUSE_LBCLICK)
		OnMouseLBtnPress(ptCur, ptPrev);

	// NOTE: move on held down click
	if (dwMouseFlags & MOUSE_LBDOWN)
		OnMouseLbtnDown(ptCur, ptPrev);

	if (dwMouseFlags & MOUSE_LBCLICKED)
		OnMouseLBtnPressd(ptCur, ptPrev);

	if (dwMouseFlags & MOUSE_LBDBLCLK)
		OnMouseLDBtnPress(ptCur, ptPrev);

	if (dwMouseFlags & MOUSE_MBCLICKED)
		m_fMBRotateTime = 0.0f;

	// Moves camera when mouse is on the borders of the screen. For both X & Y
	if (!(dwMouseFlags & MOUSE_RBDOWN))
	{
		float fRotY = 0, fRotX = 0;
		if (0 == ptCur.x) fRotY = -2.0f;
		else if ((CN3Base::s_CameraData.vp.Width - 1) == ptCur.x) fRotY = 2.0f;
		if (0 == ptCur.y) fRotX = -1.0f;
		else if ((CN3Base::s_CameraData.vp.Height - 1) == ptCur.y) fRotX = 1.0f;
		if (fRotY)
		{
			if (VP_THIRD_PERSON == s_pEng->ViewPoint()) s_pEng->CameraYawAdd(fRotY);
			else s_pPlayer->RotAdd(fRotY);
		}
		if (fRotX && VP_THIRD_PERSON != s_pEng->ViewPoint()) s_pEng->CameraPitchAdd(fRotX);
	}

	int iHotKey = -1;
	if( s_pLocalInput->IsKeyPress(KM_HOTKEY1) ) iHotKey = 0;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY2) ) iHotKey = 1;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY3) ) iHotKey = 2;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY4) ) iHotKey = 3;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY5) ) iHotKey = 4;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY6) ) iHotKey = 5;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY7) ) iHotKey = 6;
	else if( s_pLocalInput->IsKeyPress(KM_HOTKEY8) ) iHotKey = 7;
		
	if ((iHotKey >= 0 && iHotKey < 8) &&
		CN3UIBase::GetFocusedEdit() == nullptr && 
		m_pSubProcPerTrade->m_ePerTradeState == PER_TRADE_STATE_NONE )
	{
		m_pUIHotKeyDlg->EffectTriggerByHotKey(iHotKey);
	}
	// 핫키
	//////////////////////////////////////////

	if(s_pLocalInput->IsKeyPress(KM_CAMERA_CHANGE))												// 시점 변환..
	{
		this->CommandCameraChange(); // 카메라 시점 바꾸기..
	}

	// 삼인칭일때 홈, 엔드키로 카메로 올리고 내리기..
	if(s_pEng->ViewPoint() == VP_THIRD_PERSON)
	{
		float fPitch = 0;
		if(s_pLocalInput->IsKeyDown(DIK_HOME)) fPitch = DegreesToRadians(45.0f);		// home 키가 눌리면..
		else if(s_pLocalInput->IsKeyDown(DIK_END)) fPitch = DegreesToRadians(-45.0f);	// End 키가 눌리면..
		if(fPitch) s_pEng->CameraPitchAdd(fPitch);
	}

	if (!IsUIKeyOperated() && nullptr == CN3UIBase::GetFocusedEdit() )			// 채팅모드가 아닐때 
	{
		if(s_pPlayer->m_InfoBase.iAuthority == AUTHORITY_MANAGER) //게임 운영자는 이 기능을 사용할수 있다.
		{
			if ( s_pLocalInput->IsKeyDown(DIK_Q) ) s_pPlayer->m_bTempMoveTurbo = true; // 엄청 빨리 움직이게 한다..  // 임시 함수.. 나중에 없애자..
			else s_pPlayer->m_bTempMoveTurbo = false; // 엄청 빨리 움직이게 한다..  // 임시 함수.. 나중에 없애자..
		}

		if (s_pLocalInput->IsKeyPress(KM_TOGGLE_ATTACK))
		{
			// if the player is already attacking, stop it
			if (s_pPlayer->m_bAttackContinous)
			{
				CommandEnableAttackContinous(false, nullptr);
			}
			// otherwise, start the auto-attack process
			else
			{
				TryStartAttack();
			}
		}
		if (s_pLocalInput->IsKeyPress(KM_TOGGLE_RUN))
			CommandToggleWalkRun();				// 걷기 / 뛰기 토글	
		if (s_pLocalInput->IsKeyPress(KM_TARGET_NEAREST_ENEMY))
			CommandTargetSelect_NearestEnemy();	// 가장 가까운 적 타겟 잡기..
		if (s_pLocalInput->IsKeyPress(KM_TARGET_NEAREST_PARTY))
			CommandTargetSelect_NearestOurForce(); // 가장 가까운 파티 타겟잡기..
		if (s_pLocalInput->IsKeyPress(KM_TARGET_NEAREST_NPC)) // target nearest NPC with 'B'
			CommandTargetSelect_NearestNPC();

		float fRotKeyDelta = DegreesToRadians(60); // 초당 60 도 돌기..
		if(s_pLocalInput->IsKeyDown(KM_ROTATE_LEFT) || s_pLocalInput->IsKeyDown(DIK_LEFT))	
		{
			if(s_pPlayer->IsAlive()) s_pPlayer->RotAdd(-fRotKeyDelta); // 초당 180 도 왼쪽으로 돌기.
			if(m_pUIDroppedItemDlg->IsVisible()) m_pUIDroppedItemDlg->LeaveDroppedState();	
		}
		if(s_pLocalInput->IsKeyDown(KM_ROTATE_RIGHT) || s_pLocalInput->IsKeyDown(DIK_RIGHT))	
		{
			if(s_pPlayer->IsAlive()) s_pPlayer->RotAdd(fRotKeyDelta); // 초당 180 도 오른쪽으로 돌기.
			if(m_pUIDroppedItemDlg->IsVisible()) m_pUIDroppedItemDlg->LeaveDroppedState();	
		}
		
		if(s_pLocalInput->IsKeyDown(KM_MOVE_FOWARD) || s_pLocalInput->IsKeyDown(DIK_UP))
		{
			bool bStart = false;
			if(s_pLocalInput->IsKeyPress(KM_MOVE_FOWARD) || s_pLocalInput->IsKeyPress(DIK_UP))
			{
				if(VP_THIRD_PERSON == s_pEng->ViewPoint())
				{
					if(!s_pPlayer->m_bTargetOrPosMove) bStart = true;
					s_pPlayer->m_bTargetOrPosMove = false;
					if(s_pPlayer->m_bAttackContinous)
						CommandToggleAttackContinous();
				}
				else
					bStart = true;// 누르는 순간이면
			}
			this->CommandMove(MD_FORWARD, bStart); // 앞으로 이동..
		}
		else if(s_pLocalInput->IsKeyDown(KM_MOVE_BACKWARD) || s_pLocalInput->IsKeyDown(DIK_DOWN))
		{
			bool bStart = false;
			if(s_pLocalInput->IsKeyPress(KM_MOVE_BACKWARD) || s_pLocalInput->IsKeyPress(DIK_DOWN)) 
			{
				if(VP_THIRD_PERSON == s_pEng->ViewPoint())
				{
					if(!s_pPlayer->m_bTargetOrPosMove) bStart = true;
					s_pPlayer->m_bTargetOrPosMove = false;
					if(s_pPlayer->m_bAttackContinous)
						CommandToggleAttackContinous();
				}
				else
					bStart = true;// 누르는 순간이면
			}
			this->CommandMove(MD_BACKWARD, bStart); // 뒤로 이동..
		}
		else if(s_pLocalInput->IsKeyPress(KM_TOGGLE_MOVE_CONTINOUS))
		{
			this->CommandToggleMoveContinous();
		}

		if(	s_pLocalInput->IsKeyPressed(KM_MOVE_FOWARD) || s_pLocalInput->IsKeyPressed(DIK_UP) || 
			s_pLocalInput->IsKeyPressed(KM_MOVE_BACKWARD) || s_pLocalInput->IsKeyPressed(DIK_DOWN) ) // 전진/후진 키를 떼는 순간. 
		{
			this->CommandMove(MD_STOP, true);
		}

		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_INVENTORY)) this->CommandToggleUIInventory();
		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_STATE)) this->CommandToggleUIState();
		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_SKILL)) this->CommandToggleUISkillTree();
		if (s_pLocalInput->IsKeyPress(KM_TOGGLE_CMDLIST)) this->CommandToggleCmdList();
		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_SITDOWN)) this->CommandSitDown(true, !s_pPlayer->m_bSitDown);

		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_HELP)) 
		{
			if(m_pUIHelp->IsVisible()) m_pUIHelp->SetVisible(false);
			else m_pUIHelp->SetVisible(true);
		}

		if(s_pLocalInput->IsKeyPress(KM_TOGGLE_MINIMAP))
		{
			this->CommandToggleUIMiniMap();
		}

		if (s_pLocalInput->IsKeyPress(DIK_PRIOR))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->PageUp();
		
		if (s_pLocalInput->IsKeyPress(DIK_NEXT))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->PageDown();

		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_1))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(0);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_2))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(1);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_3))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(2);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_4))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(3);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_5))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(4);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_6))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(5);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_7))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(6);
		if (s_pLocalInput->IsKeyPress(KM_SKILL_PAGE_8))
			if (m_pUIHotKeyDlg)	m_pUIHotKeyDlg->SetHotKeyPage(7);

	} // end of if ( !m_UIChatDlg.IsChatMode() )

	// ..... 나머지 키보드 처리..
#if _DEBUG
	if(s_pLocalInput->IsKeyPress(DIK_F12)) // 디버깅 테스트..
		s_pEng->Lightning(); // 번개 치기..
#endif
}

void CGameProcMain::ProcessPlayerInclination()											// 경사에 서 있을때..
{
/*	float fFrm = GetIndepTimeFrame();

	__Vector3 vNorm, vNormXZ; 
	s_pTerrain->GetNormal( s_pEng->m_matPlayer.Pos().x, s_pEng->m_matPlayer.Pos().z, vNorm );

	vNorm.Normalize();
	vNormXZ = vNorm;
	vNormXZ.y = 0.0f;

	if ( vNormXZ.Magnitude() > 0.8f )
	{
		vNormXZ.x *= 0.01f*fFrm;
		vNormXZ.z *= 0.01f*fFrm;
		s_pPlayer->m_vPlayerIncline = vNormXZ;
	}*/
}

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

void CGameProcMain::MsgSend_Continous()						// 특정 조건(?)하에서 서버에게 정기적으로 메시지를 보냄..
{
	float fTime = s_pEng->TimeGet();

	if ( fTime >= m_fMsgSendTimeMove + PACKET_INTERVAL_MOVE )					// 1초가 지났으면..	
	{
		__Vector3 vPos = s_pPlayer->Position();
		if(m_vPlayerPosSended != vPos) this->MsgSend_Move(true, true); // 조금이라도 움직였으면 움직임 패킷 보냄..
	}

	if( false == s_pPlayer->m_bMoveContinous && fTime >= m_fMsgSendTimeRot + PACKET_INTERVAL_ROTATE ) // 플레이어가 정지해 있고.. 2초가 지났으면..
	{
		float fYaw = s_pPlayer->Yaw();
		if( fYaw != m_fPlayerYawSended ) MsgSend_Rotation(); // 조금이라도 회전했으면 회전 패킷 보냄
	}
}



//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

void CGameProcMain::MsgSend_Attack(int iTargetID, float fInterval, float fDistance) // 공격 패킷 날리기 - 테이블의 공격 주기를 같이 줘서 해킹을 막는다.
{
	if(s_pPlayer->m_fTimeAfterDeath > 0 || s_pPlayer->IsDead())	return; // 죽은 넘이다..

	uint8_t byBuff[32];												// 버퍼.. 
	int iOffset=0;													// 옵셋..

	uint8_t bySuccess = true;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ATTACK);						// 공격 커멘드..
	CAPISocket::MP_AddByte(byBuff, iOffset, 0x01);							// ??? 데미지??
	CAPISocket::MP_AddByte(byBuff, iOffset, bySuccess);						// 성공 여부.. - 일단 성공으로 보낸다.

	fInterval += 0.1f;

	CAPISocket::MP_AddShort(byBuff, iOffset, iTargetID );					// 상대방 아이디..
	CAPISocket::MP_AddShort(byBuff, iOffset, (int)(fInterval * 100));	// 공격한 시간
	CAPISocket::MP_AddShort(byBuff, iOffset, (int)(fDistance * 10));	// 공격한 거리

	s_pSocket->Send(byBuff, iOffset);										// 보냄..
}

void CGameProcMain::MsgSend_Move(bool bMove, bool bContinous)
{
	__Vector3 vPos(0,0,0);
	float fSpeed = s_pPlayer->MoveSpeed();
	
	uint8_t byMoveFlag = 0;

	if(true == bMove) // 움직이기 시작할때나 움직일때는
	{
		if(s_pPlayer->m_fTimeAfterDeath > 0 || s_pPlayer->IsDead())	return; // 죽은 넘이다..

		vPos = s_pPlayer->NextPos(PACKET_INTERVAL_MOVE); // 다음 1초후의 위치를 계산해서.
		byMoveFlag |= 0x01;
	}
	else // 정지시에는 
	{
		s_pPlayer->m_bTargetOrPosMove	= false;
		s_pPlayer->m_iMoveTarget		= -1;
		vPos = s_pPlayer->Position();
		fSpeed = 0;
	}

	if(true == bContinous) // 정기적으로 움직이는 거라면..
	{
		byMoveFlag |= 0x02;
	}

	uint8_t byBuff[64];											// 버퍼 설정..
	int iOffset=0;											// 옵셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MOVE);			// 커멘드..
	CAPISocket::MP_AddWord(byBuff, iOffset, (uint16_t)(vPos.x*10));			// 다음 위치
	CAPISocket::MP_AddWord(byBuff, iOffset, (uint16_t)(vPos.z*10));
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)(vPos.y*10));
	CAPISocket::MP_AddWord(byBuff, iOffset, (uint16_t)(fSpeed*10));			// 속도 
	CAPISocket::MP_AddByte(byBuff, iOffset, byMoveFlag );		// 움직임 플래그..
	s_pSocket->Send(byBuff, iOffset);							// 패킷을 보냄..

	m_vPlayerPosSended = s_pPlayer->Position(); // 최근에 보낸 위치 세팅..
	
	if(true == bMove) m_fMsgSendTimeMove = CN3Base::TimeGet(); // 시간을 기록한다..
}

void CGameProcMain::MsgSend_Rotation()
{
	if(s_pPlayer->IsDead()) return; // 죽은 넘이 어딜 감히!!

	uint8_t byBuff[8];
	int iOffset=0;

	float fYaw = s_pPlayer->Yaw(); // 방향..
	
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ROTATE);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)(fYaw*100));

	s_pSocket->Send(byBuff, iOffset);

	m_fPlayerYawSended = fYaw; // 회전값을 기록
	m_fMsgSendTimeRot = CN3Base::TimeGet(); // 시간을 기록한다..
}


void CGameProcMain::MsgSend_Chat(e_ChatMode eMode, const std::string& szChat)
{
	if (szChat.empty()
		|| szChat.size() >= 128)
		return;

	if (eMode == N3_CHAT_CLAN
		&& s_pPlayer->m_InfoBase.iKnightsID <= 0)
		return;

	uint8_t byBuff[512];
	int iOffset=0;
	
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CHAT);
	CAPISocket::MP_AddByte(byBuff, iOffset, eMode);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szChat.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szChat);

	__ASSERT(iOffset<512, "Send Buffer OverFlow");
	s_pSocket->Send(byBuff, iOffset); // 보낸다..
}

void CGameProcMain::MsgSend_ChatSelectTarget(const std::string& szTargetID)
{
	if(szTargetID.empty() || szTargetID.size() > 20) return;

	int iOffset = 0;
	uint8_t byBuff[32];

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CHAT_TARGET);

	// TEMP(srmeier): testing private messages
	CAPISocket::MP_AddByte(byBuff, iOffset, 0x01);

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szTargetID.size() );
	CAPISocket::MP_AddString(byBuff, iOffset, szTargetID );

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_Regen()
{
	if(s_pPlayer->m_iSendRegeneration >= 2) return; // 한번 보내면 다시 죽을때까지 안보내는 플래그

	uint8_t byBuff[4];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_REGENE);
	CAPISocket::MP_AddByte(byBuff, iOffset, 1); //1: 마을로 살아나기..
	
	CLogWriter::Write("Send Regeneration");

	s_pSocket->Send(byBuff, iOffset); // 보낸다..

	s_pPlayer->m_iSendRegeneration = 2; // 한번 보내면 다시 죽을때까지 안보내는 플래그
	//TRACE("보냄 - 다시 살아나기\n");
}

bool CGameProcMain::MsgSend_RequestItemBundleOpen(CPlayerNPC* pCorpse)
{
	if( nullptr == pCorpse || pCorpse->m_iDroppedItemID <= 0) return false;

	float fDistTmp = (pCorpse->Position() - s_pPlayer->Position()).Magnitude();
	if(	fDistTmp >= (pCorpse->Radius() * 2.0f + 6.0f)) return false;

	int iItemBundleID = pCorpse->m_iDroppedItemID;
	m_pUIDroppedItemDlg->m_iItemBundleID = pCorpse->m_iDroppedItemID;
		
	s_pOPMgr->CorpseRemove(pCorpse, false); // 점점 투명하게 없앤다..
	
	uint8_t byBuff[8];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_BUNDLE_OPEN_REQ);
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemBundleID);

	s_pSocket->Send(byBuff, iOffset); // 보낸다..

	return true;
}

void CGameProcMain::MsgSend_PartyOrForcePermit(int iPartyOrForce, bool bYesNo)
{
	uint8_t byBuff[4];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY);
//	CAPISocket::MP_AddByte(byBuff, iOffset, iPartyOrForce);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_OR_FORCE_PERMIT);
	CAPISocket::MP_AddByte(byBuff, iOffset, bYesNo);

	s_pSocket->Send(byBuff, iOffset); // 보낸다..
}

bool CGameProcMain::MsgSend_PartyOrForceCreate(int iPartyOrForce, const std::string& szID)
{
	if(szID.empty() || szID.size() > 20) return false;

	bool bIAmLeader, bIAmMember;
	int iMemberIndex = -1;
	CPlayerBase* pTarget = nullptr;
	this->PartyOrForceConditionGet(bIAmLeader, bIAmMember, iMemberIndex, pTarget);
	if(true == bIAmMember && false == bIAmLeader) return false; // 내가 파티에 들어 있고 리더가 아니면 실패..

	uint8_t byBuff[32];
	int iOffset=0;

	e_SubPacket_Party eCmdParty = N3_SP_PARTY_OR_FORCE_CREATE;
	if(m_pUIPartyOrForce->MemberCount() >= 2)
	{
		eCmdParty = N3_SP_PARTY_OR_FORCE_INSERT;
	}

	m_pUIPartyOrForce->m_iPartyOrForce = iPartyOrForce;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY);
//	CAPISocket::MP_AddByte(byBuff, iOffset, iPartyOrForce);
	CAPISocket::MP_AddByte(byBuff, iOffset, eCmdParty);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szID.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szID);

	s_pSocket->Send(byBuff, iOffset); // 보낸다..
	
	if(m_pUIPartyOrForce->MemberCount() <= 0) // 처음 생성하는 경우...
	{
		m_pUIPartyOrForce->MemberAdd(
			s_pPlayer->IDNumber(),
			s_pPlayer->IDString(),
			s_pPlayer->m_InfoBase.iLevel, 
			s_pPlayer->m_InfoBase.eClass, 
			s_pPlayer->m_InfoBase.iHP, 
			s_pPlayer->m_InfoBase.iHPMax,
			s_pPlayer->m_InfoExt.iMSP,
			s_pPlayer->m_InfoExt.iMSPMax);  // 내건 미리 넣어 놓는다..
	}

	//TRACE ("Party or Force 생성 신청 - Target ID(%s)\n", szID.c_str());

	return true;
}

void CGameProcMain::MsgSend_PartyOrForceLeave(int iPartyOrForce)
{
	if(m_pUIPartyOrForce->MemberCount() <= 0) return; // 파티원이 없다..

	CPlayerBase* pTarget = nullptr;
	bool bIAmLeader, bIAmMember;
	int iMemberIndex = -1;
	this->PartyOrForceConditionGet(bIAmLeader, bIAmMember, iMemberIndex, pTarget);

	uint8_t byBuff[8];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY);
//	CAPISocket::MP_AddByte(byBuff, iOffset, iPartyOrForce);
	if(bIAmLeader) // 내가 리더일경우..
	{
		if(iMemberIndex > 0 && pTarget) // 파티원이다.. 쫓아내자..
		{
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_OR_FORCE_REMOVE);
			CAPISocket::MP_AddShort(byBuff, iOffset, pTarget->IDNumber());
		}
		else // 타겟이 파티원이 아니면 파티 뽀개기..
		{
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_OR_FORCE_DESTROY);
		}
	}
	else if(bIAmMember) // 리더가 아니면 탈퇴 메시지를 보낸다..
	{
		CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_OR_FORCE_REMOVE);
		CAPISocket::MP_AddShort(byBuff, iOffset, s_pPlayer->IDNumber());
	}
	s_pSocket->Send(byBuff, iOffset); // 보낸다..
}

void CGameProcMain::MsgSend_ObjectEvent(int iEventID, int iNPCID)
{
	uint8_t byBuff[8];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_OBJECT_EVENT);
	CAPISocket::MP_AddShort(byBuff, iOffset, iEventID);	// Index
	CAPISocket::MP_AddShort(byBuff, iOffset, iNPCID);	// Parameter

	s_pSocket->Send(byBuff, iOffset); // 보낸다..
}

void CGameProcMain::MsgSend_Weather(int iWeather, int iPercent)
{
	if(iWeather < 1 || iWeather > 3) return;
	if(iPercent < 0 || iPercent > 100) return;

	uint8_t byBuff[8];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WEATHER); // -> byte - 기후.... 0x01 - 맑음.. 0x02 -  비 0x03
	CAPISocket::MP_AddByte(byBuff, iOffset, iWeather); // -> byte - 기후.... 0x01 - 맑음.. 0x02 -  비 0x03
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iPercent); // int16_t -> 맑은날 안개, 비, 눈 의 양 퍼센트로 

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_Time(int iHour, int iMin)
{
	uint8_t byBuff[12];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_TIME); 
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);		// year
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);		// month
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);		// day
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iHour);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iMin);

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_Administrator(e_SubPacket_Administrator eSP, const std::string& szID)
{
	if(szID.empty() || szID.size() >= 20) return;

	uint8_t byBuff[64];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_OPERATOR); // 관리자 전용패킷..
	CAPISocket::MP_AddByte(byBuff, iOffset, eSP);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szID.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szID);	

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_KnightsJoinReq(bool bJoin)
{
	uint8_t byBuff[8];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS); // 관리자 전용패킷..
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_JOIN_REQ);
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)bJoin);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_iJoinReqClanRequierID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_iJoinReqClan);
	
	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_KnightsJoin(int iTargetID)
{
	uint8_t byBuff[4];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS); // 관리자 전용패킷..
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_JOIN);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iTargetID);
	
	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_KnightsLeave(std::string& szName)
{
	uint8_t byBuff[64];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS); // 관리자 전용패킷..
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_MEMBER_REMOVE);
	CAPISocket::MP_AddShort(byBuff, iOffset, static_cast<int16_t>(szName.length()));
	CAPISocket::MP_AddString(byBuff, iOffset, szName);	// 아이디 문자열 패킷에 넣기..
	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_KnightsWithdraw()
{
	uint8_t byBuff[2];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS); 
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_WITHDRAW);
	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_KnightsAppointViceChief(std::string& szName)
{
	uint8_t byBuff[64];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS); // 관리자 전용패킷..
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_APPOINT_VICECHIEF);
	CAPISocket::MP_AddShort(byBuff, iOffset, static_cast<int16_t>(szName.length()));
	CAPISocket::MP_AddString(byBuff, iOffset, szName);	// 아이디 문자열 패킷에 넣기..
	s_pSocket->Send(byBuff, iOffset);
}

bool CGameProcMain::MsgRecv_MyInfo_All(Packet& pkt)
{
	int iZone = s_pPlayer->m_InfoExt.iZoneCur;
	s_pPlayer->Release(); // 일단 몽창 다 해제 하고....
	s_pPlayer->m_InfoExt.iZoneCur = iZone;

	int iID = pkt.read<int16_t>();
	int iLen = pkt.read<uint8_t>();

	std::string szID;
	pkt.readString(szID, iLen);
	s_pPlayer->IDSet(iID, szID, D3DCOLOR_XRGB(100, 210, 255)); // 밝은 파란색과 하늘색 중간..

	float fX = (pkt.read<uint16_t>())/10.0f;
	float fZ = (pkt.read<uint16_t>())/10.0f;
	float fY = (pkt.read<int16_t>())/10.0f;
	
	s_pPlayer->m_InfoBase.eNation = (e_Nation)pkt.read<uint8_t>();
	s_pPlayer->m_InfoBase.eRace = (e_Race)pkt.read<uint8_t>();
	s_pPlayer->m_InfoBase.eClass = (e_Class)pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iFace = pkt.read<uint8_t>(); // 얼굴 모양..
	s_pPlayer->m_InfoExt.iHair = pkt.read<uint8_t>(); // 머리카락

	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(s_pPlayer->m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..
	if (pLooks == nullptr)
	{
		CLogWriter::Write("CGameProcMain::MsgRecv_MyInfo_All : failed find character resource data (Race : {})",
			static_cast<int>(s_pPlayer->m_InfoBase.eRace));
	}
	__ASSERT(pLooks, "failed find character resource data");
	s_pPlayer->InitChr(pLooks); // 관절 세팅..

	s_pPlayer->m_InfoExt.iRank = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iTitle = pkt.read<uint8_t>();
	s_pPlayer->m_InfoBase.iLevel = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iLevelPrev = s_pPlayer->m_InfoBase.iLevel;
	s_pPlayer->m_InfoExt.iBonusPointRemain = pkt.read<uint8_t>(); // 남은 보너스 포인트..

	s_pPlayer->m_InfoExt.iExpNext = pkt.read<uint32_t>(); 
	s_pPlayer->m_InfoExt.iExp = pkt.read<uint32_t>(); 
	s_pPlayer->m_InfoExt.iRealmPoint = pkt.read<uint32_t>();

	// @Demircivi, implemented monthly np system.
	s_pPlayer->m_InfoExt.iRealmPointMonthly = pkt.read<uint32_t>();

	s_pPlayer->m_InfoExt.iCity = pkt.read<uint8_t>();
	
	std::string szKnightsName = "";
	int iKnightsID = pkt.read<int16_t>(); // 소속 기사단 ID
	e_KnightsDuty eKnightsDuty = (e_KnightsDuty)pkt.read<uint8_t>(); // 기사단에서의 권한..
	
	// NOTE(srmeier): adding alliance ID and knight's byFlag
	int iAllianceID = pkt.read<int16_t>();
	uint8_t byFlag = pkt.read<uint8_t>();
	
	int iKnightNameLen = pkt.read<uint8_t>(); // 소속 기사단 이름 길이.
	pkt.readString(szKnightsName, iKnightNameLen);
	int iKnightsGrade = pkt.read<uint8_t>(); // 소속 기사단 등급
	int	iKnightsRank = pkt.read<uint8_t>(); // 소속 기사단 순위
	
	// NOTE(srmeier): adding mark version and cape ID
	int16_t sMarkVersion = pkt.read<int16_t>();
	int16_t sCapeID = pkt.read<int16_t>();

	// 기사단 관련 세팅..
	s_pPlayer->m_InfoExt.eKnightsDuty = eKnightsDuty; // 기사단에서의 권한..
	s_pPlayer->KnightsInfoSet(iKnightsID, szKnightsName, iKnightsGrade, iKnightsRank);
	m_pUIVar->UpdateKnightsInfo();
	
	s_pPlayer->m_InfoBase.iHPMax = pkt.read<int16_t>();	
	s_pPlayer->m_InfoBase.iHP = pkt.read<int16_t>(); 
	s_pPlayer->m_InfoExt.iMSPMax = pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iMSP = pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iWeightMax = static_cast<int>(pkt.read<uint16_t>());
	s_pPlayer->m_InfoExt.iWeight = static_cast<int>(pkt.read<uint16_t>());

	s_pPlayer->m_InfoExt.iStrength = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iStrength_Delta = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iStamina = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iStamina_Delta = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iDexterity = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iDexterity_Delta = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iIntelligence = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iIntelligence_Delta = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iMagicAttak = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iMagicAttak_Delta = pkt.read<uint8_t>();
	
	s_pPlayer->m_InfoExt.iAttack = pkt.read<int16_t>();
//	s_pPlayer->m_InfoExt.iAttack_Delta		= pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iGuard = pkt.read<int16_t>();
//	s_pPlayer->m_InfoExt.iGuard_Delta		= pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iRegistFire = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iRegistCold = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iRegistLight = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iRegistMagic = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iRegistCurse = pkt.read<uint8_t>();
	s_pPlayer->m_InfoExt.iRegistPoison = pkt.read<uint8_t>();

	s_pPlayer->m_InfoExt.iGold = pkt.read<uint32_t>();
	s_pPlayer->m_InfoBase.iAuthority = pkt.read<uint8_t>(); //권한.. 

	// NOTE(srmeier): adding national rank and leader rank
	uint8_t bKnightsRank = pkt.read<uint8_t>();
	uint8_t bPersonalRank = pkt.read<uint8_t>();

	// 스킬 UI 갱신..
	for ( int i = 0; i < 9; i++ )
	{
		m_pUISkillTreeDlg->m_iSkillInfo[i] = pkt.read<uint8_t>();
	}
	m_pUISkillTreeDlg->InitIconUpdate();
	m_pUIHotKeyDlg->ReleaseItem();
	m_pUIHotKeyDlg->InitIconUpdate();			// 핫키가 유효한지 검사하고 유효하면 레지스트리에서 읽어온다..

	// 장착하고 있는 거..
	int iItemIDInSlots[ITEM_SLOT_COUNT]; memset(iItemIDInSlots, -1, sizeof(iItemIDInSlots));
	int iItemDurabilityInSlots[ITEM_SLOT_COUNT]; memset(iItemDurabilityInSlots, -1, sizeof(iItemDurabilityInSlots));
	int iItemCountInSlots[ITEM_SLOT_COUNT]; memset(iItemCountInSlots, -1, sizeof(iItemCountInSlots));

	for ( int i = 0; i < ITEM_SLOT_COUNT; i++ )				// 슬롯 갯수마큼..
	{
		iItemIDInSlots[i] = pkt.read<uint32_t>();
		iItemDurabilityInSlots[i] = pkt.read<int16_t>();
		iItemCountInSlots[i] = pkt.read<int16_t>();

		// NOTE(srmeier): adding rental flag and remaining time
		uint8_t bRentFlag = pkt.read<uint8_t>();
		int16_t sRemainingRentalTime = pkt.read<int16_t>();
	}

	m_fMsgSendTimeMove		= 0;						// Network ReQuest 타이머 초기화..
	m_fMsgSendTimeRot		= 0;
	m_fPlayerYawSended		= 0;						// 최근에 메시지를 보낸 시점의 플레이어 y 축 회전값.
	m_vPlayerPosSended		= s_pPlayer->Position();	// 최근에 메시지를 보낸 시점의 플레이어 위치.

	// 상태창 수치를 모두 적용
	if(m_pUIVar->m_pPageState) m_pUIVar->m_pPageState->UpdateID(szID); // 이름 적용.
	m_pUIVar->UpdateAllStates(&(s_pPlayer->m_InfoBase), &(s_pPlayer->m_InfoExt));

	//__KnightsInfoBase* pKIB = m_pUIKnightsOp->KnightsInfoFind(s_pPlayer->m_InfoBase.iKnightsID);
	//if(pKIB) m_pUIVar->m_pPageKnights->UpdateKnightsName(pKIB->szName);
	
	// 상태 바 갱신
	m_pUIStateBarAndMiniMap->UpdateExp(s_pPlayer->m_InfoExt.iExp, s_pPlayer->m_InfoExt.iExpNext, true);
	m_pUIStateBarAndMiniMap->UpdateHP(s_pPlayer->m_InfoBase.iHP, s_pPlayer->m_InfoBase.iHPMax, true);
	m_pUIStateBarAndMiniMap->UpdateMSP(s_pPlayer->m_InfoExt.iMSP, s_pPlayer->m_InfoExt.iMSPMax, true);

	m_pUIPartyOrForce->MemberInfoReInit(); // 파티 창.. 갱신..
	
	__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..	
	__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..	

	int iItemIDInInventorys[MAX_ITEM_INVENTORY]; memset(iItemIDInInventorys, -1, sizeof(iItemIDInInventorys));
	int iItemCountInInventorys[MAX_ITEM_INVENTORY]; memset(iItemCountInInventorys, -1, sizeof(iItemCountInInventorys));
	int iItemDurabilityInInventorys[MAX_ITEM_INVENTORY]; memset(iItemDurabilityInInventorys, -1, sizeof(iItemDurabilityInInventorys));

	for ( int i = 0; i < MAX_ITEM_INVENTORY; i++ )				// 슬롯 갯수마큼..
	{
		iItemIDInInventorys[i] = pkt.read<uint32_t>();
		iItemDurabilityInInventorys[i] = pkt.read<int16_t>();
		iItemCountInInventorys[i] = pkt.read<int16_t>();

		// NOTE(srmeier): adding rental flag and remaining time
		uint8_t bRentFlag = pkt.read<uint8_t>();
		int16_t sRemainingRentalTime = pkt.read<int16_t>();
	}


	// NOTE(srmeier): adding is chicken and manner points
	uint8_t bIDK; int16_t sIDK;
	bIDK = pkt.read<uint8_t>();
	bIDK = pkt.read<uint8_t>();
	sIDK = pkt.read<int16_t>();
	uint8_t bIsChicken = pkt.read<uint8_t>();
	int iMannerPoints = pkt.read<uint32_t>();


	m_pUIInventory->ReleaseItem();

	std::string szResrcFN, szIconFN;
	for ( int i = 0; i < ITEM_SLOT_COUNT; i++ )				// 슬롯 갯수마큼..
	{
		if(0 == iItemIDInSlots[i]) continue;

		pItem = s_pTbl_Items_Basic.Find(iItemIDInSlots[i]/1000*1000);	// 열 데이터 얻기..
		if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
			pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemIDInSlots[i]%1000);	// 열 데이터 얻기..
		else
			pItemExt = nullptr;

		if ( nullptr == pItem || nullptr == pItemExt )
		{
			__ASSERT(0, "NULL Item!!!");
			CLogWriter::Write("MyInfo - slot - Unknown Item {}, IDNumber", iItemIDInSlots[i]);
			continue; // 아이템이 없으면..
		}

		e_PartPosition ePart;
		e_PlugPosition ePlug;
		e_ItemType eType = MakeResrcFileNameForUPC(pItem, pItemExt, &szResrcFN, &szIconFN, ePart, ePlug, s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
		if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
		__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item Type");
		e_ItemSlot eSlot = (e_ItemSlot)i;

		switch(eSlot)
		{
		case ITEM_SLOT_EAR_RIGHT:
		case ITEM_SLOT_EAR_LEFT:
		case ITEM_SLOT_NECK:
		case ITEM_SLOT_RING_RIGHT:
		case ITEM_SLOT_RING_LEFT:
			{
				if(ITEM_TYPE_ICONONLY != eType) CLogWriter::Write("MyInfo - slot - Invalid Item");
				__ASSERT(ITEM_TYPE_ICONONLY == eType, "Invalid Item");
			}
			break;
		case ITEM_SLOT_UPPER: // Parts - 상체
		case ITEM_SLOT_LOWER: // Parts - 하체
		case ITEM_SLOT_GLOVES: // 장갑
		case ITEM_SLOT_SHOES: // 신발
		case ITEM_SLOT_HEAD: // 머리카락 ?? -> 투구 ??
			{
				if(ITEM_TYPE_PART != eType)  CLogWriter::Write("MyInfo - slot - Invalid Item");
				__ASSERT(ITEM_TYPE_PART == eType, "Invalid Item");
				s_pPlayer->PartSet(ePart, szResrcFN, pItem, pItemExt);	// 파트를 셋팅..
			}
			break;
		case ITEM_SLOT_HAND_RIGHT: // 오른손
		case ITEM_SLOT_HAND_LEFT: // 왼손
			{
				if(ITEM_TYPE_PLUG != eType) CLogWriter::Write("MyInfo - slot - Invalid Item");
				__ASSERT(ITEM_TYPE_PLUG == eType, "Invalid Item");
				
				e_PlugPosition ePlugPos;
				if(ITEM_SLOT_HAND_RIGHT == eSlot) ePlugPos = PLUG_POS_RIGHTHAND;
				else ePlugPos = PLUG_POS_LEFTHAND;
				s_pPlayer->PlugSet(ePlugPos, szResrcFN, pItem, pItemExt);	// 파트를 셋팅..
			}
			break;
		case ITEM_SLOT_SHOULDER: // 망토
			{
			}
			break;
		case ITEM_SLOT_BELT:
			{
			}
			break;
		}

		s_pPlayer->DurabilitySet(eSlot, iItemDurabilityInSlots[eSlot]);	// 무기 낡음 처리..

		__IconItemSkill* spItem = new __IconItemSkill;
		spItem->pItemBasic	= pItem;
		spItem->pItemExt	= pItemExt;
		spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
		spItem->iCount		= iItemCountInSlots[i];
		spItem->iDurability = iItemDurabilityInSlots[i];

		// 인벤토리 슬롯에 넣는다.
		m_pUIInventory->m_pMySlot[i] = spItem;
		//TRACE("Init Inv Msg Slot %d \n", iItemIDInSlots[i]);
	}

	// 인벤토리..
	int iItemCount = 0;
	for ( int i = 0; i < MAX_ITEM_INVENTORY; i++ )				// 인벤토리 갯수만큼..	
	{
		if(!iItemIDInInventorys[i]) continue;

		pItem = s_pTbl_Items_Basic.Find(iItemIDInInventorys[i]/1000*1000);	// 열 데이터 얻기..
		pItemExt = nullptr;
		if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
			pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemIDInInventorys[i]%1000);	// 열 데이터 얻기..
		if ( nullptr == pItem || nullptr == pItemExt )
		{
			__ASSERT(0, "NULL Item");
			CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", iItemIDInInventorys[i]);
			continue; // 아이템이 없으면..
		}

		e_PartPosition ePart;
		e_PlugPosition ePlug;
		e_ItemType eType = MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
		if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
		__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
		
		__IconItemSkill* spItem = new __IconItemSkill;
		spItem->pItemBasic	= pItem;
		spItem->pItemExt	= pItemExt;
		spItem->szIconFN = szIconFN; // 아이콘 파일 이름 복사..
		spItem->iCount	= iItemCountInInventorys[i];
		spItem->iDurability = iItemDurabilityInInventorys[i];

		m_pUIInventory->m_pMyInvWnd[i] = spItem; 
		//TRACE("Init Inv Msg Inve %d, iOrder %d \n", iItemIDInInventorys[i], i);
	}

	// Inventory & Slot Icon Operation.. ^^
	m_pUIInventory->InitIconUpdate();

	if (m_pUISkillTreeDlg) m_pUISkillTreeDlg->UpdateDisableCheck();
	if (m_pUIHotKeyDlg) m_pUIHotKeyDlg->UpdateDisableCheck();

	if(s_pPlayer->Part(PART_POS_UPPER)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->PartSet(PART_POS_UPPER, pLooks->szPartFNs[PART_POS_UPPER], nullptr, nullptr);	// 상체..
	if(s_pPlayer->Part(PART_POS_LOWER)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->PartSet(PART_POS_LOWER, pLooks->szPartFNs[PART_POS_LOWER], nullptr, nullptr);	// 하체..
	if(s_pPlayer->Part(PART_POS_HANDS)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->PartSet(PART_POS_HANDS,  pLooks->szPartFNs[PART_POS_HANDS], nullptr, nullptr);	// 팔..
	if(s_pPlayer->Part(PART_POS_FEET)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->PartSet(PART_POS_FEET,  pLooks->szPartFNs[PART_POS_FEET], nullptr, nullptr);	// 다리..
	if(s_pPlayer->Part(PART_POS_FACE)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->InitFace();
	if(s_pPlayer->Part(PART_POS_HAIR_HELMET)->FileName().empty()) // 아무것도 세팅안되어 있으면 파일 이름이 없다..
		s_pPlayer->InitHair();

	s_pPlayer->InventoryChrAnimationInitialize();
	s_pPlayer->SetSoundAndInitFont();

//	s_pPlayer->SettingCollisionCheckPoint();

	////////////////////////////////////////////////////////////
	// 기본값 읽기..
	int iRun = 1;
//	if(false == CGameProcedure::RegGetSetting("UserRun", &iRun, 4)) iRun = 1; // 걷고 뛰는 상태를 레지스트리에서 읽고.. 기본값은 뛰는 상태이다..
//	if(1 == iRun)
	this->CommandToggleWalkRun(); // 뛰게 만든다..

	e_ViewPoint eVP = VP_THIRD_PERSON;
	if(false == CGameProcedure::RegGetSetting("CameraMode", &eVP, 4)) eVP = VP_THIRD_PERSON; // 카메라 상태 기록
	s_pEng->ViewPointChange(eVP);
	// 기본값 읽기..
	////////////////////////////////////////////////////////////

	InitPlayerPosition(__Vector3(fX, fY, fZ)); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
	s_pPlayer->RegenerateCollisionMesh();

	// berserk temp
	//s_pPlayer->PlugSet(PLUG_POS_BACK, "item/babacloak.n3cplug_cloak", nullptr);	// 파트를 셋팅..
	// end berserk temp

	// berserk
	//s_pPlayer->AttachCloak();

	//..
	s_pOPMgr->Release();							// 다른 유저 관리 클래스 초기화..
	
	if (m_pUICmdList != nullptr)
		m_pUICmdList->CreateCategoryList();

	m_bLoadComplete = TRUE;						// 로딩 끝..

	return true;
}

bool CGameProcMain::MsgRecv_Chat(Packet& pkt)
{
	std::string szChat;				// 버퍼..
	e_ChatMode eCM	=	(e_ChatMode)pkt.read<uint8_t>();	// 채팅 타입
	e_Nation eNation =	(e_Nation)pkt.read<uint8_t>();	// 보낸사람 국가
	int iID =			pkt.read<int16_t>();			// 보낸사람

	std::string szName;
	int iNameLen = pkt.read<uint8_t>();
	pkt.readString(szName, iNameLen);

	std::string szMsg;
	int iMsgLen = pkt.read<int16_t>();
	pkt.readString(szMsg, iMsgLen);

	if (szName.empty())
		szChat = szMsg;
	else
		szChat = szName + " : " + szMsg;

	//지속 공지 삭제...
	if(eCM == N3_CHAT_CONTINUE_DELETE)
	{
		m_pUIChatDlg->DeleteContinueMsg();
		return true;
	}
	//타이틀 공지 삭제...
	else if(eCM == N3_CHAT_TITLE_DELETE)
	{
		m_pUIChatDlg->SetNoticeTitle("", 0xffffffff);
		return true;
	}

	D3DCOLOR crChat = 0xffffffff;
	switch(eCM)
	{
	case N3_CHAT_NORMAL:	crChat = D3DCOLOR_ARGB(255,255,255,255);	break;
	case N3_CHAT_PRIVATE:	crChat = D3DCOLOR_ARGB(255, 128, 255, 255);/*D3DCOLOR_ARGB(255,192,192,0);*/		break;
	case N3_CHAT_PARTY:		crChat = D3DCOLOR_ARGB(255,0,192,192);		break;
	case N3_CHAT_FORCE:		crChat = D3DCOLOR_ARGB(255,0,192,192);		break;
	//case N3_CHAT_SHOUT:	crChat = D3DCOLOR_ARGB(255,255,0,0);		break;
	case N3_CHAT_SHOUT:		crChat = D3DCOLOR_ARGB(255,0xf8,0x66,0x05);	break;
	case N3_CHAT_CLAN:		crChat = D3DCOLOR_ARGB(255,0,255,0);		break;
	case N3_CHAT_PUBLIC:	crChat = D3DCOLOR_ARGB(255,255,255,0);		break;
	case N3_CHAT_WAR:		crChat = D3DCOLOR_ARGB(255,255,255,0);		break;
	case N3_CHAT_TITLE:		crChat = D3DCOLOR_ARGB(255,255,255,0);		break;
	case N3_CHAT_CONTINUE:	crChat = D3DCOLOR_ARGB(255,255,255,0);		break;
	}

	if(eCM == N3_CHAT_TITLE)
	{
		m_pUIChatDlg->SetNoticeTitle(szChat, crChat);
		return true;
	}
	else if(N3_CHAT_WAR == eCM)
	{
		if(m_pWarMessage) m_pWarMessage->SetMessage(szChat, D3DFONT_BOLD, crChat);
		return true;
	}
	else if(N3_CHAT_CONTINUE == eCM)
	{
		m_pUIChatDlg->AddContinueMsg(eCM, szChat, crChat);
		return true;
	}


	// 통역 서비스...           ㅡ,.ㅡ a
	if (N3_CHAT_NORMAL == eCM
		|| N3_CHAT_PRIVATE == eCM
		|| N3_CHAT_SHOUT == eCM)
	{
		if (eNation != s_pPlayer->Nation()
			&& !s_pPlayer->m_InfoExt.bCanTalkToOtherNation)
		{
			CPlayerBase* pTalker = s_pOPMgr->UPCGetByID(iID, false);
			bool bIamManager = (0 == s_pPlayer->m_InfoBase.iAuthority) ? true : false;
			bool bTalkerIsManager = (pTalker && 0 == pTalker->m_InfoBase.iAuthority) ? true : false;

			// 내가 운영자가 아니고 상대방도 운영자가 아니면
			if (!bIamManager
				&& !bTalkerIsManager)
			{
				size_t i = szChat.find(':');
				if (i != std::string::npos)
				{
					for (; i < szChat.length(); i++)
						szChat[i] = '!' + rand() % 10; // 이상한 말로 바꾼다..
				}
			}
		}
	}
	
	// 풍선말 넣기..
	CPlayerBase* pBPC = nullptr;
	if(iID == s_pPlayer->IDNumber()) pBPC = s_pPlayer;
	else pBPC = s_pOPMgr->CharacterGetByID(iID, false);
	if(pBPC && s_pPlayer->Distance(pBPC->Position()) < 4.0f &&
		(N3_CHAT_NORMAL == eCM || N3_CHAT_SHOUT == eCM) ) // 보통 채팅 혹은 외치기일때만..
		pBPC->BalloonStringSet(szChat, crChat);

	// 채팅창에 넣기..
	m_pUIChatDlg->AddChatMsg(eCM, szChat, crChat);

	return true;
}

bool CGameProcMain::MsgRecv_UserMove(Packet& pkt)
{
	int iID			= pkt.read<int16_t>();
	float fX		= (pkt.read<uint16_t>())/10.0f; // 출발하거나 이동중일때에는 다음 위치. 정지할때는 현재 위치를 받는다.
	float fZ		= (pkt.read<uint16_t>())/10.0f;
	float fY		= (pkt.read<int16_t>())/10.0f;
	float fSpeed	= (pkt.read<int16_t>())/10.0f; // 출발하거나 이동중일때에는 움직이는 속도. 정지할때는 0 이 온다.
	uint8_t byMoveFlag = pkt.read<uint8_t>(); // 움직이는 플래그.. 0 정지 1 출발, 2 계속 움직임

	// 함수가 와야 할 부분.. ^^
	// 아이디, 플레이어 상태 1, 플레이어 상태 2, 현재 xzy 위치, 현재 xzy 방향, 1초뒤 x, z, y dnlcl..

	if(0xff == byMoveFlag) // 강제위치 업데이트 패킷이다..
	{
		if(iID == s_pPlayer->IDNumber())	// 내 매시지면..
		{
			this->InitPlayerPosition(__Vector3(fX, fY, fZ)); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
		}
		else
		{
			CPlayerNPC* pBPC = s_pOPMgr->CharacterGetByID(iID, true);	// 다른 플레이어를 얻어서..
			if (nullptr == pBPC)
			{
				this->MsgSend_UserInRequest(iID); // User 정보가 없을 경우 요청한다..
				return false;
			}
			else if(pBPC->IsDead())
				return false;
			
			pBPC->MoveTo(fX, fY, fZ, 0, 0);	// 현재 위치..
			pBPC->PositionSet(__Vector3(fX, fY, fZ), true);
		}
		return false;
	}

	if(iID == s_pPlayer->IDNumber())	// 내 매시지면..
	{
		s_pPlayer->m_vPosFromServer.Set(fX, fY, fZ);
		return false;
	}

	CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(iID, true);	// 다른 플레이어를 얻어서..
	if (nullptr == pUPC) return false;

//	if(0.0f != fSpeed) TRACE("Move - %4.1f ( %d : Mode %d ) %.2f초\n", fSpeed, iID, byMoveFlag, CN3Base::TimeGet());
//	else TRACE("Stop - %4.1f ( %d : Mode %d )  %.2f초\n", fSpeed, iID, byMoveFlag, CN3Base::TimeGet());

	//	서버로 부터터 받은 정보로 업데이트..
	pUPC->MoveTo(fX, fY, fZ, fSpeed, byMoveFlag);	// 현재 위치..

	return true;
}

bool CGameProcMain::MsgRecv_Rotation(Packet& pkt)
{
	int iID			= pkt.read<int16_t>();
	float fYaw		= (pkt.read<int16_t>())/100.0f;

	if(s_pPlayer->IDNumber() == iID) return false;

	CPlayerNPC* pBPC = nullptr;
	pBPC = s_pOPMgr->CharacterGetByID(iID, true);	// 다른 유저 얻어서..
	if ( nullptr == pBPC ) return false;

	pBPC->RotateTo(fYaw, false);	// 서버로 부터 받은 x, y, z값으로 

	return true;
}

/*
bool CGameProcMain::MsgRecv_Dead(Packet& pkt)
{
	int iID	= pkt.read<int16_t>();
//	TRACE("Dead message Receive.. !!!!!!!! %d \n", iID);

	if ( iID == s_pPlayer->IDNumber() )
	{
		s_pPlayer->Action(PSA_PRE_DYING, true, nullptr, true); // 플레이어 죽이기.
	}
	else
	{
		CPlayerOther* pReadyToDead = s_pOPMgr->PlayerGetByID(iID, true); // 살아 있는 넘들중에서 검색해보고..
		if(pReadyToDead) // 있으면 죽기직전으로 만든다.
		{
			pReadyToDead->Acttion(PSA_PRE_DYING, true, nullptr, true);
		}
	}

	return true;
}
*/


bool CGameProcMain::MsgRecv_Regen(Packet& pkt)
{
	__Vector3 vPosPlayer;
	vPosPlayer.x = (pkt.read<uint16_t>())/10.0f;
	vPosPlayer.z = (pkt.read<uint16_t>())/10.0f;
	vPosPlayer.y = (pkt.read<int16_t>())/10.0f;
	
	this->InitPlayerPosition(vPosPlayer); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
	s_pPlayer->RegenerateCollisionMesh(); // 충돌 메시를 다시 만든다..

	s_pPlayer->m_iSendRegeneration = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그
	s_pPlayer->m_fTimeAfterDeath = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그
	//TRACE("받음 - 다시 살아나기(%.1f, %.1f)\n", vPosPlayer.x, vPosPlayer.z);

	//
	//마법 & 효과 초기화..
	if(m_pUIStateBarAndMiniMap) m_pUIStateBarAndMiniMap->ClearMagic();
	if(m_pMagicSkillMng) m_pMagicSkillMng->ClearDurationalMagic();
	if(CGameProcedure::s_pFX) s_pFX->StopMine();

	CLogWriter::Write("Receive Regeneration");

	if(s_pPlayer->Nation()==NATION_KARUS) CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_KARUS, s_pPlayer->IDNumber(), -1);
	else if(s_pPlayer->Nation()==NATION_ELMORAD) CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_ELMORAD, s_pPlayer->IDNumber(), -1);

	return true;
}

bool CGameProcMain::MsgRecv_Time(Packet& pkt)
{
	int16_t year	= pkt.read<int16_t>();
	int16_t month = pkt.read<int16_t>();
	int16_t day	= pkt.read<int16_t>();
	int16_t hour	= pkt.read<int16_t>();
	int16_t min	= pkt.read<int16_t>();

	ACT_WORLD->SetGameTimeWithSky(year, month, day, hour, min);

	return true;
}

bool CGameProcMain::MsgRecv_Weather(Packet& pkt)
{
	int iWeather = pkt.read<uint8_t>(); // -> byte - 기후.... 0x01 - 맑음.. 0x02 -  비 0x03
	int iPercent = pkt.read<int16_t>(); // int16_t -> 맑은날 안개, 비, 눈 의 양 퍼센트로 

	
	////////////////////////////////////////////////////
	// 스피드 핵 체크용 시간....
/*	float fTimeFromServer = pkt.read<float>(); // float -> 정기적으로 주는 시간...
	float fTimeLocal = CN3Base::TimeGet();
	
	static float fTimeFromServerPrev = fTimeFromServer;
	static float fTimeLocalPrev = fTimeLocal;
	static int iTSH = 0; // Trying SpeedHacking...
	if(fTimeFromServer != 0.0f)
	{
		float fTDS = fTimeFromServer - fTimeFromServerPrev;
		if(fTDS > 355.0f && fTDS < 365.0f) // 6분에 한번 주게끔 되어 있다..
		{
			float fTDL = fTimeLocal - fTimeLocalPrev;
			if(fTDL < (fTDS * 0.8f) || fTDL > (fTDS * 1.2f)) // 로컬 타임이 서버 타임보다 20퍼센트 이상 크면..
			{
				iTSH++; // Try Speed Hacking ... ++
			}
			else 
			{
				iTSH = 0;
			}

			if(iTSH >= 3) CGameProcedure::s_bUseSpeedHack = true; // 스피드 해킹....
		}

		fTimeFromServerPrev = fTimeFromServer;
		fTimeLocalPrev = fTimeLocal;
	}
	// 스피드 핵 체크용 시간....
	////////////////////////////////////////////////////
*/
	
	if(iPercent < 20) iPercent = 20;
	if(iPercent > 100) iPercent = 100;
	float fPercent = iPercent / 100.0f;

//enum {	GEW_CLEAR=0,		// 맑음
//		GEW_DRIZZLE_RAIN=1,		// 가랑비
//		GEW_RAINY=2,			// 적당량의 비
//		GEW_HEAVY_RAIN=3,		// 폭우
//		GEW_SNOW1=11,			// 포근한 눈
//		GEW_SNOW2=12,			// 적당한 눈
//		GEW_HEAVY_SNOW=13		// 폭설
	//TRACE("받음 - 날씨(%d - %d)\n", iWeather, iPercent);

	ACT_WORLD->SetWeatherWithSky((CN3SkyMng::eSKY_WEATHER)iWeather,iPercent);	// 하늘 변화하기
	float fDelta = 1.0f;
	if(0x1 == iWeather) fDelta = 0.5f + (1.0f-fPercent)*0.5f; // 맑은 날씨. 퍼센트는 안개...
	else if(0x02 == iWeather) fDelta = 0.25f + (1.0f - fPercent)*0.75f; // 비옴 .
	else if(0x03 == iWeather) fDelta = 0.25f + (1.0f - fPercent)*0.75f; // 눈옴..

	s_pEng->FarPlaneDeltaSet(fDelta, false);

	return true;
}

bool CGameProcMain::MsgRecv_UserInOut(Packet& pkt)
{
	int iType = pkt.read<uint8_t>();//pkt.read<uint8_t>();

	if ( 0x01 == iType ) // 유저 들어올때.(원래 게임상의 유저 지역 업뎃하면서 갱신..)
		this->MsgRecv_UserIn(pkt, false);
	else if ( 0x02 == iType ) // User 나갈때.
		this->MsgRecv_UserOut(pkt);
	else if ( 0x03 == iType ) // 유저 들어올때 (죽었다 살아나거나, game start하는 유저들.)
		this->MsgRecv_UserIn(pkt, true);
	else if ( 0x04 == iType ) // 유저 들어올때 (warp)
		this->MsgRecv_UserIn(pkt, false);
	
	return true;
}

bool CGameProcMain::MsgRecv_UserIn(Packet& pkt, bool bWithFX)
{
	int iID			= pkt.read<int16_t>();

	std::string szName;
	int iNameLen	= pkt.read<uint8_t>();
	pkt.readString(szName, iNameLen );

	e_Nation eNation =				(e_Nation)pkt.read<uint8_t>(); // 소속 국가. 0 이면 없다. 1

	// 기사단 관련
	int iKnightsID =					pkt.read<int16_t>(); // 기사단 ID
	e_KnightsDuty eKnightsDuty =	(e_KnightsDuty)pkt.read<uint8_t>(); // 소속 국가. 0 이면 없다. 1

	// NOTE(srmeier): adding alliance ID
	int16_t sAllianceID = pkt.read<int16_t>();

	int iKnightNameLen = pkt.read<uint8_t>(); // 소속 기사단 이름 길이.
	std::string szKnightsName;
	pkt.readString(szKnightsName, iKnightNameLen);
	int iKnightsGrade = pkt.read<uint8_t>();			// 등급
	int iKnightsRank = pkt.read<uint8_t>();			// 순위

	// NOTE(srmeier): adding mark version and cape ID
	int16_t sMarkVersion = pkt.read<int16_t>();
	int16_t sCapeID = pkt.read<int16_t>();

	int iLevel =					pkt.read<uint8_t>(); // 레벨...
	e_Race eRace =					(e_Race)pkt.read<uint8_t>();
	e_Class eClass =				(e_Class)pkt.read<int16_t>();
	float fXPos	=					(pkt.read<uint16_t>())/10.0f;
	float fZPos	=					(pkt.read<uint16_t>())/10.0f;
	float fYPos	=					(pkt.read<int16_t>())/10.0f;
	
	float fYTerrain = ACT_WORLD->GetHeightWithTerrain(fXPos, fZPos);	// 지형의 높이값 얻기..
	float fYObject = ACT_WORLD->GetHeightNearstPosWithShape(__Vector3(fXPos, fYPos, fZPos), 1.0f); // 오브젝트에서 가장 가까운 높이값 얻기..
	if (fYObject > fYTerrain) fYPos = fYObject;
	else fYPos = fYTerrain;

	int iFace = pkt.read<uint8_t>(); // 머리카락..
	int iHair = pkt.read<uint8_t>(); // 얼굴 모양

	int iStatus = pkt.read<uint8_t>(); // 1 - 서있기.. 2 - 앉아있기.. 3 ... 죽어있다..

	// NOTE(srmeier): updating status
	//int iStatusSize = pkt.read<uint8_t>(); // 0 - 보통 크기, 1 - 커져 있다. 2 - 작아졌다..
	int iStatusSize = pkt.read<uint32_t>();

	int iRecruitParty = pkt.read<uint8_t>(); // 1 - 보통. 2 - 파티 구함..
	uint8_t byAuthority = pkt.read<uint8_t>(); // 권한...

	// NOTE(srmeier): adding is party leader, invisibilitytype, direction, chicken, rank, knight rank, personal rank
	bool bPartyLeader = pkt.read<bool>();
	uint8_t bInvisibilityType = pkt.read<uint8_t>();
	int16_t sDirection = pkt.read<int16_t>();
	bool bIsChicken = pkt.read<bool>();
	uint8_t bRank = pkt.read<uint8_t>();
	uint8_t m_bKnightsRank = pkt.read<uint8_t>();
	uint8_t m_bPersonalRank = pkt.read<uint8_t>();


	uint32_t	dwItemIDs[MAX_ITEM_SLOT_OPC];  // 착용 아이템 - 다른 플레이어(NPC 포함) 0 ~ 4 상체,하체,헬멧,팔,발 5 망토 6 오른손 7 왼손
	int			iItemDurabilities[MAX_ITEM_SLOT_OPC]; // 착용 아이템의 내구력..
	uint8_t		byItemFlags[MAX_ITEM_SLOT_OPC];
	for(int i = 0; i < MAX_ITEM_SLOT_OPC; i++)
	{
		dwItemIDs[i] = pkt.read<uint32_t>();			// 착용하고 있는 아이템들의 ID
		iItemDurabilities[i] = pkt.read<int16_t>();	// 착용하고 있는 아이템들의 현재 내구력

		// NOTE(srmeier): adding bFlag, probably the rental thing
		byItemFlags[i] = pkt.read<uint8_t>();
	}

	if ( iID == s_pPlayer->IDNumber()) 
		return false; 									// 내 패킷이면 .. // 무시한다..

	CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(iID, false);
	if(pUPC) // 이미 아이디 같은 캐릭이 있으면..
	{
		CLogWriter::Write("User In - Duplicated ID ({}, {}) Pos({:.2f},{:.2f},{:.2f})",
			iID, szName, fXPos, fYPos, fZPos);
		//TRACE("User In - Duplicated ID (%d, %s) Pos(%.2f,%.2f,%.2f)\n", iID, szName.c_str(), fXPos, fYPos, fZPos);

		// TEMP(srmeier): need to figure out what is going on here and how to fix it
		// commenting out what's below to keep the OtherPlayer in the manager...

		// NOTE(srmeier): probably shouldn't be requesting this player's info if it's already in the manager...

		//pUPC->Action(PSA_BASIC, true, nullptr, true); // 강제로 살리고..
		//pUPC->m_fTimeAfterDeath = 0;
		//pUPC->PositionSet(__Vector3(fXPos, fYPos, fZPos), true);

		return false;
	}
	
	D3DCOLOR crID = (eNation != s_pPlayer->m_InfoBase.eNation) ? D3DCOLOR_XRGB(255,96,96) : D3DCOLOR_XRGB(128,128,255); // 국가에 따라 다른색 적용

	pUPC = new CPlayerOther();
	pUPC->IDSet(iID, szName, crID);
	pUPC->m_InfoBase.eNation = eNation;
	pUPC->m_InfoBase.eClass = eClass;
	pUPC->m_InfoBase.iLevel = iLevel;
	pUPC->m_InfoBase.iAuthority = byAuthority;
	pUPC->Init(eRace, iFace, iHair, dwItemIDs, iItemDurabilities);
	pUPC->RotateTo(DegreesToRadians(rand()%360), true);
	pUPC->KnightsInfoSet(iKnightsID, szKnightsName, iKnightsGrade, iKnightsRank);

	//__KnightsInfoBase* pKIB = m_pUIKnightsOp->KnightsInfoFind(iKightsID);
	//if(pKIB) pUPC->KnightsNameSet(pKIB->szName, 0xffff0000);

	pUPC->PositionSet(__Vector3(fXPos, fYPos, fZPos), true);			// 다른 플레이어 현재 위치 셋팅..
	pUPC->MoveTo(fXPos, fYPos, fZPos, 0, 0);					// 현재 위치..
	pUPC->RotateTo(DegreesToRadians(rand()%360), true);
	s_pOPMgr->UPCAdd(pUPC);										// 캐릭터 추가...

	//if(bWithFX)
	if(bWithFX && pUPC->m_InfoBase.iAuthority != AUTHORITY_MANAGER)
	{
		if(eNation==NATION_KARUS) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_REGEN_KARUS, iID, -1);
		else if(eNation==NATION_ELMORAD) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_REGEN_ELMORAD, iID, -1);
	}

	// 앉아 있기.., 서있기 결정..
	if(1 == iStatus) // 서있기..
	{
		pUPC->Action(PSA_BASIC, true, nullptr, true);
		pUPC->ActionMove(PSM_STOP);
	}
	else if(2 == iStatus) // 앉아 있기..
	{
		pUPC->Action(PSA_SITDOWN, true, nullptr, true);
		pUPC->ActionMove(PSM_STOP);
	}
	else if(3 == iStatus) // 죽어 있다..
	{
		s_pOPMgr->MoveToCorpsesForcely(pUPC, false); // 시체로 옮긴다..
	}

	if(0x01 == iStatusSize)
	{
		pUPC->ScaleSetGradually(1.0f); // 보통 크기..
		pUPC->FlickerFactorSet(1.0f); // 부활되서 반투명.. 깜박거린다..
	}
	else if(0x02 == iStatusSize) pUPC->ScaleSetGradually(2.0f); // 커졌다..
	else if(0x03 == iStatusSize) pUPC->ScaleSetGradually(0.5f);// 작아졌다.
	else if(0x04 == iStatusSize) pUPC->FlickerFactorSet(0.7f); // 부활되서 반투명.. 깜박거린다..

	if(1 == iRecruitParty)
	{
		pUPC->InfoStringSet("", 0);
	}
	else if(2 == iRecruitParty) // 파티 구함..
	{
		int iLevel = pUPC->m_InfoBase.iLevel;
		int iLMin = iLevel - 8;
		if(iLMin < 0) iLMin = 0;
		int iLMax = iLevel + 8;
		if(iLMax > 80) iLMax = 80;

		std::string szMsg = fmt::format_text_resource(IDS_WANT_PARTY_MEMBER,
			iLMin, iLMax);
		pUPC->InfoStringSet(szMsg, 0xff00ff00);
	}

	return true;
}

bool CGameProcMain::MsgRecv_UserOut(Packet& pkt)
{
	int iID	= pkt.read<int16_t>();

	//죽은 상태의 캐릭터를 시체로 만든다.
	CPlayerNPC* pUPC = s_pOPMgr->UPCGetByID(iID, false);
	if( pUPC == nullptr ) return false;
	if( pUPC->IsDead() )
	{//캐릭터가 죽은 상태에서 UserOut을 하게 되면 시체로 바꿔준다.
		s_pOPMgr->CorpseAdd(iID);
		return true;
	}

	return s_pOPMgr->UPCDelete(iID);					// 캐릭터 제거...	
}

// 주위 영역의 모든 아이디를 카운트만큼 받는다... 글구.. 업데이트가 필요한 것만 서버에게 요청..
bool CGameProcMain::MsgRecv_UserInAndRequest(Packet& pkt)
{
	int iUPCCountReceived = pkt.read<int16_t>();
//	TRACE("UPC region update : %d\n", iUPCCountReceived);
	
	if(0 == iUPCCountReceived) return false;
	if(iUPCCountReceived < 0 || iUPCCountReceived >= 1000)
	{
		std::string szErr = fmt::format("영역 요청 오류 - 플레이어 갯수 {}", iUPCCountReceived);
		CGameProcedure::ReportDebugStringAndSendToServer(szErr);
		__ASSERT(0, szErr.c_str());
		return false;
	}

	int iID = 0;
	m_SetUPCID.clear(); // 싹 지우고...
	it_ID itID, itIDEnd = m_SetUPCID.end();
	pair_ID pairID;

	for ( int i = 0; i < iUPCCountReceived; i++ )
	{
		iID = pkt.read<int16_t>();
//		TRACE("               ID : %d\n", iID);
		if(iID == s_pPlayer->IDNumber()) continue; // 내 아이디이다.. 고로 넣으면 안된다.

		pairID = m_SetUPCID.insert(iID);
	}

	if(m_SetUPCID.empty()) // 새로 받은게 한개도 없다면 몽땅 날린다..
	{
		s_pOPMgr->ReleaseUPCs();
		return false;
	}

	// 새로 받은 아이디와 리스트에 있는 UPC ID 를 검색해서..
	CPlayerOther* pUPC = nullptr;
	it_UPC itUPC = s_pOPMgr->m_UPCs.begin(), itUPCEnd = s_pOPMgr->m_UPCs.end();
	for(; itUPC != itUPCEnd; )
	{
		pUPC = itUPC->second;
		iID = pUPC->IDNumber();
		
		itID = m_SetUPCID.find(iID);
		if(itID != itIDEnd) // 새로 들어온 리스트에 있으면.. 
		{
			m_SetUPCID.erase(itID); // 요청할 리스트에서 빼고..
			itUPC++;
		}
		else  // 새로 들어온곳에 없으면 지운다..
		{
//			TRACE("           delete : %d\n", iID);

			if(pUPC && pUPC->IsDead()) 
			{
				itUPC++;
			}
			else
			{
				delete pUPC; pUPC = nullptr;
				itUPC = s_pOPMgr->m_UPCs.erase(itUPC);
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////
	// 바로 요청 패킷을 만들어 보낸다..
	int iNewUPCCount = static_cast<int>(m_SetUPCID.size());
	if (iNewUPCCount > 0)
	{
		int iOffset = 0;												// 버퍼의 오프셋..
		std::vector<uint8_t> byBuff(iNewUPCCount * 2 + 10, 0);			// 패킷 버퍼..
		CAPISocket::MP_AddByte(&byBuff[0], iOffset, WIZ_REQ_USERIN);	// 커멘드.
		CAPISocket::MP_AddShort(&byBuff[0], iOffset, iNewUPCCount);		// 아이디 갯수..
		
		itID = m_SetUPCID.begin(); itIDEnd = m_SetUPCID.end();
		for(int i = 0; itID != itIDEnd; itID++, i++)
		{
			iID = *itID;
			CAPISocket::MP_AddShort(&byBuff[0], iOffset, iID);			// 자세한 정보가 필요한 아이디들..
		}
		s_pSocket->Send(&byBuff[0], iOffset); // 보낸다
	}
	// 바로 요청 패킷을 만들어 보낸다..
	////////////////////////////////////////////////////////////////////////////

	return true;
}

bool CGameProcMain::MsgRecv_UserInRequested(Packet& pkt)
{
	int iPlayerCount = pkt.read<int16_t>();

	if(0 == iPlayerCount) return false;
	if(iPlayerCount < 0 || iPlayerCount >= 1000)
	{
		std::string szErr = fmt::format("영역정보 받기 오류 - 플레이어 갯수 {}", iPlayerCount);
		CGameProcedure::ReportDebugStringAndSendToServer(szErr);
		__ASSERT(0, szErr.c_str());
		return false;
	}

#ifdef _DEBUG
	float fTime = CN3Base::TimeGet();
#endif

	//	int iOffset2 = iOffset;
	for ( int i = 0; i < iPlayerCount; i++ )
	{
		this->MsgRecv_UserIn(pkt); // 플레이어 갯수 만큼 유저 인...
	}

#ifdef _DEBUG
	//TRACE("  User In Requested (Count:%d) : Avg(%.4f Sec)\n", iPlayerCount, (CN3Base::TimeGet() - fTime)/iPlayerCount);
#endif

	return true;
}


bool CGameProcMain::MsgRecv_NPCInOut(Packet& pkt)
{
	uint8_t byType		= pkt.read<uint8_t>();
	if ( byType == 0x01 ) // NPC 들어올때
	{
		return this->MsgRecv_NPCIn(pkt); // NPC In 처리
	}
	else // NPC 나갈때.
	{
		return this->MsgRecv_NPCOut(pkt);
	}

	return true;
}

bool CGameProcMain::MsgRecv_NPCIn(Packet& pkt)
{
	int		iID			= pkt.read<int16_t>(); // Server에서 관리하는 고유 ID
	int		iIDResrc	= pkt.read<int16_t>(); // 리소스 ID
	int		iType		= pkt.read<uint8_t>();	// NPC Type - 0x05 : 상인
	int		iItemTrdeID	= pkt.read<uint32_t>();	// 아이템 거래할 그룹 ID 서버에 요청할 ID
	int		iScale		= pkt.read<int16_t>(); // 스케일 100 은 1.0 
	int		iItemID0	= pkt.read<uint32_t>(); // 리소스 ID
	int		iItemID1	= pkt.read<uint32_t>(); // 리소스 ID
	int 	iNameLen	= pkt.read<uint8_t>();
	std::string szName;									// NPC 아이디..
	if(iNameLen > 0) pkt.readString(szName, iNameLen );
	else szName = "";

#ifdef _DEBUG
	CLogWriter::Write("NPC In - ID({}) Name({}) Time({:.1f})",
		iID, szName, CN3Base::TimeGet()); // 캐릭 세팅..
#endif

	e_Nation eNation = (e_Nation)pkt.read<uint8_t>(); // 소속 국가. 0 이면 없다. 1
	int iLevel		= pkt.read<uint8_t>();

	float fXPos	= (pkt.read<uint16_t>())/10.0f;
	float fZPos	= (pkt.read<uint16_t>())/10.0f;
	float fYPos	= (pkt.read<int16_t>())/10.0f;

	float fYTerrain = ACT_WORLD->GetHeightWithTerrain(fXPos, fZPos);	// 지형의 높이값 얻기..
	float fYObject = ACT_WORLD->GetHeightNearstPosWithShape(__Vector3(fXPos, fYPos, fZPos), 1.0f); // 오브젝트에서 가장 가까운 높이값 얻기..
	if (fYObject > fYTerrain) fYPos = fYObject;
	else fYPos = fYTerrain;

	uint32_t dwStatus =	pkt.read<uint32_t>(); // 상태... 여러가지로 or 연산해서 쓴다. 0 문 열림, 1 닫힘. 2, 4, 8, 16 ....
	uint32_t dwType =		pkt.read<uint8_t>(); // 타입... 0 이면 캐릭터 타입 NPC, 1 이면 오브젝트 타입 NPC


	// NOTE(srmeier): adding the unknown bytes and the direction
	int16_t sIDK0 = pkt.read<int16_t>();
	int16_t sIDK1 = pkt.read<int16_t>();
	uint8_t byDirection = pkt.read<uint8_t>();


	CPlayerNPC* pNPC = s_pOPMgr->NPCGetByID(iID, false);
	if(pNPC) // 이미 아이디 같은 캐릭이 있으면..
	{
		CLogWriter::Write("NPC In - Duplicated ID ({}, {}) Pos({:.2f},{:.2f},{:.2f})",
			iID, szName, fXPos, fYPos, fZPos);
		//TRACE("NPC In - Duplicated ID (%d, %s) Pos(%.2f,%.2f,%.2f)\n", iID, szName.c_str(), fXPos, fYPos, fZPos);
		pNPC->Action(PSA_BASIC, true, nullptr, true); // 강제로 살리고..
		pNPC->m_fTimeAfterDeath = 0;
		pNPC->PositionSet(__Vector3(fXPos, fYPos, fZPos), true);
		return false;
	}

	D3DCOLOR crID = (eNation != s_pPlayer->m_InfoBase.eNation) ? D3DCOLOR_XRGB(255,128,128) : D3DCOLOR_XRGB(192,192,255);

	pNPC = new CPlayerNPC();
	pNPC->IDSet(iID, szName, crID);				// 초기화.. 및 ID 세팅.
	pNPC->m_InfoBase.eNation = eNation;
	pNPC->m_InfoBase.eRace = RACE_NPC;			// NPC 라는 걸 알린다.
	pNPC->m_InfoBase.iLevel = iLevel;
	pNPC->m_InfoBase.iAuthority = AUTHORITY_NPC;// 권한 NPC는 권한이 없고..
	
	s_pOPMgr->NPCAdd(pNPC);						// 캐릭터 추가...

	// 이제 패킷에 따라 캐릭터를 치장..(?) 시켜준다.. 아이템장착, 무기 장착등...
	CN3Shape* pShape = nullptr;
	__TABLE_PLAYER_LOOKS* pLooks = nullptr;
	if(0 == dwType)
	{
		pLooks = s_pTbl_NPC_Looks.Find(iIDResrc);	// 기본 스킨..
		if(nullptr == pLooks) // 캐릭터 기본 모습 테이블이 없으면... 
		{
			pLooks = s_pTbl_NPC_Looks.GetIndexedData(0);

			std::string szMsg = fmt::format("Normal NPC In : [Name({}), ResourceID({})]",
				szName, iIDResrc);
			MsgOutput(szMsg, 0xffff00ff);
			CLogWriter::Write(szMsg);
		}
	}
	else
	{
		pShape = ACT_WORLD->ShapeGetByIDWithShape(iIDResrc); // Object NPC 에서 찾아 본다...
		if(nullptr == pShape)
		{
			std::string szMsg = fmt::format("Object NPC In : [Name({}), ResourceID({})]",
				szName, iIDResrc);
			MsgOutput(szMsg, 0xffff00ff);
			CLogWriter::Write(szMsg);

			pLooks = s_pTbl_NPC_Looks.GetIndexedData(0);
		}
	}
		
	if(pLooks)
	{
		pNPC->InitChr(pLooks);	// 관절 세팅..
		pNPC->ScaleSet(iScale / 100.0f);

		std::string szPartFN;
		e_PartPosition eParts[6] = { PART_POS_UPPER, PART_POS_LOWER, PART_POS_FACE, PART_POS_HANDS, PART_POS_FEET, PART_POS_HAIR_HELMET };
		for(int i = 0; i < 6; i++)
		{
			pNPC->PartSet(eParts[i], pLooks->szPartFNs[eParts[i]], nullptr, nullptr);
		}

		if(iItemID0)
		{
			__TABLE_ITEM_BASIC* pItem0 = s_pTbl_Items_Basic.Find(iItemID0/1000*1000);
			__TABLE_ITEM_EXT* pItemExt0 = nullptr;
			if(pItem0 && pItem0->byExtIndex >= 0 && pItem0->byExtIndex < MAX_ITEM_EXTENSION)
				pItemExt0 = s_pTbl_Items_Exts[pItem0->byExtIndex].Find(iItemID0%1000);	// 열 데이터 얻기..
			if(pItem0 && pItemExt0)
			{
				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szItemFN;
				MakeResrcFileNameForUPC(pItem0, pItemExt0, &szItemFN, nullptr, ePart, ePlug, s_pPlayer->m_InfoBase.eRace);
				pNPC->PlugSet(PLUG_POS_RIGHTHAND, szItemFN, pItem0, pItemExt0);
			}
			else
			{
				__ASSERT(0, "Invalid Item ID And Extension");
			}
		}

		if(iItemID1)
		{
			__TABLE_ITEM_BASIC* pItem1 = s_pTbl_Items_Basic.Find(iItemID1/1000*1000);
			__TABLE_ITEM_EXT* pItemExt1 = nullptr;
			if(pItem1 && pItem1->byExtIndex >= 0 && pItem1->byExtIndex < MAX_ITEM_EXTENSION)
				pItemExt1 = s_pTbl_Items_Exts[pItem1->byExtIndex].Find(iItemID1%1000);	// 열 데이터 얻기..
			if(pItem1 && pItemExt1)
			{
				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szItemFN;
				MakeResrcFileNameForUPC(pItem1, pItemExt1, &szItemFN, nullptr, ePart, ePlug, s_pPlayer->m_InfoBase.eRace);
				pNPC->PlugSet(PLUG_POS_LEFTHAND, szItemFN, pItem1, pItemExt1);
			}
			else
			{
				__ASSERT(0, "Invalid Item ID And Extension");
			}
		}
	}
	else if(pShape && (pShape->Type() & OBJ_SHAPE_EXTRA))
	{
		CN3ShapeExtra* pSE = (CN3ShapeExtra*)pShape;
		pNPC->m_pShapeExtraRef = pSE; // 참조 오브젝트 세팅..
		pSE->m_bVisible = true; // 강제로 렌더링하지 않게 하는 플래그 해제..
		
		bool bShouldBeRotate = true;
		__Vector3 vAxis(0,1,0);
		float fRadian = 0, fRadian2 = 0;
		bool bVisible = false;

		if(OBJECT_TYPE_DOOR_LEFTRIGHT == pSE->m_iEventType) // 좌우열림 성문
		{
			vAxis.Set(0,1,0);
			fRadian = DegreesToRadians(80);
			fRadian2 = 0;
		} 
		else if(OBJECT_TYPE_DOOR_TOPDOWN == pSE->m_iEventType)
		{
			vAxis.Set(0,0,1);
			fRadian = DegreesToRadians(90);
			fRadian2 = 0;
		} // 상하열림 성문
		else if(OBJECT_TYPE_LEVER_TOPDOWN == pSE->m_iEventType)
		{
			vAxis.Set(1,0,0);
			fRadian = DegreesToRadians(45);
			fRadian2 = DegreesToRadians(-45);
		} // 상하 레버
		else if(OBJECT_TYPE_FLAG == pSE->m_iEventType)
		{
			bShouldBeRotate = false;
		}

		if(0x01 == dwStatus) // 보이게 만들거나 좌우로 열려 있는 경우..
		{
			if(bShouldBeRotate) // 열기
			{
				pSE->RotateTo(0, vAxis, fRadian, 1, true); // 바로 열기.
				pSE->RotateTo(1, vAxis, -fRadian, 1, true); // 바로 열기.
			}
			else // 보이기
			{
				pSE->m_bVisible = true;
			}
		}
		else if(0x00 == dwStatus) // 안보이게 만들거나 닫혀있다..
		{
			if(bShouldBeRotate) // 닫기
			{
				pSE->RotateTo(0, vAxis, fRadian2, 1, true); // 바로 열기.
				pSE->RotateTo(1, vAxis, -fRadian2, 1, true); // 바로 열기.
			}
			else // 안보이기.
			{
				pSE->m_bVisible = false;
			}
		}
	}
	else
	{
		std::string szMsg = fmt::format("No Resource NPC In : [Name({}), ResourceID({})]",
			szName, iIDResrc);
		CLogWriter::Write(szMsg);
	}

	pNPC->PositionSet(__Vector3(fXPos, fYPos, fZPos), true);	// 현재 위치 셋팅..
	pNPC->MoveTo(fXPos, fYPos, fZPos, 0, 0);					// 현재 위치..
	pNPC->RotateTo(DegreesToRadians(rand()%360), false);
	pNPC->Action(PSA_BASIC, true, nullptr, true);
	pNPC->ActionMove(PSM_STOP);

	return true;
}

bool CGameProcMain::MsgRecv_NPCOut(Packet& pkt)
{
	int  iID		= pkt.read<int16_t>(); // Server에서 관리하는 고유 ID
	return s_pOPMgr->NPCDelete(iID);										// 캐릭터 제거...	
}


// 주위 영역의 모든 아이디를 카운트만큼 받는다... 글구.. 업데이트가 필요한 것만 서버에게 요청..
bool CGameProcMain::MsgRecv_NPCInAndRequest(Packet& pkt)
{
	int iNPCCountReceived = pkt.read<int16_t>();
	//TRACE("NPC region update : %d\n", iNPCCountReceived);

	if(0 == iNPCCountReceived) return false;
	if(iNPCCountReceived < 0 || iNPCCountReceived >= 1000)
	{
		std::string szErr = fmt::format("영역정보 요청 오류 - NPC 갯수 {}", iNPCCountReceived);
		CGameProcedure::ReportDebugStringAndSendToServer(szErr);
		__ASSERT(0, szErr.c_str());
		return false;
	}

	int iID = 0;
	m_SetNPCID.clear(); // 싹 지우고...
	it_ID itID, itIDEnd = m_SetNPCID.end();
	pair_ID pairID;

	for ( int i = 0; i < iNPCCountReceived; i++ )
	{
		iID = pkt.read<int16_t>();
		pairID = m_SetNPCID.insert(iID);
		//TRACE("               ID : %d\n", iID);
	}

	if(m_SetNPCID.empty()) // 새로 받은게 한개도 없다면 몽땅 날린다..
	{
		s_pOPMgr->ReleaseNPCs();
		return false;
	}

	// 새로 받은 아이디와 리스트에 있는 NPC ID 를 검색해서..
	CPlayerNPC* pNPC = nullptr;
	it_NPC itNPC = s_pOPMgr->m_NPCs.begin(), itNPCEnd = s_pOPMgr->m_NPCs.end();
	for(; itNPC != itNPCEnd; )
	{
		pNPC = itNPC->second;
		iID = pNPC->IDNumber();
		
		itID = m_SetNPCID.find(iID);
		if(itID != itIDEnd) // 새로 들어온 리스트에 있으면.. 
		{
			m_SetNPCID.erase(itID); // 요청할 리스트에서 빼고..
			itNPC++;
		}
		else  // 새로 들어온곳에 없으면 지운다..
		{
			//TRACE("           delete : %d\n", iID);

			if(pNPC && pNPC->IsDead()) 
			{
				itNPC++;
			}
			else
			{
				delete pNPC; pNPC = nullptr;
				itNPC = s_pOPMgr->m_NPCs.erase(itNPC);
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////
	// 바로 요청 패킷을 만들어 보낸다..
	int iNewNPCCount = static_cast<int>(m_SetNPCID.size());
	if (iNewNPCCount > 0)
	{
		int iOffset = 0;												// 버퍼의 오프셋..
		std::vector<uint8_t> byBuff(iNewNPCCount * 2 + 10, 0);			// 패킷 버퍼..
		CAPISocket::MP_AddByte(&byBuff[0], iOffset, WIZ_REQ_NPCIN);		// 커멘드.
		CAPISocket::MP_AddShort(&byBuff[0], iOffset, iNewNPCCount);		// 아이디 갯수..

		itID = m_SetNPCID.begin(); itIDEnd = m_SetNPCID.end();
		for (int i = 0; itID != itIDEnd; itID++, i++)
		{
			iID = *itID;
			CAPISocket::MP_AddShort(&byBuff[0], iOffset, iID);			// 자세한 정보가 필요한 아이디들..
		}
		s_pSocket->Send(&byBuff[0], iOffset); // 보낸다
	}
	// 바로 요청 패킷을 만들어 보낸다..
	////////////////////////////////////////////////////////////////////////////

	return true;
}

bool CGameProcMain::MsgRecv_NPCInRequested(Packet& pkt)
{
	int iNPCCount = pkt.read<int16_t>();

	if(0 == iNPCCount) return false;
	if(iNPCCount < 0 || iNPCCount >= 1000)
	{
		std::string szErr = fmt::format("영역정보 받기오류 - NPC 갯수 {}", iNPCCount);
		CGameProcedure::ReportDebugStringAndSendToServer(szErr);
		__ASSERT(0, szErr.c_str());
		return false;
	}

#ifdef _DEBUG
	float fTime = CN3Base::TimeGet();
#endif

	for ( int i = 0; i < iNPCCount; i++ )
	{
		this->MsgRecv_NPCIn(pkt); // 플레이어 갯수 만큼 유저 인...
	}
	
#ifdef _DEBUG
	//TRACE("  NPC In Requested (Count:%d) : Avg(%.4f Sec)\n", iNPCCount, (CN3Base::TimeGet() - fTime)/iNPCCount);
#endif

	return true;
}

bool CGameProcMain::MsgRecv_NPCMove(Packet& pkt)
{
	int iID			= pkt.read<int16_t>();
	float fXPos		= (pkt.read<uint16_t>())/10.0f;
	float fZPos		= (pkt.read<uint16_t>())/10.0f;
	float fYPos		= (pkt.read<int16_t>())/10.0f;
	float fSpeed	= (pkt.read<int16_t>())/10.0f;

	// 함수가 와야 할 부분.. ^^
	CPlayerNPC* pNPC = nullptr;
	pNPC = s_pOPMgr->NPCGetByID(iID, true);				// NPC을 ID로서 얻고..
	if ( nullptr == pNPC )
	{
		this->MsgSend_NPCInRequest(iID);
		return false;		// 살아있는 NPC가 있으면..
	}

	float fY = ACT_WORLD->GetHeightWithTerrain(fXPos, fZPos);		// 지형 높이값..
	int iMoveMode = (fSpeed > 0) ? 2 : 0;
	pNPC->MoveTo(fXPos, fY, fZPos, fSpeed, iMoveMode);	// NPC 위치 갱신..

	__ASSERT(!(iMoveMode && fSpeed == 0), "Invalid NPC Move Packet");

	return true;
}

bool CGameProcMain::MsgRecv_Attack(Packet& pkt)
{
	int iType		= pkt.read<uint8_t>(); // 0x01 - 물리적인 공격, 0x02 마법 공격 0x03, 지속 마법 공격
	int iResult		= pkt.read<uint8_t>(); // 0x00 실패, 0x01 성공
	int iIDAttacker = pkt.read<int16_t>(); // 공격한 넘
	int iIDTarget	= pkt.read<int16_t>(); // 타겟이 되서 공격당한넘.

	if ( iIDAttacker == iIDTarget ) return false;		// 공격자와 피해자가 같은 경우????

	bool bIAmTarget = (iIDTarget == s_pPlayer->IDNumber()) ? true : false;
	bool bIAmAttacker = (iIDAttacker == s_pPlayer->IDNumber()) ? true : false;
	
	CPlayerBase* pAttacker = nullptr;
	if ( bIAmAttacker ) pAttacker = s_pPlayer;	// 공격하는 넘이 내 자신이면
	else pAttacker = s_pOPMgr->CharacterGetByID(iIDAttacker, true);
	if(nullptr == pAttacker) // 어라 공격하는 넘이 없네??
	{
		if(iIDAttacker > 10000) // NPC 는 1000 이상이다.
			this->MsgSend_NPCInRequest(iIDAttacker); // NPC 정보가 없을 경우 요청한다..
		else if(iIDAttacker < 3000)
			this->MsgSend_UserInRequest(iIDAttacker); // NPC 정보가 없을 경우 요청한다..
		return false; // 공격하는 넘이 없으면 돌아간다.
	}

	CPlayerBase* pTarget = nullptr;
	if(bIAmTarget) // 타겟이 나라면..
	{
		this->CommandSitDown(false, false); // 일으켜 세운다.
		if(m_pMagicSkillMng->IsCasting())
		{
			__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(s_pPlayer->m_dwMagicID);
			if(pSkill)
			{
				int SuccessValue = rand()%100;
				if(SuccessValue >= pSkill->iPercentSuccess) // 스킬 테이블에 있는 확률대로 실패한다..
					s_pPlayer->Action(PSA_BASIC, false, nullptr, true); // 캐스팅 취소, 기본동작으로 강제 세팅..
			}
		}
		pTarget = s_pPlayer;
	}
	else // 타겟이 다른넘이면..
	{
		pTarget = s_pOPMgr->CharacterGetByID(iIDTarget, true); //  일단 살아있는 넘들중에서 가져와보고.. 
		if(nullptr == pTarget) pTarget = s_pOPMgr->CharacterGetByID(iIDTarget, false); // 없다면 죽어가는 넘도 상관없이 타겟으로 잡고
	}

	if(nullptr == pTarget) return false; // 타겟이 없다!!!!

//	pTarget->m_iIDTargetMe = iIDAttacker; // 어떤 놈이 공격하는 거야??

	if(pAttacker != s_pPlayer && pAttacker && pAttacker->IsAlive()) // 공격하는 넘이 내가 아니고 다른 살아있는 넘일때..
	{
		((CPlayerNPC*)pAttacker)->RotateTo(pTarget); // 타겟을 향해서 방향 계산
		pAttacker->m_iIDTarget = iIDTarget; // 타겟 ID 설정..
		if(0x01 == iType) pAttacker->Action(PSA_ATTACK, false, pTarget); // 물리적인 직접 공격..
		else if(0x02 == iType) pAttacker->Action(PSA_SPELLMAGIC, false, pTarget); // 마법 공격..
//		else if(0x03 == iType) pAttacker->Action(PSA_SPELLMAGIC, false, pTarget); // 지속 마법 공격..
	}

	if (bIAmTarget
		|| bIAmAttacker)
	{
		if (s_pPlayer != nullptr)
		{
			m_bIsExitCanceled = TRUE;
			m_fExitTimer = 0.0f;
			if (m_eExitType != EXIT_TYPE_NONE)
			{
				m_eExitType = EXIT_TYPE_NONE;
				m_iExitTimeRemaining = EXIT_TIME_AFTER_BATTLE;

				std::string szMsg = fmt::format_text_resource(IDS_EXITING_GAME_CANCELED);
				if (m_pUIChatDlg != nullptr)
					m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
			}
		}
	}

	pTarget->m_bGuardSuccess = false; // 방어에 성공했는지에 대한 플래그..
	if(0x0 == iResult) // 공격 실패
	{
		// 죽은 넘이 아니고 스킬을 쓰즌 중이 아니면 막는 동작을 한다..
		if (pTarget->IsAlive()
			&& pTarget->State() == PSA_SPELLMAGIC)
		{
			pTarget->m_bGuardSuccess = true;
			pTarget->Action(PSA_GUARD, false);
		}

		if(pAttacker == s_pPlayer) 
		{
			std::string szMsg = fmt::format_text_resource(IDS_MSG_FMT_TARGET_ATTACK_FAILED,
				pTarget->IDString());
			MsgOutput(szMsg, 0xffffffff);
		}
	}
	else if(0x2 == iResult) // Attack And Dead 
	{
		if(pTarget == s_pPlayer)
		{
//			if(m_pUIDead) m_pUIDead->SetVisible(true);
			std::string szMsg = fmt::format_text_resource(IDS_REGENERATION);
			MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_REGENERATION); // 다시 생성 메시지 보냄..
		}
		
		pTarget->m_fTimeAfterDeath = 0.1f; // 죽기직전..
		if(pTarget->m_pShapeExtraRef) s_pOPMgr->CharacterDelete(pTarget->IDNumber()); // 오브젝트 일때는 없애버린다..!!
	}

	if(pTarget == s_pPlayer) 
	{
		//TRACE("player is under of attack (%d)\n", iIDAttacker);
	}

	return true;
}

bool CGameProcMain::MsgRecv_Dead(Packet& pkt)
{
	int iIDTarget	= pkt.read<int16_t>(); // 타겟이 되서 공격당한넘.

	
	CPlayerBase* pTarget = nullptr;
	if(iIDTarget == s_pPlayer->IDNumber())
	{
		pTarget = s_pPlayer;

//		if(m_pUIDead) m_pUIDead->SetVisible(true);

		std::string szMsg = fmt::format_text_resource(IDS_REGENERATION);
		MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_REGENERATION);
		CLogWriter::Write("Dead!!!");
	}
	else
	{
		pTarget = this->CharacterGetByID(iIDTarget, false);
	}

	if(pTarget)
	{
		if(pTarget->m_pShapeExtraRef) s_pOPMgr->CharacterDelete(pTarget->IDNumber());
		else
		{
			pTarget->m_fTimeAfterDeath = 0.1f; // 죽기직전..
			pTarget->ActionDying(PSD_KEEP_POSITION, __Vector3(0,0,1));
		}

		return true;
	}

	return false;
}

bool CGameProcMain::MsgRecv_ItemMove(Packet& pkt)
{
	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);
	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);

	uint8_t bResult =		pkt.read<uint8_t>();	// 0x01 : true, 0x00 : false..
	if (bResult)
	{
		pInfoExt->iAttack = pkt.read<int16_t>();
		pInfoExt->iGuard =	pkt.read<int16_t>();
		pInfoExt->iWeightMax = pkt.read<int16_t>();
		
		pInfoBase->iHPMax = pkt.read<int16_t>();
		pInfoExt->iMSPMax = pkt.read<int16_t>();
		
		// 아이템에 의해 가감된값이다..
		pInfoExt->iStrength_Delta =		pkt.read<uint16_t>();
		pInfoExt->iStamina_Delta	=	pkt.read<uint16_t>();
		pInfoExt->iDexterity_Delta =	pkt.read<uint16_t>();
		pInfoExt->iIntelligence_Delta =	pkt.read<uint16_t>();
		pInfoExt->iMagicAttak_Delta =	pkt.read<uint16_t>();

		pInfoExt->iRegistFire =		pkt.read<uint16_t>();
		pInfoExt->iRegistCold =		pkt.read<uint16_t>();
		pInfoExt->iRegistLight =	pkt.read<uint16_t>();
		pInfoExt->iRegistMagic =	pkt.read<uint16_t>();
		pInfoExt->iRegistCurse =	pkt.read<uint16_t>();
		pInfoExt->iRegistPoison	=	pkt.read<uint16_t>();

		if(pInfoBase->iHP > pInfoBase->iHPMax) pInfoBase->iHP = pInfoBase->iHPMax; // 범위검사..
		if(pInfoExt->iMSP > pInfoExt->iMSPMax) pInfoExt->iMSP = pInfoExt->iMSPMax; // 범위검사..

		m_pUIVar->m_pPageState->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax);
		m_pUIVar->m_pPageState->UpdateMSP(pInfoExt->iMSP, pInfoExt->iMSPMax);

		m_pUIStateBarAndMiniMap->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax, false);
		m_pUIStateBarAndMiniMap->UpdateMSP(pInfoExt->iMSP, pInfoExt->iMSPMax, false);
		
		m_pUIVar->m_pPageState->UpdateAttackPoint(pInfoExt->iAttack, pInfoExt->iAttack_Delta);
		m_pUIVar->m_pPageState->UpdateGuardPoint(pInfoExt->iGuard, pInfoExt->iGuard_Delta);
		m_pUIVar->m_pPageState->UpdateWeight(pInfoExt->iWeight, pInfoExt->iWeightMax);
		
		m_pUIVar->m_pPageState->UpdateStrength(pInfoExt->iStrength, pInfoExt->iStrength_Delta);
		m_pUIVar->m_pPageState->UpdateStamina(pInfoExt->iStamina, pInfoExt->iStamina_Delta);
		m_pUIVar->m_pPageState->UpdateDexterity(pInfoExt->iDexterity, pInfoExt->iDexterity_Delta);
		m_pUIVar->m_pPageState->UpdateIntelligence(pInfoExt->iIntelligence, pInfoExt->iIntelligence_Delta);
		m_pUIVar->m_pPageState->UpdateMagicAttak(pInfoExt->iMagicAttak, pInfoExt->iMagicAttak_Delta);

		m_pUIVar->m_pPageState->UpdateRegistFire(pInfoExt->iRegistFire, pInfoExt->iRegistFire_Delta);
		m_pUIVar->m_pPageState->UpdateRegistCold(pInfoExt->iRegistCold, pInfoExt->iRegistCold_Delta);
		m_pUIVar->m_pPageState->UpdateRegistLight(pInfoExt->iRegistLight, pInfoExt->iRegistLight_Delta);
		m_pUIVar->m_pPageState->UpdateRegistMagic(pInfoExt->iRegistMagic, pInfoExt->iRegistMagic_Delta);
		m_pUIVar->m_pPageState->UpdateRegistCurse(pInfoExt->iRegistCurse, pInfoExt->iRegistCurse_Delta);
		m_pUIVar->m_pPageState->UpdateRegistPoison(pInfoExt->iRegistPoison, pInfoExt->iRegistPoison_Delta);
	}

	m_pUIInventory->ReceiveResultFromServer(bResult);
	//TRACE("Init Inv Move Res %d \n", (int)bResult);

	return true;
}

bool CGameProcMain::MsgRecv_ItemWeightChange(Packet& pkt)		// 아이템 무게 변화..
{
	__InfoPlayerMySelf* pInfoExt = &s_pPlayer->m_InfoExt;
	pInfoExt->iWeight = pkt.read<int16_t>();
	m_pUIVar->m_pPageState->UpdateWeight(pInfoExt->iWeight, pInfoExt->iWeightMax);

	return true;
}

bool CGameProcMain::MsgRecv_UserLookChange(Packet& pkt)
{
	int iID				= pkt.read<int16_t>();
	e_ItemSlot eSlot	= (e_ItemSlot)pkt.read<uint8_t>();
	uint32_t dwItemID = pkt.read<uint32_t>();
	int iDurability = pkt.read<int16_t>();

	if(iID == s_pPlayer->IDNumber()) return false;
	
	CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(iID, false);
	if(nullptr == pUPC) return false;

	__TABLE_ITEM_BASIC* pItem = s_pTbl_Items_Basic.Find(dwItemID/1000*1000);

	__TABLE_ITEM_EXT* pItemExt = nullptr;
	if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(dwItemID%1000);	// 열 데이터 얻기..
	if(dwItemID && (nullptr == pItem || nullptr == pItemExt))
	{
		__ASSERT(0, "NULL Item!!!");
		return false;
	}

	e_PartPosition ePartPos = PART_POS_UNKNOWN, ePartPos2 = PART_POS_UNKNOWN;
	e_PlugPosition ePlugPos = PLUG_POS_UNKNOWN, ePlugPos2 = PLUG_POS_UNKNOWN;

	if(ITEM_SLOT_HEAD == eSlot) ePartPos = PART_POS_HAIR_HELMET;
	else if(ITEM_SLOT_UPPER == eSlot) ePartPos = PART_POS_UPPER;
	else if(ITEM_SLOT_LOWER == eSlot) ePartPos = PART_POS_LOWER;
	else if(ITEM_SLOT_GLOVES == eSlot) ePartPos = PART_POS_HANDS;
	else if(ITEM_SLOT_SHOES == eSlot) ePartPos = PART_POS_FEET;
	else if(ITEM_SLOT_HAND_RIGHT == eSlot) ePlugPos = PLUG_POS_RIGHTHAND;
	else if(ITEM_SLOT_HAND_LEFT == eSlot) ePlugPos = PLUG_POS_LEFTHAND;

	if(ePartPos != PART_POS_UNKNOWN) 
	{
		if(dwItemID) // 아이템이 있는 경우
		{
			std::string szItemFN;
			MakeResrcFileNameForUPC(pItem, pItemExt, &szItemFN, nullptr, ePartPos2, ePlugPos2, s_pPlayer->m_InfoBase.eRace);
			pUPC->PartSet(ePartPos, szItemFN, pItem, pItemExt); // 아이템 붙이기..
			pUPC->DurabilitySet(eSlot, iDurability);
		}
		else
		{
			__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(pUPC->m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..
			if(nullptr == pLooks)
			{
				CLogWriter::Write("CGameProcMain::MsgRecv_UserLookChange() - failed find table : Race ({})",
					static_cast<int>(pUPC->m_InfoBase.eRace));
				__ASSERT(pLooks, "failed find table");
			}
			else
			{
				if(PART_POS_HAIR_HELMET == ePartPos) pUPC->InitHair(); // 머리인데 없는 경우는..
				else pUPC->PartSet(ePartPos, pLooks->szPartFNs[ePartPos], nullptr, nullptr);
			}
		}

		return true;
	}
	else if(ePlugPos != PLUG_POS_UNKNOWN)
	{
		if(dwItemID)
		{
			std::string szItemFN;
			MakeResrcFileNameForUPC(pItem, pItemExt, &szItemFN, nullptr, ePartPos2, ePlugPos2, s_pPlayer->m_InfoBase.eRace);
			pUPC->PlugSet(ePlugPos, szItemFN, pItem, pItemExt);
			pUPC->DurabilitySet(eSlot, iDurability);
		}
		else
		{
			pUPC->PlugSet(ePlugPos, "", nullptr, nullptr);
			pUPC->DurabilitySet(eSlot, 0);
		}

		// Sound Range 안쪽이면 사운드를 바꾸어준다..
		__Vector3 vPosPlayer = s_pPlayer->Position();
		float fDist = pUPC->Distance(vPosPlayer);
		if(fDist < SOUND_RANGE_TO_SET) pUPC->SetSoundPlug(pItem); // SOUND_RANGE 안에 있으면.

		return true;
	}
	else
	{
		CLogWriter::Write("CGameProcMain::MsgRecv_UserLookChange() - Unknown Slot({}) Item({})",
			static_cast<int>(eSlot), dwItemID);
		return false;
	}

	return false;
}

bool CGameProcMain::MsgRecv_ItemBundleDrop(Packet& pkt)		// Item 이 필드에 나타나는데에 대한 응답
{
	int iID = pkt.read<int16_t>();
	int iItemID = pkt.read<uint32_t>();

	CPlayerBase* pCorpse = s_pOPMgr->NPCGetByID(iID, false);
	if(nullptr == pCorpse) pCorpse = s_pOPMgr->CorpseGetByID(iID);
	
	if(pCorpse)
		pCorpse->m_iDroppedItemID = iItemID; // 떨어트린 아이템 아이디 뭉치

	return true;
}

bool CGameProcMain::MsgRecv_ItemBundleOpen(Packet& pkt)		// 아이템 상자를 열거나 시체를 뒤진다..
{
	uint32_t dwItemID = 0;
	int iItemCount = 0;

	POINT ptCur = s_pLocalInput->MouseGetPos();
	m_pUIDroppedItemDlg->EnterDroppedState(ptCur.x, ptCur.y);
	//TRACE ("아이템 리스트 도착.. \n");

	for(int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		dwItemID = pkt.read<uint32_t>();
		iItemCount = pkt.read<int16_t>();

		// 이부분에 몬스터 아이템창을 열고 준비한다..
		if ( dwItemID )
			m_pUIDroppedItemDlg->AddToItemTable(dwItemID, iItemCount, i);
	}

	m_pUIDroppedItemDlg->InitIconUpdate();

	return true;
}

void CGameProcMain::MsgRecv_ItemRepair(Packet& pkt)			// Item Repair Result.. 
{
	int iResult = pkt.read<uint8_t>();		// Trade id
	int iGold   = pkt.read<uint32_t>();		// Trade id
	m_pUIInventory->ReceiveResultFromServer( iResult, iGold );
}

void CGameProcMain::MsgRecv_ItemCountChange(Packet& pkt)		// Item Count Change..
{
	int iTotalCount = pkt.read<int16_t>();		// Trade id

	for( int i = 0; i < iTotalCount; i++ )
	{
		int iDistrict	= pkt.read<uint8_t>();
		int iIndex		= pkt.read<uint8_t>();
		int iID			= pkt.read<uint32_t>();
		int	iCount		= pkt.read<uint32_t>();
		int iNewItem	= pkt.read<uint8_t>(); // 100 for new items, 0 otherwise
		int iDurability = pkt.read<uint16_t>();

		m_pUIInventory->ItemCountChange(iDistrict, iIndex, iCount, iID, iDurability);

		if (iNewItem == 100)
		{
			__TABLE_ITEM_BASIC* pItem = CGameProcedure::s_pTbl_Items_Basic.Find(iID / 1000 * 1000);
			if (pItem != nullptr)
			{
				std::string szMsg = fmt::format_text_resource(IDS_ITEM_RECEIVED,
					pItem->szName);
				MsgOutput(szMsg, 0xFFFFFF00);
			}
		}
	}	

	if (m_pUISkillTreeDlg) m_pUISkillTreeDlg->UpdateDisableCheck();
	if (m_pUIHotKeyDlg) m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CGameProcMain::MsgRecv_ItemDestroy(Packet& pkt)			// Item Count Change..
{
	int	iResult		= pkt.read<uint8_t>();		// Trade id
	m_pUIInventory->ReceiveResultItemRemoveFromServer(iResult);
};

void CGameProcMain::MsgRecv_MyInfo_HP(Packet& pkt)
{
	int iHPMax =	pkt.read<int16_t>();	
	int iHP =		pkt.read<int16_t>();	

	int iHPChange = iHP - s_pPlayer->m_InfoBase.iHP;
	std::string szMsg;

	if (iHPChange < 0)
	{
		szMsg = fmt::format_text_resource(IDS_MSG_FMT_HP_LOST, -iHPChange);
		MsgOutput(szMsg, 0xffff3b3b);
	}
	else if (iHPChange > 0)
	{
		szMsg = fmt::format_text_resource(IDS_MSG_FMT_HP_RECOVER, iHPChange);
		MsgOutput(szMsg, 0xff6565ff);
	}

	s_pPlayer->m_InfoBase.iHPMax = iHPMax;
	s_pPlayer->m_InfoBase.iHP = iHP;

	m_pUIVar->m_pPageState->UpdateHP(iHP, iHPMax);
	m_pUIStateBarAndMiniMap->UpdateHP(iHP, iHPMax, false);
}

void CGameProcMain::MsgRecv_MyInfo_MSP(Packet& pkt)
{
	int iMSPMax = pkt.read<int16_t>();	
	int iMSP = pkt.read<int16_t>();
	
	int iMSPChange = iMSP - s_pPlayer->m_InfoExt.iMSP;
	
	e_Class_Represent eCR = GetRepresentClass(s_pPlayer->m_InfoBase.eClass);

	bool bUseMP = true;
	if (CLASS_REPRESENT_WARRIOR == eCR
		|| CLASS_REPRESENT_ROGUE == eCR)
		bUseMP = false;

	std::string szMsg;
	if (iMSPChange < 0)
	{
		if (bUseMP)
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_MP_USE, -iMSPChange);
		else
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_SP_USE, -iMSPChange);

		MsgOutput(szMsg, 0xffff3b3b);
	}
	else if (iMSPChange > 0)
	{
		if (bUseMP)
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_MP_RECOVER, iMSPChange);
		else
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_SP_RECOVER, iMSPChange);

		MsgOutput(szMsg, 0xff6565ff);
	}

	s_pPlayer->m_InfoExt.iMSPMax = iMSPMax;
	s_pPlayer->m_InfoExt.iMSP = iMSP;

	m_pUIVar->m_pPageState->UpdateMSP(iMSP, iMSPMax);
	m_pUIStateBarAndMiniMap->UpdateMSP(iMSP, iMSPMax, false);

	if (m_pUISkillTreeDlg) m_pUISkillTreeDlg->UpdateDisableCheck();
	if (m_pUIHotKeyDlg) m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CGameProcMain::MsgRecv_MyInfo_EXP(Packet& pkt)
{
	uint64_t iExp = pkt.read<uint32_t>();
	uint64_t iOldExp = s_pPlayer->m_InfoExt.iExp;

	s_pPlayer->m_InfoExt.iExp = iExp;
	m_pUIVar->m_pPageState->UpdateExp(iExp, s_pPlayer->m_InfoExt.iExpNext);
	m_pUIStateBarAndMiniMap->UpdateExp(iExp, s_pPlayer->m_InfoExt.iExpNext, false);

	if(s_pPlayer->m_InfoExt.iLevelPrev == s_pPlayer->m_InfoBase.iLevel
		&& iExp != iOldExp)
	{
		std::string szMsg;
		if (iExp > iOldExp)
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_EXP_GET, iExp - iOldExp);
		else if (iExp < iOldExp)
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_EXP_LOST, iOldExp - iExp);

		MsgOutput(szMsg, 0xffffff00);
	}

	s_pPlayer->m_InfoExt.iLevelPrev = s_pPlayer->m_InfoBase.iLevel;
}

bool CGameProcMain::MsgRecv_MyInfo_LevelChange(Packet& pkt)
{
	int iID = pkt.read<int16_t>();
	int iLevel = pkt.read<uint8_t>();
	if(iID == s_pPlayer->IDNumber())
	{
		__InfoPlayerBase*	pInfoBase = &(s_pPlayer->m_InfoBase);
		__InfoPlayerMySelf*	pInfoExt = &(s_pPlayer->m_InfoExt);
		
		int iLevelPrev = pInfoBase->iLevel;
		pInfoBase->iLevel = iLevel;
		pInfoExt->iBonusPointRemain = pkt.read<uint8_t>(); // 남은 보너스 포인트..

		uint8_t	bExtraSkillPoint		= pkt.read<uint8_t>();	// 토탈 포인트
		//TRACE("Skill change Extra value %d\n", bExtraSkillPoint);
			
		pInfoExt->iExpNext		= pkt.read<int32_t>();
		pInfoExt->iExp			= pkt.read<int32_t>(); 

		pInfoBase->iHPMax		= pkt.read<int16_t>();	
		pInfoBase->iHP			= pkt.read<int16_t>();

		pInfoExt->iMSPMax		= pkt.read<int16_t>();
		pInfoExt->iMSP			= pkt.read<int16_t>();

		pInfoExt->iWeightMax	= pkt.read<int16_t>();
		pInfoExt->iWeight		= pkt.read<int16_t>();

		m_pUIVar->UpdateAllStates(&(s_pPlayer->m_InfoBase), &(s_pPlayer->m_InfoExt)); // 모든 정보 업데이트..

		m_pUIStateBarAndMiniMap->UpdateExp(pInfoExt->iExp, pInfoExt->iExpNext, true);
		m_pUIStateBarAndMiniMap->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax, false);
		m_pUIStateBarAndMiniMap->UpdateMSP(pInfoExt->iMSP, pInfoExt->iMSPMax, false);

		m_pUISkillTreeDlg->m_iSkillInfo[0] = bExtraSkillPoint;
		m_pUISkillTreeDlg->InitIconUpdate();		// 레벨이 변화되었으므로 .. 스킬도 추가될 수 있다..

		if(iLevel > iLevelPrev) // 이곳에 Level Up 효과를 넣어준다..
		{
			if(s_pPlayer->Nation()==NATION_KARUS) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_LEVELUP_KARUS, iID, -1);
			else if(s_pPlayer->Nation()==NATION_ELMORAD) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_LEVELUP_ELMORAD, iID, -1);
		}
	}
	else // 다른 넘이다..
	{
		CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(iID, false);
		if(pUPC)
		{
			if(iLevel > pUPC->m_InfoBase.iLevel)
			{
				if(pUPC->Nation()==NATION_KARUS) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_LEVELUP_KARUS, iID, -1);
				else if(pUPC->Nation()==NATION_ELMORAD) CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_LEVELUP_ELMORAD, iID, -1);
			}
			pUPC->m_InfoBase.iLevel = iLevel;
		}
	}

	return TRUE;
}

void CGameProcMain::MsgRecv_MyInfo_RealmPoint(Packet& pkt)
{
	uint8_t opcode = pkt.read<uint8_t>();
	if (opcode == 1) // TODO: @Demircivi: LOYALTY_NATIONAL_POINTS is: 1, define it in header. 
	{
		// TODO: @Demircivi, implement missing

		uint32_t iLoyalty = pkt.read<uint32_t>();
		uint32_t iLoyaltyMonthly = pkt.read<uint32_t>();
		uint32_t iUnk = pkt.read<uint32_t>();				// Clan donations(? Donations made by this user? For the clan overall?)
		uint32_t iClanLoyaltyAmount = pkt.read<uint32_t>();	// Premium NP(? Additional NP gained?)

		int32_t iLoyaltyDelta = iLoyalty - s_pPlayer->m_InfoExt.iRealmPoint;

		// Gained NP
		std::string szMsg;
		if (iLoyaltyDelta > 0)
		{
			szMsg = fmt::format_text_resource(IDS_LOYALTY_CHANGE_GET, iLoyaltyDelta);
			MsgOutput(szMsg, 0xffa2a0c8);
		}
		// Lost NP
		else
		{
			szMsg = fmt::format_text_resource(IDS_LOYALTY_CHANGE_LOST, -iLoyaltyDelta);
			MsgOutput(szMsg, 0xffff3b3b);
		}

		s_pPlayer->m_InfoExt.iRealmPoint = iLoyalty;
		s_pPlayer->m_InfoExt.iRealmPointMonthly = iLoyaltyMonthly;

		if (m_pUIVar->m_pPageState)
			m_pUIVar->m_pPageState->UpdateRealmPoint(s_pPlayer->m_InfoExt.iRealmPoint, s_pPlayer->m_InfoExt.iRealmPointMonthly); // 국가 기여도는 10을 나누어서 표시
	}
	else if (opcode == 2)
	{
		// TODO: @Demircivi, after implementing Manner feature call its update method from here.
		uint32_t iNewManner = pkt.read<uint32_t>(); // IDS_MANNER_CHANGE_GET / IDS_MANNER_CHANGE_LOST
		CLogWriter::Write("Got manner update packet but didn't update UI since there is no manner feature. New Manner: {}.",
			iNewManner);
	}
	else
	{
		CLogWriter::Write("Unhandled MsgRecv_MyInfo_RealmPoint subOpcode: 0x{:02X}.", opcode);
	}
}

void CGameProcMain::MsgRecv_MyInfo_PointChange(Packet& pkt)
{
	int iType = pkt.read<uint8_t>();
	int iVal = pkt.read<int16_t>();

	s_pPlayer->m_InfoBase.iHPMax =		pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iMSPMax =		pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iAttack =		pkt.read<int16_t>();
	s_pPlayer->m_InfoExt.iWeightMax =	static_cast<int>(pkt.read<uint16_t>());

	m_pUIVar->m_pPageState->UpdateHP(s_pPlayer->m_InfoBase.iHP, s_pPlayer->m_InfoBase.iHPMax);
	m_pUIStateBarAndMiniMap->UpdateHP(s_pPlayer->m_InfoBase.iHP, s_pPlayer->m_InfoBase.iHPMax, false);
	
	m_pUIVar->m_pPageState->UpdateMSP(s_pPlayer->m_InfoExt.iMSP, s_pPlayer->m_InfoExt.iMSPMax);
	m_pUIStateBarAndMiniMap->UpdateMSP(s_pPlayer->m_InfoExt.iMSP, s_pPlayer->m_InfoExt.iMSPMax, false);

	m_pUIVar->m_pPageState->UpdateAttackPoint(s_pPlayer->m_InfoExt.iAttack, s_pPlayer->m_InfoExt.iAttack_Delta);
	m_pUIVar->m_pPageState->UpdateWeight(s_pPlayer->m_InfoExt.iWeight, s_pPlayer->m_InfoExt.iWeightMax);


// 포인트 체인지 -	 보낼때 b1(1힘 2체력 3민첩 4지능 5마력) s(-1 +1)
//					 받을때 b1(1힘 2체력 3민첩 4지능 5마력) s(절대수치)

	if(0x01 == iType) // Strength
	{
		s_pPlayer->m_InfoExt.iStrength = iVal;
		m_pUIVar->m_pPageState->UpdateStrength(s_pPlayer->m_InfoExt.iStrength, s_pPlayer->m_InfoExt.iStrength_Delta);
	}
	else if(0x02 == iType) // Stamina
	{
		s_pPlayer->m_InfoExt.iStamina = iVal;
		m_pUIVar->m_pPageState->UpdateStamina(s_pPlayer->m_InfoExt.iStamina, s_pPlayer->m_InfoExt.iStamina_Delta);
	}
	else if(0x03 == iType) // Dex
	{
		s_pPlayer->m_InfoExt.iDexterity = iVal;
		m_pUIVar->m_pPageState->UpdateDexterity(s_pPlayer->m_InfoExt.iDexterity, s_pPlayer->m_InfoExt.iDexterity_Delta);
	}
	else if(0x04 == iType) // Intelligence
	{
		s_pPlayer->m_InfoExt.iIntelligence = iVal;
		m_pUIVar->m_pPageState->UpdateIntelligence(s_pPlayer->m_InfoExt.iIntelligence, s_pPlayer->m_InfoExt.iIntelligence_Delta);
	}
	else if(0x05 == iType) // Magic Attack
	{
		s_pPlayer->m_InfoExt.iMagicAttak = iVal;
		m_pUIVar->m_pPageState->UpdateMagicAttak(s_pPlayer->m_InfoExt.iMagicAttak, s_pPlayer->m_InfoExt.iMagicAttak_Delta);
	}

	if(iType >= 1 && iType <= 5)
	{
		s_pPlayer->m_InfoExt.iBonusPointRemain--;
		m_pUIVar->m_pPageState->UpdateBonusPointAndButtons(s_pPlayer->m_InfoExt.iBonusPointRemain); // 보너스 포인트 적용이 가능한가??
	}
}

void CGameProcMain::InitUI()
{
	const int iW = CN3Base::s_CameraData.vp.Width;
	const int iH = CN3Base::s_CameraData.vp.Height;

	RECT rc;
	int iX = 0, iY = 0;

	e_Nation eNation = s_pPlayer->m_InfoBase.eNation; // 국가....

	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(eNation);
	if(nullptr == pTbl) return;
	
	m_pUICmd->Init(s_pUIMgr);
	m_pUICmd->LoadFromFile(pTbl->szCmd);
	rc = m_pUICmd->GetRegion();
	m_pUICmd->SetPos((iW - (rc.right - rc.left))/2, iH - (rc.bottom - rc.top));
	m_pUICmd->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);

	m_pUIChatDlg->Init(s_pUIMgr);					//Manager 자식으로 리스트에 추가 
	m_pUIChatDlg->LoadFromFile(pTbl->szChat);
	rc = m_pUIChatDlg->GetRegion();
	RECT rcCmd = m_pUICmd->GetRegion(); rcCmd.top += 5; // .. 하드 코딩..
	iX = 0;
	iY = iH - ((rc.bottom - rc.top) + (rcCmd.bottom - rcCmd.top));
	UIPostData_Read(UI_POST_WND_CHAT, m_pUIChatDlg, iX, iY);
	m_pUIChatDlg->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
	m_pUIChatDlg->SetVisibleWithNoSound(true);

	m_pUIChatDlg2->Init(s_pUIMgr);
	m_pUIChatDlg2->LoadFromFile(pTbl->szChat2);
	m_pUIChatDlg2->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
	m_pUIChatDlg2->SetVisibleWithNoSound(false);

	m_pUIMsgDlg->Init(s_pUIMgr);
	m_pUIMsgDlg->LoadFromFile(pTbl->szMsgOutput);
	UIPostData_Read(UI_POST_WND_INFO, m_pUIMsgDlg, rc.right, rc.top);
	m_pUIMsgDlg->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
	m_pUIMsgDlg->SetVisibleWithNoSound(true);

	m_pUIMsgDlg2->Init(s_pUIMgr);
	m_pUIMsgDlg2->LoadFromFile(pTbl->szMsgOutput2);
	m_pUIMsgDlg2->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
	m_pUIMsgDlg2->SetVisibleWithNoSound(false);

	// Default info box next to chat
	RECT rcChat = m_pUIChatDlg->GetRegion();
	m_pUIMsgDlg->SetPos(rcChat.right, rcChat.top);

	// 채팅창과 메시지 창 위치 맞추기..
	m_pUIChatDlg->MoveOffset(0, -1);
	m_pUIMsgDlg->MoveOffset(0, -1);

	m_pUIStateBarAndMiniMap->Init(s_pUIMgr);
	m_pUIStateBarAndMiniMap->LoadFromFile(pTbl->szStateBar);
	m_pUIStateBarAndMiniMap->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
#ifdef _DEBUG
	m_pUIStateBarAndMiniMap->SetPos(0, 70); // 디버그 정보 표시때문에 조금 내린다....
#else
	m_pUIStateBarAndMiniMap->SetPos(0, 0);
#endif

	// 다용도 UI - 상태, 기사단관리, 퀘스트, 친구 관리등...
	m_pUIVar->Init(s_pUIMgr);
	m_pUIVar->LoadFromFile(pTbl->szVarious);
	m_pUIVar->SetVisibleWithNoSound(false);
	m_pUIVar->m_pPageState->LoadFromFile(pTbl->szState);
	m_pUIVar->m_pPageState->SetVisibleWithNoSound(true);
	m_pUIVar->m_pPageKnights->LoadFromFile(pTbl->szKnights);
	m_pUIVar->m_pPageKnights->SetVisibleWithNoSound(false);
	m_pUIVar->m_pPageFriends->LoadFromFile(pTbl->szFriends);
	m_pUIVar->m_pPageFriends->SetVisibleWithNoSound(false);
	m_pUIVar->SetStyle(m_pUIVar->GetStyle() | UISTYLE_POS_LEFT);

	// TODO(srmeier): need to implement this
	m_pUIVar->m_pPageQuest->LoadFromFile(pTbl->szQuest);
	m_pUIVar->m_pPageQuest->SetVisibleWithNoSound(false);


	
	m_pUITargetBar->Init(s_pUIMgr);
	m_pUITargetBar->LoadFromFile(pTbl->szTargetBar);
	m_pUITargetBar->SetStyle(UISTYLE_FOCUS_UNABLE | UISTYLE_HIDE_UNABLE);
	rc = m_pUITargetBar->GetRegion();
	m_pUITargetBar->SetPos((iW - (rc.right - rc.left))/2, 0);
	m_pUITargetBar->SetVisibleWithNoSound(false);

	m_pUIExitMenu->Init(s_pUIMgr);
	m_pUIExitMenu->LoadFromFile(pTbl->szExitMenu);
	m_pUIExitMenu->SetVisibleWithNoSound(false);
	rc = m_pUIExitMenu->GetRegion();
	m_pUIExitMenu->SetPos((iW - (rc.right - rc.left)) / 2, (iH - (rc.bottom - rc.top)) / 2);
	m_pUIExitMenu->SetState(UI_STATE_COMMON_NONE);
	m_pUIExitMenu->SetStyle(m_pUIExitMenu->GetStyle() | UISTYLE_SHOW_ME_ALONE);

	m_pUIHelp->Init(s_pUIMgr);
	m_pUIHelp->LoadFromFile(pTbl->szHelp);
	UIPostData_Read(UI_POST_WND_HELP, m_pUIHelp, 0, 0);
	rc = m_pUIHelp->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIHelp->SetPos(iX, iY);
//	m_pUIHelp->SetStyle(UISTYLE_SHOW_ME_ALONE);
	
	// 공지사항..
	m_pUINotice->Init(s_pUIMgr);
	m_pUINotice->LoadFromFile(pTbl->szNotice);
	m_pUINotice->SetVisibleWithNoSound(false);

	m_pUIClassChange->Init(s_pUIMgr);
	m_pUIClassChange->LoadFromFile(pTbl->szClassChange);
	m_pUIClassChange->SetVisibleWithNoSound(false);
	rc = m_pUIClassChange->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIClassChange->SetPos(iX, iY);
	m_pUIClassChange->SetStyle(UISTYLE_USER_MOVE_HIDE);

	m_pUINpcChange->Init(s_pUIMgr);
	m_pUINpcChange->LoadFromFile(pTbl->szChangeClassInit);
	m_pUINpcChange->SetVisibleWithNoSound(false);
	rc = m_pUINpcChange->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUINpcChange->SetPos(iX, iY);
	m_pUINpcChange->SetStyle(UISTYLE_SHOW_ME_ALONE | UISTYLE_USER_MOVE_HIDE);

	m_pUINpcEvent->Init(s_pUIMgr);
	m_pUINpcEvent->LoadFromFile(pTbl->szNpcEvent);
	m_pUINpcEvent->SetVisibleWithNoSound(false);
	m_pUINpcEvent->SetStyle(UISTYLE_SHOW_ME_ALONE | UISTYLE_USER_MOVE_HIDE);
	rc = m_pUINpcEvent->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUINpcEvent->SetPos(iX, iY);

	m_pUIWarp->Init(s_pUIMgr);
	m_pUIWarp->LoadFromFile(pTbl->szZoneChangeOrWarp);
	m_pUIWarp->SetVisibleWithNoSound(false);
	rc = m_pUIWarp->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIWarp->SetPos(iX, iY);
	m_pUIWarp->SetStyle(UISTYLE_USER_MOVE_HIDE | UISTYLE_SHOW_ME_ALONE);

	m_pUIRepairTooltip->Init(s_pUIMgr);
	m_pUIRepairTooltip->LoadFromFile(pTbl->szRepairTooltip);
	m_pUIRepairTooltip->SetVisibleWithNoSound(false);
	m_pUIRepairTooltip->InitPos();
	m_pUIRepairTooltip->SetStyle(UISTYLE_ALWAYSTOP|UISTYLE_FOCUS_UNABLE);

	m_pUIPartyOrForce->Init(s_pUIMgr);
	m_pUIPartyOrForce->LoadFromFile(pTbl->szPartyOrForce);
	m_pUIPartyOrForce->SetStyle(UISTYLE_HIDE_UNABLE);
	rc = m_pUIPartyOrForce->GetRegion();
	iX = iW - (rc.right - rc.left);
	m_pUIPartyOrForce->SetPos(iX, 0);
	m_pUIPartyOrForce->SetVisible(false); // 강제로 안보이기~
//	CGameProcedure::UIPostData_Read(UI_POST_WND_PARTY, m_pUIPartyOrForce, iX, 0);

	// Dropped Item Dlg.. 
	m_pUIDroppedItemDlg->Init(s_pUIMgr);
	m_pUIDroppedItemDlg->LoadFromFile(pTbl->szDroppedItem);
	m_pUIDroppedItemDlg->SetVisibleWithNoSound(false);
	m_pUIDroppedItemDlg->InitIconWnd(UIWND_DROPITEM);
	m_pUIDroppedItemDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUIDroppedItemDlg->SetState(UI_STATE_COMMON_NONE);
	m_pUIDroppedItemDlg->SetStyle(m_pUIDroppedItemDlg->GetStyle() | UISTYLE_USER_MOVE_HIDE);

	m_pUITransactionDlg->Init(s_pUIMgr);
	m_pUITransactionDlg->LoadFromFile(pTbl->szTransaction);
	rc = m_pUITransactionDlg->GetRegion();
	m_pUITransactionDlg->SetPos(iW - (rc.right-rc.left), 10);
	m_pUITransactionDlg->SetVisibleWithNoSound(false);
	m_pUITransactionDlg->InitIconWnd(UIWND_TRANSACTION);
	m_pUITransactionDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUITransactionDlg->SetState(UI_STATE_COMMON_NONE);
	m_pUITransactionDlg->SetStyle(m_pUITransactionDlg->GetStyle() | UISTYLE_POS_RIGHT | UISTYLE_USER_MOVE_HIDE);

	m_pSubProcPerTrade->InitPerTradeDlg(s_pUIMgr);

	m_pUIInventory->Init(s_pUIMgr);
	m_pUIInventory->LoadFromFile(pTbl->szInventory);
	m_pUIInventory->SetVisibleWithNoSound(false);
	m_pUIInventory->SetPos(465,10);
	m_pUIInventory->InitIconWnd(UIWND_INVENTORY);
	m_pUIInventory->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUIInventory->SetState(UI_STATE_COMMON_NONE);
	m_pUIInventory->SetStyle(m_pUIInventory->GetStyle() | UISTYLE_POS_RIGHT);

	// Countable Item Edit Dlg..
	CN3UIWndBase::s_pCountableItemEdit = new CCountableItemEditDlg;
	CN3UIWndBase::s_pCountableItemEdit->Init(s_pUIMgr);
	CN3UIWndBase::s_pCountableItemEdit->LoadFromFile(pTbl->szPersonalTradeEdit);
	CN3UIWndBase::s_pCountableItemEdit->SetStyle(UISTYLE_ALWAYSTOP);
	// 위치 계산 ..
	rc = CN3UIWndBase::s_pCountableItemEdit->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	CN3UIWndBase::s_pCountableItemEdit->SetPos(iX, iY);	
	CN3UIWndBase::s_pCountableItemEdit->SetVisibleWithNoSound(false);
	CN3UIWndBase::s_pCountableItemEdit->SetUIType(UI_TYPE_BASE);
	CN3UIWndBase::s_pCountableItemEdit->SetState(UI_STATE_COMMON_NONE);

	m_pUISkillTreeDlg->Init(s_pUIMgr);
	m_pUISkillTreeDlg->LoadFromFile(pTbl->szSkillTree);
	m_pUISkillTreeDlg->SetVisibleWithNoSound(false);
	rc = m_pUISkillTreeDlg->GetRegion();
	m_pUISkillTreeDlg->SetPos(iW - (rc.right-rc.left), 10);
	m_pUISkillTreeDlg->InitIconWnd(UIWND_SKILL_TREE);
	m_pUISkillTreeDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUISkillTreeDlg->SetState(UI_STATE_COMMON_NONE);
	m_pUISkillTreeDlg->SetStyle(m_pUISkillTreeDlg->GetStyle() | UISTYLE_POS_RIGHT);

	m_pUICmdList->Init(s_pUIMgr);
	m_pUICmdList->LoadFromFile(pTbl->szCmdList);
	m_pUICmdList->SetVisibleWithNoSound(false);
	rc = m_pUICmdList->GetRegion();
	m_pUICmdList->SetPos(iW - (rc.right - rc.left), 10);
	m_pUICmdList->SetStyle(m_pUISkillTreeDlg->GetStyle() | UISTYLE_POS_RIGHT);

	m_pUICmdEdit->Init(s_pUIMgr);
	m_pUICmdEdit->LoadFromFile(pTbl->szCmdEdit);
	m_pUICmdEdit->SetVisibleWithNoSound(false);
	rc = m_pUICmdEdit->GetRegion();
	iX = (iW - (rc.right - rc.left)) / 2;
	iY = (iH - (rc.bottom - rc.top)) / 2;
	m_pUICmdEdit->SetPos(iX, iY);
	m_pUICmdEdit->SetStyle(UISTYLE_USER_MOVE_HIDE);
	
	// default ui pos ..	해상도가 변경되면.. 상대 위치를 구해야 한다.. by ecli666
	rc = m_pUIStateBarAndMiniMap->GetRegion();
	m_pUIHotKeyDlg->Init(s_pUIMgr);
	m_pUIHotKeyDlg->LoadFromFile(pTbl->szHotKey);
	m_pUIHotKeyDlg->SetStyle(UISTYLE_HIDE_UNABLE);
	UIPostData_Read(UI_POST_WND_HOTKEY, m_pUIHotKeyDlg, rc.left, rc.bottom);
	m_pUIHotKeyDlg->SetVisibleWithNoSound(true); // 무조건 보인다!!!
	m_pUIHotKeyDlg->InitIconWnd(UIWND_HOTKEY);
	m_pUIHotKeyDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUIHotKeyDlg->SetState(UI_STATE_COMMON_NONE);

	m_pUIKnightsOp->Init(s_pUIMgr);	// 기사단 리스트 보기, 가입, 등...
	m_pUIKnightsOp->LoadFromFile(pTbl->szKnightsOperation);
	m_pUIKnightsOp->SetVisibleWithNoSound(false);

	// 파티 지원 게시판..
	m_pUIPartyBBS->Init(s_pUIMgr);
	m_pUIPartyBBS->LoadFromFile(pTbl->szPartyBBS);//, N3FORMAT_VER_1298);
	m_pUIPartyBBS->SetVisibleWithNoSound(false);
	rc = m_pUIPartyBBS->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIPartyBBS->SetPos(iX, iY);


	m_pUIWareHouseDlg->Init(s_pUIMgr);
	m_pUIWareHouseDlg->LoadFromFile(pTbl->szWareHouse);
	rc = m_pUIWareHouseDlg->GetRegion();
	m_pUIWareHouseDlg->SetPos(iW - (rc.right-rc.left), 10);
	m_pUIWareHouseDlg->SetVisibleWithNoSound(false);
	m_pUIWareHouseDlg->InitIconWnd(UIWND_WARE_HOUSE);
	m_pUIWareHouseDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUIWareHouseDlg->SetState(UI_STATE_COMMON_NONE);
	m_pUIWareHouseDlg->SetStyle(UISTYLE_USER_MOVE_HIDE | UISTYLE_POS_RIGHT);

	m_pTargetSymbol->LoadFromFile(pTbl->szTargetSymbolShape); // 플레이어가 타겟으로 잡은 캐릭터의 위치위에 그리면 된다..

	m_pUIInn->Init(s_pUIMgr);
	m_pUIInn->LoadFromFile(pTbl->szInn);
	m_pUIInn->SetVisibleWithNoSound(false);
	m_pUIInn->SetStyle(UISTYLE_SHOW_ME_ALONE | UISTYLE_USER_MOVE_HIDE);
	rc = m_pUIInn->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIInn->SetPos(iX, iY);
	
	m_pUICreateClanName->Init(s_pUIMgr);
	m_pUICreateClanName->LoadFromFile(pTbl->szInputClanName);
	m_pUICreateClanName->SetVisibleWithNoSound(false);
	rc = m_pUICreateClanName->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUICreateClanName->SetPos(iX, iY);
	m_pUICreateClanName->SetStyle(UISTYLE_USER_MOVE_HIDE);

	// Quest Menu
	m_pUIQuestMenu->Init(s_pUIMgr);
	m_pUIQuestMenu->LoadFromFile(pTbl->szQuestMenu);
	m_pUIQuestMenu->SetVisibleWithNoSound(false);
	m_pUIQuestMenu->SetStyle(UISTYLE_USER_MOVE_HIDE);

	// Quest Talk
	m_pUIQuestTalk->Init(s_pUIMgr);
	m_pUIQuestTalk->LoadFromFile(pTbl->szQuestTalk);
	m_pUIQuestTalk->SetVisibleWithNoSound(false);
	m_pUIQuestTalk->SetStyle(UISTYLE_USER_MOVE_HIDE);
	rc = m_pUIQuestTalk->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIQuestTalk->SetPos(iX, iY);

	// dead ui
	m_pUIDead->Init(s_pUIMgr);
	m_pUIDead->LoadFromFile(pTbl->szDead);
	m_pUIDead->SetVisibleWithNoSound(false);
	rc = m_pUIDead->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUIDead->SetPos(iX, iY);


	// 상거래 게시판
	m_pUITradeBBS->Init(s_pUIMgr);
	m_pUITradeBBS->LoadFromFile(pTbl->szTradeBBS);
	m_pUITradeBBS->SetVisibleWithNoSound(false);
	m_pUITradeBBS->SetStyle(UISTYLE_USER_MOVE_HIDE);
	rc = m_pUITradeBBS->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUITradeBBS->SetPos(iX, iY);

	// 상거래 종류 선택 
	m_pUITradeBBSSelector->Init(s_pUIMgr);
	m_pUITradeBBSSelector->LoadFromFile(pTbl->szTradeBBSSelector);
	m_pUITradeBBSSelector->SetVisibleWithNoSound(false);
	rc = m_pUITradeBBSSelector->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUITradeBBSSelector->SetPos(iX, iY);
	m_pUITradeBBSSelector->SetStyle(UISTYLE_USER_MOVE_HIDE);

	// 상거래 항목 내용
	m_pUITradeBBSEdit->LoadFromFile(pTbl->szTradeExplanation);
	m_pUITradeBBSEdit->SetVisibleWithNoSound(false);
	rc = m_pUITradeBBSEdit->GetRegion();
	iX = (iW - (rc.right - rc.left))/2;
	iY = (iH - (rc.bottom - rc.top))/2;
	m_pUITradeBBSEdit->SetPos(iX, iY);

	m_pUIUpgradeSelect->Init(s_pUIMgr);
	m_pUIUpgradeSelect->LoadFromFile(pTbl->szUpgradeSelect);
	m_pUIUpgradeSelect->SetVisibleWithNoSound(false);
	m_pUIUpgradeSelect->SetPos(
		(iW - m_pUIUpgradeSelect->GetWidth()) / 2,
		(iH - m_pUIUpgradeSelect->GetHeight()) / 2);
	m_pUIUpgradeSelect->SetState(UI_STATE_COMMON_NONE);
	m_pUIUpgradeSelect->SetStyle(m_pUIUpgradeSelect->GetStyle() | UISTYLE_USER_MOVE_HIDE | UISTYLE_SHOW_ME_ALONE);

	//ui level guide
	m_pUILevelGuide->Init(s_pUIMgr);
	m_pUILevelGuide->LoadFromFile(pTbl->szLvlGuide);
	m_pUILevelGuide->SetVisibleWithNoSound(false);
	m_pUILevelGuide->SetStyle(UISTYLE_POS_RIGHT);
	rc = m_pUILevelGuide->GetRegion();
	iX = iW - (rc.right - rc.left);
	iY = 10; //same pos with inventory
	m_pUILevelGuide->SetPos(iX, iY);
}

void CGameProcMain::MsgSend_RequestTargetHP(int16_t siIDTarget, uint8_t byUpdateImmediately)
{
	uint8_t byBuff[4];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_TARGET_HP);
	CAPISocket::MP_AddShort(byBuff, iOffset, siIDTarget);
	CAPISocket::MP_AddByte(byBuff, iOffset, byUpdateImmediately); // 0x00 - 점차 늘어나게끔.. 0x01 - 즉시 업데이트..

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgRecv_TargetHP(Packet& pkt)
{
	int iID				= pkt.read<int16_t>();	// SID
	uint8_t byUpdateImmediately = pkt.read<uint8_t>();	// 0x00 - 점차 늘어나게끔.. 0x01 - 즉시 업데이트..
	int iTargetHPMax	= pkt.read<uint32_t>();  // HP 
	int iTargetHPCur	= pkt.read<uint32_t>();  // HP 
	int iTargetHPChange	= pkt.read<int16_t>();  // HP 

	if(iTargetHPMax <= 0)
	{
		CPlayerNPC* pTarget = this->s_pOPMgr->CharacterGetByID(iID, true);
		std::string szBuff("Invalid HP Change - 0 ID(");
		if(pTarget) szBuff += pTarget->IDString();
		szBuff += ')';
		CLogWriter::Write(szBuff);
	}
	__ASSERT(iTargetHPMax > 0, "최대 체력 수치는 0이상이어야 합니다.");

	if(iID == s_pPlayer->m_iIDTarget) // 내가 공격하는 넘이면..
	{
		bool bUI = false;
		if(byUpdateImmediately) bUI = true;
		m_pUITargetBar->UpdateHP(iTargetHPCur, iTargetHPMax, bUI);
	//	TRACE("Target HP Update %d %d\n", iID, iTargetHPPercent);
	}

	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(iID, true);
	if (pTarget != nullptr)
	{
		pTarget->m_InfoBase.iHP = iTargetHPCur;
		pTarget->m_InfoBase.iHPMax = iTargetHPMax;

		std::string szMsg;
		if (iTargetHPChange < 0)
		{
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_TARGET_HP_LOST,
				pTarget->IDString(), -iTargetHPChange);
			MsgOutput(szMsg, 0xffffffff);
		}
		else if (iTargetHPChange > 0)
		{
			szMsg = fmt::format_text_resource(IDS_MSG_FMT_TARGET_HP_RECOVER,
				pTarget->IDString(), iTargetHPChange);
			MsgOutput(szMsg, 0xff6565ff);
		}
	}
}

// 상거래..................
bool CGameProcMain::MsgSend_NPCEvent(int16_t siIDTarget)
{
	uint8_t byBuff[4];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_NPC_EVENT);
	CAPISocket::MP_AddShort(byBuff, iOffset, siIDTarget);

	s_pSocket->Send(byBuff, iOffset);

	return true;
}

void CGameProcMain::MsgSend_NPCInRequest(int iID) // NPC 정보가 없을 경우 요청한다..
{
	//TRACE("found NPC ghost (ID:%d)\n", iID);

	int iOffset=0;													// 버퍼의 오프셋..
	uint8_t byBuff[32];;												// 패킷 버퍼..
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_REQ_NPCIN);		// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, 1);					// 아이디 갯수..
	CAPISocket::MP_AddShort(byBuff, iOffset, iID);					// 자세한 정보가 필요한 아이디들..

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_UserInRequest(int iID) // User 정보가 없을 경우 요청한다..
{
	//TRACE("found User ghost (ID:%d)\n", iID);

	int iOffset=0;													// 버퍼의 오프셋..
	uint8_t byBuff[32];;												// 패킷 버퍼..
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_REQ_USERIN);	// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, 1);					// 아이디 갯수..
	CAPISocket::MP_AddShort(byBuff, iOffset, iID);					// 자세한 정보가 필요한 아이디들..

	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::MsgSend_Warp() // 워프 - 존이동이 될수도 있다..
{	
	__WarpInfo WI;
	if (!m_pUIWarp->InfoGetCur(WI)
		|| WI.szName.empty())
		return;

	uint8_t byBuff[8];
	int iOffset = 0;

	m_szWarpDestination = WI.szName;

	if (s_pPlayer->m_InfoExt.iGold < WI.iGold)
	{
		std::string szMsg = fmt::format_text_resource(IDS_TELEPORT_TO_X_NEED_Y_COINS,
			WI.szName, WI.iGold);
		MsgOutput(szMsg, 0xFFFF3B3B);
		return;
	}

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WARP_LIST);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) WI.iID); // 워프 아이디 보내기...
	s_pSocket->Send(byBuff, iOffset);
}

void CGameProcMain::DoCommercialTransaction(int iTradeID)
{
	if (m_pUITransactionDlg->IsVisible())
		return;

	m_pUITransactionDlg->m_iTradeID = iTradeID;

	if ( !m_pUITransactionDlg->IsVisible() )
		m_pUITransactionDlg->SetVisible(true);

	if (m_pUIInventory->IsVisible()) // 인벤토리가 안열려 있으면..
		this->CommandToggleUIInventory();

	if (m_pUISkillTreeDlg->IsVisible())
		m_pUISkillTreeDlg->Close();

	m_pUITransactionDlg->EnterTransactionState();
}

bool CGameProcMain::MsgRecv_ItemTradeStart(Packet& pkt)			// 아이템 상거래..
{
	int iTradeID = pkt.read<uint32_t>();		// Trade id
	CPlayerNPC* pNPC = s_pOPMgr->NPCGetByID(s_pPlayer->m_iIDTarget, true);
	if (!pNPC)	return true;
	m_pUINpcEvent->Open(NPC_EVENT_ITEM_TRADE, iTradeID, pNPC->GetNPCOriginID());

	return true;
}

bool CGameProcMain::MsgRecv_ItemTradeResult(Packet& pkt)			// 아이템 상거래 결과..
{
	byte bfType = 0x00;	int	iMoney = 0;
	byte bResult = pkt.read<uint8_t>();		// Trade id

	switch ( bResult )
	{
		case 0x00:
			bfType = pkt.read<uint8_t>();		// Trade id
			m_pUITransactionDlg->ReceiveResultTradeFromServer( bResult, bfType, iMoney );
			break;

		case 0x01:
			iMoney = pkt.read<uint32_t>();		// Trade id
			m_pUITransactionDlg->ReceiveResultTradeFromServer( bResult, bfType, iMoney );
			break;

		case 0x03:
			m_pUITransactionDlg->ReceiveResultTradeMoveSuccess();
			break;

		case 0x04:
			m_pUITransactionDlg->ReceiveResultTradeMoveFail();
			break;
	}
	
	return true;
}

void CGameProcMain::InitZone(int iZone, const __Vector3& vPosPlayer)
{
	if(m_pSnd_Battle) m_pSnd_Battle->Stop(0.0f); // 음악 멈추기..
	if(m_pSnd_Town) m_pSnd_Town->Stop(0.0f);

	MsgSend_SpeedCheck(true);		// 스피드핵 체크 기준시간 정하기
	static int iZonePrev = -1;
	if(iZonePrev != iZone) // 다른 존일 경우에만 로딩..
	{
		m_pLightMgr->Release();
		s_pEng->SetDefaultLight(m_pLightMgr->Light(0), m_pLightMgr->Light(1), m_pLightMgr->Light(2));

		if(m_pUIChatDlg) m_pUIChatDlg->ChangeChattingMode(N3_CHAT_NORMAL); //존 이동을 하면 일반 채팅상태로 바꿔준다.
		if(m_pUIPartyOrForce) m_pUIPartyOrForce->MemberDestroy();	//존 이동을 할때 파티를 깬다...
		this->UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.

		s_pPlayer->m_bMoveContinous = true; // 멈춘다..
		this->CommandToggleMoveContinous();

		CLogWriter::Write("CGameProcMain::InitZone -> Zone Change ({} -> {}) Position({:.1f}, {:.1f}, {:.1f})",
			iZonePrev, iZone, vPosPlayer.x, vPosPlayer.y, vPosPlayer.z);

		m_bLoadComplete = false; // 로딩 끝남..
		m_pMagicSkillMng->ClearDurationalMagic();
		s_pFX->ClearAll();

		if (s_pUILoading != nullptr)
			s_pUILoading->Render("", 0);
		
		s_pPlayer->m_InfoExt.iZoneCur = iZone;
		iZonePrev = iZone; // 최근에 읽은 존 번호를 기억해둔다.

		__TABLE_ZONE* pZoneData = s_pTbl_Zones.Find(s_pPlayer->m_InfoExt.iZoneCur);
		if (nullptr == pZoneData)
		{
			CLogWriter::Write("can't find zone data. (zone : {})", s_pPlayer->m_InfoExt.iZoneCur);
			__ASSERT(0, "Zone Data Not Found!");
			system("pause");
			return;
		}

		s_pOPMgr->Release(); // 다른 넘들 다 날린다..
		s_pWorldMgr->InitWorld(iZone, vPosPlayer);

		// 미니맵 로딩..
		float fWidth = ACT_WORLD->GetWidthByMeterWithTerrain();
		m_pUIStateBarAndMiniMap->LoadMap(pZoneData->szMiniMapFN, fWidth, fWidth);

		// 줌 비율 정하기..
		float fZoom = 6.0f;
		e_Class_Represent eCR = CGameProcedure::GetRepresentClass(s_pPlayer->m_InfoBase.eClass);
		if(CLASS_REPRESENT_ROGUE == eCR) fZoom = 3.0f; // 로그 계열은 맵이 좀더 널리 자세히 보인다..
		m_pUIStateBarAndMiniMap->ZoomSet(fZoom);

		//char szBuf[256];
		char szFName[_MAX_PATH];
		_splitpath(pZoneData->szTerrainFN.c_str(), nullptr, nullptr, szFName, nullptr);
		std::string szFName2 = szFName;
		szFName2 += "_Bird";

		char szFullPathName[_MAX_PATH] = {};
		_makepath(szFullPathName, nullptr, "misc\\bird", szFName2.c_str(), "lst");

		m_pLightMgr->LoadZoneLight(pZoneData->szLightObjFN.c_str());

		m_bLoadComplete = true; // 로딩 끝남..
	}
		
	// 카메라 세팅..
	CN3Camera* pCamera		= s_pEng->CameraGetActive();		// 활성화된 카메라 얻기..
	if(pCamera)
	{
		__Vector3 vPosPlayer = s_pPlayer->Position();
		pCamera->m_Data.fFOV	= DegreesToRadians(70);				// Field of View ..
		pCamera->m_Data.fFP		= 512.0f;						// Far Plane..
		pCamera->m_Data.fNP		= 0.5f;							// Near Plane..
		pCamera->LookAt(vPosPlayer + __Vector3(0,0,-1), vPosPlayer, __Vector3(0,1,0));
		pCamera->Tick();
		pCamera->Apply();
	}
	// 기본적인 캐릭터위치와 카메라 위치 잡기..
	////////////////////////////////////////////////////////////////////////////////

	CLogWriter::Write("InitPlayerPosition() Position({:.1f}, {:.1f}, {:.1f})",
		vPosPlayer.x, vPosPlayer.y, vPosPlayer.z); // TmpLog1122
	InitPlayerPosition(vPosPlayer); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
	s_pPlayer->RegenerateCollisionMesh(); // 충돌 메시를 다시 만든다..
	s_pOPMgr->Release(); // 다른 플레이어 삭제...
}


void CGameProcMain::MsgSend_GameStart()
{
	uint8_t byBuff[32];															// 패킷 버퍼..
	int iOffset=0;															// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_GAMESTART);						// 게임 스타트 패킷 커멘드..
	//CAPISocket::MP_AddByte(byBuff, iOffset, s_pPlayer->IDString().size());		// 아이디 길이 패킷에 넣기..
	//CAPISocket::MP_AddString(byBuff, iOffset, s_pPlayer->IDString());			// 아이디 문자열 패킷에 넣기..

	// NOTE(srmeier): start the first part of the login process
	CAPISocket::MP_AddByte(byBuff, iOffset, 0x01);

	s_pSocket->Send(byBuff, iOffset);
}

bool CGameProcMain::CommandToggleWalkRun()
{
	bool bRun = s_pPlayer->ToggleRunMode();
	bool bMove = s_pPlayer->m_bMoveContinous;

	// 커맨드 버튼 업데이트..
	if(m_pUICmd->m_pBtn_Act_Walk)
	{
		m_pUICmd->m_pBtn_Act_Walk->SetVisible(bRun);
		if(bMove) m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_DOWN);
		else m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_NORMAL);
	}
	if(m_pUICmd->m_pBtn_Act_Run)
	{
		m_pUICmd->m_pBtn_Act_Run->SetVisible(!bRun);
		if(bMove) m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_DOWN);
		else m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_NORMAL);
	}

	return bRun;
}

bool CGameProcMain::CommandToggleAttackContinous()
{
	CPlayerBase* pTarget = s_pPlayer->TargetPointerCheck(false);
	this->CommandEnableAttackContinous(!s_pPlayer->m_bAttackContinous, pTarget);

	return s_pPlayer->m_bAttackContinous;
}

bool CGameProcMain::CommandToggleMoveContinous()
{
	if(s_pPlayer->IsDead()) return false;

	s_pPlayer->ToggleMoveMode();				// 자동 전진 토글.. 
	if(s_pPlayer->m_bMoveContinous)
	{
		this->CommandMove(MD_FORWARD, true);
		if(m_pUICmd->m_pBtn_Act_Run) m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_DOWN);
		if(m_pUICmd->m_pBtn_Act_Walk) m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_DOWN);
	}
	else
	{
		this->CommandMove(MD_STOP, true); // 움직임 패킷 보내기..
		if(m_pUICmd->m_pBtn_Act_Run) m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_NORMAL);
		if(m_pUICmd->m_pBtn_Act_Walk) m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_NORMAL);
	}

	return s_pPlayer->m_bMoveContinous;
}

void CGameProcMain::CommandMove(e_MoveDirection eMD, bool bStartOrEnd)
{
	if(bStartOrEnd) this->CloseUIs(); // 각종 상거래, 워프등등... UI 닫기..

	if(s_pPlayer->IsDead()) return; // 죽은 넘이 어딜 감히!!

	if(MD_FORWARD == eMD || MD_BACKWARD == eMD)
	{
		s_pUIMgr->UserMoveHideUIs();
		this->CommandSitDown(false, false, true); // 일으켜 세우고..
		if(s_pPlayer->m_bStun) return; // 기절해 있음 움직이지 못함..
		if(MD_FORWARD == eMD)
		{
			if(s_pPlayer->IsRunning()) s_pPlayer->ActionMove(PSM_RUN); // 뛰어가기..
			else s_pPlayer->ActionMove(PSM_WALK); // 걸어가기..
		}
		else
		{
			s_pPlayer->ActionMove(PSM_WALK_BACKWARD); // 후진..
		}

		if( bStartOrEnd ) // 움직이기 시작할때에는 충돌체크를 먼저 해본다..
		{
			float fSpeed = s_pPlayer->MoveSpeedCalculationAndCheckCollision(); // 속도를 구하고 그 속도로 충돌 체크를 한다. 리턴값이 0 이면 충돌이다..
			if(0 == fSpeed) // 못움직이는 상황이면..
			{
				s_pPlayer->ActionMove(PSM_STOP); // 멈춤..
			}
			else
			{
				this->MsgSend_Move(true, false); // 움직이는 순간이면.. 움직임 시작 패킷 보내기.
			}

			if(m_pUICmd->m_pBtn_Act_Run) m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_DOWN);
			if(m_pUICmd->m_pBtn_Act_Walk) m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_DOWN);
		}
	}
	else if(MD_STOP == eMD)
	{
		s_pPlayer->m_bMoveContinous = false; // 계속 걸음 멈춤..
		s_pPlayer->ActionMove(PSM_STOP);
		
		if(m_pUICmd->m_pBtn_Act_Run) m_pUICmd->m_pBtn_Act_Run->SetState(UI_STATE_BUTTON_NORMAL);
		if(m_pUICmd->m_pBtn_Act_Walk) m_pUICmd->m_pBtn_Act_Walk->SetState(UI_STATE_BUTTON_NORMAL);

		this->MsgSend_Move(false, false); // 움직임 멈춤 패킷 보내기.
	}

	if(s_pPlayer->m_bAttackContinous) // 공격중이면..
	{
		CPlayerBase* pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, false);
		if(s_pPlayer->IsAttackableTarget(pTarget)) // 공격 가능하면..
			s_pPlayer->Action(PSA_ATTACK, false, pTarget); // 공격
	}
}

/// \brief toggles the player's autoattack
void CGameProcMain::CommandEnableAttackContinous(bool bEnable, CPlayerBase* pTarget)
{
	// no change
	if (bEnable == s_pPlayer->m_bAttackContinous)
		return;

	// invalid target
	if (pTarget == nullptr)
	{
		StopAutoAttack(pTarget);
		return;
	}

	if (bEnable)
	{
		StartAutoAttack(pTarget);
	}
	else
	{
		StopAutoAttack(pTarget);
	}
}

/// \brief contains the logic that should be executed whenever starting to auto-attack
void CGameProcMain::StartAutoAttack(CPlayerBase* target)
{
	// already auto-attacking
	if (s_pPlayer->m_bAttackContinous)
		return;
	
	this->CloseUIs(); 
	s_pUIMgr->UserMoveHideUIs();

	if(s_pPlayer->m_bStun)
		return;

	s_pPlayer->RotateTo(target);

	if (!s_pPlayer->IsHostileTarget(target))
		return;

	// check if the target is attackable
	// this can fail for several reasons:
	// - invalid target
	// - target not in front of attacker
	// - target out of range
	// doesn't really feel like it should be here, it's checked in so many other places
	// and covers too many cases to be helpful
	if (!s_pPlayer->IsAttackableTarget(target))
	{
		std::string szMsg = fmt::format_text_resource(IDS_MSG_ATTACK_DISABLE);
		MsgOutput(szMsg, 0xffffff00);
		// return;
	}

	s_pPlayer->m_bAttackContinous = true;
	
	SetGameCursor(s_hCursorAttack);
		
	// Print an info message for attack start
	std::string szMsg = fmt::format_text_resource(IDS_MSG_ATTACK_START,
		target->IDString());
	MsgOutput(szMsg, 0xff00ffff);
	
	// play combat music
	PlayBGM_Battle();

	// reset state to idle, pending attack on tick
	s_pPlayer->Action(PSA_BASIC, true, target);
	
	if (m_pUICmd->m_pBtn_Act_Attack != nullptr)
		m_pUICmd->m_pBtn_Act_Attack->SetState(UI_STATE_BUTTON_DOWN);
}

/// \brief contains the logic that should be executed whenever auto-attacking is stopped
void CGameProcMain::StopAutoAttack(CPlayerBase* target)
{
	// not auto-attacking
	if (!s_pPlayer->m_bAttackContinous)
		return;
	
	s_pPlayer->m_bAttackContinous = false;
	
	e_Nation eNation = s_pPlayer->m_InfoBase.eNation;
	SetGameCursor(((NATION_ELMORAD == eNation) ? s_hCursorNormal1 : s_hCursorNormal));

	std::string szMsg = fmt::format_text_resource(IDS_MSG_ATTACK_STOP);
	s_pPlayer->Action(PSA_BASIC, true, target);
	this->MsgOutput(szMsg, 0xff00ffff);

	if (m_pUICmd->m_pBtn_Act_Attack)
	{
		m_pUICmd->m_pBtn_Act_Attack->SetState(UI_STATE_BUTTON_NORMAL);
	}
}

void CGameProcMain::CommandToggleUIChat()
{
	bool visible = m_pUIChatDlg->IsVisible();

	m_pUIChatDlg->SetVisibleWithNoSound(!visible);
	m_pUIChatDlg2->SetVisibleWithNoSound(visible);
}

void CGameProcMain::CommandToggleUIMsgWnd()
{
	bool visible = m_pUIMsgDlg->IsVisible();

	m_pUIMsgDlg->SetVisibleWithNoSound(!visible);
	m_pUIMsgDlg2->SetVisibleWithNoSound(visible);
}

bool CGameProcMain::CommandToggleUIState()
{
	bool bNeedOpen = !(m_pUIVar->IsVisible());
	if(bNeedOpen)
	{
		s_pUIMgr->SetFocusedUI(m_pUIVar);
		m_pUIVar->Open();
	}
	else m_pUIVar->Close();

	// 커맨드 버튼 업데이트..
//	if(m_pUICmd->m_pBtn_Character)
//	{
//		if(bNeedOpen) m_pUICmd->m_pBtn_Character->SetState(UI_STATE_BUTTON_DOWN); // 버튼 누름 해제..
//		else m_pUICmd->m_pBtn_Character->SetState(UI_STATE_BUTTON_NORMAL); // 버튼 누름
//	}

	return bNeedOpen;
}

bool CGameProcMain::CommandToggleUIInventory()
{
	bool bNeedOpen = false;

	// 개인 거래중이면..
	if (m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE)
		return bNeedOpen;

	if (m_pUINpcEvent->IsVisible())
		return bNeedOpen;

	if( m_pUIInn->IsVisible()) return bNeedOpen;
	if( m_pUICreateClanName->IsVisible()) return bNeedOpen;

	if (m_pUIWareHouseDlg->IsVisible())
	{
		if (m_pUIInventory->IsVisible())
			m_pUIInventory->Close(true);
		return bNeedOpen;
	}

	if (m_pUITransactionDlg->IsVisible())
	{
		if (m_pUIInventory->IsVisible())
			m_pUIInventory->Close(true);
		return bNeedOpen;
	}
	
	if (m_pUIInventory->IsVisible())
	{
		m_pUIInventory->Close(true);
		return bNeedOpen;
	}
	else
	{
		bNeedOpen = true;
		if(m_pUISkillTreeDlg->IsVisible()) m_pUISkillTreeDlg->Close();

		s_pUIMgr->SetFocusedUI(m_pUIInventory);
		m_pUIInventory->Open();
	}

	return bNeedOpen;
}

bool CGameProcMain::CommandToggleUISkillTree()
{
	bool bNeedOpen = !(m_pUISkillTreeDlg->IsVisible());

	// 개인 거래중이면..
	if (m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE)
		return bNeedOpen;

	if (bNeedOpen)
	{
		if (m_pUIInventory->IsVisible())
			m_pUIInventory->Close();
		if (m_pUITransactionDlg->IsVisible())
			m_pUITransactionDlg->LeaveTransactionState();
		if (m_pUIWareHouseDlg->IsVisible())
			m_pUIWareHouseDlg->LeaveWareHouseState();

		s_pUIMgr->SetFocusedUI(m_pUISkillTreeDlg);
		m_pUISkillTreeDlg->Open();
	}
	else
	{
		m_pUISkillTreeDlg->Close();
	}

	return bNeedOpen;
}

bool CGameProcMain::CommandToggleUIMiniMap()
{
	return m_pUIStateBarAndMiniMap->ToggleMiniMap();
}

bool CGameProcMain::CommandToggleCmdList()
{
	bool bNeedOpen = !(m_pUICmdList->IsVisible());

	if (m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE)
		return bNeedOpen;

	if (bNeedOpen)
	{
		s_pUIMgr->SetFocusedUI(m_pUICmdList);
		m_pUICmdList->Open();
	}
	else
	{
		m_pUICmdList->Close();
	}

	return bNeedOpen;
}

bool CGameProcMain::CommandToggleLevelGuide()
{
	bool bNeedOpen = !m_pUILevelGuide->IsVisible();
	m_pUILevelGuide->SetVisible(bNeedOpen);

	return bNeedOpen;
}

bool CGameProcMain::OpenCmdEdit(std::string msg)
{
	bool bNeedOpen = !m_pUICmdEdit->IsVisible();

	if (bNeedOpen)
	{
		s_pUIMgr->SetFocusedUI(m_pUICmdEdit);
		m_pUICmdEdit->Open(msg);
	}

	return bNeedOpen;
}

void CGameProcMain::CommandCameraChange() // 카메라 시점 바꾸기..
{
	if(VP_THIRD_PERSON == s_pEng->ViewPoint() && s_pPlayer->m_bTargetOrPosMove)
	{
		s_pPlayer->m_bMoveContinous = false;
		s_pPlayer->m_bTargetOrPosMove = false;
		CommandToggleMoveContinous();
	}

	s_pEng->ViewPointChange(VP_UNKNOWN); // 순서대로 시점을 바꾼다..
}

void CGameProcMain::MsgOutput(const std::string& szMsg, D3DCOLOR crMsg)
{
	m_pUIMsgDlg->AddMsg(szMsg, crMsg);
}

bool CGameProcMain::MsgRecv_ItemDroppedGetResult(Packet& pkt)	// 땅에 떨어진 아이템 먹기 결과..
{
	uint8_t	bResult; 
	uint8_t	bPos = 0;
	int		iItemID = 0;
	int		iGoldID = 0;
	int		iStrLen = 0;
	int16_t	sItemCount = 0;
	std::string szString;

	bResult = pkt.read<uint8_t>();
	if ( (bResult == 0x01) || (bResult == 0x02) || (bResult == 0x05) )
	{
		bPos	= pkt.read<uint8_t>();
		iItemID = pkt.read<uint32_t>();
			if ( (bResult == 0x01) || (bResult == 0x05) )
			{
				sItemCount = pkt.read<int16_t>();
			}
		iGoldID = pkt.read<uint32_t>();
	}


	if (bResult == 0x03)
	{
		iItemID = pkt.read<uint32_t>();
		iStrLen = (int)pkt.read<int16_t>();
		pkt.readString(szString, iStrLen);
	}

	//TRACE("받음 - Item Get %d %d\n", bResult, iGoldID);

	if ( m_pUIDroppedItemDlg )
		m_pUIDroppedItemDlg->GetItemByIDToInventory(bResult, iItemID, iGoldID, bPos, sItemCount, iStrLen, szString);
	return true;
}

void CGameProcMain::MsgRecv_ZoneChange(
	Packet& pkt)
{
	uint8_t opcode = pkt.read<uint8_t>();
	switch (opcode)
	{
		case ZONE_CHANGE_TELEPORT:
		{
			int iZone		= 10 * pkt.read<uint8_t>();
			int iZoneSub	= pkt.read<uint8_t>();
			float fX = pkt.read<uint16_t>() / 10.0f;
			float fZ = pkt.read<uint16_t>() / 10.0f;
			float fY = pkt.read<int16_t>() / 10.0f;
			int iVictoryNation = pkt.read<uint8_t>();

			LoadingUIChange(iVictoryNation);


			s_pPlayer->m_iSendRegeneration = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그
			s_pPlayer->m_fTimeAfterDeath = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그

			if (s_pPlayer->IsDead())
			{
				//TRACE("ZoneChange - 다시 살아나기(%.1f, %.1f)\n", fX, fZ);

				//마법 & 효과 초기화..
				if (m_pUIStateBarAndMiniMap != nullptr)
					m_pUIStateBarAndMiniMap->ClearMagic();

				if (m_pMagicSkillMng != nullptr)
					m_pMagicSkillMng->ClearDurationalMagic();

				if (s_pFX != nullptr)
					s_pFX->StopMine();

				if (s_pPlayer->Nation() == NATION_KARUS)
					s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_KARUS, s_pPlayer->IDNumber(), -1);
				else if (s_pPlayer->Nation() == NATION_ELMORAD)
					s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_ELMORAD, s_pPlayer->IDNumber(), -1);
			}

			InitZone(iZone, __Vector3(fX, fY, fZ)); // Zone Update

			uint8_t byBuff[4];
			int iOffset_send = 0;
			CAPISocket::MP_AddByte(byBuff, iOffset_send, WIZ_ZONE_CHANGE);
			CAPISocket::MP_AddByte(byBuff, iOffset_send, (uint8_t) ZONE_CHANGE_LOADING);
			s_pSocket->Send(byBuff, iOffset_send);
		} break;

		case ZONE_CHANGE_LOADED:
		{
			uint8_t byBuff[4];
			int iOffset_send = 0;
			CAPISocket::MP_AddByte(byBuff, iOffset_send, WIZ_ZONE_CHANGE);
			CAPISocket::MP_AddByte(byBuff, iOffset_send, (uint8_t) ZONE_CHANGE_LOADED);
			s_pSocket->Send(byBuff, iOffset_send);
		} break;

	}
}

void CGameProcMain::MsgRecv_UserState(Packet& pkt)
{
	int iID = pkt.read<int16_t>();
	e_SubPacket_State eSP = (e_SubPacket_State)pkt.read<uint8_t>(); // 0x01
	int32_t iState = pkt.read<int32_t>();

	CPlayerBase* pBPC = nullptr;
	if ( s_pPlayer->IDNumber() == iID )
		pBPC = s_pPlayer;
	else
		pBPC = s_pOPMgr->UPCGetByID(iID, false); 
	
	if(nullptr == pBPC) return;

	if(N3_SP_STATE_CHANGE_SITDOWN == eSP) // 앉기,서기,죽음...
	{
		if(pBPC != s_pPlayer) // 플레이어가 아닐때..
		{
			if(0x01 == iState) 
				pBPC->Action(PSA_BASIC, true);
			else if(0x02 == iState) 
				pBPC->Action(PSA_SITDOWN, true);
			else if(0x03 == iState) 
				pBPC->Action(PSA_DYING, false, nullptr, true);
		}
	}
	else if(N3_SP_STATE_CHANGE_RECRUIT_PARTY == eSP) // 파티 구함..
	{
		if(0x01 == iState) 
		{
			pBPC->InfoStringSet("", 0);
		}
		else if(0x02 == iState) 
		{
			int iLevel = pBPC->m_InfoBase.iLevel;
			int iLMin = iLevel - 8;
			if(iLMin < 0) iLMin = 0;
			int iLMax = iLevel + 8;
			if(iLMax > 80) iLMax = 80;

			std::string szMsg = fmt::format_text_resource(IDS_WANT_PARTY_MEMBER,
				iLMin, iLMax);
			pBPC->InfoStringSet(szMsg, 0xff00ff00);
		}
	}
	else if(N3_SP_STATE_CHANGE_SIZE == eSP) // 크기 변함
	{
		if(0x01 == iState)
		{
			pBPC->ScaleSetGradually(1.0f); // 보통 크기..
			pBPC->FlickerFactorSet(1.0f); // 부활되서 반투명.. 깜박거린다..
		}
		else if(0x02 == iState) pBPC->ScaleSetGradually(2.0f); // 커졌다..
		else if(0x03 == iState) pBPC->ScaleSetGradually(0.5f);// 작아졌다.
		else if(0x04 == iState) pBPC->FlickerFactorSet(0.7f); // 부활되서 반투명.. 깜박거린다..
	}
	else if(N3_SP_STATE_CHANGE_ACTION == eSP) // 크기 변함
	{
		if (1 == iState) pBPC->AnimationAdd(ANI_GREETING0, true); // 인사
		else if (2 == iState) pBPC->AnimationAdd(ANI_GREETING1, true); // 인사
		else if (3 == iState) pBPC->AnimationAdd(ANI_GREETING2, true); // 인사
		else if (11 == iState) pBPC->AnimationAdd(ANI_WAR_CRY1, true); // 도발
		else if (12 == iState) pBPC->AnimationAdd(ANI_WAR_CRY2, true); // 도발
		else if (13 == iState) pBPC->AnimationAdd(ANI_WAR_CRY3, true); // 도발
	}
	else if (N3_SP_STATE_CHANGE_VISIBLE == eSP)
	{
		if (pBPC->m_InfoBase.iAuthority == AUTHORITY_MANAGER) {
			if (0 == iState)
				pBPC->m_bVisible = true;
			if (255 == iState && (s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER))
				pBPC->m_bVisible = false;
		}
	}
}

void CGameProcMain::MsgRecv_Notice(Packet& pkt)
{
	if(m_pUINotice) m_pUINotice->RemoveNotice();

	int iNoticeCount = pkt.read<uint8_t>();
	for(int i = 0; i < iNoticeCount; i++)
	{
		int iStrLen = pkt.read<uint8_t>();
		if(iStrLen <= 0) continue;

		std::string szNotice;
		pkt.readString(szNotice, iStrLen);
		if(m_pUINotice) m_pUINotice->m_Texts.push_back(szNotice);
	}

	if(m_pUINotice && iNoticeCount > 0)
	{
		m_pUINotice->GenerateText();
		
		// NOTE(srmeier): set where on the screen the notice appears
		RECT rc = m_pUINotice->GetRegion();
		int x = CN3Base::s_CameraData.vp.Width - (rc.right - rc.left);//(CN3Base::s_CameraData.vp.Width/2) - (rc.right - rc.left)/2;
		int y = 10;//(CN3Base::s_CameraData.vp.Height/2) - (rc.bottom - rc.top)/2;
		m_pUINotice->SetPos(x, y);
		m_pUINotice->SetVisible(true);
	}
}

void CGameProcMain::MsgRecv_PartyOrForce(Packet& pkt)
{
//	int iPartyOrForce = pkt.read<uint8_t>();
	int iSubCmd	= pkt.read<uint8_t>();
	
	switch(iSubCmd)
	{
		case N3_SP_PARTY_OR_FORCE_PERMIT:			// 0x02	// Send - b1(YesNo) | Recv - s1(ID) 요청한 사람의 ID
		{
			int iID			= pkt.read<int16_t>();
			int iStrLen		= pkt.read<int16_t>();
			std::string szID;
			pkt.readString(szID, iStrLen);
			
			if(iID >= 0)
			{
				std::string szMsg = fmt::format_text_resource(IDS_PARTY_PERMIT);
				MessageBoxPost(szID + szMsg, "", MB_YESNO, BEHAVIOR_PARTY_PERMIT);
			}
		}
		break;

		case N3_SP_PARTY_OR_FORCE_INSERT:			// 0x03	// Send - s1(ID) | Recv - s3(ID, HPMax, HP, MPMax, MP) b2(Level, Class) - 문자열은 ID 로 알아낸다..
		{
			int iIDorErrorCode		= pkt.read<int16_t>();		// IDs and positive numbers, error codes are negative numbers

			if (iIDorErrorCode >= 0)
			{
				int iPartyPosition	= pkt.read<uint8_t>();		// order of user in the party
				int iIDLength		= pkt.read<int16_t>();
				std::string szID;	pkt.readString(szID, iIDLength);
				int iHPMax			= pkt.read<int16_t>();
				int iHP				= pkt.read<int16_t>();
				int iLevel			= pkt.read<uint8_t>();
				e_Class eClass		= (e_Class) pkt.read<int16_t>();
				int iMPMax			= pkt.read<int16_t>();
				int iMP				= pkt.read<int16_t>();
				e_Nation eNation	= (e_Nation) pkt.read<uint8_t>();

				m_pUIPartyOrForce->MemberAdd(iIDorErrorCode, szID, iLevel, eClass, iHP, iHPMax, iMP, iMPMax); // 다른넘 파티에추가..
				if (iIDorErrorCode != s_pPlayer->IDNumber()) // 자기 자신이 아닌 경우 메시지 출력.
				{
					std::string szMsg = fmt::format_text_resource(IDS_PARTY_INSERT);
					MsgOutput(szID + szMsg, D3DCOLOR_ARGB(255, 255, 255, 255));
				}
			}
			// 파티에 들어올수 없다..
			else
			{
				std::string szMsg;

				// 상대방이 파티에 들어오기를 거절 하였다..
				if (-1 == iIDorErrorCode)
					szMsg = fmt::format_text_resource(IDS_PARTY_INSERT_ERR_REJECTED);
				// 레벨 차이가 너무 난다...
				else if (-2 == iIDorErrorCode)
					szMsg = fmt::format_text_resource(IDS_PARTY_INSERT_ERR_LEVEL_DIFFERENCE);
				// 파티를 맺을 수 없는 국가이다.
				else if (-3 == iIDorErrorCode)
					szMsg = fmt::format_text_resource(IDS_PARTY_INSERT_ERR_INVALID_NATION);
				// 상대방이 파티에 들어오기를 거절 하였다..
				else
					szMsg = fmt::format_text_resource(IDS_PARTY_INSERT_ERR);

				MsgOutput(szMsg, D3DCOLOR_ARGB(255, 255, 255, 255));
				if (m_pUIPartyOrForce->MemberCount() == 1) m_pUIPartyOrForce->MemberDestroy(); // 멤버가 한명이면 내가 파티를 만든 경우다.
			}
			
			this->UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.
		}
		break;
	
		case N3_SP_PARTY_OR_FORCE_REMOVE:			// 0x04	// Send - s1(ID) | Recv - s1(ID) - 
		{
			int iID			= pkt.read<int16_t>();

			if (iID == s_pPlayer->IDNumber())
			{
				std::string szMsg = fmt::format_text_resource(IDS_PARTY_DESTROY); // 파티를 떠났다..
				this->MsgOutput(szMsg, D3DCOLOR_ARGB(255, 255, 255, 255));  // 파티 해제 메시지
				m_pUIPartyOrForce->MemberDestroy(); // 자기 자신이면.. 파티를 뽀갠다..
			}
			else
			{
				int iMemberIndex = -1;
				const __InfoPartyOrForce* pInfo = m_pUIPartyOrForce->MemberInfoGetByID(iID, iMemberIndex);
				if (pInfo)
				{
					std::string szMsg = fmt::format_text_resource(IDS_PARTY_LEAVE); // 파티를 떠났다..
					this->MsgOutput(pInfo->szID + szMsg, D3DCOLOR_ARGB(255, 255, 255, 255)); // 누가 파티에서 떠났다는 메시지..
					m_pUIPartyOrForce->MemberRemove(iID); // 남이면..
				}
			}

			this->UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.
		}
		break;
		
		case N3_SP_PARTY_OR_FORCE_DESTROY:			// 0x05	// Send
		{
			m_pUIPartyOrForce->MemberDestroy(); // 파티 뽀갠다..

			std::string szMsg = fmt::format_text_resource(IDS_PARTY_DESTROY);
			this->MsgOutput(szMsg, D3DCOLOR_ARGB(255,255,255,255));

			this->UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.
		}
		break;

		case N3_SP_PARTY_OR_FORCE_HP_CHANGE:		// 0x06	// Recv - s3(ID, HPMax, HP, iMPMax, MP) - 자기 자신이면 파티를 깨야 한다..
		{
			int iID			= pkt.read<int16_t>();
			int iHPMax		= pkt.read<int16_t>();
			int iHP			= pkt.read<int16_t>();
			int iMPMax		= pkt.read<int16_t>();
			int iMP			= pkt.read<int16_t>();

			m_pUIPartyOrForce->MemberHPChange(iID, iHP, iHPMax, iMP, iMPMax);
		}
		break;
		
		case N3_SP_PARTY_OR_FORCE_LEVEL_CHANGE:		// 0x07	// Recv - s1(ID), b1(Level)
		{
			int iID			= pkt.read<int16_t>();
			int iLevel		= pkt.read<uint8_t>();

			m_pUIPartyOrForce->MemberLevelChange(iID, iLevel);
		}
		break;
		
		case N3_SP_PARTY_OR_FORCE_CLASS_CHANGE:		// 0x08	// Recv - s1(ID), b1(Class)드물지만 전직할때...
		{
			int iID			= pkt.read<int16_t>();
			e_Class eClass	= (e_Class)(pkt.read<int16_t>());

			m_pUIPartyOrForce->MemberClassChange(iID, eClass);
		}
		break;
		
		case N3_SP_PARTY_OR_FORCE_STATUS_CHANGE:	// 0x09	// Recv - s1(ID), b1(Status)...독, 저주, 지속성마법, 축복
		{
			int iID	=			pkt.read<int16_t>();
			e_PartyStatus ePS =	(e_PartyStatus)pkt.read<uint8_t>();
			int iSuffer = 		pkt.read<uint8_t>();
			bool bSuffer = (iSuffer) ? true : false; 

			m_pUIPartyOrForce->MemberStatusChange(iID, ePS, bSuffer);
		}
		break;
	}
}

void CGameProcMain::CommandSitDown(bool bLimitInterval, bool bSitDown, bool bImmediately)
{
	if(bSitDown == s_pPlayer->m_bSitDown) return; // 상태가 같으면 돌아간다..

	// 앉기 서기 제한..
	if(bLimitInterval)
	{
		float fTime = CN3Base::TimeGet();
		static float fTimePrev = fTime - 4.0f;
		if(fTime - fTimePrev < 3.0f) return;
		fTimePrev = fTime;
	}

	e_StateAction eSA = s_pPlayer->State();
	e_StateMove eSM = s_pPlayer->StateMove();

	if(bSitDown)
	{
		if(eSM != PSM_STOP) // 뛰던 놈이면 멈춘다.
			return;

		if(this->m_pMagicSkillMng->IsCasting()) // 스킬 캐스팅 중이면 앉지 못한다..
			return;

		if(s_pPlayer->m_bAttackContinous) // 계속 공격하는 중이면..
			this->CommandEnableAttackContinous(false, nullptr); // 계속 공격 취소..
	}

	bool bVBs[2] = { false, false };
	int iState = 0;
	if(bSitDown)
	{
		eSA = PSA_SITDOWN;
		bVBs[0] = false; bVBs[1] = true;
		iState = 0x02;
	} // 앉는 경우
	else
	{
		eSA = PSA_BASIC;
		bVBs[0] = true; bVBs[1] = false;
		iState = 0x01;
	} // 일어서는 경우
	
	s_pPlayer->m_bSitDown = bSitDown;
	s_pPlayer->Action(eSA, true, nullptr, bImmediately);

	if(m_pUICmd->m_pBtn_Act_SitDown)
	{
		m_pUICmd->m_pBtn_Act_SitDown->SetVisible(bVBs[0]);
		m_pUICmd->m_pBtn_Act_SitDown->SetState(UI_STATE_BUTTON_DOWN); // 버튼 누름
	}
	if(m_pUICmd->m_pBtn_Act_StandUp)
	{
		m_pUICmd->m_pBtn_Act_StandUp->SetVisible(bVBs[1]);
		m_pUICmd->m_pBtn_Act_StandUp->SetState(UI_STATE_BUTTON_DOWN); // 버튼 누름
	}

	this->MsgSend_StateChange(N3_SP_STATE_CHANGE_SITDOWN, iState); // 앉았다.. 패킷..
}

// 가장 가까운 적 타겟 잡기..
void CGameProcMain::CommandTargetSelect_NearestEnemy()
{
	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByNearestEnemy(s_pPlayer->Position());
	TargetSelect(pTarget);
	s_pPlayer->RotateTo(pTarget);
}

// 가장 가까운 파티 타겟잡기..
void CGameProcMain::CommandTargetSelect_NearestOurForce()
{
	CPlayerOther* pTarget = m_pUIPartyOrForce->MemberGetByNearst(s_pPlayer->Position());
	TargetSelect(pTarget);
	s_pPlayer->RotateTo(pTarget);
}

// select closest NPC
void CGameProcMain::CommandTargetSelect_NearestNPC()
{
	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByNearestNPC(s_pPlayer->Position());
	TargetSelect(pTarget);
	s_pPlayer->RotateTo(pTarget);
}

void CGameProcMain::CloseUIs()
{
}

void CGameProcMain::MsgSend_StateChange(e_SubPacket_State eSP, int iState)
{
	uint8_t byBuff[4];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_STATE_CHANGE);	// 상태 변화..
	CAPISocket::MP_AddByte(byBuff, iOffset, eSP);
	CAPISocket::MP_AddShort(byBuff, iOffset, iState);//CAPISocket::MP_AddByte(byBuff, iOffset, iState);

	s_pSocket->Send(byBuff, iOffset);	
}

void CGameProcMain::MsgSend_PerTradeReq(int iDestID, bool bNear)
{
	uint8_t byBuff[4];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_REQ);		
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iDestID );			// 상대방 아이디..
	if(bNear)
		CAPISocket::MP_AddByte(byBuff, iOffset, 1);
	else
		CAPISocket::MP_AddByte(byBuff, iOffset, 2);
	//1:일반 거래
	//2:상거래 게시판 거래

	s_pSocket->Send(byBuff, iOffset);									// 보냄..

	//TRACE("아이디: %d, 아이템 거래 신청 패킷 보냄.. \n", iDestID);
}

void CGameProcMain::MsgRecv_PerTrade(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();
	int16_t	sOtherID, sItemCount, sCount, sDurability;
	uint8_t	bResult, bItemPos;
	int		iItemID, iCount, iTotalGold;

	switch ( bSubCom )
	{
		case N3_SP_PER_TRADE_REQ:
			//TRACE("아이템 거래 신청 패킷 받음.. \n");
			sOtherID = pkt.read<int16_t>();	

			if (m_pUITransactionDlg->IsVisible()) 	/* 상인과 거래중이면.. */
			{
				// 거절한다..
				m_pUITransactionDlg->LeaveTransactionState();
				m_pSubProcPerTrade->LeavePerTradeState(PER_TRADE_RESULT_MY_DISAGREE);
				break;
			}

			if (m_pUIWareHouseDlg->IsVisible()) 	/* 보관함에 보관중이면.. */
			{
				// 거절한다..
				m_pUIWareHouseDlg->LeaveWareHouseState();
				m_pSubProcPerTrade->LeavePerTradeState(PER_TRADE_RESULT_MY_DISAGREE);
				break;
			}

			if ( m_pUIInventory->IsVisible() )
				m_pUIInventory->Close();

			if (m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE)
			{
				std::string stdMsg = fmt::format_text_resource(IDS_PER_TRADEING_OTHER);
				MsgOutput(stdMsg, 0xff9b9bff);
				break;
			}

			if (m_pUIQuestMenu->IsVisible())
				m_pUIQuestMenu->SetVisible(false);

			if (m_pUIQuestTalk->IsVisible())
				m_pUIQuestTalk->SetVisible(false);

			if (m_pUINpcEvent->IsVisible())
				m_pUINpcEvent->Close();

			if (m_pUITradeBBSSelector->IsVisible())
				m_pUITradeBBSSelector->SetVisible(false);

			if(m_pUITradeBBS->IsVisible())
				m_pUITradeBBS->SetVisible(false);

			m_pSubProcPerTrade->ReceiveMsgPerTradeReq(sOtherID);
			break;


		case N3_SP_PER_TRADE_AGREE:
			bResult = pkt.read<uint8_t>();
			m_pSubProcPerTrade->ReceiveMsgPerTradeAgree(bResult);
			break;

		case N3_SP_PER_TRADE_ADD:
			bResult = pkt.read<uint8_t>();
			m_pSubProcPerTrade->ReceiveMsgPerTradeAdd(bResult);
			break;

		case N3_SP_PER_TRADE_OTHER_ADD:
			iItemID = pkt.read<uint32_t>();
			iCount  = pkt.read<uint32_t>();
			sDurability = pkt.read<int16_t>();
			m_pSubProcPerTrade->ReceiveMsgPerTradeOtherAdd(iItemID, iCount, (int)sDurability);			
			break;

		case N3_SP_PER_TRADE_OTHER_DECIDE:
			m_pSubProcPerTrade->ReceiveMsgPerTradeOtherDecide();
			break;

		case N3_SP_PER_TRADE_DONE:
			bResult = pkt.read<uint8_t>();
			if ( bResult == 0x01 )		// 성공이면..
			{	
				iTotalGold = pkt.read<uint32_t>();
				m_pSubProcPerTrade->ReceiveMsgPerTradeDoneSuccessBegin(iTotalGold);
				sItemCount = pkt.read<int16_t>();
				for( int i = 0; i < sItemCount; i++ )
				{
					bItemPos = pkt.read<uint8_t>();	
					iItemID = pkt.read<uint32_t>();
					sCount  = pkt.read<int16_t>();	
					sDurability = pkt.read<int16_t>();
					m_pSubProcPerTrade->ReceiveMsgPerTradeDoneItemMove(bItemPos, iItemID, sCount, sDurability);					
				}
				m_pSubProcPerTrade->ReceiveMsgPerTradeDoneSuccessEnd();
			}
			else						// 실패이면..
				m_pSubProcPerTrade->ReceiveMsgPerTradeDoneFail();
			break;

		case N3_SP_PER_TRADE_CANCEL:
				m_pSubProcPerTrade->ReceiveMsgPerTradeCancel();
			break;
	}
}

void CGameProcMain::TargetSelect(int iID, bool bMustAlive)
{
	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(iID, bMustAlive);
	this->TargetSelect(pTarget);
}

void CGameProcMain::TargetSelect(CPlayerNPC* pTarget)
{
	if(PSA_SPELLMAGIC == s_pPlayer->State()) // 마법 캐스팅을 하는 중간에는 타겟을 못 바꾼다..
		return;

	int iIDTargetPrev = s_pPlayer->m_iIDTarget; // 전의 타겟 기억..
	s_pPlayer->m_iIDTarget = -1;
	s_pPlayer->m_pObjectTarget = nullptr;

	if(pTarget && pTarget->m_InfoBase.iAuthority != AUTHORITY_MANAGER)
	{ //운영자는 포커스를 주지 않게 하기 위해서...
		s_pPlayer->m_iIDTarget = pTarget->IDNumber();
		if(iIDTargetPrev != s_pPlayer->m_iIDTarget) // 전의 타겟과 다르면
		{
			this->CommandEnableAttackContinous(false, nullptr);	// 자동 공격 취소..

			D3DCOLOR crID = 0xffffffff;
			if(	pTarget->PlayerType() == PLAYER_OTHER) // User..
			{
				if(pTarget->m_InfoBase.eNation != s_pPlayer->m_InfoBase.eNation) crID = 0xffff4040; // 다른 국가이면
				else crID = 0xff6b9fff;
			}
			else // NPC
			{
				if(pTarget->m_InfoBase.eNation != s_pPlayer->m_InfoBase.eNation) crID = 0xffff6060; // 다른 국가이면
				else crID = 0xff1064ff;
			}
			
			if( pTarget->IsAlive() )//살아있는 상태만 target bar를 보여준다.
			{
				m_pUITargetBar->SetVisible(true);
				m_pUITargetBar->SetIDString(pTarget->IDString(), crID); // 이름을 넣고..
				this->MsgSend_RequestTargetHP(s_pPlayer->m_iIDTarget, 0x01);	// 서버에게 HP정보를 요청한다..
			}
			else
			{
				m_pUITargetBar->SetVisible(false); // 타겟 바 없애기..
			}
		}
	}
	else
	{
		s_pPlayer->m_iIDTarget = -1; // 타겟 아이디를 잡고..
		m_pUITargetBar->SetVisible(false); // 타겟 바 없애기..

		this->CommandEnableAttackContinous(false, nullptr); // 자동 공격 취소..
	}

	if(	PSA_SITDOWN != s_pPlayer->State() && 
		PSM_STOP == s_pPlayer->StateMove() &&
		PSA_BASIC == s_pPlayer->State()) s_pPlayer->Action(PSA_BASIC, true); // 기본 자세 바꾸기..

	this->UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.
}

void CGameProcMain::MsgRecv_SkillChange(Packet& pkt)			// 스킬 변화..
{
	int iType	= pkt.read<uint8_t>();
	int iValue	= pkt.read<uint8_t>();

	m_pUISkillTreeDlg->m_iSkillInfo[iType] = iValue;
	m_pUISkillTreeDlg->m_iSkillInfo[0]++;
	m_pUISkillTreeDlg->InitIconUpdate();		// 스킬 포인트가 변화되었으므로 .. 스킬도 변화될 수 있다..
}

void CGameProcMain::MsgRecv_MagicProcess(Packet& pkt)
{
	e_SubPacket_Magic eSP = (e_SubPacket_Magic)pkt.read<uint8_t>();
	
	switch ( eSP )
	{
	case N3_SP_MAGIC_CASTING:
		m_pMagicSkillMng->MsgRecv_Casting(pkt);
		break;
	case N3_SP_MAGIC_FLYING:
		m_pMagicSkillMng->MsgRecv_Flying(pkt);
		break;
	case N3_SP_MAGIC_EFFECTING:
		m_pMagicSkillMng->MsgRecv_Effecting(pkt);
		break;
	case N3_SP_MAGIC_FAIL:
		m_pMagicSkillMng->MsgRecv_Fail(pkt);
		break;
	case N3_SP_MAGIC_TYPE4BUFFTYPE:
		m_pMagicSkillMng->MsgRecv_BuffType(pkt);
		break;
	}	
}

void CGameProcMain::MsgRecv_ClassChange(Packet& pkt)			// 직업 변화..
{
	e_SubPacket_ClassChange eSP = (e_SubPacket_ClassChange)pkt.read<uint8_t>();

	switch ( eSP )
	{
		case N3_SP_CLASS_CHANGE_SUCCESS:		// Success..
			m_pUIClassChange->Open(N3_SP_CLASS_CHANGE_SUCCESS);
			break;

		case N3_SP_CLASS_CHANGE_NOT_YET:		// Not Yet..
			m_pUIClassChange->Open(N3_SP_CLASS_CHANGE_NOT_YET);
			break;

		case N3_SP_CLASS_CHANGE_ALREADY:		// Already..
			m_pUIClassChange->Open(N3_SP_CLASS_CHANGE_ALREADY);
			break;

		case N3_SP_CLASS_CHANGE_FAILURE:		// Failure..
			m_pUIClassChange->RestorePrevClass();
			break;
	}
}

void CGameProcMain::MsgRecv_ObjectEvent(Packet& pkt)
{
	int iType = pkt.read<uint8_t>();		// Event Type
	int iResult = pkt.read<uint8_t>();

	if (iType == OBJECT_TYPE_BINDPOINT)
	{
		std::string szMsg;
		if (iResult == 1)
			szMsg = fmt::format_text_resource(IDS_BIND_POINT_FAILED);
		MsgOutput(szMsg, 0xff00ff00);
	}
	else if (iType == OBJECT_TYPE_DOOR_LEFTRIGHT
		|| iType == OBJECT_TYPE_DOOR_TOPDOWN
		|| iType == OBJECT_TYPE_LEVER_TOPDOWN
		|| iType == OBJECT_TYPE_FLAG)
	{
		int iID = pkt.read<int16_t>();	// 열고 닫을 성문 ID
		int iActivate = pkt.read<uint8_t>();	// 열고 닫음..

		CPlayerNPC* pNPC = s_pOPMgr->NPCGetByID(iID, true);
		__ASSERT(pNPC, "Invalid NPC ID");
		if (pNPC != nullptr)
		{
			__ASSERT(pNPC->m_pShapeExtraRef && (pNPC->m_pShapeExtraRef->Type() & OBJ_SHAPE_EXTRA), "Invalid object!!");
			std::string szMsg = "Object Event - invalid object!!";
			if (pNPC->m_pShapeExtraRef)
			{
				__Vector3 vAxis(0, 1, 0);
				float fRadian = DegreesToRadians(90);
				bool bShouldBeRotate = true; // 돌려야 하는지??
				if (OBJECT_TYPE_DOOR_LEFTRIGHT == iType) // 좌우열림 성문
				{
					if (0x01 == iActivate)
					{
						fRadian = DegreesToRadians(80);
						szMsg = fmt::format_text_resource(IDS_DOOR_OPENED);
					}
					else
					{
						fRadian = DegreesToRadians(0);
						szMsg = fmt::format_text_resource(IDS_DOOR_CLOSED);
					}
					vAxis.Set(0, 1, 0);
				}
				else if (OBJECT_TYPE_DOOR_TOPDOWN == iType) // 상하열림 성문
				{
					if (0x01 == iActivate)
					{
						fRadian = DegreesToRadians(90);
						szMsg = fmt::format_text_resource(IDS_DOOR_OPENED);
					}
					else
					{
						DegreesToRadians(0);
						szMsg = fmt::format_text_resource(IDS_DOOR_CLOSED);
					}
					vAxis.Set(0, 0, 1);
				}
				else if (OBJECT_TYPE_LEVER_TOPDOWN == iType) // 상하 레버
				{
					if (0x01 == iActivate)
					{
						fRadian = DegreesToRadians(-45);
						szMsg = fmt::format_text_resource(IDS_LEVER_ACTIVATE);
					}
					else
					{
						fRadian = DegreesToRadians(45);
						szMsg = fmt::format_text_resource(IDS_LEVER_DEACTIVATE);
					}
					vAxis.Set(1, 0, 0);
				}
				else if (OBJECT_TYPE_FLAG == iType)
				{
					bShouldBeRotate = false; // 돌려야 하는지??
				}

				if (0x01 == iActivate)
				{
				}
				else // if(0x00 == iActivate);
				{
					szMsg = fmt::format_text_resource(IDS_DOOR_CLOSED);
				}

				CN3ShapeExtra* pSE = (CN3ShapeExtra*) pNPC->m_pShapeExtraRef;
				if (bShouldBeRotate)
				{
					pSE->RotateTo(0, vAxis, fRadian, 1);
					pSE->RotateTo(1, vAxis, -fRadian, 1);
				}
				else
				{
					if (iActivate) pSE->m_bVisible = true;
					else pSE->m_bVisible = false;
				}
			}
			MsgOutput(szMsg, 0xff00ff00);
		}
	}
	else if (iType == OBJECT_TYPE_WARP_POINT)
	{
		std::string szMsg;
		if (iResult == 0)
			szMsg = fmt::format_text_resource(IDS_WARP_WRONG_GATE);
		MsgOutput(szMsg, 0xff00ff00);
	}
	else
	{
		__ASSERT(0, "Unknown Object Event");
	}
}

void CGameProcMain::RequestExit()
{
	if (m_pUIExitMenu != nullptr)
		m_pUIExitMenu->SetVisible(true);
}

void CGameProcMain::ParseChattingCommand(const std::string& szCmd)
{
	static char szCmds[4][1024] = { "", "", "", "" };
	static uint8_t byBuff[1024] = "";
	sscanf(szCmd.c_str(), "/%s %s %s %s", szCmds[0], szCmds[1], szCmds[2], szCmds[3]);

	if(0 == lstrcmp(szCmds[0], "goto"))
	{
		float fX = (float)atof(szCmds[1]);
		float fZ = (float)atof(szCmds[2]);
		
		int iOffset = 0;
		CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WARP);
		CAPISocket::MP_AddWord(byBuff, iOffset, (uint16_t)(fX * 10));
		CAPISocket::MP_AddWord(byBuff, iOffset, (uint16_t)(fZ * 10));

		s_pSocket->Send(byBuff, iOffset);
	}
	
	e_ChatCmd eCmd = CMD_UNKNOWN;
	for(int i = 0; i < CMD_COUNT; i++)
	{
		if(0 == lstrcmpi(szCmds[0], g_szCmdMsg[i].c_str()))
		{
			eCmd = (e_ChatCmd)i;
			break;
		}
	}

	switch(eCmd)
	{
		case CMD_WHISPER:
		{
			this->MsgSend_ChatSelectTarget(szCmds[1]); // 일대일 채팅 상대 정하기.
		}
		break;

		case CMD_TOWN:
		{
			if(s_pPlayer->m_bStun) return; // 기절해 있음 못함..
			if(s_pPlayer->m_InfoBase.iHP * 2 >= s_pPlayer->m_InfoBase.iHPMax) // HP가 반 이상 있어야 한다.
			{
				// NOTE(srmeier): currently there is an issue where OtherPlayers may get
				// duplicated in the player manager if they where there before the TP

				int iOffset = 0;
				CAPISocket::MP_AddWord(byBuff, iOffset, WIZ_HOME);		// 마을로 가기...
				s_pSocket->Send(byBuff, iOffset);
			}
			else // HP가 반 이상 있어야 한다.
			{
				std::string szMsg = fmt::format_text_resource(IDS_ERR_GOTO_TOWN_OUT_OF_HP);
				this->MsgOutput(szMsg, 0xffff00ff);
			}
		}
		break;

		case CMD_TRADE:
		{
			CPlayerOther* pOPC = s_pOPMgr->UPCGetByID(s_pPlayer->m_iIDTarget, true);

			// 타겟으로 다른 플레이어가 잡혀있고..  가까이 있으면..
			if (pOPC != nullptr
				&& (pOPC->Position() - s_pPlayer->Position()).Magnitude() < (pOPC->Height() + 5.0f)
				// 개인간 아이템 거래..
				// 상거래 중이 아니면..
				&& !m_pUITransactionDlg->IsVisible())
			{
				if (s_pPlayer->Nation() != pOPC->Nation()
					&& !s_pPlayer->m_InfoExt.bCanTradeWithOtherNation)
					return;

				std::string szMsg = fmt::format_text_resource(IDS_PERSONAL_TRADE_REQUEST);
				MsgOutput(pOPC->IDString() + szMsg, 0xffffff00);

				MsgSend_PerTradeReq(pOPC->IDNumber());
				
				if (m_pUINpcEvent->IsVisible())
					m_pUINpcEvent->Close();

				if (m_pUIQuestTalk->IsVisible())
					m_pUIQuestTalk->SetVisible(false);

				if (m_pUIQuestMenu->IsVisible())
					m_pUIQuestMenu->SetVisible(false);

				m_pSubProcPerTrade->EnterWaitMsgFromServerStatePerTradeReq();
			}
		}
		break;

		case CMD_EXIT:
		{
			RequestExit();
		}
		break;

		case CMD_PARTY:
		{
			CPlayerBase* pTarget = s_pOPMgr->UPCGetByID(s_pPlayer->m_iIDTarget, true);
			if (pTarget != nullptr)
			{
				std::string szMsg;
				if (this->MsgSend_PartyOrForceCreate(0, pTarget->IDString()))
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE); // 파티 요청.. 
				else
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE_FAILED); // 파티 초대 실패
				this->MsgOutput(pTarget->IDString() + szMsg, 0xffffff00);
			}
		}
		break;

		case CMD_LEAVEPARTY:
		{
			this->MsgSend_PartyOrForceLeave(0); // 파티 요청..
		}
		break;

		case CMD_RECRUITPARTY:
		{
			if(m_pUIPartyBBS)
			{
				if(s_pPlayer->m_bRecruitParty)
				{
					m_pUIPartyBBS->MsgSend_RegisterCancel();
				}
				else
				{
					m_pUIPartyBBS->MsgSend_Register();
				}
			}

//			if(m_pUIPartyBBS && !m_pUIPartyBBS->IsVisible())
//			m_pUIPartyBBS->MsgSend_RefreshData(0);
		}
		break;

		case CMD_JOINCLAN:
		{
			if(s_pPlayer->m_InfoExt.eKnightsDuty == KNIGHTS_DUTY_CHIEF ||
				s_pPlayer->m_InfoExt.eKnightsDuty == KNIGHTS_DUTY_VICECHIEF)
			{			
				this->MsgSend_KnightsJoin(s_pPlayer->m_iIDTarget);
			}
		}
		break;

		case CMD_WITHDRAWCLAN:
		{
			this->MsgSend_KnightsWithdraw();
		}
		break;

		case CMD_FIRECLAN:
		{
			if(s_pPlayer->m_InfoExt.eKnightsDuty == KNIGHTS_DUTY_CHIEF)
			{
				std::string szName = szCmds[1];
				MsgSend_KnightsLeave(szName);			
			}
		}
		break;

		case CMD_APPOINTVICECHIEF:
		{
			if(s_pPlayer->m_InfoExt.eKnightsDuty == KNIGHTS_DUTY_CHIEF)
			{
				std::string szName = szCmds[1];
				MsgSend_KnightsAppointViceChief(szName);
			}
		}
		break;

		case CMD_GREETING:
		case CMD_GREETING2:
		case CMD_GREETING3:
		{
			if(	s_pPlayer->State() == PSA_BASIC && 
				s_pPlayer->StateMove() == PSM_STOP )
			{
				this->MsgSend_StateChange(N3_SP_STATE_CHANGE_ACTION, 1 + (eCmd - CMD_GREETING));
			}
		}
		break;

		case CMD_PROVOKE:
		case CMD_PROVOKE2:
		case CMD_PROVOKE3:
		{
			if(	s_pPlayer->State() == PSA_BASIC && 
				s_pPlayer->StateMove() == PSM_STOP )
			{
				this->MsgSend_StateChange(N3_SP_STATE_CHANGE_ACTION, 11 + (eCmd - CMD_PROVOKE));
			}
		}
		break;

		case CMD_VISIBLE:
		{
			this->MsgSend_StateChange(N3_SP_STATE_CHANGE_VISIBLE, 0);
		}
		break;

		case CMD_INVISIBLE:
		{
			this->MsgSend_StateChange(N3_SP_STATE_CHANGE_VISIBLE, 255);
		}
		break;

		case CMD_CLEAN:
		{
			int iPercent = atoi(szCmds[1]);
			this->MsgSend_Weather(1, iPercent);
		}
		break;

		case CMD_RAINING:
		{
			int iPercent = atoi(szCmds[1]);
			this->MsgSend_Weather(2, iPercent);
		}
		break;

		case CMD_SNOWING:
		{
			int iPercent = atoi(szCmds[1]);
			this->MsgSend_Weather(3, iPercent);
		}
		break;

		case CMD_TIME:
		{
			int iHour = atoi(szCmds[1]);
			int iMin = atoi(szCmds[2]);
			this->MsgSend_Time(iHour, iMin);
		}
		break;

		case CMD_CU_COUNT:
		{
			int iOffset=0;
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CONCURRENTUSER); 
			s_pSocket->Send(byBuff, iOffset);
		}
		break;

		case CMD_NOTICE:
		{
			if(szCmd.size() >= (g_szCmdMsg[CMD_NOTICE].size()+2))//7)
			{
				std::string szChat = szCmd.substr(g_szCmdMsg[CMD_NOTICE].size()+2); // "/공지 "를 제외한 나머지 문자열
				this->MsgSend_Chat(N3_CHAT_PUBLIC, szChat);
			}
		}
		break;

		case CMD_ARREST:
		{
			this->MsgSend_Administrator(N3_SP_ADMINISTRATOR_ARREST, szCmds[1]); //추적		
		}
		break;

		case CMD_FORBIDCONNECT:
		{
			this->MsgSend_Administrator(N3_SP_ADMINISTRATOR_FORBID_CONNECT, szCmds[1]); //접속금지		
		}
		break;
		
		case CMD_FORBIDCHAT:
		{
			this->MsgSend_Administrator(N3_SP_ADMINISTRATOR_CHAT_FORBID, szCmds[1]); //채팅금지		
		}
		break;
		
		case CMD_PERMITCHAT:
		{
			this->MsgSend_Administrator(N3_SP_ADMINISTRATOR_CHAT_PERMIT, szCmds[1]); //채팅허가		
		}
		break;
		
		case CMD_GAME_SAVE:
		{
			if(m_fRequestGameSave > 300.0f)
			{
				uint8_t byBuff[4];												// 버퍼.. 
				int iOffset=0;												// 옵셋..
				s_pSocket->MP_AddByte(byBuff, iOffset, WIZ_DATASAVE);	// 저장 요청 커멘드..
				s_pSocket->Send(byBuff, iOffset);				// 보냄..
				m_fRequestGameSave = 0.0f;

				std::string szMsg = fmt::format_text_resource(IDS_REQUEST_GAME_SAVE);
				MsgOutput(szMsg, 0xffffff00);
			}
			else
			{
				std::string szMsg = fmt::format_text_resource(IDS_DELAY_GAME_SAVE, 5);
				MsgOutput(szMsg, 0xffffff00);
			}
		}
		break;

		default:
		break;
	} // end of switch(eCmd)

	// Clears out the strings from the szCmds so we won't re-send same values on the next command execution.
	memset(szCmds, 0, sizeof(szCmds));
}

void CGameProcMain::UpdateUI_PartyOrForceButtons()
{
	// 파티 버튼 상태 바꾸기..
	CPlayerBase* pTarget = nullptr;
	bool bIAmLeader = false, bIAmMemberOfParty = false;
	int iMemberIndex = -1;
	this->PartyOrForceConditionGet(bIAmLeader, bIAmMemberOfParty, iMemberIndex, pTarget);
	m_pUIPartyOrForce->MemberSelect(iMemberIndex);

	m_pUICmd->UpdatePartyButtons(bIAmLeader, bIAmMemberOfParty, iMemberIndex, pTarget);
}

const __InfoPartyOrForce* CGameProcMain::PartyOrForceConditionGet(bool& bIAmLeader, bool& bIAmMember, int& iMemberIndex, class CPlayerBase*& pTarget)
{
	// 파티 버튼 상태 바꾸기..
	bIAmLeader = false;
	iMemberIndex = -1;
	bIAmMember = false;
	pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, true);

	if(m_pUIPartyOrForce->MemberCount() >= 2)
	{
		bIAmMember = true;
		if(m_pUIPartyOrForce->MemberInfoGetByIndex(0)->iID == s_pPlayer->IDNumber()) bIAmLeader = true;
		return m_pUIPartyOrForce->MemberInfoGetByID(s_pPlayer->m_iIDTarget, iMemberIndex);
	}

	return nullptr;
}

void CGameProcMain::UpdateUI_MiniMap()
{
	if(nullptr == m_pUIStateBarAndMiniMap || !m_pUIStateBarAndMiniMap->IsVisible()) return;


	m_pUIStateBarAndMiniMap->PositionInfoClear();

	D3DCOLOR crType = 0xffffffff;

	it_NPC it = s_pOPMgr->m_NPCs.begin(), itEnd = s_pOPMgr->m_NPCs.end();
	CPlayerNPC* pNPC = nullptr;
	for(; it != itEnd; it++) // NPC
	{
		pNPC = it->second;

		if (s_pPlayer->IsHostileTarget(pNPC))
			crType = 0xff800000; // 다른 국가 NPC 혹은 몬스터 주황색
		else
			crType = 0xff00a0ff; // 같은 국가 NPC 하늘색

		m_pUIStateBarAndMiniMap->PositionInfoAdd(pNPC->IDNumber(), pNPC->Position(), crType, false);
	}

	it_UPC it2 = s_pOPMgr->m_UPCs.begin(), itEnd2 = s_pOPMgr->m_UPCs.end();
	CPlayerOther* pUPC = nullptr;
	__TABLE_ZONE* pZoneInfo = s_pTbl_Zones.Find(s_pPlayer->m_InfoExt.iZoneCur);
	for(; it2 != itEnd2; it2++) // User
	{
		pUPC = it2->second;

		bool bDrawTop = false;
		// 적국일경우
		if (s_pPlayer->IsHostileTarget(pUPC))
		{
			if(pUPC->State() == PSA_SITDOWN)
			{
				pUPC->m_InfoBase.bRenderID = false; // 아이디 표시하지 않음.
				continue; // 앉아있으면.. 지나간다..
			}
			else
			{
				pUPC->m_InfoBase.bRenderID = true; // 아이디 표시함.
			}

			if(pZoneInfo && FALSE == pZoneInfo->bIndicateEnemyPlayer) continue; // 적국이 표시 되지 않아야 한다면.. 지나간다..
			
			crType = 0xffff4040; // 다른 국가  - 밝은 빨간색
		}
		else // 같은 국가면..
		{
			int iMemberIndex = -1;
			const __InfoPartyOrForce* pPI = m_pUIPartyOrForce->MemberInfoGetByID(pUPC->IDNumber(), iMemberIndex);
			if(pPI)
			{
				bDrawTop = true; // 맨 위에 그린다.
				crType = 0xffffff00; // 파티 멤버면 // 노란색
			}
			else
			{
				crType = 0xff0040ff; // 파티 멤버가 아니면 밝은 파란색
			}
		}

		if(pUPC && pUPC->m_InfoBase.iAuthority != AUTHORITY_MANAGER)	// 운영자가 아닌경우만 미니맵에 포인트를 찍어준다.
			m_pUIStateBarAndMiniMap->PositionInfoAdd(pUPC->IDNumber(), pUPC->Position(), crType, bDrawTop);
	}
}

void CGameProcMain::UpdateUI_TargetBar()
{
	if(nullptr == m_pUITargetBar || !m_pUITargetBar->IsVisible()) return;

	//죽은 캐릭터가 선택되었을때는 target bar를 그려주지 않는다.
	CPlayerNPC* t_pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, false);
	if( t_pTarget && t_pTarget->State() == PSA_DEATH )
	{
		m_pUITargetBar->SetVisible(false);
		return;
	}

	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, true);
	if(pTarget) // 타겟이 유효하면..
	{
		float fTimeTmp = CN3Base::TimeGet();
		if(fTimeTmp > m_pUITargetBar->m_fTimeSendPacketLast + PACKET_INTERVAL_REQUEST_TARGET_HP) // 1초가 지나면 타겟 정보 요청
		{
			this->MsgSend_RequestTargetHP(s_pPlayer->m_iIDTarget, false);
			m_pUITargetBar->m_fTimeSendPacketLast = fTimeTmp;
		}
	}
	else // 타겟이 없으면..
	{
		s_pPlayer->m_iIDTarget = -1;
		m_pUITargetBar->SetVisible(false);
	}
}

void CGameProcMain::UpdateBGM()
{
	if(	nullptr == m_pSnd_Battle || !m_pSnd_Battle->IsPlaying() ) return;

//	if(s_pPlayer->pTarget && s_pPlayer->pTarget->IsAlive()) 
	__Vector3 vPosPlayer = s_pPlayer->Position();

	bool bStopBattleBgm = true;
	CPlayerBase* pBPC;
	it_NPC it = s_pOPMgr->m_NPCs.begin(), itEnd = s_pOPMgr->m_NPCs.end();
	for(; it != itEnd && bStopBattleBgm; it++)
	{
		pBPC = it->second;
		if (!s_pPlayer->IsHostileTarget(pBPC))
			continue;

		if((vPosPlayer - pBPC->Position()).Magnitude() < 12.0f)
			bStopBattleBgm = false;
	}

	CPlayerOther* pUPC;
	it_UPC it2 = s_pOPMgr->m_UPCs.begin(), itEnd2 = s_pOPMgr->m_UPCs.end();
	for(; it2 != itEnd2 && bStopBattleBgm; it2++)
	{
		pUPC = it2->second;
		if (!s_pPlayer->IsHostileTarget(pUPC))
			continue;

		if((vPosPlayer - pUPC->Position()).Magnitude() < 12.0f)
			bStopBattleBgm = false;
	}

	if(bStopBattleBgm) this->PlayBGM_Town();
}

void CGameProcMain::UpdateCameraAndLight()
{
	__Vector3 vPosPlayer = s_pPlayer->Position();
	if(s_pPlayer->State() == PSA_SITDOWN)
	{
		float fRootY = s_pPlayer->RootPosition().y;
		float fH = s_pPlayer->Height();
		vPosPlayer.y += fRootY - (fH / 2.0f);
	}

	D3DCOLOR crDiffuses[MAX_GAME_LIGHT];
	D3DCOLOR crAmbients[MAX_GAME_LIGHT];
	for(int i = 0; i < MAX_GAME_LIGHT; i++)
	{
		crDiffuses[i] = ACT_WORLD->GetLightDiffuseColorWithSky(i);
		crAmbients[i] = ACT_WORLD->GetLightAmbientColorWithSky(i);
	}
	
	s_pEng->Tick(	crDiffuses, crAmbients, ACT_WORLD->GetFogColorWithSky(), 
					vPosPlayer, s_pPlayer->Rotation(),
					s_pPlayer->Height(), ACT_WORLD->GetSunAngleByRadinWithSky() );		// 캐릭터 위치와 해의 각도를 넣어준다..
	s_pEng->ApplyCameraAndLight();	// 카메라와 라이트에 세팅된 값을 D3D Device 에 적용한다.
}

void CGameProcMain::MsgRecv_DurabilityChange(Packet& pkt)		// 내구력 변경..
{
	e_ItemSlot eSlot = (e_ItemSlot)pkt.read<uint8_t>();	
	int iCurValue  = pkt.read<int16_t>();	

	s_pPlayer->DurabilitySet(eSlot, iCurValue);
	m_pUIInventory->DurabilityChange(eSlot, iCurValue);
}

void CGameProcMain::MsgRecv_NpcEvent(Packet& pkt)				// Npc Event(Exchange, Repair both).. 
{
	int iTradeID = pkt.read<uint32_t>();		// Trade id
	CPlayerNPC* pNPC = s_pOPMgr->NPCGetByID(s_pPlayer->m_iIDTarget, true);
	if (!pNPC)	return;

	m_pUINpcEvent->Open(NPC_EVENT_TRADE_REPAIR, iTradeID, pNPC->GetNPCOriginID());
}


void CGameProcMain::MsgRecv_Knights(Packet& pkt)
{
	e_SubPacket_Knights eSP = (e_SubPacket_Knights)(pkt.read<uint8_t>());	// Sub Packet

	switch(eSP)
	{
	case N3_SP_KNIGHTS_CREATE: // 생성..
		this->MsgRecv_Knights_Create(pkt);
		break;
	case N3_SP_KNIGHTS_WITHDRAW: //탈퇴
		this->MsgRecv_Knights_Withdraw(pkt);
		break;
	case N3_SP_KNIGHTS_JOIN: //가입
		this->MsgRecv_Knights_Join(pkt);
		break;
	case N3_SP_KNIGHTS_MEMBER_REMOVE: //멤버 삭제 - 
		this->MsgRecv_Knights_Leave(pkt);
		break;
	case N3_SP_KNIGHTS_APPOINT_VICECHIEF: //부단장 임명 - 가입허가와 같음
		this->MsgRecv_Knights_AppointViceChief(pkt);
 	break;
	case N3_SP_KNIGHTS_MEMBER_INFO_ALL:
		this->MsgRecv_Knights_MemberInfoAll(pkt);
		break;
	case N3_SP_KNIGHTS_GRADE_CHANGE_ALL:
		this->MsgRecv_Knights_GradeChangeAll(pkt);
		break;
	case N3_SP_KNIGHTS_DESTROY: // 뽀개기 Send - | Recv - b1(1:성공 0:실패)
		{
			uint8_t	bSubCom = pkt.read<uint8_t>();
			
			std::string szMsg;
			switch ( (e_SubPacket_KNights_Common)bSubCom )
			{
			case N3_SP_KNIGHTS_COMMON_SUCCESS: //클랜파괴 성공
				szMsg = fmt::format_text_resource(IDS_CLAN_WITHDRAW_SUCCESS);
				m_pUIKnightsOp->KnightsInfoDelete(s_pPlayer->m_InfoBase.iKnightsID);
				this->MsgOutput(szMsg, 0xffffff00);
				break;
			case N3_SP_KNIGHTS_COMMON_DBFAIL: //DB검색 실패..
			case N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER:	//없는 유저..
				break;
			}
			s_pPlayer->m_InfoExt.eKnightsDuty = KNIGHTS_DUTY_UNKNOWN;
			s_pPlayer->KnightsInfoSet(0, "", 0, 0);
			m_pUIVar->UpdateKnightsInfo();
		}
		break;
	case N3_SP_KNIGHTS_DUTY_CHANGE: // 직위 변경..
		MsgRecv_Knights_Duty_Change(pkt);
		break;
	case N3_SP_KNIGHTS_JOIN_REQ:
		MsgRecv_Knigts_Join_Req(pkt);
		break;

/*	case N3_SP_KNIGHTS_APPOINT_CHIEF: //단장 임명 - 가입허가와 같음
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_APPOINT_CHIEF_SUCCESS); // 성공
		}
		break;
	case N3_SP_KNIGHTS_DESTROY: // 뽀개기 Send - | Recv - b1(1:성공 0:실패)
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_DESTROY_SUCCESS); // 성공

			s_pPlayer->m_InfoBase.iKnightsID = 0;
			s_pPlayer->m_InfoExt.eKnightsDuty = KNIGHTS_DUTY_UNKNOWN;

			// 기사단에서 뺀다..
			m_pUIVar->m_pPageKnights->UpdateKnightsName("");
			m_pUIVar->m_pPageKnights->UpdateKnightsChiefName("");
			m_pUIVar->m_pPageKnights->UpdateKnightsDuty(KNIGHTS_DUTY_UNKNOWN);

			m_pUIKnightsOp->MsgSend_KnightsList(0); // 다시 기사단 리스트를 요청한다..
		}
		break;

	case N3_SP_KNIGHTS_MEMBER_JOIN_ADMIT: //멤버 가입 허가 Send - s1(Knights ID) | Recv - b1(1:성공 0:실패)
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_ADMIT_SUCCESS); // 성공
		}
		break;
	case N3_SP_KNIGHTS_MEMBER_JOIN_REJECT: //멤버 가입 거절 - 가입허가와 같음
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_REJECT_SUCCESS); // 성공
		}
		break;
	case N3_SP_KNIGHTS_MEMBER_PUNISH: //멤버 징계 - 가입허가와 같음
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_PUNISH_SUCCESS); // 성공
		}
		break;
	case N3_SP_KNIGHTS_APPOINT_OFFICER: // 장교임명 - 가입허가와 같음
		{
			szMsg = fmt::format_text_resource(IDS_KNIGHTS_APPOINT_OFFICER_SUCCESS); // 성공
		}
		break;
	case N3_SP_KNIGHTS_LIST: //모든 리스트 요청 Send - | s1(Knights Count) Loop { s1(Knights ID) s1(Name Length) str1 (Name) }
		{
			if(false == m_pUIKnightsOp->IsVisible())
			{
				m_pUIKnightsOp->Open(s_pPlayer->m_InfoExt.eKnightsDuty); // UI 열고 리스트등 초기화..
			}
			else 
			{
				m_pUIKnightsOp->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty); // UI 열고 리스트등 초기화..
			}
			m_pUIKnightsOp->MsgRecv_KnightsList(pkt);
		}
		break;
	case N3_SP_KNIGHTS_MEMBER_INFO_ALL: // 전체 멤버 Send - s1(page) | s1(Member Count) Loop { s1(Name Length) str1 (Name) }
		{
			m_pUIVar->m_pPageKnights->MsgRecv_MemberInfo(pkt);
		}
		break;
	case N3_SP_KNIGHTS_MEMBER_INFO_ONLINE: //현재 접속 리스트 Send - s1(page) | s1(Member Count) Loop { s1(Name Length) str1 (Name) }
		{
			m_pUIVar->m_pPageKnights->MsgRecv_MemberInfo(pkt);
		}
		break;
	case N3_SP_KNIGHTS_STASH: //기사단 창고
		{
		}
		break;
	case N3_SP_KNIGHTS_DUTY_CHANGE: // 직위 변경..
		{
			int iID = pkt.read<int16_t>();
			e_KnightsDuty eDuty = (e_KnightsDuty)pkt.read<uint8_t>();

			if(iID == s_pPlayer->IDNumber()) // 내 직위 변경..
			{
				m_pUIVar->m_pPageKnights->UpdateKnightsDuty(eDuty);
			}
			else
			{
				CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(iID, false);
				if(pUPC) // 다른넘 직위 변경..
				{
				}
			}
		}
		break;
	default:
		__ASSERT(0, "Invalid Knights SubPacket");
		break;
*/	}
}

void CGameProcMain::MsgRecv_KnightsListBasic(Packet& pkt) // 기사단 기본 정보 받기..
{
	e_SubPacket_KnightsList eSP = (e_SubPacket_KnightsList)(pkt.read<uint8_t>());	// Sub Packet
	switch(eSP)
	{
	case N3_SP_KNIGHTS_LIST_BASIC_ALL: // Receive - s1(knights Count) { s21(id, 이름길이), str1(이름) }
		{
			int iCount = pkt.read<int16_t>();	// 기사단 갯수
			for(int i = 0; i < iCount; i++)
			{
				std::string szID;
				int iID = pkt.read<int16_t>();		// 기사단 ID
				int iLen = pkt.read<int16_t>();		// ID 문자열 길이..
				pkt.readString(szID, iLen);	// ID 문자열..

				m_pUIKnightsOp->KnightsInfoInsert(iID, szID); // 기사단 정보 모든 걸 받는다..
			}
		}
		break;
	case N3_SP_KNIGHTS_LIST_BASIC_INSERT: // Receive - s2(id, 이름길이), str1(이름)
		{
			std::string szID;
			int iID = pkt.read<int16_t>();		// 기사단 ID
			int iLen = pkt.read<int16_t>();		// ID 문자열 길이..
			pkt.readString(szID, iLen);	// ID 문자열..

			m_pUIKnightsOp->KnightsInfoInsert(iID, szID); // 기사단 정보 추가..
		}
		break;
	case N3_SP_KNIGHTS_LIST_BASIC_REMOVE: // Receive - s1(id)
		{
			int iID = pkt.read<int16_t>();		// 기사단 ID
			m_pUIKnightsOp->KnightsInfoDelete(iID); // 기사단 정보 지우기..
		}
		break;
	}
}

void CGameProcMain::MsgRecv_ContinousPacket(Packet& pkt) // 압축된 데이터 이다... 한번 더 파싱해야 한다!!!
{
	uint16_t iWholeSize = pkt.read<uint16_t>();

	while (pkt.rpos() < iWholeSize)
	{
		uint16_t iSizeThisPacket = pkt.read<uint16_t>();

		if (iSizeThisPacket <= 0 || iSizeThisPacket >= iWholeSize)
		{
			__ASSERT(0, "Invalid continous packet");
			break; // 멈춘다!!
		}

		Packet tempPacket;
		tempPacket.readFrom(pkt, iSizeThisPacket);
		ProcessPacket(tempPacket);
	}
}

void CGameProcMain::MsgRecv_WareHouse(Packet& pkt)			// 보관함 관련 패킷..
{
	uint8_t	bResult, bSubCom = pkt.read<uint8_t>();

	switch ( (e_SubPacket_WareHouse)bSubCom )
	{
		case N3_SP_WARE_INN:
			m_pUIInn->SetVisible(true);
			break;

		case N3_SP_WARE_OPEN:
			MsgRecv_WareHouseOpen(pkt);
			break;

		case N3_SP_WARE_GET_IN:
			bResult = pkt.read<uint8_t>();	// 0x01 : true, 0x00 : false..
			if (m_pUIWareHouseDlg) m_pUIWareHouseDlg->ReceiveResultToWareMsg(bResult);
			break;

		case N3_SP_WARE_GET_OUT:
			bResult = pkt.read<uint8_t>();	// 0x01 : true, 0x00 : false..
			if (m_pUIWareHouseDlg) m_pUIWareHouseDlg->ReceiveResultFromWareMsg(bResult);
			break;

		case N3_SP_WARE_WARE_MOVE:
			bResult = pkt.read<uint8_t>();	// 0x01 : true, 0x00 : false..
			if (m_pUIWareHouseDlg) m_pUIWareHouseDlg->ReceiveResultWareToWareMsg(bResult);
			break;

		case N3_SP_WARE_INV_MOVE:
			bResult = pkt.read<uint8_t>();	// 0x01 : true, 0x00 : false..
			if (m_pUIWareHouseDlg) m_pUIWareHouseDlg->ReceiveResultInvToInvMsg(bResult);
			break;
	}
}

void CGameProcMain::MsgRecv_WareHouseOpen(Packet& pkt)		// 보관함 오픈..
{
	if (m_pUIWareHouseDlg->IsVisible())
		return;

	uint8_t idk = pkt.read<uint8_t>();

	int iWareGold, iItemID, iItemDurability, iItemCount;
	iWareGold		= pkt.read<uint32_t>();
	m_pUIWareHouseDlg->EnterWareHouseStateStart(iWareGold);

	for ( int i = 0; i < MAX_ITEM_WARE_PAGE*MAX_ITEM_TRADE; i++ )				// 슬롯 갯수마큼..
	{
		iItemID			= pkt.read<uint32_t>();
		iItemDurability	= pkt.read<int16_t>();
		iItemCount		= pkt.read<int16_t>();
		m_pUIWareHouseDlg->AddItemInWare( iItemID, iItemDurability, iItemCount, i );
	}

	if (!m_pUIWareHouseDlg->IsVisible())
		m_pUIWareHouseDlg->SetVisible(true);

	if (m_pUIInventory->IsVisible())		// 인벤토리가 안열려 있으면..
		this->CommandToggleUIInventory();

	if (m_pUISkillTreeDlg->IsVisible())
		m_pUISkillTreeDlg->Close();

	m_pUIWareHouseDlg->EnterWareHouseStateEnd();
}

void CGameProcMain::PlayBGM_Town()
{
	if(m_pSnd_Battle) m_pSnd_Battle->Stop(3.0f);
	if(nullptr == m_pSnd_Town || m_pSnd_Town->IsPlaying()) return;
	m_pSnd_Town->SetMaxVolume(60);
	m_pSnd_Town->Play(nullptr, 3.0f); // 전투 음악 설정.. 해제는 주위에 몬스터가 없을때 한다..
}

void CGameProcMain::PlayBGM_Battle()
{
	if(m_pSnd_Town) m_pSnd_Town->Stop(3.0f);
	if(nullptr == m_pSnd_Battle || m_pSnd_Battle->IsPlaying()) return;
	m_pSnd_Battle->SetMaxVolume(80);
	m_pSnd_Battle->Play(nullptr, 3.0f); // 전투 음악 설정.. 해제는 주위에 몬스터가 없을때 한다..
}

void CGameProcMain::ReleaseSound()
{
	if(ACT_WORLD && ACT_WORLD->GetSkyRef()) ACT_WORLD->GetSkyRef()->ReleaseSound();
	CN3Base::s_SndMgr.ReleaseStreamObj(&m_pSnd_Town);
	CN3Base::s_SndMgr.ReleaseStreamObj(&m_pSnd_Battle);
}

void CGameProcMain::MsgRecv_NpcChangeOpen(Packet& pkt)		// Class Change와 초기화..
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	switch (bSubCom)
	{
		case N3_SP_CLASS_CHANGE_PURE:
			m_pUINpcChange->Open();
			break;

		case N3_SP_CLASS_CHANGE_REQ:
			MsgRecv_ClassChange(pkt);
			break;

		case N3_SP_CLASS_ALL_POINT:
			MsgRecv_AllPointInit(pkt);
			break;

		case N3_SP_CLASS_SKILL_POINT:
			MsgRecv_SkillPointInit(pkt);
			break;

		case N3_SP_CLASS_POINT_CHANGE_PRICE_QUERY:
			MsgRecv_PointChangePriceQueryRequest(pkt);
			break;

		case N3_SP_CLASS_PROMOTION:
			MsgRecv_ClassPromotion(pkt);
			break;
	}
}

void CGameProcMain::MsgRecv_AllPointInit(Packet& pkt)			// All Point 초기화..
{
	uint8_t	bType		= pkt.read<uint8_t>();	
	uint32_t dwGold		= pkt.read<uint32_t>();	

	std::string szMsg; 

	switch (bType)
	{
		case 0x00:	// 돈이 부족..
			szMsg = fmt::format_text_resource(IDS_POINTINIT_NOT_ENOUGH_NOAH, dwGold);
			MsgOutput(szMsg, 0xffff3b3b);
			break;

		case 0x01:	// 성공..
			s_pPlayer->m_InfoExt.iStrength = pkt.read<int16_t>();
			m_pUIVar->m_pPageState->UpdateStrength(s_pPlayer->m_InfoExt.iStrength, s_pPlayer->m_InfoExt.iStrength_Delta);

			s_pPlayer->m_InfoExt.iStamina = pkt.read<int16_t>();
			m_pUIVar->m_pPageState->UpdateStamina(s_pPlayer->m_InfoExt.iStamina, s_pPlayer->m_InfoExt.iStamina_Delta);

			s_pPlayer->m_InfoExt.iDexterity = pkt.read<int16_t>();
			m_pUIVar->m_pPageState->UpdateDexterity(s_pPlayer->m_InfoExt.iDexterity, s_pPlayer->m_InfoExt.iDexterity_Delta);

			s_pPlayer->m_InfoExt.iIntelligence = pkt.read<int16_t>();
			m_pUIVar->m_pPageState->UpdateIntelligence(s_pPlayer->m_InfoExt.iIntelligence, s_pPlayer->m_InfoExt.iIntelligence_Delta);

			s_pPlayer->m_InfoExt.iMagicAttak = pkt.read<int16_t>();
			m_pUIVar->m_pPageState->UpdateMagicAttak(s_pPlayer->m_InfoExt.iMagicAttak, s_pPlayer->m_InfoExt.iMagicAttak_Delta);

			s_pPlayer->m_InfoBase.iHPMax =		pkt.read<int16_t>();
			s_pPlayer->m_InfoExt.iMSPMax =		pkt.read<int16_t>();
			s_pPlayer->m_InfoExt.iAttack =		pkt.read<int16_t>();
			s_pPlayer->m_InfoExt.iWeightMax		= static_cast<int>(pkt.read<uint16_t>());

			m_pUIVar->m_pPageState->UpdateHP(s_pPlayer->m_InfoBase.iHP, s_pPlayer->m_InfoBase.iHPMax);
			m_pUIStateBarAndMiniMap->UpdateHP(s_pPlayer->m_InfoBase.iHP, s_pPlayer->m_InfoBase.iHPMax, false);
			
			m_pUIVar->m_pPageState->UpdateMSP(s_pPlayer->m_InfoExt.iMSP, s_pPlayer->m_InfoExt.iMSPMax);
			m_pUIStateBarAndMiniMap->UpdateMSP(s_pPlayer->m_InfoExt.iMSP, s_pPlayer->m_InfoExt.iMSPMax, false);

			m_pUIVar->m_pPageState->UpdateAttackPoint(s_pPlayer->m_InfoExt.iAttack, s_pPlayer->m_InfoExt.iAttack_Delta);
			m_pUIVar->m_pPageState->UpdateWeight(s_pPlayer->m_InfoExt.iWeight, s_pPlayer->m_InfoExt.iWeightMax);

			s_pPlayer->m_InfoExt.iBonusPointRemain = pkt.read<int16_t>(); // 남은 보너스 포인트..
			m_pUIVar->m_pPageState->UpdateBonusPointAndButtons(s_pPlayer->m_InfoExt.iBonusPointRemain); // 보너스 포인트 적용이 가능한가??

			// 돈 변경.. 인벤토리는 바꾸고 상거래.. 개인 거래와는 배타적..
			s_pPlayer->m_InfoExt.iGold = dwGold;
			if (m_pUIInventory->IsVisible())
				m_pUIInventory->GoldUpdate();
			if (m_pUITransactionDlg->IsVisible())
				m_pUITransactionDlg->GoldUpdate();
			if (m_pSubProcPerTrade && m_pSubProcPerTrade->m_pUIPerTradeDlg->IsVisible())
				m_pSubProcPerTrade->m_pUIPerTradeDlg->GoldUpdate();

			break;

		case 0x02:	// Already..
			szMsg = fmt::format_text_resource(IDS_POINTINIT_ALREADY);
			MsgOutput(szMsg, 0xffff3b3b);
			break;
	}
}

void CGameProcMain::MsgRecv_SkillPointInit(Packet& pkt)		// Skill Point 초기화..
{
	uint8_t	bType		= pkt.read<uint8_t>();	
	uint32_t dwGold		= pkt.read<uint32_t>();	
	std::string szMsg; 

	switch (bType)
	{
		case 0x00:	// 돈이 부족..
			szMsg = fmt::format_text_resource(IDS_POINTINIT_NOT_ENOUGH_NOAH, dwGold);
			MsgOutput(szMsg, 0xffff3b3b);
			break;

		case 0x01:	// 성공..
			m_pUISkillTreeDlg->m_iSkillInfo[0] = pkt.read<uint8_t>();
			for (int i = 1; i < 9; i++)
				m_pUISkillTreeDlg->m_iSkillInfo[i] = 0;
			m_pUISkillTreeDlg->InitIconUpdate();

			// 돈 변경.. 인벤토리는 바꾸고 상거래.. 개인 거래와는 배타적..
			s_pPlayer->m_InfoExt.iGold = dwGold;
			if (m_pUIInventory->IsVisible())
				m_pUIInventory->GoldUpdate();
			if (m_pUITransactionDlg->IsVisible())
				m_pUITransactionDlg->GoldUpdate();
			if (m_pSubProcPerTrade && m_pSubProcPerTrade->m_pUIPerTradeDlg->IsVisible())
				m_pSubProcPerTrade->m_pUIPerTradeDlg->GoldUpdate();

			if (m_pUIHotKeyDlg)
				m_pUIHotKeyDlg->AllFactorClear();
			break;

		case 0x02:	// Already..
			szMsg = fmt::format_text_resource(IDS_POINTINIT_ALREADY);
			MsgOutput(szMsg, 0xffff3b3b);
			break;
	}
}

void CGameProcMain::MsgRecv_PointChangePriceQueryRequest(Packet& pkt)		// 가격에 대한 응답 패킷..
{
	uint32_t dwGold		= pkt.read<uint32_t>();	
	m_pUINpcChange->ReceivePriceFromServer(dwGold);
}

void CGameProcMain::MsgRecv_NoahChange(Packet& pkt)		// 노아 변경..
{
	uint8_t	bType			= pkt.read<uint8_t>();	
	uint32_t dwGoldOffset	= pkt.read<uint32_t>();		
	uint32_t dwGold			= pkt.read<uint32_t>();	

	std::string szMsg; 

	switch (bType)
	{
		case GOLD_CHANGE_GAIN:
			szMsg = fmt::format_text_resource(IDS_NOAH_CHANGE_GET, dwGoldOffset);
			MsgOutput(szMsg, 0xff6565ff);
			break;

		case GOLD_CHANGE_LOSE:
			szMsg = fmt::format_text_resource(IDS_NOAH_CHANGE_LOST, dwGoldOffset);
			MsgOutput(szMsg, 0xffff3b3b);
			break;

		case GOLD_CHANGE_SPEND:
			szMsg = fmt::format_text_resource(IDS_NOAH_CHANGE_SPEND, dwGoldOffset);
			MsgOutput(szMsg, 0xffff3b3b);
			break;
	}
	
	s_pPlayer->m_InfoExt.iGold = dwGold;

	if (m_pUIInventory->IsVisible())
		m_pUIInventory->GoldUpdate();
	if (m_pUITransactionDlg->IsVisible())
		m_pUITransactionDlg->GoldUpdate();
	if (m_pSubProcPerTrade && m_pSubProcPerTrade->m_pUIPerTradeDlg->IsVisible())
		m_pSubProcPerTrade->m_pUIPerTradeDlg->GoldUpdate();
}

void CGameProcMain::MsgRecv_WarpList(Packet& pkt)		// 워프 리스트 - 존 체인지가 될 수도 있다..
{
	uint8_t opcode = pkt.read<uint8_t>();
	if (opcode == 2)
	{
		MsgRecv_WarpList_Error(pkt);
		return;
	}

	if (opcode != 1)
		return;

	m_pUIWarp->Reset();

	int iListCount = pkt.read<int16_t>();

	// if there are no warp info (if m_bZoneChangeSameZone is true) - No need to show empty list. 
	if (iListCount == 0)
		return;

	int iStrLen = 0;

	for(int i = 0; i < iListCount; i++)
	{
		__WarpInfo WI;
		
		WI.iID = pkt.read<int16_t>();				// 워프 ID
		iStrLen = pkt.read<int16_t>();				// 이름 길이
		pkt.readString(WI.szName, iStrLen);			// 이름
		iStrLen = pkt.read<int16_t>();				// 동의문 길이
		pkt.readString(WI.szAgreement, iStrLen);	// 동의문
		WI.iZone = pkt.read<int16_t>();				// 존번호
		WI.iMaxUser = pkt.read<int16_t>();			// 최대 유저 카운트.
		WI.iGold = pkt.read<uint32_t>();			// 돈
		WI.vPos.x = (pkt.read<int16_t>())/10.0f;	// 좌표 
		WI.vPos.z = (pkt.read<int16_t>())/10.0f;	//
		WI.vPos.y = (pkt.read<int16_t>())/10.0f;	// 

		m_pUIWarp->InfoAdd(WI);
	}

	m_pUIWarp->UpdateList();
	m_pUIWarp->SetVisible(true);
}

void CGameProcMain::MsgRecv_WarpList_Error(Packet& pkt)
{
	uint8_t errorCode = pkt.read<uint8_t>();
	std::string szMsg;

	switch (errorCode)
	{
		case WARP_LIST_ERROR_SUCCESS:
			szMsg = fmt::format_text_resource(IDS_WARP_ARRIVED_AT, m_szWarpDestination);
			MsgOutput(szMsg, 0xFFFFFF00);
			break;

		case WARP_LIST_ERROR_MIN_LEVEL:
		{
			int iRequiredLevel = pkt.read<uint8_t>();

			szMsg = fmt::format_text_resource(IDS_WARP_MIN_LEVEL, iRequiredLevel);
			MsgOutput(szMsg, 0xFFFFFF00);
		}
		break;

		case WARP_LIST_ERROR_NOT_DURING_CSW:
			szMsg = fmt::format_text_resource(IDS_WARP_NOT_DURING_CSW);
			MsgOutput(szMsg, 0xFFFFFF00);
			break;

		case WARP_LIST_ERROR_NOT_DURING_WAR:
			szMsg = fmt::format_text_resource(IDS_WARP_NOT_DURING_WAR);
			MsgOutput(szMsg, 0xFFFFFF00);
			break;

		case WARP_LIST_ERROR_NEED_LOYALTY:
			szMsg = fmt::format_text_resource(IDS_WARP_NEED_LOYALTY);
			MsgOutput(szMsg, 0xFFFFFF00);
			break;

		case WARP_LIST_ERROR_WRONG_LEVEL_DLW:
			szMsg = fmt::format_text_resource(IDS_WARP_LEVEL_30_TO_50);
			MessageBoxPost(szMsg, "", MB_OK);
			break;

		case WARP_LIST_ERROR_DO_NOT_QUALIFY:
			szMsg = fmt::format_text_resource(IDS_WARP_DO_NOT_QUALIFY);
			MessageBoxPost(szMsg, "", MB_OK);
			break;
	}
}

void CGameProcMain::MsgRecv_Knights_Create(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	switch ( (e_SubPacket_KNights_Create)bSubCom )
	{
		case N3_SP_KNIGHTS_CREATE_SUCCESS:
			{
				int sid = pkt.read<int16_t>();
				std::string szID;
				int iID = pkt.read<int16_t>();		// 기사단 ID
				int iLen = pkt.read<int16_t>();		// ID 문자열 길이..
				pkt.readString(szID, iLen);	// ID 문자열..
				int iGrade = pkt.read<uint8_t>();	// 등급
				int iRank = pkt.read<uint8_t>();		// 순위
				uint32_t dwGold = pkt.read<uint32_t>();

				if(s_pPlayer->IDNumber()==sid)
				{
					m_pUIInn->Message(/*IDS_CLAN_MAKE_SUCCESS*/6505);

					// 돈 변경.. 인벤토리는 바꾸고 상거래.. 개인 거래와는 배타적..
					s_pPlayer->m_InfoExt.iGold = dwGold;
					if (m_pUIInventory->IsVisible()) m_pUIInventory->GoldUpdate();
					if (m_pUITransactionDlg->IsVisible()) m_pUITransactionDlg->GoldUpdate();
					if (m_pSubProcPerTrade && m_pSubProcPerTrade->m_pUIPerTradeDlg->IsVisible())
						m_pSubProcPerTrade->m_pUIPerTradeDlg->GoldUpdate();

					//기사단(클랜)UI업데이트...해라...
					s_pPlayer->m_InfoExt.eKnightsDuty = KNIGHTS_DUTY_CHIEF;
					s_pPlayer->KnightsInfoSet(iID, szID, iGrade, iRank);
					m_pUIVar->UpdateKnightsInfo();

					if(m_pUIVar->m_pPageKnights->IsVisible())
					{
						m_pUIVar->m_pPageKnights->MsgSend_MemberInfoAll();
						m_pUIVar->m_pPageKnights->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty);
					}

					//m_pUIKnightsOp->KnightsInfoInsert(iID, szID); // 기사단 정보 추가..
				}
				else
				{
					CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(sid, true);
					if(pUPC)
						pUPC->KnightsInfoSet(iID, szID, iGrade, iRank);
				}
			}
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_LOWLEVEL:
			m_pUIInn->Message(/*IDS_CLAN_DENY_LOWLEVEL*/6500);
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_DUPLICATEDNAME:
			m_pUICreateClanName->Open(/*IDS_CLAN_REINPUT_NAME*/6508);
			break;

		case N3_SP_KNIGHTS_CREATE_FAIL_LOWMONEY:
			m_pUIInn->Message(/*IDS_CLAN_DENY_LOWGOLD*/6501);
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_ALREADYJOINED:
			m_pUIInn->Message(/*IDS_CLAN_DENY_ALREADYJOINED*/6503);
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_INVALIDDAY:
			m_pUIInn->Message(/*IDS_CLAN_DENY_INVALIDDAY*/6502);
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_DBFAIL:
		case N3_SP_KNIGHTS_CREATE_FAIL_UNKNOWN:
			m_pUIInn->Message(/*IDS_CLAN_DENY_UNKNOWN*/6504);
			break;
		case N3_SP_KNIGHTS_CREATE_FAIL_INVALIDSERVER:
			m_pUIInn->Message(/*IDS_CLAN_DENY_INVALID_SERVER*/6527);
			break;
	}
}

void CGameProcMain::MsgRecv_Knights_Withdraw(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	std::string szMsg;
	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_DBFAIL:
		break;
	case N3_SP_KNIGHTS_COMMON_SUCCESS:
		{
			int sid = pkt.read<int16_t>();
			if(s_pPlayer->IDNumber()==sid)
			{
				s_pPlayer->m_InfoBase.iKnightsID = pkt.read<int16_t>();
				s_pPlayer->m_InfoExt.eKnightsDuty = (e_KnightsDuty)pkt.read<uint8_t>();
				m_pUIVar->UpdateKnightsInfo();

				s_pPlayer->KnightsInfoSet(s_pPlayer->m_InfoBase.iKnightsID, "", 0, 0);
				szMsg = fmt::format_text_resource(IDS_CLAN_WITHDRAW_SUCCESS);
				this->MsgOutput(szMsg, 0xffffff00);

				if(m_pUIVar->m_pPageKnights->IsVisible())
				{
					m_pUIVar->m_pPageKnights->MsgSend_MemberInfoAll();
					m_pUIVar->m_pPageKnights->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty);
				}
			}
			else
			{
				int iKnightsID = pkt.read<int16_t>();
				e_KnightsDuty eKnightsDuty = (e_KnightsDuty)pkt.read<uint8_t>();

				CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(sid, true);
				if(pUPC)
				{
					//__KnightsInfoBase* pKIB = m_pUIKnightsOp->KnightsInfoFind(iKnightsID);
					//if(pKIB) pUPC->KnightsNameSet(pKIB->szName, 0xffff0000);
					//else pUPC->KnightsNameSet("", 0xffff0000);
					pUPC->KnightsInfoSet(iKnightsID, "", 0, 0);
				}
			}
		}
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER:
	case N3_SP_KNIGHTS_COMMON_FAIL_DEAD_USER:
	case N3_SP_KNIGHTS_COMMON_FAIL_ENEMY_USER:
	case N3_SP_KNIGHTS_COMMON_FAIL_OTHER_CLAN_USER:
	case N3_SP_KNIGHTS_COMMON_FAIL_INVALIDRIGHT:
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_CLAN:
	case N3_SP_KNIGHTS_COMMON_FAIL_FULL:
	case N3_SP_KNIGHTS_COMMON_FAIL_ME:
	case N3_SP_KNIGHTS_COMMON_FAIL_NOT_JOINED:
		szMsg = fmt::format_text_resource(IDS_CLAN_WITHDRAW_FAIL);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_BATTLEZONE:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_BATTLEZONE);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	}
}

void CGameProcMain::MsgRecv_Knights_Join(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	std::string szMsg;
	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_DBFAIL: //DB검색 실패..
		break;
	case N3_SP_KNIGHTS_COMMON_SUCCESS: //클랜가입 성공
		{
			int sid = pkt.read<int16_t>();
			int iID = pkt.read<int16_t>();
			e_KnightsDuty eDuty = (e_KnightsDuty)pkt.read<uint8_t>();
			int iL = pkt.read<int16_t>(); // 소속 기사단 이름 길이.
			std::string szKnightsName;
			pkt.readString(szKnightsName, iL);
			int iGrade = pkt.read<uint8_t>();	// 등급
			int iRank = pkt.read<uint8_t>();		// 순위

			if(s_pPlayer->IDNumber()==sid)
			{
				s_pPlayer->m_InfoExt.eKnightsDuty = eDuty;
				s_pPlayer->KnightsInfoSet(iID, szKnightsName, iGrade, iRank);
				m_pUIVar->UpdateKnightsInfo();

				szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_SUCCESS);
				this->MsgOutput(szMsg, 0xffffff00);

				if(m_pUIVar->m_pPageKnights->IsVisible())
				{
					m_pUIVar->m_pPageKnights->MsgSend_MemberInfoAll();
					m_pUIVar->m_pPageKnights->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty);
				}
			}
			else
			{
				CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(sid, true);								
				if(pUPC)
					pUPC->KnightsInfoSet(iID, szKnightsName, iGrade, iRank);
			}
		}
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER:	//없는 유저..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_DEAD_USER:	//상대유저가 죽어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_DEAD_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ENEMY_USER: //상대유저의 국가가 다름..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_ENEMY_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_OTHER_CLAN_USER: //상대유저가 이미 다른 클랜이나 기사단에 가입되어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_OTHER_CLAN_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_INVALIDRIGHT: //권한이 없음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_INVALIDRIGHT);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_CLAN:	//존재하지 않는 기사단..									
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_CLAN);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_FULL:	//인원이 풀..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_CLAN_FULL);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ME:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_ME);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NOT_JOINED:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_NOTJOINED);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_REJECT:
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_REJECT);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_BATTLEZONE:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_BATTLEZONE);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	}	
}

void CGameProcMain::MsgRecv_Knights_Leave(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	std::string szMsg;
	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_DBFAIL: //DB검색 실패..
		break;
	case N3_SP_KNIGHTS_COMMON_SUCCESS: //클랜탈퇴 성공
		{
			int sid = pkt.read<int16_t>();
			int iID = pkt.read<int16_t>();
			e_KnightsDuty eDuty = (e_KnightsDuty)pkt.read<uint8_t>();
			int iL = pkt.read<int16_t>(); // 소속 기사단 이름 길이.
			std::string szKnightsName;
			pkt.readString(szKnightsName, iL);
			int iGrade = pkt.read<uint8_t>();	// 등급
			int iRank = pkt.read<uint8_t>();		// 순위

			if(s_pPlayer->IDNumber()==sid)
			{
				s_pPlayer->m_InfoExt.eKnightsDuty = eDuty;
				s_pPlayer->KnightsInfoSet(iID, szKnightsName, iGrade, iRank);
				m_pUIVar->UpdateKnightsInfo();
				
				szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_SUCCESS);
				this->MsgOutput(szMsg, 0xffffff00);

				if(m_pUIVar->m_pPageKnights->IsVisible())
				{
					m_pUIVar->m_pPageKnights->MsgSend_MemberInfoAll();
					m_pUIVar->m_pPageKnights->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty);
				}
			}
			else
			{
				CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(sid, true);								
				if(pUPC)
					pUPC->KnightsInfoSet(iID, "", 0, 0);
			}
		}
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER:	//없는 유저..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_DEAD_USER:	//상대유저가 죽어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_DEAD_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ENEMY_USER: //상대유저의 국가가 다름..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_ENEMY_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_OTHER_CLAN_USER: //상대유저가 이미 다른 클랜이나 기사단에 가입되어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_OTHER_CLAN_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_INVALIDRIGHT: //권한이 없음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_INVALIDRIGHT);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_CLAN:	//존재하지 않는 기사단..									
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_CLAN);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_FULL:	//인원이 풀..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_CLAN_FULL);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ME:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_ME);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NOT_JOINED:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_NOTJOINED);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_BATTLEZONE:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_BATTLEZONE);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	}	
}

void CGameProcMain::MsgRecv_Knights_AppointViceChief(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	std::string szMsg;
	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_DBFAIL: //DB검색 실패..
		break;
	case N3_SP_KNIGHTS_COMMON_SUCCESS: //클랜가입 성공
		{
			int iID = pkt.read<int16_t>();
			e_KnightsDuty eDuty = (e_KnightsDuty)pkt.read<uint8_t>();

			s_pPlayer->m_InfoBase.iKnightsID = iID;
			s_pPlayer->m_InfoExt.eKnightsDuty = eDuty;
			m_pUIVar->UpdateKnightsInfo();

			szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_SUCCESS);
			this->MsgOutput(szMsg, 0xffffff00);

			if(m_pUIVar->m_pPageKnights->IsVisible())
			{
				m_pUIVar->m_pPageKnights->MsgSend_MemberInfoAll();
				m_pUIVar->m_pPageKnights->ChangeUIByDuty(s_pPlayer->m_InfoExt.eKnightsDuty);
			}
		}
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER:	//없는 유저..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_DEAD_USER:	//상대유저가 죽어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_DEAD_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ENEMY_USER: //상대유저의 국가가 다름..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_ENEMY_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_OTHER_CLAN_USER: //상대유저가 이미 다른 클랜이나 기사단에 가입되어 있음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_OTHER_CLAN_USER);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_INVALIDRIGHT: //권한이 없음..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_INVALIDRIGHT);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NONE_CLAN:	//존재하지 않는 기사단..									
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_NONE_CLAN);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_FULL:	//인원이 풀..
		szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_FAIL_CLAN_FULL);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_ME:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_ME);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_NOT_JOINED:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_NOTJOINED);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	case N3_SP_KNIGHTS_COMMON_FAIL_BATTLEZONE:
		szMsg = fmt::format_text_resource(IDS_CLAN_COMMON_FAIL_BATTLEZONE);
		this->MsgOutput(szMsg, 0xffffff00);
		break;
	}	
}

void CGameProcMain::MsgRecv_Knights_MemberInfoAll(Packet& pkt)
{
	uint8_t	bSubCom = pkt.read<uint8_t>();

	std::string szMsg;
	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_SUCCESS:
		m_pUIVar->m_pPageKnights->MsgRecv_MemberInfo(pkt);
		break;
	case N3_SP_KNIGHTS_COMMON_DBFAIL: //DB검색 실패..
	default:
		break;		
	}
}

void CGameProcMain::MsgRecv_Knights_GradeChangeAll(Packet& pkt)
{
	int iCount = pkt.read<int16_t>();
	if(iCount <= 0) return;
	
	std::vector<int> iIDs(iCount, 0);
	std::vector<int> iGrades(iCount, 0);
	std::vector<int> iRanks(iCount, 0);

	for(int i = 0; i < iCount; i++)
	{
		iIDs[i] = pkt.read<int16_t>();
		iGrades[i] = pkt.read<uint8_t>();
		iRanks[i] = pkt.read<uint8_t>();
	}

	it_UPC it = s_pOPMgr->m_UPCs.begin(), itEnd = s_pOPMgr->m_UPCs.end();
	for(; it != itEnd; it++)
	{
		CPlayerOther* pUPC = it->second;
		if(nullptr == pUPC) continue;

		int iIDTmp = pUPC->m_InfoBase.iKnightsID;
		if(iIDTmp <= 0) continue;

		for(int i = 0; i < iCount; i++)
		{
			if(iIDs[i] == iIDTmp)
			{
				pUPC->KnightsInfoSet(iIDTmp, pUPC->m_InfoExt.szKnights, iGrades[i], iRanks[i]);
				break;
			}
		}
	}

}

void CGameProcMain::MsgRecv_Knights_Duty_Change(Packet& pkt)
{
	uint8_t bSubCom = pkt.read<uint8_t>();

	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_SUCCESS:
		{
			int sid = pkt.read<int16_t>();
			int iID = pkt.read<int16_t>();
			e_KnightsDuty eDuty = (e_KnightsDuty)pkt.read<uint8_t>();

			if(s_pPlayer->IDNumber()==sid)
			{
				s_pPlayer->m_InfoBase.iKnightsID = iID;
				s_pPlayer->m_InfoExt.eKnightsDuty = eDuty;
				m_pUIVar->UpdateKnightsInfo();
				if(s_pPlayer->m_InfoBase.iKnightsID == 0)
					s_pPlayer->KnightsInfoSet(0, "", 0, 0);
				//std::string szName;
				//__KnightsInfoBase* pKIB = m_pUIKnightsOp->KnightsInfoFind(s_pPlayer->m_InfoBase.iKnightsID);
				//if(pKIB) m_pUIVar->m_pPageKnights->UpdateKnightsName(pKIB->szName);
				//else m_pUIVar->m_pPageKnights->UpdateKnightsName("");
			}
			else
			{
				CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(sid, true);								
				if(pUPC)
					if(iID == 0) pUPC->KnightsInfoSet(0, "", 0, 0);
			}
		}
		break;
	}
}

void CGameProcMain::MsgRecv_Knigts_Join_Req(Packet& pkt)
{
	uint8_t bSubCom = pkt.read<uint8_t>();

	switch ( (e_SubPacket_KNights_Common)bSubCom )
	{
	case N3_SP_KNIGHTS_COMMON_SUCCESS:
		{
			m_iJoinReqClanRequierID = pkt.read<int16_t>();
			m_iJoinReqClan = pkt.read<int16_t>();

			int iL = pkt.read<int16_t>(); // 소속 기사단 이름 길이.
			std::string szKnightsName;
			pkt.readString(szKnightsName, iL);

//			std::string szName;
//			__KnightsInfoBase* pKIB = m_pUIKnightsOp->KnightsInfoFind(m_iJoinReqClan);
//			if(!pKIB)
//			{
//				MsgSend_KnightsJoinReq(false);
//				break;
//			}

			std::string szMsg = fmt::format_text_resource(IDS_CLAN_JOIN_REQ, szKnightsName);
			MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_CLAN_JOIN);			
		}
		break;
	}
}

int CGameProcMain::MsgRecv_VersionCheck(Packet& pkt) // virtual
{
	int iVersion = CGameProcedure::MsgRecv_VersionCheck(pkt);
	this->MsgSend_CharacterSelect(); // virtual

	return iVersion;
}

bool CGameProcMain::MsgRecv_CharacterSelect(Packet& pkt) // virtual
{
	bool bSuccess = CGameProcedure::MsgRecv_CharacterSelect(pkt);

	//전쟁존에서 죽어서 서버 체인지 하는 경우는 다시 값을 세팅해준다.
	if(s_pPlayer->IsDead())
	{
		this->InitPlayerPosition(s_pPlayer->Position()); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
		s_pPlayer->RegenerateCollisionMesh(); // 충돌 메시를 다시 만든다..
		s_pPlayer->m_iSendRegeneration = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그
		s_pPlayer->m_fTimeAfterDeath = 0; // 한번 보내면 다시 죽을때까지 안보내는 플래그

		//
		//마법 & 효과 초기화..
		if(m_pUIStateBarAndMiniMap) m_pUIStateBarAndMiniMap->ClearMagic();
		if(m_pMagicSkillMng) m_pMagicSkillMng->ClearDurationalMagic();
		if(CGameProcedure::s_pFX) s_pFX->StopMine();

		CLogWriter::Write("Receive Regeneration");

		if(s_pPlayer->Nation()==NATION_KARUS) CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_KARUS, s_pPlayer->IDNumber(), -1);
		else if(s_pPlayer->Nation()==NATION_ELMORAD) CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), -1, FXID_REGEN_ELMORAD, s_pPlayer->IDNumber(), -1);
	}
			

	this->InitZone(s_pPlayer->m_InfoExt.iZoneCur, s_pPlayer->Position()); // 존을 바꾼다..
	s_pProcMain->MsgSend_GameStart(); // 존로딩이 끝나면 게임 시작..

	return bSuccess;
}

void CGameProcMain::MsgRecv_Corpse(Packet& pkt)
{
	int iID	= pkt.read<int16_t>();//regen하고자 하는 유저의 아이디

	if( s_pPlayer->IDNumber() != iID )
	{
		s_pOPMgr->CorpseAdd( iID );

		if( s_pPlayer->m_iIDTarget == iID )
			s_pPlayer->m_iIDTarget = -1; //만약 내가 regen한 캐릭터에 포커스를 가지고 있다면 초기화 해준다.
	}
}

void CGameProcMain::MsgSend_PerTradeBBSReq(std::string szName, int iDestID)
{
	if(	!m_pUITransactionDlg->IsVisible() ) //// 개인간 아이템 거래.. // 상거래 중이 아니면..
	{
		std::string szMsg = fmt::format_text_resource(IDS_PERSONAL_TRADE_REQUEST);
		MsgOutput(szName + szMsg, 0xffffff00);

		MsgSend_PerTradeReq(iDestID, false);

		if (m_pUINpcEvent->IsVisible())
			m_pUINpcEvent->Close();
		m_pSubProcPerTrade->EnterWaitMsgFromServerStatePerTradeReq(szName);
	}
}

void CGameProcMain::MsgSend_CharacterSelect() // virtual
{
	CGameProcedure::MsgSend_CharacterSelect();
	
	m_pMagicSkillMng->ClearDurationalMagic();
	s_pFX->ClearAll();
}

void CGameProcMain::ControlViewVDegree(int16_t sValue)
{
	if(s_pEng->ViewPoint() == VP_THIRD_PERSON)
	{
		float fPitch = 0;
		if(sValue > 0)	fPitch = DegreesToRadians(45.0f)*3;
		else			fPitch = DegreesToRadians(-45.0f)*3;
		if(fPitch) s_pEng->CameraPitchAdd(fPitch);
	}
}
/*
bool CGameProcMain::OnMouseMove(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	if(ptCur.x != ptPrev.x || ptCur.y != ptPrev.y)
	{
		if(m_pMagicSkillMng->m_dwRegionMagicState==1)
		{
			__Vector3 vPick;
			CPlayerNPC*	 pTarget = nullptr;
		
			int iID = -1;
			pTarget = s_pOPMgr->Pick(ptCur.x, ptCur.y, iID, &vPick); // 사방에 깔린넘들 픽킹..
			this->TargetSelect(iID, false); // 타겟을 잡는다..
			if(nullptr == pTarget) // 타겟이 없으면..
			{
				s_pPlayer->m_pObjectTarget = ACT_WORLD->PickWithShape(ptCur.x, ptCur.y, true, &vPick); // 찍힌 위치를 저장한다..
				if(nullptr == s_pPlayer->m_pObjectTarget) // 타겟도 없으면..
				{
					ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, vPick); // 지형을 찍어본다..
				}
			}
			s_pFX->SetBundlePos(m_pMagicSkillMng->m_iMyRegionTargetFXID, m_pMagicSkillMng->m_iMyRegionTargetFXID, vPick);
		}
	}

	return true;
}
*/
bool CGameProcMain::OnMouseMove(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	// NOTE: check if cursor position has changed
	if(ptCur.x != ptPrev.x || ptCur.y != ptPrev.y)
	{
		// NOTE: check if something has been selected by the cursor
		if(m_pMagicSkillMng->m_dwRegionMagicState==1)
		{
			__Vector3 vNormal, vMyPos, vGap, vDir;

			vMyPos = s_pPlayer->Position();
			vMyPos.y += s_pPlayer->Height() / 2;

			ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, m_vMouseSkillPos); // 지형을 찍어본다..

			vDir = m_vMouseSkillPos - vMyPos;
			vGap = vDir;
			vDir.Normalize();

			bool bColShape = ACT_WORLD->CheckCollisionWithShape(vMyPos, vDir, vGap.Magnitude(), &m_vMouseSkillPos, &vNormal);

			if(!bColShape) // 타겟도 없으면..
			{
				int iID = -1;
				s_pOPMgr->Pick(ptCur.x, ptCur.y, iID, &m_vMouseSkillPos); // 사방에 깔린넘들 픽킹..
				this->TargetSelect(iID, false); // 타겟을 잡는다..
			}
			else
			{
				m_vMouseSkillPos.y = ACT_WORLD->GetHeightWithTerrain(m_vMouseSkillPos.x, m_vMouseSkillPos.z);
			}
			s_pFX->SetBundlePos(m_pMagicSkillMng->m_iMyRegionTargetFXID, m_pMagicSkillMng->m_iMyRegionTargetFXID, m_vMouseSkillPos);
		}
	}

	return true;
}

// 왼쪽 더블 클릭
bool CGameProcMain::OnMouseLDBtnPress(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething)
		return false;

	TryStartAttack();
	
	return true;
}

/// \brief attempts to start the auto-attack process
/// \returns true if auto-attack process started, false otherwise
bool CGameProcMain::TryStartAttack()
{
	CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(s_pPlayer->m_iIDTarget, true);
	if (pTarget == nullptr || pTarget->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
	{
		s_pPlayer->m_iIDTarget = SKILLMAGIC_TARGET_UNKNOWN;
		return false;
	}

	if (s_pEng->ViewPoint() == VP_THIRD_PERSON)
	{
		if (s_pPlayer->IsAttackableTarget(pTarget, false))
		{
			CommandMove(MD_STOP, true);
			CommandEnableAttackContinous(true, pTarget);
		}
		else
		{
			CommandMove(MD_FORWARD, true);
			s_pPlayer->SetMoveTargetID(s_pPlayer->m_iIDTarget);
		}
	}
	else
	{
		s_pPlayer->m_bAttackContinous = false;
		CommandToggleAttackContinous();
	}

	return true;
}

// 왼쪽 클릭
bool CGameProcMain::OnMouseLBtnPress(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	_POINT ptPlayer = ::_Convert3D_To_2DCoordinate(	s_pPlayer->Position(), 
													CN3Base::s_CameraData.mtxView,
													CN3Base::s_CameraData.mtxProjection,
													CN3Base::s_CameraData.vp.Width,
													CN3Base::s_CameraData.vp.Height);
	
	__Vector3 vDir((float)(ptCur.x - ptPlayer.x), 0, (float)(ptPlayer.y - ptCur.y));
	__Matrix44 mtxTmp; mtxTmp.RotationY(s_pEng->CameraYaw());
	vDir *= mtxTmp;
	vDir.Normalize();
	float fYaw = ::_Yaw2D(vDir.x, vDir.z);

	CPlayerNPC*	 pTarget			= nullptr;
	BOOL		 bFindCorpse		= false;

	int iID = -1;
	pTarget = s_pOPMgr->PickPrecisely(ptCur.x, ptCur.y, iID, &m_vMouseLBClickedPos); // 사방에 깔린넘들 픽킹..
	this->TargetSelect(iID, false); // 타겟을 잡는다..
	if(nullptr == pTarget) // 타겟이 없으면..
	{
		if(s_pPlayer->m_bAttackContinous) // 계속 공격하는 중이면..
			this->CommandEnableAttackContinous(false, nullptr); // 계속 공격 취소..

		s_pPlayer->m_pObjectTarget = ACT_WORLD->PickWithShape(ptCur.x, ptCur.y, true, &m_vMouseLBClickedPos); // 찍힌 위치를 저장한다..
		if(nullptr == s_pPlayer->m_pObjectTarget) // 타겟도 없으면..
		{
			// 시체 뒤저서 아이템 상자 열기..
			CPlayerNPC* pCorpse = s_pOPMgr->PickCorpse(ptCur.x, ptCur.y, iID); // 픽킹..
			if(false == this->MsgSend_RequestItemBundleOpen(pCorpse)) // 시체 뒤지기 요청..
			{
				ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, m_vMouseLBClickedPos); // 지형을 찍어본다..
			}
			else
				bFindCorpse = true;
		}
	}

	if(m_pMagicSkillMng->m_dwRegionMagicState==1)
	{
//		s_pFX->SetBundlePos(m_pMagicSkillMng->m_iMyRegionTargetFXID, m_pMagicSkillMng->m_iMyRegionTargetFXID, m_vMouseLBClickedPos);
		s_pFX->SetBundlePos(m_pMagicSkillMng->m_iMyRegionTargetFXID, m_pMagicSkillMng->m_iMyRegionTargetFXID, m_vMouseSkillPos);
		m_pMagicSkillMng->m_dwRegionMagicState = 2;
	}

	if(!s_pPlayer->IsDead() && VP_THIRD_PERSON == s_pEng->ViewPoint())
	{
		m_fLBClickTime = CN3Base::TimeGet();
		this->CommandSitDown(false, false); // 일단 일으켜 세운다..

		if(pTarget)
		{
			if(s_pLocalInput->IsKeyDown(DIK_LCONTROL) || s_pLocalInput->IsKeyDown(DIK_RCONTROL))
			{
				if(s_pPlayer->IsAttackableTarget(pTarget, false))
				{
					if(s_pPlayer->m_bTargetOrPosMove)
						this->CommandMove(MD_STOP, true);

					this->CommandEnableAttackContinous(true, pTarget); // 자동 공격
				}
				else
				{
					this->CommandMove(MD_FORWARD, true);
					s_pPlayer->SetMoveTargetID(s_pPlayer->m_iIDTarget);
				}
			}
			else
			{
				if(s_pPlayer->m_bTargetOrPosMove && s_pPlayer->m_iMoveTarget != pTarget->IDNumber())
					this->CommandMove(MD_STOP, true);
			}
		}
		else if(!bFindCorpse)
		{
			s_pPlayer->RotateTo(fYaw, true);
			__Vector3 vMovePoint;
			ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, vMovePoint); // 지형을 찍어본다..

			float fDist = (vMovePoint - s_pPlayer->Position()).Magnitude();

			if(!s_pPlayer->m_bTargetOrPosMove && fDist > 1.5f)
				this->CommandMove(MD_FORWARD, true);

			if(fDist > 1.5f)
			{
				s_pPlayer->SetMoveTargetPos(vMovePoint);
			}
			else if(s_pPlayer->m_bTargetOrPosMove)
			{
				this->CommandMove(MD_STOP, true);
			}
		}
	}
	else if(!s_pPlayer->IsDead())
	{
		if(pTarget && (s_pLocalInput->IsKeyDown(DIK_LCONTROL) || s_pLocalInput->IsKeyDown(DIK_RCONTROL)))
		{
			if(s_pPlayer->IsAttackableTarget(pTarget, false))
			{
				if(s_pPlayer->m_bTargetOrPosMove)
					this->CommandMove(MD_STOP, true);

				this->CommandEnableAttackContinous(true, pTarget); // 자동 공격
			}
			else
			{
				s_pPlayer->m_bAttackContinous = false;
				CommandToggleAttackContinous();
			}
		}
	}

	return true;
}

// 왼쪽 클릭업
bool CGameProcMain::OnMouseLBtnPressd(POINT ptCur, POINT ptPrev)
{
	if(!s_pLocalInput->IsKeyDown(KM_MOVE_FOWARD))
	{
//		if(!s_pPlayer->m_bTargetOrPosMove)
//			this->CommandMove(MD_STOP, true);
	}
	return true;
}

// 왼쪽 눌리고 있을때
bool CGameProcMain::OnMouseLbtnDown(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	_POINT ptPlayer = ::_Convert3D_To_2DCoordinate(	s_pPlayer->Position(), 
													CN3Base::s_CameraData.mtxView,
													CN3Base::s_CameraData.mtxProjection,
													CN3Base::s_CameraData.vp.Width,
													CN3Base::s_CameraData.vp.Height);
	
	__Vector3 vDir((float)(ptCur.x - ptPlayer.x), 0, (float)(ptPlayer.y - ptCur.y));
	__Matrix44 mtxTmp; mtxTmp.RotationY(s_pEng->CameraYaw());
	vDir *= mtxTmp;
	vDir.Normalize();
	float fYaw = ::_Yaw2D(vDir.x, vDir.z);

	if(!s_pPlayer->IsDead() && VP_THIRD_PERSON == s_pEng->ViewPoint() && !s_pLocalInput->IsKeyDown(KM_MOVE_FOWARD)) // 삼인칭 시점이면.. UI 를 건들지 않았으면..
	{
		__Vector3 vMovePoint;
		float fDist;
		float fNowTime = CN3Base::TimeGet();

		if( fNowTime - m_fLBClickTime > 0.1f && s_pPlayer->m_bTargetOrPosMove)
		{
			if(s_pPlayer->m_bAttackContinous)
				CommandToggleAttackContinous();


			this->CommandSitDown(false, false); // 일단 일으켜 세운다..
			s_pPlayer->RotateTo(fYaw, true);
			this->CommandMove(MD_FORWARD, false);

			ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, vMovePoint); // 지형을 찍어본다..
			fDist = (vMovePoint - s_pPlayer->Position()).Magnitude();

			s_pPlayer->SetMoveTargetPos(vMovePoint);
		}
		else if( fNowTime - m_fLBClickTime > 0.1f && !s_pPlayer->m_bTargetOrPosMove)
		{
			if(s_pPlayer->m_bAttackContinous)
				CommandToggleAttackContinous();

			s_pPlayer->RotateTo(fYaw, true);
			ACT_WORLD->PickWideWithTerrain(ptCur.x, ptCur.y, vMovePoint); // 지형을 찍어본다..

			fDist = (vMovePoint - s_pPlayer->Position()).Magnitude();

			if(fDist > 1.5f)
			{
				this->CommandMove(MD_FORWARD, true);
				s_pPlayer->SetMoveTargetPos(vMovePoint);
			}
		}
	}
	return true;
}

// 오른쪽 클릭
bool CGameProcMain::OnMouseRBtnPress(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	if(s_pLocalInput->IsKeyDown(DIK_LCONTROL) || s_pLocalInput->IsKeyDown(DIK_RCONTROL))
	{
		m_pUIHotKeyDlg->EffectTriggerByMouse();
		return true;
	}

	int iID = -1;
	CPlayerNPC* pNPC = s_pOPMgr->PickNPC(ptCur.x, ptCur.y, iID); // 픽킹..

	if(nullptr == pNPC)
	{
		// NOTE: sending the packet to pick up items
		CPlayerNPC* pCorpse = s_pOPMgr->PickCorpse(ptCur.x, ptCur.y, iID); // 픽킹..
		if(false == this->MsgSend_RequestItemBundleOpen(pCorpse)) // 시체 뒤저서 아이템 상자 열기..
		{
			// NOTE: if no corpse and item box then check if the player clicked on an iteractable shape
			CN3Shape* pShape = ACT_WORLD->PickWithShape(ptCur.x, ptCur.y, true);
			if(	pShape && pShape == s_pPlayer->m_pObjectTarget && pShape->m_iEventID) // Event 가 있으면..
			{
				float fD = (s_pPlayer->Position() - pShape->Pos()).Magnitude(); 
				float fDLimit = (s_pPlayer->Radius() + pShape->Radius()) * 2.0f;
				if(fD > fDLimit) // 거리가 멀면
				{
					std::string szMsg; 
					if (OBJECT_TYPE_BINDPOINT == pShape->m_iEventType)
						szMsg = fmt::format_text_resource(IDS_BIND_POINT_REQUEST_FAIL);
					else
						szMsg = fmt::format_text_resource(IDS_ERR_REQUEST_OBJECT_EVENT_SO_FAR);
					this->MsgOutput(szMsg, 0xffff8080);
				}
				else
				{
					if(OBJECT_TYPE_BINDPOINT == pShape->m_iEventType)
					{
						std::string szMsg = fmt::format_text_resource(IDS_REQUEST_BINDPOINT);
						this->MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_REQUEST_BINDPOINT); // 바인팅 포인트 설정 메시지 박스
					}
					else if(OBJECT_TYPE_WARP_POINT == pShape->m_iEventType)
					{
						this->MsgSend_ObjectEvent(pShape->m_iEventID, pShape->m_iNPC_ID); // 오브젝트 이벤트 보내기..
					}
				}
			}
		}
	}
	else if(pNPC->IDNumber() == s_pPlayer->m_iIDTarget) // 타겟으로 찍은 캐릭터와 피킹한 캐릭터가 같고 ..) 
	{
		if(	pNPC->m_pShapeExtraRef ) // 오브젝트 형태의 NPC 이면.. 컨트롤 할 NPC의 ID 가 있으면..
		{
			float fD = (s_pPlayer->Position() - pNPC->m_pShapeExtraRef->Pos()).Magnitude();
			float fDLimit = (s_pPlayer->Radius() + pNPC->m_pShapeExtraRef->Radius()) * 2.0f;
			if(fD > fDLimit) // 거리가 멀면
			{
				std::string szMsg = fmt::format_text_resource(IDS_ERR_REQUEST_OBJECT_EVENT_SO_FAR);
				this->MsgOutput(szMsg, 0xffff8080);
			}
			else
			{
				this->MsgSend_ObjectEvent(pNPC->m_pShapeExtraRef->m_iEventID, pNPC->IDNumber());
			}
		}
		else // 보통 NPC 이면..
		{
			// NOTE: an NPC has been clicked on
			// 같은 국가 일때만..
			if (!s_pPlayer->IsHostileTarget(pNPC))
			{
				float fD = (s_pPlayer->Position() - pNPC->Position()).Magnitude();
				float fDLimit = (s_pPlayer->Radius() + pNPC->Radius()) * 3.0f;
				if(fD > fDLimit) // 거리가 멀면
				{
					std::string szMsg = fmt::format_text_resource(IDS_ERR_REQUEST_NPC_EVENT_SO_FAR);
					this->MsgOutput(szMsg, 0xffff8080);
				}
				else
				{
					s_pPlayer->ActionMove(PSM_STOP); // 일단 멈추고..
					pNPC->RotateTo(s_pPlayer); // 방향을 플레이어 쪽으로 돌린다.
					this->MsgSend_NPCEvent(iID); // 이벤트 요청..
					if (m_pUITransactionDlg) m_pUITransactionDlg->m_iNpcID = pNPC->IDNumber();
				}
			}
		}
	}
	return true;
}

// 오른쪽 클릭업
bool CGameProcMain::OnMouseRBtnPressd(POINT ptCur, POINT ptPrev)
{
	return true;
}

// 오른쪽 눌리고 있을때
bool CGameProcMain::OnMouseRbtnDown(
	POINT ptCur,
	POINT ptPrev)
{
	if (s_pUIMgr->m_bDoneSomething)
		return false;

	float fMouseSensivity = 0.02f;//0.05f;//

	float fRotY = DegreesToRadians(180.0f) * ((ptCur.x - ptPrev.x) * fMouseSensivity); // 회전할 양을 계산하고..
	float fRotX = DegreesToRadians(180.0f) * ((ptCur.y - ptPrev.y) * fMouseSensivity);
	if (fRotY != 0.0f
		&& s_pPlayer->IsAlive())
	{
		if (VP_THIRD_PERSON == s_pEng->ViewPoint())
			s_pEng->CameraYawAdd(fRotY);
		// 기절해 있지 않을때만..
		else if (!s_pPlayer->m_bStun)
			s_pPlayer->RotAdd(fRotY);
	}
	if (fRotX)
	{
		// 카메라 확대
		if (VP_THIRD_PERSON == s_pEng->ViewPoint())
			s_pEng->CameraZoom(-fRotX);
		// 카메라 각도
		else
			s_pEng->CameraPitchAdd(fRotX);
	}

	if (fRotY != 0.0f
		|| fRotX != 0.0f)
	{
		SetGameCursor(nullptr);

		POINT ptScreen = ptPrev;
		::ClientToScreen(s_hWndBase, &ptScreen);
		::SetCursorPos(ptScreen.x, ptScreen.y);
		s_pLocalInput->MouseSetPos(ptPrev.x, ptPrev.y);
	}

	return true;
}

// 오른쪽 더블 클릭
bool CGameProcMain::OnMouseRDBtnPress(POINT ptCur, POINT ptPrev)
{
	if(s_pUIMgr->m_bDoneSomething) return false;

	//스킬 매직이 사용되었다면....
	m_pUIHotKeyDlg->EffectTriggerByMouse();

	return true;
}

void CGameProcMain::ProcessUIKeyInput(bool bEnable)
{
	if(m_pUIChatDlg && !m_pUIChatDlg->IsChatMode())
	{
		CGameProcedure::ProcessUIKeyInput();
		if(s_pLocalInput->IsKeyPress(DIK_RETURN) && !s_bKeyPress)
		{
			m_pUIChatDlg->SetFocus();
		}
	}
	else if(m_pUIChatDlg && m_pUIChatDlg->IsChatMode())
	{
		s_bKeyPress = false;
		if(m_pUIChatDlg->GetEnableKillFocus())
		{
			m_pUIChatDlg->SetEnableKillFocus(false);
			m_pUIChatDlg->KillFocus();
		}
	}
}

void CGameProcMain::MsgSend_SpeedCheck(bool bInit)
{
	uint8_t	byBuff[10];											// 버퍼.. 
	int		iOffset=0;											// 옵셋..
	float	fTime = CN3Base::TimeGet();							// 클라이언트 시간

	s_pSocket->MP_AddByte(byBuff, iOffset, WIZ_SPEEDHACK_CHECK);	// 스피드핵 체크 패킷..
	s_pSocket->MP_AddByte(byBuff, iOffset, bInit);				// 서버가 기준 시간으로 쓸 타입 true 이면 기준시간 false면 체크타입
	s_pSocket->MP_AddFloat(byBuff, iOffset, fTime);				// 클라이언트 시간
	s_pSocket->Send(byBuff, iOffset);							// 보냄..
}

void CGameProcMain::MsgRecv_ClassPromotion(Packet& pkt)
{
	uint16_t sClass = pkt.read<uint16_t>();
	uint16_t socketID = pkt.read<uint16_t>();

	// TODO: Clean this up when CPlayerMySelf is derived properly so we can share this logic in a much nicer fashion.
	if (socketID == s_pPlayer->IDNumber())
	{
		s_pPlayer->m_InfoBase.eClass = (e_Class)sClass;
		m_pUIVar->UpdateAllStates(&s_pPlayer->m_InfoBase, &s_pPlayer->m_InfoExt);
		m_pUIHotKeyDlg->ClassChangeHotkeyFlush();
		m_pUISkillTreeDlg->SetPageInCharRegion();
		m_pUISkillTreeDlg->ButtonVisibleStateSet();
		m_pUISkillTreeDlg->InitIconUpdate();
	}
	else
	{
		auto pUPC = s_pOPMgr->UPCGetByID(socketID, false);
		if (pUPC != nullptr)
			pUPC->m_InfoBase.eClass = (e_Class)sClass;
	}

	s_pFX->TriggerBundle(socketID, -1, FXID_CLASS_CHANGE, socketID, -1);
}

void CGameProcMain::MsgRecv_ItemUpgrade(Packet& pkt)
{
	// NOTE: This method may not officially exist; it's inlined into CGameProcMain::ProcessPacket()
	auto opcode = (e_ItemUpgradeOpcode) pkt.read<uint8_t>();
	switch (opcode)
	{
		case ITEM_UPGRADE_REQ:
			if (m_pUIUpgradeSelect != nullptr)
			{
				m_pUIUpgradeSelect->SetVisible(true);

				int iNpcID = pkt.read<int16_t>();
				m_pUIUpgradeSelect->SetNpcID(iNpcID);
			}
			break;

		case ITEM_UPGRADE_PROCESS:
#if 0 // TODO
			if (m_pUIItemUpgrade != nullptr)
				m_pUIItemUpgrade->MsgRecv_ItemUpgrade(pkt);
#endif
			break;

		case ITEM_UPGRADE_ACCESSORIES:
#if 0 // TODO
			if (m_pUIRingUpgrade != nullptr)
				m_pUIRingUpgrade->MsgRecv_RingUpgrade(pkt);
#endif
			break;
	}
}

void CGameProcMain::MsgRecv_ZoneAbility(Packet& pkt)
{
	auto opcode = (e_ZoneAbilityOpcode) pkt.read<uint8_t>();
	if (opcode == ZONE_ABILITY_UPDATE)
	{
		s_pPlayer->m_InfoExt.bCanTradeWithOtherNation	= pkt.read<bool>();
		s_pPlayer->m_InfoExt.eZoneAbilityType			= (e_ZoneAbilityType) pkt.read<uint8_t>();
		s_pPlayer->m_InfoExt.bCanTalkToOtherNation		= pkt.read<bool>();
		s_pPlayer->m_InfoExt.sZoneTariff				= pkt.read<int16_t>();
	}
}

// ===== END WarFare/GameProcMain.cpp =====

// ===== BEGIN WarFare/GameProcMain.h =====
#line 1 "WarFare/GameProcMain.h"
﻿#pragma once

#include "GameProcedure.h"
#include <set>

typedef std::set<int>::iterator it_ID;
typedef std::pair<it_ID, bool> pair_ID;

class CGameProcMain : public CGameProcedure  
{
	friend class CGameProcedure;
protected:
	std::set<int> m_SetNPCID;
	std::set<int> m_SetUPCID;

public:
#ifdef _N3_64GRID_
	CServerMesh		*m_pSMesh;									// 서버에게 필요한 메쉬 클래스..
#endif
	class CUIInventory*			m_pUIInventory;			// 인벤토리
	class CUIVarious*			m_pUIVar;				// 캐릭터 상태창, 기사단 관리 등이 페이지로 들어간 다용도 UI
	class CUIChat*				m_pUIChatDlg;			// 채팅 입출력 대화상자..
	class CUIMessageWnd*		m_pUIMsgDlg;			// 게임 메시지 출력 상자.
	
	// Folded UI
	class CUIChat2*			m_pUIChatDlg2;
	class CUIMessageWnd2*	m_pUIMsgDlg2;

	class CUIStateBar*			m_pUIStateBarAndMiniMap;	// mp,hp,exp, minimap....
	class CUICmd*				m_pUICmd;				// 왼쪽 하단의 명령버튼 창..
	class CUITargetBar*			m_pUITargetBar;			// 타겟 상태창..
	class CUICmdList*			m_pUICmdList;	    
	class CUICmdEdit*			m_pUICmdEdit;
	class CUITransactionDlg*	m_pUITransactionDlg;
	class CUIDroppedItemDlg*	m_pUIDroppedItemDlg;
	class CSubProcPerTrade*		m_pSubProcPerTrade;
	class CUIHelp*				m_pUIHelp;
	class CUIPartyOrForce*		m_pUIPartyOrForce;
	class CUISkillTreeDlg*		m_pUISkillTreeDlg;
	class CUIHotKeyDlg*			m_pUIHotKeyDlg;
	class CUINotice*			m_pUINotice;
	class CUIClassChange*		m_pUIClassChange;
	class CUINPCEvent*			m_pUINpcEvent;
	class CUIRepairTooltipDlg*	m_pUIRepairTooltip;
	class CUIWareHouseDlg*		m_pUIWareHouseDlg;
	class CUIInn*				m_pUIInn;
	class CUICreateClanName*	m_pUICreateClanName;
	class CUIExitMenu*			m_pUIExitMenu;


	class CUIKnightsOperation*	m_pUIKnightsOp;					// 기사단 리스트 보기, 가입, 등...
	class CUIPartyBBS*			m_pUIPartyBBS;					// 파티 지원 게시판.
	class CUITradeSellBBS*		m_pUITradeBBS;					// 상거래 게시판
	class CUIQuestMenu*			m_pUIQuestMenu;					// Quest Menu
	class CUIQuestTalk*			m_pUIQuestTalk;					// Quest Talk
	class CUIDead*				m_pUIDead;						// Dead UI
	class CUITradeBBSSelector*	m_pUITradeBBSSelector;			// 상거래 게시판 종류 선택
	class CUITradeBBSEditDlg*	m_pUITradeBBSEdit;				// 상거래 게시물 설명

	class CUIUpgradeSelect*		m_pUIUpgradeSelect;
	class CUILevelGuide*		m_pUILevelGuide;

	class CN3Shape*				m_pTargetSymbol;				// 플레이어가 타겟으로 잡은 캐릭터의 위치위에 그리면 된다..

	class CN3SndObjStream*		m_pSnd_Town, *m_pSnd_Battle;	//마을음악, 전투음악 포인터..
	class CMagicSkillMng*		m_pMagicSkillMng;

	class CUINPCChangeEvent*	m_pUINpcChange;
	class CUIWarp*				m_pUIWarp;
	class CWarMessage*			m_pWarMessage;					// 전쟁관련 메시지
	class CLightMgr*			m_pLightMgr;

	   
	//..
	BOOL		m_bLoadComplete;							// 로딩이 완료되었나??
	
	float		m_fMsgSendTimeMove;							// 최근 이동 메시지 보낸 시간..
	float		m_fMsgSendTimeRot;							// 최근 회전 메시지 보낸 시간..
	float		m_fPlayerYawSended; // 최근에 메시지를 보낸 시점의 플레이어 y 축 회전값.
	float		m_fRequestGameSave;	// 최근에 게임 데이터 저장을 요청한 시간
	__Vector3	m_vPlayerPosSended; // 최근에 메시지를 보낸 시점의 플레이어 위치.

	__Vector3	m_vMouseLBClickedPos;
	__Vector3	m_vMouseSkillPos;

	float		m_fExitTimer;
	float		m_fLBClickTime;

	int			m_iJoinReqClan;
	int			m_iJoinReqClanRequierID;

	int			KM_COUNT;

	BOOL		m_bIsExitCanceled;
	e_ExitType	m_eExitType;
	int			m_iExitTimeRemaining; // seconds remaining until exit

	float		m_fMBRotateTime;

	std::string	m_szWarpDestination;

protected:
	virtual bool ProcessPacket(Packet& pkt);

	bool	MsgRecv_CharacterSelect(Packet& pkt); // virtual
	int		MsgRecv_VersionCheck(Packet& pkt); // virtual

	bool	MsgRecv_MyInfo_All(Packet& pkt);
	void	MsgRecv_MyInfo_HP(Packet& pkt);
	void	MsgRecv_MyInfo_MSP(Packet& pkt);
	void	MsgRecv_MyInfo_EXP(Packet& pkt);
	bool	MsgRecv_MyInfo_LevelChange(Packet& pkt);
	void	MsgRecv_MyInfo_RealmPoint(Packet& pkt);
	void	MsgRecv_MyInfo_PointChange(Packet& pkt);

	bool	MsgRecv_Chat(Packet& pkt);
	bool	MsgRecv_UserMove(Packet& pkt);
	bool	MsgRecv_Rotation(Packet& pkt);
//	bool	MsgRecv_Dead(Packet& pkt);
	bool	MsgRecv_Regen(Packet& pkt);
	void	MsgRecv_Corpse(Packet& pkt);
	bool	MsgRecv_Time(Packet& pkt);
	bool	MsgRecv_Weather(Packet& pkt);
	
	bool	MsgRecv_UserInAndRequest(Packet& pkt);		// 주위 영역의 모든 User 아이디를 카운트만큼 받는다... 글구.. 업데이트가 필요한 것만 서버에게 요청..
	bool	MsgRecv_UserInRequested(Packet& pkt);					// 서버에게 요청한 유저의 아이디들을 받아서 User 처리..
	bool	MsgRecv_UserInOut(Packet& pkt);
	bool	MsgRecv_UserIn(Packet& pkt, bool bWithFX=false);
	bool	MsgRecv_UserOut(Packet& pkt);
	void	MsgRecv_UserState(Packet& pkt);

	bool	MsgRecv_NPCInAndRequest(Packet& pkt);		// 주위 영역의 모든 NPC 아이디를 카운트만큼 받는다... 글구.. 업데이트가 필요한 것만 서버에게 요청..
	bool	MsgRecv_NPCInRequested(Packet& pkt);				// 서버에게 요청한 NPC 아이디들을 받아서 User 처리..
	bool	MsgRecv_NPCInOut(Packet& pkt);
	bool	MsgRecv_NPCIn(Packet& pkt);
	bool	MsgRecv_NPCOut(Packet& pkt);
	bool	MsgRecv_NPCMove(Packet& pkt);

	bool	MsgRecv_Attack(Packet& pkt);
	bool	MsgRecv_Dead(Packet& pkt);

	bool	MsgRecv_ItemMove(Packet& pkt);					// Item Move에 대한 응답..
	bool	MsgRecv_ItemBundleDrop(Packet& pkt);			// Item 이 필드에 나타나는데에 대한 응답
	bool	MsgRecv_ItemBundleOpen(Packet& pkt);			// 아이템 상자를 열거나 시체를 뒤진다..
	bool	MsgRecv_ItemTradeStart(Packet& pkt);			// 아이템 상거래..
	bool	MsgRecv_ItemTradeResult(Packet& pkt);			// 아이템 상거래 결과..
	bool	MsgRecv_ItemDroppedGetResult(Packet& pkt);	// 땅에 떨어진 아이템 먹기 결과..
	bool	MsgRecv_ItemWeightChange(Packet& pkt);		// 아이템 무게 변화..

	bool	MsgRecv_UserLookChange(Packet& pkt);			// 겉모습이 바뀐다.. 아이템 착용등

	void	MsgRecv_TargetHP(Packet& pkt);

	void	MsgRecv_ZoneChange(Packet& pkt);			// 걍 단순한 존 체인지.

	void	MsgRecv_Notice(Packet& pkt);
	void	MsgRecv_PartyOrForce(Packet& pkt);
	void	MsgRecv_PerTrade(Packet& pkt);

	void	MsgRecv_SkillChange(Packet& pkt);			// 스킬 변화..
	void	MsgRecv_MagicProcess(Packet& pkt);			// 스킬 변화..
	void	MsgRecv_ClassChange(Packet& pkt);			// 직업 변화..
	void	MsgRecv_ClassPromotion(Packet& pkt);

	void	MsgRecv_ObjectEvent(Packet& pkt);			// 오브젝트 이벤트 신청에 대한 응답

	void	MsgRecv_DurabilityChange(Packet& pkt);		// 내구력 변경..
	void	MsgRecv_NpcEvent(Packet& pkt);				// Npc Event(Exchange, Repair both).. 

	void	MsgRecv_Knights(Packet& pkt);				// 기사단 조작 관련 패킷..
	void	MsgRecv_KnightsListBasic(Packet& pkt);		// 기사단 기본 정보들..
	
	void	MsgRecv_CompressedPacket(Packet& pkt);		// 압축된 패킷이다... 압축 풀고 루프를 돌면서 한번더 파싱해야 한다!!!
	void	MsgRecv_ContinousPacket(Packet& pkt);		// 붙어서 오는 패킷이다.. 루프를 돌면서 한번더 파싱해야 한다!!!

	void	MsgRecv_ItemRepair(Packet& pkt);			// Item Repair Result.. 
	void	MsgRecv_ItemCountChange(Packet& pkt);		// Item Count Change..
	void	MsgRecv_ItemDestroy(Packet& pkt);			// Item Count Change..

	void	MsgRecv_WareHouse(Packet& pkt);			// 보관함 관련 패킷..
	void	MsgRecv_WareHouseOpen(Packet& pkt);		// 보관함 오픈..

	void	MsgRecv_NpcChangeOpen(Packet& pkt);		// Class Change와 초기화..
	void	MsgRecv_AllPointInit(Packet& pkt);			// All Point 초기화..
	void	MsgRecv_SkillPointInit(Packet& pkt);		// Skill Point 초기화..
	void	MsgRecv_PointChangePriceQueryRequest(Packet& pkt);		// 가격에 대한 응답 패킷..

	void	MsgRecv_NoahChange(Packet& pkt);			// 노아 변경..
	void	MsgRecv_WarpList(Packet& pkt);				// 워프 리스트..
	void	MsgRecv_WarpList_Error(Packet& pkt);		// 워프 리스트..

	//	void	MsgRecv_ServerCheckAndRequestConcurrentUserCount(Packet& pkt);			// 서버 IP 와 포트를 받아 동접자를 체크해 본다..
//	void	MsgRecv_ConcurrentUserCountAndSendServerCheck(Packet& pkt);
	
	//knights...
	void	MsgRecv_Knights_Create(Packet& pkt);
	void	MsgRecv_Knights_Withdraw(Packet& pkt);
	void	MsgRecv_Knights_Join(Packet& pkt);
	void	MsgRecv_Knights_Leave(Packet& pkt);
	void	MsgRecv_Knights_AppointViceChief(Packet& pkt);
	void	MsgRecv_Knights_MemberInfoAll(Packet& pkt);
	void	MsgRecv_Knights_GradeChangeAll(Packet& pkt);
	void	MsgRecv_Knights_Duty_Change(Packet& pkt);
	void	MsgRecv_Knigts_Join_Req(Packet& pkt);
	void	MsgRecv_ItemUpgrade(Packet& pkt);

	void	MsgRecv_ZoneAbility(Packet& pkt);

public:
	void	ProcessUIKeyInput(bool bEnable = true);
	bool	OnMouseMove(POINT ptCur, POINT ptPrev);
	bool	OnMouseLbtnDown(POINT ptCur, POINT ptPrev);
	bool	OnMouseLBtnPressd(POINT ptCur, POINT ptPrev);
	bool	OnMouseLBtnPress(POINT ptCur, POINT ptPrev);
	bool	OnMouseLDBtnPress(POINT ptCur, POINT ptPrev);
	
	/// \brief attempts to start the auto-attack process
	/// \returns true if auto-attack process started, false otherwise
	bool	TryStartAttack();
	bool	OnMouseRbtnDown(POINT ptCur, POINT ptPrev);
	bool	OnMouseRBtnPressd(POINT ptCur, POINT ptPrev);
	bool	OnMouseRBtnPress(POINT ptCur, POINT ptPrev);
	bool	OnMouseRDBtnPress(POINT ptCur, POINT ptPrev);
	
	void	ControlViewVDegree(int16_t sValue);
	void	PlayBGM_Town();
	void	PlayBGM_Battle();

	void	DoCommercialTransaction(int iTradeID);								// 상거래..

	const __InfoPartyOrForce*	PartyOrForceConditionGet(bool& bIAmLeader, bool& bIAmMember, int& iMemberIndex, class CPlayerBase*& pTarget);
	void						TargetSelect(int iID, bool bMustAlive);
	void						TargetSelect(class CPlayerNPC* pTarget);
	
	void	CommandToggleUIChat();
	void	CommandToggleUIMsgWnd();

	bool	CommandToggleUIInventory();
	bool	CommandToggleUIState();
	bool	CommandToggleAttackContinous();
	bool	CommandToggleMoveContinous();
	bool	CommandToggleWalkRun();
	bool	CommandToggleUISkillTree();
	bool	CommandToggleUIMiniMap();
	bool	CommandToggleCmdList();
	bool	CommandToggleLevelGuide();
	bool	OpenCmdEdit(std::string msg);

	void	CommandMove(e_MoveDirection eMD, bool bStartOrEnd); // 움직이는 방향(전후진, 멈춤), 움직이기 시작하는가?
	void	CommandEnableAttackContinous(bool bEnable, CPlayerBase* pTarget);

	/// \brief contains the logic that should be executed whenever starting to auto-attack
	void	StartAutoAttack(CPlayerBase* target);
	/// \brief contains the logic that should be executed whenever auto-attacking is stopped
	void	StopAutoAttack(CPlayerBase* target = nullptr);
	
	void	CommandCameraChange(); // 카메라 시점 바꾸기..
	void	CommandSitDown(bool bLimitInterval, bool bSitDown, bool bImmediately = false);

	void	CommandTargetSelect_NearestEnemy(); // 가장 가까운 적 타겟 잡기..
	void	CommandTargetSelect_NearestOurForce(); // 가장 가까운 파티 타겟잡기..
	void	CommandTargetSelect_NearestNPC(); // target nearest NPC

	void	CloseUIs(); // 각종 상거래, 워프등등... UI 닫기..

	void	MsgOutput(const std::string& szMsg, D3DCOLOR crMsg);

	void	InitZone(int iZone, const __Vector3& vPosPlayer);
	void	InitUI();
	void	InitPlayerPosition(const __Vector3& vPos); // 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.

	void	MsgSend_Continous();												// 특정 조건(?)하에서 서버에게 정기적으로 메시지를 보냄..
	void	MsgSend_Attack(int iTargetID, float fInterval, float fDistance);	// 공격 패킷 날리기 - 테이블의 공격 주기를 같이 줘서 해킹을 막는다.
	void	MsgSend_Move(bool bMove, bool bContinous);							// 서버에게 움직임 패킷을 날린다.. // 움직이는가 ? 주기적으로 움직이는 건가?
	void	MsgSend_Rotation();													// 서버에게 회전 패킷을 날린다..
	void	MsgSend_Chat(enum e_ChatMode eMode, const std::string& szChat);		// 서버에게 채팅 메시지를 날린다..
	void	MsgSend_ChatSelectTarget(const std::string& szTargetID); // 일대일 채팅 상대 정하기.
	void	MsgSend_Regen();
	bool	MsgSend_RequestItemBundleOpen(CPlayerNPC* pCorpse); // 아이템 상자를 열거나 시체를 뒤진다..
	void	MsgSend_RequestTargetHP(int16_t siIDTarget, uint8_t byUpdateImmediately); // 0x00 - 점차 늘어나게끔.. 0x01 - 즉시 업데이트..
	void	MsgSend_GameStart();
	bool	MsgSend_NPCEvent(int16_t siIDTarget);
	void	MsgSend_NPCInRequest(int iID); // NPC 정보가 없을 경우 요청한다..
	void	MsgSend_UserInRequest(int iID); // User 정보가 없을 경우 요청한다..
	void	MsgSend_Warp(); // 워프?? - 존체인지가 될수도 있다..
	void	MsgSend_StateChange(enum e_SubPacket_State eSP, int iState);
	void	MsgSend_PerTradeReq(int iDestID, bool bNear = true);
	void	MsgSend_SpeedCheck(bool bInit = false);

	void	MsgSend_PartyOrForcePermit(int iPartyOrForce, bool bYesNo); // iPartyOrForce 1 : Party, 2:Force
	void	MsgSend_PartyOrForceLeave(int iPartyOrForce); // iPartyOrForce 1 : Party, 2:Force
	bool	MsgSend_PartyOrForceCreate(int iPartyOrForce, const std::string& szID); // iPartyOrForce 1 : Party, 2:Force

	void	MsgSend_ObjectEvent(int iEventID, int iNPCID);		// 오브젝트에 설정되어 있는 이벤트 요청..
	void	MsgSend_Weather(int iWeather, int iPercent);
	void	MsgSend_Time(int iHour, int iMin);
	void	MsgSend_Administrator(enum e_SubPacket_Administrator eSP, const std::string& szID);
	
	void	MsgSend_KnightsJoin(int iTargetID);
	void	MsgSend_KnightsLeave(std::string& szName);
	void	MsgSend_KnightsWithdraw();
	void	MsgSend_KnightsAppointViceChief(std::string& szName);
	void	MsgSend_KnightsJoinReq(bool bJoin);	
	void	MsgSend_PerTradeBBSReq(std::string szName, int iDestID);
	void	MsgSend_CharacterSelect(); // virtual


	void	ProcessPlayerInclination();				// 경사 처리..(가만히 있어도 경사가 급하면 미끄러짐..).
	void	ProcessLocalInput(uint32_t dwMouseFlags);	// 키보드 눌린것을 처리한다..

	void	RequestExit();
	void	ParseChattingCommand(const std::string& szCmd);
	

	void	UpdateUI_PartyOrForceButtons(); // 커맨드 줄에 있는 파티 버튼을 상황에 따라 업데이트 해준다.
	void	UpdateUI_MiniMap();
	void	UpdateUI_TargetBar();
	void	UpdateBGM();
	void	UpdateCameraAndLight();

	void	RenderTarget();
	
	void	Init();									// UI 와 UI 리소스등을 읽는다.
	void	Release();								// Release..	
	void	ReleaseUIs();
	void	ReleaseSound();
	
	void	Tick();								// 잡다한 계산..
	void	Render();							// 렌더링..

	CGameProcMain();									// 생성자.
	virtual ~CGameProcMain();							// 소멸자.
};

// ===== END WarFare/GameProcMain.h =====

// ===== BEGIN WarFare/GameProcNationSelect.cpp =====
#line 1 "WarFare/GameProcNationSelect.cpp"
﻿// GameProcNationSelect.cpp: implementation of the CGameProcNationSelect class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "PacketDef.h"
#include "GameEng.h"
#include "APISocket.h"

#include "GameProcNationSelect.h"
#include "PlayerMySelf.h"
#include "UINationSelectDlg.h"
#include "UIManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcNationSelect::CGameProcNationSelect()
{
	m_pUINationSelectDlg = nullptr;
	s_pPlayer->m_InfoBase.eNation = NATION_NOTSELECTED; // 아직 국가를 선택하지 않았다..
}

CGameProcNationSelect::~CGameProcNationSelect()
{
	delete m_pUINationSelectDlg; m_pUINationSelectDlg = nullptr;
}

void CGameProcNationSelect::Release()
{
	CGameProcedure::Release();

	delete m_pUINationSelectDlg; m_pUINationSelectDlg = nullptr;
}

void CGameProcNationSelect::Init()
{
	CGameProcedure::Init();

	std::string szTemp; 
	
	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(NATION_ELMORAD);
	if (pTbl != nullptr)
		szTemp = pTbl->szNationSelectNew;
	
	m_pUINationSelectDlg = new CUINationSelectDlg();
	m_pUINationSelectDlg->Init(s_pUIMgr);
	m_pUINationSelectDlg->LoadFromFile(szTemp);
	m_pUINationSelectDlg->m_pProcNationSelectRef = this; // 참조 포인터 넣기..

	s_pPlayer->m_InfoBase.eNation = NATION_NOTSELECTED; // 아직 국가를 선택하지 않았다..
}

void CGameProcNationSelect::Tick()
{
	CGameProcedure::Tick();	// 키, 마우스 입력 등등..

	if(NATION_KARUS == s_pPlayer->m_InfoBase.eNation || NATION_ELMORAD == s_pPlayer->m_InfoBase.eNation)
		CGameProcedure::ProcActiveSet((CGameProcedure*)s_pProcCharacterSelect); // 국가를 골랐으면 캐릭터 선택으로 바로 간다..
}

void CGameProcNationSelect::Render()
{
	uint32_t color = 0x00000000; // 검은색으로..
	s_pEng->Clear(color); // 클리어..
	s_pEng->s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...

	CGameProcedure::Render(); // UI 나 그밖의 기본적인 것들 렌더링..

	s_pEng->s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	s_pEng->Present(CN3Base::s_hWndBase);
}


void CGameProcNationSelect::MsgSendNationSelect(e_Nation eNation)
{
	uint8_t byBuff[4];										// 패킷 버퍼..
	int iOffset=0;										// 버퍼의 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_SEL_NATION);	// 커멘드.
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)eNation);		// 아이디 길이..
		
	s_pSocket->Send(byBuff, iOffset);								// 보낸다

	s_pUIMgr->EnableOperationSet(false); // 응답 패킷을 받기 전까지 아무짓 못하게 한다..
}

bool CGameProcNationSelect::ProcessPacket(Packet& pkt)
{
	size_t rpos = pkt.rpos();
	if (CGameProcedure::ProcessPacket(pkt))
		return true;

	pkt.rpos(rpos);

	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	switch ( iCmd )										// 커멘드에 다라서 분기..
	{
		case WIZ_SEL_NATION:							// 캐릭터 선택 메시지..
		{
			int iNation = pkt.read<uint8_t>(); // 국가 - 0 실패.. 1 - 카루스 2 - 엘모라드..

			if( 0 == iNation ) 	s_pPlayer->m_InfoBase.eNation = NATION_NOTSELECTED; // 아직 국가를 선택하지 않았다..
			else if( 1 == iNation ) s_pPlayer->m_InfoBase.eNation = NATION_KARUS;
			else if( 2 == iNation ) s_pPlayer->m_InfoBase.eNation = NATION_ELMORAD;
		}
		return true;
	}
	
	return false;
}
// ===== END WarFare/GameProcNationSelect.cpp =====

// ===== BEGIN WarFare/GameProcNationSelect.h =====
#line 1 "WarFare/GameProcNationSelect.h"
﻿// GameProcNationSelect.h: interface for the CGameProcNationSelect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMEPROCNATIONSELECT_H__83F05883_F45C_4119_BD8F_EBF2C2CF0A29__INCLUDED_)
#define AFX_GAMEPROCNATIONSELECT_H__83F05883_F45C_4119_BD8F_EBF2C2CF0A29__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameProcedure.h"

class CGameProcNationSelect : public CGameProcedure   
{
public:
	class CUINationSelectDlg* m_pUINationSelectDlg;	

protected:
	virtual bool ProcessPacket(Packet& pkt);

public:
	void MsgSendNationSelect(e_Nation eNation);
	
	void Release();
	void Init();
	void Tick();
	void Render();

	CGameProcNationSelect();
	virtual ~CGameProcNationSelect();
};

#endif // !defined(AFX_GAMEPROCNATIONSELECT_H__83F05883_F45C_4119_BD8F_EBF2C2CF0A29__INCLUDED_)

// ===== END WarFare/GameProcNationSelect.h =====

// ===== BEGIN WarFare/GameProcOption.cpp =====
#line 1 "WarFare/GameProcOption.cpp"
﻿// GameProcOption.cpp: implementation of the CGameProcOption class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcOption.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGameProcOption::CGameProcOption()
{
}

CGameProcOption::~CGameProcOption()
{
}

void CGameProcOption::Init()
{
	CGameProcedure::Init();
}

void CGameProcOption::Release()
{
	CGameProcedure::Release();
}

void CGameProcOption::Render()
{
	CGameProcedure::Render(); // UI 나 그밖의 기본적인 것들 렌더링..
}

void CGameProcOption::Tick()
{
	CGameProcedure::Tick();	// 키, 마우스 입력 등등..
}

// ===== END WarFare/GameProcOption.cpp =====

// ===== BEGIN WarFare/GameProcOption.h =====
#line 1 "WarFare/GameProcOption.h"
﻿// GameProcOption.h: interface for the CGameProcOption class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GAMEPROCOPTION_H__98F2C543_CFC5_45AA_84DA_B93B34A29C46__INCLUDED_)
#define AFX_GAMEPROCOPTION_H__98F2C543_CFC5_45AA_84DA_B93B34A29C46__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameProcedure.h"

class CGameProcOption : public CGameProcedure  
{
public:
	void Init();
	void Release();
	void Tick();
	void Render();
	
	CGameProcOption();
	virtual ~CGameProcOption();

};

#endif // !defined(AFX_GAMEPROCOPTION_H__98F2C543_CFC5_45AA_84DA_B93B34A29C46__INCLUDED_)

// ===== END WarFare/GameProcOption.h =====

// ===== BEGIN WarFare/GameProcedure.cpp =====
#line 1 "WarFare/GameProcedure.cpp"
﻿// GameProcedure.cpp: implementation of the CGameProcedure class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcedure.h"
#include "GameDef.h"
#include "GameEng.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "N3FXMgr.h"
#include "PlayerMyself.h"
#include "GameProcLogIn.h"
#include "GameProcNationSelect.h"
#include "GameProcCharacterCreate.h"
#include "GameProcCharacterSelect.h"
#include "GameProcMain.h"
#include "GameProcOption.h"
#include "UILoading.h"
#include "UIMessageBox.h"
#include "UIMessageBoxManager.h"
#include "UIManager.h"
#include "UINotice.h"
#include "UIHelp.h"
#include "UIHotKeyDlg.h"
#include "UIChat.h"
#include "UIVarious.h"
#include "UIPartyOrForce.h"
#include "UIMessageWnd.h"
#include "UIEndingDisplay.h"
#include "MagicSkillMng.h"
#include "GameCursor.h"
#include "resource.h"
#include "text_resources.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3FXBundle.h>

#include <N3Base/BitmapFile.h>

#include <JpegFile/JpegFile.h>

#include <shared/lzf.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CN3SndObjStream*	CGameProcedure::s_pSnd_BGM = nullptr;			// 메인 배경음악 포인터..
CLocalInput*		CGameProcedure::s_pLocalInput = nullptr;		// 마우스와 키보드 입력 객체 .. Direct Input 을 썼다.
CAPISocket*			CGameProcedure::s_pSocket = nullptr;			// 메인 소켓 객체
CAPISocket*			CGameProcedure::s_pSocketSub = nullptr;		// 서브 소켓 객체
CGameEng*			CGameProcedure::s_pEng = nullptr;				// 3D Wrapper Engine
CN3FXMgr*			CGameProcedure::s_pFX = nullptr;

CUIManager*			CGameProcedure::s_pUIMgr = nullptr;			// UI Manager
CUILoading*			CGameProcedure::s_pUILoading = nullptr;		// 로딩바..
CUIMessageBoxManager*	CGameProcedure::s_pMsgBoxMgr = nullptr;		// MessageBox Manager
//bool				CGameProcedure::s_bUseSpeedHack = false;

CGameProcedure*				CGameProcedure::s_pProcPrev = nullptr;
CGameProcedure*				CGameProcedure::s_pProcActive = nullptr;

CGameProcLogIn*				CGameProcedure::s_pProcLogIn = nullptr;
CGameProcNationSelect*		CGameProcedure::s_pProcNationSelect = nullptr;
CGameProcCharacterCreate*	CGameProcedure::s_pProcCharacterCreate = nullptr;
CGameProcCharacterSelect*	CGameProcedure::s_pProcCharacterSelect = nullptr;
CGameProcMain*				CGameProcedure::s_pProcMain = nullptr;
CGameProcOption*			CGameProcedure::s_pProcOption = nullptr;
CGameCursor*				CGameProcedure::s_pGameCursor = nullptr;

HCURSOR	CGameProcedure::s_hCursorNormal    = nullptr;
HCURSOR	CGameProcedure::s_hCursorNormal1   = nullptr;
HCURSOR CGameProcedure::s_hCursorClick     = nullptr;
HCURSOR CGameProcedure::s_hCursorClick1    = nullptr;
HCURSOR CGameProcedure::s_hCursorAttack    = nullptr;
HCURSOR CGameProcedure::s_hCursorPreRepair = nullptr;
HCURSOR CGameProcedure::s_hCursorNowRepair = nullptr;

e_LogInClassification CGameProcedure::s_eLogInClassification; // 접속한 서비스.. MGame, Daum, KnightOnLine ....
std::string	CGameProcedure::s_szAccount = ""; // 계정 문자열..
std::string	CGameProcedure::s_szPassWord = ""; // 계정 비번..
std::string	CGameProcedure::s_szServer = ""; // 서버 문자열..
bool CGameProcedure::m_bCursorLocked = false;
HCURSOR CGameProcedure::m_hPrevGameCursor = nullptr;
HWND CGameProcedure::s_hWndSubSocket = nullptr; // 서브 소켓용 윈도우 핸들..
int	CGameProcedure::s_iChrSelectIndex = 0;
bool CGameProcedure::s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
bool CGameProcedure::s_bWindowed = false; // 창모드 실행??
bool CGameProcedure::s_bKeyPress = false;	//키가 눌려졌을때 ui에서 해당하는 조작된적이 있다면
bool CGameProcedure::s_bKeyPressed = false;	//키가 올라갔을때 ui에서 해당하는 조작된적이 있다면

bool CGameProcedure::s_bIsRestarting = false;

// NOTE: adding boolean to check if window has focus or not
bool CGameProcedure::s_bIsWindowInFocus = true;

CGameProcedure::CGameProcedure()
{
	m_bCursorLocked = false;
}

CGameProcedure::~CGameProcedure()
{
	m_bCursorLocked = false;
}

void CGameProcedure::Release()
{
	s_pUIMgr->SetFocusedUI(nullptr);
}

void CGameProcedure::Init()
{
	s_pUIMgr->SetFocusedUI(nullptr);
}

void CGameProcedure::StaticMemberInit(HINSTANCE hInstance, HWND hWndMain)
{
	//////////////////////////////////////////////////////////////////////////////////////////
	// 게임 기본 3D 엔진 만들기..
	s_bWindowed = true;
	// #if _DEBUG 

	if (s_Options.bWindowMode) 
	{
		DEVMODE dm = {};
		EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &dm);
		if (dm.dmBitsPerPel != (DWORD) s_Options.iViewColorDepth)
		{
			dm.dmSize = sizeof(DEVMODE);
			dm.dmPelsWidth = s_Options.iViewWidth;
			dm.dmPelsHeight = s_Options.iViewHeight;
			dm.dmBitsPerPel = s_Options.iViewColorDepth;
			dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
			::ChangeDisplaySettings(&dm, CDS_FULLSCREEN);
		}
	}
	else
	{
		DEVMODE dm = {};
		dm.dmSize = sizeof(DEVMODE);
		dm.dmPelsWidth = s_Options.iViewWidth;
		dm.dmPelsHeight = s_Options.iViewHeight;
		dm.dmBitsPerPel = s_Options.iViewColorDepth;
		dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
		::ChangeDisplaySettings(&dm, CDS_FULLSCREEN);
	}

	s_pEng = new CGameEng();
	if (!s_pEng->Init(
		s_bWindowed,
		hWndMain,
		s_Options.iViewWidth,
		s_Options.iViewHeight,
		s_Options.iViewColorDepth,
		TRUE))
		exit(-1);

	// 게임 기본 3D 엔진 만들기..
	::SetFocus(hWndMain); // Set focus this window..

	RECT rc;
	::GetClientRect(s_hWndBase, &rc);
	RECT rcTmp = rc; rcTmp.left = (rc.right - rc.left) / 2; rcTmp.bottom = rcTmp.top + 30;
	CN3UIEdit::CreateEditWindow(s_hWndBase, rcTmp);
	//////////////////////////////////////////////////////////////////////////////////////////

	//s_hWndSubSocket = hWndSub; // 서브 소켓용 윈도우 핸들..

	CGameBase::StaticMemberInit(); // Table 및 지형, 오브젝트, 캐릭터 초기화...

	//////////////////////////////////////////////////////////////////////////////////////////
	// Game Procedure 소켓과 로컬 인풋, 3D엔진, Resource Table 로딩 및 초기화...
	s_pSocket = new CAPISocket();
	s_pSocketSub = new CAPISocket();

	// 커서 만들기..
	s_hCursorNormal		= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_NORMAL));
	s_hCursorNormal1	= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_NORMAL1));
	s_hCursorClick		= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_CLICK));
	s_hCursorClick1		= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_CLICK1));
	s_hCursorAttack		= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_ATTACK));
	s_hCursorPreRepair	= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_PRE_REPAIR));
	s_hCursorNowRepair	= LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CURSOR_NOW_REPAIR));

	if (!CN3Base::s_Options.bWindowCursor)
	{
		s_pGameCursor = new CGameCursor();
		s_pGameCursor->LoadFromFile("ui\\cursor.uif");
	}

	SetGameCursor(s_hCursorNormal);

	s_pLocalInput = new CLocalInput();
	s_pLocalInput->Init(hInstance, hWndMain); // Input 만 초기화.

	//////////////////////////////////////////////////////////////////////////////////////////
	// Sound 초기화..
	if(CN3Base::s_Options.bSndEnable)
	{
		CN3Base::s_SndMgr.Init(s_hWndBase);//pWindow);
		CN3Base::s_SndMgr.SetDuplicated(CN3Base::s_Options.bSndDuplicated);
	}
	CN3FXBundle::SetEffectSndDistance(float(CN3Base::s_Options.iEffectSndDist));

	s_pFX = new CN3FXMgr();

	__TABLE_UI_RESRC* pTblUI = s_pTbl_UI.Find(NATION_ELMORAD); // 기본은 엘모라드 UI 로 한다..
	if(pTblUI == nullptr) {
		printf("ERROR: UI table is NULL.\n");
		system("pause");
		//Sleep(1000 * 5);
		exit(-1);
	}

	s_pUIMgr = new CUIManager(); // 기본 UIManager
	s_pMsgBoxMgr = new CUIMessageBoxManager(); //MessageBox Manager

	// 툴팁..
	CN3UIBase::EnableTooltip(pTblUI->szToolTip);

	//////////////////////////////////////////////////////////////////////////////////////////
	// 각 프로시저들 생성
	s_pProcLogIn			= new CGameProcLogIn();				// 로그인 프로시져
	s_pProcNationSelect		= new CGameProcNationSelect();		// 나라 선택
	s_pProcCharacterSelect	= new CGameProcCharacterSelect();	// 캐릭터 선택
	s_pProcCharacterCreate	= new CGameProcCharacterCreate();	// 캐릭터 만들기
	s_pProcMain				= new CGameProcMain();				// 메인 게임 프로시져
	s_pProcOption			= new CGameProcOption();			// 게임 옵션 프로시져
}

void CGameProcedure::StaticMemberRelease()
{
	delete s_pSocket; s_pSocket = nullptr; // 통신 끊기..
	delete s_pSocketSub; s_pSocketSub = nullptr; // 서브 소켓 없애기..
	delete s_pFX; s_pFX = nullptr;

	////////////////////////////////////////////////////////////
	// 기본값 쓰기..
	if(s_pPlayer)
	{
		int iRun = s_pPlayer->IsRunning(); // 이동 모드가 뛰는 상태였으면 
		CGameProcedure::RegPutSetting("UserRun", &iRun, 4); // 걷기, 뛰기 상태 기록..
	}
	
	if(s_pEng)
	{
		e_ViewPoint eVP = s_pEng->ViewPoint();
		CGameProcedure::RegPutSetting("CameraMode", &eVP, 4); // 카메라 상태 기록
	}
	// 기본값 쓰기..
	////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////
	// 엔딩화면 보이기..
	if(s_pPlayer)
	{
		e_Nation eNation = s_pPlayer->m_InfoBase.eNation;
		__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(eNation);
		if(pTbl)
		{
			CUIEndingDisplay Credit; // 엔딩 표시하기..
			Credit.LoadFromFile(pTbl->szEndingDisplay);
			Credit.Render();
		}
	}
	// 엔딩화면 보이기..
	////////////////////////////////////////////////////////////////////////

	Sleep(1000);

	if (s_Options.bWindowMode)
	{
		DEVMODE dm = {};
		::EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &dm);

		if (dm.dmBitsPerPel != (DWORD) s_Options.iViewColorDepth)
		{
			dm.dmSize = sizeof(DEVMODE);
			dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
			::ChangeDisplaySettings(&dm, CDS_FULLSCREEN);
		}
	}
	else
	{
		DEVMODE dm = {};
		::EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &dm);

		if (dm.dmPelsWidth != (DWORD) s_Options.iViewWidth
			|| dm.dmPelsHeight != (DWORD) s_Options.iViewHeight
			|| dm.dmBitsPerPel != (DWORD) s_Options.iViewColorDepth)
		{
			dm.dmSize = sizeof(DEVMODE);
			dm.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
			::ChangeDisplaySettings(&dm, CDS_FULLSCREEN);
		}
	}

//	if ( (s_pProcMain) && (s_pProcMain->m_pUIHotKeyDlg) )
//			s_pProcMain->m_pUIHotKeyDlg->CloseIconRegistry();

	// UI 위치및 보이기 등의 정보 저장..
	if(s_pProcMain)
	{
		UIPostData_Write(UI_POST_WND_CHAT, s_pProcMain->m_pUIChatDlg);
		UIPostData_Write(UI_POST_WND_HOTKEY, s_pProcMain->m_pUIHotKeyDlg);
		UIPostData_Write(UI_POST_WND_HELP, s_pProcMain->m_pUIHelp);
		UIPostData_Write(UI_POST_WND_PARTY, s_pProcMain->m_pUIPartyOrForce);
		UIPostData_Write(UI_POST_WND_INFO, s_pProcMain->m_pUIMsgDlg);
	}

	// 각 프로시저들
	delete s_pProcLogIn; s_pProcLogIn = nullptr; 						// 로그인 프로시져
	delete s_pProcNationSelect; s_pProcNationSelect = nullptr; 		// 나라 선택
	delete s_pProcCharacterSelect; s_pProcCharacterSelect = nullptr; 	// 캐릭터 선택
	delete s_pProcCharacterCreate; s_pProcCharacterCreate = nullptr; 	// 캐릭터 만들기
	delete s_pProcMain; s_pProcMain = nullptr; 						// 메인 게임 프로시져
	delete s_pProcOption; s_pProcOption = nullptr; 					// 게임 옵션 프로시져

	// UI 들 날리기..
	if(s_pUILoading) delete s_pUILoading; s_pUILoading = nullptr;		// Loading Bar
	delete s_pMsgBoxMgr;
	delete s_pUIMgr; s_pUIMgr = nullptr;				// UI Manager

//	delete s_pIME; s_pIME = nullptr;
	delete s_pLocalInput; s_pLocalInput = nullptr;
	delete s_pEng; s_pEng = nullptr; // 젤 마지막에 엔진 날리기.!!!!!

	if(s_pGameCursor) delete s_pGameCursor; s_pGameCursor = nullptr;

	CGameBase::StaticMemberRelease();
}

void CGameProcedure::Tick()
{
	s_pLocalInput->Tick(); // 키보드와 마우스로부터 입력을 받는다.

	if (s_pGameCursor != nullptr)
		s_pGameCursor->Tick();

	ProcessUIKeyInput();

	uint32_t dwMouseFlags = s_pLocalInput->MouseGetFlag();
	POINT ptPrev = s_pLocalInput->MouseGetPosOld();
	POINT ptCur = s_pLocalInput->MouseGetPos();

	e_Nation eNation = s_pPlayer->m_InfoBase.eNation;
	if (dwMouseFlags & MOUSE_LBCLICK)
		SetGameCursor(((NATION_ELMORAD == eNation) ? s_hCursorClick1 : s_hCursorClick));
	else if (dwMouseFlags & MOUSE_LBCLICKED)
		SetGameCursor(((NATION_ELMORAD == eNation) ? s_hCursorNormal1 : s_hCursorNormal));
	if (dwMouseFlags & MOUSE_RBCLICKED)
	{
		// 메인 프로시져 이면..
		if (s_pPlayer->m_bAttackContinous && s_pProcActive == s_pProcMain)
			SetGameCursor(s_hCursorAttack);
		else
			SetGameCursor(((NATION_ELMORAD == eNation) ? s_hCursorNormal1 : s_hCursorNormal));
	}

	uint32_t dwRet = s_pMsgBoxMgr->MouseProcAndTick(dwMouseFlags, ptCur, ptPrev);
	if (dwRet == 0)
		dwRet = s_pUIMgr->MouseProc(dwMouseFlags, ptCur, ptPrev);

	s_pUIMgr->Tick();

	// 몬가 하면... 
//	if((dwRet & UI_MOUSEPROC_CHILDDONESOMETHING) || (dwRet & UI_MOUSEPROC_DONESOMETHING))
//		s_pLocalInput->MouseRemoveFlag(0xffMOUSE_LBCLICK | MOUSE_LBCLICKED | MOUSE_LBDBLCLK);
	s_pUIMgr->m_bDoneSomething = false;		// UI 에서 조작을 했다...
	if(dwRet != UI_MOUSEPROC_NONE)
		s_pUIMgr->m_bDoneSomething = true;		// UI 에서 조작을 했다...

	CN3Base::s_SndMgr.Tick(); // Sound Engine...

	// 스크린 캡쳐 키..
	if(s_pLocalInput->IsKeyPress(DIK_NUMPADMINUS)) // 키패드의 마이너스 키를 누르면..
	{
		SYSTEMTIME st;
		::GetLocalTime(&st);

		std::string szFN = fmt::format("{}_{}_{}_{}.{}.{}.ksc",
			st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
		CaptureScreenAndSaveToFile(szFN);
	}

	//////////////////////////////////
	// Network Msg 처리하기
	while (!s_pSocket->m_qRecvPkt.empty())
	{
		auto pkt = s_pSocket->m_qRecvPkt.front();
		if (!ProcessPacket(*pkt))
			CLogWriter::Write("Invalid Packet... ({})", pkt->GetOpcode());

		delete pkt;
		s_pSocket->m_qRecvPkt.pop();
	}

	while (!s_pSocketSub->m_qRecvPkt.empty())
	{
		auto pkt = s_pSocketSub->m_qRecvPkt.front();
		if (!ProcessPacket(*pkt))
			break;

		delete pkt;
		s_pSocketSub->m_qRecvPkt.pop();
	}
	// Network Msg 처리하기
	//////////////////////////////////
}

void CGameProcedure::Render()
{
	if(s_pUIMgr) s_pUIMgr->Render(); // UI 들 렌더링..

	s_pMsgBoxMgr->Render();
	if(s_pGameCursor) s_pGameCursor->Render();
}

void CGameProcedure::TickActive()
{
	if(s_pProcActive != s_pProcPrev) // 프로시저가 바뀌면..
	{
		if(s_pProcPrev) s_pProcPrev->Release();
		if(s_pProcActive) s_pProcActive->Init();

		s_pProcPrev = s_pProcActive;
	}

	if(s_pProcActive)	s_pProcActive->Tick();		// 현재 프로시저 Tick ................................
}

void CGameProcedure::RenderActive()
{
//	if(s_pProcActive != s_pProcPrev) // 프로시저가 바뀌면..
//	{
//		if(s_pProcPrev) s_pProcPrev->Release();
//		if(s_pProcActive) s_pProcActive->Init();
//
//		s_pProcPrev = s_pProcActive;
//	}
//	else 
//	{
		if(s_pProcActive == s_pProcPrev) s_pProcActive->Render();
//	}
}

bool CGameProcedure::CaptureScreenAndSaveToFile(const std::string& szFN)
{
	/*
	if(szFN.empty()) return false;
	CJpegFile file;

	RECT wndRect;
	GetWindowRect(CN3Base::s_hWndBase, &wndRect);
	
	HANDLE hDIB = file.CopyScreenToDIB(&wndRect);
	if(hDIB)
	{
		int nQuality = 90;
		char szBuf[256] = "";

		//운영자는 양질의 스크린 캡쳐를 할수 있게...
		if(s_pPlayer->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
			nQuality = 100;

		if(file.EncryptJPEG(hDIB, nQuality, szFN, szBuf) == TRUE)
		{
			TRACE("Screen Captue %s\n", szFN.c_str());
		}
		GlobalFree(hDIB);
	}
	*/
	return true;
/*
	int iW = CN3Base::s_CameraData.vp.Width;
	int iH = CN3Base::s_CameraData.vp.Height;

	bool bResult = false;
	LPDIRECT3DSURFACE8 lpDDSTmp = nullptr;
	LPDIRECT3DSURFACE8 lpDDSBack = nullptr;
	CN3Base::s_lpD3DDev->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &lpDDSBack);
	if(lpDDSBack)
	{
		CN3Base::s_lpD3DDev->CreateImageSurface(iW, iH, D3DFMT_X8R8G8B8, &lpDDSTmp);
		if(lpDDSTmp)
		{
			HRESULT rval = D3DXLoadSurfaceFromSurface(lpDDSTmp, nullptr, nullptr, lpDDSBack, nullptr, nullptr, D3DX_FILTER_NONE, 0);
//			HRESULT rval = s_lpD3DDev->CopyRects(lpDDSBack, nullptr, 0, lpDDSTmp, nullptr);
//			char szErr[256];
//			::D3DXGetErrorString(rval, szErr, 256);

			if(D3D_OK == rval)
			{
				D3DLOCKED_RECT LR;
				if(D3D_OK == lpDDSTmp->LockRect(&LR, nullptr, 0))
				{
//					std::vector<uint8_t> buff(iW * iH * 3, 0);
					CBitMapFile bmf;
					bmf.Create(iW, iH);

					for(int y = 0; y < iH; y++)
					{
						uint8_t* pPS = ((uint8_t*)LR.pBits) + LR.Pitch * y;
//						uint8_t* pPD = (uint8_t*)(&(buff[y * (iW * 3)]));
						uint8_t* pPD = (uint8_t*)(bmf.Pixels(0, y));

						for(int x = 0; x < iW; x++, pPS += 4, pPD +=3 )
						{
							pPD[0] = pPS[0];
							pPD[1] = pPS[1];
							pPD[2] = pPS[2];
						}
					}
					lpDDSTmp->UnlockRect();

//					CJpeg jpg;
//					jpg.SaveJPG(szFN.c_str(), iW, iH, &(buff[0]));
					bmf.SaveToFile(szFN.c_str());
				}
			}
			
			lpDDSTmp->Release();
			lpDDSTmp = nullptr;
		}


		lpDDSBack->Release();
		lpDDSBack = nullptr;
	}

	return bResult;
*/
}

void CGameProcedure::ProcActiveSet(CGameProcedure* pProc)
{
	if (pProc == nullptr
		|| s_pProcActive == pProc)
		return;

	if (s_pUIMgr != nullptr)
		s_pUIMgr->EnableOperationSet(true); // UI를 조작할수 있게 한다..

	CGameProcedure::MessageBoxClose(-1); // MessageBox 가 떠 있으면 감춘다.

	s_pProcPrev = s_pProcActive; // 전의 것 포인터 기억..
	s_pProcActive = pProc;
}

void CGameProcedure::ReConnect()
{
	s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
	CGameProcedure::s_pSocket->ReConnect();
	s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..
}

std::string CGameProcedure::MessageBoxPost(const std::string& szMsg, const std::string& szTitle, int iStyle, e_Behavior eBehavior)
{
	return s_pMsgBoxMgr->MessageBoxPost(szMsg, szTitle, iStyle, eBehavior);
}

void CGameProcedure::MessageBoxClose(const std::string& szMsg)
{
	s_pMsgBoxMgr->MessageBoxClose(szMsg);
}

void CGameProcedure::MessageBoxClose(int iMsgBoxIndex)
{
	if( iMsgBoxIndex == -1 )
		s_pMsgBoxMgr->MessageBoxCloseAll();
}


bool CGameProcedure::RegPutSetting( const char *ValueName, void *pValueData, long length )
{
	HKEY	hKey;

	if ( RegOpenKey( HKEY_CURRENT_USER, GetStrRegKeySetting().c_str(), &hKey ) != ERROR_SUCCESS ) 
	{
		if ( RegCreateKey( HKEY_CURRENT_USER, GetStrRegKeySetting().c_str(), &hKey ) != ERROR_SUCCESS )
		{
			__ASSERT(0, "Registry Create Failed!!!");
			return false;
		}
		if(RegOpenKey( HKEY_CURRENT_USER, GetStrRegKeySetting().c_str(), &hKey ) != ERROR_SUCCESS ) 
		{
			__ASSERT(0, "Registry Open Failed!!!");
			return false;
		}
	}

	// set the value
	if ( RegSetValueEx( hKey, ValueName, 0, REG_BINARY, (const uint8_t *)pValueData, length ) != ERROR_SUCCESS )
	{
		__ASSERT(0, "Registry Write Failed!!!");
		RegCloseKey( hKey );
		return false;
	}

	if ( RegCloseKey( hKey ) != ERROR_SUCCESS ) 
	{
		__ASSERT(0, "Registry Close Failed!!!");
		return false;
	}

	return true;
}

bool CGameProcedure::RegGetSetting( const char *ValueName, void *pValueData, long length)
{
	HKEY	hKey;
	DWORD	Type;
	DWORD	len;

	len = length;

	if ( RegOpenKey( HKEY_CURRENT_USER, GetStrRegKeySetting().c_str(), &hKey ) != ERROR_SUCCESS ) 
	{
//		__ASSERT(0, "Registry Open Failed!!!");
		return false;
	}

	// get the value
	if ( RegQueryValueEx( hKey, ValueName, nullptr, &Type, (uint8_t *)pValueData, &len ) != ERROR_SUCCESS )
	{
//		__ASSERT(0, "Registry Query Failed!!!");
		RegCloseKey( hKey );
		return false;
	}

	if ( RegCloseKey( hKey ) != ERROR_SUCCESS ) 
	{
//		__ASSERT(0, "Registry Close Failed!!!");
		return false;
	}

	return true;
}

void CGameProcedure::UIPostData_Write(const std::string& szKey, CN3UIBase* pUI)
{
	if(szKey.empty() || nullptr == pUI) return;

	__WndInfo WI;
	lstrcpyn(WI.szName, szKey.c_str(), 16);
	WI.bVisible = pUI->IsVisible();
	WI.ptPosition = pUI->GetPos();

	RegPutSetting(WI.szName, &WI, sizeof(__WndInfo) );
}

void CGameProcedure::UIPostData_Read(const std::string& szKey, CN3UIBase* pUI, int iDefaultX, int	 iDefaultY)
{
	if(szKey.empty() || nullptr == pUI) return;

	// 1. 디폴트 데이터를 만든다..
	// 2. 데이터를 읽어온다..
	// 3. 영역이 유효한지를 판단한다..

	__WndInfo WI;
	WI.ptPosition.x = iDefaultX;
	WI.ptPosition.y = iDefaultY;
	if(false == RegGetSetting(szKey.c_str(), &WI, sizeof(__WndInfo))) WI.bVisible = true; // 기본 데이터가 없으면 무조건 보이게 한다..

	RECT rc = pUI->GetRegion();

	if (WI.ptPosition.x < 0) WI.ptPosition.x = 0;
	if (WI.ptPosition.x + (rc.right - rc.left) > (int)s_CameraData.vp.Width)
		WI.ptPosition.x = s_CameraData.vp.Width - (rc.right - rc.left);
	if (WI.ptPosition.y < 0) WI.ptPosition.y = 0;
	if (WI.ptPosition.y + (rc.bottom - rc.top) >(int)s_CameraData.vp.Height)
		WI.ptPosition.y = s_CameraData.vp.Height - (rc.bottom - rc.top);

	pUI->SetVisible(WI.bVisible);
	if(0 == WI.ptPosition.x && 0 == WI.ptPosition.y)
		pUI->SetPos(iDefaultX, iDefaultY);
	else pUI->SetPos(WI.ptPosition.x, WI.ptPosition.y);
}

void CGameProcedure::SetGameCursor(HCURSOR hCursor, bool bLocked)
{
	if(s_pGameCursor)
	{
		e_Cursor eCursor = CURSOR_KA_NORMAL;

		if(hCursor == s_hCursorNormal)
			eCursor = CURSOR_KA_NORMAL;
		else if(hCursor == s_hCursorNormal1)
			eCursor = CURSOR_EL_NORMAL;
		else if(hCursor == s_hCursorClick)
			eCursor = CURSOR_KA_CLICK;
		else if(hCursor == s_hCursorClick1)
			eCursor = CURSOR_EL_CLICK;
		else if(hCursor == s_hCursorAttack)
			eCursor = CURSOR_ATTACK;
		else if(hCursor == s_hCursorPreRepair)
			eCursor = CURSOR_PRE_REPAIR;
		else if(hCursor == s_hCursorNowRepair)
			eCursor = CURSOR_NOW_REPAIR;
		else if(hCursor == nullptr)
			eCursor = CURSOR_UNKNOWN;

		SetGameCursor(eCursor, bLocked);

		if ((!m_bCursorLocked) && bLocked)
		{
			m_bCursorLocked = true;
		}

	}
	else
	{
		if ((m_bCursorLocked) && (!bLocked) ) return;
		else if ( ((m_bCursorLocked) && bLocked) || ((!m_bCursorLocked) && !bLocked) )
		{
			SetCursor(hCursor);
			return;
		}
		else if ((!m_bCursorLocked) && bLocked)
		{
			m_hPrevGameCursor = GetCursor();
			m_bCursorLocked = true;
			SetCursor(hCursor);
		}
	}
}

void CGameProcedure::SetGameCursor(e_Cursor eCursor, bool bLocked)
{
	if(s_pGameCursor == nullptr) return;
	s_pGameCursor->SetGameCursor(eCursor, bLocked);
}

void CGameProcedure::RestoreGameCursor()
{
	if(s_pGameCursor)
	{
		if (m_bCursorLocked) 
			m_bCursorLocked = false;

		if(s_pGameCursor) s_pGameCursor->RestoreGameCursor();
	}
	else
	{
		if (m_bCursorLocked) 
			m_bCursorLocked = false;

		SetCursor(m_hPrevGameCursor);	
	}
}

std::string CGameProcedure::GetStrRegKeySetting()
{
	return fmt::format("Software\\KnightOnline\\{}_{}_{}",
		s_szAccount, s_szServer, s_iChrSelectIndex);
}

bool CGameProcedure::ProcessPacket(Packet& pkt)
{
	int iCmd = pkt.read<uint8_t>();	// 커멘드 파싱..
	switch ( iCmd )										// 커멘드에 다라서 분기..
	{
		case WIZ_COMPRESS_PACKET:
			this->MsgRecv_CompressedPacket(pkt);
			return true;

		case WIZ_VERSION_CHECK: // 암호화도 같이 받는다..
			this->MsgRecv_VersionCheck(pkt); // virtual
			return true;

		case WIZ_LOGIN:
			this->MsgRecv_GameServerLogIn(pkt);
			return true;

		case WIZ_SERVER_CHANGE:				// 서버 바꾸기 메시지..
		{
			// 다른 존 서버로 다시 접속한다.
			int iLen = 0;
			std::string szName, szIP;
//			iLen = pkt.read<int16_t>(); // 서버 이름
//			pkt.readString(szName, iLen);
			iLen = pkt.read<int16_t>(); // 서버 IP
			pkt.readString(szIP, iLen);
			uint32_t dwPort = pkt.read<int16_t>();
			s_pPlayer->m_InfoExt.iZoneInit = pkt.read<uint8_t>();
			s_pPlayer->m_InfoExt.iZoneCur = pkt.read<uint8_t>();
			int iVictoryNation = pkt.read<uint8_t>();
			CGameProcedure::LoadingUIChange(iVictoryNation);

			s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
			s_pSocket->Disconnect(); // 끊고...
			Sleep(2000); // 2초 딜레이.. 서버가 처리할 시간을 준다.
			int iErr = s_pSocket->Connect(s_hWndBase, szIP.c_str(), dwPort);
			s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

			if(iErr) this->ReportServerConnectionFailed("Current Zone", iErr, true); // 서버 접속 오류.. Exit.
			else
			{
				// 버전체크를 보내면.. 응답으로 버전과 암호화 키가 온다.
				// 메인 프로시저의 경우 Character_Select 를 보내고 로그인일경우 GameServer_LogIn 을 보낸다.
				this->MsgSend_VersionCheck(); 
			}
		}
		return true;

		case WIZ_SEL_CHAR:
		{
			this->MsgRecv_CharacterSelect(pkt); // virtual
		}
		return true;
	}

	return false;
}

void CGameProcedure::ReportServerConnectionFailed(const std::string& szServerName, int iErrCode, bool bNeedQuitGame)
{
	std::string szMsg = fmt::format_text_resource(IDS_FMT_CONNECT_ERROR, szServerName, iErrCode);
	
	e_Behavior eBehavior = (bNeedQuitGame ? BEHAVIOR_EXIT : BEHAVIOR_NOTHING);
	MessageBoxPost(szMsg, "", MB_OK, eBehavior);
}

void CGameProcedure::ReportServerConnectionClosed(bool bNeedQuitGame)
{
	// Reset timer to allow immediate reconnections.
	if (s_pProcLogIn != nullptr)
		s_pProcLogIn->ResetGameConnectionAttemptTimer();

	if (!s_bNeedReportConnectionClosed)
		return;

	std::string szMsg = fmt::format_text_resource(IDS_CONNECTION_CLOSED);
	e_Behavior eBehavior = ((bNeedQuitGame) ? BEHAVIOR_EXIT : BEHAVIOR_NOTHING);
	MessageBoxPost(szMsg, "", MB_OK, eBehavior);

	if (s_pPlayer != nullptr)
	{
		__Vector3 vPos = s_pPlayer->Position();
		CLogWriter::Write("Socket Closed... Zone({}) Pos({:.1f}, {:.1f}, {:.1f}) Exp({})",
			s_pPlayer->m_InfoExt.iZoneCur, vPos.x, vPos.y, vPos.z, s_pPlayer->m_InfoExt.iExp);
	}
	else
	{
		CLogWriter::Write("Socket Closed...");
	}

	if (s_pSocket!= nullptr)
		s_pSocket->Release();
}

void CGameProcedure::ReportDebugStringAndSendToServer(const std::string& szDebug)
{
	if (szDebug.empty())
		return;

	CLogWriter::Write(szDebug);

	if (s_pSocket == nullptr
		|| !s_pSocket->IsConnected())
		return;

	std::vector<uint8_t> buffer(szDebug.size() + 4, 0);	// 버퍼.. 
	int iOffset = 0;												// 옵셋..
	s_pSocket->MP_AddByte(&buffer[0], iOffset, WIZ_DEBUG_STRING_PACKET);
	s_pSocket->MP_AddShort(&buffer[0], iOffset, static_cast<int16_t>(szDebug.size()));
	s_pSocket->MP_AddString(&buffer[0], iOffset, szDebug);
	s_pSocket->Send(&buffer[0], iOffset);				// 보냄..
}

void CGameProcedure::MsgSend_GameServerLogIn()
{
	uint8_t byBuff[128];										// 패킷 버퍼..
	int iOffset = 0;										// 버퍼의 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_LOGIN);	// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_szAccount.size());	// 아이디 길이..
	CAPISocket::MP_AddString(byBuff, iOffset, s_szAccount);			// 실제 아이디..
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_szPassWord.size());	// 패스워드 길이
	CAPISocket::MP_AddString(byBuff, iOffset, s_szPassWord);		// 실제 패스워드
		
	s_pSocket->Send(byBuff, iOffset);								// 보낸다
}

void CGameProcedure::MsgSend_VersionCheck() // virtual
{
	// Version Check
	int iOffset = 0;
	uint8_t byBuffs[4];
	CAPISocket::MP_AddByte(byBuffs, iOffset, WIZ_VERSION_CHECK);				// 커멘드.
	s_pSocket->Send(byBuffs, iOffset);	// 보낸다

#ifdef _CRYPTION
	s_pSocket->m_bEnableSend = FALSE; // 보내기 가능..?
#endif // #ifdef _CRYPTION
}

void CGameProcedure::MsgSend_CharacterSelect() // virtual
{
	uint8_t byBuff[64];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_SEL_CHAR);				// 커멘드.
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_szAccount.size());				// 계정 길이..
	CAPISocket::MP_AddString(byBuff, iOffset, s_szAccount);						// 계정 문자열..
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDString().size());		// 캐릭 아이디 길이..
	CAPISocket::MP_AddString(byBuff, iOffset, s_pPlayer->IDString());			// 캐릭 아이디 문자열..
	CAPISocket::MP_AddByte(byBuff, iOffset, s_pPlayer->m_InfoExt.iZoneInit);	// 처음 접속인지 아닌지 0x01:처음 접속
	CAPISocket::MP_AddByte(byBuff, iOffset, s_pPlayer->m_InfoExt.iZoneCur);		// 캐릭터 선택창에서의 캐릭터 존 번호
	s_pSocket->Send(byBuff, iOffset);	// 보낸다

	CLogWriter::Write("MsgSend_CharacterSelect - name({}) zone({})",
		s_pPlayer->IDString(), s_pPlayer->m_InfoExt.iZoneCur); // 디버깅 로그..
}

void CGameProcedure::MsgRecv_CompressedPacket(Packet& pkt) // 압축된 데이터 이다... 한번 더 파싱해야 한다!!!
{
	uint16_t compressedLength	= pkt.read<uint16_t>();
	uint16_t originalLength		= pkt.read<uint16_t>();
	uint32_t originalChecksum	= pkt.read<uint32_t>();

	std::vector<uint8_t> decompressedBuffer(originalLength);

	uint32_t decompressedLength = lzf_decompress(
		pkt.contents() + pkt.rpos(),
		compressedLength,
		&decompressedBuffer[0],
		originalLength);

	_ASSERT(decompressedLength == originalLength);

	if (decompressedLength != originalLength)
		return;

	// Don't bother to verify checksums in release.
	// It's just unnecessarily slow.
#if defined(_DEBUG)
	if (originalChecksum != 0)
	{
		uint32_t actualChecksum = crc32(&decompressedBuffer[0], decompressedLength);
		_ASSERT(actualChecksum == originalChecksum);

		if (actualChecksum != originalChecksum)
			return;
	}
#endif

	Packet decompressedPkt;
	decompressedPkt.append(&decompressedBuffer[0], originalLength);

	ProcessPacket(decompressedPkt);
}

int CGameProcedure::MsgRecv_VersionCheck(Packet& pkt) // virtual
{
	int iVersion = pkt.read<int16_t>();	// 버전
#ifdef _CRYPTION
	uint64_t iPublicKey = pkt.read<uint64_t>(); // 암호화 공개키
	CAPISocket::InitCrypt(iPublicKey);
	s_pSocket->m_bEnableSend = TRUE; // 보내기 가능..?
#endif // #ifdef _CRYPTION

	if (iVersion != CURRENT_VERSION)
	{
		std::string szMsg;

		int iLangID = ::GetUserDefaultLangID();

		// Taiwan Language
		if (0x0404 == iLangID)
		{
			szMsg = fmt::format_text_resource(IDS_VERSION_CONFIRM_TW);
		}
		else
		{
			szMsg = fmt::format_text_resource(IDS_VERSION_CONFIRM,
				CURRENT_VERSION / 1000.0f, iVersion / 1000.0f);
		}

		MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_EXIT);
	}

	return iVersion;
}

int CGameProcedure::MsgRecv_GameServerLogIn(Packet& pkt) // virtual
{
	int iNation = pkt.read<uint8_t>(); // 국가 - 0 없음 0xff - 실패..
	return iNation;
}

bool CGameProcedure::MsgRecv_CharacterSelect(Packet& pkt) // virtual
{
	int iResult = pkt.read<uint8_t>(); // 0x00 실패
	if(1 == iResult) // 성공..
	{
		int iZoneCur = pkt.read<uint8_t>();
		float fX = (pkt.read<uint16_t>())/10.0f;
		float fZ = (pkt.read<uint16_t>())/10.0f;
		float fY = (pkt.read<int16_t>())/10.0f;

		int iVictoryNation = pkt.read<uint8_t>();
		CGameProcedure::LoadingUIChange(iVictoryNation);

		int iZonePrev;
		if(N3FORMAT_VER_DEFAULT & N3FORMAT_VER_1264) {
			iZonePrev = s_pPlayer->m_InfoExt.iZoneCur = 10*iZoneCur;
		} else {
			iZonePrev = s_pPlayer->m_InfoExt.iZoneCur = iZoneCur;
		}
		s_pPlayer->PositionSet(__Vector3(fX, fY, fZ), true);

		CLogWriter::Write("MsgRecv_CharacterSelect - name({}) zone({} -> {})",
			s_pPlayer->m_InfoBase.szID, iZonePrev, iZoneCur);
		return true;
	}
	else // 실패
	{
		CLogWriter::Write("MsgRecv_CharacterSelect - failed({})", iResult);
		return false;
	}

	if(iResult) return true;
	else return false;
}

void CGameProcedure::ProcessUIKeyInput(bool bEnable)
{
	s_bKeyPressed	= false;	//키가 올라갔을때 ui에서 해당하는 조작된적이 있다면

	if(!bEnable)
	{
		if(s_bKeyPress)
		{
			for(int i = 0; i < NUMDIKEYS; i++)
			{
				if(s_pLocalInput->IsKeyPressed(i))
				{
					if(!s_bKeyPressed) s_bKeyPress = false;
					break;
				}
			}
		}
		return;
	}


	CN3UIBase* pMsgBox = s_pMsgBoxMgr->GetFocusMsgBox();
	CN3UIBase* pUIFocus = s_pUIMgr->GetFocusedUI();

	if(pMsgBox && pMsgBox->IsVisible())//this_ui
	{
		for(int i = 0; i < NUMDIKEYS; i++)
		{
			if(s_pLocalInput->IsKeyPress(i))
				s_bKeyPress |= pMsgBox->OnKeyPress(i);
			if(s_pLocalInput->IsKeyPressed(i))
				s_bKeyPressed |= pMsgBox->OnKeyPressed(i);
		}
	}
	else if(pUIFocus && pUIFocus->IsVisible()) // 포커싱 된 UI 가 있으면...
	{
		for(int i = 0; i < NUMDIKEYS; i++)
		{
			if(s_pLocalInput->IsKeyPress(i))
			{
				if(pUIFocus->m_pChildUI && pUIFocus->m_pChildUI->IsVisible())
					s_bKeyPress |= pUIFocus->m_pChildUI->OnKeyPress(i);
				else
					s_bKeyPress |= pUIFocus->OnKeyPress(i);
			}
			if(s_pLocalInput->IsKeyPressed(i))
			{
				if(pUIFocus->m_pChildUI && pUIFocus->m_pChildUI->IsVisible())
					s_bKeyPressed |= pUIFocus->m_pChildUI->OnKeyPressed(i);
				else
					s_bKeyPressed |= pUIFocus->OnKeyPressed(i);
			}
		}
	}

	if(s_bKeyPress)
	{
		for(int i = 0; i < NUMDIKEYS; i++)
		{
			if(s_pLocalInput->IsKeyPressed(i))
			{
				if(!s_bKeyPressed) s_bKeyPress = false;
				break;
			}
		}
	}
}

bool CGameProcedure::IsUIKeyOperated()
{
	if (!s_bKeyPress && !s_bKeyPressed)
		return false;

	return true;
}

void CGameProcedure::LoadingUIChange(int iVictoryNation)
{
	if(s_pPlayer->m_InfoExt.iVictoryNation == iVictoryNation)
		return;

	s_pPlayer->m_InfoExt.iVictoryNation = iVictoryNation;

	std::string szLoading;
	if(s_pUILoading) delete s_pUILoading; s_pUILoading = nullptr;		// Loading Bar

	s_pUILoading = new CUILoading();
	__ASSERT(s_pUILoading, "로딩화면 생성 실패");
	if(s_pUILoading == nullptr) return;

	__TABLE_UI_RESRC* pTblUI = s_pTbl_UI.Find(NATION_ELMORAD); // 기본은 엘모라드 UI 로 한다..
	__ASSERT(pTblUI, "기본 UI 가 없습니다.");
	if(pTblUI == nullptr) return;

	switch(iVictoryNation)
	{
	case VICTORY_ABSENCE:
		szLoading = pTblUI->szLoading;
		break;
	case VICTORY_ELMORAD:
		szLoading = pTblUI->szElLoading;
		break;
	case VICTORY_KARUS:
		szLoading = pTblUI->szKaLoading;
		break;
	default:
		szLoading = pTblUI->szLoading;
		break;
	}

	//TRACE("Loading UIF : %s\n", szLoading.c_str());
	s_pUILoading->LoadFromFile(szLoading); // 기본적인 로딩 바 만들기..
}

// ===== END WarFare/GameProcedure.cpp =====

// ===== BEGIN WarFare/GameProcedure.h =====
#line 1 "WarFare/GameProcedure.h"
﻿// GameProcedure.h: interface for the CGameProcedure class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GameProcedure_H__0BEC53F2_1282_402C_9A28_FB98CC131F64__INCLUDED_)
#define AFX_GameProcedure_H__0BEC53F2_1282_402C_9A28_FB98CC131F64__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

enum e_LogInClassification { LIC_KNIGHTONLINE = 0, LIC_MGAME = 1, LIC_DAUM = 2 };

#include "GameDef.h"
#include "GameBase.h"

#include "N3WorldManager.h"

#define		UI_POST_WND_CHAT		"Wnd_Chat"
#define		UI_POST_WND_HOTKEY		"Wnd_Hotkey"
#define		UI_POST_WND_PARTY		"Wnd_Party"
#define		UI_POST_WND_HELP		"Wnd_Help"
#define		UI_POST_WND_INFO		"Wnd_Msg"

const int MAX_MSG_BOX = 4;

struct __WndInfo
{
	char			szName[16];
	bool			bVisible;
	POINT			ptPosition;

	__WndInfo()
	{
		memset(szName, 0, sizeof(szName));
		bVisible = false;
		ptPosition = {};
	}
};

class CHotkeyData 
{
public:
	int	row;
	int column;
	int iID;

	CHotkeyData()
	{
		row = 0;
		column = 0;
		iID = 0;
	}

	CHotkeyData(int rw, int cl, int id)
	{
		row = rw;
		column = cl;
		iID = id;
	}
};

class CGameProcedure : public CGameBase
{
public:
	static class CN3SndObjStream*	s_pSnd_BGM;			// 메인 배경음악 포인터..
	static class CLocalInput*		s_pLocalInput;		// 마우스와 키보드 입력 객체 .. Direct Input 을 썼다.
	static class CAPISocket*		s_pSocket;			// 메인 소켓 객체
	static class CAPISocket*		s_pSocketSub;		// 서브 소켓 객체..
	static class CGameEng*			s_pEng;				// 3D Wrapper Engine
	static class CN3FXMgr*			s_pFX;
	
	static class CUIManager*		s_pUIMgr;					// UI Manager
	static class CUILoading*		s_pUILoading;				// 로딩바..
	static class CUIMessageBoxManager*	s_pMsgBoxMgr;			// MessageBox Manager

	static class CGameProcLogIn*			s_pProcLogIn;
	static class CGameProcNationSelect*		s_pProcNationSelect;
	static class CGameProcCharacterCreate*	s_pProcCharacterCreate;
	static class CGameProcCharacterSelect*	s_pProcCharacterSelect;
	static class CGameProcMain*				s_pProcMain;
	static class CGameProcOption*			s_pProcOption;

	static class CGameProcedure*			s_pProcPrev;
	static class CGameProcedure*			s_pProcActive;

	static class CGameCursor*				s_pGameCursor;

	static HCURSOR s_hCursorNormal;
	static HCURSOR s_hCursorNormal1;
	static HCURSOR s_hCursorClick;
	static HCURSOR s_hCursorClick1;
	static HCURSOR s_hCursorAttack;
	static HCURSOR s_hCursorPreRepair;
	static HCURSOR s_hCursorNowRepair;

	static e_LogInClassification	s_eLogInClassification; // 접속한 서비스.. MGame, Daum, KnightOnLine ....
	static std::string				s_szAccount; // 계정 문자열..
	static std::string				s_szPassWord; // 계정 비번..
	static std::string				s_szServer; // 서버이름 문자열..
	static int						s_iChrSelectIndex; // 이계정의 몇번째 캐릭인지...??

	static bool		m_bCursorLocked;
	static HCURSOR	m_hPrevGameCursor;
	static HWND		s_hWndSubSocket; // 서브 소켓용 윈도우 핸들..

	static bool		s_bNeedReportConnectionClosed; // 서버접속이 끊어진걸 보고해야 하는지..
	static bool		s_bWindowed; // 창모드 실행??
	static bool		s_bKeyPress;	//키가 눌려졌을때 ui에서 해당하는 조작된적이 있다면
	static bool		s_bKeyPressed;	//키가 올라갔을때 ui에서 해당하는 조작된적이 있다면

	static bool		s_bIsRestarting;

	// NOTE: adding boolean to check if window has focus or not
	static bool		s_bIsWindowInFocus;

public:
	static std::string MessageBoxPost(const std::string& szMsg, const std::string& szTitle, int iStyle, e_Behavior eBehavior = BEHAVIOR_NOTHING);
	static void MessageBoxClose(const std::string& szMsg);
	static void MessageBoxClose(int iMsgBoxIndex);

	static void ProcActiveSet(CGameProcedure* pProc);
	static void ReConnect();
	
	static void ReportServerConnectionFailed(const std::string& szServerName, int iErrCode, bool bNeedQuitGame);
	static void ReportServerConnectionClosed(bool bNeedQuitGame);
	static void ReportDebugStringAndSendToServer(const std::string& szDebug);

	virtual int		MsgRecv_VersionCheck(Packet& pkt); // 암호화 키도 같이 받는다..
	virtual int		MsgRecv_GameServerLogIn(Packet& pkt); // virtual - 국가번호를 리턴한다.
	virtual bool	MsgRecv_CharacterSelect(Packet& pkt);

	static void		MsgSend_GameServerLogIn();
	void			MsgSend_VersionCheck();
	virtual void	MsgSend_CharacterSelect();
	void			MsgRecv_CompressedPacket(Packet& pkt);


	
	virtual void Release(); // 리소스 풀어주기..
	virtual void Init(); // 필요한 요소들을 초기화 및 로딩
	virtual void Tick();  // 프로시져 인덱스를 리턴한다. 0 이면 그대로 진행
	virtual void Render();
	virtual void ProcessUIKeyInput(bool bEnable = true);

	static bool	IsUIKeyOperated();
	static void	StaticMemberInit(HINSTANCE hInstance, HWND hWndMain);
	static void StaticMemberRelease();

	static void TickActive();
	static void RenderActive();

	static bool RegPutSetting( const char *ValueName, void *pValueData, long length );
	static bool RegGetSetting( const char *ValueName, void *pValueData, long length );

	static void	UIPostData_Read(const std::string& szKey, class CN3UIBase* pUI, int iDefaultX, int iDefaultY);
	static void	UIPostData_Write(const std::string& szKey, CN3UIBase* pUI);

	static bool CaptureScreenAndSaveToFile(const std::string& szFN);

	static void	SetGameCursor(HCURSOR hCursor, bool bLocked = false);
	static void	SetGameCursor(e_Cursor eCursor, bool bLocked = false);
	static void RestoreGameCursor();

protected:
	virtual bool ProcessPacket(Packet& pkt);

private:
	static std::string GetStrRegKeySetting();

public:
	void LoadingUIChange(int iVictoryNation);
	CGameProcedure();
	virtual ~CGameProcedure();
};


#endif // !defined(AFX_GameProcedure_H__0BEC53F2_1282_402C_9A28_FB98CC131F64__INCLUDED_)

// ===== END WarFare/GameProcedure.h =====

// ===== BEGIN WarFare/GrassBoard.cpp =====
#line 1 "WarFare/GrassBoard.cpp"
﻿// N3Board2DGrass.cpp: implementation of the CGrassBoard class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GrassBoard.h"
#include "N3Terrain.h"
#include <N3Base/N3Texture.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGrassBoard::CGrassBoard()
{
	m_dwType |= OBJ_BOARD;
	CGrassBoard::Release();
}

CGrassBoard::~CGrassBoard()
{
	this->Release();
}

void CGrassBoard::Release()
{
//	memset(m_vRects, 0, sizeof(m_vRects));

	m_nTexIndex = -1;
	m_ucTexIndex = 0;
	m_ucTexNum = 0;

	m_vCenterPo.Zero();

	m_dwBoardType = BOARD_Y;

	m_fBrightmin = 1.0f;
	m_fBrightmax = 1.0f;
	m_bCamOut = FALSE;

	CN3Transform::Release();
}

void CGrassBoard::ReCalcMatrix()
{
	Grass_Info* pGrass;
	for (int i = 0; i < m_ucTexNum; ++i)
	{
		pGrass = &m_sGrassInfo[i];

		pGrass->mtxWorld.Scale(m_vScale);
		if (m_qRot.w != 0)
			pGrass->mtxWorld *= m_qRot;
		pGrass->mtxWorld.PosSet(m_vPos);
	}
}

void CGrassBoard::Tick(CN3Terrain* pTerrain)
{
	// 회전 시킨다..
	static __Vector3 vBakCam;
	if(vBakCam == s_CameraData.vEye) return;	//	카메라 움직이지 않으면 계산 필요없음 
	vBakCam = s_CameraData.vEye;

	uint32_t dwAlpha;
	__Vector3 vDir;
	Grass_Info* pGrass;
	for(int i=0;i<m_ucTexNum;++i)
	{
		pGrass = &m_sGrassInfo[i];

		if(pGrass->vPos.y==0.0f)	//	높이값 
			pGrass->vPos.y = pTerrain->GetHeight(pGrass->vPos.x,pGrass->vPos.z);

		//	카메라와의 방향백터
		vDir = s_CameraData.vEye - pGrass->vPos;

		//	카메라 방향으로 방향을 튼다
		if(vDir.x > 0.0f) pGrass->mtxWorld.RotationY(-atanf(vDir.z/vDir.x) - (__PI * 0.5f));
		else pGrass->mtxWorld.RotationY(-atanf(vDir.z/vDir.x) + (__PI * 0.5f));
		pGrass->mtxWorld.PosSet(m_sGrassInfo[i].vPos);

		//	카메라와의 거리에 따라 알파먹임
		dwAlpha = SetBrightLevel(vDir.Magnitude());
		if(dwAlpha!=0x00000000) pGrass->dwAlpColor = dwAlpha;
	}
}

void CGrassBoard::Render(CN3Texture** ppTex)
{
	if(m_bCamOut==TRUE) return;	//	카메라 범위 벋어나 찍지 않음

	DWORD dwColorop, dwColorA1, dwColorA2;

	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP,   &dwColorop);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorA1);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG2, &dwColorA2);

	static Grass_Info* pGrass;
	for(int i=0;i<m_ucTexNum;++i)
	{
		pGrass = &m_sGrassInfo[i];
		if(ppTex[pGrass->iTexIndex]==nullptr) continue;

		s_lpD3DDev->SetTransform(D3DTS_WORLD, pGrass->mtxWorld.toD3D());

		s_lpD3DDev->SetTexture(0,ppTex[pGrass->iTexIndex]->Get());
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

		s_lpD3DDev->SetFVF(FVF_XYZCOLORT1);

		static __VertexXyzColorT1 vRects[4];
		vRects[0].Set((-1.0f/2.0f), 1.0f, 0,  pGrass->dwAlpColor, 0.0f, 0.0f);
		vRects[1].Set( (1.0f/2.0f), 1.0f, 0,  pGrass->dwAlpColor, 1.0f, 0.0f);
		vRects[2].Set( (1.0f/2.0f),  0	, 0,  pGrass->dwAlpColor, 1.0f, 1.0f);
		vRects[3].Set((-1.0f/2.0f),  0	, 0,  pGrass->dwAlpColor, 0.0f, 1.0f);

		s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vRects, sizeof(__VertexXyzColorT1));
	}

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,   dwColorop);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwColorA1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, dwColorA2);

}

void CGrassBoard::Init(__Vector3 vPos, uint32_t dwBoardType)
{
	m_vPos = vPos;
	m_dwBoardType = dwBoardType;
}

bool CGrassBoard::Load(File& file)
{
	return CN3Transform::Load(file);
}

#ifdef _N3TOOL
bool CGrassBoard::Save(File& file)
{
	return CN3Transform::Save(file);
}
#endif // end of #ifdef _N3TOOL

void CGrassBoard::LoadFromFile(int iTexIndex,uint8_t ucTexOrgIndex,__Vector3 vPos)
{
	Release();

//	m_nTexIndex = iTexIndex;
//	m_usTexIndex = ucTexOrgIndex;
//	m_dwBoardType = BOARD_Y;
//	Init(vPos, m_dwBoardType, 0.7f, 0.7f);
//	Init(vPos, m_dwBoardType, 1.0f, 1.0f);
}

uint32_t CGrassBoard::SetBrightLevel(float Level)
{
	static float fLevelbak;	//	카메라와의 거리를 백업하여 같을시 알파계산을 넘김-예전 데이타 간직
	if(fLevelbak == Level) return 0x00000000;	//	카메라와의 거리가 같다면 계산할 필요가 없다
	fLevelbak = Level;

	if(Level<0.0f) return 0x00ffffff;
	if(Level>m_fBrightmin+m_fBrightmax)	return 0x00ffffff;	//	일정거리 이상은 보이지 않음		
	
	uint32_t Color=0x00ffffff;
	if(Level>m_fBrightmin)	//	일정거리내만큼 보임
	{
		float brightper = (Level-m_fBrightmin)/m_fBrightmax;
		uint32_t alphaColor = (uint32_t)(255 - 255*brightper);
		Color = (alphaColor << 24) | 0x00ffffff;
	}
	else Color = 0xffffffff;	//	일정거리안은 완전히 보여줌

	return Color;
}

void CGrassBoard::SetInfo(__Vector3 vBoardPosion,uint16_t usData)
{
	m_vCenterPo.Set(vBoardPosion.x+2.0f , vBoardPosion.y , vBoardPosion.z+2.0f);	//	지도에서의 중간위치기억
	m_ucTexIndex = (uint8_t)((usData & 0xff00)>>8);	//	풀의 인덱스
	m_ucTexNum = (uint8_t)(usData&0x00ff);	//	풀의 갯수

	if(m_ucTexNum>20) m_ucTexNum = 20;

	int GrassInputCount;
	int InputGrass[8];
	FindGrassIndex(m_ucTexIndex,InputGrass,GrassInputCount);

	int iCount=0;
	Grass_Info* pGrass;
	int mRand;
	for(int i=0;i<m_ucTexNum;++i)
	{
		pGrass = &m_sGrassInfo[i];

		mRand = rand();	pGrass->vPos.x = (mRand%40)/10.0f + vBoardPosion.x;

		pGrass->dwAlpColor = 0x00ffffff;
		pGrass->iTexIndex = InputGrass[iCount];
		if(++iCount>=GrassInputCount) iCount=0;

		mRand = rand();	pGrass->vPos.z = (mRand%40)/10.0f+ vBoardPosion.z;	//	랜더값를 좀더 벌리기 위해
		pGrass->vPos.y = 0.0f;
	}
}

void CGrassBoard::FindGrassIndex(const uint8_t uCGrassMngOrder,int* pnInputGrass,int& nGrassTotNum)
{
	nGrassTotNum=0;
	if(uCGrassMngOrder & 0x01)  { pnInputGrass[nGrassTotNum] = 0 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x02)  { pnInputGrass[nGrassTotNum] = 1 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x04)  { pnInputGrass[nGrassTotNum] = 2 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x08)  { pnInputGrass[nGrassTotNum] = 3 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x10)  { pnInputGrass[nGrassTotNum] = 4 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x20)  { pnInputGrass[nGrassTotNum] = 5 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x40)  { pnInputGrass[nGrassTotNum] = 6 ; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x80)  { pnInputGrass[nGrassTotNum] = 7 ; nGrassTotNum++; }
}


// ===== END WarFare/GrassBoard.cpp =====

// ===== BEGIN WarFare/GrassBoard.h =====
#line 1 "WarFare/GrassBoard.h"
﻿// N3Board2DGrass.h: interface for the GrassBoard class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GRASSBOARD_H__D53F0EC4_B777_49CD_BEE8_071AD4A1680E__INCLUDED_)
#define AFX_GRASSBOARD_H__D53F0EC4_B777_49CD_BEE8_071AD4A1680E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Transform.h>

const uint32_t BOARD_X				= 0;
const uint32_t BOARD_Y				= 1;
const uint32_t BOARD_Z				= 2;
const uint32_t BOARD_XYZ			= 3;

class CN3Terrain;

class CGrassBoard : public CN3Transform
{
protected:
	typedef struct Grass_Info
	{
		__Matrix44	mtxWorld;
		__Vector3	vPos;	//	풀의 위치(지도상의)
		uint32_t		dwAlpColor;	//	풀의 알파
		int			iTexIndex;	//	풀의 인덱스
	}Grass_Info;
//	__VertexXyzColorT1 m_vRects[4];
	Grass_Info		m_sGrassInfo[20];

	int				m_nTexIndex;
	uint8_t	m_ucTexIndex;	//	그림인덱스
	uint8_t	m_ucTexNum;	//	풀의 갯수

//	float			m_fLeftPo;
//	float			m_fTopPo;
	__Vector3		m_vCenterPo;

public:
	uint32_t m_dwBoardType; // Board Type

	float	m_fBrightmin;	//	unit full bright lengs
	float	m_fBrightmax;	//	unit shadow lengs	

	BOOL	m_bCamOut;	//	카메라의 범위를 벋어나 랜더 할 필요 없음(TRUE)

	BOOL	m_bGroundInfo;	//	현재 셀이 풀을 그릴수 있는지 확인

public:
//	void TexSelectNum(int Texindex,uint8_t TexOrgIndex) {m_nTexIndex = Texindex, m_usTexIndex = TexOrgIndex;}
//	BOOL ThisTexIsHave(uint8_t TexIndex) { return TexIndex & m_usTexIndex;}

	void Init(__Vector3 vPos, uint32_t dwBoardType);
	void Tick(CN3Terrain* pTerrain);
	void Render(CN3Texture** ppTex);

	void ReCalcMatrix() override;

	bool Load(File& file) override;
	void LoadFromFile(int iTexIndex,uint8_t ucTexOrgIndex,__Vector3 vPos);

	void SetBrightInit(float min,float max) {m_fBrightmin = min,m_fBrightmax = max - min;};
	uint32_t SetBrightLevel(float Level);
	
	void SetInfo(__Vector3 vBoardPosion,uint16_t usData);
//	uint16_t GetLeft() {return m_vCenterPo.x;}
//	uint16_t GetTop()  {return m_vCenterPo.z;}
	__Vector3	GetPo() {return m_vCenterPo;}

#ifdef _N3TOOL
	bool Save(File& file) override;
#endif // end of #ifdef _N3TOOL

	void Release() override;

	CGrassBoard();
	~CGrassBoard() override;

protected:
	void FindGrassIndex(const uint8_t uCGrassMngOrder, int* pnInputGrass, int& nGrassTotNum);
};

#endif // !defined(AFX_GRASSBOARD_H__D53F0EC4_B777_49CD_BEE8_071AD4A1680E__INCLUDED_)

// ===== END WarFare/GrassBoard.h =====

// ===== BEGIN WarFare/GrassMng.cpp =====
#line 1 "WarFare/GrassMng.cpp"
﻿// Grass.cpp: implementation of the CGrassMng class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GameProcMain.h"
#include "N3WorldManager.h"
#include "N3Terrain.h"
#include "GameEng.h"
#include "GrassMng.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

enum {GRASS_LEFT=0,GRASS_TOP,GRASS_RIGHT,GRASS_BOTTOM};

CGrassMng::CGrassMng()
{
	Release();
}

CGrassMng::~CGrassMng()
{
	CLogWriter::Write("CGrassMng::~CGrassMng -> 소멸자"); // TmpLog1122
	Release();
	CLogWriter::Write("CGrassMng::~CGrassMng -> 소멸자 finish"); // TmpLog1122
}


void CGrassMng::Init(__Vector3 CamPo)
{	
	for(int i=0;i<GRASS_TILENUM;++i)
		for(int j=0;j<GRASS_TILENUM;++j)
		{
			m_pGrasses[i][j].Init(CamPo,BOARD_Y);
			m_pGrasses[i][j].SetBrightInit(12,15);
		}
}


void CGrassMng::Tick(CGameProcedure* pProc)
{
	if(m_bChkZoneChange==false) return;

	__Vector3 vCamPos = pProc->s_pEng->s_CameraData.vEye;	//	현재 카메라의 위치

	ChkTileRange(vCamPos.x,vCamPos.z);

	BOOL IsCamOut;
	CGrassBoard* pGrassBoard = &m_pGrasses[0][0];
	for(int i=0;i<GRASS_TILENUM;++i)
		for(int j=0;j<GRASS_TILENUM;++j,++pGrassBoard)
		{
			pGrassBoard->ScaleSet(1.5f, 1.5f, 1.5f);

			//	카메라 밖이면 랜더를 하지 않는다.
			vCamPos = pGrassBoard->GetPo();
			IsCamOut = pProc->s_pEng->s_CameraData.IsOutOfFrustum(vCamPos,3);
			if(IsCamOut==TRUE)
			{
				pGrassBoard->m_bCamOut = TRUE;
				continue;
			}

			pGrassBoard->m_bCamOut = FALSE;
			pGrassBoard->Tick(ACT_WORLD->GetTerrainRef());
		}

/*
	CGrassBoard*   pGrass = nullptr; 
	__Vector3	  vPivot;		

	uint8_t GrassIndex=0;
	int mRand,nRand;
	float p,n;

	it_GrassBoard it = m_Grasses.begin();
	int iSize = m_Grasses.size();
	for(int i = 0; i < iSize; i++, it++)
	{
		pGrass = *it;

		float XResult = vCamPos.x - m_pCount[i].x;
		float ZResult = vCamPos.z - m_pCount[i].z;

		if(XResult >= 18 || XResult < -18 || ZResult >= 18 || ZResult < -18)
		{
			do{
				mRand = rand();	p = (mRand%180)/10.000;
				nRand = rand();	n = (nRand%180)/10.000;
			}while(p<15 && n<15);

			if(XResult > 0 && ZResult > 0)
			{
				m_pCount[i].x = (float)((m_pCount[i].x + XResult) + p);
				m_pCount[i].z = (float)((m_pCount[i].z + ZResult) + n);
			}

			else if(XResult > 0 && ZResult < 0)
			{
				m_pCount[i].x = (float)((m_pCount[i].x + XResult) + p);
				m_pCount[i].z = (float)((m_pCount[i].z + ZResult) - n);
			}

			else if(XResult < 0 && ZResult > 0)
			{
				m_pCount[i].x = (float)((m_pCount[i].x + XResult) - p);
				m_pCount[i].z = (float)((m_pCount[i].z + ZResult) + n);
			}

			else if(XResult < 0 && ZResult < 0)
			{
				m_pCount[i].x = (float)((m_pCount[i].x + XResult) - p);
				m_pCount[i].z = (float)((m_pCount[i].z + ZResult) - n);
			}

			XResult = 0;
			ZResult = 0;
			
			if(m_pCount[i].y == -FLT_MAX)                                              
				return;
		}

		// 지형정보(풀이 위치한 타일의 지형정보를 얻는다)
		uint8_t cGroundInfo = s_pTerrain->GetGrassAttr(((uint16_t)m_pCount[i].x)/TILE_SIZE, ((uint16_t)m_pCount[i].z)/TILE_SIZE);	//	현재 타일의 정보
		if(cGroundInfo==0)	//	풀을 뿌리는 셀(영역,지역) 아님
		{
			pGrass->m_bCamOut = TRUE;
			continue;
		}

		GrassIndex |= cGroundInfo;

		m_pCount[i].y = s_pTerrain->GetHeight(m_pCount[i].x, m_pCount[i].z);	//	높이 설정

    	pGrass->ScaleSet(1.5f, 1.5f, 1.5f);
		vPivot.Set(m_pCount[i].x,m_pCount[i].y,m_pCount[i].z);

		BOOL IsCamOut;
		//	카메라 밖이면 랜더를 하지 않는다.
		IsCamOut = pProc->s_pEng->s_CameraData.IsOutOfFrustum(vPivot,1);
		if(IsCamOut==TRUE)
		{
			pGrass->m_bCamOut = TRUE;
			continue;
		}

		//	거리를 계산하여 부드럽게 보이게 한다.
		__Vector3 leng = vCamPos - m_pCount[i];
		float lengs = leng.Magnitude();
		IsCamOut = pGrass->SetBrightLevel(lengs);	//	거리간 알파, 랜더하게끔 자동 세팅
		if(IsCamOut == TRUE) 	//	거리가 멀면 랜더를 안한다.
		{
			pGrass->m_bCamOut = TRUE;
			continue;
		}

		pGrass->PosSet(vPivot);		//	위치 입력
		pGrass->Tick(-1);			//	카메라의 위치에 맞게 변환
		if(pGrass->ThisTexIsHave(cGroundInfo) == false)
		{
			int nGrassNum;
			uint8_t uCGrassMngIndex;
			FindGrassIndex(cGroundInfo,nGrassNum,uCGrassMngIndex);
			pGrass->TexSelectNum(nGrassNum,uCGrassMngIndex);
		}
		pGrass->m_bCamOut = FALSE;	//	화면에 뿌려줌(랜더)
	}

	//	만약 다른 풀의 종류에 변동이 생겼을 경우 모두 지우고 다시 풀로 채운다
	if(m_ucDrawIndex!=GrassIndex)
	{
		m_ucDrawIndex = GrassIndex;
		ChkThisZoneUseGrass(GRASS_MAKEUSE);
	}
*/
}

void CGrassMng::FindGrassIndex(uint8_t GrassIndex,int& nFineGrass,uint8_t& ucFineIndex)
{
	int GrassInputCount;
	int InputGrass[8];
	uint8_t InputGrassOrg[8];
	nFineGrass=0;

	FindGrassIndex(GrassIndex,InputGrass,InputGrassOrg,GrassInputCount);

	if(GrassInputCount>0) //	만약 풀이 2개 이상이면 랜덤으로 구한다
	{
		nFineGrass = (int)(rand()%GrassInputCount);
	}

	ucFineIndex = InputGrassOrg[nFineGrass];
	nFineGrass = InputGrass[nFineGrass];
}



void CGrassMng::Render()
{
	if(m_bChkZoneChange==false) return;

	// backup
	DWORD dwLighting;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLighting);

	DWORD dwAlphaBlend, dwTextureFactor;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_TEXTUREFACTOR, &dwTextureFactor);
	
	DWORD dwAlphaOP, dwAlphaArg1,dwAlphaArg2;
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAlphaOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAlphaArg1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAlphaArg2);

	// render state 세팅
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING,	TRUE );  
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

	// texture state 세팅 (alpha)
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

	for(int i=0;i<GRASS_TILENUM;++i)
		for(int j=0;j<GRASS_TILENUM;++j)
			m_pGrasses[i][j].Render(m_txTexture);

	// restore
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLighting );  
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAlphaOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAlphaArg1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAlphaArg2);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactor);

}



void CGrassMng::Release()
{
	m_bChkZoneChange = false;

	ZeroMemory(m_fChkRange, sizeof(m_fChkRange));

	for (int i = 0; i < m_iFileMaxNum; i++)
		CGameBase::s_MngTex.Delete(&m_txTexture[i]);

	m_iFileMaxNum = 0;
	m_usDrawIndex = 0;
}

int CGrassMng::SetFile(int iTexIndex,uint8_t ucTexOrgIndex,__Vector3 CamPo)
{
/*	if(iTexIndex<0) return 2;

	int iGrassNum = m_Grasses.size();
	if(iGrassNum >= GRASS_MAX) return 1;

	float row = 18.0f, col = 18.0f;

	CGrassBoard* pGrass = new CGrassBoard;
	pGrass->LoadFromFile(iTexIndex,ucTexOrgIndex,CamPo);
	pGrass->SetBrightInit(12,15);
	m_Grasses.push_back(pGrass);
	
	m_pCount[iGrassNum].x  = CamPo.x+RandomGenf(row, -(row));
	m_pCount[iGrassNum].z  = CamPo.z+RandomGenf(col, -(col));
*/
	return 0;
}


inline float CGrassMng::RandomGenf(float max, float min)
{
	if ( max == min ) return max;
	if ( min > max ) { float b = min; min = max; max = b; }
	int k = rand()%(int)((max*100-min*100));	

	return (float)((float)(k*0.01f)+min);
}

void CGrassMng::FindGrassIndex(const uint8_t uCGrassMngOrder,int* pnInputGrass,uint8_t* GrassIndex,int& nGrassTotNum)
{
	nGrassTotNum=0;
	if(uCGrassMngOrder & 0x01)  { pnInputGrass[nGrassTotNum] = 0 , GrassIndex[nGrassTotNum] = 0x01; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x02)  { pnInputGrass[nGrassTotNum] = 1 , GrassIndex[nGrassTotNum] = 0x02; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x04)  { pnInputGrass[nGrassTotNum] = 2 , GrassIndex[nGrassTotNum] = 0x04; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x08)  { pnInputGrass[nGrassTotNum] = 3 , GrassIndex[nGrassTotNum] = 0x08; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x10)  { pnInputGrass[nGrassTotNum] = 4 , GrassIndex[nGrassTotNum] = 0x10; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x20)  { pnInputGrass[nGrassTotNum] = 5 , GrassIndex[nGrassTotNum] = 0x20; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x40)  { pnInputGrass[nGrassTotNum] = 6 , GrassIndex[nGrassTotNum] = 0x40; nGrassTotNum++; }
	if(uCGrassMngOrder & 0x80)  { pnInputGrass[nGrassTotNum] = 7 , GrassIndex[nGrassTotNum] = 0x80; nGrassTotNum++; }
}

void CGrassMng::ChkThisZoneUseGrass(int nGrassUseOrder)
{
	if(m_usDrawIndex==0) return;
/*
	int GrassInputCount;
	int InputGrass[8];
	uint8_t InputGrassOrg[8];

	FindGrassIndex(m_usDrawIndex,InputGrass,InputGrassOrg,GrassInputCount);

	if(nGrassUseOrder==GRASS_MAKENEW)
	{
		int iReturnMsg=0;
		while(!iReturnMsg)
		{
			for(int i=0;i<GrassInputCount && !iReturnMsg;i++)
			{
				iReturnMsg = SetFile(InputGrass[i],InputGrassOrg[i],m_vCamPo);
			}
		}
	}
	else if(nGrassUseOrder==GRASS_MAKEUSE)
	{
		CGrassBoard*   pGrass = nullptr; 
		it_GrassBoard it = m_Grasses.begin();
		int iSize = m_Grasses.size();
		int nGrassCount=0,i;
		
		if(iSize==0) return;

//		for(int nGrassCount=0;nGrassCount<iSize;nGrassCount++)
		while(nGrassCount<iSize)
		{
			for(i=0;i<GrassInputCount && nGrassCount<iSize;i++,nGrassCount++,it++)
			{
				pGrass = *it;
				pGrass->TexSelectNum(InputGrass[i],InputGrassOrg[i]);
			}
		}
	}
*/
}

bool CGrassMng::ChangeZone()
{
	Release();

	//	이번 존에서 쓰일 그림의 최대 갯수
	if (!ACT_WORLD->GetTerrainRef()) return false;
	m_iFileMaxNum = ACT_WORLD->GetTerrainRef()->m_iNumGrass;

	if(m_iFileMaxNum==0) 
	{
		m_usDrawIndex=0;
		return false;
	}

	//	그림의 수많큰 이름을 옮기고 나머지 지움
	for(int i=0;i<m_iFileMaxNum;i++)
	{
#ifdef _DEBUG
		if (ACT_WORLD->GetTerrainRef())
			continue;
		strcpy(m_strFileName[i], ACT_WORLD->GetTerrainRef()->m_pGrassTextureName[i]);
#endif
		m_txTexture[i] = CGameBase::s_MngTex.Get(ACT_WORLD->GetTerrainRef()->m_pGrassTextureName[i]);
	}

	for(int i=0;i<8;i++)
	{
#ifdef _DEBUG
		m_strFileName[i][0] = '\0';
#endif
		m_txTexture[i] = nullptr;
	}


	//	지금 옮긴 지형에서 쓰일 풀의 인덱스를 가짐
	__Vector3 vCamPos = CGameBase::s_CameraData.vEye;
	this->ChkTileRange(vCamPos.x,vCamPos.z);

	//	Tick,Render를 허락
	m_bChkZoneChange=true;

	return true;
}

inline bool CGrassMng::IsInRect(float fPoX,float fPoY,float* fRange)
{
	return (fPoX>fRange[GRASS_LEFT] && fPoX<fRange[GRASS_RIGHT] 
		 && fPoY>fRange[GRASS_TOP] && fPoY<fRange[GRASS_BOTTOM]);
}

void CGrassMng::ChkTileRange(float fCamX,float fCamZ)
{
	if(IsInRect(fCamX,fCamZ,m_fChkRange)==true) return;	//	고칠게 없어

	//	캐릭터의 바로 한칸의 영역
	float fCompRange[4];
	fCompRange[GRASS_LEFT]   = (fCamX/TILE_SIZE)*TILE_SIZE;
	fCompRange[GRASS_RIGHT]  = fCompRange[GRASS_LEFT]+TILE_SIZE;
	fCompRange[GRASS_TOP]    = (fCamZ/TILE_SIZE)*TILE_SIZE;	
	fCompRange[GRASS_BOTTOM] = fCompRange[GRASS_TOP]+TILE_SIZE;

	//	전체 구역
	float fLargeRange[4];
	fLargeRange[GRASS_LEFT]	  = fCompRange[GRASS_LEFT] - 5*TILE_SIZE;
	fLargeRange[GRASS_RIGHT]  = fCompRange[GRASS_RIGHT] + 5*TILE_SIZE;
	fLargeRange[GRASS_TOP]    = fCompRange[GRASS_TOP] - 5*TILE_SIZE;
	fLargeRange[GRASS_BOTTOM] = fCompRange[GRASS_BOTTOM] + 5*TILE_SIZE;


	//	새로운 타일의 영역을 얻어온다
	uint16_t FineTile[GRASS_TILENUM*2];
	int iFineTile=0;
	FineNewTile(FineTile,iFineTile,fCompRange,fLargeRange);	//	바꾸어야할 타일 찾음


	int iTileCount=0;
	__Vector3 vCenter;
	CGrassBoard* pBoard;
	uint16_t usGrassInfo;
	for(int x=0; x<GRASS_TILENUM; ++x)
	{
		for(int z=0; z<GRASS_TILENUM; ++z)
		{
			pBoard = &m_pGrasses[x][z];

			vCenter = pBoard->GetPo();

			//	영역 벗어난 구역에 찾은구역 넣음
			if(IsInRect( vCenter.x,vCenter.z,fLargeRange )==false)
			{
				if (!ACT_WORLD->GetTerrainRef())
					continue;
				usGrassInfo = ACT_WORLD->GetTerrainRef()->GetGrassAttr(
					(FineTile[iTileCount+0]) / (int)TILE_SIZE,
					(FineTile[iTileCount+1]) / (int)TILE_SIZE);	//	현재 타일의 정보

				vCenter.Set(FineTile[iTileCount],0.0f,FineTile[iTileCount+1]);	//	왼쪽위의 좌표
				vCenter.y = ACT_WORLD->GetTerrainRef()->GetHeight(vCenter.x,vCenter.z);

				pBoard->SetInfo(vCenter,usGrassInfo);	//	타일의 정보를 바탕으로 풀 갱신

				iTileCount+=2;
			}
		}
	}

	memcpy(m_fChkRange,fCompRange,sizeof(float)*4);
}

void CGrassMng::FineNewTile(uint16_t* Tile,int& iCount,float* fCompRange,float* fLargeRange)
{
	float sx=-1,sy=-1;
	if(fCompRange[GRASS_LEFT] != m_fChkRange[GRASS_LEFT])
	{
		sy = fLargeRange[GRASS_TOP];

		if(fCompRange[GRASS_LEFT] > m_fChkRange[GRASS_LEFT]) sx = fLargeRange[GRASS_RIGHT] - TILE_SIZE;
		else												 sx = fLargeRange[GRASS_LEFT];

		for(int i=0;i<GRASS_TILENUM;++i)
		{
			Tile[iCount] = (uint16_t)sx , Tile[iCount+1] = (uint16_t)(sy+=TILE_SIZE);	iCount+=2;
		}
	}

	if(fCompRange[GRASS_TOP] != m_fChkRange[GRASS_TOP])
	{
		if(fCompRange[GRASS_TOP] > m_fChkRange[GRASS_TOP]) sy = fLargeRange[GRASS_TOP];
		else											   sy = fLargeRange[GRASS_BOTTOM] - TILE_SIZE;

		int si,ei;
		if(sx == -1)						   si = 0 , ei = GRASS_TILENUM   ; 
		else if(sx == fLargeRange[GRASS_LEFT]) si = 1 , ei = GRASS_TILENUM   ;
		else								   si = 0 , ei = GRASS_TILENUM-1 ;

		sx = fLargeRange[GRASS_LEFT] + TILE_SIZE*si;
		
		for(int i=si;i<ei;++i)
		{
			Tile[iCount] = (uint16_t)(sx+=TILE_SIZE) , Tile[iCount+1] = (uint16_t)sy;	iCount+=2;
		}
	}
}

// ===== END WarFare/GrassMng.cpp =====

// ===== BEGIN WarFare/GrassMng.h =====
#line 1 "WarFare/GrassMng.h"
﻿// GrassMng.h: interface for the CGrassMng class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GRASSMNG_H__3B6D6FD3_4213_40EE_A8E9_F50412B49EC2__INCLUDED_)
#define AFX_GRASSMNG_H__3B6D6FD3_4213_40EE_A8E9_F50412B49EC2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameBase.h"
//#include "GameProcedure.h"
#include <list>
#include "GrassBoard.h"

#define GRASS_MAX 11 //	(40/4(TILE_SIZE)) + 1
#define GRASS_TILENUM 11
#define GRASS_MAKENEW	1
#define	GRASS_MAKEUSE	2

class CGameProcedure;
class CN3Terrain;

//typedef std::list<class CGrassBoard*>::iterator it_GrassBoard;
class CGrassMng   : public CGameBase
{
protected:

//	std::list<class CGrassBoard*>	m_Grasses;
	CGrassBoard		m_pGrasses[GRASS_TILENUM][GRASS_TILENUM];	//	풀 뿌려지는 영역
//	__Vector3		m_pCount[GRASS_MAX];
	float			m_fChkRange[4];	//	카메라와의 위치검색용

//	__Vector3		m_vCamPo;
	bool			m_bChkZoneChange;
	uint16_t	m_usDrawIndex;

	CN3Texture*		m_txTexture[8];
#ifdef _DEBUG
	char			m_strFileName[8][_MAX_PATH];	//	나중에 디버거를 위해 그림의 이름을 백업 받는다
#endif
	int				m_iFileMaxNum;

protected:
	void	LoadFromFile(const char* szFileName,__Vector3 CamPo);
	int		SetFile(int iTexIndex,uint8_t ucTexOrgIndex,__Vector3 CamPo);
	float	RandomGenf(float max, float min);
	void	ChkThisZoneUseGrass(int nGrassUseOrder);

	void	FindGrassIndex(uint8_t GrassIndex,int& nFineGrass,uint8_t& ucFineIndex);
	void	FindGrassIndex(const uint8_t uCGrassMngOrder,int* pnInputGrass,uint8_t* GrassIndex,int& nGrassTotNum);

	void	ChkTileRange(float fCamX,float fCamZ);	//	타일간움직임 채크,tick
	void	FineNewTile(uint16_t* Tile,int& iCount,float* ChkRange,float* LargeRange);

public:
	void	Init(__Vector3 CamPo);
	void	Tick(CGameProcedure* pProc);
	void	Render();
	void	Release();

	bool	ChangeZone();

	bool	IsInRect(float fPoX,float fPoY,float* fRange);	//	영역내에 있는지 확인
public:
	CGrassMng();
	virtual ~CGrassMng();
};

#endif // !defined(AFX_GRASS_H__3B6D6FD3_4213_40EE_A8E9_F50412B49EC2__INCLUDED_)

// ===== END WarFare/GrassMng.h =====

// ===== BEGIN WarFare/IconItemSkill.cpp =====
#line 1 "WarFare/IconItemSkill.cpp"
﻿#include "StdAfx.h"
#include "IconItemSkill.h"
#include "GameDef.h"

int __IconItemSkill::GetBuyPrice() const
{
	if (pItemBasic == nullptr
		|| pItemExt == nullptr)
		return 0;

	return pItemBasic->iPrice * pItemExt->siPriceMultiply;
}

int __IconItemSkill::GetSellPrice(bool bHasPremium /*= false*/) const
{
	if (pItemBasic == nullptr
		|| pItemExt == nullptr)
		return 0;

	constexpr int PREMIUM_RATIO = 4;
	constexpr int NORMAL_RATIO = 6;

	int iSellPrice = pItemBasic->iPrice * pItemExt->siPriceMultiply;

	if (pItemBasic->iSaleType != SALE_TYPE_FULL)
	{
		if (bHasPremium)
			iSellPrice /= PREMIUM_RATIO;
		else
			iSellPrice /= NORMAL_RATIO;
	}

	if (iSellPrice < 1)
		iSellPrice = 1;

	return iSellPrice;
}

// ===== END WarFare/IconItemSkill.cpp =====

// ===== BEGIN WarFare/IconItemSkill.h =====
#line 1 "WarFare/IconItemSkill.h"
﻿#pragma once

class CN3UIIcon;
struct __TABLE_ITEM_BASIC;
struct __TABLE_ITEM_EXT;
struct __TABLE_UPC_SKILL;
struct	__IconItemSkill
{
	CN3UIIcon*	pUIIcon;
	std::string	szIconFN;

	union
	{
		struct
		{
			__TABLE_ITEM_BASIC*	pItemBasic;
			__TABLE_ITEM_EXT*	pItemExt;
			int					iCount;
			int					iDurability;	// 내구력
		};

		__TABLE_UPC_SKILL* pSkill;			// Skill.. ^^
	};

	int GetBuyPrice() const;
	int GetSellPrice(bool bHasPremium = false) const;
};

// ===== END WarFare/IconItemSkill.h =====

// ===== BEGIN WarFare/ItemRepairMgr.cpp =====
#line 1 "WarFare/ItemRepairMgr.cpp"
﻿// ItemRepairMgr.cpp: implementation of the CItemRepairMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIRepairTooltipDlg.h"
#include "ItemRepairMgr.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "UIInventory.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CItemRepairMgr::CItemRepairMgr()
{
	m_pspItemBack = nullptr;	
}

CItemRepairMgr::~CItemRepairMgr()
{

}

void CItemRepairMgr::Tick()
{
	CUIInventory *pInv	= CGameProcedure::s_pProcMain->m_pUIInventory;
	if (!pInv) return;
	if (!pInv->IsVisible())	return;
	if (pInv->GetInvState() != INV_STATE_REPAIR) return;
	if (CN3UIBase::s_bWaitFromServer) return;

	CUIRepairTooltipDlg *pDlg = CGameProcedure::s_pProcMain->m_pUIRepairTooltip;
	if (pDlg)	pDlg->m_bBRender = false;

	POINT ptCur			= CGameProcedure::s_pLocalInput->MouseGetPos();

	// 위치를 구해서 
	int i;	int iArm = 0x00; int iOrder = -1; __IconItemSkill* spItem = nullptr;
	for (i = 0; i < ITEM_SLOT_COUNT; i++)
	{
		if (spItem) break;
		if (pInv->m_pMySlot[i])
		{
			if (pInv->m_pMySlot[i]->pUIIcon->IsIn(ptCur.x, ptCur.y))
			{
				iArm = 0x01;
				spItem = pInv->m_pMySlot[i];
				iOrder = i;
			}
		}
	}

	if (!spItem)
	{
		for (i = 0; i < MAX_ITEM_INVENTORY; i++)
		{
			if (spItem) break;
			if (pInv->m_pMyInvWnd[i])
			{
				if (pInv->m_pMyInvWnd[i]->pUIIcon->IsIn(ptCur.x, ptCur.y))
				{
					iArm = 0x02;
					spItem = pInv->m_pMyInvWnd[i];
					iOrder = i;
				}
			}
		}
	}

	// 아이콘 위에 있으면..  
	int iRepairGold = 0;
	if (spItem)
	{
		iRepairGold = CalcRepairGold(spItem);

		// 수리 가격 툴팁 표시..
		if (pDlg)
		{
			pDlg->m_bBRender		= true;
			pDlg->m_iBxpos			= ptCur.x;
			pDlg->m_iBypos			= ptCur.y;
			pDlg->m_pBspItem		= spItem;
			pDlg->m_iBRequiredGold	= iRepairGold;
		}

		// 내가 가진 돈 보다 수리 비용이 비싸면.. 
		if (iRepairGold > s_pPlayer->m_InfoExt.iGold)
		{
			// 빨갛게 표시.. 
			if (pDlg)
				pDlg->m_bBHaveEnough = false;
		}
		else
		{
			//아이면 원래 색깔..
			if (pDlg)
				pDlg->m_bBHaveEnough = true;
		}
	}

	uint32_t dwMouseFlags	= CGameProcedure::s_pLocalInput->MouseGetFlag();	// 마우스 버튼 플래그 - LocalInput.h 참조
	if (dwMouseFlags & MOUSE_LBCLICK)		// 왼쪽 버튼을 누르면..
	{
		m_pspItemBack	= spItem;
		m_iArm			= iArm;
		m_iiOrder		= iOrder;
	}
	else if(dwMouseFlags & MOUSE_LBCLICKED)
	{
		if (m_pspItemBack && spItem && (m_pspItemBack == spItem) )
		{
			// Send To Server..
			if (iRepairGold > 0)										// 수리 가격이 있으면..
			{
				// 내가 가진 돈 보다 수리 비용이 비싸면.. 
				if (iRepairGold > s_pPlayer->m_InfoExt.iGold)
				{
					// 서버에게 보내지 않고 메시지 표시.. 
					std::string szMsg = fmt::format_text_resource(IDS_REPAIR_LACK_GOLD);
					CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff00ff);
				}
				else
				{
					uint8_t byBuff[8];															// 패킷 버퍼..
					int iOffset=0;															// 패킷 오프셋..

					CAPISocket::MP_AddByte(byBuff, iOffset,  WIZ_ITEM_REPAIR);			// 게임 스타트 패킷 커멘드..
					CAPISocket::MP_AddByte(byBuff, iOffset,  iArm);							// 아이디 길이 패킷에 넣기..
					CAPISocket::MP_AddByte(byBuff, iOffset,  iOrder);							// 아이디 길이 패킷에 넣기..
					CAPISocket::MP_AddDword(byBuff, iOffset, spItem->pItemBasic->dwID+spItem->pItemExt->dwID);	// 아이디 문자열 패킷에 넣기..

					CGameProcedure::s_pSocket->Send(byBuff, iOffset);	

					// 응답을 기다림..
					CN3UIBase::s_bWaitFromServer = true;

					// Change To Cursor..
					CGameProcedure::SetGameCursor(CGameProcedure::s_hCursorNowRepair, true);
				}
			}
		}
	}
}

void CItemRepairMgr::ReceiveResultFromServer(int iResult, int iUserGold)
{
	CUIRepairTooltipDlg *pDlg = CGameProcedure::s_pProcMain->m_pUIRepairTooltip;
	CUIInventory *pInv	= CGameProcedure::s_pProcMain->m_pUIInventory;
	if (!pInv) return;
	if (!m_pspItemBack) return;

	// 성공이면 npc영역의 Durability를 최대값으로..
	if(iResult == 0x01)
	{
		m_pspItemBack->iDurability = m_pspItemBack->pItemBasic->siMaxDurability+m_pspItemBack->pItemExt->siMaxDurability;

		switch (m_iArm)
		{
			case 0x01: // 장착하고 있는 아이템
				pInv->m_pMySlot[m_iiOrder] = m_pspItemBack;
				s_pPlayer->DurabilitySet((e_ItemSlot)m_iiOrder, m_pspItemBack->iDurability); // 내구력을 복구 해준다..
				break;

			case 0x02: // 인벤토리에 있는 아이템..
				pInv->m_pMyInvWnd[m_iiOrder] = m_pspItemBack;
				break;
		}

		// 아이콘 상태가 UISTYLE_DURABILITY_EXHAUST 이면..
		m_pspItemBack->pUIIcon->SetStyle(m_pspItemBack->pUIIcon->GetStyle() & (~UISTYLE_DURABILITY_EXHAUST));
		
		if (pDlg)	pDlg->m_iBRequiredGold	= 0;
		pInv->PlayRepairSound();
	}

	// 돈 업데이트..
	UpdateUserTotalGold(iUserGold);

	// 응답 기다림 해제..
	CN3UIBase::s_bWaitFromServer = false;

	// Change To Cursor..
	CGameProcedure::SetGameCursor(CGameProcedure::s_hCursorPreRepair, true);
}

void CItemRepairMgr::UpdateUserTotalGold(int iGold)
{
	// 돈 업데이트..
	s_pPlayer->m_InfoExt.iGold = iGold;
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
}

int CItemRepairMgr::CalcRepairGold(__IconItemSkill* spItem)
{
	int iMaxDurability = spItem->pItemBasic->siMaxDurability + spItem->pItemExt->siMaxDurability;
	if (iMaxDurability <= 0) return 0;
	float fAllPrice = (float)spItem->pItemBasic->iPrice*(float)spItem->pItemExt->siPriceMultiply;
	float fTemp = ((fAllPrice-10.0f)/(10000.0f))+pow(fAllPrice, 0.75f);
	float fValue = fTemp*( (float)(iMaxDurability - spItem->iDurability) / (float)(iMaxDurability) );

	return (int)fValue;
}






// ===== END WarFare/ItemRepairMgr.cpp =====

// ===== BEGIN WarFare/ItemRepairMgr.h =====
#line 1 "WarFare/ItemRepairMgr.h"
﻿// ItemRepairMgr.h: interface for the CItemRepairMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ITEMREPAIRMGR_H__773AD64F_2ADD_44CC_BCE8_1EF2F38C76FB__INCLUDED_)
#define AFX_ITEMREPAIRMGR_H__773AD64F_2ADD_44CC_BCE8_1EF2F38C76FB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameBase.h"

class CItemRepairMgr : CGameBase
{
	struct __IconItemSkill*	m_pspItemBack;	
	int						m_iArm;
	int						m_iiOrder;

public:
	CItemRepairMgr();
	virtual ~CItemRepairMgr();

	void	Tick();
	void	ReceiveResultFromServer(int iResult, int iUserGold);

	void	UpdateUserTotalGold(int iGold);
	int		CalcRepairGold(struct __IconItemSkill* spItem);
};

#endif // !defined(AFX_ITEMREPAIRMGR_H__773AD64F_2ADD_44CC_BCE8_1EF2F38C76FB__INCLUDED_)

// ===== END WarFare/ItemRepairMgr.h =====

// ===== BEGIN WarFare/LightMgr.cpp =====
#line 1 "WarFare/LightMgr.cpp"
﻿// LightMgr.cpp: implementation of the CLightMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LightMgr.h"

#include <FileIO/FileReader.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CLightMgr::CLightMgr()
{
	m_Lights.clear();
	for(int i=0;i<LGT_MAX;i++) m_pActiveLight[i] = nullptr;
}

CLightMgr::~CLightMgr()
{
	std::list<CN3Light*>::iterator it;
	for(it=m_Lights.begin(); it!=m_Lights.end(); it++)
	{
		CN3Light* pLgt = (*it);
		delete pLgt;
	}
	m_Lights.clear();
	for(int i=0;i<LGT_MAX;i++)
	{
		if(m_pActiveLight[i]) delete m_pActiveLight[i];
	}
}

void CLightMgr::Release()
{
	/////////////////////////////////////////////
	// Release...
	std::list<CN3Light*>::iterator it;
	for(it=m_Lights.begin(); it!=m_Lights.end(); it++)
	{
		CN3Light* pLgt = (*it);
		delete pLgt;
	}
	m_Lights.clear();
	for(int i=0;i<LGT_MAX;i++)
	{
		if(m_pActiveLight[i]) delete m_pActiveLight[i];
		m_pActiveLight[i] = nullptr;
	}
	//	Release..
	/////////////////////////////////////////////
		
	///////////////////////////////////////////////////////////////
	// 기본 라이트 세팅
	__ColorValue crLgt;

	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.8f;
	CN3Light* pLightGlobal = new CN3Light(); // 전체를 비출 라이트..
	pLightGlobal->m_Data.InitDirection(LGT_DEFAULT0, { 0, -1, 0 }, crLgt);
	m_pActiveLight[LGT_DEFAULT0] = pLightGlobal;


	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.5f;
	CN3Light* pLightGlobal2 = new CN3Light(); // 반대 편에서 전체를 비출 라이트..
	pLightGlobal2->m_Data.InitDirection(LGT_DEFAULT1, { 0, 1, 0}, crLgt);
	m_pActiveLight[LGT_DEFAULT1] = pLightGlobal2;

	crLgt.a = 0.0f, crLgt.r = crLgt.g = crLgt.b = 0.3f;
	CN3Light* pLight = new CN3Light(); // 카메라와 붙어 다닌다...
	pLight->m_Data.InitPoint(LGT_DEFAULT2, { 0, 0, 0 }, crLgt, 32.0f);
	m_pActiveLight[LGT_DEFAULT2] = pLight;
	// 기본 라이트 세팅
	///////////////////////////////////////////////////////////////	
}

void CLightMgr::Tick()
{
	int i;
	//거리에 따라 추려내고...
	int NumSlotEmpty = 0;
	float LimitLeft, LimitRight, LimitUp, LimitDown;
	LimitLeft = CN3Base::s_CameraData.vEye.x - LIGHT_VALIDRANGE;
	LimitRight = CN3Base::s_CameraData.vEye.x + LIGHT_VALIDRANGE;
	LimitUp = CN3Base::s_CameraData.vEye.z + LIGHT_VALIDRANGE;
	LimitDown = CN3Base::s_CameraData.vEye.z - LIGHT_VALIDRANGE;

	__Vector3 vPosTmp;
	for(i=LGT_ADDITIONAL0;i<LGT_MAX;i++)
	{
		if(!m_pActiveLight[i])
		{
			NumSlotEmpty++;
			continue;
		}

		vPosTmp = m_pActiveLight[i]->Pos();
		if(vPosTmp.x < LimitLeft || vPosTmp.x > LimitRight || vPosTmp.z < LimitDown || vPosTmp.z > LimitUp)
		{
			m_pActiveLight[i]->m_Data.bOn = false;
			m_pActiveLight[i]->Apply();

			AddLight(m_pActiveLight[i]);
			m_pActiveLight[i] = nullptr;
			NumSlotEmpty++;

			continue;
		}
	}

	std::list<CN3Light*>::iterator it = m_Lights.begin();
	while(NumSlotEmpty>0 && it!=m_Lights.end())
	{
		CN3Light* pLgt = (*it);
		vPosTmp = pLgt->Pos();
		if(vPosTmp.x > LimitLeft && vPosTmp.x < LimitRight && vPosTmp.z > LimitDown && vPosTmp.z < LimitUp)
		{
			for(i=LGT_ADDITIONAL0;i<LGT_MAX;i++)
			{
				if(!m_pActiveLight[i])
				{
					m_pActiveLight[i] = pLgt;
					m_pActiveLight[i]->m_Data.bOn = true;
					m_pActiveLight[i]->m_Data.nNumber = i;
					NumSlotEmpty--;
					break;
				}
			}
			it = m_Lights.erase(it);
		}
		else it++;
	}

	//tick돌려라..
	for(i=0;i<LGT_MAX;i++)
	{
		if(m_pActiveLight[i])
		{
			m_pActiveLight[i]->Tick();
			m_pActiveLight[i]->Apply();
		}
	}
}

void CLightMgr::AddLight(CN3Light* pLgt)
{
	if(!pLgt) return;
	m_Lights.push_back(pLgt);	
}

void CLightMgr::LoadZoneLight(const char* szFN)
{
	if (szFN == nullptr)
		return;
	
	FileReader file;
	if (!file.OpenExisting(szFN))
		return;

	int iVersion;
	file.Read(&iVersion, sizeof(int));

	int cnt;
	file.Read(&cnt, sizeof(int));
	for (int i = 0; i < cnt; i++)
	{
		CN3Light* pLgt = new CN3Light;
		pLgt->m_iFileFormatVersion = N3FORMAT_VER_DEFAULT;
		pLgt->Load(file);
		AddLight(pLgt);
	}
}

// ===== END WarFare/LightMgr.cpp =====

// ===== BEGIN WarFare/LightMgr.h =====
#line 1 "WarFare/LightMgr.h"
﻿// LightMgr.h: interface for the CLightMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__LIGHTMGR_H__)
#define __LIGHTMGR_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Light.h>

#include <list>

const float LIGHT_VALIDRANGE = 100.0f;
enum eIdxLight {LGT_DEFAULT0 = 0, LGT_DEFAULT1 = 1, LGT_DEFAULT2 = 2, LGT_ADDITIONAL0 = 3, LGT_ADDITIONAL1 = 4,
				LGT_ADDITIONAL2 = 5, LGT_ADDITIONAL3 = 6, LGT_ADDITIONAL4 = 7, LGT_MAX = 8 };

class CLightMgr : public CN3Base  
{
public:
	std::list<CN3Light*>	m_Lights;
	CN3Light*				m_pActiveLight[LGT_MAX];

public:
	void		Release();
	void		Tick();
	void		AddLight(CN3Light* pLgt);
	CN3Light*	Light(int idx) { return m_pActiveLight[idx]; }

	void		LoadZoneLight(const char* szFN);
	
	CLightMgr();
	virtual ~CLightMgr();
};

#endif // #if !defined(__LIGHTMGR_H__)

// ===== END WarFare/LightMgr.h =====

// ===== BEGIN WarFare/LocalInput.cpp =====
#line 1 "WarFare/LocalInput.cpp"
﻿/*
*/

#include "stdafx.h"
#include "LocalInput.h"
#include <mmsystem.h>

#include "GameProcMain.h"
#include "GameEng.h"

CLocalInput::CLocalInput()
{
	m_lpDI = nullptr;
	m_lpDIDKeyboard = nullptr;

	m_hWnd = nullptr;

	m_bNoKeyDown = FALSE;

	m_nMouseFlag = 0;
	m_nMouseFlagOld = 0;

	m_dwTickLBDown = 0;
	m_dwTickRBDown = 0;

	m_ptCurMouse.x = m_ptCurMouse.y = 0;
	m_ptOldMouse.x = m_ptOldMouse.y = 0;

	SetRect(&m_rcLBDrag, 0, 0, 0, 0);
	SetRect(&m_rcMBDrag, 0, 0, 0, 0);
	SetRect(&m_rcRBDrag, 0, 0, 0, 0);

	SetRect(&m_rcMLimit, 0, 0, 0, 0);

	memset(m_byCurKeys, 0, sizeof(m_byCurKeys));
	memset(m_byOldKeys, 0, sizeof(m_byOldKeys));
	memset(m_bKeyPresses, 0, sizeof(m_bKeyPresses));
	memset(m_bKeyPresseds, 0, sizeof(m_bKeyPresseds));
	memset(m_dwTickKeyPress, 0, sizeof(m_dwTickKeyPress));
}	

CLocalInput::~CLocalInput()
{
	// shutdown keyboard
	if (m_lpDIDKeyboard != nullptr)
	{
		UnacquireKeyboard();

		m_lpDIDKeyboard->Release();
		m_lpDIDKeyboard = nullptr;
	}

	// kill directinput
	if (m_lpDI != nullptr)
	{
		m_lpDI->Release();
		m_lpDI = nullptr;
	}
}

//////////////////////////////////////////////////////////////////////////////////
// Try to accquire all devices. Use SetActiveDevices() if you do not want 
// some devices.
//////////////////////////////////////////////////////////////////////////////////
BOOL CLocalInput::Init(HINSTANCE hInst, HWND hWnd)
{
	HRESULT rval;

	m_hWnd = hWnd; // 윈도우 핸들 기억..

	rval = DirectInput8Create(hInst, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**) &m_lpDI, nullptr);
	if (rval != DI_OK)
		return FALSE;

	// Create the keyboard device
	rval = m_lpDI->CreateDevice(GUID_SysKeyboard, &m_lpDIDKeyboard, nullptr);
	if (rval == DI_OK)
	{
		m_lpDIDKeyboard->SetDataFormat(&c_dfDIKeyboard);
		m_lpDIDKeyboard->SetCooperativeLevel(hWnd, DISCL_NONEXCLUSIVE | DISCL_FOREGROUND | DISCL_NOWINKEY);

		AcquireKeyboard();
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Controls which devices you have accquired.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::SetActiveDevices(BOOL bKeyboard)
{
	if (bKeyboard)
		AcquireKeyboard();
	else 
		UnacquireKeyboard();
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Wipes out the internal key data.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::KeyboardFlushData()
{
	memset(m_byOldKeys, 0, NUMDIKEYS);
	memset(m_byCurKeys, 0, NUMDIKEYS);
}

/////////////////////////////////////////////////////////////////////////////////////////////
// This restricts the mouse to a defined area.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::MouseSetLimits(int x1, int y1, int x2, int y2)
{
	m_rcMLimit.left = x1;
	m_rcMLimit.top = y1;
	m_rcMLimit.right = x2;
	m_rcMLimit.bottom = y2;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Sets the mouse position. This restricts the position to the physical display.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::MouseSetPos(int x, int y)
{
	// clamp non-free mouse values to limits
	if ((m_ptCurMouse.x = x) >= m_rcMLimit.right)
		m_ptCurMouse.x = m_rcMLimit.right-1;

	if ((m_ptCurMouse.y = y) >= m_rcMLimit.bottom)
		m_ptCurMouse.y = m_rcMLimit.bottom-1;

	if ((m_ptCurMouse.x = x) <= m_rcMLimit.left)
		m_ptCurMouse.x = m_rcMLimit.left+1;

	if ((m_ptCurMouse.y = y) <= m_rcMLimit.top)
		m_ptCurMouse.y = m_rcMLimit.top+1;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Retrieves the keystate of a given key.
/////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLocalInput::KeyboardGetKeyState(int nDIKey)
{
	if (nDIKey < 0 || nDIKey >= NUMDIKEYS)
		return FALSE;

	return m_byCurKeys[nDIKey];
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Obtains access to the keyboard.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::AcquireKeyboard()
{
	if (m_lpDIDKeyboard != nullptr)
	{
		HRESULT rval = m_lpDIDKeyboard->Acquire();
//		if (rval != DI_OK) MessageBox(::GetActiveWindow(), "Acquire Keyboard Failed.", "DirectInput", MB_OK);
		if (rval == DI_OK || rval == S_FALSE)
		{
//			m_bKeyboard = TRUE;
			KeyboardFlushData();
			return;
		}
	}	
//		m_bKeyboard = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Releases access to the keyboard.
/////////////////////////////////////////////////////////////////////////////////////////////
void CLocalInput::UnacquireKeyboard()
{
	KeyboardFlushData();
//	m_bKeyboard = FALSE;

	if (m_lpDIDKeyboard != nullptr)
	{
		HRESULT rval = m_lpDIDKeyboard->Unacquire();
//		if (rval != DI_OK) MessageBox(::GetActiveWindow(), "UnAcquire Keyboard Failed.", "DirectInput", MB_OK);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Updates all devices. Call this before you check for input.
/////////////////////////////////////////////////////////////////////////////////////////////
// 되도록이면 전체 프로시저 돌때 한번씩만 도는게 좋다.. 여러번 하면 혼란이 올수도 있다.
void CLocalInput::Tick()
{
	HRESULT err;

	HWND hWndActive = ::GetActiveWindow(); // 포커싱되었을때만...
	if (hWndActive != m_hWnd)
		return;

	///////////////////////
	//  KEYBOARD
	///////////////////////
//	if(m_bKeyboard)
//	{
		memcpy(m_byOldKeys, m_byCurKeys, NUMDIKEYS); // 전의 키 상태 기록

		err = m_lpDIDKeyboard->GetDeviceState(NUMDIKEYS, m_byCurKeys); // 현재 키 상태 기록
		if (err != DI_OK)
			AcquireKeyboard();
		else
		{
			m_bNoKeyDown = TRUE; // 첨엔 아무것도 안눌림

			for (int i = 0; i < NUMDIKEYS; i++)
			{
				if (!m_byOldKeys[i] && m_byCurKeys[i])
					m_bKeyPresses[i] = TRUE; // 눌리는 순간
				else
					m_bKeyPresses[i] = FALSE;

				if (m_byOldKeys[i] && !m_byCurKeys[i])
					m_bKeyPresseds[i] = TRUE; // 눌렀다 떼는 순간..
				else
					m_bKeyPresseds[i] = FALSE;

				if (m_byCurKeys[i])
					m_bNoKeyDown = FALSE;
			}
		}
//	}

	///////////////////////
	//  MOUSE
	///////////////////////

	m_ptOldMouse = m_ptCurMouse; // 일단 전의 것 복사...

	RECT rcClient;
	::GetClientRect(m_hWnd, &rcClient);
	::GetCursorPos(&m_ptCurMouse); // 좀 이상해서... 그냥 시스템 마우스 커서 위치 가져오기
	::ScreenToClient(m_hWnd, &m_ptCurMouse); // 클라이언트 영역으로 변환

	if (PtInRect(&rcClient, m_ptCurMouse)) //  && GetFocus() == m_hWnd) // 스크린 영역 밖에 있거나 포커스가 가있지 않으면..
	{
		// 마우스 버튼 상태 보관.
		m_nMouseFlagOld = m_nMouseFlag;
		m_nMouseFlag = 0;

		// 마우스 상태 가져오기
		if (_IsKeyDown(VK_LBUTTON))
			m_nMouseFlag |= MOUSE_LBDOWN;

		if (_IsKeyDown(VK_MBUTTON))
			m_nMouseFlag |= MOUSE_MBDOWN;

		if (_IsKeyDown(VK_RBUTTON))
			m_nMouseFlag |= MOUSE_RBDOWN;

		// 버튼 클릭 직후..
		if (!(m_nMouseFlagOld & MOUSE_LBDOWN) && (m_nMouseFlag & MOUSE_LBDOWN))
			m_nMouseFlag |= MOUSE_LBCLICK;

		if (!(m_nMouseFlagOld & MOUSE_MBDOWN) && (m_nMouseFlag & MOUSE_MBDOWN))
			m_nMouseFlag |= MOUSE_MBCLICK;

		if (!(m_nMouseFlagOld & MOUSE_RBDOWN) && (m_nMouseFlag & MOUSE_RBDOWN))
			m_nMouseFlag |= MOUSE_RBCLICK;

		// 버튼에서 손을 떼면
		if ((m_nMouseFlagOld & MOUSE_LBDOWN) && !(m_nMouseFlag & MOUSE_LBDOWN))
			m_nMouseFlag |= MOUSE_LBCLICKED;

		if ((m_nMouseFlagOld & MOUSE_MBDOWN) && !(m_nMouseFlag & MOUSE_MBDOWN))
			m_nMouseFlag |= MOUSE_MBCLICKED;

		if ((m_nMouseFlagOld & MOUSE_RBDOWN) && !(m_nMouseFlag & MOUSE_RBDOWN))
			m_nMouseFlag |= MOUSE_RBCLICKED;

		static DWORD dwDblClk = GetDoubleClickTime(); // 윈도우의 더블 클릭시간을 가져오고..
		if (m_nMouseFlag & MOUSE_LBCLICKED) // 왼쪽 더블 클릭 감지
		{
			static DWORD dwCLicked = 0;
			if (timeGetTime() < dwCLicked + dwDblClk)
				m_nMouseFlag |= MOUSE_LBDBLCLK;
			dwCLicked = timeGetTime();
		}

		if (m_nMouseFlag & MOUSE_MBCLICKED) // 왼쪽 더블 클릭 감지
		{
			static DWORD dwCLicked = 0;
			if (timeGetTime() < dwCLicked + dwDblClk)
				m_nMouseFlag |= MOUSE_MBDBLCLK;
			dwCLicked = timeGetTime();
		}

		if (m_nMouseFlag & MOUSE_RBCLICKED) // 왼쪽 더블 클릭 감지
		{
			static DWORD dwCLicked = 0;
			if (timeGetTime() < dwCLicked + dwDblClk)
				m_nMouseFlag |= MOUSE_RBDBLCLK;
			dwCLicked = timeGetTime();
		}

		// 드래그 영역 처리
		if (m_nMouseFlag & MOUSE_LBDOWN)
		{
			m_rcLBDrag.right = m_ptCurMouse.x;
			m_rcLBDrag.bottom = m_ptCurMouse.y;
		}

		if (m_nMouseFlag & MOUSE_MBDOWN)
		{
			m_rcMBDrag.right = m_ptCurMouse.x;
			m_rcMBDrag.bottom = m_ptCurMouse.y;
		}

		if (m_nMouseFlag & MOUSE_RBDOWN)
		{
			m_rcRBDrag.right = m_ptCurMouse.x;
			m_rcRBDrag.bottom = m_ptCurMouse.y;
		}

		if (m_nMouseFlag & MOUSE_LBCLICK)
		{
			m_rcLBDrag.left = m_ptCurMouse.x;
			m_rcLBDrag.top = m_ptCurMouse.y;
		}

		if (m_nMouseFlag & MOUSE_MBCLICK)
		{
			m_rcMBDrag.left = m_ptCurMouse.x;
			m_rcMBDrag.top = m_ptCurMouse.y;
		}

		if (m_nMouseFlag & MOUSE_RBCLICK)
		{
			m_rcRBDrag.left = m_ptCurMouse.x;
			m_rcRBDrag.top = m_ptCurMouse.y;
		}
	}
}

// ===== END WarFare/LocalInput.cpp =====

// ===== BEGIN WarFare/LocalInput.h =====
#line 1 "WarFare/LocalInput.h"
﻿#ifndef _LocalInput_H_
#define _LocalInput_H_

#include <DInput.h>

#include <N3Base/My_3DStruct.h>

const int DK_NONE = 0;
const int DK_RELEASE = 1;
const int DK_PRESS = 2;
const int DK_REPEAT = 4;
const int NUMDIKEYS = 256;

// 마우스 플래그 - 한개 이상의 플래그가 OR 연산으로 조합되어 있다..
const int MOUSE_LBCLICK		= 0x1;
const int MOUSE_LBCLICKED	= 0x2;
const int MOUSE_LBDOWN		= 0x4;
const int MOUSE_MBCLICK		= 0x8;
const int MOUSE_MBCLICKED	= 0x10;
const int MOUSE_MBDOWN		= 0x20;
const int MOUSE_RBCLICK		= 0x40;
const int MOUSE_RBCLICKED	= 0x80;
const int MOUSE_RBDOWN		= 0x100;
const int MOUSE_LBDBLCLK	= 0x200;
const int MOUSE_MBDBLCLK	= 0x400;
const int MOUSE_RBDBLCLK	= 0x800;

//////////////////////////////////////////////////////////////////////////////////
// CLocalInput is a class wrapper for DirectInput and contains functions to receive 
// data from the mouse, keyboard
//////////////////////////////////////////////////////////////////////////////////
class CLocalInput
{
private:
	void AcquireKeyboard();
	void UnacquireKeyboard();

protected:
	LPDIRECTINPUT8			m_lpDI;
	LPDIRECTINPUTDEVICE8	m_lpDIDKeyboard;

	HWND m_hWnd;

//	BOOL m_bMouse;
//	BOOL m_bKeyboard;

	int m_nMouseFlag, m_nMouseFlagOld; // 마우스 버튼 눌림 플래그
	uint32_t m_dwTickLBDown; // 마우스 왼쪽 버튼 더블 클릭 감지용
	uint32_t m_dwTickRBDown; // 마우스 오른쪽 버튼 더블 클릭 감지용

	POINT	m_ptCurMouse; // 현재 마우스 포인터
	POINT	m_ptOldMouse; // 직전 마우스 포인터

	RECT	m_rcLBDrag; // 드래그 영역
	RECT	m_rcMBDrag; // 드래그 영역
	RECT	m_rcRBDrag; // 드래그 영역

	RECT m_rcMLimit; // 마우스 움직임 제한 영역
	uint8_t m_byCurKeys[NUMDIKEYS]; // 현재 키 상태
	uint8_t m_byOldKeys[NUMDIKEYS]; // 직전 키 상태
	BOOL m_bKeyPresses[NUMDIKEYS]; // 키를 누른 순간인지
	BOOL m_bKeyPresseds[NUMDIKEYS]; // 키를 눌렀다 떼는 순간인지
	BOOL m_bNoKeyDown; // 아무 키입력도 없는지

	uint32_t m_dwTickKeyPress[NUMDIKEYS];
	
public:
	void KeyboardClearInput(int iIndex = -1) // 키보드 입력을 무효화 시킨다.. 기본값은 몽땅 무효화이다..
	{
		if(-1 == iIndex)
		{
			memset(m_byOldKeys, 0, sizeof(m_byOldKeys));
			memset(m_byCurKeys, 0, sizeof(m_byCurKeys));
			memset(m_bKeyPresses, 0, sizeof(m_bKeyPresses));
			memset(m_bKeyPresseds, 0, sizeof(m_bKeyPresseds));
		}
		else if(iIndex >= 0 && iIndex < NUMDIKEYS) // 특정한 키만 무효화..
		{
			m_byCurKeys[iIndex] = m_byOldKeys[iIndex] = m_bKeyPresses[iIndex] = m_bKeyPresseds[iIndex] = 0;
		}
	}
	BOOL IsNoKeyDown() { return m_bNoKeyDown; }
	BOOL IsKeyDown(int iIndex) { if(iIndex < 0 || iIndex >= NUMDIKEYS) return FALSE; return m_byCurKeys[iIndex]; } // 키보드가 눌려있는지... "DInput.h" 에 정의 되어 있는 DIK_???? 스캔코드를 참조..
	BOOL IsKeyPress(int iIndex) { if(iIndex < 0 || iIndex >= NUMDIKEYS) return FALSE; return m_bKeyPresses[iIndex]; } // 키보드를 누르는 순간... "DInput.h" 에 정의 되어 있는 DIK_???? 스캔코드를 참조..
	BOOL IsKeyPressed(int iIndex) { if(iIndex < 0 || iIndex >= NUMDIKEYS) return FALSE; return m_bKeyPresseds[iIndex]; } // 키보드를 누르고나서 떼는 순간... "DInput.h" 에 정의 되어 있는 DIK_???? 스캔코드를 참조..
	
	BOOL Init(HINSTANCE hInst, HWND hWnd);

	void Tick(void);
	void KeyboardFlushData();
	void MouseSetLimits(int x1, int y1, int x2, int y2);
	void SetActiveDevices(BOOL bKeyboard);
	void MouseSetPos(int x, int y);

	BOOL KeyboardGetKeyState(int nDIKey); // 최근 눌려진 키 검사..

	const POINT MouseGetPos() { return m_ptCurMouse; }
	const POINT MouseGetPosOld() { return m_ptOldMouse; }
	
	RECT MouseGetLBDragRect() { return m_rcLBDrag; }
	RECT MouseGetMBDragRect() { return m_rcMBDrag; }
	RECT MouseGetRBDragRect() { return m_rcRBDrag; }

	int MouseGetFlag() { return m_nMouseFlag; } // Mouse Flag 의 or 연산으로 조합되어 있다.
	int MouseGetFlagOld() { return m_nMouseFlagOld; }
	void MouseRemoveFlag(int nFlag = -1) { if(-1 == nFlag) m_nMouseFlag = m_nMouseFlagOld = 0; else m_nMouseFlag &= (~nFlag); } // 특정한 Mouse Flag 제거

	CLocalInput(void);
	~CLocalInput(void);
};

#endif // end of _LocalInput_H_

// ===== END WarFare/LocalInput.h =====

// ===== BEGIN WarFare/MagicSkillMng.cpp =====
#line 1 "WarFare/MagicSkillMng.cpp"
﻿// MagicSkillMng.cpp: implementation of the CMagicSkillMng class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MagicSkillMng.h"
#include "GameProcMain.h"
#include "APISocket.h"
#include "PacketDef.h"
#include "PlayerMySelf.h"
#include "PlayerOtherMgr.h"
#include "N3FXMgr.h"
#include "N3WorldManager.h"

#include "UIStateBar.h"
#include "UIInventory.h"
#include "UIVarious.h"
#include "UIPartyOrForce.h"
#include "UIHotKeyDlg.h"

#include "text_resources.h"

#include <N3Base/N3SndObj.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3ShapeExtra.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMagicSkillMng::CMagicSkillMng()
{
	m_pGameProcMain = nullptr;
	m_dwRegionMagicState = 0;
	m_dwCastingStateNonAction = 0;
	m_fCastTimeNonAction = 0.0f;
	m_dwNonActionMagicID = 0;
	m_iNonActionMagicTarget = -1;
	//m_fRecastTimeNonAction = 0.0f;

	m_iMyRegionTargetFXID = 0;
	m_fZonePointerRadius = -1.0f;
	m_fZonePointerRadiusEffective = 0.0f;
	m_fZonePointerRotRad = 0.0f;

	Init();
}

CMagicSkillMng::CMagicSkillMng(CGameProcMain* pGameProcMain)
{
	m_pGameProcMain = pGameProcMain;
	m_dwRegionMagicState = 0;
	m_dwCastingStateNonAction = 0;
	m_fCastTimeNonAction = 0.0f;
	m_dwNonActionMagicID = 0;
	m_iNonActionMagicTarget = -1;
	//m_fRecastTimeNonAction = 0.0f;

	m_iMyRegionTargetFXID = 0;
	m_fZonePointerRadius = -1.0f;
	m_fZonePointerRadiusEffective = 0.0f;
	m_fZonePointerRotRad = 0.0f;

	Init();
}

void CMagicSkillMng::Init()
{
	m_pTbl_Type_1 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_1>;
	m_pTbl_Type_1->LoadFromFile("Data\\Skill_Magic_1.tbl");

	m_pTbl_Type_2 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_2>;
	m_pTbl_Type_2->LoadFromFile("Data\\Skill_Magic_2.tbl");

	m_pTbl_Type_3 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_3>;
	m_pTbl_Type_3->LoadFromFile("Data\\Skill_Magic_3.tbl");

	m_pTbl_Type_4 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_4>;
	m_pTbl_Type_4->LoadFromFile("Data\\Skill_Magic_4.tbl");

//	m_pTbl_Type_6 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_6>;
//	m_pTbl_Type_6->LoadFromFile("Data\\Skill_Magic_6.tbl");

	m_pTbl_Type_7 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_7>;
	m_pTbl_Type_7->LoadFromFile("Data\\Skill_Magic_7.tbl");

//	m_pTbl_Type_9 = new CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_9>;
//	m_pTbl_Type_9->LoadFromFile("Data\\Skill_Magic_9.tbl");

	m_MySelf.clear();

	m_iTarget = -1;
	m_vTargetPos.Set(0,0,0);

	//m_fRecastTime = 0.0f;
	m_fDelay = 0.0f;

	m_dwRegionMagicState = 0;

	InitType4();

	m_iMyRegionTargetFXID = 0;
	/*
	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);
	if( pInfoBase->eClass==CLASS_KA_ROGUE || pInfoBase->eClass==CLASS_KA_HUNTER || pInfoBase->eClass==CLASS_KA_PENETRATOR )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_KA_ROGUE;
	}
	else if( pInfoBase->eClass==CLASS_KA_WIZARD || pInfoBase->eClass==CLASS_KA_SORCERER || pInfoBase->eClass==CLASS_KA_NECROMANCER )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_KA_WIZARD;
	}
	else if( pInfoBase->eClass==CLASS_KA_PRIEST || pInfoBase->eClass==CLASS_KA_SHAMAN || pInfoBase->eClass==CLASS_KA_DARKPRIEST )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_KA_PRIEST;
	}
	else if( pInfoBase->eClass==CLASS_EL_ROGUE || pInfoBase->eClass==CLASS_EL_RANGER || pInfoBase->eClass==CLASS_EL_ASSASIN )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_EL_ROGUE;
	}
	else if( pInfoBase->eClass==CLASS_EL_WIZARD || pInfoBase->eClass==CLASS_EL_MAGE || pInfoBase->eClass==CLASS_EL_ENCHANTER )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_EL_WIZARD;
	}
	else if( pInfoBase->eClass==CLASS_EL_PRIEST || pInfoBase->eClass==CLASS_EL_CLERIC || pInfoBase->eClass==CLASS_EL_DRUID )
	{
		m_iMyRegionTargetFXID = FXID_REGION_TARGET_EL_PRIEST;
	}
	*/
}

CMagicSkillMng::~CMagicSkillMng()
{
	m_pGameProcMain = nullptr;

	if(m_pTbl_Type_1 != nullptr) { delete m_pTbl_Type_1; m_pTbl_Type_1 = nullptr; }
	if(m_pTbl_Type_2 != nullptr) { delete m_pTbl_Type_2; m_pTbl_Type_2 = nullptr; }
	if(m_pTbl_Type_3 != nullptr) { delete m_pTbl_Type_3; m_pTbl_Type_3 = nullptr; }
	if(m_pTbl_Type_4 != nullptr) { delete m_pTbl_Type_4; m_pTbl_Type_4 = nullptr; }
//	if(m_pTbl_Type_6 != nullptr) { delete m_pTbl_Type_6; m_pTbl_Type_6 = nullptr; }
	if(m_pTbl_Type_7 != nullptr) { delete m_pTbl_Type_7; m_pTbl_Type_7 = nullptr; }
//	if(m_pTbl_Type_9 != nullptr) { delete m_pTbl_Type_9; m_pTbl_Type_9 = nullptr; }
//	if(m_pTbl_Type_10 != nullptr) { delete m_pTbl_Type_10; m_pTbl_Type_10 = nullptr; }
}


//
//
//
bool CMagicSkillMng::IsCasting()
{
	if(s_pPlayer->State() == PSA_SPELLMAGIC ||
		s_pPlayer->m_dwMagicID != 0xffffffff ||
		s_pPlayer->m_bStun == true ||
		m_fDelay > 0.0f ) return true;	
	return false;
}

// returns true if the player is currently equipping the required item group
bool CMagicSkillMng::HasEquippedRequiredItemGroup(const __TABLE_UPC_SKILL* pSkill) const
{
	int LeftItem = s_pPlayer->ItemClass_LeftHand();
	int RightItem = s_pPlayer->ItemClass_RightHand();

	int LeftItemGroup = LeftItem / 10;
	int RightItemGroup = RightItem / 10;

	if (pSkill->dwNeedItem != 9
		&& pSkill->dwNeedItem != 0
		&& pSkill->dwNeedItem != static_cast<uint32_t>(LeftItemGroup)
		&& pSkill->dwNeedItem != static_cast<uint32_t>(RightItemGroup))
		return false;

	return true;
}

// returns true if the player is currently equipping a weapon, if applicable
bool CMagicSkillMng::HasRequiredWeaponEquipped(const __TABLE_UPC_SKILL* pSkill) const
{
	// NOTE: Officially this is explicitly == 0, but only for CheckValidSkillMagic().
	// We'll just keep it consistent with the logic enforced on cast, as that's the real enforcer here.
	if (pSkill->dwNeedItem != 9
		&& !s_pPlayer->HasWeaponEquipped())
		return false;

	return true;
}

bool CMagicSkillMng::HasRequiredMana(const __TABLE_UPC_SKILL* pSkill) const
{
	return s_pPlayer->m_InfoExt.iMSP >= pSkill->iExhaustMSP;
}

bool CMagicSkillMng::HasRequiredHealth(const __TABLE_UPC_SKILL* pSkill) const
{
	// Ignore HP requirement for Sacrifice skill.
	if (pSkill->iExhaustHP >= 10000)
		return true;

	return s_pPlayer->m_InfoBase.iHP >= pSkill->iExhaustHP;
}

bool CMagicSkillMng::HasRequiredExhaustItem(const __TABLE_UPC_SKILL* pSkill, bool* reportError /*= nullptr*/) const
{
	if (pSkill->dwExhaustItem == 0)
		return true;

	int NumItem = m_pGameProcMain->m_pUIInventory->GetCountInInvByID(pSkill->dwExhaustItem);

	if (pSkill->dw1stTableType == 2
		|| pSkill->dw2ndTableType == 2)
	{
		__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
		if (pType2 == nullptr)
			return false;

		if (NumItem < pType2->iNumArrow)
		{
			if (reportError != nullptr)
				*reportError = true;

			return false;
		}
	}
	else
	{
		if (NumItem < 1)
		{
			if (reportError != nullptr)
				*reportError = true;

			return false;
		}
	}

	__TABLE_ITEM_BASIC* pItem = nullptr;
	__TABLE_ITEM_EXT* pItemExt = nullptr;

	pItem = s_pTbl_Items_Basic.Find(pSkill->dwExhaustItem / 1000 * 1000);
	if (pItem != nullptr && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(pSkill->dwExhaustItem % 1000);
	if (pItem == nullptr || pItemExt == nullptr)
	{
		__ASSERT(0, "NULL Item");
		CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", pSkill->dwExhaustItem);
		return false;	// 아이템이 없으면..
	}

	if (pItem->byAttachPoint == ITEM_LIMITED_EXHAUST)
	{
		// 종족 체크..
		switch (pItem->byNeedRace)
		{
			case 0:
				break;

			default:
				if (pItem->byNeedRace != s_pPlayer->m_InfoBase.eRace)
					return false;
				break;
		}

		// 직업 체크..
		if (pItem->byNeedClass != 0)
		{
			switch (pItem->byNeedClass)
			{
				case CLASS_KINDOF_WARRIOR:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_WARRIOR:
						case CLASS_KA_BERSERKER:
						case CLASS_KA_GUARDIAN:
						case CLASS_EL_WARRIOR:
						case CLASS_EL_BLADE:
						case CLASS_EL_PROTECTOR:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_ROGUE:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_ROGUE:
						case CLASS_KA_HUNTER:
						case CLASS_KA_PENETRATOR:
						case CLASS_EL_ROGUE:
						case CLASS_EL_RANGER:
						case CLASS_EL_ASSASIN:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_WIZARD:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_WIZARD:
						case CLASS_KA_SORCERER:
						case CLASS_KA_NECROMANCER:
						case CLASS_EL_WIZARD:
						case CLASS_EL_MAGE:
						case CLASS_EL_ENCHANTER:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_PRIEST:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_PRIEST:
						case CLASS_KA_SHAMAN:
						case CLASS_KA_DARKPRIEST:
						case CLASS_EL_PRIEST:
						case CLASS_EL_CLERIC:
						case CLASS_EL_DRUID:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_ATTACK_WARRIOR:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_BERSERKER:
						case CLASS_EL_BLADE:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_DEFEND_WARRIOR:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_GUARDIAN:
						case CLASS_EL_PROTECTOR:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_ARCHER:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_HUNTER:
						case CLASS_EL_RANGER:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_ASSASSIN:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_PENETRATOR:
						case CLASS_EL_ASSASIN:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_ATTACK_WIZARD:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_SORCERER:
						case CLASS_EL_MAGE:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_PET_WIZARD:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_NECROMANCER:
						case CLASS_EL_ENCHANTER:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_HEAL_PRIEST:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_SHAMAN:
						case CLASS_EL_CLERIC:
							break;
						default:
							return false;
					}
					break;

				case CLASS_KINDOF_CURSE_PRIEST:
					switch (s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_DARKPRIEST:
						case CLASS_EL_DRUID:
							break;
						default:
							return false;
					}
					break;

				default:
					if (s_pPlayer->m_InfoBase.eClass != pItem->byNeedClass)
						return false;
					break;
			}
		}

		// 요구레벨 체크..
		if (s_pPlayer->m_InfoBase.iLevel < pItem->cNeedLevel + pItemExt->siNeedLevel)
			return false;

		// 요구 능력치 체크..
		int iNeedValue;
		iNeedValue = pItem->byNeedStrength;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedStrength;
		if (iNeedValue > 0 && s_pPlayer->m_InfoExt.iStrength < iNeedValue)
			return false;

		iNeedValue = pItem->byNeedStamina;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedStamina;
		if (iNeedValue > 0 && s_pPlayer->m_InfoExt.iStamina < iNeedValue)
			return false;

		iNeedValue = pItem->byNeedDexterity;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedDexterity;
		if (iNeedValue > 0 && s_pPlayer->m_InfoExt.iDexterity < iNeedValue)
			return false;

		iNeedValue = pItem->byNeedInteli;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedInteli;
		if (iNeedValue > 0 && s_pPlayer->m_InfoExt.iIntelligence < iNeedValue)
			return false;

		iNeedValue = pItem->byNeedMagicAttack;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedMagicAttack;
		if (iNeedValue > 0 && s_pPlayer->m_InfoExt.iAttack < iNeedValue)
			return false;
	}

	return true;
}

// Visually disables skills on the skillbar (CUIHotKeyDlg) and skill tree (CUISkillTreeDlg)
bool CMagicSkillMng::CheckValidSkillMagic(const __TABLE_UPC_SKILL* pSkill) const
{
	if (!HasRequiredMana(pSkill))
		return false;

	if (!HasRequiredHealth(pSkill))
		return false;

	if (!HasEquippedRequiredItemGroup(pSkill))
		return false;
	
	if (!HasRequiredWeaponEquipped(pSkill))
		return false;

	if (!HasRequiredExhaustItem(pSkill))
		return false;

	return true;
}

bool CMagicSkillMng::CheckValidCondition(int iTargetID, const __TABLE_UPC_SKILL* pSkill) const
{
	e_Class_Represent Class = GetRepresentClass(s_pPlayer->m_InfoBase.eClass);

	if (pSkill->iNeedSkill != 0)
	{
		if (Class == CLASS_REPRESENT_WARRIOR)
		{
			int NeedSkill = pSkill->iNeedSkill / 10;
			if (NeedSkill != CLASS_KA_WARRIOR && NeedSkill != CLASS_KA_BERSERKER && NeedSkill != CLASS_KA_GUARDIAN
				&& NeedSkill != CLASS_EL_WARRIOR && NeedSkill != CLASS_EL_BLADE && NeedSkill != CLASS_EL_PROTECTOR)
			{
				std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_DIFFURENTCLASS);
				m_pGameProcMain->MsgOutput(buff, 0xffffff00);
				return false;
			}
		}
		else if (Class == CLASS_REPRESENT_ROGUE)
		{
			int NeedSkill = pSkill->iNeedSkill / 10;
			if (NeedSkill != CLASS_KA_ROGUE && NeedSkill != CLASS_KA_HUNTER && NeedSkill != CLASS_KA_PENETRATOR
				&& NeedSkill != CLASS_EL_ROGUE && NeedSkill != CLASS_EL_RANGER && NeedSkill != CLASS_EL_ASSASIN)
			{
				std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_DIFFURENTCLASS);
				m_pGameProcMain->MsgOutput(buff, 0xffffff00);
				return false;
			}
		}
		else if (Class == CLASS_REPRESENT_WIZARD)
		{
			int NeedSkill = pSkill->iNeedSkill / 10;
			if (NeedSkill != CLASS_KA_WIZARD && NeedSkill != CLASS_KA_SORCERER && NeedSkill != CLASS_KA_NECROMANCER
				&& NeedSkill != CLASS_EL_WIZARD && NeedSkill != CLASS_EL_MAGE && NeedSkill != CLASS_EL_ENCHANTER)
			{
				std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_DIFFURENTCLASS);
				m_pGameProcMain->MsgOutput(buff, 0xffffff00);
				return false;
			}
		}
		else if (Class == CLASS_REPRESENT_PRIEST)
		{
			int NeedSkill = pSkill->iNeedSkill / 10;
			if (NeedSkill != CLASS_KA_PRIEST && NeedSkill != CLASS_KA_DARKPRIEST && NeedSkill != CLASS_KA_SHAMAN
				&& NeedSkill != CLASS_EL_PRIEST && NeedSkill != CLASS_EL_CLERIC && NeedSkill != CLASS_EL_DRUID)
			{
				std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_DIFFURENTCLASS);
				m_pGameProcMain->MsgOutput(buff, 0xffffff00);
				return false;
			}
		}
	}

	if (!HasRequiredMana(pSkill))
	{
		std::string buff;

		if (Class == CLASS_REPRESENT_PRIEST || Class == CLASS_REPRESENT_WIZARD)
		{
			buff = fmt::format_text_resource(IDS_MSG_CASTING_FAIL_LACK_MP);
			m_pGameProcMain->MsgOutput(buff, 0xffffff00);
		}
		else if (Class == CLASS_REPRESENT_WARRIOR || Class == CLASS_REPRESENT_ROGUE)
		{
			buff = fmt::format_text_resource(IDS_SKILL_FAIL_LACK_SP);
			m_pGameProcMain->MsgOutput(buff, 0xffffff00);
		}

		return false;
	}

	if (!HasRequiredHealth(pSkill))
	{
		std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_LACK_HP);
		m_pGameProcMain->MsgOutput(buff, 0xffffff00);
		return false;
	}

	if (!HasEquippedRequiredItemGroup(pSkill))
	{
		std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_INVALID_ITEM);
		m_pGameProcMain->MsgOutput(buff, 0xffffff00);
		return false;
	}

	if (!HasRequiredWeaponEquipped(pSkill))
	{
		std::string buff = fmt::format_text_resource(IDS_SKILL_FAIL_PLEASE_EQUIP_YOUR_WEAPON);
		m_pGameProcMain->MsgOutput(buff, 0xffffff00);
		return false;
	}

	bool reportError = false;
	if (!HasRequiredExhaustItem(pSkill, &reportError))
	{
		if (reportError)
		{
			std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_LACK_ITEM);
			m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
		}
		return false;
	}


	if ((pSkill->dw1stTableType == 3 || pSkill->dw2ndTableType == 3)
		&& pSkill->iTarget == SKILLMAGIC_TARGET_SELF)
	{
		__TABLE_UPC_SKILL_TYPE_3* pType3 = m_pTbl_Type_3->Find(pSkill->dwID);
		if (pType3 == nullptr)
			return false;

		int key = 0;
		if (pType3->iStartDamage > 0
			|| (pType3->iStartDamage == 0 && pType3->iDuraDamage > 0))
			key = DDTYPE_TYPE3_DUR_OUR;
		else
			key = DDTYPE_TYPE3_DUR_ENEMY;

		key += pType3->iDDType;

		if (key == DDTYPE_TYPE3_DUR_OUR)
		{
			if (m_ListBuffTypeID.contains(key))
				return false;
		}
	}

	if ((pSkill->dw1stTableType == 4 || pSkill->dw2ndTableType == 4)
		&& (pSkill->iTarget == SKILLMAGIC_TARGET_SELF || iTargetID == s_pPlayer->IDNumber()))
	{
		__TABLE_UPC_SKILL_TYPE_4* pType4 = m_pTbl_Type_4->Find(pSkill->dwID);
		if (pType4 == nullptr)
			return false;

		switch (pType4->iBuffType)
		{
			case BUFFTYPE_MAXHP:
				if (m_iMaxHP != 0)
					return false;
				break;
			case BUFFTYPE_AC:
				if (m_iAC != 0)
					return false;
				break;
			case BUFFTYPE_ATTACK:
				if (m_iAttack != 0)
					return false;
				break;
			case BUFFTYPE_ATTACKSPEED:
				if (m_fAttackSpeed != 1.0f)
					return false;
				break;
			case BUFFTYPE_SPEED:
				if (m_fSpeed != 1.0f)
					return false;
				break;
			case BUFFTYPE_ABILITY:
				if (m_iStr != 0
					|| m_iSta != 0
					|| m_iDex != 0
					|| m_iInt != 0
					|| m_iMAP != 0)
					return false;
				break;
			case BUFFTYPE_RESIST:
				if (m_iFireR != 0
					|| m_iColdR != 0
					|| m_iLightningR != 0
					|| m_iMagicR != 0
					|| m_iDeseaseR != 0
					|| m_iPoisonR != 0)
					return false;
				break;
		}
	}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// 스킬 사용시 오브젝트 체크
	CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);
	if (pTarget == nullptr)
		return true;

	__Vector3 vNormal, vMyPos, vGap, vDir, vSkillPos;

	vMyPos = s_pPlayer->Position();
	vMyPos.y += s_pPlayer->Height() / 2;

	vDir = (pTarget->Position() + pTarget->Height() / 2) - vMyPos;
	vGap = vDir;
	vDir.Normalize();

	bool bColShape = ACT_WORLD->CheckCollisionWithShape(vMyPos, vDir, vGap.Magnitude(), &vSkillPos, &vNormal);

	switch (pSkill->iTarget)
	{
		case SKILLMAGIC_TARGET_NPC_ONLY:
			if (bColShape)
			{
				std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_OBJECT_BLOCK);
				m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
				return false;
			}
			break;

		case SKILLMAGIC_TARGET_ENEMY_ONLY:
			if (s_pPlayer->IsHostileTarget(pTarget))
			{
				if (bColShape)
				{
					std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_OBJECT_BLOCK);
					m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
					return false;
				}
			}
			break;

		case SKILLMAGIC_TARGET_ALL:
			if (bColShape)
			{
				std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_OBJECT_BLOCK);
				m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
				return false;
			}
			break;

		case SKILLMAGIC_TARGET_DEAD_FRIEND_ONLY:
			if (!s_pPlayer->IsHostileTarget(pTarget)
				&& pTarget->IsDead())
			{
				if (bColShape)
				{
					std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_OBJECT_BLOCK);
					m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
					return false;
				}
			}
			break;
	}

// 스킬 사용시 오브젝트 체크
/////////////////////////////////////////////////////////////////////////////////////////////////////

	return true;
}


//
///
//
bool CMagicSkillMng::MsgSend_MagicProcess(int iTargetID, __TABLE_UPC_SKILL* pSkill)
{
	//if(m_fRecastTime > 0.0f) return;//recast time이 아직 안되었네..^^
	if(s_pPlayer->IsDead()) return false; // 죽어 있네.. ^^

	///////////////////////////////////////////////////////////////////////////////////
	// 스킬 쓸 조건이 되는지 검사...
	// Existing validity checks
	if (pSkill == nullptr) return false;
	// Check cooldowns first
	auto itRecast = m_RecastTimes.find(pSkill->dwID);
	auto itNonAction = m_NonActionRecastTimes.find(pSkill->dwID);

	if (pSkill->iSelfAnimID1 > 0) // Casting skill with animation
	{
		if (IsCasting() || (itRecast != m_RecastTimes.end() && itRecast->second > 0))
			return false;
	}
	else // Instant/non-action skill
	{
		if (itNonAction != m_NonActionRecastTimes.end() && itNonAction->second > 0)
			return false;
		m_dwCastingStateNonAction = 0;
		m_fCastTimeNonAction = 0.0f;
		m_dwNonActionMagicID = 0;
		m_iNonActionMagicTarget = -1;
	}
	if(!CheckValidCondition(iTargetID, pSkill)) return false;

	//TRACE("마법성공 state : %d time %.2f\n", s_pPlayer->State(), CN3Base::TimeGet());
	// 스킬 쓸 조건이 되는지 검사 끝...
	///////////////////////////////////////////////////////////////////////////////////
	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);
	CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);

	//지역마법타겟 초기화..
	CGameProcedure::s_pFX->Stop(s_pPlayer->IDNumber(), s_pPlayer->IDNumber(), m_iMyRegionTargetFXID, m_iMyRegionTargetFXID, true);

	CancelZonePointer();

	m_dwRegionMagicState = 0;	
	if(m_iMyRegionTargetFXID == 0)
	{
		if(pInfoBase->eNation == NATION_KARUS)
		{
			m_iMyRegionTargetFXID = FXID_REGION_TARGET_KA_WIZARD;
		}
		else if(pInfoBase->eNation == NATION_ELMORAD)
		{
			m_iMyRegionTargetFXID = FXID_REGION_TARGET_EL_WIZARD;
		}
	}
	//	

//	if(!pTarget) return false;//임시 일단 죽어 있다면 리턴을 한다.

	float fDist = s_pPlayer->Radius() + 1.0f; // 공격 거리제한..
	if(pTarget != nullptr) fDist += pTarget->Radius();

	switch(pSkill->iTarget)
	{
	case SKILLMAGIC_TARGET_SELF:
		{
			StartSkillMagicAtTargetPacket(pSkill, (int16_t)s_pPlayer->IDNumber());
			return true;
		}
	case SKILLMAGIC_TARGET_FRIEND_WITHME:
		{
			if(pTarget == nullptr)
			{
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)s_pPlayer->IDNumber());
				return true;
			}
			else if (!s_pPlayer->IsHostileTarget(pTarget))
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_FRIEND_ONLY:
		{
			if (pTarget != nullptr
				&& !s_pPlayer->IsHostileTarget(pTarget))
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_PARTY:
		{
			__InfoPartyOrForce* pInfo = (__InfoPartyOrForce*)m_pGameProcMain->m_pUIPartyOrForce->MemberInfoGetSelected();
			if(!pInfo && iTargetID==-1) pTarget = (CPlayerBase*)s_pPlayer;

			int iMemberIndex  = -1;
			if(pTarget != nullptr &&
				( m_pGameProcMain->m_pUIPartyOrForce->MemberInfoGetByID(pTarget->IDNumber(), iMemberIndex) ||
				pTarget->IDNumber() == s_pPlayer->IDNumber() ) )
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			else if(pInfo != nullptr)	//거리에 상관없이 파티원들에게 쓸때...
			{
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pInfo->iID);
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_NPC_ONLY:
		{
			if(pTarget != nullptr && s_pOPMgr->NPCGetByID(pTarget->IDNumber(), true))
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_PARTY_ALL:
		{
			StartSkillMagicAtPosPacket(pSkill, s_pPlayer->Position());
			return true;
		}
	case SKILLMAGIC_TARGET_ENEMY_ONLY:
		{
			if (pTarget != nullptr
				&& s_pPlayer->IsHostileTarget(pTarget))
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				//CLogWriter::Write("send msg : {:.4f}", CN3Base::TimeGet());
				//TRACE("send msg : %.4f\n", CN3Base::TimeGet());
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_ALL:
		{
			if(pTarget != nullptr)
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			break;
		}
	case SKILLMAGIC_TARGET_AREA:
		{
			StartSkillMagicAtPosPacket(pSkill, s_pPlayer->Position());
			return true;
		}
	case SKILLMAGIC_TARGET_AREA_ENEMY:
	case SKILLMAGIC_TARGET_AREA_FRIEND:
	case SKILLMAGIC_TARGET_AREA_ALL:
		{
			m_dwRegionMagicState = 1;
			m_dwRegionSkill = (*pSkill);
//			CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), 0, m_iMyRegionTargetFXID, m_pGameProcMain->m_vMouseLBClickedPos, m_iMyRegionTargetFXID);	//전격무기...
			CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), 0, m_iMyRegionTargetFXID, m_pGameProcMain->m_vMouseSkillPos, m_iMyRegionTargetFXID);	//전격무기...

			// Zone pointer circle FX with scaling

			switch (pSkill->dw1stTableType)
			{
				case 3:
				{
					__TABLE_UPC_SKILL_TYPE_3* pType3 = m_pTbl_Type_3->Find(pSkill->dwID);
					if (pType3 != nullptr)
						m_fZonePointerRadius = pType3->iRadius - 1.0f;
				} break;

				case 4:
				{
					__TABLE_UPC_SKILL_TYPE_4* pType4 = m_pTbl_Type_4->Find(pSkill->dwID);
					if (pType4 != nullptr)
						m_fZonePointerRadius = pType4->iRadius - 1.0f;
				} break;

				case 7:
				{
					__TABLE_UPC_SKILL_TYPE_7* pType7 = m_pTbl_Type_7->Find(pSkill->dwID);
					if (pType7 != nullptr)
						m_fZonePointerRadius = pType7->iRadius - 1.0f;
				} break;

				default:
					return true;
			}

			m_fZonePointerRotRad = 0.0f;
			m_fZonePointerRadiusEffective = 0.0f;

			// Start FX elements
			for (int j = 0; j < 8; j++)
			{
				CGameProcedure::s_pFX->TriggerBundle(
					s_pPlayer->IDNumber(),
					0,
					FXID_ZONE_POINTER,
					m_pGameProcMain->m_vMouseSkillPos,
					FXID_ZONE_POINTER + j);	// Unique index
			}

			return true;
		}
	case SKILLMAGIC_TARGET_DEAD_FRIEND_ONLY:
		{
			if (pTarget != nullptr
				&& !s_pPlayer->IsHostileTarget(pTarget)
				&& pTarget->IsDead())
			{
				if( !CheckValidDistance(pSkill, pTarget->Position(), fDist) ) return false;
				StartSkillMagicAtTargetPacket(pSkill, (int16_t)pTarget->IDNumber());
				return true;
			}
			break;
		}
	default:
		break;
	}

	return false;
}

void CMagicSkillMng::SetSkillCooldown(__TABLE_UPC_SKILL* pSkill)
{
	// Convert iReCastTime (stored in tenths of seconds) to seconds
	const float fCooldown = static_cast<float>(pSkill->iReCastTime) / 10.0f;

	if (pSkill->iSelfAnimID1 > 0)
	{
		m_RecastTimes[pSkill->dwID] = fCooldown;
	}
	else
	{
		m_NonActionRecastTimes[pSkill->dwID] = fCooldown;
	}
}

bool CMagicSkillMng::CheckValidDistance(const __TABLE_UPC_SKILL* pSkill, __Vector3 vTargetPos, float fTargetRadius) const
{
	float fDist = (vTargetPos - s_pPlayer->Position()).Magnitude(); // 공격 거리를 구하고..

	if(pSkill->iValidDist > 0 && fDist <= (pSkill->iValidDist+fTargetRadius + 1.0f)) return true;

	//type1
	if(pSkill->dw1stTableType==1 || pSkill->dw2ndTableType==1)
	{
		__IconItemSkill* pItemIcon = m_pGameProcMain->m_pUIInventory->m_pMySlot[ITEM_SLOT_HAND_RIGHT];
		if(pItemIcon != nullptr)
		{
			float fValidDist = (pItemIcon->pItemBasic->siAttackRange/10.0f) + fTargetRadius + 1.0f;
			if(fValidDist >= fDist) return true;
		}
	}

	//화살쏠때....
	if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
	{
		__IconItemSkill* pItemIcon1 = m_pGameProcMain->m_pUIInventory->m_pMySlot[ITEM_SLOT_HAND_LEFT];
		__IconItemSkill* pItemIcon2 = m_pGameProcMain->m_pUIInventory->m_pMySlot[ITEM_SLOT_HAND_RIGHT];
		float ItemDistance = 0.0f;

		if(pItemIcon2 != nullptr) ItemDistance = pItemIcon2->pItemBasic->siAttackRange/10.0f;
		if(pItemIcon1 != nullptr) ItemDistance = pItemIcon1->pItemBasic->siAttackRange/10.0f;

		float fValidDist = ItemDistance + fTargetRadius + 1.0f;
		__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
		fValidDist *= (float)pType2->iAddDist;
		fValidDist /= 100.0f;

		if(fValidDist >= fDist) return true;
	}

	std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_SOFAR, pSkill->szName);
	m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);

	return false;
}

void CMagicSkillMng::StartSkillMagicAtPosPacket(__TABLE_UPC_SKILL* pSkill, __Vector3 vPos)
{
	if(pSkill == nullptr) return;
	int SourceID = s_pPlayer->IDNumber();

	if(pSkill->iSelfAnimID1<0)
	{
		m_dwCastingStateNonAction = 1;
		m_fCastTimeNonAction = (float)pSkill->iCastTime / 10.0f;
		m_dwNonActionMagicID = pSkill->dwID;
		m_iNonActionMagicTarget = -1;
		//m_fRecastTimeNonAction = (float)(pSkill->iReCastTime) / 10.0f;

		int spart1 = pSkill->iSelfPart1 % 1000;
		int spart2 = pSkill->iSelfPart1 / 1000;
		spart2 = abs(spart2);

		CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iSelfFX1, SourceID, spart1, -1);
		if(spart2!=0) CGameProcedure::s_pFX->TriggerBundle(SourceID, spart2, pSkill->iSelfFX1, SourceID, spart2, -2);
		SetSkillCooldown(pSkill);
		return;
	}
	m_pGameProcMain->CommandSitDown(false, false); // 혹시라도 앉아있음 일으켜 세운다..

	if (pSkill->iCastTime == 0)
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
		m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);

		uint8_t byBuff[32];
		int iOffset = 0;
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) WIZ_MAGIC_PROCESS);
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) N3_SP_MAGIC_EFFECTING);
		CAPISocket::MP_AddDword(byBuff, iOffset, (int) pSkill->dwID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) SourceID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) -1);

		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) vPos.x);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) vPos.y);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) vPos.z);

		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);

		CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	
		return;
	}

	///////////////////////////////////////////////////////////////////////////////
	//	
	s_pPlayer->m_dwMagicID = pSkill->dwID;
	s_pPlayer->m_fCastingTime = 0.0f;
	m_iTarget = -1;
	m_vTargetPos = vPos;
		
	int spart1 = pSkill->iSelfPart1 % 1000;
	int spart2 = pSkill->iSelfPart1 / 1000;
	spart2 = abs(spart2);

	CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iSelfFX1, SourceID, spart1, -1);
	if(spart2!=0) CGameProcedure::s_pFX->TriggerBundle(SourceID, spart2, pSkill->iSelfFX1, SourceID, spart2, -2);

	s_pPlayer->m_iIDTarget = -1;
	//s_pPlayer->ActionMove(PSM_STOP);
	m_pGameProcMain->CommandMove(MD_STOP, true);

	s_pPlayer->m_iMagicAni = pSkill->iSelfAnimID1;
	if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
	{
		int LeftItem = s_pPlayer->ItemClass_LeftHand();
		int RightItem = s_pPlayer->ItemClass_RightHand();
		if(RightItem == ITEM_CLASS_BOW_CROSS || LeftItem==ITEM_CLASS_BOW_CROSS)
		{
			s_pPlayer->m_iMagicAni = ANI_SHOOT_QUARREL_A;
		}
	}
	s_pPlayer->m_fCastFreezeTime = 10.0f;
	s_pPlayer->Action(PSA_SPELLMAGIC, false, nullptr);

	////////////////////////////////////////////////////////////////////////////////////////

	uint8_t byBuff[32];
	int iOffset=0;
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_CASTING);
	CAPISocket::MP_AddDword(byBuff, iOffset, (int)pSkill->dwID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SourceID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)-1);

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vPos.x);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vPos.y);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vPos.z);
	
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	
	CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
	SetSkillCooldown(pSkill);

	if(pSkill->iTarget == SKILLMAGIC_TARGET_ENEMY_ONLY) m_pGameProcMain->PlayBGM_Battle();
}

void CMagicSkillMng::StartSkillMagicAtTargetPacket(__TABLE_UPC_SKILL* pSkill, int16_t TargetID)
{
	if(pSkill == nullptr) return;
	int SourceID = s_pPlayer->IDNumber();
	if(pSkill->iSelfAnimID1<0)
	{
		m_dwCastingStateNonAction = 1;
		m_fCastTimeNonAction = (float)(pSkill->iCastTime) / 10.0f;
		m_dwNonActionMagicID = pSkill->dwID;
		m_iNonActionMagicTarget = TargetID;
		//m_fRecastTimeNonAction = (float)(pSkill->iReCastTime) / 10.0f;

		int spart1 = pSkill->iSelfPart1 % 1000;
		int spart2 = pSkill->iSelfPart1 / 1000;
		spart2 = abs(spart2);

		CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iSelfFX1, SourceID, spart1, -1);
		if(spart2!=0) CGameProcedure::s_pFX->TriggerBundle(SourceID, spart2, pSkill->iSelfFX1, SourceID, spart2, -2);
		SetSkillCooldown(pSkill);
		return;
	}

	m_pGameProcMain->CommandSitDown(false, false); // 혹시라도 앉아있음 일으켜 세운다..
	
	if((pSkill->dw1stTableType==1 || pSkill->dw2ndTableType==1) && pSkill->iCastTime==0)
	{
		CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(TargetID, true);
		if(pTarget == nullptr) return;

		//바로 skill로 들어가..^^
		//casting packet은 보내지 않고..바로 effect packet을 보낸다..

		//기술 애니메이션 드가...=^^=
		//효과있으면 같이 드가..
		__TABLE_UPC_SKILL_TYPE_1* pType1 = m_pTbl_Type_1->Find(pSkill->dwID);
		if(pType1 == nullptr) return;

		// 검기 색을 바꾸어 준다..
//		D3DCOLOR crTrace = TraceColorGet(pSkill); // 스킬의 종류에 따라 검기의 색을 정한다..
//		s_pPlayer->PlugTraceColorRemake(crTrace); // 검기 색 적용..

		s_pPlayer->RotateTo(pTarget);

		m_iTarget = TargetID;

		for(int i=0;i<pType1->iNumCombo;i++)
		{
			bool bImmediately = ((0 == i) ? true : false); // 처음건 바로 넣는다..
			s_pPlayer->AnimationAdd((e_Ani)pType1->iAct[i], bImmediately);
		}			
		
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
		m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
		
		uint8_t byBuff[32];
		int iOffset = 0;
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) WIZ_MAGIC_PROCESS);
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) N3_SP_MAGIC_EFFECTING);
		CAPISocket::MP_AddDword(byBuff, iOffset, (int) pSkill->dwID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) SourceID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) TargetID);

		CAPISocket::MP_AddShort(byBuff, iOffset, 1);
		CAPISocket::MP_AddShort(byBuff, iOffset, 1);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);

		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		
		CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	
		SetSkillCooldown(pSkill);
		return;
	}

	if (pSkill->iCastTime == 0)
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
		m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);

		uint8_t byBuff[32];
		int iOffset = 0;
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) WIZ_MAGIC_PROCESS);
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) N3_SP_MAGIC_EFFECTING);
		CAPISocket::MP_AddDword(byBuff, iOffset, (int) pSkill->dwID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) SourceID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) TargetID);

		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		
		CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	
		SetSkillCooldown(pSkill);
		return;
	}

	/////////////////////////////////////////////////////////////
	//내껀 패킷 보내면서 그냥 처리..
	s_pPlayer->m_dwMagicID = pSkill->dwID;
	s_pPlayer->m_fCastingTime = 0.0f;
	m_iTarget = TargetID;
	
	CPlayerBase* pTargetPlayer = m_pGameProcMain->CharacterGetByID(TargetID, false);
			
	int spart1 = pSkill->iSelfPart1 % 1000;
	int spart2 = pSkill->iSelfPart1 / 1000;
	spart2 = abs(spart2);

	CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iSelfFX1, SourceID, spart1, -1);
	if(spart2!=0) CGameProcedure::s_pFX->TriggerBundle(SourceID, spart2, pSkill->iSelfFX1, SourceID, spart2, -2);

	s_pPlayer->m_iIDTarget = TargetID;			

	//s_pPlayer->ActionMove(PSM_STOP);
	m_pGameProcMain->CommandMove(MD_STOP, true);

	s_pPlayer->m_iMagicAni = pSkill->iSelfAnimID1;
	if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
	{
		int LeftItem = s_pPlayer->ItemClass_LeftHand();
		int RightItem = s_pPlayer->ItemClass_RightHand();
		if(RightItem == ITEM_CLASS_BOW_CROSS || LeftItem==ITEM_CLASS_BOW_CROSS)
		{
			s_pPlayer->m_iMagicAni = ANI_SHOOT_QUARREL_A;
		}
	}
	s_pPlayer->m_fCastFreezeTime = 10.0f;
	s_pPlayer->Action(PSA_SPELLMAGIC, false, pTargetPlayer);

	uint8_t byBuff[32];
	int iOffset=0;
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_CASTING);
	CAPISocket::MP_AddDword(byBuff, iOffset, (int)pSkill->dwID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SourceID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)TargetID);

	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	
	CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
	
	if(pSkill->iTarget == SKILLMAGIC_TARGET_ENEMY_ONLY) m_pGameProcMain->PlayBGM_Battle();
	//
	/////////////////////////////////////////////////////////////
}


//
//	내가 캐스팅 중이면 케스팅 처리해야되고, flying효과도 처리..
//
void CMagicSkillMng::Tick()
{
#ifdef _DEBUG
	std::string debugMessage;
	m_fMsgUpdateTimer += CN3Base::s_fSecPerFrm;
#endif

	for (auto it = m_RecastTimes.begin(); it != m_RecastTimes.end(); )
	{
#ifdef _DEBUG
		if (m_fMsgUpdateTimer >= 0.2f)
		{
			debugMessage = fmt::format("SkillID: {} - {:.2f} seconds", it->first, it->second);
			m_pGameProcMain->MsgOutput(debugMessage, 0xffffff00);
			m_fMsgUpdateTimer = 0.0f;
		}
#endif
		it->second -= CN3Base::s_fSecPerFrm;

		if (it->second < 0)
			it = m_RecastTimes.erase(it);
		else
			++it;
	}

	for (auto it = m_NonActionRecastTimes.begin(); it != m_NonActionRecastTimes.end(); )
	{
#ifdef _DEBUG
		if (m_fMsgUpdateTimer >= 0.2f)
		{
			debugMessage = fmt::format("SkillID: {} - skill {:.2f} seconds", it->first, it->second);
			m_pGameProcMain->MsgOutput(debugMessage, 0xffffff00);
			m_fMsgUpdateTimer = 0.0f;
		}
#endif

		it->second -= CN3Base::s_fSecPerFrm;
		if (it->second < 0)
			it = m_NonActionRecastTimes.erase(it);
		else
			++it;
	}

	// Legacy Existing code for delay and casting
	m_fDelay -= CN3Base::s_fSecPerFrm;
	if (m_fDelay < 0.0f) m_fDelay = 0.0f;
	ProcessCasting();
	//TRACE("skillmagic tick state : %d time %.2f\n", s_pPlayer->State(), CN3Base::TimeGet());

	if (m_fZonePointerRadius > 0.0f)
	{
		// Initially grow radius per tick as per official.
		if (m_fZonePointerRadiusEffective <= m_fZonePointerRadius)
			m_fZonePointerRadiusEffective += 1.0f;

		// Get REAL-TIME mouse position
		m_fZonePointerRotRad += CN3Base::s_fSecPerFrm * DegreesToRadians(50.0f);

		UpdateZonePointerPositions();
	}

	if(m_dwRegionMagicState==2)
	{
		m_dwRegionMagicState = 0;
		CGameProcedure::s_pFX->Stop(s_pPlayer->IDNumber(), s_pPlayer->IDNumber(), m_iMyRegionTargetFXID, m_iMyRegionTargetFXID, true);
		CancelZonePointer();
//		if( !CheckValidDistance(&m_dwRegionSkill, m_pGameProcMain->m_vMouseLBClickedPos, 0) ) return;
//		StartSkillMagicAtPosPacket(&m_dwRegionSkill, m_pGameProcMain->m_vMouseLBClickedPos);		
		if( !CheckValidDistance(&m_dwRegionSkill, m_pGameProcMain->m_vMouseSkillPos, 0) ) return;
		StartSkillMagicAtPosPacket(&m_dwRegionSkill, m_pGameProcMain->m_vMouseSkillPos);		
	}

	if( m_dwCastingStateNonAction == 1)
	{
		m_fCastTimeNonAction -= CN3Base::s_fSecPerFrm;
		if(m_fCastTimeNonAction<0.0f)
		{
			__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(m_dwNonActionMagicID);
			if(!pSkill) 
			{
				m_dwCastingStateNonAction = 0;
				m_fCastTimeNonAction = 0.0f;
				m_dwNonActionMagicID = 0;
				m_iNonActionMagicTarget = -1;
				return;
			}

			uint8_t byBuff[32];
			int iOffset = 0;
			CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) WIZ_MAGIC_PROCESS);
			CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t) N3_SP_MAGIC_EFFECTING);
			CAPISocket::MP_AddDword(byBuff, iOffset, (int) m_dwNonActionMagicID);
			CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_pPlayer->IDNumber());
			CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_iNonActionMagicTarget);

			CAPISocket::MP_AddShort(byBuff, iOffset, 0);	//targetpos...
			CAPISocket::MP_AddShort(byBuff, iOffset, 0);
			CAPISocket::MP_AddShort(byBuff, iOffset, 0);

			CAPISocket::MP_AddShort(byBuff, iOffset, 0);
			CAPISocket::MP_AddShort(byBuff, iOffset, 0);
			CAPISocket::MP_AddShort(byBuff, iOffset, 0);
			
			CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

			m_dwCastingStateNonAction = 0;
			m_fCastTimeNonAction = 0.0f;
			m_dwNonActionMagicID = 0;
			m_iNonActionMagicTarget = -1;

			//m_fRecastTimeNonAction = (float)(pSkill->iReCastTime) / 10.0f;

		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
			m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
		}
	}
//	if(s_pPlayer->State()==PSA_SPELLMAGIC) 
}

void CMagicSkillMng::UpdateZonePointerPositions()
{
	// Update all FX positions
	for (int j = 0; j < 8; j++)
	{
		const float fRadians = m_fZonePointerRotRad + (DegreesToRadians(45.0f) * j);

		__Vector3 vNewPos = m_pGameProcMain->m_vMouseSkillPos;
		vNewPos.y = CGameBase::ACT_WORLD->GetHeightWithTerrain(vNewPos.x, vNewPos.z);

		vNewPos.x += cosf(fRadians) * m_fZonePointerRadiusEffective;
		vNewPos.z += sinf(fRadians) * m_fZonePointerRadiusEffective;

		// Update FX position using the index
		CGameProcedure::s_pFX->SetBundlePos(
			FXID_ZONE_POINTER,
			FXID_ZONE_POINTER + j,	// Index
			vNewPos);
	}
}

// When cancelling the skill or changing modes
void CMagicSkillMng::CancelZonePointer()
{
	for (int j = 0; j < 8; j++)
	{
		CGameProcedure::s_pFX->Stop(
			s_pPlayer->IDNumber(),
			0,
			FXID_ZONE_POINTER,
			FXID_ZONE_POINTER + j,
			true);
	}

	m_fZonePointerRadius = -1.0f;
	m_fZonePointerRadiusEffective = 0.0f;
	m_fZonePointerRotRad = 0.0f;
}

void CMagicSkillMng::SuccessCast(__TABLE_UPC_SKILL* pSkill, CPlayerBase* pTarget)
{
	s_pPlayer->m_dwMagicID = 0xffffffff;
	s_pPlayer->m_fCastingTime = 0.0f;

	uint8_t byBuff[32];
	int iOffset=0;
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);

	int idx = 0;
	if(pSkill->iFlyingFX==0) 
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
	else
	{
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FLYING);
		if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)//화살쏘기..
		{
			int iNumArrow = 1;
			__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
			if(pType2 != nullptr) iNumArrow = pType2->iNumArrow;

			idx = AddIdx(pSkill->dwID, iNumArrow);
		}
		else idx = AddIdx(pSkill->dwID);				
	}

	if(pSkill->dw1stTableType==1 || pSkill->dw2ndTableType==1)
	{		
		//바로 skill로 들어가..^^
		//casting packet은 보내지 않고..바로 effect packet을 보낸다..

		//기술 애니메이션 드가...=^^=
		//효과있으면 같이 드가..
		__TABLE_UPC_SKILL_TYPE_1* pType1 = m_pTbl_Type_1->Find(pSkill->dwID);
		if(pType1 == nullptr) return;

		s_pPlayer->RotateTo(pTarget);

		for(int i=0;i<pType1->iNumCombo;i++)
		{
			bool bImmediately = ((0 == i) ? true : false); // 처음건 바로 넣는다..
			s_pPlayer->AnimationAdd((const e_Ani)pType1->iAct[i], bImmediately);				
		}			
		
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
		m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);

		uint8_t byBuff[32];
		int iOffset = 0;
		//CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
		//CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
		CAPISocket::MP_AddDword(byBuff, iOffset, (int) pSkill->dwID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_pPlayer->IDNumber());
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_iTarget);

		CAPISocket::MP_AddShort(byBuff, iOffset, 1);
		CAPISocket::MP_AddShort(byBuff, iOffset, 1);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);

		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);

		CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..				
		SetSkillCooldown(pSkill);
	}
	else
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_USE, pSkill->szName);
		m_pGameProcMain->MsgOutput(szMsg, 0xffffff00);
		//m_fRecastTime = (float) pSkill->iReCastTime / 10.0f;
		m_fDelay = 0.3f;

		CAPISocket::MP_AddDword(byBuff, iOffset, (int) pSkill->dwID);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) s_pPlayer->IDNumber());
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_iTarget);

		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_vTargetPos.x);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_vTargetPos.y);
		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) m_vTargetPos.z);

		CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) idx);//flying이라면 idx...
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);
		CAPISocket::MP_AddShort(byBuff, iOffset, 0);

		CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
		SetSkillCooldown(pSkill);

		if (pSkill->iFlyingFX != 0)
		{
			////////////////////////////////////////////////////
			//flying처리하기..	
			int SourceID = s_pPlayer->IDNumber();

			s_pPlayer->m_iMagicAni = pSkill->iSelfAnimID2;
			if(pSkill->dw1stTableType == 2 || pSkill->dw2ndTableType == 2)
			{
				m_fDelay = 0.1f;
				int LeftItem = s_pPlayer->ItemClass_LeftHand();
				int RightItem = s_pPlayer->ItemClass_RightHand();
				if (RightItem == ITEM_CLASS_BOW_CROSS || LeftItem == ITEM_CLASS_BOW_CROSS)
				{
					s_pPlayer->m_iMagicAni = ANI_SHOOT_QUARREL_B;
				}
			}
			s_pPlayer->m_fCastFreezeTime = 0.0f;
			s_pPlayer->Action(PSA_SPELLMAGIC, false);
			//s_pPlayer->Action(PSA_BASIC, false);

			CGameProcedure::s_pFX->Stop(SourceID, SourceID, pSkill->iSelfFX1, -1, true);
			CGameProcedure::s_pFX->Stop(SourceID, SourceID, pSkill->iSelfFX1, -2, true);

			if(pSkill->dw1stTableType == 2 || pSkill->dw2ndTableType == 2)//화살쏘기..
			{
				int16_t Data[6] = { (int16_t)m_vTargetPos.x, (int16_t)m_vTargetPos.y, (int16_t)m_vTargetPos.z, (int16_t)idx, 0, 0 };
				FlyingType2(pSkill, SourceID, m_iTarget, Data);
				return;
			}

			CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(m_iTarget, false);
			int spart1 = pSkill->iSelfPart1 % 1000;
			if(pTarget == nullptr)
			{
				__Vector3 vTargetPos = s_pPlayer->Position() + s_pPlayer->Direction();
				CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iFlyingFX, m_vTargetPos,
															idx, FX_BUNDLE_MOVE_DIR_FIXEDTARGET);
			}
			else
			{
				CGameProcedure::s_pFX->TriggerBundle(SourceID, spart1, pSkill->iFlyingFX, m_iTarget,
												0, idx, FX_BUNDLE_MOVE_DIR_FLEXABLETARGET);
			}
			//
			////////////////////////////////////////////////////
		}
		else
		{
			if(pSkill->iSelfAnimID2>=0)
			{
				s_pPlayer->m_iMagicAni = pSkill->iSelfAnimID2;
				s_pPlayer->m_fCastFreezeTime = 0.0f;
				s_pPlayer->Action(PSA_SPELLMAGIC, false);
				//s_pPlayer->Action(PSA_BASIC, false);				
			}
		}

		if(pSkill->iSelfFX2>0)
			CGameProcedure::s_pFX->TriggerBundle(s_pPlayer->IDNumber(), pSkill->iSelfPart2, pSkill->iSelfFX2, s_pPlayer->IDNumber(), pSkill->iSelfPart2, -3);
	}
}

void CMagicSkillMng::FailCast(__TABLE_UPC_SKILL* pSkill)
{
	s_pPlayer->m_dwMagicID = 0xffffffff;
	s_pPlayer->m_fCastingTime = 0.0f;

	uint8_t byBuff[32];
	int iOffset=0;
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
	CAPISocket::MP_AddDword(byBuff, iOffset, (int)pSkill->dwID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDNumber());
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDNumber());

	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_CASTING);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	
}

void CMagicSkillMng::ProcessCasting()
{
	//캐스팅 처리..
	if(s_pPlayer->m_dwMagicID != 0xffffffff)
	{
		__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(s_pPlayer->m_dwMagicID);

		CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(m_iTarget, true);
		if(pTarget != nullptr) s_pPlayer->RotateTo(pTarget); // 일단 타겟을 향해 방향을 돌린다..

		//캐스팅 성공적으로 완료...
		float fCastingTime = ((float)pSkill->iCastTime) / 10.0f * s_pPlayer->m_fAttackDelta;

		if(pSkill != nullptr)
		{
			bool bSuccess = false;
			if( s_pPlayer->m_fCastingTime >= fCastingTime && s_pPlayer->State()==PSA_SPELLMAGIC && s_pPlayer->StateMove()==PSM_STOP)
			{
				SuccessCast(pSkill, pTarget);
				bSuccess = true;
			}
			
			//캐스팅 실패...
			if(bSuccess == false && (s_pPlayer->State()!=PSA_SPELLMAGIC || s_pPlayer->StateMove()!=PSM_STOP))
				FailCast(pSkill);
		}
		else s_pPlayer->m_dwMagicID = 0xffffffff;
	}	
}

void CMagicSkillMng::MobCasting(__TABLE_UPC_SKILL* pSkill, int iSourceID)
{
	if(pSkill == nullptr) return;

	//캐스팅 성공적으로 완료...
	uint8_t byBuff[32];
	int iOffset=0;
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);

	int idx = 0;
	if(pSkill->iFlyingFX==0) 
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
	else
	{
		CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FLYING);
		if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)//화살쏘기..
		{
			int iNumArrow = 1;
			__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
			if(pType2 != nullptr) iNumArrow = pType2->iNumArrow;

			idx = AddIdx(pSkill->dwID, iNumArrow);
		}
		else idx = AddIdx(pSkill->dwID);
	}

	CAPISocket::MP_AddDword(byBuff, iOffset, (int)pSkill->dwID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iSourceID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDNumber());

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_vTargetPos.x);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_vTargetPos.y);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_vTargetPos.z);

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)idx);//flying이라면 idx...
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);
	CAPISocket::MP_AddShort(byBuff, iOffset, 0);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
}


void CMagicSkillMng::MsgRecv_Casting(Packet& pkt)
{
	////common.....//////////////////////////////////////////////////////////////
	//	
	uint32_t dwMagicID = pkt.read<uint32_t>();
	int	iSourceID = pkt.read<int16_t>();
	int	iTargetID = pkt.read<int16_t>();

	int16_t Data[6];
	for(int i=0;i<6;i++)
	{
		Data[i] = pkt.read<int16_t>();
	}

	//if(iSourceID<0) return;
	if(iSourceID<0 || iSourceID==s_pPlayer->IDNumber()) return;
	//	
	////common.....//////////////////////////////////////////////////////////////
	
	__Vector3	vTargetPos;
	if(iTargetID == -1) vTargetPos.Set((float)Data[0], (float)Data[1], (float)Data[2]);
	
	CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, true);
	if(pPlayer == nullptr) return;

	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	if(pSkill == nullptr) return;

	//내가 쓸때...
	if(iSourceID==s_pPlayer->IDNumber())
	{
		m_pGameProcMain->CommandSitDown(false, false); // 혹시라도 앉아있음 일으켜 세운다..
		
		s_pPlayer->m_dwMagicID = dwMagicID;
		s_pPlayer->m_fCastingTime = 0.0f;
		m_iTarget = iTargetID;
		m_vTargetPos = vTargetPos;
	}
	
	//몬스터가 나를 향해 쏠때...
	if( s_pOPMgr->NPCGetByID(iSourceID, true) )
	{
		pPlayer->RotateTo((CPlayerBase*)s_pPlayer); // 이넘을 바라본다.
		pPlayer->m_iIDTarget = iTargetID;
		pPlayer->ActionMove(PSM_STOP);
		pPlayer->m_iMagicAni = pSkill->iSelfAnimID1;
		pPlayer->Action(PSA_ATTACK, false, (CPlayerBase*)s_pPlayer);

		if(iTargetID==s_pPlayer->IDNumber()) 
			MobCasting(pSkill, iSourceID);
		return;
	}

	CPlayerBase* pTargetPlayer = m_pGameProcMain->CharacterGetByID(iTargetID, false);
		
	int spart1 = pSkill->iSelfPart1 % 1000;
	int spart2 = pSkill->iSelfPart1 / 1000;
	spart2 = abs(spart2);

	CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iSelfFX1, iSourceID, spart1, -1);
	if(spart2!=0) CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart2, pSkill->iSelfFX1, iSourceID, spart2, -2);

	pPlayer->m_iIDTarget = iTargetID;			

	pPlayer->ActionMove(PSM_STOP);
	pPlayer->m_iMagicAni = pSkill->iSelfAnimID1;
	if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
	{
		int LeftItem = pPlayer->ItemClass_LeftHand();
		int RightItem = pPlayer->ItemClass_RightHand();
		if(RightItem == ITEM_CLASS_BOW_CROSS || LeftItem==ITEM_CLASS_BOW_CROSS)
		{
			pPlayer->m_iMagicAni = ANI_SHOOT_QUARREL_A;
		}
	}
	pPlayer->m_fCastFreezeTime = 10.0f;
	pPlayer->Action(PSA_SPELLMAGIC, false, pTargetPlayer);

	//CLogWriter::Write("send casting : {:.4f}", CN3Base::TimeGet());
	//TRACE("recv casting : %.4f\n", CN3Base::TimeGet());

	if(pSkill->iTarget == SKILLMAGIC_TARGET_ENEMY_ONLY) m_pGameProcMain->PlayBGM_Battle();
}

void CMagicSkillMng::MsgRecv_Flying(Packet& pkt)
{
	////common.....//////////////////////////////////////////////////////////////
	//	
	uint32_t dwMagicID = pkt.read<uint32_t>();
	int	iSourceID = pkt.read<int16_t>();
	int	iTargetID = pkt.read<int16_t>();

	int16_t Data[6];
	for(int i=0;i<6;i++)
	{
		Data[i] = pkt.read<int16_t>();
	}

	//if(iSourceID<0) return;
	if(iSourceID<0 || iSourceID==s_pPlayer->IDNumber()) return;

	CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, true);
	if(pPlayer == nullptr) return;

	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	if(pSkill == nullptr) return;
	//
	////common.....//////////////////////////////////////////////////////////////

	//TRACE("recv flying : %.4f\n", CN3Base::TimeGet());

	if(pPlayer != nullptr && pPlayer->State()==PSA_SPELLMAGIC)
	{
		pPlayer->m_iMagicAni = pSkill->iSelfAnimID2;
		if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
		{
			int LeftItem = pPlayer->ItemClass_LeftHand();
			int RightItem = pPlayer->ItemClass_RightHand();
			if(RightItem == ITEM_CLASS_BOW_CROSS || LeftItem==ITEM_CLASS_BOW_CROSS)
			{
				pPlayer->m_iMagicAni = ANI_SHOOT_QUARREL_B;
			}
		}
		pPlayer->m_fCastFreezeTime = 0.0f;
		pPlayer->Action(PSA_SPELLMAGIC, false);
	}

	CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
	CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);

	if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)//화살쏘기..
	{
		FlyingType2(pSkill, iSourceID, iTargetID, Data);
		return;
	}

	CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);

	int spart1 = pSkill->iSelfPart1 % 1000;
	
	if(pTarget == nullptr)
	{
		if(pPlayer != nullptr)
		{
			__Vector3 vTargetPos = pPlayer->Position() + pPlayer->Direction();
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos,
													Data[3], FX_BUNDLE_MOVE_DIR_FIXEDTARGET);
		}
	}
	else
	{
		CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, iTargetID,
										0/*pSkill->iTargetPart*/, Data[3], FX_BUNDLE_MOVE_DIR_FLEXABLETARGET);
	}
}

void CMagicSkillMng::MsgRecv_Effecting(Packet& pkt)
{
	////common.....//////////////////////////////////////////////////////////////
	//
	uint32_t dwMagicID = pkt.read<uint32_t>();
	int	iSourceID = pkt.read<int16_t>();
	int	iTargetID = pkt.read<int16_t>();

	int16_t Data[6];
	for(int i=0;i<6;i++)
	{
		Data[i] = pkt.read<int16_t>();
	}

	CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, false);
	if(pPlayer == nullptr) return;

	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	if(pSkill == nullptr) return;
	//
	////common.....//////////////////////////////////////////////////////////////
		
	if(pPlayer != nullptr && iSourceID!=s_pPlayer->IDNumber() && pPlayer->State()==PSA_SPELLMAGIC)
	{
		pPlayer->m_iMagicAni = pSkill->iSelfAnimID2;	//화살놓는 동작...
		pPlayer->m_fCastFreezeTime = 0.0f;
		pPlayer->Action(PSA_SPELLMAGIC, false);
	}

	CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
	CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);

	if(pSkill->dw1stTableType==1 || pSkill->dw2ndTableType==1)	//	타입1인경우 걍 스킬이야..콤보도 껴있어..좀 특별하게 관리해야돼..
	{
		if(!EffectingType1(dwMagicID, iSourceID, iTargetID, Data)) return;
	}

	if(pSkill->dw1stTableType==4 || pSkill->dw2ndTableType==4)
	{
		if(iTargetID==s_pPlayer->IDNumber()) EffectingType4(dwMagicID);
	}

	if(pSkill->dw1stTableType==3 || pSkill->dw2ndTableType==3)
	{
		if(iTargetID==s_pPlayer->IDNumber()) EffectingType3(dwMagicID);
	}

	if(pSkill->iFlyingFX!=0 && 
		(pSkill->iTarget < SKILLMAGIC_TARGET_AREA_ENEMY || pSkill->iTarget > SKILLMAGIC_TARGET_AREA) ) return;	//플라잉이 있는 마법의 경우는 효과를 fail에서 처리한다..
	
	if(iTargetID==-1)
	{
		__Vector3 vTargetPos(Data[0],Data[1],Data[2]);
		CGameProcedure::s_pFX->TriggerBundle(iSourceID, 0, pSkill->iTargetFX, vTargetPos);
	}
	else
		CGameProcedure::s_pFX->TriggerBundle(iSourceID, 0, pSkill->iTargetFX, iTargetID, pSkill->iTargetPart);
}

void CMagicSkillMng::MsgRecv_Fail(Packet& pkt)
{
	////common.....//////////////////////////////////////////////////////////////
	//
	uint32_t dwMagicID = pkt.read<uint32_t>();
	int	iSourceID = pkt.read<int16_t>();
	int	iTargetID = pkt.read<int16_t>();

	int16_t Data[6];
	for(int i=0;i<6;i++)
	{
		Data[i] = pkt.read<int16_t>();
	}
	CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, false);
	if(pPlayer == nullptr) return;

	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	if(pSkill == nullptr) return;
	//
	////common.....//////////////////////////////////////////////////////////////
		
	if(pPlayer != nullptr && iSourceID != s_pPlayer->IDNumber() && pPlayer->State()==PSA_SPELLMAGIC)
	{
		pPlayer->m_iMagicAni = pSkill->iSelfAnimID2;
		pPlayer->m_fCastFreezeTime = 0.0f;
		pPlayer->Action(PSA_SPELLMAGIC, false);

		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);
	}

	if(Data[3]==SKILLMAGIC_FAIL_ATTACKZERO)
	{
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);
		
		if(iSourceID == s_pPlayer->IDNumber())
		{
			s_pPlayer->m_dwMagicID = 0xffffffff;
			m_pGameProcMain->CommandSitDown(false, false); 

			std::string szMsg = fmt::format_text_resource(IDS_MSG_FMT_TARGET_ATTACK_FAILED,
				pSkill->szName);
			m_pGameProcMain->MsgOutput(szMsg, 0xffff3b3b);			
		}
		return;
	}

	if(Data[3]==SKILLMAGIC_FAIL_NOEFFECT)
	{
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);
		
		if (pPlayer != nullptr)
			pPlayer->Action(PSA_BASIC, true);

		if(iSourceID == s_pPlayer->IDNumber())
		{
			s_pPlayer->m_dwMagicID = 0xffffffff;
			m_pGameProcMain->CommandSitDown(false, false); // 혹시라도 앉아있음 일으켜 세운다..

			std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_EFFECTING, pSkill->szName);
			m_pGameProcMain->MsgOutput(szMsg, 0xffff3b3b);			
		}
		return;
	}	

	if(Data[3]==SKILLMAGIC_FAIL_CASTING)//	캐스팅 실패인 것이다..
	{
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -1, true);
		CGameProcedure::s_pFX->Stop(iSourceID, iSourceID, pSkill->iSelfFX1, -2, true);
		
		if (pPlayer != nullptr)
			pPlayer->Action(PSA_BASIC, true);

		if(iSourceID == s_pPlayer->IDNumber())
		{
			s_pPlayer->m_dwMagicID = 0xffffffff;
			m_pGameProcMain->CommandSitDown(false, false); // 혹시라도 앉아있음 일으켜 세운다..

			std::string szMsg = fmt::format_text_resource(IDS_SKILL_FAIL_CASTING);
			m_pGameProcMain->MsgOutput(szMsg, 0xffff3b3b);
		}
		return;
	}

	if(Data[3]==SKILLMAGIC_FAIL_KILLFLYING)//flying효과 죽이고..그자리에 타겟효과 해라..	
	{
		if(iSourceID == s_pPlayer->IDNumber() ||
			((iTargetID==s_pPlayer->IDNumber() && s_pOPMgr->NPCGetByID(iSourceID, false)!= nullptr)))
		{
			RemoveIdx(Data[4]);
		}
		else CGameProcedure::s_pFX->Stop(iSourceID, iTargetID, pSkill->iFlyingFX, Data[4]);

		if(iTargetID==s_pPlayer->IDNumber())
		{
			if(pSkill->dw1stTableType==2 || pSkill->dw2ndTableType==2)
			{
				StopCastingByRatio();
			}
			else if(pSkill->dw1stTableType==3 || pSkill->dw2ndTableType==3)
			{
				__TABLE_UPC_SKILL_TYPE_3* pType3 = m_pTbl_Type_3->Find(dwMagicID);

				if(pType3->iAttribute==3)
				{
					StopCastingByRatio();
					StunMySelf(pType3);
				}
			}
		}

		CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);
		if(pTarget != nullptr)
		{
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, pSkill->iTargetPart, pSkill->iTargetFX, iTargetID, pSkill->iTargetPart);
			
		}
		else
		{
			__Vector3 TargetPos(Data[0], Data[1], Data[2]);
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, 0, pSkill->iTargetFX, TargetPos);
		}		
		return;
	}

	//그외 stop이 필요한게 있을꺼야..
	//그땐...
	//CGameProcedure::s_pFX->Stop(iSourceID, iTargetID, pSkill->iSelfFX, 0);
}


//type4 해제..
void CMagicSkillMng::MsgRecv_BuffType(Packet& pkt)
{
	int iBuffType = pkt.read<uint8_t>();
	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);

	std::multimap<int, uint32_t>::iterator it = m_ListBuffTypeID.find(iBuffType);
	if(it!= m_ListBuffTypeID.end())
	{
		__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(it->second);
		m_pGameProcMain->m_pUIStateBarAndMiniMap->DelMagic(pSkill);
		m_ListBuffTypeID.erase(it);
	}

	switch(iBuffType)
	{
	case BUFFTYPE_MAXHP:
		if(pInfoBase->iHP < pInfoBase->iHPMax)
		{
			pInfoBase->iHPMax -= m_iMaxHP;
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax);
		}
		m_iMaxHP = 0;
		break;
	case BUFFTYPE_AC:
		pInfoExt->iGuard_Delta -= m_iAC;
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateGuardPoint(pInfoExt->iGuard, pInfoExt->iGuard_Delta);
		m_iAC = 0;
		break;
	case BUFFTYPE_ATTACK:
		if(m_iAttack) pInfoExt->iAttack_Delta -= m_iAttack;
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateAttackPoint(pInfoExt->iAttack, pInfoExt->iAttack_Delta);
		m_iAttack = 0;
		break;
	case BUFFTYPE_ATTACKSPEED:
		s_pPlayer->m_fAttackDelta /= m_fAttackSpeed; 
		m_fAttackSpeed = 1.0f;
		break;
	case BUFFTYPE_SPEED:
		s_pPlayer->m_fMoveDelta /= m_fSpeed;
		m_fSpeed = 1.0f;
		//TRACE("스프린트 해제. MoveDelta = %f\n", s_pPlayer->m_fMoveDelta);
		break;
	case BUFFTYPE_ABILITY:
		pInfoExt->iStrength_Delta -= m_iStr;
		pInfoExt->iStamina_Delta -= m_iSta;
		pInfoExt->iDexterity_Delta -= m_iDex;
		pInfoExt->iIntelligence_Delta -= m_iInt;
		pInfoExt->iMagicAttak_Delta -= m_iMAP;

		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStrength(pInfoExt->iStrength, pInfoExt->iStrength_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStamina(pInfoExt->iStamina, pInfoExt->iStamina_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateDexterity(pInfoExt->iDexterity, pInfoExt->iDexterity_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateIntelligence(pInfoExt->iIntelligence, pInfoExt->iIntelligence_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateMagicAttak(pInfoExt->iMagicAttak, pInfoExt->iMagicAttak_Delta);

		m_iStr = 0;
		m_iSta = 0;
		m_iDex = 0;
		m_iInt = 0;
		m_iMAP = 0;
		break;
	case BUFFTYPE_RESIST:
		pInfoExt->iRegistFire_Delta -= m_iFireR;
		pInfoExt->iRegistCold_Delta -= m_iColdR;
		pInfoExt->iRegistLight_Delta -= m_iLightningR;
		pInfoExt->iRegistMagic_Delta -= m_iMagicR;
		pInfoExt->iRegistCurse_Delta -= m_iDeseaseR;
		pInfoExt->iRegistPoison_Delta -= m_iPoisonR;

		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistFire(pInfoExt->iRegistFire, pInfoExt->iRegistFire_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCold(pInfoExt->iRegistCold, pInfoExt->iRegistCold_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistLight(pInfoExt->iRegistLight, pInfoExt->iRegistLight_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistMagic(pInfoExt->iRegistMagic, pInfoExt->iRegistMagic_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCurse(pInfoExt->iRegistCurse, pInfoExt->iRegistCurse_Delta);
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistPoison(pInfoExt->iRegistPoison, pInfoExt->iRegistPoison_Delta);

		m_iFireR = 0;
		m_iColdR = 0;
		m_iLightningR = 0;
		m_iMagicR = 0;
		m_iDeseaseR = 0;
		m_iPoisonR = 0;
		break;
	}
}


//
//
//
void CMagicSkillMng::FlyingType2(__TABLE_UPC_SKILL* pSkill, int iSourceID, int iTargetID, int16_t* pData)
{
	CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, true);
	if(pPlayer == nullptr) return;
	__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
	if(pType2 == nullptr) return;

	int LeftItem = pPlayer->ItemClass_LeftHand()/10;
	int RightItem = pPlayer->ItemClass_RightHand()/10;

	if(LeftItem == (ITEM_CLASS_BOW/10))//활이닷..
	{
		CN3Base::s_SndMgr.PlayOnceAndRelease(ID_SOUND_SKILL_THROW_ARROW, &(pPlayer->Position()));
	}
	else if(RightItem == (ITEM_CLASS_JAVELIN/10))//투창이닷...pla
	{
	}
	
	int spart1 = pSkill->iSelfPart1 % 1000;

	__Vector3 vTargetPos(0,0,0);

	CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);
	if(pTarget == nullptr)
	{
		vTargetPos = pPlayer->Position() + pPlayer->Direction();
		CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos+pPlayer->Position(), pData[3], pType2->iSuccessType);
		
		int NumArrow = (pType2->iNumArrow - 1) >>1;
		int idx = pData[3];
		
		__Vector3 vTargetPos2 = vTargetPos - pPlayer->Position();
		__Vector3 vTargetPos3;
		__Matrix44 mtx;
		for(int i=1;i<=NumArrow;i++)
		{
			float fAng = (__PI * (float)i) / 12.0f;	// 15도 씩 나눠서...
				
			mtx.Identity();
			mtx.RotationY(-fAng);
			vTargetPos3 = vTargetPos2*mtx;
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, pType2->iSuccessType);

			mtx.Identity();
			mtx.RotationY(fAng);
			vTargetPos3 = vTargetPos2*mtx;
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, pType2->iSuccessType);
		}
	}
	else
	{
		vTargetPos = pTarget->Center();

		if(pType2->iSuccessType == FX_BUNDLE_MOVE_DIR_FIXEDTARGET)
		{
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos, pData[3], FX_BUNDLE_MOVE_DIR_FIXEDTARGET);
					
			int NumArrow = (pType2->iNumArrow - 1) >>1;

			int idx = pData[3];

			__Vector3 vTargetPos2 = vTargetPos - pPlayer->Position();
			__Vector3 vTargetPos3;
			__Matrix44 mtx;
			for(int i=1;i<=NumArrow;i++)
			{
				float fAng = (__PI * (float)i) / 12.0f;	// 15도 씩 나눠서...
					
				mtx.Identity();
				mtx.RotationY(-fAng);
				vTargetPos3 = vTargetPos2*mtx;
				CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, FX_BUNDLE_MOVE_DIR_FIXEDTARGET);
				
				mtx.Identity();
				mtx.RotationY(fAng);
				vTargetPos3 = vTargetPos2*mtx;
				CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, FX_BUNDLE_MOVE_DIR_FIXEDTARGET);
			}
		}

		else 
		{
			CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, iTargetID, pSkill->iTargetPart, pData[3], pType2->iSuccessType);
					
			int NumArrow = (pType2->iNumArrow - 1) >>1;

			int idx = pData[3];

			__Vector3 vTargetPos2 = vTargetPos - pPlayer->Position();
			__Vector3 vTargetPos3;
			__Matrix44 mtx;
			for(int i=1;i<=NumArrow;i++)
			{
				float fAng = (__PI * (float)i) / 12.0f;	// 15도 씩 나눠서...
					
				mtx.Identity();
				mtx.RotationY(-fAng);
				vTargetPos3 = vTargetPos2*mtx;
				CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, pType2->iSuccessType);


				mtx.Identity();
				mtx.RotationY(fAng);
				vTargetPos3 = vTargetPos2*mtx;
				CGameProcedure::s_pFX->TriggerBundle(iSourceID, spart1, pSkill->iFlyingFX, vTargetPos3+pPlayer->Position(), idx++, pType2->iSuccessType);
			}
		}
	}

	//__TABLE_UPC_SKILL_TYPE_2* pType2 = m_pTbl_Type_2->Find(pSkill->dwID);
	//if(pType2 != nullptr)	CGameProcedure::s_pFX->Trigger(iSourceID, spart1, pSkill->iFlyingFX, iTargetID, 	pSkill->iTargetPart, pData[3], pType2->iSuccessType);
}


//
//
//

bool CMagicSkillMng::EffectingType1(uint32_t dwMagicID, int iSourceID, int iTargetID, int16_t* pData)
{
	CPlayerBase* pTarget = m_pGameProcMain->CharacterGetByID(iTargetID, false);
	if(pTarget != nullptr)
	{
		if(iSourceID != s_pPlayer->IDNumber()) // 내가 스킬을 쓸때..
		{
			__TABLE_UPC_SKILL_TYPE_1* pType1 = m_pTbl_Type_1->Find(dwMagicID);
			if(pType1 != nullptr)
			{
				CPlayerBase* pPlayer = m_pGameProcMain->CharacterGetByID(iSourceID, true);
				__ASSERT(pPlayer, "NULL Player Pointer!!");
				if(pPlayer != nullptr)
				{
					// 검기 색을 바꾸어 준다..
//					__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
//					D3DCOLOR crTrace = TraceColorGet(pSkill); // 스킬의 종류에 따라 검기의 색을 정한다..
//					pPlayer->PlugTraceColorRemake(crTrace); // 검기 색 적용..

					pPlayer->RotateTo(pTarget);

					// TODO: Update this. It's intended to apply based on the equipped weapon type,
					// and rather than manually queue, this behaviour will be passed through Action().
					e_Ani eAni = (e_Ani) pType1->iAct[0];
					pPlayer->Action(PSA_SPELLMAGIC, false, pTarget, false);
					pPlayer->AnimationAdd(eAni, true);
				}
			}
		}
	}
	return true;
}

void CMagicSkillMng::EffectingType3(uint32_t dwMagicID)
{
	__TABLE_UPC_SKILL_TYPE_3* pType3 = m_pTbl_Type_3->Find(dwMagicID);
	__ASSERT(pType3, "NULL type3 Pointer!!");
	if(pType3 == nullptr) return;

	StunMySelf(pType3);

	int key = 0;
	if(pType3->iStartDamage>0 || (pType3->iStartDamage==0 && pType3->iDuraDamage>0) ) key = DDTYPE_TYPE3_DUR_OUR;
	else key = DDTYPE_TYPE3_DUR_ENEMY;

	if(key==DDTYPE_TYPE3_DUR_ENEMY && pType3->iAttribute==3) StopCastingByRatio();

	if(pType3->iDurationTime==0) return;
		
	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	m_pGameProcMain->m_pUIStateBarAndMiniMap->AddMagic(pSkill, (float)pType3->iDurationTime);
	m_ListBuffTypeID.insert(stlmultimapVAL_INT_DWORD(key, dwMagicID));
}

//
//
//
void CMagicSkillMng::EffectingType4(uint32_t dwMagicID)
{
	__TABLE_UPC_SKILL_TYPE_4* pType4 = m_pTbl_Type_4->Find(dwMagicID);
	__ASSERT(pType4, "NULL type4 Pointer!!");
	if(pType4 == nullptr) return;

	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);

	std::multimap<int, uint32_t>::iterator it = m_ListBuffTypeID.find(pType4->iBuffType);
	if(it!= m_ListBuffTypeID.end())
	{
		__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(it->second);
		m_pGameProcMain->m_pUIStateBarAndMiniMap->DelMagic(pSkill);
		m_ListBuffTypeID.erase(it);
	}

	__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(dwMagicID);
	m_pGameProcMain->m_pUIStateBarAndMiniMap->AddMagic(pSkill, (float)pType4->iDuration);
	m_ListBuffTypeID.insert(stlmultimapVAL_INT_DWORD(pType4->iBuffType,dwMagicID));

	//같은 버프타입의 마법은 중복사용할 수 없다...먼저 사용된 것만 유효..
	if(pType4 != nullptr)
	{
		switch(pType4->iBuffType)
		{
		case BUFFTYPE_MAXHP:
			pInfoBase->iHPMax -= m_iMaxHP;
									
			m_iMaxHP = pType4->iMaxHP;
			pInfoBase->iHPMax += m_iMaxHP;
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateHP(pInfoBase->iHP,
																pInfoBase->iHPMax);
			break;
		case BUFFTYPE_AC:
			pInfoExt->iGuard_Delta -= m_iAC;

			m_iAC = pType4->iAC;
			pInfoExt->iGuard_Delta += m_iAC;
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateGuardPoint(pInfoExt->iGuard, pInfoExt->iGuard_Delta);
			break;
		case BUFFTYPE_ATTACK:
			pInfoExt->iAttack_Delta -= m_iAttack;

			m_iAttack = (pInfoExt->iAttack * pType4->iAttack / 100) - pInfoExt->iAttack;
			pInfoExt->iAttack_Delta += m_iAttack;
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateAttackPoint(pInfoExt->iAttack, pInfoExt->iAttack_Delta);
			break;
		case BUFFTYPE_ATTACKSPEED:
			s_pPlayer->m_fAttackDelta /= m_fAttackSpeed; 

			m_fAttackSpeed = (float)pType4->iAttackSpeed / 100.0f;
			s_pPlayer->m_fAttackDelta *= m_fAttackSpeed; 
			break;
		case BUFFTYPE_SPEED:
			s_pPlayer->m_fMoveDelta /= m_fSpeed;

			m_fSpeed = (float)pType4->iMoveSpeed / 100.0f;
			s_pPlayer->m_fMoveDelta *= m_fSpeed; 
			break;
		case BUFFTYPE_ABILITY:
			pInfoExt->iStrength_Delta -= m_iStr;
			pInfoExt->iStamina_Delta -= m_iSta;
			pInfoExt->iDexterity_Delta -= m_iDex;
			pInfoExt->iIntelligence_Delta -= m_iInt;
			pInfoExt->iMagicAttak_Delta -= m_iMAP;

			m_iStr = pType4->iStr;
			m_iSta = pType4->iSta;
			m_iDex = pType4->iDex;
			m_iInt = pType4->iInt;
			m_iMAP = pType4->iMAP;
			pInfoExt->iStrength_Delta += m_iStr;
			pInfoExt->iStamina_Delta += m_iSta;
			pInfoExt->iDexterity_Delta += m_iDex;
			pInfoExt->iIntelligence_Delta += m_iInt;
			pInfoExt->iMagicAttak_Delta += m_iMAP;

			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStrength(pInfoExt->iStrength, pInfoExt->iStrength_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStamina(pInfoExt->iStamina, pInfoExt->iStamina_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateDexterity(pInfoExt->iDexterity, pInfoExt->iDexterity_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateIntelligence(pInfoExt->iIntelligence, pInfoExt->iIntelligence_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateMagicAttak(pInfoExt->iMagicAttak, pInfoExt->iMagicAttak_Delta);
			break;
		case BUFFTYPE_RESIST:
			pInfoExt->iRegistFire_Delta -= m_iFireR;
			pInfoExt->iRegistCold_Delta -= m_iColdR;
			pInfoExt->iRegistLight_Delta -= m_iLightningR;
			pInfoExt->iRegistMagic_Delta -= m_iMagicR;
			pInfoExt->iRegistCurse_Delta -= m_iDeseaseR;
			pInfoExt->iRegistPoison_Delta -= m_iPoisonR;

			m_iFireR = pType4->iFireResist;
			m_iColdR = pType4->iColdResist;
			m_iLightningR = pType4->iLightningResist;
			m_iMagicR = pType4->iMagicResist;
			m_iDeseaseR = pType4->iDeseaseResist;
			m_iPoisonR = pType4->iPoisonResist;

			pInfoExt->iRegistFire_Delta += m_iFireR;
			pInfoExt->iRegistCold_Delta += m_iColdR;
			pInfoExt->iRegistLight_Delta += m_iLightningR;
			pInfoExt->iRegistMagic_Delta += m_iMagicR;
			pInfoExt->iRegistCurse_Delta += m_iDeseaseR;
			pInfoExt->iRegistPoison_Delta += m_iPoisonR;

			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistFire(pInfoExt->iRegistFire, pInfoExt->iRegistFire_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCold(pInfoExt->iRegistCold, pInfoExt->iRegistCold_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistLight(pInfoExt->iRegistLight, pInfoExt->iRegistLight_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistMagic(pInfoExt->iRegistMagic, pInfoExt->iRegistMagic_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCurse(pInfoExt->iRegistCurse, pInfoExt->iRegistCurse_Delta);
			m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistPoison(pInfoExt->iRegistPoison, pInfoExt->iRegistPoison_Delta);
			break;
		}
	}
}


//
//	내가 쓰는 스킬이나 마법은 내가 인덱스를 넣어서 관리한다..
//	이건 인덱스 넣는 함수..
//
int CMagicSkillMng::AddIdx(uint32_t MagicID, int iNum)
{
	int idx = 0;
	std::map<int, uint32_t>::iterator it;
	
	//연결되는 index를 여러개 한꺼번에 만드는 경우..
	if(iNum>1)
	{
		if(m_MySelf.size()!=0)
		{
			it = m_MySelf.end();
			it--;
			idx = it->first + 1;
		}
		else idx = 1;						

		for(int i=0;i<iNum;i++)
		{
			m_MySelf.insert(stlmapVAL_INT_DWORD(idx+i, MagicID));
		}
		return idx;
	}

	//그냥 하나의 인덱스만 만드는 경우..
	for(it = m_MySelf.begin(); it!=m_MySelf.end(); it++)
	{
		if(it->first==idx)
		{
			idx++;
			continue;
		}
		else
		{
			m_MySelf.insert(stlmapVAL_INT_DWORD(idx, MagicID));
			break;
		}
	}
	if(it==m_MySelf.end())
	{
		m_MySelf.insert(stlmapVAL_INT_DWORD(idx, MagicID));
	}

	return idx;
}


//
//
//
void CMagicSkillMng::InitType4()
{
	m_iBuffType = 0;
	
	m_fAttackSpeed = 1.0f;
	m_fSpeed = 1.0f;

	m_iAC = 0;
	m_iAttack = 0;
	m_iMaxHP = 0;
	m_iStr = 0;
	m_iSta = 0;
	m_iDex = 0;
	m_iInt = 0;
	m_iMAP = 0;
	m_iFireR = 0;
	m_iColdR = 0;
	m_iLightningR = 0;
	m_iMagicR = 0;
	m_iDeseaseR = 0;
	m_iPoisonR = 0;


	std::multimap<int, uint32_t>::iterator its, ite;
	its = m_ListBuffTypeID.begin();
	ite = m_ListBuffTypeID.end();

	for(;its != ite; its++)
	{
		__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find((*its).second);
		m_pGameProcMain->m_pUIStateBarAndMiniMap->DelMagic(pSkill);		
	}
	m_ListBuffTypeID.clear();
}


//
//	이건 인덱스 제거하는 함수..
//
void CMagicSkillMng::RemoveIdx(int idx)
{
	m_MySelf.erase(idx);
}

uint32_t CMagicSkillMng::GetMagicID(int idx)
{
	std::map<int, uint32_t>::iterator it = m_MySelf.find(idx);
	return it->second;
}

D3DCOLOR CMagicSkillMng::TraceColorGet(__TABLE_UPC_SKILL* pSkill) // 스킬의 종류에 따라 검기의 색을 정한다..
{
	if(pSkill == nullptr) return 0xff404040;
	
	D3DCOLOR crTrace = 0xffff4040;
	switch(pSkill->dwNeedItem) // 요구 아이템에 따라서...
	{
		case 1: crTrace = 0xff808080; // ITEM_CLASS_DAGGER = 11 // 단검(dagger)
		case 2: crTrace = 0xff909090; // ITEM_CLASS_SWORD = 21, // 한손검(onehandsword)
		//case : crTrace = ; // ITEM_CLASS_SWORD_2H = 22, // 3 : 양손검(twohandsword)
		case 3: crTrace = 0xff7070ff; // ITEM_CLASS_AXE = 31, // 한손도끼(onehandaxe)
		//case : crTrace = ; // ITEM_CLASS_AXE_2H = 32, // 두손도끼(twohandaxe)
		case 4: crTrace = 0xffa07070; // ITEM_CLASS_MACE = 41, // 한손타격무기(mace)
		//case : crTrace = ; // ITEM_CLASS_MACE_2H = 42, // 두손타격무기(twohandmace)
		case 5: crTrace = 0xffff7070; // ITEM_CLASS_SPEAR = 51, // 창(spear)
		//case : crTrace = ; // ITEM_CLASS_POLEARM = 52, // 폴암(polearm)
		default: crTrace = 0xff4040ff;
	}
	
	return crTrace;
}

bool CMagicSkillMng::IsPositiveMagic(uint32_t dwMagicID)
{
	__TABLE_UPC_SKILL* pSkill = CGameBase::s_pTbl_Skill.Find(dwMagicID);
	if(pSkill == nullptr) return true;

	if(pSkill->dw1stTableType==3 || pSkill->dw2ndTableType==3)
	{
		__TABLE_UPC_SKILL_TYPE_3* pType3 = m_pTbl_Type_3->Find(dwMagicID);
		if(pType3 == nullptr) return true;

		int key = 0;
		if(pType3->iStartDamage>0 || (pType3->iStartDamage==0 && pType3->iDuraDamage>0) ) key = DDTYPE_TYPE3_DUR_OUR;
		else key = DDTYPE_TYPE3_DUR_ENEMY;

		key += pType3->iDDType;
		if(key==DDTYPE_TYPE3_DUR_OUR) return true;
		return false;
	}
	if(pSkill->dw1stTableType==4 || pSkill->dw2ndTableType==4)
	{
		__TABLE_UPC_SKILL_TYPE_4* pType4 = m_pTbl_Type_4->Find(dwMagicID);
		if(pType4 == nullptr) return true;

		switch(pType4->iBuffType)
		{
		case BUFFTYPE_MAXHP:
			if(pType4->iMaxHP>0) return true;
			break;
		case BUFFTYPE_AC:
			if(pType4->iAC>0) return true;
			break;
		case BUFFTYPE_RESIZE:
			return true;
		case BUFFTYPE_ATTACK:
			if(pType4->iAttack>100) return true;
			break;
		case BUFFTYPE_ATTACKSPEED:
			if(pType4->iAttackSpeed>100) return true;
			break;
		case BUFFTYPE_SPEED:
			if(pType4->iMoveSpeed>100) return true;
			break;
		case BUFFTYPE_ABILITY:
			if(pType4->iStr>0 || pType4->iSta>0 || pType4->iDex>0 || pType4->iInt>0 || pType4->iMAP>0) return true;
			break;
		case BUFFTYPE_RESIST:
			if(pType4->iFireResist>0 || pType4->iColdResist>0 || pType4->iLightningResist>0 ||
				pType4->iMagicResist>0 || pType4->iDeseaseResist>0 || pType4->iPoisonResist>0) return true;
			break;
		}		
	}
	return false;
}

void CMagicSkillMng::ClearDurationalMagic()
{
	__InfoPlayerBase* pInfoBase = &(s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);

	if(pInfoBase->iHP < pInfoBase->iHPMax)
	{
		pInfoBase->iHPMax -= m_iMaxHP;
		m_pGameProcMain->m_pUIVar->m_pPageState->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax);
	}
	m_iMaxHP = 0;

	pInfoExt->iGuard_Delta -= m_iAC;
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateGuardPoint(pInfoExt->iGuard, pInfoExt->iGuard_Delta);
	m_iAC = 0;

	if(m_iAttack) pInfoExt->iAttack_Delta -= m_iAttack;
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateAttackPoint(pInfoExt->iAttack, pInfoExt->iAttack_Delta);
	m_iAttack = 0;
	
	s_pPlayer->m_fAttackDelta /= m_fAttackSpeed; 
	m_fAttackSpeed = 1.0f;
	
	s_pPlayer->m_fMoveDelta /= m_fSpeed;
	m_fSpeed = 1.0f;
	
	pInfoExt->iStrength_Delta -= m_iStr;
	pInfoExt->iStamina_Delta -= m_iSta;
	pInfoExt->iDexterity_Delta -= m_iDex;
	pInfoExt->iIntelligence_Delta -= m_iInt;
	pInfoExt->iMagicAttak_Delta -= m_iMAP;
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStrength(pInfoExt->iStrength, pInfoExt->iStrength_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateStamina(pInfoExt->iStamina, pInfoExt->iStamina_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateDexterity(pInfoExt->iDexterity, pInfoExt->iDexterity_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateIntelligence(pInfoExt->iIntelligence, pInfoExt->iIntelligence_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateMagicAttak(pInfoExt->iMagicAttak, pInfoExt->iMagicAttak_Delta);
	m_iStr = 0;
	m_iSta = 0;
	m_iDex = 0;
	m_iInt = 0;
	m_iMAP = 0;	
	
	pInfoExt->iRegistFire_Delta -= m_iFireR;
	pInfoExt->iRegistCold_Delta -= m_iColdR;
	pInfoExt->iRegistLight_Delta -= m_iLightningR;
	pInfoExt->iRegistMagic_Delta -= m_iMagicR;
	pInfoExt->iRegistCurse_Delta -= m_iDeseaseR;
	pInfoExt->iRegistPoison_Delta -= m_iPoisonR;
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistFire(pInfoExt->iRegistFire, pInfoExt->iRegistFire_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCold(pInfoExt->iRegistCold, pInfoExt->iRegistCold_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistLight(pInfoExt->iRegistLight, pInfoExt->iRegistLight_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistMagic(pInfoExt->iRegistMagic, pInfoExt->iRegistMagic_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistCurse(pInfoExt->iRegistCurse, pInfoExt->iRegistCurse_Delta);
	m_pGameProcMain->m_pUIVar->m_pPageState->UpdateRegistPoison(pInfoExt->iRegistPoison, pInfoExt->iRegistPoison_Delta);
	m_iFireR = 0;
	m_iColdR = 0;
	m_iLightningR = 0;
	m_iMagicR = 0;
	m_iDeseaseR = 0;
	m_iPoisonR = 0;

	InitType4();
}

void CMagicSkillMng::StopCastingByRatio()
{
	m_pGameProcMain->CommandSitDown(false, false); // 일으켜 세운다.
	if(IsCasting())
	{
		__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(s_pPlayer->m_dwMagicID);
		if(pSkill != nullptr)
		{
			int SuccessValue = rand()%100;
			if(SuccessValue >= pSkill->iPercentSuccess) // 스킬 테이블에 있는 확률대로 실패한다..
			{
				FailCast(pSkill);
				//if(	s_pPlayer->Action(PSA_BASIC, false, nullptr, true); // 캐스팅 취소, 기본동작으로 강제 세팅..
			}				
		}
	}
}

void CMagicSkillMng::StunMySelf(__TABLE_UPC_SKILL_TYPE_3* pType3)
{
	if(pType3->iAttribute!=3) return;

	int sample = rand()%101;

	__InfoPlayerMySelf* pInfoExt = &(s_pPlayer->m_InfoExt);

	float Regist = (float)(pInfoExt->iRegistLight + pInfoExt->iRegistLight_Delta);
	if(Regist>80.0f) Regist = 80.0f;

	float Prob = (30.0f+(40.0f-( 40.0f*(Regist/80.0f) )));

	if(sample < (int)Prob) //얼어라...
	{
		m_pGameProcMain->CommandSitDown(false, false); // 일으켜 세운다.
		s_pPlayer->Stun(STUN_TIME);
	}
}

float CMagicSkillMng::GetCooldown(const __TABLE_UPC_SKILL* pSkill) const
{
	if (pSkill->iSelfAnimID1 > 0)
	{
		auto it = m_RecastTimes.find(pSkill->dwID);
		if (it == m_RecastTimes.end())
			return -1;

		return it->second;
	}
	else
	{
		auto it = m_NonActionRecastTimes.find(pSkill->dwID);
		if (it == m_NonActionRecastTimes.end())
			return -1;

		return it->second;
	}
}

// ===== END WarFare/MagicSkillMng.cpp =====

// ===== BEGIN WarFare/MagicSkillMng.h =====
#line 1 "WarFare/MagicSkillMng.h"
﻿#pragma once

#include "GameDef.h"
#include "GameBase.h"
#include <map>

typedef std::map<int, uint32_t>::value_type stlmapVAL_INT_DWORD;
typedef std::multimap<int, uint32_t>::value_type stlmultimapVAL_INT_DWORD;


class CMagicSkillMng : public CGameBase
{
public:
	class CGameProcMain* m_pGameProcMain;
	
	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_1>*	m_pTbl_Type_1;
	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_2>*	m_pTbl_Type_2;
	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_3>*	m_pTbl_Type_3;
	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_4>*	m_pTbl_Type_4;
//	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_6>*	m_pTbl_Type_6;
	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_7>*	m_pTbl_Type_7;
//	CN3TableBase<struct __TABLE_UPC_SKILL_TYPE_9>*	m_pTbl_Type_9;

	std::map<int, uint32_t>	m_MySelf;

	int						m_iTarget;
	__Vector3				m_vTargetPos;

	//나를 타겟으로 잡은 몬스터처리 관련..
	std::map<int, uint32_t>	m_MobList;	//	int m_iMobID; uint32_t m_dwMobMagicID;
	
	//related type4.....
	std::multimap<int, uint32_t>	m_ListBuffTypeID;

	int						m_iBuffType;

	float					m_fAttackSpeed;
	float					m_fSpeed;

	int						m_iAC;
	int						m_iAttack;
	int						m_iMaxHP;
	int						m_iStr;
	int						m_iSta;
	int						m_iDex;
	int						m_iInt;
	int						m_iMAP; // Magic Attack Point

	int						m_iFireR;
	int						m_iColdR;
	int						m_iLightningR;
	int						m_iMagicR;
	int						m_iDeseaseR;
	int						m_iPoisonR;

	//recast time...
	//float					m_fRecastTime;
	float					m_fDelay;
		
	//related region magic...
	uint32_t				m_dwRegionMagicState;	//0:마침..1:지역선택중..2:지역선택했음.
	__TABLE_UPC_SKILL		m_dwRegionSkill;		//선택된 지역스킬..

	//related non-casting action magic...
	uint32_t				m_dwCastingStateNonAction;	//0:아무것도 없는 평온한 상태 1: 캐스팅중
	float					m_fCastTimeNonAction;
	uint32_t				m_dwNonActionMagicID;
	int						m_iNonActionMagicTarget;
	//float					m_fRecastTimeNonAction;

	//지역마법..
	int						m_iMyRegionTargetFXID;

private:
	std::map<uint32_t, float> m_RecastTimes;          // Casting skills
	std::map<uint32_t, float> m_NonActionRecastTimes; // Instant skills, don't think this is actually needed
#ifdef _DEBUG
	float m_fMsgUpdateTimer = 0.0f;
#endif
	float m_fZonePointerRotRad;
	float m_fZonePointerRadius;
	float m_fZonePointerRadiusEffective;

protected:
	bool	CheckValidCondition(int iTargetID, const __TABLE_UPC_SKILL* pSkill) const;
	bool	CheckValidDistance(const __TABLE_UPC_SKILL* pSkill, __Vector3 vTargetPos, float fTargetRadius) const;
	
	void	InitType4();

	void	StartSkillMagicAtTargetPacket(__TABLE_UPC_SKILL* pSkill, int16_t TargetID);
	void	StartSkillMagicAtPosPacket(__TABLE_UPC_SKILL* pSkill, __Vector3 vPos);
	
	void	ProcessCasting();

	void	MobCasting(__TABLE_UPC_SKILL* pSkill, int iSourceID);

	void	FlyingType2(__TABLE_UPC_SKILL* pSkill, int iSourceID, int iTargetID, int16_t* pData);

	void	EffectingType4(uint32_t dwMagicID);
	void	EffectingType3(uint32_t dwMagicID);
	bool	EffectingType1(uint32_t dwMagicID, int iSourceID, int iTargetID, int16_t* pData);

	int		AddIdx(uint32_t dwMagicID, int iNum=1);	//return value is index...
	void	RemoveIdx(int idx);

	void	SuccessCast(__TABLE_UPC_SKILL* pSkill, CPlayerBase* pTarget);
	void	FailCast(__TABLE_UPC_SKILL* pSkill);

	// returns true if the player is currently equipping the required item group
	bool	HasEquippedRequiredItemGroup(const __TABLE_UPC_SKILL* pSkill) const;

	// returns true if the player is currently equipping a weapon, if applicable
	bool	HasRequiredWeaponEquipped(const __TABLE_UPC_SKILL* pSkill) const;

	bool	HasRequiredMana(const __TABLE_UPC_SKILL* pSkill) const;
	bool	HasRequiredHealth(const __TABLE_UPC_SKILL* pSkill) const;
	bool	HasRequiredExhaustItem(const __TABLE_UPC_SKILL* pSkill, bool* reportError = nullptr) const;
	
public:
	bool	CheckValidSkillMagic(const __TABLE_UPC_SKILL* pSkill) const;
	void	StunMySelf(__TABLE_UPC_SKILL_TYPE_3* pType3);
	void	StopCastingByRatio();
	void	ClearDurationalMagic();
	D3DCOLOR	TraceColorGet(__TABLE_UPC_SKILL* pSkill); // 스킬의 종류에 따라 검기의 색을 정한다..

	bool	IsPositiveMagic(uint32_t dwMagicID);
	bool	IsCasting();
	uint32_t	GetMagicID(int idx);
		
	bool	MsgSend_MagicProcess(int iTargetID, __TABLE_UPC_SKILL* pSkill);
	void	SetSkillCooldown(__TABLE_UPC_SKILL* pSkill);
	void	MsgRecv_Casting(Packet& pkt);
	void	MsgRecv_Flying(Packet& pkt);
	void	MsgRecv_Effecting(Packet& pkt);
	void	MsgRecv_Fail(Packet& pkt);
	void	MsgRecv_BuffType(Packet& pkt);
	
	void	Init();
	void	Tick();
	void	UpdateZonePointerPositions();
	void	CancelZonePointer();
	float   GetCooldown(const __TABLE_UPC_SKILL* pSkill) const;

	CMagicSkillMng();
	CMagicSkillMng(CGameProcMain* pGameProcMain);
	virtual ~CMagicSkillMng();
};

// ===== END WarFare/MagicSkillMng.h =====

// ===== BEGIN WarFare/N3ClientShapeMgr.cpp =====
#line 1 "WarFare/N3ClientShapeMgr.cpp"
﻿#include "StdAfx.h"
#include "N3ClientShapeMgr.h"
#include "GameProcedure.h"
#include "UILoading.h"

void CN3ClientShapeMgr::UpdateLoadStatus(int iLoadedShapes, int iTotalShapes)
{
#ifdef _REPENT
	CGameProcedure::RenderLoadingBar(80 + 15 * iLoadedShapes / iTotalShapes);
#else
	int iLoading = (iLoadedShapes + 1) * 100 / iTotalShapes;
	std::string buff = fmt::format("Loading Objects... {} %", iLoading);
	CGameProcedure::s_pUILoading->Render(buff, iLoading);
#endif
}

// ===== END WarFare/N3ClientShapeMgr.cpp =====

// ===== BEGIN WarFare/N3ClientShapeMgr.h =====
#line 1 "WarFare/N3ClientShapeMgr.h"
﻿#pragma once

#include <N3Base/N3ShapeMgr.h>

class CN3ClientShapeMgr : public CN3ShapeMgr
{
public:
	using CN3ShapeMgr::CN3ShapeMgr;

	void UpdateLoadStatus(int iLoadedShapes, int iTotalShapes) override;
};

// ===== END WarFare/N3ClientShapeMgr.h =====

// ===== BEGIN WarFare/N3FXBundleGame.cpp =====
#line 1 "WarFare/N3FXBundleGame.cpp"
﻿// N3FXBundleGame.cpp: implementation of the CN3FXBundleGame class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3FXBundleGame.h"
#include "GameProcMain.h"
#include "PlayerBase.h"
#include "N3Terrain.h"
#include "N3FXPartBillBoardGame.h"
#include "N3FXPartBottomBoardGame.h"
#include "GameEng.h"

#include <N3Base/N3SndObj.h>
#include <N3Base/N3FXPartMesh.h>
#include <N3Base/N3FXPartParticles.h>
#include <N3Base/N3FXPartBillBoard.h>
#include <N3Base/N3ShapeExtra.h>
#include <N3Base/N3Camera.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

/////////////////////////////////////////
// Construction/Destruction
/////////////////////////////////////////

CN3FXBundleGame::CN3FXBundleGame()
{
	m_iIdx = 0;
	m_iID = -1;
	m_bRegion = false;
}

CN3FXBundleGame::~CN3FXBundleGame()
{

}

void CN3FXBundleGame::Trigger(int iSourceID, int iTargetID, int iTargetJoint, int iSndID)
{
	m_bRegion = false;

	CPlayerBase* pTarget = CGameProcedure::s_pProcMain->CharacterGetByID(iTargetID, false);
	if(!pTarget) return;
	
	CPlayerBase* pSource = CGameProcedure::s_pProcMain->CharacterGetByID(iSourceID, true);
	if(pSource)
	{
		if(pSource->m_pShapeExtraRef)
		{
			__Vector3 vMin = pSource->m_pShapeExtraRef->Min();
			__Vector3 vMax = pSource->m_pShapeExtraRef->Max();
			m_vPos = vMin + ((vMax-vMin)*0.5f);	
		}
		else
		{
			const __Matrix44* pMtx = pSource->JointMatrixGet(m_iSourceJoint);
			if(!pMtx) m_vPos = pSource->Position();
			else pSource->JointPosGet(m_iSourceJoint, m_vPos);
		}

		m_vDestPos = pSource->Position() + pSource->Direction();		
	}

	//CPlayerBase* pTarget = CGameProcedure::s_pProcMain->CharacterGetByID(iTargetID, false);
	if(pTarget && pTarget!=pSource)
	{
		if(m_bDependScale)
		{
			//m_vTargetScale.x = m_vTargetScale.z = pTarget->Radius() * 2.0f;
			//m_vTargetScale.y = pTarget->Height();
			float width = pTarget->Radius() * 2.0f;
			if(width > pTarget->Height()) m_fTargetScale = width;
			else m_fTargetScale = pTarget->Height();
		}

		if(pTarget->m_pShapeExtraRef)
		{
			__Vector3 vMin = pTarget->m_pShapeExtraRef->Min();
			__Vector3 vMax = pTarget->m_pShapeExtraRef->Max();

			m_vDestPos = vMin + ((vMax-vMin)*0.5f);	
		}
		else
		{
			__Vector3 vMin = pTarget->Min();
			__Vector3 vMax = pTarget->Max();
			m_vDestPos = vMin + ((vMax-vMin)*0.5f);
			//m_vDestPos = pTarget->Position();
			
			if(iTargetJoint==-1)
			{
				__Vector3 vMin = pTarget->Min();
				__Vector3 vMax = pTarget->Max();
	
				m_vDestPos = vMin + ((vMax-vMin)*0.5f);	
				m_vDestPos.y = vMin.y;
				//m_vDestPos = pTarget->Position();	
			}
			else if(iTargetJoint>-1)
			{
				const __Matrix44* pMtx = pTarget->JointMatrixGet(iTargetJoint);
				if(!pMtx) m_vDestPos = pTarget->Position() + (pTarget->Height()*0.5f);
				else pTarget->JointPosGet(iTargetJoint, m_vDestPos);
			}
		}
	//	m_vDir = pTarget->Direction();
	//	m_vDir.Normalize();
	}

	m_fDistance = (m_vDestPos - m_vPos).Magnitude();
	m_fHeight = m_fDistance/2.0f;

	m_vDir = m_vDestPos - m_vPos;
	m_vDir.Normalize();
	
	if(m_bStatic)
	{
		Trigger(iSourceID, m_vDestPos, iSndID);
		return;
	}

	CN3FXBundle::Trigger(iSourceID, iTargetID, iTargetJoint, iSndID);
}

void CN3FXBundleGame::Trigger(int iSourceID, __Vector3 TargetPos, int iSndID)
{
	m_bRegion = true;
	
	CPlayerBase* pSource = CGameProcedure::s_pProcMain->CharacterGetByID(iSourceID, true);
	if(pSource)
	{
		if(pSource->m_pShapeExtraRef)
		{
			__Vector3 vMin = pSource->m_pShapeExtraRef->Min();
			__Vector3 vMax = pSource->m_pShapeExtraRef->Max();

			m_vPos = vMin + ((vMax-vMin)*0.5f);	
		}
		else
		{
			const __Matrix44* pMtx = pSource->JointMatrixGet(m_iSourceJoint);
			if(!pMtx) m_vPos = pSource->Position();
			else pSource->JointPosGet(m_iSourceJoint, m_vPos);
		}
	}

	m_vDestPos = TargetPos;

	m_fDistance = (m_vDestPos - m_vPos).Magnitude();
	m_fHeight = m_fDistance/2.0f;

	m_vDir = m_vDestPos - m_vPos;
	m_vDir.Normalize();
	CN3FXBundle::Trigger(iSourceID, -1, -1, iSndID);
}

bool CN3FXBundleGame::Tick()
{
	if(m_dwState==FX_BUNDLE_STATE_DEAD) return false;
	
	m_fLife += CN3Base::s_fSecPerFrm;

	if(m_dwState==FX_BUNDLE_STATE_LIVE)
	{
	//	if(m_fLife>=m_fLife0) Stop();		

		if(!m_bRegion)
		{
			CPlayerBase* pTarget = CGameProcedure::s_pProcMain->CharacterGetByID(m_iTargetID, false);

			if(pTarget && pTarget->m_pShapeExtraRef)
			{
				__Vector3 vMin = pTarget->m_pShapeExtraRef->Min();
				__Vector3 vMax = pTarget->m_pShapeExtraRef->Max();

				m_vDestPos = vMin + ((vMax-vMin)*0.5f);	
			}
			else if(pTarget && m_iTargetJoint==-1)
			{
				__Vector3 vMin = pTarget->Min();
				__Vector3 vMax = pTarget->Max();
	
				m_vDestPos = vMin + ((vMax-vMin)*0.5f);	
				m_vDestPos.y = vMin.y;
				//m_vDestPos = pTarget->Position();	
			}
			else if(pTarget && m_iTargetJoint>-1)
			{
				const __Matrix44* pMtx = pTarget->JointMatrixGet(m_iTargetJoint);
				if(!pMtx) m_vDestPos = pTarget->Position();
				else pTarget->JointPosGet(m_iTargetJoint, m_vDestPos);
			}
		}

		switch(m_iMoveType)
		{
		case FX_BUNDLE_MOVE_CURVE_FIXEDTARGET:
			{
				m_vPos.x = (m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity).x; 
				m_vPos.z = (m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity).z;
				float fAng;
				if(m_fDistance!=0.0f)
					fAng = __PI * (m_fDistance - (m_vDestPos - m_vPos).Magnitude()) / m_fDistance;
				else fAng = 0.0f;
								
				m_vPos.y = sinf(fAng) * m_fHeight;
				break;
			}
		case FX_BUNDLE_MOVE_DIR_SLOW:
		case FX_BUNDLE_MOVE_DIR_FIXEDTARGET:
			{
				m_vPos += m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity;
				break;
			}
		case FX_BUNDLE_MOVE_DIR_FLEXABLETARGET_RATIO:
			{
				CPlayerBase* pTarget = CGameProcedure::s_pProcMain->CharacterGetByID(m_iTargetID, false);
				if(!pTarget) 
				{
					m_vPos += m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity;
					break;
				}
				else
				{
					/*
					m_vDestPos = pTarget->Position();
					const __Matrix44* pMtx = pTarget->JointMatrixGet(m_iTargetJoint);
					if(pMtx) pTarget->JointPosGet(m_iTargetJoint, m_vDestPos);

					__Vector3 vDestDir = m_vDestPos - m_vPos;
					vDestDir.Normalize();

					__Quaternion qtRot;
					__Vector3 vDirAxis;
					float fDirAng;
					
					vDirAxis.Cross(m_vDir, vDestDir);

					int tmp;
					tmp = vDirAxis.x*10000.0f;
					vDirAxis.x = (float)(tmp)/10000.0f;
					tmp = vDirAxis.y*10000.0f;
					vDirAxis.y = (float)(tmp)/10000.0f;
					tmp = vDirAxis.z*10000.0f;
					vDirAxis.z = (float)(tmp)/10000.0f;
					if(vDirAxis.x==0.0f && vDirAxis.y==0.0f && vDirAxis.z==0.0f) vDirAxis.Set(0,1,0);

					fDirAng = acos((double)m_vDir.Dot(vDestDir));
					if(fDirAng > __PI*s_fSecPerFrm) fDirAng = __PI*s_fSecPerFrm;
					else if(fDirAng < -__PI*s_fSecPerFrm) fDirAng = -__PI*s_fSecPerFrm;

					qtRot.RotationAxis(vDirAxis, fDirAng);

					__Matrix44 mtxRot = qtRot;
					m_vDir *= mtxRot;

					m_vPos += m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity;
					
					float fTerrainY = s_pTerrain->GetHeight(m_vPos.x, m_vPos.z);
					if(m_vPos.y <= fTerrainY) m_vPos.y = fTerrainY + 0.3f;	//땅을 타고 날라가라..
					break;
					*/
				}
				//break;
			}
		case FX_BUNDLE_MOVE_DIR_FLEXABLETARGET:
			{
				CPlayerBase* pTarget = CGameProcedure::s_pProcMain->CharacterGetByID(m_iTargetID, false);
				if(!pTarget) 
				{
					m_vPos += m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity;
					break;
				}

				if(pTarget && pTarget->m_pShapeExtraRef)
				{
					__Vector3 vMin = pTarget->m_pShapeExtraRef->Min();
					__Vector3 vMax = pTarget->m_pShapeExtraRef->Max();

					m_vDestPos = vMin + ((vMax-vMin)*0.5f);	
				}

				else 
				{
					m_vDestPos = pTarget->Position();
					
					const __Matrix44* pMtx = pTarget->JointMatrixGet(m_iTargetJoint);
					if(!pMtx) m_vDestPos = pTarget->Position();
					else pTarget->JointPosGet(m_iTargetJoint, m_vDestPos);
				}				

				m_vDir = m_vDestPos - m_vPos;
				m_vDir.Normalize();
				
				m_vPos += m_vDir*CN3Base::s_fSecPerFrm*m_fVelocity;

				//float fTerrainY = s_pTerrain->GetHeight(m_vPos.x, m_vPos.z);
				//if(m_vPos.y <= fTerrainY) m_vPos.y = fTerrainY + 0.3f;	//땅을 타고 날라가라..
				break;
			}

		case FX_BUNDLE_MOVE_NONE:
			{
				//m_vDir.Set(0,0,1);
				m_vDir.y = 0.0f;
				m_vDir.Normalize();
				m_vPos = m_vDestPos;
				if(m_iSourceID==m_iTargetID)
				{
					CPlayerBase* pSource = CGameProcedure::s_pProcMain->CharacterGetByID(m_iSourceID, false);
					if(pSource) 
					{
						m_vDir = pSource->Direction();
						m_vDir.y = 0.0f;
						m_vDir.Normalize();
					}
				}
				break;
			}
		case FX_BUNDLE_REGION_POISON:
			{
				CN3Camera* pCamera = CGameProcedure::s_pEng->CameraGetActive();		// 활성화된 카메라 얻기..

				__Vector3 vEyePos = pCamera->EyePos();
				__Vector3 vEyeAt  = pCamera->AtPos();
				__Vector3 vEyeDir = vEyeAt - vEyePos;
				vEyeDir.Normalize();
				m_vDir = vEyeDir;
				m_vPos = vEyePos + vEyeDir*CN3Base::s_CameraData.fNP*3;
				break;
			}
		}
	}

	if(m_dwState==FX_BUNDLE_STATE_DYING || m_dwState==FX_BUNDLE_STATE_LIVE)
	{
		if(CheckAllPartsDead() || (m_fLife0 !=0.0f && m_fLife > m_fLife0) )
		{
			m_dwState = FX_BUNDLE_STATE_DEAD;
			Init();
			return false;
		}
	}

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i] && m_pPart[i]->pPart)
		{
			if(m_pPart[i]->fStartTime <= m_fLife && m_pPart[i]->pPart->m_dwState==FX_PART_STATE_READY)
			{
				m_pPart[i]->pPart->Start();
			}
			m_pPart[i]->pPart->Tick();

		}
	}

	return true;
}

void CN3FXBundleGame::Duplicate(CN3FXBundleGame* pDestBundle)
{
	pDestBundle->FileNameSet(this->FileName());

	pDestBundle->m_iVersion = m_iVersion;
	pDestBundle->m_fLife0 = m_fLife0;
	
	pDestBundle->m_fVelocity = m_fVelocity;
	pDestBundle->m_bDependScale = m_bDependScale;
	pDestBundle->m_bStatic = pDestBundle->m_bStatic;

	for(int i=0;i<MAX_FX_PART;i++)
	{
		if(m_pPart[i])
		{
			if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_PARTICLE)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartParticles;
				CN3FXPartParticles* pPart = (CN3FXPartParticles*)pDestBundle->m_pPart[i]->pPart;

				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_PARTICLE;

				pPart->Duplicate((CN3FXPartParticles*)m_pPart[i]->pPart);
			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_BOARD)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;				

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartBillBoardGame;
				CN3FXPartBillBoardGame* pPart = (CN3FXPartBillBoardGame*)pDestBundle->m_pPart[i]->pPart;

				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_BOARD;

				pPart->Duplicate((CN3FXPartBillBoardGame*)m_pPart[i]->pPart);
			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_MESH)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartMesh;
				CN3FXPartMesh* pPart = (CN3FXPartMesh*)pDestBundle->m_pPart[i]->pPart;
				
				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_MESH;

				pPart->Duplicate((CN3FXPartMesh*)m_pPart[i]->pPart);

			}
			else if(m_pPart[i]->pPart->m_iType == FX_PART_TYPE_BOTTOMBOARD)
			{
				pDestBundle->m_pPart[i] = new FXPARTWITHSTARTTIME;

				pDestBundle->m_pPart[i]->fStartTime = m_pPart[i]->fStartTime;

				pDestBundle->m_pPart[i]->pPart = new CN3FXPartBottomBoardGame;
				CN3FXPartBottomBoardGame* pPart = (CN3FXPartBottomBoardGame*)pDestBundle->m_pPart[i]->pPart;
				
				pPart->m_pRefBundle = pDestBundle;
				pPart->m_pRefPrevPart = nullptr;
				pPart->m_iType = FX_PART_TYPE_BOTTOMBOARD;

				pPart->Duplicate((CN3FXPartBottomBoardGame*)m_pPart[i]->pPart);
			}
		}
	}
}

CN3FXPartBase* CN3FXBundleGame::AllocatePart(int iPartType) const
{
	switch (iPartType)
	{
		case FX_PART_TYPE_BOARD:
			return new CN3FXPartBillBoardGame();

		case FX_PART_TYPE_BOTTOMBOARD:
			return new CN3FXPartBottomBoardGame();
	}

	return CN3FXBundle::AllocatePart(iPartType);
}

void CN3FXBundleGame::SetPreBundlePos(int iSourceID, int iJoint)
{
	CPlayerBase* pSource = CGameProcedure::s_pProcMain->CharacterGetByID(iSourceID, true);
	if(pSource)
	{
		if(pSource->m_pShapeExtraRef)
		{
			__Vector3 vMin = pSource->m_pShapeExtraRef->Min();
			__Vector3 vMax = pSource->m_pShapeExtraRef->Max();
			m_vPrePos = vMin + ((vMax-vMin)*0.5f);	
		}
		else
		{
			const __Matrix44* pMtx = pSource->JointMatrixGet(iJoint);
			if(!pMtx) m_vPrePos = pSource->Position();
			else pSource->JointPosGet(iJoint, m_vPrePos);
		}
	}
}

// ===== END WarFare/N3FXBundleGame.cpp =====

// ===== BEGIN WarFare/N3FXBundleGame.h =====
#line 1 "WarFare/N3FXBundleGame.h"
﻿// N3FXBundleGame.h: interface for the CN3FXBundleGame class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3FXBUNDLEGAME_H__1B6BEFC3_79A4_4FFE_A48B_475D1F07E26A__INCLUDED_)
#define AFX_N3FXBUNDLEGAME_H__1B6BEFC3_79A4_4FFE_A48B_475D1F07E26A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3FXBundle.h>

class CN3FXBundleGame : public CN3FXBundle
{
public:
	int					m_iID;			//겜에서 쓰는 아디..
	int					m_iIdx;
	bool				m_bRegion;

	//포물선 운동을 위한...싸인곡선 이용함다..
	float				m_fDistance;
	float				m_fHeight;
	
public:
	void	SetPreBundlePos(int iSourceID, int iJoint);
	void	Trigger(int iSourceID=0, int iTargetID = 0, int iTargetJoint = 0, int iSndID = -1);
	void	Trigger(int iSourceID, __Vector3 TargetPos, int iSndID = -1);
	bool	Tick();
	
	void	Duplicate(CN3FXBundleGame* pDestBundle);
	CN3FXPartBase* AllocatePart(int iPartType) const override;

	CN3FXBundleGame();
	virtual ~CN3FXBundleGame();

};

#endif // !defined(AFX_N3FXBUNDLEGAME_H__1B6BEFC3_79A4_4FFE_A48B_475D1F07E26A__INCLUDED_)

// ===== END WarFare/N3FXBundleGame.h =====

// ===== BEGIN WarFare/N3FXMgr.cpp =====
#line 1 "WarFare/N3FXMgr.cpp"
﻿#include "StdAfx.h"
#include "N3FXMgr.h"
#include "GameBase.h"
#include "GameProcmain.h"
#include "GameProcedure.h"
#include "PlayerOtherMgr.h"
#include "PlayerNPC.h"
#include "PlayerMySelf.h"
#include "N3FXBundleGame.h"
#include "N3WorldManager.h"
#include "MagicSkillMng.h"
#include "APISocket.h"
#include "PacketDef.h"

#include <N3Base/N3ShapeExtra.h>

CN3FXMgr::CN3FXMgr()
{
	m_fOriginLimitedTime = 60.0f;
}

CN3FXMgr::~CN3FXMgr()
{
	stlLIST_BUNDLEGAME_IT it;
	for(it=m_ListBundle.begin(); it!=m_ListBundle.end(); it++)
	{
		delete (*it);
	}
	m_ListBundle.clear();

	stlMAP_BUNDLEORIGIN_IT itOrigin;
	for(itOrigin=m_OriginBundle.begin(); itOrigin!=m_OriginBundle.end(); itOrigin++)
	{
		LPFXBUNDLEORIGIN pSrc = itOrigin->second;
		delete pSrc->pBundle;
		delete pSrc;
	}
	m_OriginBundle.clear();	
}


//
//
//
void CN3FXMgr::TriggerBundle(int SourceID, int SourceJoint, int FXID, int TargetID, int Joint, int idx, int MoveType)
{
	__TABLE_FX* pFX = s_pTbl_FXSource.Find(FXID);
	if(!pFX) return;

	std::string strTmp = pFX->szFN;
	_strlwr(&strTmp[0]);
	
	stlMAP_BUNDLEORIGIN_IT itOrigin = m_OriginBundle.find(strTmp);
	
	if(itOrigin != m_OriginBundle.end())	//같은 효과가 있다..
	{
		LPFXBUNDLEORIGIN pSrc = itOrigin->second;
		
		CN3FXBundleGame* pBundle = new CN3FXBundleGame;
		
		pBundle->SetPreBundlePos(SourceID, Joint);
		pSrc->pBundle->Duplicate(pBundle);
		pBundle->m_iID = FXID;
		pBundle->m_iIdx = idx;
		pBundle->m_iMoveType = MoveType;
		pBundle->m_iSourceJoint = SourceJoint;

		pBundle->Trigger(SourceID, TargetID, Joint, pFX->dwSoundID);
		
		m_ListBundle.push_back(pBundle);
		pSrc->iNum++;
	}
	else	//같은 효과가 없다..
	{
		LPFXBUNDLEORIGIN pSrc = new FXBUNDLEORIGIN;
		pSrc->pBundle = new CN3FXBundleGame;
		pSrc->pBundle->LoadFromFile(strTmp);

		CN3FXBundleGame* pBundle = new CN3FXBundleGame;

		pBundle->SetPreBundlePos(SourceID, Joint);
		pSrc->pBundle->Duplicate(pBundle);	
		pBundle->m_iID = FXID;
		pBundle->m_iIdx = idx;
		pBundle->m_iMoveType = MoveType;
		pBundle->m_iSourceJoint = SourceJoint;

		pBundle->Trigger(SourceID, TargetID, Joint, pFX->dwSoundID);
		
		m_ListBundle.push_back(pBundle);
		
		pSrc->iNum++;
		m_OriginBundle.insert(stlMAP_BUNDLEORIGIN_VALUE(strTmp, pSrc));
	}
}


//
//
//
void CN3FXMgr::TriggerBundle(int SourceID, int SourceJoint, int FXID, __Vector3 TargetPos, int idx, int MoveType)
{
	__TABLE_FX* pFX = s_pTbl_FXSource.Find(FXID);
	if(!pFX) return; 

	std::string strTmp = pFX->szFN;
	_strlwr(&strTmp[0]);

	stlMAP_BUNDLEORIGIN_IT itOrigin = m_OriginBundle.find(strTmp);

	if(itOrigin != m_OriginBundle.end())	//같은 효과가 있다..
	{
		LPFXBUNDLEORIGIN pSrc = itOrigin->second;		
		CN3FXBundleGame* pBundle = new CN3FXBundleGame;
				
		pBundle->SetPreBundlePos(SourceID, SourceJoint);
		pSrc->pBundle->Duplicate(pBundle);
		pBundle->m_iID = FXID;
		pBundle->m_iIdx = idx;
		pBundle->m_iMoveType = MoveType;
		pBundle->m_iSourceJoint = SourceJoint;

		pBundle->Trigger(SourceID, TargetPos, pFX->dwSoundID);		
		m_ListBundle.push_back(pBundle);
		pSrc->iNum++;
	}
	else	//같은 효과가 없다..
	{
		LPFXBUNDLEORIGIN pSrc = new FXBUNDLEORIGIN;
		pSrc->pBundle = new CN3FXBundleGame;
		pSrc->pBundle->LoadFromFile(pFX->szFN);

		CN3FXBundleGame* pBundle = new CN3FXBundleGame;

		pBundle->SetPreBundlePos(SourceID, SourceJoint);
		pSrc->pBundle->Duplicate(pBundle);	
		pBundle->m_iID = FXID;
		pBundle->m_iIdx = idx;
		pBundle->m_iMoveType = MoveType;
		pBundle->m_iSourceJoint = SourceJoint;

		pBundle->Trigger(SourceID, TargetPos, pFX->dwSoundID);
		m_ListBundle.push_back(pBundle);

		pSrc->iNum++;
		m_OriginBundle.insert(stlMAP_BUNDLEORIGIN_VALUE(strTmp, pSrc));
	}
}


//
//
//
void CN3FXMgr::Stop(int SourceID, int TargetID, int FXID, int idx, bool immediately)
{
	CN3FXBundleGame* pBundle;
	if(FXID < 0)
	{
		stlLIST_BUNDLEGAME_IT it = m_ListBundle.begin();	
		while(it!=m_ListBundle.end())
		{
			pBundle = (*it);
			if(!pBundle)
			{
				it = m_ListBundle.erase(it);
				continue;
			}
			if(pBundle->m_iSourceID==SourceID && pBundle->m_iIdx==idx)
			{
				pBundle->Stop(immediately);
			}
			it++;
		}
	}
	else
	{
		stlLIST_BUNDLEGAME_IT it = m_ListBundle.begin();	
		while(it!=m_ListBundle.end())
		{
			pBundle = (*it);
			if(!pBundle)
			{
				it = m_ListBundle.erase(it);
				continue;
			}
			if(pBundle->m_iSourceID==SourceID && pBundle->m_iID == FXID && pBundle->m_iIdx==idx)
			{
				pBundle->Stop(immediately);
			}
			it++;
		}
	}
}

//
//
//
void CN3FXMgr::SetBundlePos(int FXID, int idx, __Vector3& vPos)
{
	stlLIST_BUNDLEGAME_IT it = m_ListBundle.begin();
	CN3FXBundleGame* pBundle;
	while(it!=m_ListBundle.end())
	{
		pBundle = (*it);
		if(pBundle && pBundle->m_iID == FXID && pBundle->m_iIdx==idx)
		{
			pBundle->m_vDestPos = vPos;
			return;
		}
		it++;
	}
}

//
//
//
void CN3FXMgr::StopMine()
{
	CN3FXBundleGame* pBundle;

	stlLIST_BUNDLEGAME_IT it = m_ListBundle.begin();	
	while(it!=m_ListBundle.end())
	{
		pBundle = (*it);
		if(!pBundle)
		{
			it = m_ListBundle.erase(it);
			continue;
		}
		if(pBundle->m_iSourceID==CGameBase::s_pPlayer->IDNumber())
		{
			pBundle->Stop(true);
		}
		it++;
	}
}


//
//
//
void CN3FXMgr::Tick()
{
	stlMAP_BUNDLEORIGIN_IT itOrigin = m_OriginBundle.begin();
	while(itOrigin!=m_OriginBundle.end())
	{
		LPFXBUNDLEORIGIN pSrc = itOrigin->second;
		if(pSrc && pSrc->iNum<=0)
		{
			pSrc->fLimitedTime += CN3Base::s_fSecPerFrm;
			if(pSrc->fLimitedTime > m_fOriginLimitedTime)
			{
				if(pSrc->pBundle) delete pSrc->pBundle;
				delete pSrc;
				
				itOrigin = m_OriginBundle.erase(itOrigin);
				continue;
			}
		}
		itOrigin++;
	}
//	TRACE("Origin Bundle Count : %d \n", m_OriginBundle.size());
//	TRACE("현재쓰고 있는 효과의 수 : %d \n", m_ListBundle.size());

	stlLIST_BUNDLEGAME_IT it = m_ListBundle.begin();
	//std::list<CN3FXBundleGame*>::iterator it = m_ListBundle.begin();
	while(it!=m_ListBundle.end())
	{
		CN3FXBundleGame* pBundle = (*it);
		if(!pBundle)
		{
			it = m_ListBundle.erase(it);
			continue;
		}
		if(pBundle->m_dwState==FX_BUNDLE_STATE_DEAD)
		{
			stlMAP_BUNDLEORIGIN_IT itOrigin = m_OriginBundle.find(pBundle->FileName());
			if(itOrigin!=m_OriginBundle.end())	//같은 효과가 있다..
			{
				LPFXBUNDLEORIGIN pSrc = itOrigin->second;
				pSrc->iNum--;
			}
//			else
//			{
//				TRACE("Invalid Bundle-.- \n");
//			}
			
			delete pBundle;
			it = m_ListBundle.erase(it);
			continue;
		}		
		
		//내가 쏜 것이고..
		//pBundle->m_iMoveType과 살아있는지를 체크한 다음
		//시야권 검사는 보류....만약 한다면...view frustum으로 하는게 아니라...
		//player와 obj의 거리를 구해서 일정거리 이상이면 없애는 걸로해라..
		//충돌검사
/*	
		if(pBundle->m_iMoveType != FX_BUNDLE_MOVE_NONE &&
			pBundle->m_dwState==FX_BUNDLE_STATE_LIVE &&
			( s_pPlayer->IDNumber()==pBundle->m_iSourceID ||
			( s_pPlayer->IDNumber()==pBundle->m_iTargetID &&
			s_pOPMgr->UPCGetByID(pBundle->m_iSourceID, true)==nullptr)))
*/
		if(pBundle->m_iMoveType != FX_BUNDLE_MOVE_NONE && pBundle->m_dwState==FX_BUNDLE_STATE_LIVE)
		{
			if(s_pOPMgr->UPCGetByID(pBundle->m_iSourceID, true)==nullptr &&
				s_pOPMgr->NPCGetByID(pBundle->m_iSourceID, true)==nullptr &&
				s_pPlayer->IDNumber()!=pBundle->m_iSourceID	)
			{
				pBundle->Stop();
			}

			uint32_t dwToMe = 0; //dwToMe==1이면 내가 쏜거.. dwToMe==2이면 내가 타겟..
			if(s_pPlayer->IDNumber()==pBundle->m_iSourceID) dwToMe = 1;
			else if( s_pPlayer->IDNumber()==pBundle->m_iTargetID &&
					s_pOPMgr->UPCGetByID(pBundle->m_iSourceID, true)==nullptr) dwToMe = 2;
			
			if(dwToMe == 1 || dwToMe == 2)
			{
				__Vector3 vCol;
				float fHeight = 0.5f;

				// npc or player와 충돌체크..
				bool bCol = false;
				it_UPC it = s_pOPMgr->m_UPCs.begin();
				it_UPC itEnd = s_pOPMgr->m_UPCs.end();
				CPlayerOther* pUPC = nullptr;

				if( dwToMe==2 && ((pBundle->m_vPos - s_pPlayer->Position()).Magnitude()<16.0f) )
				{
					__Vector3 vCp = s_pPlayer->Center();
					if( true == s_pPlayer->CheckCollisionByBox(pBundle->m_vPos, pBundle->m_vPos + pBundle->m_vDir*pBundle->m_fVelocity*CN3Base::s_fSecPerFrm, &vCol, nullptr) )
					//if( true == CheckCollisionSphere(pBundle->m_vPos, pBundle->m_vPos + pBundle->m_vDir*pBundle->m_fVelocity*CN3Base::s_fSecPerFrm, vCp, s_pPlayer->Radius(), &vCol) )
					{
						bCol = true;
						pBundle->m_vPos = vCol;
						pBundle->Stop();
						int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
						
						uint8_t byBuff[32];
						int iOffset=0;
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
						CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDNumber());

						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						
						CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						
						CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	

						iOffset=0;
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
						CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)s_pPlayer->IDNumber());

						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);

						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
						CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);					
						
						CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

						break;
					}
				}

				for(; it != itEnd; it++)
				{
					pUPC = it->second;
					if (dwToMe == 1
						&& !s_pPlayer->IsHostileTarget(pUPC))
						continue;
					
					if((pBundle->m_vPos - pUPC->Position()).Magnitude() > 16.0f) continue; // 16 미터 이상 떨어져 있음 지나간다..

					__Vector3 vCp = pUPC->Center();
					//if( true == CheckCollisionSphere(pBundle->m_vPos, pBundle->m_vPos + pBundle->m_vDir*pBundle->m_fVelocity*CN3Base::s_fSecPerFrm, vCp, pUPC->Radius(), &vCol) )
					if ( true == pUPC->CheckCollisionByBox(pBundle->m_vPos, pBundle->m_vPos + pBundle->m_vDir*pBundle->m_fVelocity*CN3Base::s_fSecPerFrm, &vCol, nullptr) )
					{
						bCol = true;
						pBundle->m_vPos = vCol;
						pBundle->Stop();
						int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
						
						uint8_t byBuff[32];
						int iOffset=0;
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
						CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pUPC->IDNumber());

						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						
						CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);
						
						CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..	

						iOffset=0;
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
						CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
						CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pUPC->IDNumber());

						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);

						CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
						CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
						CAPISocket::MP_AddShort(byBuff, iOffset, 0);					
						
						CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

						break;
					}
				}

				if(false == bCol)
				{
					__Vector3 vNext = pBundle->m_vPos + pBundle->m_vDir * (pBundle->m_fVelocity * CN3Base::s_fSecPerFrm * 1.2f);

					it_NPC it2 = s_pOPMgr->m_NPCs.begin();
					it_NPC itEnd2 = s_pOPMgr->m_NPCs.end();
					CPlayerNPC* pSNPC = s_pOPMgr->NPCGetByID(pBundle->m_iSourceID, FALSE);
					CPlayerNPC* pNPC = nullptr;
					for(; it2 != itEnd2; it2++)
					{
						pNPC = (*it2).second;

						if (dwToMe == 1
							&& !s_pPlayer->IsHostileTarget(pNPC))
							continue;

						if (pSNPC != nullptr
							&& dwToMe == 2
							&& !pSNPC->IsHostileTarget(pNPC))
							continue;

						if((pBundle->m_vPos - pNPC->Position()).Magnitude() > 16.0f) continue; // 16 미터 이상 떨어져 있음 지나간다..

						if(pNPC->IDNumber()==pBundle->m_iTargetID && pNPC->m_pShapeExtraRef)
						{
							__Vector3 vMin = pNPC->m_pShapeExtraRef->Min();
							__Vector3 vMax = pNPC->m_pShapeExtraRef->Max();
							__Vector3 vDestPos = vMin + ((vMax-vMin)*0.5f);

							float fDistTmp = pBundle->m_fVelocity * CN3Base::s_fSecPerFrm * 1.2f;
							
							if((pBundle->m_vPos - vDestPos).Magnitude() <= fDistTmp)
							{
								bCol = true;
								pBundle->Stop();
								int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
								
								uint8_t byBuff[32];
								int iOffset=0;
								CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
								CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
								CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pNPC->IDNumber());

								CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								
								CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
								CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								
								CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
								
								iOffset=0;
								CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
								CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
								CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pNPC->IDNumber());

								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_vPos.x);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_vPos.y);
								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_vPos.z);

								CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
								CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
								CAPISocket::MP_AddShort(byBuff, iOffset, 0);					
								
								CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

								break;
							}
						}

						__Vector3 vCp = pNPC->Center();
						//if( true == CheckCollisionSphere(pBundle->m_vPos, vNext, vCp, pNPC->Radius(), &vCol) )
						if ( true == pNPC->CheckCollisionByBox(pBundle->m_vPos, vNext, &vCol, nullptr) )
						{
							bCol = true;
							pBundle->m_vPos = vCol;
							pBundle->Stop();
							int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
							
							uint8_t byBuff[32];
							int iOffset=0;
							CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
							CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
							CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pNPC->IDNumber());

							CAPISocket::MP_AddShort(byBuff, iOffset, 0);
							CAPISocket::MP_AddShort(byBuff, iOffset, 0);
							CAPISocket::MP_AddShort(byBuff, iOffset, 0);
							
							CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
							CAPISocket::MP_AddShort(byBuff, iOffset, 0);
							CAPISocket::MP_AddShort(byBuff, iOffset, 0);
							
							CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
							
							iOffset=0;
							CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
							CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
							CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pNPC->IDNumber());

							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);

							CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
							CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
							CAPISocket::MP_AddShort(byBuff, iOffset, 0);					
							
							CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

							break;						
						}
					}
				}
				
				// Object 와 충돌 체크..
				if(bCol == false &&
					true == ACT_WORLD->CheckCollisionWithShape(pBundle->m_vPos, pBundle->m_vDir, pBundle->m_fVelocity * CN3Base::s_fSecPerFrm, &vCol))
				{
					bCol = true;
					pBundle->m_vPos = vCol;

					pBundle->Stop();
					int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
					
					uint8_t byBuff[32];
					int iOffset=0;

					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
					CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)-1);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);
					
					CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);

					CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

					iOffset=0;
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
					CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)-1);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
					CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);	
					
					CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..			
				}
				// 지형과 충돌체크..
				if(bCol == false &&
					ACT_WORLD->CheckCollisionWithTerrain(pBundle->m_vPos, pBundle->m_vDir, pBundle->m_fVelocity, &vCol))
				{
					//충돌...
					//여기서 패킷 날려야 겠구만...
					bCol = true;
					pBundle->m_vPos = vCol;
					pBundle->Stop();
					int iMagicID = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetMagicID(pBundle->m_iIdx);
					
					uint8_t byBuff[32];
					int iOffset=0;

					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_EFFECTING);
					CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)-1);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);
					
					CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);	//?
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);

					CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

					iOffset=0;
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_FAIL);
					CAPISocket::MP_AddDword(byBuff, iOffset, iMagicID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)pBundle->m_iSourceID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)-1);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.x);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.y);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)vCol.z);

					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)SKILLMAGIC_FAIL_KILLFLYING);			
					CAPISocket::MP_AddShort(byBuff, iOffset, pBundle->m_iIdx);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
								
					CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..
				}
			}
		}			
		pBundle->Tick();
		it++;
	}
}


//
//
//
void CN3FXMgr::Render()
{
	//온갖 renderstate설정...	
	DWORD dwLgt, dwAlpha, dwZEnable;
	DWORD dwSrcBlend, dwDestBlend;

	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLgt );
	s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE,	&dwAlpha );
	s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwSrcBlend );
    s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwDestBlend );
	s_lpD3DDev->GetRenderState( D3DRS_ZWRITEENABLE, &dwZEnable );

	s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE );
	s_lpD3DDev->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
	
	__Matrix44 mtx;
	mtx.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());
	
	stlLIST_BUNDLEGAME_IT itBegin = m_ListBundle.begin();
	stlLIST_BUNDLEGAME_IT itEnd = m_ListBundle.end();
	stlLIST_BUNDLEGAME_IT it;
	
	for(it=itBegin; it!=itEnd; it++) (*it)->Render();

	s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLgt );
	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE,	dwAlpha );
	s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, dwSrcBlend );
    s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, dwDestBlend );
	s_lpD3DDev->SetRenderState( D3DRS_ZWRITEENABLE, dwZEnable );
}

bool CN3FXMgr::CheckCollisionSphere(__Vector3 vSp, __Vector3 vEp, __Vector3 vCp, float fRadius, __Vector3* vCol)
{
	__Vector3 vSpCp = vCp - vSp;
	float DistSpCp = vSpCp.Magnitude();
	if(DistSpCp <= fRadius)
	{
		(*vCol) = vSp;
		return true;
	}

	__Vector3 vDir = vEp - vSp;
	float DistSpEp = vDir.Magnitude();
	vDir.Normalize();

	__Vector3 vCross;
	vCross.Cross(vSpCp, vDir);
	float DistCross = vCross.Magnitude();

	if(DistCross <= fRadius)
	{
		float sqDistCross = DistCross*DistCross;
		float DistSpCross = sqrt((DistSpCp*DistSpCp)-sqDistCross);

		if(DistSpCross < DistSpEp)
		{
			float DistCol = DistSpCross - sqrt((fRadius*fRadius)-sqDistCross);
			
			(*vCol) = vSp + vDir*DistCol;
			return true;
		}
	}
	return false;	
}

void CN3FXMgr::ClearAll()
{
	stlLIST_BUNDLEGAME_IT it;
	for(it=m_ListBundle.begin(); it!=m_ListBundle.end(); it++)
	{
		CN3FXBundleGame* pBundle = (*it);
		if(pBundle) delete pBundle;
	}
	m_ListBundle.clear();

	stlMAP_BUNDLEORIGIN_IT itOrigin;
	for(itOrigin=m_OriginBundle.begin(); itOrigin!=m_OriginBundle.end(); itOrigin++)
	{
		LPFXBUNDLEORIGIN pSrc = itOrigin->second;
		if(pSrc)
		{
			if(pSrc->pBundle) delete pSrc->pBundle;
			delete pSrc;
		}
	}
	m_OriginBundle.clear();
}

// ===== END WarFare/N3FXMgr.cpp =====

// ===== BEGIN WarFare/N3FXMgr.h =====
#line 1 "WarFare/N3FXMgr.h"
﻿// N3FXMgr.h: interface for the CN3FXMgr class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXMGR_H__
#define __N3FXMGR_H__

#include <list>
#include <map>
#include "N3UIWndBase.h"

#include <N3Base/N3FXDef.h>

class CN3FXBundleGame;

typedef struct __FXBundleOrigin	// 번들에서 파트들 관리할때..
{
	class CN3FXBundleGame*	pBundle;
	int						iNum;
	float					fLimitedTime;
	
	__FXBundleOrigin()
	{
		pBundle = nullptr;
		iNum = 0;
		fLimitedTime = 0.0f;
	}
} FXBUNDLEORIGIN, *LPFXBUNDLEORIGIN;

typedef std::map<std::string, LPFXBUNDLEORIGIN> stlMAP_BUNDLEORIGIN;
typedef stlMAP_BUNDLEORIGIN::value_type stlMAP_BUNDLEORIGIN_VALUE;
typedef stlMAP_BUNDLEORIGIN::iterator stlMAP_BUNDLEORIGIN_IT;

typedef std::list<CN3FXBundleGame*> stlLIST_BUNDLEGAME;
//typedef stlLIST_BUNDLEGAME::value_type stlLIST_BUNDLEGAME_VALUE;
typedef stlLIST_BUNDLEGAME::iterator stlLIST_BUNDLEGAME_IT;

class CN3FXMgr : public CGameBase
{
public:
	//std::list<CN3FXBundleGame*>		m_ListBundle;
	stlLIST_BUNDLEGAME			m_ListBundle;

	stlMAP_BUNDLEORIGIN			m_OriginBundle;

	float						m_fOriginLimitedTime;
	
public:
	void	TriggerBundle(int SourceID, int SourceJoint, int FXID, int TargetID, int TargetJoint, int idx = 0, int MoveType = FX_BUNDLE_MOVE_NONE);
	void	TriggerBundle(int SourceID, int SourceJoint, int FXID, __Vector3 TargetPos, int idx = 0, int MoveType = FX_BUNDLE_MOVE_NONE);
	void	Stop(int SourceID, int TargetID, int FXID = -1, int idx = 0, bool immediately = false);
	void	StopMine();
	void	Tick();
	void	Render();
	bool	CheckCollisionSphere(__Vector3 vSp, __Vector3 vEp, __Vector3 vCp, float fRadius, __Vector3* vCol);

	void	SetBundlePos(int FXID, int idx, __Vector3& vPos);

	void	ClearAll();		
	CN3FXMgr();	
	virtual ~CN3FXMgr();
};

#endif // #ifndef __N3FXMGR_H__

// ===== END WarFare/N3FXMgr.h =====

// ===== BEGIN WarFare/N3FXPartBillBoardGame.cpp =====
#line 1 "WarFare/N3FXPartBillBoardGame.cpp"
﻿// N3FXPartBillBoard.cpp: implementation of the CN3FXPartBillBoard class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "GameProcedure.h"
#include "N3WorldManager.h"
#include "N3FXPartBillBoardGame.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//
//
//

float CN3FXPartBillBoardGame::GetGroundHeight(float x, float z)
{
	float fHeight = 0.1f;
	fHeight = CGameBase::ACT_WORLD->GetHeightWithTerrain(x, z) + 0.1f;
	return fHeight;
}

// ===== END WarFare/N3FXPartBillBoardGame.cpp =====

// ===== BEGIN WarFare/N3FXPartBillBoardGame.h =====
#line 1 "WarFare/N3FXPartBillBoardGame.h"
﻿// N3FXPartBillBoardGame.h: interface for the CN3FXPartBillBoard class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTBILLBOARDGAME_H__
#define __N3FXPARTBILLBOARDGAME_H__

#include <N3Base/N3FXPartBillBoard.h>

class CN3FXPartBillBoardGame : public CN3FXPartBillBoard
{
public:
	float	GetGroundHeight(float x, float z);

	CN3FXPartBillBoardGame() {}
	virtual ~CN3FXPartBillBoardGame() {}
};

#endif // !defined(AFX_N3FXPARTBILLBOARD_H__3449DE4C_B687_459A_BF2C_A1FB98895B17__INCLUDED_)

// ===== END WarFare/N3FXPartBillBoardGame.h =====

// ===== BEGIN WarFare/N3FXPartBottomBoardGame.cpp =====
#line 1 "WarFare/N3FXPartBottomBoardGame.cpp"
﻿// N3FXPartBottomBoard.cpp: implementation of the CN3FXPartBottomBoard class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "GameProcedure.h"
#include "N3WorldManager.h"
#include "N3FXPartBottomBoardGame.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3FXPartBottomBoardGame::CN3FXPartBottomBoardGame()
{
}

CN3FXPartBottomBoardGame::~CN3FXPartBottomBoardGame()
{
	if(m_pVB)
	{
		delete[] m_pVB;
		m_pVB = nullptr;
	}

	if(m_vUnit)
	{
		delete[] m_vUnit;
		m_vUnit = nullptr;
	}
}


//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////

float CN3FXPartBottomBoardGame::GetGroundHeight(float x, float z)
{
	float fHeight = 0.1f;
	fHeight = CGameBase::ACT_WORLD->GetHeightWithTerrain(x, z) + 0.1f;
	return fHeight;
}

// ===== END WarFare/N3FXPartBottomBoardGame.cpp =====

// ===== BEGIN WarFare/N3FXPartBottomBoardGame.h =====
#line 1 "WarFare/N3FXPartBottomBoardGame.h"
﻿// N3FXPartBottomBoardGame.h: interface for the CN3FXPartBottomBoard class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3FXPARTBOTTOMBOARDGAME_H__
#define __N3FXPARTBOTTOMBOARDGAME_H__

#include <N3Base/N3FXPartBottomBoard.h>

class CN3FXPartBottomBoardGame : public CN3FXPartBottomBoard
{
public:
	float	GetGroundHeight(float x, float z);

public:
	CN3FXPartBottomBoardGame();
	virtual ~CN3FXPartBottomBoardGame();
};

#endif // #ifndef __N3FXPARTBOTTOMBOARD_H__

// ===== END WarFare/N3FXPartBottomBoardGame.h =====

// ===== BEGIN WarFare/N3Pond.cpp =====
#line 1 "WarFare/N3Pond.cpp"
﻿// N3Pond.cpp: implementation of the CN3Pond class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3Pond.h"

#include <N3Base/N3Texture.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


#define ATISQRT	4.94974747f

// 생성자.. 변수 디폴트값 할당..
CN3Pond::CN3Pond()
{
	m_iPondMeshNum = 0;
	m_pCPondMesh=nullptr;
	m_pfMaxVtx=nullptr;

	memset(m_pTexPond, 0, sizeof(m_pTexPond));
}

CN3Pond::~CN3Pond()
{
	Release();
}

void CN3Pond::Release()
{
	if(m_iPondMeshNum>0)
	{
		if(m_pCPondMesh!=nullptr)
		{
			delete []m_pCPondMesh;
			m_pCPondMesh=nullptr;
		}
		m_iPondMeshNum=0;
	}

	if(m_iMaxVtxNum>0)
	{
		if(m_pfMaxVtx)
		{
			delete [] m_pfMaxVtx;
			m_pfMaxVtx = nullptr;
		}
	
		m_iMaxVtxNum=0;
	}

	for(int i = 0; i < MAX_POND_TEX; i++)
		s_MngTex.Delete(&(m_pTexPond[i]));

	m_fTexIndex = 0.0f;
}

bool CN3Pond::Load(File& file)
{
	Release();

	file.Read(&m_iPondMeshNum, sizeof(int));	///
//	if(m_iPondMeshNum<=0) {m_iPondMeshNum=0;return 1;}
	if(true) {m_iPondMeshNum=0;return 1;}

	m_pCPondMesh = new CPongMesh [m_iPondMeshNum];	///

	CPongMesh* ptmpPondMesh;
	for (int i=0;i<m_iPondMeshNum;i++)
	{
		ptmpPondMesh = &m_pCPondMesh[i];

		int iVC;
		file.Read(&iVC, sizeof(iVC));				// 점 갯수
		ptmpPondMesh->m_iVC = iVC;	///
		ptmpPondMesh->m_bTick2Rand = FALSE;		///
		if(iVC<=0) 
		{
			ptmpPondMesh->m_pVertices=nullptr;
			continue;
		}

		int iWidthVertex;
		file.Read(&iWidthVertex, sizeof(iWidthVertex));				// 한 라인당 점 갯수
		ptmpPondMesh->m_iWidthVtx = iWidthVertex;		///
		ptmpPondMesh->m_iHeightVtx = iVC/iWidthVertex;	///

		int iTexNameLength = 0;
		file.Read(&iTexNameLength, sizeof(int));
		if (iTexNameLength > 0)
		{
			char szTexture[50];
			file.Read(szTexture, iTexNameLength);			// texture name
			szTexture[iTexNameLength] = '\0';

			std::string szTextureFName = fmt::format("misc\\river\\{}", szTexture);

			ptmpPondMesh->m_pTexWave = s_MngTex.Get(szTextureFName);
			__ASSERT(ptmpPondMesh->m_pTexWave, "CN3Pond::texture load failed");
		}


		// XyxT2 -> XyzColorT2 Converting.
		ptmpPondMesh->m_pVertices = new __VertexPond[iVC];	///
		file.Read(ptmpPondMesh->m_pVertices, iVC * sizeof(__VertexPond));

		ptmpPondMesh->m_pVertices[0].y += 0.2f;				//	수치가 높으면 물결이 크게 요동친다
		ptmpPondMesh->m_pVertices[iWidthVertex].y += 0.2f;	//	수치가 높으면 물결이 크게 요동친다
		ptmpPondMesh->m_pfMaxHeight = ptmpPondMesh->m_pVertices[0].y += 0.3f;		//	물결의 최대치

		ptmpPondMesh->m_pfVelocityArray = new float[iVC];	///
		memset(ptmpPondMesh->m_pfVelocityArray,0,sizeof(float)*iVC);

		
		int iIC;
		file.Read(&iIC, sizeof(iIC));				// IndexBuffer Count.
		ptmpPondMesh->m_iIC = iIC;		///
		ptmpPondMesh->m_wpIndex = new uint16_t [iVC*6];		///

		int j,k;
		int iWidth = iWidthVertex,iHeight = iVC/iWidthVertex;
		int x=0,y=iWidth;
		uint16_t* indexPtr = ptmpPondMesh->m_wpIndex;	//	삼각형을 부를 위치 설정
		iWidth--;

		__VertexPond* ptVtx = ptmpPondMesh->m_pVertices;
		float StX,EnX,StZ,EnZ;
		StX = ptVtx[0].x,EnX = ptVtx[iWidth].x;
		StZ = ptVtx[0].z,EnZ = ptVtx[iHeight].z;
		for (j=0; j<iHeight; j++)
		{
			for (k=0; k<iWidth; k++)
			{
				//	삼각형을 부를 위치 설정
				indexPtr[0] = x;
				indexPtr[1] = x+1;
				indexPtr[2] = y;
				indexPtr[3] = y;
				indexPtr[4] = x+1;
				indexPtr[5] = y+1;

				indexPtr += 6;
				x++;
				y++;

				//	연못의 최소최대 위치 구함
				if(StX>ptVtx->x) StX = ptVtx->x;
				if(EnX<ptVtx->x) EnX = ptVtx->x;
				if(StZ>ptVtx->z) StZ = ptVtx->z;
				if(EnZ<ptVtx->z) EnZ = ptVtx->z;
				ptVtx++;
			}
			x++;
			y++;
		}


		float fmin,fmax,fmaxcal,fmincal;
		if(ptmpPondMesh->m_pfMaxHeight>0.0f)
		{
			fmax = ptmpPondMesh->m_pfMaxHeight*0.04f;
			fmin = -fmax;
			fmaxcal = fmax*ATISQRT;
			fmincal = -fmaxcal;
		}
		else if(ptmpPondMesh->m_pfMaxHeight<0.0f)
		{
			fmin = ptmpPondMesh->m_pfMaxHeight*0.04f;
			fmax = -fmin;
			fmincal = fmin*ATISQRT;
			fmaxcal = -fmincal;
		}
		else
		{
			fmax = 0.04f;
			fmin = -fmax;
			fmaxcal = fmax*ATISQRT;
			fmincal = -fmaxcal;
		}

		ptmpPondMesh->m_fmin = fmin;
		ptmpPondMesh->m_fmax = fmax;
		ptmpPondMesh->m_fmaxcal = fmaxcal;
		ptmpPondMesh->m_fmincal = fmincal;

		ptmpPondMesh->m_vCenterPo.Set(((EnX-StX)/2.0f) + StX
									 ,ptmpPondMesh->m_pVertices[1].y
									 ,((EnZ-StZ)/2.0f) + StZ);
		if(EnX-StX > EnZ-StZ)
			ptmpPondMesh->m_fRadius = EnX-StX;
		else ptmpPondMesh->m_fRadius = EnZ-StZ;


		ptmpPondMesh->m_bTick2Rand = TRUE;		///

		if(m_iMaxVtxNum<iVC) m_iMaxVtxNum=iVC;	//	가장큰 계산범위 구함
	}	

	m_pfMaxVtx = new float [m_iMaxVtxNum];
	m_iMaxVtxNum *= sizeof(float);

#ifdef _DEBUG
	for (int x = 0; x < 2000; x++)
		UpdateWaterPositions();
#endif

	if (m_iPondMeshNum <= 0)
		return false;

	std::string szFileName;
	for (int i = 0; i < MAX_POND_TEX; i++)
	{
		szFileName = fmt::format("misc\\river\\caust{:02}.dxt", i);
		m_pTexPond[i] = CN3Base::s_MngTex.Get(szFileName);
		__ASSERT(m_pTexPond[i], "CN3Pond::texture load failed");
	}

	return true;
}

void CN3Pond::Tick()
{
	if(m_iPondMeshNum==0) return;

	float frame;

	m_fTexIndex += s_fSecPerFrm*15.0f;
	if (m_fTexIndex >= 32.0f)
	{
		m_fTexIndex -= 32.0f;
	}

	// 프레임이 임계값보다 작으면 버린다..
	if ( CN3Base::s_fFrmPerSec < 0.1f ) return;
	
	// Desire Frame Rate보다 Frame이 잘 나오는 경우..
	if ( 30.0f <= CN3Base::s_fFrmPerSec )
	{
		static float ftemp = 0.0f;
		frame = (30.0f / CN3Base::s_fFrmPerSec)*1.2f;
		ftemp += frame;
		if ( ftemp > 1.0f )
		{
			UpdateWaterPositions();
			ftemp -= 1.0f;
		}
	}
	// Desire Frame보다 Frame이 잘 안나오는 경우..
	else 
	{
		static float ftemp = 0.0f;
		frame = (30.0f / CN3Base::s_fFrmPerSec)*1.2f;
		ftemp   += frame;
		int i    = (int)ftemp;
		float j  = ftemp - (float)i;

		for ( int k = 0; k < i; k++ )
		{
			UpdateWaterPositions();
		}
//		TRACE("Frame not Accecl \n");
		ftemp = j;
	}
}

void CN3Pond::Render()
{
	if(m_iPondMeshNum <= 0) return;

	int iTex = (int)m_fTexIndex;
	__ASSERT(iTex < MAX_POND_TEX, "Pond Texture index overflow..");
	if(iTex >= MAX_POND_TEX || nullptr == m_pTexPond[iTex]) return;

	// Backup
	__Matrix44 matWorld, matOld;	matWorld.Identity();
	DWORD dwAlphaEnable, dwSrcBlend, dwDestBlend;
	s_lpD3DDev->GetTransform(D3DTS_WORLD, matOld.toD3D());
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaEnable);
	s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	DWORD dwColor_0, dwColorArg1_0, dwColorArg2_0, dwMipFilter_0;
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwColor_0);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorArg1_0);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG2, &dwColorArg2_0);
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_MIPFILTER, &dwMipFilter_0);
	DWORD dwColor_1, dwColorArg1_1, dwColorArg2_1, dwMipFilter_1;
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLOROP, &dwColor_1);
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG1, &dwColorArg1_1);
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG2, &dwColorArg2_1);
	s_lpD3DDev->GetSamplerState(1, D3DSAMP_MIPFILTER, &dwMipFilter_1);


	// Set
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());


	// texture state 세팅 (alpha)
	s_lpD3DDev->SetTexture(0, m_pTexPond[iTex]->Get());
	s_lpD3DDev->SetTexture(2, nullptr);

	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
    s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );

	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
    s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);	
	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE);
    s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT);	
    s_lpD3DDev->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_NONE );
    s_lpD3DDev->SetSamplerState( 1, D3DSAMP_MIPFILTER, D3DTEXF_NONE );

	s_lpD3DDev->SetFVF(D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX2);

	for(int i=0;i<m_iPondMeshNum;i++)
	{
		if(m_pCPondMesh[i].m_bTick2Rand)
		{
			if(m_pCPondMesh[i].m_pTexWave) s_lpD3DDev->SetTexture(1, m_pCPondMesh[i].m_pTexWave->Get());
			else s_lpD3DDev->SetTexture(1, nullptr);

			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST
												, 0
												, m_pCPondMesh[i].m_iVC
												, m_pCPondMesh[i].m_iIC
												, m_pCPondMesh[i].m_wpIndex
												, D3DFMT_INDEX16
												, m_pCPondMesh[i].m_pVertices
												, sizeof(__VertexPond));
		}
	}


	// restore 
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matOld.toD3D());
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaEnable);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwColor_0);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwColorArg1_0);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, dwColorArg2_0);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, dwMipFilter_0);

	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, dwColor_1);
	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, dwColorArg1_1);
	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, dwColorArg2_1);
	s_lpD3DDev->SetSamplerState(1, D3DSAMP_MIPFILTER, dwMipFilter_1);
}

void CN3Pond::UpdateWaterPositions()
{
	CPongMesh* pPondMesh;

	//	기초 데이타
	int	x, y,n,m;
	float d;
	__VertexPond* pVtx,*ptmpVtx,*ptmpVtxSub,*ptmpVtxPlus;
	float* pForceArray,*ptmpForceArray,*ptmpFArrSub,*ptmpFArrPlus;

	//	계산 변수
	float max,min,mincal,maxcal;

	for(int i=0;i<m_iPondMeshNum;i++)
	{
		pPondMesh = &m_pCPondMesh[i];

		//	이번에 쓰이지 않을 경우 넘어감
		if(CN3Base::s_CameraData.IsOutOfFrustum(pPondMesh->m_vCenterPo,pPondMesh->m_fRadius)==TRUE)
		{
			pPondMesh->m_bTick2Rand = FALSE;
			continue;
		}
		else pPondMesh->m_bTick2Rand = TRUE;

//		TRACE("Pond Is Chk  ---------- %d \n",i);
		//	기초데이타 작성
		m = pPondMesh->m_iWidthVtx;
		n = pPondMesh->m_iHeightVtx;
		max = pPondMesh->m_fmax;
		min = pPondMesh->m_fmin;
		maxcal = pPondMesh->m_fmaxcal;
		mincal = pPondMesh->m_fmincal;

		memset(m_pfMaxVtx, 0, m_iMaxVtxNum);

		pVtx = pPondMesh->m_pVertices;
		pForceArray = m_pfMaxVtx;
		
		//	계산 
		for (x=1; x<n-1; x++)
		{
			ptmpFArrSub = pForceArray;
			pForceArray += m;
			ptmpForceArray = pForceArray;
			ptmpFArrPlus = ptmpForceArray+m;

			ptmpVtxSub = pVtx;
			pVtx += m;
			ptmpVtx = pVtx;
			ptmpVtxPlus = ptmpVtx+m;

			for (y=1; y<m-1; y++) 
			{
				 //   Kernel looks like this:
				 //
				 //    1/Root2 |    1    | 1/Root2 
				 //   ---------+---------+---------
				 //       1    |    0    |    1  
				 //   ---------+---------+---------
				 //    1/Root2 |    1    | 1/Root2 
				 
				ptmpForceArray++,ptmpFArrPlus++,ptmpFArrSub++;
				ptmpVtx++,ptmpVtxPlus++,ptmpVtxSub++;

				d = ptmpVtx->y - (ptmpVtx-1)->y;
				 if ( d < min ) d = min;	if ( d > max ) d = max;
				 *ptmpForceArray	-= d;
				 *(ptmpForceArray-1)+= d;

				 d = ptmpVtx->y - ptmpVtxSub->y;
				 if ( d < min ) d = min;	if ( d > max ) d = max;
				 *ptmpForceArray	-= d;
				 *ptmpFArrSub		+= d;

				 d = ptmpVtx->y - (ptmpVtx+1)->y;
				 if ( d < min ) d = min;	if ( d > max ) d = max;
				 *ptmpForceArray	-= d;
				 *(ptmpForceArray+1)+= d;

				 d = ptmpVtx->y - ptmpVtxPlus->y;
				 if ( d < min ) d = min;	if ( d > max ) d = max;
				 *ptmpForceArray	-= d;
				 *ptmpFArrPlus		+= d;

				 d = (ptmpVtx->y - (ptmpVtxPlus+1)->y)*ATISQRT;
				 if ( d < mincal ) d = mincal;	if ( d > maxcal ) d = maxcal;
				 *ptmpForceArray	-= d;
				 *(ptmpFArrPlus+1)	+= d;

				 d = (ptmpVtx->y - (ptmpVtxSub-1)->y)*ATISQRT;
				 if ( d < mincal ) d = mincal;	if ( d > maxcal ) d = maxcal;
				 *ptmpForceArray	-= d;
				 *(ptmpFArrSub-1)	+= d;

				 d = (ptmpVtx->y - (ptmpVtxPlus-1)->y)*ATISQRT;
				 if ( d < mincal ) d = mincal;	if ( d > maxcal ) d = maxcal;
				 *ptmpForceArray	-= d;
				 *(ptmpFArrPlus-1)	+= d;

				 d = (ptmpVtx->y - (ptmpVtxSub+1)->y)*ATISQRT;
				 if ( d < mincal ) d = mincal;	if ( d > maxcal ) d = maxcal;
				 *ptmpForceArray	-= d;
				 *(ptmpFArrSub+1)	+= d;
			}
		}

		ptmpForceArray = pPondMesh->m_pfVelocityArray;	//	같은형이라 빌려씀
		pForceArray = m_pfMaxVtx;
		pVtx = pPondMesh->m_pVertices;
		for (x=0; x<pPondMesh->m_iVC; x++)
		{
//			*ptmpForceArray += *pForceArray*0.02f;
			(*ptmpForceArray) += (*pForceArray)*0.001f;
			
			pVtx->y += (*ptmpForceArray);
			if(pVtx->y > pPondMesh->m_pfMaxHeight)
				pVtx->y = pPondMesh->m_pfMaxHeight;

			pForceArray++,pVtx++,ptmpForceArray++;
		}
	}
}

// ===== END WarFare/N3Pond.cpp =====

// ===== BEGIN WarFare/N3Pond.h =====
#line 1 "WarFare/N3Pond.h"
﻿// N3Pond.h: interface for the CN3Pond class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3Pond_H__B9A59A74_B468_4552_8D80_E8AF3FE586E0__INCLUDED_)
#define AFX_N3Pond_H__B9A59A74_B468_4552_8D80_E8AF3FE586E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MAX_PONDMESH_LINE		200
#define MAX_PONDMESH_VERTEX		200*4
#define MAX_POND_TEX	32


#include <N3Base/N3BaseFileAccess.h>

class CN3Pond : public CN3BaseFileAccess
{
public:
	CN3Pond();
	virtual		~CN3Pond();

	struct __VertexPond
	{
	public:
		float x,y,z;
		float nx,ny,nz;
		D3DCOLOR	color;
		float u,v, u2,v2;
		void Set(float sx, float sy,float sz, float snx, float sny, float snz, D3DCOLOR scolor, float su, float sv, float su2, float sv2)
		{
			x = sx, y = sy, z = sz;
			nx = snx, ny = sny, nz = snz;
			color = scolor;
			u = su, v = sv;
			u2 = su2, v2 = sv2;
		}
	};

	class CPongMesh
	{
	public:
		CN3Texture*		m_pTexWave;
		BOOL			m_bTick2Rand;	//	시야에 들어와 tick과rend를 실행결정
		__VertexPond*	m_pVertices;	//	Vertices
		float*			m_pfVelocityArray;	//	계산 저장
		float			m_pfMaxHeight;	//	물결이 어느정도 이상 올라가지 못하게 함
		uint16_t*			m_wpIndex;		//	그림을 그릴 순서
		int				m_iIC;			// Index Buffer Count.
		int				m_iVC;			// Vertex Count.

		int				m_iWidthVtx,m_iHeightVtx;		// 계산에 필요
		float			m_fmin,m_fmax,m_fmaxcal,m_fmincal;

		__Vector3		m_vCenterPo;	//	연못의 중간지점
		float			m_fRadius;		//	연못의 지름

		CPongMesh() {m_bTick2Rand=FALSE;m_pVertices=nullptr,m_wpIndex=nullptr;m_pfVelocityArray=nullptr;m_pTexWave=nullptr;};
		virtual ~CPongMesh() 
		{
			if(m_pVertices) delete []m_pVertices;m_pVertices=nullptr;
			if(m_wpIndex) delete []m_wpIndex;m_wpIndex=nullptr;
			if(m_pfVelocityArray) delete []m_pfVelocityArray;m_pfVelocityArray=nullptr;
			if(m_pTexWave)	{CN3Base::s_MngTex.Delete(&m_pTexWave); m_pTexWave = nullptr;}
		};
	};

public:
	int				m_iPondMeshNum;	//	전체 연못의 갯수
	CPongMesh*		m_pCPondMesh;	//	연못의 정보

	CN3Texture*		m_pTexPond[MAX_POND_TEX];	
	float			m_fTexIndex;

	int				m_iMaxVtxNum;	//	가장 많은 vertices수
	float*			m_pfMaxVtx;		//	물결높이 계산을 위한 임시

public:
	void		Release() override;
	bool		Load(File& file) override;
	void		Render();
	void		Tick();

private:
	void		CheckHeight(float& ChkHeight)
	{
		if ( ChkHeight < -0.01f )	ChkHeight +=  0.01f;
		else if ( ChkHeight >  0.01f )	ChkHeight += -0.01f;
	};

	void		UpdateWaterPositions();
};

#endif // !defined(AFX_N3Pond_H__B9A59A74_B468_4552_8D80_E8AF3FE586E0__INCLUDED_)

// ===== END WarFare/N3Pond.h =====

// ===== BEGIN WarFare/N3River.cpp =====
#line 1 "WarFare/N3River.cpp"
﻿// N3River.cpp: implementation of the CN3River class.
//
//////////////////////////////////////////////////////////////////////
#include "StdAfx.h"
#include "N3River.h"

#include <N3Base/N3Texture.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define WAVE_TOP		0.02f
//#define WAVE_STEP		0.0005f
#define WAVE_STEP		0.001f

CN3River::CN3River()
{
	m_fTexIndex = 0.0f;
	m_pRiverInfo = nullptr;
	m_iRiverCount = 0;
}

CN3River::~CN3River()
{
	if (m_pRiverInfo)
		delete[] m_pRiverInfo, m_pRiverInfo = nullptr;
}

bool CN3River::Load(File& file)
{
	uint16_t wIndex[18] = {4,0,1,4,1,5,5,1,2,5,2,6,6,2,3,6,3,7};

	file.Read(&m_iRiverCount, sizeof(m_iRiverCount));
	if (m_iRiverCount == 0)	return true;
	
	m_pRiverInfo = new _RIVER_INFO[m_iRiverCount];

	_RIVER_INFO	*pInfo = nullptr;
	for (int i=0;i<m_iRiverCount;i++)
	{
		pInfo = m_pRiverInfo+i;
		file.Read(&pInfo->iVC, sizeof(int));
		__ASSERT(pInfo->iVC, "CN3River : nVertexCount is zero!!");
		__ASSERT(pInfo->iVC%4==0, "RiverVertex is a multiple of 4");

		pInfo->pVertices = new __VertexRiver[pInfo->iVC];
		file.Read(pInfo->pVertices, pInfo->iVC*sizeof(__VertexRiver));
		file.Read(&pInfo->iIC, sizeof(int));
		__ASSERT(pInfo->iIC%18==0, "River-Vertex-Index is a multiple of 18");

		int iTexNameLength = 0;
		file.Read(&iTexNameLength, sizeof(int));
		if (iTexNameLength > 0)
		{
			char szTexture[50];
			file.Read(szTexture, iTexNameLength);			// texture name
			szTexture[iTexNameLength] = '\0';

			std::string szTextureFName = fmt::format("misc\\river\\{}", szTexture);

			pInfo->m_pTexWave = s_MngTex.Get(szTextureFName);
			__ASSERT(pInfo->m_pTexWave, "CN3River::texture load failed");
		}


		pInfo->pwIndex = new uint16_t[pInfo->iIC];		
		for (int l=0;l<pInfo->iIC/18;l++)
		{
			for (int j=0;j<18;j++)
			{
				pInfo->pwIndex[l*18+j] = wIndex[j] + l*4;
			}
		}

		// 
		pInfo->pDiff = new _RIVER_DIFF[pInfo->iVC];
		float fAdd = 0.0f;
		float fMul = 0.002f;
		for (int l=0;l<pInfo->iVC;l++)
		{
			pInfo->pDiff[l].fDiff = fAdd;
			if (l%2==0)
				pInfo->pDiff[l].fWeight = 1.0f;
			else
				pInfo->pDiff[l].fWeight = -1.0f;
			if (l%4==0)
			{
				fAdd += fMul;
				if (fAdd > WAVE_TOP)
					fMul = -0.002f;
				else if (fAdd < - WAVE_TOP)
					fMul = 0.002f;
			}
		}

		int j,k;
		__VertexRiver* ptVtx = pInfo->pVertices;
		float StX,EnX,StZ,EnZ;
		StX = ptVtx[0].x,EnX = ptVtx[4].x;
		StZ = ptVtx[0].z,EnZ = ptVtx[pInfo->iVC/4].z;
		for (j=0; j<pInfo->iVC/4; j++)
		{
			for (k=0; k<4; k++)
			{
				if(StX>ptVtx->x) StX = ptVtx->x;
				if(EnX<ptVtx->x) EnX = ptVtx->x;
				if(StZ>ptVtx->z) StZ = ptVtx->z;
				if(EnZ<ptVtx->z) EnZ = ptVtx->z;
				ptVtx++;
			}
		}

		pInfo->m_vCenterPo.Set(((EnX-StX)/2.0f) + StX
							  ,pInfo->pVertices[0].y
							  ,((EnZ-StZ)/2.0f) + StZ);

		if(EnX-StX > EnZ-StZ)
			pInfo->m_fRadius = (float)(EnX-StX)*2.0f;
		else pInfo->m_fRadius = (float)(EnZ-StZ)*2.0f;

	}	

	std::string szFileName;
	for (int i = 0; i < MAX_RIVER_TEX; i++)
	{
		szFileName = fmt::format("misc\\river\\caust{:02}.dxt", i);
		m_pTexRiver[i] = s_MngTex.Get(szFileName);
		__ASSERT(m_pTexRiver[i], "CN3River::texture load failed");
	}

	return true;
}

void CN3River::Render()
{
	if (m_iRiverCount <= 0) return;
	int iTex = (int)m_fTexIndex;
	__ASSERT(iTex < MAX_RIVER_TEX, "River Texture index overflow..");
	if(iTex >= MAX_RIVER_TEX || nullptr == m_pTexRiver[iTex]) return;

	// Backup
	__Matrix44 matWorld, matOld;	matWorld.Identity();
	DWORD dwAlphaEnable, dwSrcBlend, dwDestBlend;
	s_lpD3DDev->GetTransform(D3DTS_WORLD, matOld.toD3D());
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaEnable);
	s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	DWORD dwColor_0, dwColorArg1_0, dwColorArg2_0, dwMipFilter_0;
	DWORD dwColor_1, dwColorArg1_1, dwColorArg2_1, dwMipFilter_1;
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwColor_0);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorArg1_0);
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG2, &dwColorArg2_0);
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_MIPFILTER, &dwMipFilter_0);
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLOROP, &dwColor_1);
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG1, &dwColorArg1_1);
	s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG2, &dwColorArg2_1);
	s_lpD3DDev->GetSamplerState(1, D3DSAMP_MIPFILTER, &dwMipFilter_1);

	// Set
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matWorld.toD3D());

	s_lpD3DDev->SetTexture(0, m_pTexRiver[iTex]->Get());
	s_lpD3DDev->SetTexture(2, nullptr);
	
	s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
    s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );

	s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
    s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);	
	s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE);
    s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT);	
    s_lpD3DDev->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_NONE );
    s_lpD3DDev->SetSamplerState( 1, D3DSAMP_MIPFILTER, D3DTEXF_NONE );

	s_lpD3DDev->SetFVF(D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE | D3DFVF_TEX2);
	_RIVER_INFO		*pInfo = nullptr;
	for (int i=0;i<m_iRiverCount;i++)
	{
		pInfo = m_pRiverInfo + i;
		if(pInfo->m_bTick2Rand==TRUE)
		{
			if(pInfo->m_pTexWave) s_lpD3DDev->SetTexture(1, pInfo->m_pTexWave->Get());
			else s_lpD3DDev->SetTexture(1, nullptr);

			s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, pInfo->iVC, pInfo->iIC/3, pInfo->pwIndex, D3DFMT_INDEX16, pInfo->pVertices, sizeof(__VertexRiver));
		}
	}

	// restore 
	s_lpD3DDev->SetTransform(D3DTS_WORLD, matOld.toD3D());
	s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaEnable);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);

	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwColor_0);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwColorArg1_0);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, dwColorArg2_0);
	s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER, dwMipFilter_0);
	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, dwColor_1);
	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, dwColorArg1_1);
	s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, dwColorArg2_1);
	s_lpD3DDev->SetSamplerState(1, D3DSAMP_MIPFILTER, dwMipFilter_1);
}

void CN3River::Tick()
{
	if (m_iRiverCount == 0)return;

	_RIVER_INFO	*pInfo=nullptr;
	for (int i=0;i<m_iRiverCount;i++)
	{
		pInfo = m_pRiverInfo+i;
		if(CN3Base::s_CameraData.IsOutOfFrustum(pInfo->m_vCenterPo,pInfo->m_fRadius)==TRUE)
		{
			pInfo->m_bTick2Rand = FALSE;
			continue;
		}
		else pInfo->m_bTick2Rand = TRUE;

		for (int j=0;j<pInfo->iVC;j++)
		{
			(pInfo->pVertices+j)->v += 0.01f*s_fSecPerFrm;
			(pInfo->pVertices+j)->v2 += 0.01f*s_fSecPerFrm;
		}
	}
	

	m_fTexIndex += s_fSecPerFrm*15.0f;
	if (m_fTexIndex >= 32.0f)
	{
		m_fTexIndex -= 32.0f;
	}

	static float fWave = 0.0f;
	fWave += s_fSecPerFrm;
	if (fWave > 0.1f)
	{
		fWave = 0.0f;
		UpdateWaterPositions();
	}
}

void CN3River::UpdateWaterPositions()
{
	if(m_iRiverCount == 0)return;

	_RIVER_INFO		*pInfo = nullptr;
	_RIVER_DIFF		*pDiff = nullptr;
	__VertexRiver	*pVertex;
	int tmp;

	for (int i=0;i<m_iRiverCount;i++)
	{
		pInfo = m_pRiverInfo + i;
		__ASSERT(pInfo, "pInfo is null");
		pDiff = pInfo->pDiff;
		
		pVertex = pInfo->pVertices;
		for (int j=0;j<pInfo->iVC; j++)
		{
			// berserk
			// For optimizing.
			tmp = j%4;
			if (tmp==0 || tmp==3)	
			{
				pDiff++;
				continue;
			}

			pDiff->fDiff += WAVE_STEP*pDiff->fWeight;
			if (pDiff->fDiff > WAVE_TOP)
				pDiff->fWeight = -1.0f;
			else if (pDiff->fDiff < -WAVE_TOP)
				pDiff->fWeight = 1.0f;

			pVertex[j].y += pDiff->fDiff;
			pDiff++;
		}
	}
}

// ===== END WarFare/N3River.cpp =====

// ===== BEGIN WarFare/N3River.h =====
#line 1 "WarFare/N3River.h"
﻿// N3River.h: interface for the CN3River class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3RIVER_H__D0171C53_F631_4EC3_9D42_B4B754093FAC__INCLUDED_)
#define AFX_N3RIVER_H__D0171C53_F631_4EC3_9D42_B4B754093FAC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>

#define MAX_RIVER_TEX	32

class CN3River : public CN3Base  // CN3RiverPatch를 관리하는 클래스
{
public:
	CN3River();
	virtual ~CN3River();

	struct __VertexRiver
	{
	public:
		float x,y,z;
		float nx,ny,nz;
		D3DCOLOR	color;
		float u,v, u2,v2;
		void Set(float sx, float sy,float sz, float snx, float sny, float snz, D3DCOLOR scolor, float su, float sv, float su2, float sv2)
		{
			x = sx, y = sy, z = sz;
			nx = snx, y = sny, z = sny;
			color = scolor;
			u = su, v = sv;
			u2 = su2, v2 = sv2;
		}
	};

	struct _RIVER_DIFF
	{
		float	fDiff;
		float	fWeight;
	};

	struct _RIVER_INFO
	{
		int iVC;
		int iIC;
		__VertexRiver		*pVertices;
		uint16_t				*pwIndex;
		_RIVER_DIFF			*pDiff;

		BOOL				m_bTick2Rand;
		__Vector3			m_vCenterPo;	//	강의 중간지점
		float				m_fRadius;		//	강의 지름

		CN3Texture			*m_pTexWave;

		_RIVER_INFO() {
			pVertices = nullptr; pwIndex = nullptr; pDiff = nullptr;
			m_pTexWave = nullptr;
		}
		~_RIVER_INFO() {
			if (pVertices)
				delete[] pVertices, pVertices = nullptr;
			if (pwIndex)
				delete[] pwIndex, pwIndex = nullptr;
			if (pDiff)
				delete[] pDiff, pDiff = nullptr;
			m_pTexWave = nullptr;
		}
	};

protected:
	_RIVER_INFO			*m_pRiverInfo;
	int					m_iRiverCount;

	CN3Texture			*m_pTexRiver[MAX_RIVER_TEX];


	float				m_fTexIndex;
	void				UpdateWaterPositions();
public:
	virtual bool	Load(File& file);
	void			Render();
	void			Tick();
};

#endif // !defined(AFX_N3RIVER_H__D0171C53_F631_4EC3_9D42_B4B754093FAC__INCLUDED_)

// ===== END WarFare/N3River.h =====

// ===== BEGIN WarFare/N3Terrain.cpp =====
#line 1 "WarFare/N3Terrain.cpp"
﻿//
// N3Terrain.cpp: implementation of the CLyTerrain class.
//	2001. 10. 22.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3Terrain.h"
#include "N3TerrainPatch.h"
#include "PlayerMySelf.h"
#include "GameBase.h"
#include "GameProcedure.h"
#include "UILoading.h"

#include "N3River.h"
#include "N3Pond.h"

#include <FileIO/FileReader.h>

#include <stdio.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const float COLLISION_BOX = 100.0f;

//
// Construction/Destruction
//
CN3Terrain::CN3Terrain()
{
	m_Material.Init();
	m_ShadeMode = D3DSHADE_GOURAUD;
	m_FillMode = D3DFILL_SOLID;
	m_iLodLevel = MIN_LOD_LEVEL;

	m_ppPatch = nullptr;

	m_pat_CenterPos.x = m_pat_CenterPos.y = 0;
	m_pat_LBPos.x = m_pat_LBPos.y = 0;
	m_pat_PrevLBPos.x = m_pat_PrevLBPos.y = 0;

	SetRectEmpty(&m_pat_BoundRect);
	m_iNumPatch = 0;

	m_pMapData = nullptr;
	m_ti_MapSize = 0;
	m_pat_MapSize = 0;

	//m_ppIsLightMap = nullptr;
	//m_pppLightMapTex = nullptr;

	m_ti_CenterPos.x = m_ti_CenterPos.y = 0;
	m_ti_PrevCenterPos = m_ti_CenterPos;

	m_ppPatchRadius = nullptr;
	m_ppPatchMiddleY = nullptr;

	ZeroMemory(m_pGrassFileName, MAX_PATH);

	for (int i = 0; i < MAX_GRASS; i++)
		ZeroMemory(m_pGrassTextureName[i], MAX_PATH);
	m_iNumGrass = 0;

	m_NumTileTex = 0;
	m_pTileTex = nullptr;
	m_ppColorMapTex = nullptr;
	m_iNumColorMap = 0;

	float TileDirU[8][4] = {
		{ 0.0f,	1.0f, 0.0f,	1.0f},		//[up][LT, RT, LB, RB]
		{ 0.0f,	0.0f, 1.0f, 1.0f},		//[right][ // ]
		{ 1.0f,	0.0f, 1.0f, 0.0f},		//[left][ // ]
		{ 1.0f, 1.0f, 0.0f,	0.0f},		//[bottom][ // ]

		{ 1.0f,	0.0f, 1.0f,	0.0f},		//[up_mirr][LT, RT, LB, RB]
		{ 0.0f,	0.0f, 1.0f, 1.0f},		//[right_mirr][ // ]
		{ 0.0f,	1.0f, 0.0f, 1.0f},		//[left_mirr][ // ]
		{ 1.0f, 1.0f, 0.0f,	0.0f}		//[bottom_mirr][ // ]
	};
	memcpy(m_fTileDirU, TileDirU, sizeof(float) * 8 * 4);

	float TileDirV[8][4] = {
		{ 0.0f, 0.0f, 1.0f, 1.0f},		//[up][ // ]
		{ 1.0f, 0.0f, 1.0f, 0.0f},		//[right][ // ]
		{ 1.0f, 1.0f, 0.0f, 0.0f},		//[left][ // ]
		{ 0.0f, 1.0f, 0.0f, 1.0f},		//[bottom][ // ]

		{ 0.0f, 0.0f, 1.0f, 1.0f},		//[up_mirr][ // ]
		{ 0.0f, 1.0f, 0.0f, 1.0f},		//[right_mirr][ // ]
		{ 1.0f, 1.0f, 0.0f, 0.0f},		//[left_mirr][ // ]
		{ 1.0f, 0.0f, 1.0f, 0.0f}		//[bottom_mirr][ // ]
	};
	memcpy(m_fTileDirV, TileDirV, sizeof(float) * 8 * 4);

	MakeDistanceTable();

	m_pGrassAttr = nullptr;
	m_pGrassNum = nullptr;

	m_pRiver = nullptr;
	m_pPond = nullptr;
	m_pNormal = nullptr;

	m_bAvailableTile = true;
}

CN3Terrain::~CN3Terrain()
{
	Release();
}


//
//	MakeDistanceTable
//	거리를 계산하지 말고 테이블에서 가져올 수 있게 미리 테이블 생성..
//	정수 단위 거리..
//
void CN3Terrain::MakeDistanceTable()
{
	int x, z;
	double dist;
	for (x = 0;x < DISTANCE_TABLE_SIZE;x++)
	{
		for (z = 0;z < DISTANCE_TABLE_SIZE;z++)
		{
			dist = sqrt((double) ((x * x) + (z * z))) + 0.6;
			m_iDistanceTable[x][z] = (int) dist;
		}
	}
}


//
//	Release....
//
void CN3Terrain::Release()
{
	int x;

	if (m_pGrassAttr)
	{
		//free(m_pGrassAttr);
		GlobalFree(m_pGrassAttr);
		m_pGrassAttr = nullptr;
	}

	if (m_pGrassNum)
	{
		//free(m_pGrassAttr);
		GlobalFree(m_pGrassNum);
		m_pGrassNum = nullptr;
	}

//	{
//		for(x=0;x<m_ti_MapSize;x++)
//		{
//			if(m_ppGrassAttr[x])
//			{
//				delete[] m_ppGrassAttr[x];
//				m_ppGrassAttr[x] = nullptr;
//			}
//		}
//		delete[] m_ppGrassAttr;
//		m_ppGrassAttr = nullptr;
//	}

	if (m_pRiver)
	{
		m_pRiver->Release();
		delete m_pRiver;
		m_pRiver = nullptr;
	}

	if (m_pPond)
	{
		delete m_pPond;
		m_pPond = nullptr;
	}

	if (m_pTileTex)
	{
//		for(x=0;x<m_NumTileTex;x++)
//			m_pTileTex[x].Release();
		delete[] m_pTileTex;
		m_pTileTex = nullptr;
	}

	if (m_ppColorMapTex)
	{
		for (x = 0;x < m_iNumColorMap;x++)
		{
//			for(z=0;z<m_iNumColorMap;z++)
//			{
//				m_ppColorMapTex[x][z].Release();
//			}
			delete[] m_ppColorMapTex[x];
			m_ppColorMapTex[x] = nullptr;
		}
		delete[] m_ppColorMapTex;
		m_ppColorMapTex = nullptr;
	}

	if (m_ppPatch)
	{
		for (x = 0;x < m_iNumPatch;x++)
		{
//			for(z=0;z<m_iNumPatch;z++)
//			{
//				m_ppPatch[x][z].Release();
//			}
			delete[] m_ppPatch[x];
			m_ppPatch[x] = nullptr;
		}
		delete[] m_ppPatch;
		m_ppPatch = nullptr;
	}

	if (m_pMapData)
	{
		//free(m_pMapData);
		GlobalFree(m_pMapData);
		m_pMapData = nullptr;
	}

	if (m_pNormal)
	{
		GlobalFree(m_pNormal);
		m_pNormal = nullptr;
	}

	if (m_ppPatchRadius)
	{
		for (x = 0;x < m_pat_MapSize;x++)
		{
			delete[] m_ppPatchRadius[x];
			m_ppPatchRadius[x] = nullptr;
		}
		delete[] m_ppPatchRadius;
		m_ppPatchRadius = nullptr;
	}

	if (m_ppPatchMiddleY)
	{
		for (x = 0;x < m_pat_MapSize;x++)
		{
			delete[] m_ppPatchMiddleY[x];
			m_ppPatchMiddleY[x] = nullptr;
		}
		delete[] m_ppPatchMiddleY;
		m_ppPatchMiddleY = nullptr;
	}

	int z;
	for (x = 0;x < 3;x++)
	{
		for (z = 0;z < 3;z++)
		{
			stlMap_N3TexIt itBegin = m_LightMapPatch[x][z].begin();
			stlMap_N3TexIt itEnd = m_LightMapPatch[x][z].end();
			stlMap_N3TexIt it;

			for (it = itBegin; it != itEnd; it++)
			{
				CN3Texture* pTex = (*it).second;
				if (pTex) delete pTex;
			}
			m_LightMapPatch[x][z].clear();
		}
	}

	CN3BaseFileAccess::Release();
}


//
//	Init...
//
void CN3Terrain::Init()
{
	Release();

	TestAvailableTile();

	m_Material.Init();
	m_ShadeMode = D3DSHADE_GOURAUD;
	m_FillMode = D3DFILL_SOLID;
	//m_FillMode = D3DFILL_WIREFRAME;

	m_pat_CenterPos.x = m_pat_CenterPos.y = -100;
	m_pat_LBPos.x = m_pat_LBPos.y = -100;
	m_pat_PrevLBPos.x = m_pat_PrevLBPos.y = -100;

	SetRectEmpty(&m_pat_BoundRect);
	//m_pat_Center2Side = ((int)CN3Base::s_CameraData.fFP / (PATCH_TILE_SIZE * TILE_SIZE)) + 1;
//	m_pat_Center2Side = 17;		// CN3Base::s_CameraData.fFP = 512 라고 가정할때...
	m_pat_Center2Side = 33;		// CN3Base::s_CameraData.fFP = 1024 라고 가정할때...

	m_iNumPatch = (m_pat_Center2Side << 1) + 1;

	int x;
	m_ppPatch = new CN3TerrainPatch * [m_iNumPatch];
	for (x = 0;x < m_iNumPatch;x++)
	{
		m_ppPatch[x] = new CN3TerrainPatch[m_iNumPatch];
	}
	int z;
	for (x = 0;x < m_iNumPatch;x++)
	{
		for (z = 0;z < m_iNumPatch;z++)
		{
			m_ppPatch[x][z].Init(this);
		}
	}

	m_pBaseTex.LoadFromFile("Misc\\Terrain_Base.bmp");

	m_iLodLevel = MIN_LOD_LEVEL;
	SetLODLevel(3);

	m_pMapData = nullptr;
	m_pNormal = nullptr;
	m_ti_MapSize = 0;
	m_pat_MapSize = 0;

	m_ti_CenterPos.x = m_ti_CenterPos.y = -100;
	m_ti_PrevCenterPos = m_ti_CenterPos;

	ZeroMemory(m_pGrassFileName, MAX_PATH);
	for (int i = 0; i < MAX_GRASS; i++)
		ZeroMemory(m_pGrassTextureName[i], MAX_PATH);
	m_iNumGrass = 0;

	m_NumTileTex = 0;
	m_pTileTex = nullptr;
	m_ppColorMapTex = nullptr;
	m_iNumColorMap = 0;

	m_pGrassAttr = nullptr;
	m_pGrassNum = nullptr;

	m_pRiver = new CN3River();
	m_pPond = new CN3Pond();
}


//
//	글픽카드가 타일맵을 그릴 수 있는지 없는지 검사...
//
void CN3Terrain::TestAvailableTile()
{
	m_bAvailableTile = true;

	if (CN3Base::s_DevCaps.MaxTextureBlendStages < 3 ||
		((CN3Base::s_DevCaps.PrimitiveMiscCaps & D3DPMISCCAPS_BLENDOP) == 0))
	{
#ifdef _N3GAME
		CLogWriter::Write("terrain tile not supported..");
#endif
		m_bAvailableTile = false;
	}

	return;

	DWORD ColorOP[3], ColorArg1[3], ColorArg2[3];

	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &ColorOP[0]);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &ColorArg1[0]);

	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLOROP, &ColorOP[1]);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG1, &ColorArg1[1]);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG2, &ColorArg2[1]);

	CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLOROP, &ColorOP[2]);
	CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLORARG1, &ColorArg1[2]);
	CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLORARG2, &ColorArg2[2]);

	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_ADD);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLOROP, D3DTOP_MODULATE);
	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG1, D3DTA_CURRENT);
	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

	DWORD dwNumPasses;
	HRESULT hr;
	hr = CN3Base::s_lpD3DDev->ValidateDevice(&dwNumPasses);

	if (hr & D3DERR_TOOMANYOPERATIONS)
	{
		m_bAvailableTile = false;
	}
	if (hr & D3DERR_UNSUPPORTEDCOLORARG)
	{
		m_bAvailableTile = false;
	}
	if (hr & D3DERR_UNSUPPORTEDCOLOROPERATION)
	{
		m_bAvailableTile = false;
	}

	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, ColorOP[0]);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, ColorArg1[0]);

	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, ColorOP[1]);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, ColorArg1[1]);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, ColorArg2[1]);

	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLOROP, ColorOP[2]);
	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG1, ColorArg1[2]);
	CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG2, ColorArg2[2]);
}


//
//	Load...
//
bool CN3Terrain::Load(File& file)
{
	std::string szFNBackup = m_szFileName; // Init 를 하고 나면 파일 이름이 없어진다.... 그래서...

	Init();

	if (m_iFileFormatVersion >= N3FORMAT_VER_1264)
	{
		int iIdk0;
		file.Read(&iIdk0, sizeof(int));

		int iNL;
		file.Read(&iNL, sizeof(int));

		if (iNL > 0)
		{
			m_szName.assign(iNL, '\0');
			file.Read(&m_szName[0], iNL);
		}
		else
		{
			m_szName.clear();
		}
	}

	m_szFileName = szFNBackup;

	CUILoading* pUILoading = nullptr;
#ifdef _N3GAME
	pUILoading = CGameProcedure::s_pUILoading; // 로딩바..
#endif
	if (pUILoading) pUILoading->Render("Allocating Terrain...", 0);

	file.Read(&(m_ti_MapSize), sizeof(int));
	m_pat_MapSize = (m_ti_MapSize - 1) / PATCH_TILE_SIZE;

	int x, z;

	//m_pMapData = (LPMAPDATA)malloc(sizeof(MAPDATA)*m_ti_MapSize*m_ti_MapSize);
	m_pMapData = (LPMAPDATA) GlobalAlloc(GMEM_FIXED, sizeof(MAPDATA) * m_ti_MapSize * m_ti_MapSize);
#ifdef _N3GAME
	if (m_pMapData == nullptr) CLogWriter::Write("Terrain Error : MapData Memory Allocation Failed..-.-");
#endif
	__ASSERT(m_pMapData, "MapData Memory Allocation Failed..-.-");
	file.Read(m_pMapData, sizeof(MAPDATA) * m_ti_MapSize * m_ti_MapSize);

	m_pNormal = (__Vector3*) GlobalAlloc(GMEM_FIXED, sizeof(__Vector3) * m_ti_MapSize * m_ti_MapSize);
#ifdef _N3GAME
	if (m_pNormal == nullptr) CLogWriter::Write("Terrain Error : Normal Vector Memory Allocation Failed..-.-");
#endif
	__ASSERT(m_pNormal, "Normal Vector Memory Allocation Failed..-.-");
	SetNormals();

	if (pUILoading) pUILoading->Render("", 100);

	//patch middleY & radius...

	m_ppPatchRadius = new float* [m_pat_MapSize];
	m_ppPatchMiddleY = new float* [m_pat_MapSize];
	for (x = 0;x < m_pat_MapSize;x++)
	{
		m_ppPatchMiddleY[x] = new float[m_pat_MapSize];
		m_ppPatchRadius[x] = new float[m_pat_MapSize];
	}

	if (pUILoading) pUILoading->Render("Loading Terrain Patch Data...", 0);

	std::string szLoadingBuff;
	for (x = 0; x < m_pat_MapSize; x++)
	{
		for (z = 0; z < m_pat_MapSize; z++)
		{
			file.Read(&m_ppPatchMiddleY[x][z], sizeof(float));
			file.Read(&m_ppPatchRadius[x][z], sizeof(float));
		}

		int iLoading = (x + 1) * 100 / m_pat_MapSize;
		szLoadingBuff = fmt::format("Loading Terrain Patch Data... {} %", iLoading);

		if (pUILoading != nullptr)
			pUILoading->Render(szLoadingBuff, iLoading);
	}

//	m_ppGrassAttr = new uint8_t* [m_ti_MapSize];
//	for(x=0; x<m_ti_MapSize; x++)
//	{
//		m_ppGrassAttr[x] = new uint8_t[m_ti_MapSize];
//		file.Read(m_ppGrassAttr[x], sizeof(uint8_t)*m_ti_MapSize);
//
//		if(!(x%256))
//		{
//			pUILoading->SetValue(20 + 7 * x / m_ti_MapSize); 
//			pUILoading->Render();
//		}
//
//	}

	//m_pGrassAttr = (uint8_t*)malloc(sizeof(uint8_t)*m_ti_MapSize*m_ti_MapSize);
	m_pGrassAttr = (uint8_t*) GlobalAlloc(GMEM_FIXED, sizeof(uint8_t) * m_ti_MapSize * m_ti_MapSize);
#ifdef _N3GAME
	if (m_pGrassAttr == nullptr) CLogWriter::Write("Terrain Error : GrassAttr Data Memory Allocation Failed..-.-");
#endif
	__ASSERT(m_pGrassAttr, "GrassAttr Data Memory Allocation Failed..-.-");
	file.Read(m_pGrassAttr, sizeof(uint8_t) * m_ti_MapSize * m_ti_MapSize);

	//^^v풀갯수 정보 넣기...(조만간 넣어라..)
	m_pGrassNum = (uint8_t*) GlobalAlloc(GMEM_FIXED, sizeof(uint8_t) * m_ti_MapSize * m_ti_MapSize);
#ifdef _N3GAME
	if (m_pGrassNum == nullptr) CLogWriter::Write("Terrain Error : GrassNum Data Memory Allocation Failed..-.-");
#endif
	__ASSERT(m_pGrassNum, "GrassNum Data Memory Allocation Failed..-.-");
	//file.Read(m_pGrassNum, sizeof(uint8_t)*m_ti_MapSize*m_ti_MapSize);	
	memset(m_pGrassNum, 5, sizeof(uint8_t) * m_ti_MapSize * m_ti_MapSize);

	// load colormap....
	file.Read(m_pGrassFileName, MAX_PATH);
	LoadGrassInfo();

	LoadTileInfo(file);

	// load lightmap..
	if (pUILoading != nullptr)
		pUILoading->Render("Loading Lightmap Data...", 0);

	int NumLightMap = 0;
	file.Read(&NumLightMap, sizeof(int));

	int16_t sx, sz;
	CN3Texture* pTmpTex = new CN3Texture;
	for (int i = 0; i < NumLightMap; i++)
	{
		file.Read(&sx, sizeof(int16_t));
		file.Read(&sz, sizeof(int16_t));
		pTmpTex->Load(file);

		//loading bar...
		int iLoading = (i + 1) * 100 / NumLightMap;
		szLoadingBuff = fmt::format("Loading Lightmap Data... {} %", iLoading);
		if (pUILoading != nullptr)
			pUILoading->Render(szLoadingBuff, iLoading);
	}
	delete pTmpTex;

	if (pUILoading != nullptr)
		pUILoading->Render("Loading River Data...", 0);

	m_pRiver->Load(file); // 맵데이터 올때까지만 잠시만 막자..2002.11.15
	m_pPond->Load(file);

	if (pUILoading != nullptr)
		pUILoading->Render("", 100);
	return true;
}


//
//
//
void CN3Terrain::SetNormals()
{
	return;
/*
	int x,z;
	__Vector3 vNormalTmp(0.0f, 0.0f, 0.0f);
	__Vector3 V1, V2;
	for(x=0;x<m_ti_MapSize;x++)
	{
		for(z=0;z<m_ti_MapSize;z++)
		{
			if( x==0 || z==0 || x==(m_ti_MapSize-1) || z==(m_ti_MapSize-1) )
			{
				m_pNormal[z + x*m_ti_MapSize].Set(0.0f, 1.0f, 0.0f);
			}
			else
			{
				int c = x*m_ti_MapSize + z;
				if ((x+z)%2==1)
				{
					int u,v;
					for(int i=0;i<4;i++)
					{
						if(i==0) { u = x*m_ti_MapSize + (z+1); v = (x+1)*m_ti_MapSize + z; }
						else if(i==1) { u = (x+1)*m_ti_MapSize + z; v = x*m_ti_MapSize + (z-1); }
						else if(i==2) { u = x*m_ti_MapSize + (z-1); v = (x-1)*m_ti_MapSize + z; }
						else if(i==3) { u = (x-1)*m_ti_MapSize + z; v = x*m_ti_MapSize + (z+1); }
					}

					V1.Set(0.0f, m_pMapData[u].fHeight - m_pMapData[c].fHeight, 4.0f);
					V2.Set(4.0f, m_pMapData[v].fHeight - m_pMapData[c].fHeight, 0.0f);
					vNormalTmp.Cross(V1, V2);
					vNormalTmp.Normalize();



				}
			}
		}
	}
*/
}


//
//
//
uint16_t CN3Terrain::GetGrassAttr(int x, int z)
{
	uint16_t Attr;
	if (x < 0 || x >= m_ti_MapSize || z < 0 || z >= m_ti_MapSize) return 0;
	if (m_pGrassAttr && m_pGrassNum)
	{
		Attr = (((uint16_t) m_pGrassAttr[x * m_ti_MapSize + z]) << 8) + m_pGrassNum[x * m_ti_MapSize + z];
		return Attr;
	}
	return 0;
}


//
//
//
MAPDATA	CN3Terrain::GetMapData(int x, int z)
{
	MAPDATA MapData;
	if (x < 0 || x >= m_ti_MapSize || z < 0 || z >= m_ti_MapSize) return MapData;
	MapData = m_pMapData[(x * m_ti_MapSize) + z];

	return MapData;
}


//
//
//
void CN3Terrain::LoadGrassInfo()
{
	CUILoading* pUILoading = nullptr;
#ifdef _N3GAME
	pUILoading = CGameProcedure::s_pUILoading; // 로딩바..
#endif
	if (pUILoading) pUILoading->Render("Loading Terrain Grass Data...", 0);

	m_iNumGrass = 0;
	if (strcmp(m_pGrassFileName, "") == 0)
	{
		ZeroMemory(m_pGrassAttr, sizeof(uint8_t) * m_ti_MapSize * m_ti_MapSize);
		return;
	}

	char szDrive[_MAX_DRIVE];
	char szDir[_MAX_DIR] = {}, szGrassDir[_MAX_DIR] = {},
		szModuleFilePath[_MAX_PATH] = {}, szFullPath[_MAX_PATH] = {};
	GetModuleFileName(nullptr, szModuleFilePath, _MAX_PATH);
	_splitpath(szModuleFilePath, szDrive, szDir, nullptr, nullptr);

	strcpy(szGrassDir, "misc\\grass");
	_makepath(szFullPath, szDrive, szGrassDir, m_pGrassFileName, "grs");

	FileReader file;
	if (!file.OpenExisting(szFullPath))
		return;

	char Buff[80] = {};
	if (!file.Read(Buff, 80))
		return;

	if (strcmp(Buff, "GrassInfoFile") != 0)
		return;

	if (!file.Read(&m_iNumGrass, sizeof(int)))
		return;

	int id;
	char FileName[MAX_PATH] = {}, szDxtFullPath[MAX_PATH] = {};
	std::string szLoadingBuff;

	for (int i = 0; i < m_iNumGrass; i++)
	{
		if (!file.Read(&id, sizeof(int)))
			return;

		if (!file.Read(FileName, MAX_PATH))
			return;

		_makepath(szDxtFullPath, szDrive, szGrassDir, FileName, nullptr);
		strcpy(m_pGrassTextureName[Log2(id)], szDxtFullPath);

		//loading bar...
		int iLoading = (i + 1) * 100 / m_iNumGrass;
		szLoadingBuff = fmt::format("Loading Terrain Grass Data... {} %", iLoading);
		if (pUILoading != nullptr)
			pUILoading->Render(szLoadingBuff, iLoading);
	}
}


//
//
//
void CN3Terrain::LoadTileInfo(File& file)
{
	CUILoading* pUILoading = CGameProcedure::s_pUILoading; // 로딩바..
	if (pUILoading != nullptr)
		pUILoading->Render("Loading Terrain Tile Data...", 0);

	file.Read(&m_NumTileTex, sizeof(uint32_t));
	if (m_NumTileTex == 0)
		return;

	m_pTileTex = new CN3Texture[m_NumTileTex];

	int NumTileTexSrc;
	file.Read(&NumTileTexSrc, sizeof(int));
	if (NumTileTexSrc == 0)
		return;

	char** SrcName = new char* [NumTileTexSrc];
	for (int i = 0; i < NumTileTexSrc; i++)
	{
		SrcName[i] = new char[MAX_PATH];
		file.Read(SrcName[i], MAX_PATH);
	}

	int16_t SrcIdx, TileIdx;
	std::string szLoadingBuff;
	for (uint32_t i = 0; i < m_NumTileTex; i++)
	{
		file.Read(&SrcIdx, sizeof(int16_t));
		file.Read(&TileIdx, sizeof(int16_t));

		// NOTE: kinda a temp thing...
		m_pTileTex[i].m_iFileFormatVersion = m_iFileFormatVersion;

		FileReader gttFile;
		if (!gttFile.OpenExisting(SrcName[SrcIdx]))
			continue;

		for (int j = 0; j < TileIdx; j++)
		{
//			m_pTileTex[i].m_iLOD = s_Options.iTexLOD_Terrain; // LOD 적용후 읽기..
//			m_pTileTex[i].Load(gttFile);// 앞에 있는 쓸때 없는 것들...
			m_pTileTex[i].SkipFileHandle(gttFile);// 앞에 있는 쓸때 없는 것들...
		}
		m_pTileTex[i].m_iLOD = s_Options.iTexLOD_Terrain; // LOD 적용후 읽기..
		m_pTileTex[i].Load(gttFile);// 진짜 타일...

		//loading bar...
		int iLoading = (i + 1) * 100 / m_NumTileTex;
		szLoadingBuff = fmt::format("Loading Terrain Tile Data... {} %", iLoading);
		if (pUILoading != nullptr)
			pUILoading->Render(szLoadingBuff, iLoading);
	}

	for (int i = 0; i < NumTileTexSrc; i++)
	{
		delete[] SrcName[i];
		SrcName[i] = nullptr;
	}

	delete[] SrcName;
}


//
//	lod level 설정..
//	default는 3...
//	min = 0, max = 10..
//
bool CN3Terrain::SetLODLevel(int level)
{
	if (level == m_iLodLevel) return false;
	m_iLodLevel = level;

	if (m_iLodLevel < 2) m_iLodLevel = 2;

	int x, z;
	int dist;
	for (x = 0;x < m_iNumPatch;x++)
	{
		for (z = 0;z < m_iNumPatch;z++)
		{
			dist = m_iDistanceTable[std::abs(m_pat_Center2Side - x)][std::abs(m_pat_Center2Side - z)];
			if (dist <= m_iLodLevel) m_ppPatch[x][z].SetLevel(1);
			else if (dist <= m_iLodLevel + 3) m_ppPatch[x][z].SetLevel(2);
			else m_ppPatch[x][z].SetLevel(3);
		}
	}

	SetBlunt();

	return true;
}


//
//	SetBlunt...
//	각 패치들 그릴방법 정하기..어느면을 무디게 할것인지..
//
void CN3Terrain::SetBlunt()
{
	for (int x = 0;x < m_iNumPatch;x++)
	{
		for (int z = 0;z < m_iNumPatch;z++)
		{
			m_ppPatch[x][z].m_IsBlunt[0] = true;
			m_ppPatch[x][z].m_IsBlunt[1] = true;
			m_ppPatch[x][z].m_IsBlunt[2] = true;
			m_ppPatch[x][z].m_IsBlunt[3] = true;
			if (m_ppPatch[x][z].GetLevel() == 1)
			{
				m_ppPatch[x][z].m_IsBlunt[0] = false;
				m_ppPatch[x][z].m_IsBlunt[1] = false;
				m_ppPatch[x][z].m_IsBlunt[2] = false;
				m_ppPatch[x][z].m_IsBlunt[3] = false;
				continue;
			}

			if (m_ppPatch[x][z].GetLevel() == 2)
			{
				if (x > 0)
				{
					if (m_ppPatch[x][z].GetLevel() > m_ppPatch[x - 1][z].GetLevel()) m_ppPatch[x][z].m_IsBlunt[0] = false;
				}
				if ((z + 1) < m_iNumPatch)
				{
					if (m_ppPatch[x][z].GetLevel() > m_ppPatch[x][z + 1].GetLevel()) m_ppPatch[x][z].m_IsBlunt[1] = false;
				}
				if ((x + 1) < m_iNumPatch)
				{
					if (m_ppPatch[x][z].GetLevel() > m_ppPatch[x + 1][z].GetLevel()) m_ppPatch[x][z].m_IsBlunt[2] = false;
				}
				if (z > 0)
				{
					if (m_ppPatch[x][z].GetLevel() > m_ppPatch[x][z - 1].GetLevel()) m_ppPatch[x][z].m_IsBlunt[3] = false;
				}
				continue;
			}

			if (x > 0)
			{
				if (m_ppPatch[x][z].GetLevel() >= m_ppPatch[x - 1][z].GetLevel()) m_ppPatch[x][z].m_IsBlunt[0] = false;
			}
			if ((z + 1) < m_iNumPatch)
			{
				if (m_ppPatch[x][z].GetLevel() >= m_ppPatch[x][z + 1].GetLevel()) m_ppPatch[x][z].m_IsBlunt[1] = false;
			}
			if ((x + 1) < m_iNumPatch)
			{
				if (m_ppPatch[x][z].GetLevel() >= m_ppPatch[x + 1][z].GetLevel()) m_ppPatch[x][z].m_IsBlunt[2] = false;
			}
			if (z > 0)
			{
				if (m_ppPatch[x][z].GetLevel() >= m_ppPatch[x][z - 1].GetLevel()) m_ppPatch[x][z].m_IsBlunt[3] = false;
			}
		}
	}
}


//
//	Tick..
//
void CN3Terrain::Tick()
{
	int iLOD = 0; // LOD 수준 계산.. 나중에 계산식을 바꾸어야 한다.
	iLOD = (int) (3.0f * s_CameraData.fFP / 512.0f);
	bool ChangeLOD = this->SetLODLevel(iLOD);

	m_pat_PrevLBPos = m_pat_LBPos;
	m_ti_PrevCenterPos = m_ti_CenterPos;

	bool bMovePatch = CheckMovePatch();
	if (bMovePatch || ChangeLOD)
	{
		DispositionPatch();
	}

	bool bChangeBound = CheckBound();

	int x, z;
	if ((bMovePatch) || (bChangeBound) || ChangeLOD)
	{
		for (x = m_pat_BoundRect.left; x <= m_pat_BoundRect.right; x++)
		{
			for (z = m_pat_BoundRect.top; z <= m_pat_BoundRect.bottom; z++)
			{
				if (x < 0 || z < 0) continue;
				m_ppPatch[x][z].Tick();
			}
		}
	}
	if (m_pRiver) m_pRiver->Tick();
	if (m_pPond) m_pPond->Tick();
}


//
//	CheckMovePatch
//	패치단위의 이동이 이루어 졌는지...
//
bool CN3Terrain::CheckMovePatch()
{
	m_ti_CenterPos.x = Real2Tile(CN3Base::s_CameraData.vEye.x);
	m_ti_CenterPos.y = Real2Tile(CN3Base::s_CameraData.vEye.z);

	m_pat_LBPos.x = Tile2Patch(m_ti_CenterPos.x) - m_pat_Center2Side;
	m_pat_LBPos.y = Tile2Patch(m_ti_CenterPos.y) - m_pat_Center2Side;

	if (m_pat_PrevLBPos.x == m_pat_LBPos.x &&
		m_pat_PrevLBPos.y == m_pat_LBPos.y) return false;

	return true;
}


//
//	DispositionPatch
//
void CN3Terrain::DispositionPatch()
{
	int x, z;
	int px, pz;
	int cx, cz;
	for (x = 0; x < m_iNumPatch; x++)
	{
		for (z = 0; z < m_iNumPatch; z++)
		{
			px = m_pat_LBPos.x + x;
			pz = m_pat_LBPos.y + z;

			if (px < 0 || pz < 0 || px >= m_pat_MapSize || pz >= m_pat_MapSize) continue;

			m_ppPatch[x][z].m_ti_LBPoint.x = px * PATCH_TILE_SIZE;
			m_ppPatch[x][z].m_ti_LBPoint.y = pz * PATCH_TILE_SIZE;

			cx = px * PATCH_PIXEL_SIZE / COLORMAPTEX_SIZE;
			cz = pz * PATCH_PIXEL_SIZE / COLORMAPTEX_SIZE;
			if (cx < 0 || cz < 0 || cx >= m_iNumColorMap || cz >= m_iNumColorMap) m_ppPatch[x][z].m_pRefColorTex = nullptr;
			else m_ppPatch[x][z].m_pRefColorTex = &(m_ppColorMapTex[cx][cz]);
		}
	}

	//lightmap읽어서 배치하고...
	//있던건 지우고...
	POINT PrevCenter = m_pat_CenterPos;
	m_pat_CenterPos.x = m_pat_LBPos.x + (m_iNumPatch / 2);
	m_pat_CenterPos.y = m_pat_LBPos.y + (m_iNumPatch / 2);

	if (PrevCenter.x == m_pat_CenterPos.x)
	{
		if (PrevCenter.y == m_pat_CenterPos.y) SetLightMap(DIR_CM);
		else if (PrevCenter.y == (m_pat_CenterPos.y + 1)) SetLightMap(DIR_CB);
		else if (PrevCenter.y == (m_pat_CenterPos.y - 1)) SetLightMap(DIR_CT);
		else SetLightMap(DIR_WARP);
	}
	else if (PrevCenter.x == (m_pat_CenterPos.x - 1))
	{
		if (PrevCenter.y == m_pat_CenterPos.y) SetLightMap(DIR_RM);
		else if (PrevCenter.y == (m_pat_CenterPos.y + 1)) SetLightMap(DIR_RB);
		else if (PrevCenter.y == (m_pat_CenterPos.y - 1)) SetLightMap(DIR_RT);
		else SetLightMap(DIR_WARP);
	}
	else if (PrevCenter.x == (m_pat_CenterPos.x + 1))
	{
		if (PrevCenter.y == m_pat_CenterPos.y) SetLightMap(DIR_LM);
		else if (PrevCenter.y == (m_pat_CenterPos.y + 1)) SetLightMap(DIR_LB);
		else if (PrevCenter.y == (m_pat_CenterPos.y - 1)) SetLightMap(DIR_LT);
		else SetLightMap(DIR_WARP);
	}
	else SetLightMap(DIR_WARP);


	//m_pRiver->SetPatchPos(m_pat_LBPos.x+m_pat_Center2Side, m_pat_LBPos.y+m_pat_Center2Side);
}


//
//
//
void CN3Terrain::SetLightMap(int dir)
{
#ifndef _N3TOOL
	__TABLE_ZONE* pZoneData = CGameBase::s_pTbl_Zones.Find(CGameBase::s_pPlayer->m_InfoExt.iZoneCur);
	if (pZoneData == nullptr)
		return;

	FileReader file;
	if (!file.OpenExisting(pZoneData->szLightMapFN))
		return;

	int* Addr = new int[m_pat_MapSize * m_pat_MapSize];
	int iVersion;
	file.Read(&iVersion, sizeof(int));
	file.Read(&Addr[0], sizeof(int) * m_pat_MapSize * m_pat_MapSize);

	//DIR_LT = 0, DIR_CT = 1, DIR_RT = 2,
	//DIR_LM = 3, DIR_CM = 4, DIR_RM = 5,
	//DIR_LB = 6, DIR_CB = 7, DIR_RB = 8,
	//DIR_WARP = 9	
	switch (dir)
	{
		case DIR_LT:
		{
			SetLightMapPatch(0, 0, file, Addr);
			ReplaceLightMapPatch(1, 0, m_LightMapPatch[0][1]);
			ReplaceLightMapPatch(2, 0, m_LightMapPatch[1][1]);

			SetLightMapPatch(0, 1, file, Addr);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[0][2]);
			ReplaceLightMapPatch(2, 1, m_LightMapPatch[1][2]);

			SetLightMapPatch(0, 2, file, Addr);
			SetLightMapPatch(1, 2, file, Addr);
			SetLightMapPatch(2, 2, file, Addr);
			break;
		}
		case DIR_CT:
		{
			ReplaceLightMapPatch(0, 0, m_LightMapPatch[0][1]);
			ReplaceLightMapPatch(1, 0, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(2, 0, m_LightMapPatch[2][1]);

			ReplaceLightMapPatch(0, 1, m_LightMapPatch[0][2]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[1][2]);
			ReplaceLightMapPatch(2, 1, m_LightMapPatch[2][2]);

			SetLightMapPatch(0, 2, file, Addr);
			SetLightMapPatch(1, 2, file, Addr);
			SetLightMapPatch(2, 2, file, Addr);
			break;
		}
		case DIR_RT:
		{
			ReplaceLightMapPatch(0, 0, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(1, 0, m_LightMapPatch[2][1]);
			SetLightMapPatch(2, 0, file, Addr);

			ReplaceLightMapPatch(0, 1, m_LightMapPatch[1][2]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[2][2]);
			SetLightMapPatch(2, 1, file, Addr);

			SetLightMapPatch(0, 2, file, Addr);
			SetLightMapPatch(1, 2, file, Addr);
			SetLightMapPatch(2, 2, file, Addr);
			break;
		}
		case DIR_LM:
		{
			ReplaceLightMapPatch(2, 0, m_LightMapPatch[1][0]);
			ReplaceLightMapPatch(2, 1, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(2, 2, m_LightMapPatch[1][2]);

			ReplaceLightMapPatch(1, 0, m_LightMapPatch[0][0]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[0][1]);
			ReplaceLightMapPatch(1, 2, m_LightMapPatch[0][2]);

			SetLightMapPatch(0, 0, file, Addr);
			SetLightMapPatch(0, 1, file, Addr);
			SetLightMapPatch(0, 2, file, Addr);
			break;
		}
		case DIR_WARP:
		{
			SetLightMapPatch(0, 0, file, Addr);
			SetLightMapPatch(1, 0, file, Addr);
			SetLightMapPatch(2, 0, file, Addr);

			SetLightMapPatch(0, 1, file, Addr);
			SetLightMapPatch(1, 1, file, Addr);
			SetLightMapPatch(2, 1, file, Addr);

			SetLightMapPatch(0, 2, file, Addr);
			SetLightMapPatch(1, 2, file, Addr);
			SetLightMapPatch(2, 2, file, Addr);
			break;
		}
		case DIR_RM:
		{
			ReplaceLightMapPatch(0, 0, m_LightMapPatch[1][0]);
			ReplaceLightMapPatch(0, 1, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(0, 2, m_LightMapPatch[1][2]);

			ReplaceLightMapPatch(1, 0, m_LightMapPatch[2][0]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[2][1]);
			ReplaceLightMapPatch(1, 2, m_LightMapPatch[2][2]);

			SetLightMapPatch(2, 0, file, Addr);
			SetLightMapPatch(2, 1, file, Addr);
			SetLightMapPatch(2, 2, file, Addr);
			break;
		}
		case DIR_LB:
		{
			ReplaceLightMapPatch(2, 2, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(1, 2, m_LightMapPatch[0][1]);
			SetLightMapPatch(0, 2, file, Addr);

			ReplaceLightMapPatch(2, 1, m_LightMapPatch[1][0]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[0][0]);
			SetLightMapPatch(0, 1, file, Addr);

			SetLightMapPatch(0, 0, file, Addr);
			SetLightMapPatch(1, 0, file, Addr);
			SetLightMapPatch(2, 0, file, Addr);
			break;
		}
		case DIR_CB:
		{
			ReplaceLightMapPatch(0, 2, m_LightMapPatch[0][1]);
			ReplaceLightMapPatch(1, 2, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(2, 2, m_LightMapPatch[2][1]);

			ReplaceLightMapPatch(0, 1, m_LightMapPatch[0][0]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[1][0]);
			ReplaceLightMapPatch(2, 1, m_LightMapPatch[2][0]);

			SetLightMapPatch(0, 0, file, Addr);
			SetLightMapPatch(1, 0, file, Addr);
			SetLightMapPatch(2, 0, file, Addr);
			break;
		}
		case DIR_RB:
		{
			ReplaceLightMapPatch(0, 2, m_LightMapPatch[1][1]);
			ReplaceLightMapPatch(1, 2, m_LightMapPatch[2][1]);
			SetLightMapPatch(2, 2, file, Addr);

			ReplaceLightMapPatch(0, 1, m_LightMapPatch[1][0]);
			ReplaceLightMapPatch(1, 1, m_LightMapPatch[2][0]);
			SetLightMapPatch(2, 1, file, Addr);

			SetLightMapPatch(0, 0, file, Addr);
			SetLightMapPatch(1, 0, file, Addr);
			SetLightMapPatch(2, 0, file, Addr);
			break;
		}
	}

	delete[] Addr;
#endif
}


//
//
//
void CN3Terrain::ReplaceLightMapPatch(int x, int z, stlMap_N3Tex& LightMapPatch)
{
	stlMap_N3TexIt itBegin = m_LightMapPatch[x][z].begin();
	stlMap_N3TexIt itEnd = m_LightMapPatch[x][z].end();
	stlMap_N3TexIt it;

	for (it = itBegin; it != itEnd; it++)
	{
		CN3Texture* pTex = (*it).second;
		if (pTex) delete pTex;
	}
	m_LightMapPatch[x][z].clear();
	m_LightMapPatch[x][z] = LightMapPatch;
	LightMapPatch.clear();
}


//
//
//
void CN3Terrain::SetLightMapPatch(int x, int z, File& file, int* pAddr)
{
	stlMap_N3TexIt itBegin = m_LightMapPatch[x][z].begin();
	stlMap_N3TexIt itEnd = m_LightMapPatch[x][z].end();
	stlMap_N3TexIt it;

	for (it = itBegin; it != itEnd; it++)
	{
		CN3Texture* pTex = (*it).second;
		if (pTex) delete pTex;
	}
	m_LightMapPatch[x][z].clear();

	int px, pz;
	px = m_pat_CenterPos.x - 1 + x;
	pz = m_pat_CenterPos.y - 1 + z;

	if (px < 0 || px >= m_pat_MapSize || pz < 0 || pz >= m_pat_MapSize)
		return;

	int jump = pAddr[px + (m_pat_MapSize * pz)];
	if (jump <= 0)
		return;

	file.Seek(jump, SEEK_SET);

	int TexCount;
	file.Read(&TexCount, sizeof(int));

	int tx, tz;
	int rtx, rtz;
	for (int i = 0; i < TexCount; i++)
	{
		file.Read(&tx, sizeof(int));
		file.Read(&tz, sizeof(int));

		CN3Texture* pTex = new CN3Texture;
		pTex->m_iFileFormatVersion = m_iFileFormatVersion;

		pTex->Load(file);
		rtx = px * PATCH_TILE_SIZE + tx;
		rtz = pz * PATCH_TILE_SIZE + tz;

		uint32_t key = rtx * 10000 + rtz;
		m_LightMapPatch[x][z].insert(stlMap_N3TexValue(key, pTex));
	}
}


//
//
//
CN3Texture* CN3Terrain::GetLightMap(int tx, int tz)
{
	int px, pz;
	px = tx / PATCH_TILE_SIZE;
	pz = tz / PATCH_TILE_SIZE;

	px -= (m_pat_CenterPos.x - 1);
	pz -= (m_pat_CenterPos.y - 1);
	if (px < 0 || px>2 || pz < 0 || pz>2) return nullptr;

	uint32_t key = tx * 10000 + tz;
	stlMap_N3TexIt it = m_LightMapPatch[px][pz].find(key);
	if (it != m_LightMapPatch[px][pz].end())
	{
		return (*it).second;
	}
	return nullptr;
}


//
//	CheckBounce...
//	패치단위의 가시영역 검사..
//	변했으면 return true...
//
bool CN3Terrain::CheckBound()
{
	RECT prevPatRc = m_pat_BoundRect;

	RECT rc;
	rc.left = rc.right = Real2Patch(CN3Base::s_CameraData.vEye.x);
	rc.top = rc.bottom = Real2Patch(CN3Base::s_CameraData.vEye.z);


	// 사면체의 법선 벡터와 Far 네 귀퉁이 위치 계산..
	float fS = sinf(CN3Base::s_CameraData.fFOV / 2.0f);
	float fPL = CN3Base::s_CameraData.fFP;
	float fAspect = CN3Base::s_CameraData.fAspect; // 종횡비

	// Far Plane 의 네 귀퉁이 위치 계산
	__Vector3 vFPs[4] = { __Vector3(fPL * -fS * fAspect, fPL * fS, fPL),	// LeftTop
							__Vector3(fPL * fS * fAspect, fPL * fS, fPL),		// rightTop
							__Vector3(fPL * fS * fAspect, fPL * -fS, fPL),	// RightBottom
							__Vector3(fPL * -fS * fAspect, fPL * -fS, fPL) }; // LeftBottom
	// 귀퉁이 위치에 회전 행렬을 적용한다..
	for (int i = 0; i < 4; i++)
		vFPs[i] = vFPs[i] * CN3Base::s_CameraData.mtxViewInverse;


	for (int i = 0; i < 4; i++)
	{
		POINT FarPoint;
		FarPoint.x = Real2Patch(vFPs[i].x);
		FarPoint.y = Real2Patch(vFPs[i].z);

		if (FarPoint.x < rc.left) rc.left = FarPoint.x;
		if (FarPoint.x > rc.right) rc.right = FarPoint.x;
		if (FarPoint.y < rc.top) rc.top = FarPoint.y;
		if (FarPoint.y > rc.bottom) rc.bottom = FarPoint.y;
	}

	rc.left = rc.left - m_pat_LBPos.x - 1;
	rc.right = rc.right - m_pat_LBPos.x + 1;
	rc.top = rc.top - m_pat_LBPos.y - 1;
	rc.bottom = rc.bottom - m_pat_LBPos.y + 1;

	if (rc.left < 0) rc.left = 0;
	if (rc.left >= m_iNumPatch) rc.left = m_iNumPatch - 1;
	if (rc.right < 0) rc.right = 0;
	if (rc.right >= m_iNumPatch) rc.right = m_iNumPatch - 1;
	if (rc.top < 0) rc.top = 0;
	if (rc.top >= m_iNumPatch) rc.top = m_iNumPatch - 1;
	if (rc.bottom < 0) rc.bottom = 0;
	if (rc.bottom >= m_iNumPatch) rc.bottom = m_iNumPatch - 1;

	m_pat_BoundRect = rc;

	bool bChangeRender = CheckRenderablePatch();

	if (!bChangeRender && EqualRect(&m_pat_BoundRect, &prevPatRc)) return false;

	return true;
}


//
//
//
bool CN3Terrain::CheckRenderablePatch()
{
	bool bChange = false;
	__Vector3 CenterPoint;
	int px, pz;
	int x, z;
	BOOL PrevState;
	for (x = m_pat_BoundRect.left; x <= m_pat_BoundRect.right; x++)
	{
		for (z = m_pat_BoundRect.top; z <= m_pat_BoundRect.bottom; z++)
		{
			if (x < 0 || z < 0) continue;

			PrevState = m_ppPatch[x][z].m_bIsRender;
			m_ppPatch[x][z].m_bIsRender = TRUE;

			px = m_pat_LBPos.x + x;
			pz = m_pat_LBPos.y + z;

			if (px < 0 || pz < 0 || px >= m_pat_MapSize || pz >= m_pat_MapSize)
			{
				m_ppPatch[x][z].m_bIsRender = FALSE;
				continue;
			}

			CenterPoint.Set((float) ((m_ppPatch[x][z].m_ti_LBPoint.x + (PATCH_TILE_SIZE >> 1)) * TILE_SIZE),
							m_ppPatchMiddleY[px][pz],
							(float) ((m_ppPatch[x][z].m_ti_LBPoint.y + (PATCH_TILE_SIZE >> 1)) * TILE_SIZE));

			m_ppPatch[x][z].m_bIsRender = (!(CN3Base::s_CameraData.IsOutOfFrustum(CenterPoint, m_ppPatchRadius[px][pz] * 2.0f)));
			if (m_ppPatch[x][z].m_bIsRender != PrevState) bChange = true;
		}
	}
	return bChange;
}


//
//
//
void CN3Terrain::Render()
{
	__Matrix44 WorldMtx;
	WorldMtx.Identity();
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, WorldMtx.toD3D());

	__Material mtl;
	mtl.Init();
	CN3Base::s_lpD3DDev->SetMaterial(&mtl);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, m_FillMode);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SHADEMODE, m_ShadeMode);

	DWORD CullMode, ZEnable;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &CullMode);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &ZEnable);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	//CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZBIAS, 1);

	DWORD ColorOP0, ColorOP1, ColorOP2;
	DWORD ColorArg01, ColorArg02, ColorArg11, ColorArg12, ColorArg21, ColorArg22;

	HRESULT hr;
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &ColorOP0);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &ColorArg01);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG2, &ColorArg02);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLOROP, &ColorOP1);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG1, &ColorArg11);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG2, &ColorArg12);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLOROP, &ColorOP2);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLORARG1, &ColorArg21);
	hr = CN3Base::s_lpD3DDev->GetTextureStageState(2, D3DTSS_COLORARG2, &ColorArg22);

	DWORD AddressU1, AddressV1, AddressU2, AddressV2;
	//hr = s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSU, &AddressU1 );
	//hr = s_lpD3DDev->GetTextureStageState( 0, D3DTSS_ADDRESSV, &AddressV1 );
	//hr = s_lpD3DDev->GetTextureStageState(1, D3DTSS_ADDRESSU, &AddressU2);
	//hr = s_lpD3DDev->GetTextureStageState(1, D3DTSS_ADDRESSV, &AddressV2);
	hr = s_lpD3DDev->GetSamplerState(0, D3DSAMP_ADDRESSU, &AddressU1);
	hr = s_lpD3DDev->GetSamplerState(0, D3DSAMP_ADDRESSV, &AddressV1);
	hr = s_lpD3DDev->GetSamplerState(1, D3DSAMP_ADDRESSU, &AddressU2);
	hr = s_lpD3DDev->GetSamplerState(1, D3DSAMP_ADDRESSV, &AddressV2);

	// 각각의 텍스쳐들을 연결했을때 경계선을 없앨 수 있다..^^
	//hr = s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_MIRROR );
	//hr = s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_MIRROR );
	//hr = s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_MIRROR );
	//hr = s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_MIRROR );
	hr = s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);
	hr = s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);
	hr = s_lpD3DDev->SetSamplerState(1, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);
	hr = s_lpD3DDev->SetSamplerState(1, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);

	int x, z;
	for (x = m_pat_BoundRect.left; x <= m_pat_BoundRect.right; x++)
	{
		for (z = m_pat_BoundRect.top; z <= m_pat_BoundRect.bottom; z++)
		{
			if (x < 0 || z < 0) continue;
			m_ppPatch[x][z].Render();
		}
	}

	/*
	hr = s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSU, AddressU1 );
	hr = s_lpD3DDev->SetTextureStageState( 0, D3DTSS_ADDRESSV, AddressV1 );
	hr = s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ADDRESSU, AddressU2 );
	hr = s_lpD3DDev->SetTextureStageState( 1, D3DTSS_ADDRESSV, AddressV2 );
	*/
	hr = s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSU, AddressU1);
	hr = s_lpD3DDev->SetSamplerState(0, D3DSAMP_ADDRESSV, AddressV1);
	hr = s_lpD3DDev->SetSamplerState(1, D3DSAMP_ADDRESSU, AddressU2);
	hr = s_lpD3DDev->SetSamplerState(1, D3DSAMP_ADDRESSV, AddressV2);

	// restor texture stage state settings...
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, ColorOP0);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, ColorArg01);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, ColorArg02);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, ColorOP1);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, ColorArg11);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, ColorArg12);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLOROP, ColorOP2);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG1, ColorArg21);
	hr = CN3Base::s_lpD3DDev->SetTextureStageState(2, D3DTSS_COLORARG2, ColorArg22);
	hr = CN3Base::s_lpD3DDev->SetTexture(0, nullptr);
	hr = CN3Base::s_lpD3DDev->SetTexture(1, nullptr);
	hr = CN3Base::s_lpD3DDev->SetTexture(2, nullptr);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, CullMode);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, ZEnable);

	if (m_pRiver) m_pRiver->Render();
	if (m_pPond) m_pPond->Render();
}


//
//	Log2(x) = l..
//	2의 승수에 대해서만 제대로 작동...(x>0)
//
inline int CN3Terrain::Log2(int x)
{
	int l = 0;
	while (x != 1)
	{
		x = x >> 1;
		l++;
	}
	return l;
}


//
//
//
float CN3Terrain::GetHeight(float x, float z)
{
	int ix, iz;
	ix = ((int) x) / (int) TILE_SIZE;
	iz = ((int) z) / (int) TILE_SIZE;

	if (ix<0 || ix>(m_ti_MapSize - 2)) return -FLT_MAX;
	if (iz<0 || iz>(m_ti_MapSize - 2)) return -FLT_MAX;

	float dX, dZ;
	dX = (x - (ix * TILE_SIZE)) / TILE_SIZE;
	dZ = (z - (iz * TILE_SIZE)) / TILE_SIZE;

	float y;
	float h1, h2, h3, h12, h13;

	if ((ix + iz) % 2 == 0)	//사각형이 / 모양.. 
	{
		h1 = m_pMapData[ix * m_ti_MapSize + iz].fHeight;
		h3 = m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight;
		if (dZ > dX)	//윗쪽 삼각형..
		{
			h2 = m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight;

			h12 = h1 + (h2 - h1) * dZ;	// h1과 h2사이의 높이값
			h13 = h1 + (h3 - h1) * dZ;	// h1과 h3사이의 높이값

			y = h12 + ((h13 - h12) * (dX / dZ));	// 찾고자 하는 높이값
			return y;
		}
		else	//아래쪽 삼각형..
		{
			if (dX == 0.0f) return h1;

			h2 = m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight;

			h12 = h1 + (h2 - h1) * dX;	// h1과 h2사이의 높이값
			h13 = h1 + (h3 - h1) * dX;	// h1과 h3사이의 높이값

			y = h12 + ((h13 - h12) * (dZ / dX));	// 찾고자 하는 높이값
			return y;
		}
	}

	else if ((ix + iz) % 2 == 1)	//사각형이 역슬레쉬 모양..
	{
		h1 = m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight;
		h3 = m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight;

		if ((dX + dZ) > 1.0f)	//윗쪽 삼각형..
		{
			if (dZ == 0.0f) return h1;
			h2 = m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight;

			h12 = h1 + (h2 - h1) * dZ;
			h13 = h1 + (h3 - h1) * dZ;

			y = h12 + ((h13 - h12) * ((1.0f - dX) / dZ));
			return y;
		}
		else	//아래쪽 삼각형..
		{
			if (dX == 1.0f) return h1;
			h2 = m_pMapData[ix * m_ti_MapSize + iz].fHeight;

			h12 = h2 + (h1 - h2) * dX;	// h1과 h2사이의 높이값
			h13 = h3 + (h1 - h3) * dX;	// h1과 h3사이의 높이값

			y = h12 + ((h13 - h12) * (dZ / (1.0f - dX)));
			return y;
		}
	}

	return -FLT_MAX;
}



//
//	GetNormal(float x, float z, __Vector3& vNormal)
//
void CN3Terrain::GetNormal(float x, float z, __Vector3& vNormal)
{
	if (x<10.0f || x>((m_ti_MapSize - 1) * TILE_SIZE - 10.0f) || z<10.0f || z>((m_ti_MapSize - 1) * TILE_SIZE - 10.0f))
	{
		vNormal.Set(0.0f, 1.0f, 0.0f);
		return;
	}

	int ix, iz;
	ix = ((int) x) / (int) TILE_SIZE;
	iz = ((int) z) / (int) TILE_SIZE;

	float dX, dZ;
	dX = (x - ix * TILE_SIZE) / TILE_SIZE;
	dZ = (z - iz * TILE_SIZE) / TILE_SIZE;

	__Vector3 v1, v2;
	vNormal.Set(0, 1, 0);
	float Height;
	if ((ix + iz) % 2 == 1)
	{
		if ((dX + dZ) < 1.0f)
		{
			Height = m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight - m_pMapData[ix * m_ti_MapSize + iz].fHeight;
			v1.Set(0, Height, TILE_SIZE);

			Height = m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight - m_pMapData[ix * m_ti_MapSize + iz].fHeight;
			v2.Set(TILE_SIZE, Height, 0);

			vNormal.Cross(v1, v2);
			return;
		}
		else
		{
			Height = m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight - m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight;
			v1.Set(0.0f, Height, (-1) * TILE_SIZE);

			Height = m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight - m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight;
			v2.Set((-1) * TILE_SIZE, Height, 0.0f);

			vNormal.Cross(v1, v2);
			return;
		}
	}
	else
	{
		if (dZ > dX)
		{
			Height = m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight - m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight;
			v1.Set(TILE_SIZE, Height, 0.0f);

			Height = m_pMapData[ix * m_ti_MapSize + iz].fHeight - m_pMapData[ix * m_ti_MapSize + (iz + 1)].fHeight;
			v2.Set(0.0f, Height, (-1) * TILE_SIZE);

			vNormal.Cross(v1, v2);
			return;
		}
		else
		{
			Height = m_pMapData[ix * m_ti_MapSize + iz].fHeight - m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight;
			v1.Set((-1) * TILE_SIZE, Height, 0.0f);

			Height = m_pMapData[(ix + 1) * m_ti_MapSize + (iz + 1)].fHeight - m_pMapData[(ix + 1) * m_ti_MapSize + iz].fHeight;
			v2.Set(0.0f, Height, TILE_SIZE);

			vNormal.Cross(v1, v2);
			return;
		}
	}
	return;
}


//
//
//
bool CN3Terrain::IsInTerrain(float x, float z)
{

	if (x<30.0f || x>((m_ti_MapSize - 1) * TILE_SIZE - 30.0f) || z<30.0f || z>((m_ti_MapSize - 1) * TILE_SIZE - 30.0f)) return false;
	return true;
}


//
///////////////////////////////////////////////////////////////////////////////////////////////////////
//


#define OFFSET_COLLISION_TERRAIN 0.5f


BOOL CN3Terrain::Pick(int x, int y, __Vector3& vPick)
{
	// Compute the vector of the pick ray in screen space
	__Vector3 vTmp;
	vTmp.x = (((2.0f * x) / (CN3Base::s_CameraData.vp.Width)) - 1) / CN3Base::s_CameraData.mtxProjection.m[0][0];
	vTmp.y = -(((2.0f * y) / (CN3Base::s_CameraData.vp.Height)) - 1) / CN3Base::s_CameraData.mtxProjection.m[1][1];
	vTmp.z = 1.0f;

	// Transform the screen space pick ray into 3D space
	__Matrix44* pMtxVI = &CN3Base::s_CameraData.mtxViewInverse;
	__Vector3 vDir;
	vDir.x = vTmp.x * pMtxVI->m[0][0] + vTmp.y * pMtxVI->m[1][0] + vTmp.z * pMtxVI->m[2][0];
	vDir.y = vTmp.x * pMtxVI->m[0][1] + vTmp.y * pMtxVI->m[1][1] + vTmp.z * pMtxVI->m[2][1];
	vDir.z = vTmp.x * pMtxVI->m[0][2] + vTmp.y * pMtxVI->m[1][2] + vTmp.z * pMtxVI->m[2][2];
	__Vector3 vPos = pMtxVI->Pos();
	__Vector3 vPosCur = vPos;

	bool bCollision = FALSE;
	__Vector3 A, B, C;
	float t, u, v;

	int ix = ((int) vPosCur.x) / (int) TILE_SIZE;
	int iz = ((int) vPosCur.z) / (int) TILE_SIZE;

	if ((ix + iz) % 2 == 1)				// 당근.. 왼손 바인딩...
	{
		A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
		A.y += OFFSET_COLLISION_TERRAIN;
		C.y += OFFSET_COLLISION_TERRAIN;
		B.y += OFFSET_COLLISION_TERRAIN;
	}
	if ((ix + iz) % 2 == 0)
	{
		A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
		C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
		A.y += OFFSET_COLLISION_TERRAIN;
		C.y += OFFSET_COLLISION_TERRAIN;
		B.y += OFFSET_COLLISION_TERRAIN;
	}
	bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);

	if (FALSE == bCollision) // 충돌점이 없을 경우....
	{
		vPick.Set(0, 0, 0); // 일단 충돌 점은 없고..

		// 음....		!!가상!!  버텍스 버퍼와 인덱스 버퍼 만들기..
		__Vector3	AA[8];							// 가상 버텍스 버퍼..
		int			pIndex[36];						// 가상 인덱스 버퍼..
		int* pIdx = pIndex;

		AA[0] = __Vector3(vPos.x - COLLISION_BOX, vPos.y - COLLISION_BOX, vPos.z + COLLISION_BOX);
		AA[1] = __Vector3(vPos.x + COLLISION_BOX, vPos.y - COLLISION_BOX, vPos.z + COLLISION_BOX);
		AA[2] = __Vector3(vPos.x + COLLISION_BOX, vPos.y - COLLISION_BOX, vPos.z - COLLISION_BOX);
		AA[3] = __Vector3(vPos.x - COLLISION_BOX, vPos.y - COLLISION_BOX, vPos.z - COLLISION_BOX);
		AA[4] = __Vector3(vPos.x - COLLISION_BOX, vPos.y + COLLISION_BOX, vPos.z + COLLISION_BOX);
		AA[5] = __Vector3(vPos.x + COLLISION_BOX, vPos.y + COLLISION_BOX, vPos.z + COLLISION_BOX);
		AA[6] = __Vector3(vPos.x + COLLISION_BOX, vPos.y + COLLISION_BOX, vPos.z - COLLISION_BOX);
		AA[7] = __Vector3(vPos.x - COLLISION_BOX, vPos.y + COLLISION_BOX, vPos.z - COLLISION_BOX);

		// 윗면.
		*pIdx++ = 0;  *pIdx++ = 1;  *pIdx++ = 3;
		*pIdx++ = 2;  *pIdx++ = 3;  *pIdx++ = 1;

		// 앞면..
		*pIdx++ = 7;  *pIdx++ = 3;  *pIdx++ = 6;
		*pIdx++ = 2;  *pIdx++ = 6;  *pIdx++ = 3;

		// 왼쪽..
		*pIdx++ = 4;  *pIdx++ = 0;  *pIdx++ = 7;
		*pIdx++ = 3;  *pIdx++ = 7;  *pIdx++ = 0;

		// 오른쪽..
		*pIdx++ = 6;  *pIdx++ = 2;  *pIdx++ = 5;
		*pIdx++ = 1;  *pIdx++ = 5;  *pIdx++ = 2;

		// 뒷면..
		*pIdx++ = 5;  *pIdx++ = 1;  *pIdx++ = 4;
		*pIdx++ = 0;  *pIdx++ = 4;  *pIdx++ = 1;

		// 밑면..
		*pIdx++ = 7;  *pIdx++ = 6;  *pIdx++ = 4;
		*pIdx++ = 5;  *pIdx++ = 4;  *pIdx++ = 6;

		for (int i = 0; FALSE == bCollision && i < 36; i += 3)
		{
			float t, u, v;
			bCollision = ::_IntersectTriangle(vPos, vDir, AA[pIndex[i]], AA[pIndex[i + 1]], AA[pIndex[i + 2]], t, u, v, &vPick);
		}
	}

	return bCollision;
}

BOOL CN3Terrain::PickWide(int x, int y, __Vector3& vPick)
{
	// Compute the vector of the pick ray in screen space
	__Vector3 vTmp;
	vTmp.x = (((2.0f * x) / (CN3Base::s_CameraData.vp.Width)) - 1) / CN3Base::s_CameraData.mtxProjection.m[0][0];
	vTmp.y = -(((2.0f * y) / (CN3Base::s_CameraData.vp.Height)) - 1) / CN3Base::s_CameraData.mtxProjection.m[1][1];
	vTmp.z = 1.0f;

	// Transform the screen space pick ray into 3D space
	__Matrix44* pMtxVI = &CN3Base::s_CameraData.mtxViewInverse;
	__Vector3 vDir;
	vDir.x = vTmp.x * pMtxVI->m[0][0] + vTmp.y * pMtxVI->m[1][0] + vTmp.z * pMtxVI->m[2][0];
	vDir.y = vTmp.x * pMtxVI->m[0][1] + vTmp.y * pMtxVI->m[1][1] + vTmp.z * pMtxVI->m[2][1];
	vDir.z = vTmp.x * pMtxVI->m[0][2] + vTmp.y * pMtxVI->m[1][2] + vTmp.z * pMtxVI->m[2][2];
	__Vector3 vPos = pMtxVI->Pos();
	__Vector3 vPosCur = vPos;

	vDir.Normalize();

	bool bCollision = FALSE;
	__Vector3 A, B, C;
	float t, u, v;

	while ((vPosCur.x >= 0.0f) && (vPosCur.z >= 0.0f) && (IsInTerrain(vPosCur.x, vPosCur.z)))
	{
		if (bCollision)	return bCollision;

		int ix = ((int) vPosCur.x) / (int) TILE_SIZE;
		int iz = ((int) vPosCur.z) / (int) TILE_SIZE;

		for (int i = 0; i < 10; i++)
		{
			switch (i)
			{
				case 0:			//  0, 0
					break;
				case 1:
					ix--;		// -1, 0
					break;
				case 2:			//  0, -1
					ix++;
					iz--;
					break;
				case 3:			// -1, -1
					ix--;
					break;
				case 4:			//  1, -1
					ix++;
					ix++;
					break;
				case 5:			// -1, 1
					ix--;
					ix--;
					iz++;
					iz++;
					break;
				case 6:			//  0, 1
					ix++;
					break;
				case 7:			//  1, 1		
					ix++;
					break;
				case 8:			//  1, 0
					iz--;
					break;
				case 9:			//  0, 0
					ix--;
					break;
			};

			if ((ix + iz) % 2 == 1)				// 당근.. 왼손 바인딩...
			{
				A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)		break;

				A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
				B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)		break;
			}
			if ((ix + iz) % 2 == 0)
			{
				A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
				C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)		break;

				A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)		break;
			}
		}
		vPosCur += (vDir * TILE_SIZE);
		//vDir 크기가 작기 때문에 Nomalize하고 TILE_SIZE만큼 곱해서 다음 체크할 위치를 바꿔준다.
		//이렇게 하지 않으면 체크한 부분을 여러번 체크하기 때문에 부하가 커진다.
	}

	if (FALSE == bCollision) // 충돌점이 없을 경우....
	{
		vPick.Set(0, 0, 0); // 일단 충돌 점은 없고..

		// 음....		!!가상!!  버텍스 버퍼와 인덱스 버퍼 만들기..
		__Vector3	AA[8];							// 가상 버텍스 버퍼..
		int			pIndex[36];						// 가상 인덱스 버퍼..
		int* pIdx = pIndex;

#define COL_BOX_OFF 2000

		AA[0] = __Vector3(vPos.x - COL_BOX_OFF, vPos.y - COL_BOX_OFF, vPos.z + COL_BOX_OFF);
		AA[1] = __Vector3(vPos.x + COL_BOX_OFF, vPos.y - COL_BOX_OFF, vPos.z + COL_BOX_OFF);
		AA[2] = __Vector3(vPos.x + COL_BOX_OFF, vPos.y - COL_BOX_OFF, vPos.z - COL_BOX_OFF);
		AA[3] = __Vector3(vPos.x - COL_BOX_OFF, vPos.y - COL_BOX_OFF, vPos.z - COL_BOX_OFF);
		AA[4] = __Vector3(vPos.x - COL_BOX_OFF, vPos.y + COL_BOX_OFF, vPos.z + COL_BOX_OFF);
		AA[5] = __Vector3(vPos.x + COL_BOX_OFF, vPos.y + COL_BOX_OFF, vPos.z + COL_BOX_OFF);
		AA[6] = __Vector3(vPos.x + COL_BOX_OFF, vPos.y + COL_BOX_OFF, vPos.z - COL_BOX_OFF);
		AA[7] = __Vector3(vPos.x - COL_BOX_OFF, vPos.y + COL_BOX_OFF, vPos.z - COL_BOX_OFF);

		// 윗면.
		*pIdx++ = 0;  *pIdx++ = 1;  *pIdx++ = 3;
		*pIdx++ = 2;  *pIdx++ = 3;  *pIdx++ = 1;

		// 앞면..
		*pIdx++ = 7;  *pIdx++ = 3;  *pIdx++ = 6;
		*pIdx++ = 2;  *pIdx++ = 6;  *pIdx++ = 3;

		// 왼쪽..
		*pIdx++ = 4;  *pIdx++ = 0;  *pIdx++ = 7;
		*pIdx++ = 3;  *pIdx++ = 7;  *pIdx++ = 0;

		// 오른쪽..
		*pIdx++ = 6;  *pIdx++ = 2;  *pIdx++ = 5;
		*pIdx++ = 1;  *pIdx++ = 5;  *pIdx++ = 2;

		// 뒷면..
		*pIdx++ = 5;  *pIdx++ = 1;  *pIdx++ = 4;
		*pIdx++ = 0;  *pIdx++ = 4;  *pIdx++ = 1;

		// 밑면..
		*pIdx++ = 7;  *pIdx++ = 6;  *pIdx++ = 4;
		*pIdx++ = 5;  *pIdx++ = 4;  *pIdx++ = 6;

		for (int i = 0; FALSE == bCollision && i < 36; i += 3)
		{
			float t, u, v;
			bCollision = ::_IntersectTriangle(vPos, vDir, AA[pIndex[i]], AA[pIndex[i + 1]], AA[pIndex[i + 2]], t, u, v, &vPick);
		}
	}

	return bCollision;
}

#define __MAX_DISTANCE 6000


//
//
//
void CN3Terrain::CalcCollisionTerrainByOTPlayer(__Vector3 vOrig, __Vector3 vAt, __Vector3& Vec)
{
	bool boo = FALSE;
	__Vector3 vec2, vec3, vec4, vDir;		// vec1 & vec2 is 2D..  vec3 & vec4 is 3D..
	__Vector3 A, B, C;
	float ftx, fty, ftz;
	vec2 = vOrig;
	vec3 = vAt;
	vOrig = vec2;
	vec3.Normalize(); vec3 *= TILE_SIZE;
	vDir = vec3;
	vec4 = vec2;

	int ix = ((int) vec2.x) / (int) TILE_SIZE;
	int iz = ((int) vec2.z) / (int) TILE_SIZE;

	if ((ix + iz) % 2 == 1)						// 당근.. 왼손 바인딩...
	{
		A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

		boo = ::_IntersectTriangle(vOrig, vDir, A, B, C, ftx, fty, ftz);
		if (boo == TRUE)
		{
			Vec = vOrig + vDir*ftx;
			return;
		}

		A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
		B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

		boo = ::_IntersectTriangle(vOrig, vDir, A, B, C, ftx, fty, ftz);
		if (boo == TRUE)
		{
			Vec = vOrig + vDir*ftx;
			return;
		}
	}
	if ((ix + iz) % 2 == 0)
	{
		A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
		C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

		boo = ::_IntersectTriangle(vOrig, vDir, A, B, C, ftx, fty, ftz);
		if (boo == TRUE)
		{
			Vec = vOrig + vDir*ftx;
			return;
		}

		A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
		C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

		boo = ::_IntersectTriangle(vOrig, vDir, A, B, C, ftx, fty, ftz);
		if (boo == TRUE)
		{
			Vec = vOrig + vDir*ftx;
			return;
		}
	}

//#define COLLISION_BOX 6000

	// 음....		!!가상!!  버텍스 버퍼와 인덱스 버퍼 만들기..
	__Vector3	AA[8];							// 가상 버텍스 버퍼..
	int			pIndex[36];						// 가상 인덱스 버퍼..
	int* pIdx = pIndex;

	AA[0] = __Vector3(vec4.x - COLLISION_BOX, vec4.y - COLLISION_BOX, vec4.z + COLLISION_BOX);
	AA[1] = __Vector3(vec4.x + COLLISION_BOX, vec4.y - COLLISION_BOX, vec4.z + COLLISION_BOX);
	AA[2] = __Vector3(vec4.x + COLLISION_BOX, vec4.y - COLLISION_BOX, vec4.z - COLLISION_BOX);
	AA[3] = __Vector3(vec4.x - COLLISION_BOX, vec4.y - COLLISION_BOX, vec4.z - COLLISION_BOX);
	AA[4] = __Vector3(vec4.x - COLLISION_BOX, vec4.y + COLLISION_BOX, vec4.z + COLLISION_BOX);
	AA[5] = __Vector3(vec4.x + COLLISION_BOX, vec4.y + COLLISION_BOX, vec4.z + COLLISION_BOX);
	AA[6] = __Vector3(vec4.x + COLLISION_BOX, vec4.y + COLLISION_BOX, vec4.z - COLLISION_BOX);
	AA[7] = __Vector3(vec4.x - COLLISION_BOX, vec4.y + COLLISION_BOX, vec4.z - COLLISION_BOX);

	// 윗면.
	*pIdx++ = 0;  *pIdx++ = 1;  *pIdx++ = 3;
	*pIdx++ = 2;  *pIdx++ = 3;  *pIdx++ = 1;

	// 앞면..
	*pIdx++ = 7;  *pIdx++ = 3;  *pIdx++ = 6;
	*pIdx++ = 2;  *pIdx++ = 6;  *pIdx++ = 3;

	// 왼쪽..
	*pIdx++ = 4;  *pIdx++ = 0;  *pIdx++ = 7;
	*pIdx++ = 3;  *pIdx++ = 7;  *pIdx++ = 0;

	// 오른쪽..
	*pIdx++ = 6;  *pIdx++ = 2;  *pIdx++ = 5;
	*pIdx++ = 1;  *pIdx++ = 5;  *pIdx++ = 2;

	// 뒷면..
	*pIdx++ = 5;  *pIdx++ = 1;  *pIdx++ = 4;
	*pIdx++ = 0;  *pIdx++ = 4;  *pIdx++ = 1;

	// 밑면..
	*pIdx++ = 7;  *pIdx++ = 6;  *pIdx++ = 4;
	*pIdx++ = 5;  *pIdx++ = 4;  *pIdx++ = 6;

	for (int i = 0; i < 36; i += 3)
	{
		boo = ::_IntersectTriangle(vOrig, vDir, AA[pIndex[i]], AA[pIndex[i + 1]], AA[pIndex[i + 2]], ftx, fty, ftz);
		if (boo == TRUE)
			break;
	}
	Vec = vOrig + vDir*ftx;
}

bool CN3Terrain::CheckIncline(const __Vector3& vPos, const __Vector3& vDir, float fIncline)
{
	__Vector3 vNormal;
	this->GetNormal(vPos.x, vPos.z, vNormal);
	vNormal.Normalize();
	vNormal.y = 0.0f;
	if (vNormal.Magnitude() > fIncline && vNormal.Dot(vDir) <= 0.0f) return true;
	return false;
}

bool CN3Terrain::CheckCollisionCamera(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	float fHeight = this->GetHeight(vEyeResult.x, vEyeResult.z);
	float fDelta = fHeight - vEyeResult.y + fNP;
	if (fDelta < 0) return false;

	__Vector3 vDir = vAt - vEyeResult;
	vDir.Normalize();
	vDir.Set(0, 1, 0);

	vEyeResult += vDir * fDelta;
	return true;
}


bool CN3Terrain::CheckCollision(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol)
{
	float fHeight1, fHeight2;
	vDir.Normalize();

	fHeight1 = vPos.y - this->GetHeight(vPos.x, vPos.z);
	__Vector3 vNextPos = vPos + (vDir * (fVelocity * CN3Base::s_fSecPerFrm));
	fHeight2 = vNextPos.y - this->GetHeight(vNextPos.x, vNextPos.z);
	if (fHeight1 <= 0)
	{
		(*vCol) = vPos;
		(*vCol).y = this->GetHeight(vPos.x, vPos.z) + 0.1f;
		return true;
	}
	if (fHeight1 * fHeight2 > 0) return false; // both would be positive

	/////////////////////////////////////////////
	//걍 덜 정밀하게 하려면..이케...
	//
	(*vCol) = vPos;
	(*vCol).y = this->GetHeight(vPos.x, vPos.z) + 0.1f;
	return true;
	//
	/////////////////////////////////////////////

	//정밀하게 하려면 다음과 같이해...
	//충돌했다...
	RECT rt;
	rt.left = Real2Tile(vPos.x);
	rt.bottom = Real2Tile(vPos.z);
	rt.right = Real2Tile(vNextPos.x);
	rt.top = Real2Tile(vNextPos.z);

	if (rt.left > rt.right)
	{
		int tmp = rt.left;
		rt.left = rt.right;
		rt.right = rt.left;
	}
	if (rt.bottom > rt.top)
	{
		int tmp = rt.top;
		rt.top = rt.bottom;
		rt.bottom = rt.top;
	}

	__Vector3 A, B, C;
	BOOL bCollision;
	__Vector3 vPick;
	float t, u, v;
	for (int ix = rt.left; ix <= rt.right;ix++)
	{
		for (int iz = rt.bottom; iz <= rt.top;iz++)
		{
			if ((ix + iz) % 2 == 1)				// 당근.. 왼손 바인딩...
			{
				A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)
				{
					(*vCol) = vPick;
					return true;
				}

				A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
				B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)
				{
					(*vCol) = vPick;
					return true;
				}
			}
			if ((ix + iz) % 2 == 0)
			{
				A.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);
				C.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)
				{
					(*vCol) = vPick;
					return true;
				}

				A.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				B.Set((float) ix * TILE_SIZE, GetHeight(ix * TILE_SIZE, iz * TILE_SIZE), (float) iz * TILE_SIZE);
				C.Set((float) (ix + 1) * TILE_SIZE, GetHeight((ix + 1) * TILE_SIZE, (iz + 1) * TILE_SIZE), (float) (iz + 1) * TILE_SIZE);

				bCollision = ::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick);
				if (bCollision == TRUE)
				{
					(*vCol) = vPick;
					return true;
				}
			}
		}
	}

	(*vCol) = vPos;
	(*vCol).y = this->GetHeight(vPos.x, vPos.z);
	return true;
}

bool CN3Terrain::LoadColorMap(const std::string& szFN)
{
	CUILoading* pUILoading = CGameProcedure::s_pUILoading; // 로딩바..

	m_iNumColorMap = (m_pat_MapSize * PATCH_PIXEL_SIZE) / COLORMAPTEX_SIZE;
	m_ppColorMapTex = new CN3Texture* [m_iNumColorMap];
	for (int x = 0; x < m_iNumColorMap; x++)
	{
		m_ppColorMapTex[x] = new CN3Texture[m_iNumColorMap];

		for (int i = 0; i < m_iNumColorMap; ++i)
			m_ppColorMapTex[x][i].m_iFileFormatVersion = m_iFileFormatVersion;
	}

	FileReader colorMapFile;
	if (!colorMapFile.OpenExisting(szFN))
	{
#ifdef _N3GAME
		CLogWriter::Write("Failed to load ColorMap - {}", szFN);
#endif
		return false;
	}

	std::string szBuff;
	for (int x = 0; x < m_iNumColorMap; x++)
	{
		for (int z = 0; z < m_iNumColorMap; z++)
		{
			m_ppColorMapTex[x][z].m_iLOD = s_Options.iTexLOD_Terrain; // LOD 적용후 읽는다..
			m_ppColorMapTex[x][z].Load(colorMapFile);
		}

		szBuff = fmt::format("Loading colormap {} %", x * 100 / m_iNumColorMap);
		if (pUILoading != nullptr)
			pUILoading->Render(szBuff, 60 + 15 * x / m_iNumColorMap);
	}

	return true;
}

CN3Texture* CN3Terrain::GetTileTex(int x, int z)
{
	if (x < 0 || x >= m_ti_MapSize || z < 0 || z >= m_ti_MapSize) return nullptr;

	MAPDATA MapData;
	MapData = m_pMapData[(x * m_ti_MapSize) + z];
	return &(m_pTileTex[MapData.Tex1Idx]);
}

bool CN3Terrain::GetTileTexInfo(float x, float z, TERRAINTILETEXINFO& TexInfo1, TERRAINTILETEXINFO& TexInfo2)
{
	int tx, tz;
	tx = (int) x / (int) TILE_SIZE;
	tz = (int) z / (int) TILE_SIZE;

	if (tx < 0 || tx >= m_ti_MapSize || tz < 0 || tz >= m_ti_MapSize) return false;

	MAPDATA MapData = m_pMapData[(tx * m_ti_MapSize) + tz];


	if (MapData.Tex1Idx >= m_NumTileTex)
	{
		TexInfo1.pTex = nullptr;
		TexInfo1.u = TexInfo1.v = 0.0f;
	}
	else
	{
		TexInfo1.pTex = &(m_pTileTex[MapData.Tex1Idx]);
		TexInfo1.u = TexInfo1.v = 0.0f;
		//u1[0] = m_pRefTerrain->m_fTileDirU[dir1][2];
		//u1[1] = m_pRefTerrain->m_fTileDirU[dir1][0];
		//u1[2] = m_pRefTerrain->m_fTileDirU[dir1][1];
		//u1[3] = m_pRefTerrain->m_fTileDirU[dir1][3];

		//v1[0] = m_pRefTerrain->m_fTileDirV[dir1][2];
		//v1[1] = m_pRefTerrain->m_fTileDirV[dir1][0];
		//v1[2] = m_pRefTerrain->m_fTileDirV[dir1][1];
		//v1[3] = m_pRefTerrain->m_fTileDirV[dir1][3];

		//u2[0] = m_pRefTerrain->m_fTileDirU[dir2][2];
		//u2[1] = m_pRefTerrain->m_fTileDirU[dir2][0];
		//u2[2] = m_pRefTerrain->m_fTileDirU[dir2][1];
		//u2[3] = m_pRefTerrain->m_fTileDirU[dir2][3];

		//v2[0] = m_pRefTerrain->m_fTileDirV[dir2][2];
		//v2[1] = m_pRefTerrain->m_fTileDirV[dir2][0];
		//v2[2] = m_pRefTerrain->m_fTileDirV[dir2][1];
		//v2[3] = m_pRefTerrain->m_fTileDirV[dir2][3];

	}

	if (MapData.Tex2Idx >= m_NumTileTex)
	{
		TexInfo2.pTex = nullptr;
		TexInfo2.u = TexInfo2.v = 0.0f;
	}
	else
	{
		TexInfo2.pTex = &(m_pTileTex[MapData.Tex2Idx]);
		TexInfo2.u = TexInfo2.v = 0.0f;
		//u1[0] = m_pRefTerrain->m_fTileDirU[dir1][2];
		//u1[1] = m_pRefTerrain->m_fTileDirU[dir1][0];
		//u1[2] = m_pRefTerrain->m_fTileDirU[dir1][1];
		//u1[3] = m_pRefTerrain->m_fTileDirU[dir1][3];

		//v1[0] = m_pRefTerrain->m_fTileDirV[dir1][2];
		//v1[1] = m_pRefTerrain->m_fTileDirV[dir1][0];
		//v1[2] = m_pRefTerrain->m_fTileDirV[dir1][1];
		//v1[3] = m_pRefTerrain->m_fTileDirV[dir1][3];

		//u2[0] = m_pRefTerrain->m_fTileDirU[dir2][2];
		//u2[1] = m_pRefTerrain->m_fTileDirU[dir2][0];
		//u2[2] = m_pRefTerrain->m_fTileDirU[dir2][1];
		//u2[3] = m_pRefTerrain->m_fTileDirU[dir2][3];

		//v2[0] = m_pRefTerrain->m_fTileDirV[dir2][2];
		//v2[1] = m_pRefTerrain->m_fTileDirV[dir2][0];
		//v2[2] = m_pRefTerrain->m_fTileDirV[dir2][1];
		//v2[3] = m_pRefTerrain->m_fTileDirV[dir2][3];

	}

	return true;
}

// ===== END WarFare/N3Terrain.cpp =====

// ===== BEGIN WarFare/N3Terrain.h =====
#line 1 "WarFare/N3Terrain.h"
﻿//	N3Terrain.h: interface for the CLyTerrain class.
//	2001. 10. 22.
//
//////////////////////////////////////////////////////////////////////

#ifndef __N3TERRAIN_H__
#define __N3TERRAIN_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////
//	변수앞에 ti_가 붙은 건 타일단위..
//	변수앞에 pat_가 붙은 건 패치단위..
//	변수앞에 re_가 붙은 건 미터단위..
//

#include <N3Base/N3Texture.h>

#include "N3TerrainDef.h"
#include "N3TerrainPatch.h"

#include <string>

//class CN3Terrain : public CGameBase
class CN3Terrain : public CN3BaseFileAccess
{
public:
	//common..
	__Material			m_Material;
	D3DSHADEMODE		m_ShadeMode;
	D3DFILLMODE			m_FillMode;
	int					m_iLodLevel;
			
	//Patch...
	CN3TerrainPatch**	m_ppPatch;
	POINT				m_pat_LBPos;
	POINT				m_pat_PrevLBPos;
	RECT				m_pat_BoundRect;	//LBPos에 대한 상대좌표..
	int					m_iNumPatch;
	int					m_pat_Center2Side;	//중심점에서 한쪽변까지의 길이..
	int					m_iDistanceTable[DISTANCE_TABLE_SIZE][DISTANCE_TABLE_SIZE];
	
	//MapInfo..
	MAPDATA*			m_pMapData;
	int					m_ti_MapSize;				// 셀이 몇개 들어가나.. 4096Meter -> 1024 + 1
	int					m_pat_MapSize;				// 패치 갯수.. 사이즈에 따라 틀리다..
	__Vector3*			m_pNormal;

	//LightMap Info..
	POINT				m_pat_CenterPos;
	stlMap_N3Tex		m_LightMapPatch[3][3];
	
	//bool**			m_ppIsLightMap;
	//CN3Texture***		m_pppLightMapTex;

	//Patch
	float**				m_ppPatchRadius;
	float**				m_ppPatchMiddleY;

	//Tile..
	POINT				m_ti_CenterPos;
	POINT				m_ti_PrevCenterPos;

	//Texture...
	uint32_t				m_NumTileTex;				// Tile Texture 갯수
	CN3Texture*			m_pTileTex;

	//ColorMap..
	CN3Texture**		m_ppColorMapTex;
	int					m_iNumColorMap;				// 컬러맵은 분할 저장되어 있다.. 갯수 = 

	//컬러맵위에 덧 씌우는 무늬맵..
	CN3Texture			m_pBaseTex;

	//타일방향..
	float m_fTileDirU[8][4];
	float m_fTileDirV[8][4];

	//Grass Attr;
	char				m_pGrassTextureName[MAX_GRASS][MAX_PATH];
	char				m_pGrassFileName[MAX_PATH];
	uint8_t*		m_pGrassAttr;
	uint8_t*		m_pGrassNum;
	int					m_iNumGrass;

	class CN3River*		m_pRiver;
	class CN3Pond*		m_pPond;

	bool				m_bAvailableTile;

protected:
	void	SetNormals();
	void	SetLightMap(int dir);
	void	ReplaceLightMapPatch(int x, int z, stlMap_N3Tex& LightMapPatch);
	void	SetLightMapPatch(int x, int z, File& file, int* pAddr);

	
	void	TestAvailableTile();
	void	MakeDistanceTable();

	inline	int	Log2(int x);	//2의 승수 전용....
	int Real2Tile(float x){ return ((int)x / (int)TILE_SIZE); } // 실좌표 -> 타일좌표...(절대좌표)
	int Tile2Patch(int x) { return (x / PATCH_TILE_SIZE); } // 타일좌표 -> 패치좌표...(절대좌표계)
	int Real2Patch(float fX) { return ( ((int)fX / (int)TILE_SIZE) / PATCH_TILE_SIZE ); } // 실좌표 -> 패치좌표..(절대좌표계)
		
	void	LoadTileInfo(File& file);
	bool	CheckRenderablePatch();
	bool	CheckMovePatch();
	bool	CheckBound();
	void	DispositionPatch();
	void	SetBlunt();
	void	LoadGrassInfo();
	
public:
	CN3Texture* GetLightMap(int tx, int tz);
	float	GetWidthByMeter() { return (float)((m_ti_MapSize - 1) * TILE_SIZE); }
	int		GetLODLevel() { return m_iLodLevel; }
	bool	SetLODLevel(int level);
	float	GetHeight(float x, float z);
	void	Release() override;
	void	Init();
	bool	Load(File& file) override;
	void	Tick();
	void	Render();
	void	SetFillMode(D3DFILLMODE FillMode) { m_FillMode = FillMode; }
	void	SetShadeMode(D3DSHADEMODE ShadeMode) {m_ShadeMode = ShadeMode; }
		
	CN3Terrain();
	~CN3Terrain() override;

public:	//additional........
	bool			GetTileTexInfo(float x, float z, TERRAINTILETEXINFO& TexInfo1, TERRAINTILETEXINFO& TexInfo2);
	CN3Texture*		GetTileTex(int x, int z);
	MAPDATA			GetMapData(int x, int z);
	uint16_t		GetGrassAttr(int x, int z);
	bool			LoadColorMap(const std::string& szFN);
	void			GetNormal(float x, float z, __Vector3& vNormal);
	bool			IsInTerrain(float x, float z);
	//..
	BOOL			Pick(int x, int y, __Vector3& vPick);
	BOOL			PickWide(int x, int y, __Vector3& vPick);
	void			CalcCollisionTerrainByOTPlayer(__Vector3, __Vector3, __Vector3& );

	bool			CheckIncline(const __Vector3& vPos, const __Vector3& vDir, float fIncline); // 현재 위치와 방향에서의 경사값이 인수로 들어온것보다 크면(못올라갈 곳이면) true, 작으면 false
	bool			CheckCollisionCamera(__Vector3& vEye, const __Vector3& vAt, float fNP); // vEye 에 계산된 값도 들어온다.. 카메라 Near Plane을 넣으면 계산.
	BOOL			CheckCollisionByHeight(const __Vector3& vPos, float fUnitSize, float& fHeight)
	{
		fHeight = this->GetHeight(vPos.x, vPos.z);
		if(vPos.y < fHeight + fUnitSize) return TRUE; // 현재 높이가 지형높이 + 크기 보다 작다면 
		return FALSE;
	}
	bool			CheckCollision(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vpCol);
	
};

#endif // !defined(__N3TERRAIN_H__)

// ===== END WarFare/N3Terrain.h =====

// ===== BEGIN WarFare/N3TerrainDef.h =====
#line 1 "WarFare/N3TerrainDef.h"
﻿////////////////////////////////////////////////////////////////////////////////////////
//
//	N3TerrainDef.h
//	- 이것저것 Terrain에 관련된 자료형정의, 상수정의...
//	- 게임에 쓰는 지형 (쿼드트리 아님...^^)
//	- 2001. 10. 22.
//
//	By Donghoon..
//
////////////////////////////////////////////////////////////////////////////////////////

#ifndef __N3TERRAINDEF_H__
#define __N3TERRAINDEF_H__

// Constant Definitions..
const int PATCH_TILE_SIZE = 8;		//	패치 하나에 타일이 8x8개 들어간다.
const float TILE_SIZE = 4.0f;			//	타일하나당 길이 4m
const int MAX_LOD_LEVEL = 10;		//	LOD수준이 가장 높은 단계 가장 Detail...
const int MIN_LOD_LEVEL = 0;		//	LOD수준이 가장 낮은 단계 가장 Rough...
const int MAX_PATCH_LEVEL = 3;		//	2 ^ 3 = 8.
const int PATCH_PIXEL_SIZE = 32;	//	패치하나에 들어가는 픽셀수..
const int UNITUV = 32;				//	컬러맵 텍스쳐 한장에 들어가는 타일수..
const int LIGHTMAP_TEX_SIZE = 16;	//	타일 하나당 들어가는 라이트맵 텍스쳐 크기.
const int TILE_PIXEL_SIZE = 128;	//	타일하나의 실제 픽셀 사이즈.
const int COLORMAPTEX_SIZE = 128;	//	컬러맵 텍스쳐의 픽셀크기..128x128
const int DISTANCE_TABLE_SIZE = 64; //	셀단위의 거리 테이블 크기(64 x 64)..
const int MAX_GRASS	= 8;
const int MAX_TERRAIN_SOUND_EFFECT = 4;

enum { DIR_LT = 0, DIR_CT = 1, DIR_RT = 2,
		DIR_LM = 3, DIR_CM = 4, DIR_RM = 5,
		DIR_LB = 6, DIR_CB = 7, DIR_RB = 8,
		DIR_WARP = 9 }; 

// Structure Definitions..
typedef struct __MapData			// 맵데이터...
{
	float	fHeight;				//타일텍스쳐가 꽉차는지 아닌지..
	uint32_t	bIsTileFull	: 1;		//지형의 높이값..
	uint32_t	Tex1Dir		: 5;		//첫번째 타일 텍스쳐 찍는 방향.
	uint32_t	Tex2Dir		: 5;		//두번째 타일 텍스쳐 찍는 방향.
	uint32_t	Tex1Idx		: 10;		//첫번째 타일 텍스쳐의 인덱스.
	uint32_t	Tex2Idx		: 10;		//두번째 타일 텍스쳐의 인덱스.
	
	__MapData()
	{
		bIsTileFull = true;
		fHeight = FLT_MIN;
		Tex1Idx = 1023;
		Tex1Dir = 0;
		Tex2Idx = 1023;
		Tex2Dir = 0;
	}
} MAPDATA, *LPMAPDATA;

typedef struct __FanInfo
{
	int		NumFace;
	int		NumVertex;
} FANINFO, *LPFANINFO;

typedef struct __TerrainTileTexInfo
{
	class CN3Texture* pTex;
	float u;
	float v;
	
	__TerrainTileTexInfo()
	{
		pTex = nullptr;
		u = v = 0.0f;
	}
} TERRAINTILETEXINFO, *LPTERRAINTILETEXINFO;

typedef struct __TerrainBGMInfo
{
	std::string szBGM[MAX_TERRAIN_SOUND_EFFECT];
	float		fBGMRegenTime[MAX_TERRAIN_SOUND_EFFECT];
	std::string szBGE[MAX_TERRAIN_SOUND_EFFECT];
	float		fBGERegenTime[MAX_TERRAIN_SOUND_EFFECT];

	__TerrainBGMInfo()
	{
		for(int i=0;i<MAX_TERRAIN_SOUND_EFFECT;i++)
		{
			szBGM[i] = "";
			fBGMRegenTime[i] = 0.0f;
			szBGE[i] = "";
			fBGERegenTime[i] = 0.0f;
		}
	}
} TERRAINBGMINFO, *LPTERRAINBGMINFO;

#include <list>
typedef std::list<FANINFO> FanInfoList;
typedef FanInfoList::iterator FIIt;
//typedef CellInfoList::value_type DTValue;

#include <map>
typedef std::map<uint32_t,class CN3Texture*> stlMap_N3Tex;
typedef stlMap_N3Tex::iterator stlMap_N3TexIt;
typedef stlMap_N3Tex::value_type stlMap_N3TexValue;

#endif	//end of #ifndef __LYTERRAINDEF_H__
// ===== END WarFare/N3TerrainDef.h =====

// ===== BEGIN WarFare/N3TerrainManager.cpp =====
#line 1 "WarFare/N3TerrainManager.cpp"
﻿// N3TerrainManager.cpp: implementation of the CN3TerrainManager class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3TerrainManager.h"
#include "N3Terrain.h"
#include "N3ClientShapeMgr.h"
#include "BirdMng.h"
//#include "GrassMng.h"
#include "GameProcedure.h"
#include "PlayerMySelf.h"

#include <N3Base/N3SkyMng.h>
#include <N3Base/LogWriter.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3TerrainManager::CN3TerrainManager()
{
	// N3Terrain..
	m_pTerrain = new CN3Terrain;

	// Shape..
	m_pShapes = new CN3ClientShapeMgr();

	// Sky..
	m_pSky = new CN3SkyMng();

	// Bird..
	m_pBirdMng = new CBirdMng();

//	// Grass..
//	m_pGrasses = new CGrassMng();
}

CN3TerrainManager::~CN3TerrainManager()
{
	// N3Terrain..
	delete m_pTerrain;  m_pTerrain = nullptr;

	// Shape..
	delete m_pShapes; m_pShapes = nullptr;

	// Sky..
	delete m_pSky;		m_pSky = nullptr;

	// Bird..
	delete m_pBirdMng; m_pBirdMng = nullptr;

	// Grass..
//	delete m_pGrasses; m_pGrasses = nullptr;
}

/////////////////////////////////////////////////////////////////////

void CN3TerrainManager::InitWorld(int iZoneID, const __Vector3& vPosPlayer)
{
	__TABLE_ZONE* pZone = s_pTbl_Zones.Find(s_pPlayer->m_InfoExt.iZoneCur);
	if (pZone == nullptr)
	{
		CLogWriter::Write("Null Zone Data : {}", iZoneID);
		return;
	}

	/*if(iZoneID == 1) m_pTerrain->LoadFromFile(pZone->szTerrainFN, N3FORMAT_VER_1068);//N3FORMAT_VER_1298);//pZone->dwVersion);
	else*/ m_pTerrain->LoadFromFile(pZone->szTerrainFN);//, N3FORMAT_VER_1298);


	m_pTerrain->LoadColorMap(pZone->szColorMapFN);		// 컬러맵 로드..
	m_pShapes->Release();


	/*if(iZoneID == 1) m_pShapes->LoadFromFile(pZone->szObjectPostDataFN, N3FORMAT_VER_1068);
	else*/ m_pShapes->LoadFromFile(pZone->szObjectPostDataFN);//, N3FORMAT_VER_1298);//, pZone->dwVersion);	// 오브젝트 데이터 로드..
	

	char szFName[_MAX_PATH];
	_splitpath(pZone->szTerrainFN.c_str(), nullptr, nullptr, szFName, nullptr);
	std::string szFName2 = fmt::format("{}_Bird",szFName);

	char szFullPathName[_MAX_PATH];
	_makepath(szFullPathName, nullptr, "misc\\bird", szFName2.c_str(), "lst");
	m_pBirdMng->LoadFromFile(szFullPathName);

//	m_pGrasses->Init(vPosPlayer);
	m_pSky->LoadFromFile(pZone->szSkySetting); // 하늘, 구름, 태양, 날씨 변화등 정보 및 텍스처 로딩..
	m_pSky->SunAndMoonDirectionFixByHour(pZone->iFixedSundDirection); // 해, 달 방향을 고정하든가 혹은 0 이면 고정하지 않는다.
}

void CN3TerrainManager::Tick()
{
	m_pTerrain->Tick();
	m_pShapes->Tick();
//	m_pGrasses->Tick((CGameProcedure* )CGameProcedure::s_pProcMain);
	m_pSky->Tick();
	m_pBirdMng->Tick();
}

CN3Terrain* CN3TerrainManager::GetTerrainRef()
{
	return m_pTerrain;
}

CN3SkyMng* CN3TerrainManager::GetSkyRef()
{
	return m_pSky;
}

void CN3TerrainManager::RenderTerrain()
{
	if (m_pTerrain)		m_pTerrain->Render();
}

void CN3TerrainManager::RenderShape()
{
	if (m_pShapes)		m_pShapes->Render();
}

void CN3TerrainManager::RenderSky()
{
	if (m_pSky)		m_pSky->Render();
}

void CN3TerrainManager::RenderGrass()
{
//	if (m_pGrasses)		m_pGrasses->Render();
}

void CN3TerrainManager::RenderBirdMgr()
{
	if (m_pBirdMng)		m_pBirdMng->Render();
}

void CN3TerrainManager::RenderSkyWeather()
{
	if (m_pSky)		m_pSky->RenderWeather();
}

//////////////////////////////////////////////////////////////////////////////////

// Terrain..
bool CN3TerrainManager::CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	if (m_pTerrain)		
		return m_pTerrain->CheckCollisionCamera(vEyeResult, vAt, fNP);
	else
		return false;
}

float CN3TerrainManager::GetHeightWithTerrain(float x, float z, bool bWarp)
{

	if (m_pTerrain)		
		return m_pTerrain->GetHeight(x, z);
	else
		return -FLT_MAX;
}

BOOL CN3TerrainManager::PickWideWithTerrain(int x, int y, __Vector3& vPick)
{
	if (m_pTerrain)
		return m_pTerrain->PickWide(x, y, vPick);
	else
		return FALSE;
}

bool CN3TerrainManager::CheckCollisionWithTerrain(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol)
{
	if (m_pTerrain)
		return m_pTerrain->CheckCollision(vPos, vDir, fVelocity, vCol);
	else
		return false;
}

void CN3TerrainManager::GetNormalWithTerrain(float x, float z, __Vector3& vNormal)
{
	if (m_pTerrain)	m_pTerrain->GetNormal(x, z, vNormal);
}

float CN3TerrainManager::GetWidthByMeterWithTerrain()
{
	if (m_pTerrain)
		return m_pTerrain->GetWidthByMeter();
	else
		return -FLT_MAX;
}

bool CN3TerrainManager::IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore)
{
	if (m_pTerrain)
		return m_pTerrain->IsInTerrain(x, z);
	else
		return false;	
}

bool CN3TerrainManager::CheckInclineWithTerrain(const __Vector3& vPos, const __Vector3& vDir, float fIncline)
{
	if (m_pTerrain)
		return m_pTerrain->CheckIncline(vPos, vDir, fIncline);
	else
		return false;	
}

// Shapes..
bool CN3TerrainManager::CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	if (m_pShapes) 
		return m_pShapes->CheckCollisionCamera(vEyeResult, vAt, fNP);
	else
		return false;
}

float CN3TerrainManager::GetHeightNearstPosWithShape(const __Vector3 &vPos, float fDist, __Vector3* pvNormal)
{
	if (m_pShapes) 
		return m_pShapes->GetHeightNearstPos(vPos, fDist, pvNormal);
	else
		return -FLT_MAX;
}

void CN3TerrainManager::RenderCollisionWithShape(const __Vector3& vPos)
{
	if (m_pShapes) m_pShapes->RenderCollision(vPos);
}

float CN3TerrainManager::GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal)
{
	if (m_pShapes) 
		return m_pShapes->GetHeight(fX, fZ, pvNormal);
	else
		return -FLT_MAX;
}

CN3Shape* CN3TerrainManager::ShapeGetByIDWithShape(int iID)
{
	if (m_pShapes) 
		return m_pShapes->ShapeGetByID(iID);
	else
		return nullptr;
}

CN3Shape* CN3TerrainManager::PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick)
{
	if (m_pShapes) 
		return m_pShapes->Pick(iXScreen, iYScreen, bMustHaveEvent, pvPick);
	else
		return nullptr;
}

bool CN3TerrainManager::CheckCollisionWithShape(	  const __Vector3& vPos,				 // 충돌 위치
																						const __Vector3& vDir,				   // 방향 벡터
																						float fSpeedPerSec,					    // 초당 움직이는 속도
																						__Vector3* pvCol,						 // 충돌 지점
																						__Vector3* pvNormal,				  // 충돌한면의 법선벡터
																						__Vector3* pVec)						// 충돌한 면 의 폴리곤 __Vector3[3]
{
	if (m_pShapes) 
		return m_pShapes->CheckCollision( vPos, vDir, fSpeedPerSec, pvCol, pvNormal, pVec);
	else
		return false;
}

// Sky..
D3DCOLOR CN3TerrainManager::GetSkyColorWithSky()
{
	if (m_pSky)
		return m_pSky->GetSkyColor();
	else
		return 0xffffffff;
}

float CN3TerrainManager::GetSunAngleByRadinWithSky()	
{ 	
	if (m_pSky)
		return m_pSky->GetSunAngleByRadin();
	else
		return -FLT_MAX;
}

void CN3TerrainManager::RenderWeatherWithSky()
{
	if (m_pSky)	m_pSky->RenderWeather();	
}

void CN3TerrainManager::SetGameTimeWithSky(int iYear, int iMonth, int iDay, int iHour, int iMin)
{
	if (m_pSky)	m_pSky->SetGameTime(iYear, iMonth, iDay, iHour, iMin);
}

void CN3TerrainManager::SetWeatherWithSky(int iWeather, int iPercentage)
{
	if (m_pSky)	m_pSky->SetWeather((CN3SkyMng::eSKY_WEATHER)iWeather, iPercentage);
}

D3DCOLOR CN3TerrainManager::GetLightDiffuseColorWithSky(int iIndex)
{
	if (m_pSky)	
		return m_pSky->GetLightDiffuseColor(iIndex);
	else
		return 0xffffffff;
}

D3DCOLOR CN3TerrainManager::GetLightAmbientColorWithSky(int iIndex)
{
	if (m_pSky)	
		return 	m_pSky->GetLightAmbientColor(iIndex);
	else
		return 0xffffffff;
}

D3DCOLOR CN3TerrainManager::GetFogColorWithSky()
{
	if (m_pSky)	
		return m_pSky->GetFogColor();
	else
		return 0xffffffff;
}

/*
CN3Sun*	CN3TerrainManager::GetSunPointerWithSky()
{
	if (m_pSky)
		return m_pSky->GetSunPointer();
	else
		return nullptr;
}
*/

// Grass..
void CN3TerrainManager::InitWithGrass(__Vector3 CamPo)
{
//	if (m_pGrasses)	m_pGrasses->Init(CamPo);
}









// ===== END WarFare/N3TerrainManager.cpp =====

// ===== BEGIN WarFare/N3TerrainManager.h =====
#line 1 "WarFare/N3TerrainManager.h"
﻿// N3TerrainManager.h: interface for the CN3TerrainManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3TERRAINMANAGER_H__4FA514AC_F8F8_4E09_88DC_AC31F2C9B21D__INCLUDED_)
#define AFX_N3TERRAINMANAGER_H__4FA514AC_F8F8_4E09_88DC_AC31F2C9B21D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3WorldBase.h"

class CN3TerrainManager : public CN3WorldBase
{
	friend class CN3WorldManager;

	class CN3Terrain*		m_pTerrain;										  // 지형 클래스
	class CN3ShapeMgr*		m_pShapes;										// 물체 클래스
	class CN3SkyMng*		m_pSky;											  // 하늘 클래스
	class CBirdMng*			m_pBirdMng;									     // 하늘에 날라다니는 새들 관리..
//	class CGrassMng*		m_pGrasses;									  // 풀 그림

	// Function..
	void InitWorld(int iZoneID, const __Vector3& vPosPlayer);
	void Tick();

//////////////////////////////////////////////////////////////////////
	CN3Terrain* GetTerrainRef();
	CN3SkyMng* GetSkyRef();

	// Terrain..
	bool CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	float GetHeightWithTerrain(float x, float z, bool bWarp = false);
	BOOL PickWideWithTerrain(int x, int y, __Vector3& vPick);
	bool CheckCollisionWithTerrain(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol);
	void GetNormalWithTerrain(float x, float z, __Vector3& vNormal);
	float GetWidthByMeterWithTerrain();
	bool IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore = __Vector3());
	bool CheckInclineWithTerrain(const __Vector3& vPos, const __Vector3& vDir, float fIncline);

	// Shapes..
	bool CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	float GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr); 
	void RenderCollisionWithShape(const __Vector3& vPos);
	float GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal = nullptr); 
	CN3Shape* ShapeGetByIDWithShape(int iID);
	CN3Shape* PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr);
	bool CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
														const __Vector3& vDir,				   // 방향 벡터
														float fSpeedPerSec,					    // 초당 움직이는 속도
														__Vector3* pvCol = nullptr,			 // 충돌 지점
														__Vector3* pvNormal = nullptr,		 // 충돌한면의 법선벡터
														__Vector3* pVec = nullptr);			// 충돌한 면 의 폴리곤 __Vector3[3]

	// Sky..
	D3DCOLOR GetSkyColorWithSky();
	float GetSunAngleByRadinWithSky();
	void RenderWeatherWithSky();
	void SetGameTimeWithSky(int iYear, int iMonth, int iDay, int iHour, int iMin);
	void SetWeatherWithSky(int iWeather, int iPercentage);
	D3DCOLOR GetLightDiffuseColorWithSky(int iIndex);
	D3DCOLOR GetLightAmbientColorWithSky(int iIndex);
	D3DCOLOR GetFogColorWithSky();
	//CN3Sun*	GetSunPointerWithSky();

	// Bird..

	// Grass..
	void InitWithGrass(__Vector3 CamPo);

	// Rendering..
	void RenderTerrain();
	void RenderShape();	
	void RenderSky();
	void RenderGrass();
	void RenderBirdMgr();
	void RenderSkyWeather();

public:
	CN3TerrainManager();
	virtual ~CN3TerrainManager();
};

#endif // !defined(AFX_N3TERRAINMANAGER_H__4FA514AC_F8F8_4E09_88DC_AC31F2C9B21D__INCLUDED_)

// ===== END WarFare/N3TerrainManager.h =====

// ===== BEGIN WarFare/N3TerrainPatch.cpp =====
#line 1 "WarFare/N3TerrainPatch.cpp"
﻿// N3TerrainPatch.cpp: implementation of the CN3TerrainPatch class.
// 2001.10.22.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3TerrainPatch.h"
#include "N3Terrain.h"

#include <N3Base/N3Texture.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif


//
//	생성자
//
CN3TerrainPatch::CN3TerrainPatch()
{
	m_bIsRender = FALSE;
	m_iLevel = 0;
	m_CellSize = 0;
	m_NumCell = 0;
	m_ti_LBPoint.x = m_ti_LBPoint.y = -1;
	m_pRefTerrain = nullptr;
	for(int i=0;i<4;i++) m_IsBlunt[i] = true;

	m_pRefColorTex = nullptr;
	
	m_VBSize[2] = 10;
	m_VBSize[1] = 56;
	m_VBSize[0] = 256;

	m_pVB = nullptr;

	m_FanInfoList.clear();

	m_pTileTexIndx[0] = nullptr;
	m_pTileTexIndx[1] = nullptr;
	m_pIsTileFull = nullptr;

	//lightmap...
	m_pLightMapVB = nullptr;
	m_pRefLightMapTex = nullptr;
	m_NumLightMapTex = 0;
}


//
//	소멸자
//
CN3TerrainPatch::~CN3TerrainPatch()
{
	Release();
}


//
//
//
void CN3TerrainPatch::Release()
{
	if(m_pVB)
	{
		m_pVB->Release();
		m_pVB = nullptr;
	}

	if(m_pLightMapVB)
	{
		m_pLightMapVB->Release();
		m_pLightMapVB = nullptr;
	}
	
	m_FanInfoList.clear();

	for(int i=0;i<2;i++)
	{
		delete[] m_pTileTexIndx[i];
		m_pTileTexIndx[i] = nullptr;
	}
	delete[] m_pIsTileFull;
	m_pIsTileFull = nullptr;

	if(m_pRefLightMapTex)
	{
		delete[] m_pRefLightMapTex;	
		m_pRefLightMapTex = nullptr;
	}
}


//
//
//
void CN3TerrainPatch::Init()
{
	Release();

	for(int i=0;i<4;i++) m_IsBlunt[i] = true;
	m_bIsRender = FALSE;
	m_iLevel = 0;
	m_CellSize = 0;
	m_NumCell = 0;

	m_NumLightMapTex = 0;
	m_pLightMapVB = nullptr;
	m_pRefLightMapTex = nullptr;

	m_ti_LBPoint.x = m_ti_LBPoint.y = -1;
	m_pRefTerrain = nullptr;

	m_pVB = nullptr;
	m_pRefColorTex = nullptr;

	m_pTileTexIndx[0] = nullptr;
	m_pTileTexIndx[1] = nullptr;
	m_pIsTileFull = nullptr;
	
	m_FanInfoList.clear();
}


//
//
//
void CN3TerrainPatch::Init(CN3Terrain* pTerrain)
{
	Release();

	for(int i=0;i<4;i++) m_IsBlunt[i] = true;
	m_bIsRender = FALSE;
	m_iLevel = 0;
	m_CellSize = 0;
	m_NumCell = 0;

	m_NumLightMapTex = 0;
	m_pLightMapVB = nullptr;
	m_pRefLightMapTex = nullptr;

	m_ti_LBPoint.x = m_ti_LBPoint.y = -1;
	m_pRefTerrain = pTerrain;

	m_pVB = nullptr;
	m_pRefColorTex = nullptr;

	for(int i=0;i<2;i++) 
	{
		m_pTileTexIndx[i] = new uint32_t [PATCH_TILE_SIZE*PATCH_TILE_SIZE];
		memset(m_pTileTexIndx[i], 0xff, sizeof(uint32_t)*PATCH_TILE_SIZE*PATCH_TILE_SIZE);
	}
	m_pIsTileFull = new bool [PATCH_TILE_SIZE*PATCH_TILE_SIZE];

	m_FanInfoList.clear();
}


//
//	Set Level....
//
void CN3TerrainPatch::SetLevel(int level)
{
	if(level==m_iLevel) return;

	m_iLevel = level;

	m_CellSize = 1 << level;
	m_NumCell = PATCH_TILE_SIZE / m_CellSize;
	m_FanInfoList.clear();

	if(m_pVB) { m_pVB->Release(); m_pVB = nullptr; }
	if(m_pLightMapVB) { m_pLightMapVB->Release(); m_pLightMapVB = nullptr; }
	m_NumLightMapTex = 0;
	delete [] m_pRefLightMapTex; m_pRefLightMapTex = nullptr;

	HRESULT hr;
	if(level==1)
	{
		hr = CN3Base::s_lpD3DDev->CreateVertexBuffer( m_VBSize[level-1]*sizeof(__VertexT2), 0, FVF_VNT2, D3DPOOL_MANAGED, &m_pVB, nullptr );
		hr = CN3Base::s_lpD3DDev->CreateVertexBuffer( m_VBSize[level-1]*sizeof(__VertexT1), 0, FVF_VNT1, D3DPOOL_MANAGED, &m_pLightMapVB, nullptr );

		m_NumLightMapTex = 0;
		m_pRefLightMapTex = new CN3Texture* [PATCH_TILE_SIZE*PATCH_TILE_SIZE];
	}
	else
	{
		hr = CN3Base::s_lpD3DDev->CreateVertexBuffer( m_VBSize[level-1]*sizeof(__VertexT1), 0, FVF_VNT1, D3DPOOL_MANAGED, &m_pVB, nullptr );
	}
}


//
//
//
void CN3TerrainPatch::Tick()
{
	if(m_ti_LBPoint.x < 0 || m_ti_LBPoint.y < 0 ||
		m_ti_LBPoint.x >= (m_pRefTerrain->m_ti_MapSize-1) || m_ti_LBPoint.y >= (m_pRefTerrain->m_ti_MapSize-1)
	)
	{
		m_bIsRender = FALSE;		
	}
	if(m_bIsRender==FALSE) return;

	int HalfCell = m_CellSize >> 1;
	
	int VertexIdx = 0;
	int FaceCount = 0;
	int VertexCount = 0;
	
	int ix, iz;
	int tx, tz;
	int cx, cz;	//cell center point...
		
	FANINFO FaceInfo;
	
	if(m_iLevel==1)
	{
		m_FanInfoList.clear();
		m_NumLightMapTex = 0;
		__VertexT1* pLightMapVertices = nullptr;

		__VertexT2* pVertices;
		if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
			return;

		int dir1, dir2;
		int TileCount = 0;
		float u1[4], u2[4], v1[4], v2[4];

		///////////////////////////////////
		//unitUV
		//				
		for(ix=0; ix<PATCH_TILE_SIZE;ix++)
		{
			for(iz=0; iz<PATCH_TILE_SIZE;iz++)
			{
				tx = ix + m_ti_LBPoint.x;
				tz = iz + m_ti_LBPoint.y;

				MAPDATA MapData = m_pRefTerrain->GetMapData(tx,tz);

				dir1 = MapData.Tex1Dir;
				dir2 = MapData.Tex2Dir;

				m_pTileTexIndx[0][TileCount] = MapData.Tex1Idx;
				m_pTileTexIndx[1][TileCount] = MapData.Tex2Idx;
				m_pIsTileFull[TileCount] = MapData.bIsTileFull;

				if( m_pTileTexIndx[0][TileCount]>m_pRefTerrain->m_NumTileTex || m_pIsTileFull[TileCount]==false)	// 타일이 없는 경우..컬러맵을 찍어야 돼...
				{
					u1[0] = u1[1] = UVConvert((float)(tx%UNITUV) / (float)UNITUV);
					u1[2] = u1[3] = UVConvert(u1[0] + (1.0f/(float)UNITUV));

					v1[0] = v1[3] = UVConvert((float)(UNITUV - (tz%UNITUV)) / (float)UNITUV);
					v1[1] = v1[2] = UVConvert(v1[0] - (1.0f/(float)UNITUV));

					//u1[0] =	u1[1] = (float)(tx%UNITUV) / (float)UNITUV;
					//u1[2] = u1[3] = u1[0] + (1.0f/(float)UNITUV);

					//v1[0] = v1[3] = (float)(UNITUV - (tz%UNITUV)) / (float)UNITUV;
					//v1[1] = v1[2] = v1[0] - (1.0f/(float)UNITUV);

					u2[0] =	u2[1] = 0.0f;
					u2[2] = u2[3] = 1.0f;

					v2[0] = v2[3] = 0.0f;
					v2[1] = v2[2] = 1.0f;
				}
				else	// 타일을 찍는 경우...
				{
					u1[0] = m_pRefTerrain->m_fTileDirU[dir1][2];
					u1[1] = m_pRefTerrain->m_fTileDirU[dir1][0];
					u1[2] = m_pRefTerrain->m_fTileDirU[dir1][1];
					u1[3] = m_pRefTerrain->m_fTileDirU[dir1][3];

					v1[0] = m_pRefTerrain->m_fTileDirV[dir1][2];
					v1[1] = m_pRefTerrain->m_fTileDirV[dir1][0];
					v1[2] = m_pRefTerrain->m_fTileDirV[dir1][1];
					v1[3] = m_pRefTerrain->m_fTileDirV[dir1][3];

					u2[0] = m_pRefTerrain->m_fTileDirU[dir2][2];
					u2[1] = m_pRefTerrain->m_fTileDirU[dir2][0];
					u2[2] = m_pRefTerrain->m_fTileDirU[dir2][1];
					u2[3] = m_pRefTerrain->m_fTileDirU[dir2][3];

					v2[0] = m_pRefTerrain->m_fTileDirV[dir2][2];
					v2[1] = m_pRefTerrain->m_fTileDirV[dir2][0];
					v2[2] = m_pRefTerrain->m_fTileDirV[dir2][1];
					v2[3] = m_pRefTerrain->m_fTileDirV[dir2][3];
				}

				if((ix+iz)%2==0)
				{
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[0], v1[0], u2[0], v2[0]);
					pVertices[VertexIdx+1].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz+1).fHeight,
												(float)((tz+1) * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[1], v1[1], u2[1], v2[1]);
					pVertices[VertexIdx+2].Set( (float)((tx+1) * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx+1,tz+1).fHeight,
												(float)((tz+1) * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[2], v1[2], u2[2], v2[2]);
					pVertices[VertexIdx+3].Set( (float)((tx+1) * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx+1,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[3], v1[3], u2[3], v2[3]);
					VertexIdx+=4;
					TileCount++;

					//set lightmap vb...
					if(m_pRefTerrain->GetLightMap(tx, tz))
					{
						m_pRefLightMapTex[m_NumLightMapTex] = m_pRefTerrain->GetLightMap(tx, tz);

						if (pLightMapVertices == nullptr
							&& FAILED(m_pLightMapVB->Lock(0, 0, (void**) &pLightMapVertices, 0)))
						{
							m_pVB->Unlock();
							return;
						}

						int VBIndx = m_NumLightMapTex * 4;
						float suv = 1.0f/(float)LIGHTMAP_TEX_SIZE;
						float euv = (float)(LIGHTMAP_TEX_SIZE - 1.0f)/(float)LIGHTMAP_TEX_SIZE;

						pLightMapVertices[VBIndx].Set((float)(tx * TILE_SIZE), m_pRefTerrain->GetMapData(tx,tz).fHeight,
														(float)(tz * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														suv, euv);
						pLightMapVertices[VBIndx+1].Set((float)(tx * TILE_SIZE), m_pRefTerrain->GetMapData(tx,tz+1).fHeight,
														(float)((tz+1) * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														suv, suv);
						pLightMapVertices[VBIndx+2].Set((float)((tx+1) * TILE_SIZE), m_pRefTerrain->GetMapData(tx+1,tz+1).fHeight,
														(float)((tz+1) * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														euv, suv);
						pLightMapVertices[VBIndx+3].Set((float)((tx+1) * TILE_SIZE), m_pRefTerrain->GetMapData(tx+1,tz).fHeight,
														(float)(tz * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														euv, euv);
						
						m_NumLightMapTex++;			
					}
				}
				else
				{
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz+1).fHeight,
												(float)((tz+1) * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[1], v1[1], u2[1], v2[1]);
					pVertices[VertexIdx+1].Set( (float)((tx+1) * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx+1,tz+1).fHeight,
												(float)((tz+1) * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[2], v1[2], u2[2], v2[2]);
					pVertices[VertexIdx+2].Set( (float)((tx+1) * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx+1,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[3], v1[3], u2[3], v2[3]);
					pVertices[VertexIdx+3].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												u1[0], v1[0], u2[0], v2[0]);
					VertexIdx+=4;
					TileCount++;

					//set lightmap vb...
					if(m_pRefTerrain->GetLightMap(tx, tz))
					{
						m_pRefLightMapTex[m_NumLightMapTex] = m_pRefTerrain->GetLightMap(tx, tz);

						if (pLightMapVertices == nullptr
							&& FAILED(m_pLightMapVB->Lock(0, 0, (void**) &pLightMapVertices, 0)))
						{
							m_pVB->Unlock();
							return;
						}

						int VBIndx = m_NumLightMapTex * 4;
						float suv = 1.0f/(float)LIGHTMAP_TEX_SIZE;
						float euv = (float)(LIGHTMAP_TEX_SIZE - 1.0f)/(float)LIGHTMAP_TEX_SIZE;

						pLightMapVertices[VBIndx].Set((float)(tx * TILE_SIZE), m_pRefTerrain->GetMapData(tx,tz+1).fHeight,
														(float)((tz+1) * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														suv, suv);
						pLightMapVertices[VBIndx+1].Set((float)((tx+1) * TILE_SIZE), m_pRefTerrain->GetMapData(tx+1,tz+1).fHeight,
														(float)((tz+1) * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														euv, suv);
						pLightMapVertices[VBIndx+2].Set((float)((tx+1) * TILE_SIZE), m_pRefTerrain->GetMapData(tx+1,tz).fHeight,
														(float)(tz * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														euv, euv);
						pLightMapVertices[VBIndx+3].Set((float)(tx * TILE_SIZE), m_pRefTerrain->GetMapData(tx,tz).fHeight,
														(float)(tz * TILE_SIZE), 0.0f, 1.0f, 0.0f,
														suv, euv);						
						m_NumLightMapTex++;			
					}
				}
			}
		}

		if(pLightMapVertices) m_pLightMapVB->Unlock();

		m_pVB->Unlock();
		return;
	}

	float tu,tv;	//center u,v...
	if(m_iLevel==2)
	{
		m_FanInfoList.clear();
		__VertexT1* pVertices;
		if (FAILED(m_pVB->Lock(0, 0, (void**) &pVertices, 0)))
			return;

		float HalfUV = (float)HalfCell/(float)UNITUV;

		for(ix=0; ix<m_NumCell; ix++)
		{
			for(iz=0; iz<m_NumCell; iz++)
			{
				VertexCount = VertexIdx;
				FaceCount = 0;

				cx = ix*m_CellSize + HalfCell + m_ti_LBPoint.x;
				cz = iz*m_CellSize + HalfCell + m_ti_LBPoint.y;

				//cell의 가운데 점...
				tx = cx;
				tz = cz;

				tu = (float)(tx%UNITUV) / (float)UNITUV;
				tv = (float)(UNITUV - (tz%UNITUV)) / (float)UNITUV;
				
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
										m_pRefTerrain->GetMapData(tx,tz).fHeight,
										(float)(tz * TILE_SIZE),
										0.0f, 1.0f, 0.0f,
										UVConvert(tu),
										UVConvert(tv));
										//tu, tv);
				VertexIdx++;
				
				//LB Point..
				tx = cx - HalfCell;
				tz = cz - HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv + HalfUV));
											//tu - HalfUV, tv + HalfUV);
				VertexIdx++;
				
				// LM Point...
				if( (ix==0) && (m_IsBlunt[0]==false) )
				{
					for(int i=0;i<3;i++)
					{
						tz++;
						pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
													m_pRefTerrain->GetMapData(tx,tz).fHeight,
													(float)(tz * TILE_SIZE),
													0.0f, 1.0f, 0.0f,
													UVConvert(tu - HalfUV),
													UVConvert((float)(UNITUV - (tz%UNITUV)) / (float)UNITUV));
													//(tu - HalfUV), ((float)(UNITUV - (tz%UNITUV)) / (float)UNITUV));
						VertexIdx++;
						FaceCount++;
					}
				}

				//LT.......
				tz = cz + HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv - HalfUV));
											//(tu - HalfUV), (tv - HalfUV));
				VertexIdx++;
				FaceCount++;
				
				// MT...
				if( ((iz+1)==m_NumCell) && (m_IsBlunt[1]==false) )
				{
					for(int i=0;i<3;i++)
					{
						tx++;
						pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
													m_pRefTerrain->GetMapData(tx,tz).fHeight,
													(float)(tz * TILE_SIZE),
													0.0f, 1.0f, 0.0f,
													UVConvert((float)(tx%UNITUV) / (float)UNITUV),
													UVConvert(tv - HalfUV));
													//((float)(tx%UNITUV) / (float)UNITUV), (tv - HalfUV));
						VertexIdx++;
						FaceCount++;
					}
				}

				//RT.......
				tx = cx + HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu + HalfUV),
											UVConvert(tv - HalfUV));
											//(tu + HalfUV), (tv - HalfUV));
				VertexIdx++;
				FaceCount++;

				// RM...
				if( ((ix+1)==m_NumCell) && (m_IsBlunt[2]==false) )
				{
					for(int i=0;i<3;i++)
					{
						//tx = cx + HalfCell;
						tz--;
						pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
													m_pRefTerrain->GetMapData(tx,tz).fHeight,
													(float)(tz * TILE_SIZE),
													0.0f, 1.0f, 0.0f,
													UVConvert(tu + HalfUV),
													UVConvert((float)(UNITUV - (tz%UNITUV)) / (float)UNITUV));
													//(tu + HalfUV), ((float)(UNITUV - (tz%UNITUV)) / (float)UNITUV));
						VertexIdx++;
						FaceCount++;
					}
				}

				//RB......
				//tx = cx + HalfCell;
				tz = cz - HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu + HalfUV),
											UVConvert(tv + HalfUV));
											//(tu + HalfUV), (tv + HalfUV));
				VertexIdx++;
				FaceCount++;

				// MB...
				if( (iz==0) && (m_IsBlunt[3]==false) )
				{
					for(int i=0;i<3;i++)
					{
						tx--;							
						pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
													m_pRefTerrain->GetMapData(tx,tz).fHeight,
													(float)(tz * TILE_SIZE),
													0.0f, 1.0f, 0.0f,
													UVConvert((float)(tx%UNITUV) / (float)UNITUV),
													UVConvert(tv + HalfUV));
													//((float)(tx%UNITUV) / (float)UNITUV), (tv + HalfUV));
						VertexIdx++;
						FaceCount++;
					}
				}

				//LB Point..
				tx = cx - HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv + HalfUV));
											//(tu - HalfUV), (tv + HalfUV));
				VertexIdx++;
				FaceCount++;
				FaceInfo.NumFace = FaceCount;
				FaceInfo.NumVertex = VertexIdx - VertexCount;
				m_FanInfoList.push_back(FaceInfo);
			}
		}
	
		m_pVB->Unlock();
		return;
	}

	if(m_iLevel>2)	// level3 이상..	
	{
		m_FanInfoList.clear();
		__VertexT1* pVertices;
		HRESULT hr = m_pVB->Lock( 0, 0, (void**)&pVertices, 0 );
		if (FAILED(hr))
			return;

		float HalfUV = (float)HalfCell/(float)UNITUV;

		for(ix=0; ix<m_NumCell; ix++)
		{
			for(iz=0; iz<m_NumCell; iz++)
			{
				VertexCount = VertexIdx;
				FaceCount = 0;

				cx = ix*m_CellSize + HalfCell + m_ti_LBPoint.x;
				cz = iz*m_CellSize + HalfCell + m_ti_LBPoint.y;

				//cell의 가운데 점...
				tx = cx;
				tz = cz;

				tu = (float)(tx%UNITUV) / (float)UNITUV;
				tv = (float)(UNITUV - (tz%UNITUV)) / (float)UNITUV;

				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
										m_pRefTerrain->GetMapData(tx,tz).fHeight,
										(float)(tz * TILE_SIZE),
										0.0f, 1.0f, 0.0f,
										UVConvert(tu),
										UVConvert(tv));
										//(tu), (tv));
				VertexIdx++;
				
				//LB Point..
				tx = cx - HalfCell;
				tz = cz - HalfCell;

				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv + HalfUV));
											//(tu - HalfUV),
											//(tv + HalfUV));
				VertexIdx++;
				
				// LM Point...
				if( (ix==0) && (m_IsBlunt[0]==false) )
				{
					tz += HalfCell;
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												UVConvert(tu - HalfUV),
												UVConvert(tv));
												//(tu - HalfUV),
												//(tv));
					VertexIdx++;
					FaceCount++;
				}

				//LT.......
				//tx = cx - HalfCell;
				tz = cz + HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv - HalfUV));
											//(tu - HalfUV), (tv - HalfUV));
				VertexIdx++;
				FaceCount++;
				
				// MT...
				if( ((iz+1)==m_NumCell) && (m_IsBlunt[1]==false) )
				{
					tx += HalfCell;
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												UVConvert(tu),
												UVConvert(tv - HalfUV));
												//(tu), (tv - HalfUV));
					VertexIdx++;
					FaceCount++;
				}

				//RT.......
				tx = cx + HalfCell;		
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu + HalfUV),
											UVConvert(tv - HalfUV));
											//(tu + HalfUV), (tv - HalfUV));
				VertexIdx++;
				FaceCount++;

				// RM...
				if( ((ix+1)==m_NumCell) && (m_IsBlunt[2]==false) )
				{
					tz -= HalfCell;
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												UVConvert(tu + HalfUV),
												UVConvert(tv));
												//(tu + HalfUV), (tv));
					VertexIdx++;
					FaceCount++;
				}

				//RB......
				//tx = cx + HalfCell;
				tz = cz - HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu + HalfUV),
											UVConvert(tv + HalfUV));
											//(tu + HalfUV), (tv + HalfUV));
				VertexIdx++;
				FaceCount++;

				// MB...
				if( (iz==0) && (m_IsBlunt[3]==false) )
				{
					tx-=HalfCell;
					pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
												m_pRefTerrain->GetMapData(tx,tz).fHeight,
												(float)(tz * TILE_SIZE),
												0.0f, 1.0f, 0.0f,
												UVConvert(tu),
												UVConvert(tv + HalfUV));
												//(tu), (tv + HalfUV));
					VertexIdx++;
					FaceCount++;
				}

				//LB Point..
				tx = cx - HalfCell;
				pVertices[VertexIdx].Set( (float)(tx * TILE_SIZE),
											m_pRefTerrain->GetMapData(tx,tz).fHeight,
											(float)(tz * TILE_SIZE),
											0.0f, 1.0f, 0.0f,
											UVConvert(tu - HalfUV),
											UVConvert(tv + HalfUV));
											//(tu - HalfUV), (tv + HalfUV));
				VertexIdx++;
				FaceCount++;
				FaceInfo.NumFace = FaceCount;
				FaceInfo.NumVertex = VertexIdx - VertexCount;
				m_FanInfoList.push_back(FaceInfo);
			}
		}
	
		m_pVB->Unlock();
	}
}


//
//
//
void CN3TerrainPatch::Render()
{
	if(m_bIsRender==FALSE) return;

	HRESULT hr;
	
	if(m_iLevel>1)
	{
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE);

		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE);	
		hr = CN3Base::s_lpD3DDev->SetTexture( 1, nullptr);
		
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE);	
		hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr);

		CN3Base::s_lpD3DDev->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexT1) );
		CN3Base::s_lpD3DDev->SetFVF(FVF_VNT1);

		if(m_pRefColorTex->Get()) hr = CN3Base::s_lpD3DDev->SetTexture( 0, m_pRefColorTex->Get() );
		else hr = CN3Base::s_lpD3DDev->SetTexture( 0, nullptr );

		FIIt it;
		int vc = 0;
		int fc;
		for(it = m_FanInfoList.begin(); it != m_FanInfoList.end(); it++)
		{
			fc = it->NumFace;
			hr = CN3Base::s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, vc, fc);
			vc += it->NumVertex;
#if _DEBUG
			CN3Base::s_RenderInfo.nTerrain_Polygon += it->NumVertex; // Rendering Information 갱신..
#endif			
		}		
		return;
	}	
	
	if(m_iLevel==1)
	{
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	
		CN3Base::s_lpD3DDev->SetStreamSource( 0, m_pVB, 0, sizeof(__VertexT2) );
		CN3Base::s_lpD3DDev->SetFVF(FVF_VNT2);
			
		int TotalTile = PATCH_TILE_SIZE*PATCH_TILE_SIZE;
		for(int i=0; i<TotalTile; i++)
		{
			hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
			hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

			hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr );

			if( m_pTileTexIndx[0][i] >= m_pRefTerrain->m_NumTileTex || (m_pIsTileFull[i]==false) )	// 0: 컬러맵, 1:무늬 or 0:부분타일 1:NONE...
			{
				hr = CN3Base::s_lpD3DDev->SetTexture( 0, m_pRefColorTex->Get());
				hr = CN3Base::s_lpD3DDev->SetTexture( 1, m_pRefTerrain->m_pBaseTex.Get());

				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_MODULATE);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT);

				hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_MODULATE);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLORARG2, D3DTA_DIFFUSE);			
			}
			else if(m_pTileTexIndx[0][i] < m_pRefTerrain->m_NumTileTex)
			{
				if(m_pTileTexIndx[1][i] < m_pRefTerrain->m_NumTileTex)	//0: tile, 1: tile..
				{
					hr = CN3Base::s_lpD3DDev->SetTexture( 0, m_pRefTerrain->m_pTileTex[m_pTileTexIndx[0][i]].Get());
					hr = CN3Base::s_lpD3DDev->SetTexture( 1, m_pRefTerrain->m_pTileTex[m_pTileTexIndx[1][i]].Get());
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_ADD);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT);

					if(m_pRefTerrain->m_bAvailableTile)
					{
						hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr);
						hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_MODULATE);
						hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_CURRENT);
						hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
					}
				}
				else	//0: tile, 1:NONE...
				{
					hr = CN3Base::s_lpD3DDev->SetTexture( 0, m_pRefTerrain->m_pTileTex[m_pTileTexIndx[0][i]].Get());
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

					hr = CN3Base::s_lpD3DDev->SetTexture( 1, nullptr);
					hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE);
					hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE);
				}
			}

			hr = CN3Base::s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, (i<<2), 2);
			
			if( (!m_pRefTerrain->m_bAvailableTile) &&
				m_pTileTexIndx[0][i] < m_pRefTerrain->m_NumTileTex &&
				m_pTileTexIndx[1][i] < m_pRefTerrain->m_NumTileTex )
			{
				DWORD dwAlphaEnable, dwSrcBlend, dwDestBlend;
				hr = s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaEnable);
				hr = s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwSrcBlend);
				hr = s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwDestBlend);

				hr = CN3Base::s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
				hr = CN3Base::s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ZERO);
				hr = CN3Base::s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

				hr = CN3Base::s_lpD3DDev->SetTexture( 0, nullptr);
				hr = CN3Base::s_lpD3DDev->SetTexture( 1, nullptr);
				hr = CN3Base::s_lpD3DDev->SetTexture( 2, nullptr);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE);
				hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE);

				hr = CN3Base::s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, (i<<2), 2);

				hr = s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlphaEnable);
				hr = s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, dwSrcBlend);
				hr = s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, dwDestBlend);
			}
		}

#if _DEBUG
		CN3Base::s_RenderInfo.nTerrain_Tile_Polygon += TotalTile * 2; // Rendering Information 갱신..
#endif

		// Render Light Map...
		s_lpD3DDev->SetStreamSource( 0, m_pLightMapVB, 0, sizeof(__VertexT1) );
		s_lpD3DDev->SetFVF(FVF_VNT1);

		DWORD dwAlphaEnable, dwSrcBlend, dwDestBlend;

		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		hr = CN3Base::s_lpD3DDev->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
		
		hr = s_lpD3DDev->GetRenderState( D3DRS_ALPHABLENDENABLE, &dwAlphaEnable);
		hr = s_lpD3DDev->GetRenderState( D3DRS_SRCBLEND, &dwSrcBlend);
		hr = s_lpD3DDev->GetRenderState( D3DRS_DESTBLEND, &dwDestBlend);

		hr = s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
		hr = s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		hr = s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
		
		for(int i=0;i<m_NumLightMapTex;i++)
		{
			s_lpD3DDev->SetTexture( 0, m_pRefLightMapTex[i]->Get());
			hr = s_lpD3DDev->DrawPrimitive( D3DPT_TRIANGLEFAN, (i<<2), 2);
		}
		hr = s_lpD3DDev->SetRenderState( D3DRS_ALPHABLENDENABLE, dwAlphaEnable);
		hr = s_lpD3DDev->SetRenderState( D3DRS_SRCBLEND, dwSrcBlend);
		hr = s_lpD3DDev->SetRenderState( D3DRS_DESTBLEND, dwDestBlend);
	}
}


//
//	한픽셀씩 축소시킨 커러맵 쓸때 uv바꿔주는 함수..
//	필요없게 됐다..-.- 걍 텍스쳐 스테이지 스테이트에서 mirror쓰면 된다..ㅡ.ㅡ
//
inline float CN3TerrainPatch::UVConvert(float uv)
{
	//return ( (uv*((float)COLORMAPTEX_SIZE - 2.0f) + 1.0f) / (float)COLORMAPTEX_SIZE);
	return uv;
}



// ===== END WarFare/N3TerrainPatch.cpp =====

// ===== BEGIN WarFare/N3TerrainPatch.h =====
#line 1 "WarFare/N3TerrainPatch.h"
﻿// N3Patch.h: interface for the CN3TerrainPatch class.
// 2001.10.22.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LYTERRAIN_H__38B10089_4193_49B7_BF2A_CD9C6CD3251A__INCLUDED_)
#define AFX_LYTERRAIN_H__38B10089_4193_49B7_BF2A_CD9C6CD3251A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "N3TerrainDef.h"
#include <N3Base/N3Base.h>

class CN3Texture;
class CN3Terrain;

class CN3TerrainPatch : public CN3Base
{
public:
	BOOL						m_bIsRender;
	POINT						m_ti_LBPoint;
	CN3Terrain*					m_pRefTerrain;
	bool						m_IsBlunt[4];	//Left, Top, Right, Bottom...
	CN3Texture*					m_pRefColorTex;

protected:
	int							m_CellSize;
	int							m_NumCell;
	int							m_iLevel;
	LPDIRECT3DVERTEXBUFFER9		m_pVB;
	int							m_VBSize[MAX_PATCH_LEVEL];
	
	FanInfoList					m_FanInfoList;
	
	//for level1
	uint32_t*					m_pTileTexIndx[2];
	bool*						m_pIsTileFull;

	//lightmap...
	LPDIRECT3DVERTEXBUFFER9		m_pLightMapVB;
	CN3Texture**				m_pRefLightMapTex;
	int							m_NumLightMapTex;

	//Tile지원 안하는 카드들을 위한 설정.
	//LPDIRECT3DVERTEXBUFFER8		m_pFoolishTileVB;
	//int							m_NumFoolishTile;

public:
	inline float	UVConvert(float uv);
	int		GetLevel() { return m_iLevel; }
	void	SetLevel(int level);
	void	Release();
	void	Init();
	void	Init(CN3Terrain* pTerrain);
	void	Tick();
	void	Render();
	
public:
	CN3TerrainPatch();
	virtual ~CN3TerrainPatch();
};

#endif // !defined(AFX_LYTERRAIN_H__38B10089_4193_49B7_BF2A_CD9C6CD3251A__INCLUDED_)

// ===== END WarFare/N3TerrainPatch.h =====

// ===== BEGIN WarFare/N3UIDBCLButton.cpp =====
#line 1 "WarFare/N3UIDBCLButton.cpp"
﻿// N3UIDBCLButton.cpp: implementation of the CN3UIDBCLButton class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3UIDBCLButton.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIDBCLButton::CN3UIDBCLButton()
{
}

CN3UIDBCLButton::~CN3UIDBCLButton()
{
}

uint32_t CN3UIDBCLButton::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;

	RECT rect = GetRegion();
	if(!::PtInRect(&rect, ptCur))		// 영역 밖이면
	{
		dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
		return dwRet;
	}

	if (dwFlags & UI_MOUSE_LBDBLCLK)
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_DBLCLK); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

// ===== END WarFare/N3UIDBCLButton.cpp =====

// ===== BEGIN WarFare/N3UIDBCLButton.h =====
#line 1 "WarFare/N3UIDBCLButton.h"
﻿// N3UIIcon.h: interface for the CN3UIIcon class.
//
//////////////////////////////////////////////////////////////////////

#if !defined __N3UIDBCLBUTTON_H__
#define __N3UIDBCLBUTTON_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIImage.h>

class CN3UIDBCLButton : public CN3UIImage
{
public:
	CN3UIDBCLButton();
	virtual ~CN3UIDBCLButton();

	virtual uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
};

#endif // !defined(AFX_N3UIICON_H__DD3FD0B0_334A_4DA5_81E7_F29E82C84D6D__INCLUDED_)

// ===== END WarFare/N3UIDBCLButton.h =====

// ===== BEGIN WarFare/N3UIIcon.cpp =====
#line 1 "WarFare/N3UIIcon.cpp"
﻿// N3UIIcon.cpp: implementation of the CN3UIIcon class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3UIIcon.h"
#include "GameProcedure.h"
#include "UIImageTooltipDlg.h"

#ifdef _N3GAME
#include "N3UIWndBase.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3UIIcon::CN3UIIcon()
{
	m_eType = UI_TYPE_ICON;
}

CN3UIIcon::~CN3UIIcon()
{
}

uint32_t CN3UIIcon::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;

	if (!m_bVisible) return dwRet;
	if ( (m_pParent->GetState() == UI_STATE_COMMON_NONE) || (m_pParent->GetState() == UI_STATE_ICON_MOVING) ) 
		SetStyle(GetStyle() & (~UISTYLE_ICON_HIGHLIGHT));	

	if (s_bWaitFromServer)
		return dwRet;

	RECT rect = GetRegion();
	if ( ::PtInRect(&rect, ptCur) && (m_pParent->GetState() == UI_STATE_COMMON_NONE) )
		SetStyle(GetStyle() | UISTYLE_ICON_HIGHLIGHT);	

	rect = GetMoveRect();

	if(!::PtInRect(&rect, ptCur))		// 영역 밖이면
	{
		dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
		return dwRet;
	}

	if((dwFlags & UI_MOUSE_LBCLICK) && !(dwFlags & UI_MOUSE_RBDOWN))  // 왼쪽버튼 눌르는 순간
	{
		m_pParent->SetState(UI_STATE_ICON_MOVING);
		m_pParent->ReceiveMessage(this, UIMSG_ICON_DOWN_FIRST); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if((dwFlags & UI_MOUSE_LBCLICKED) && !(dwFlags & UI_MOUSE_RBDOWN)) // 왼쪽버튼을 떼는 순간
	{
		if(m_pParent && m_pParent->GetState() == UI_STATE_ICON_MOVING) // 이전 상태가 버튼을 Down 상태이면
		{
			m_pParent->SetState(UI_STATE_COMMON_NONE);
			m_pParent->ReceiveMessage(this, UIMSG_ICON_UP); // 부모에게 버튼 클릭 통지..
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
	}

	if ((dwFlags & UI_MOUSE_RBCLICK)  && !(dwFlags & UI_MOUSE_LBDOWN))	// 오른쪽
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_RDOWN_FIRST); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if((dwFlags & UI_MOUSE_RBCLICKED)  && !(dwFlags & UI_MOUSE_LBDOWN))// 오른쪽 버튼을 떼는 순간
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_RUP); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if (dwFlags & UI_MOUSE_LBDOWN)	// 왼쪽
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_DOWN); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}
/*
	else
	{
		if(m_pParent && m_pParent->GetState() == UI_STATE_ICON_MOVING) // 이전 상태가 버튼을 Down 상태이면
		{
			m_pParent->ReceiveMessage(this, UIMSG_ICON_UP); // 부모에게 버튼 클릭 통지..
			dwRet |= UI_MOUSEPROC_DONESOMETHING;
			return dwRet;
		}
	}
*/

	if (dwFlags & UI_MOUSE_LBDBLCLK)	// 왼쪽 더블 클릭
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_DBLCLK); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if (dwFlags & UI_MOUSE_RBDBLCLK)	// 오른쪽 더블 클릭
	{
		m_pParent->ReceiveMessage(this, UIMSG_ICON_RDBLCLK); // 부모에게 버튼 클릭 통지..
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

void CN3UIIcon::Render()
{
	if (!IsVisible()) return;

	CN3UIWndBase::s_pSelectionImage->SetVisible(false);

/*	if ( m_dwStyle & UISTYLE_ICON_HIGHLIGHT )
	{		
		CN3UIWndBase::s_pSelectionImage->SetVisible(true);
		CN3UIWndBase::s_pSelectionImage->SetRegion(GetRegion());
		CN3UIWndBase::s_pSelectionImage->Render();
		CN3UIWndBase::s_pSelectionImage->SetVisible(false);
	}*/

	CN3UIImage::Render();

	if (m_dwStyle & UISTYLE_DISABLE_SKILL)
	{
		CN3UIWndBase::s_pSelectionImage->SetVisible(true);
		CN3UIWndBase::s_pSelectionImage->SetRegion(GetRegion());
		m_dc = CN3UIWndBase::s_pSelectionImage->GetColor();
		CN3UIWndBase::s_pSelectionImage->SetColor(D3DCOLOR_RGBA(40,40, 40, 160));
		CN3UIWndBase::s_pSelectionImage->RenderIconWrapper();
		CN3UIWndBase::s_pSelectionImage->SetColor(m_dc);
		CN3UIWndBase::s_pSelectionImage->SetVisible(false);
	}

	if( m_dwStyle & UISTYLE_DURABILITY_EXHAUST )
	{
		CN3UIWndBase::s_pSelectionImage->SetVisible(true);
		CN3UIWndBase::s_pSelectionImage->SetRegion(GetRegion());
		m_dc = CN3UIWndBase::s_pSelectionImage->GetColor();
		CN3UIWndBase::s_pSelectionImage->SetColor(D3DCOLOR_RGBA(200, 20, 20, 100));
		CN3UIWndBase::s_pSelectionImage->RenderIconWrapper();
		CN3UIWndBase::s_pSelectionImage->SetColor(m_dc);
		CN3UIWndBase::s_pSelectionImage->SetVisible(false);
	}
}






// ===== END WarFare/N3UIIcon.cpp =====

// ===== BEGIN WarFare/N3UIIcon.h =====
#line 1 "WarFare/N3UIIcon.h"
﻿// N3UIIcon.h: interface for the CN3UIIcon class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIICON_H__DD3FD0B0_334A_4DA5_81E7_F29E82C84D6D__INCLUDED_)
#define AFX_N3UIICON_H__DD3FD0B0_334A_4DA5_81E7_F29E82C84D6D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIImage.h>

class CN3UIIcon : public CN3UIImage
{
	D3DCOLOR	m_dc;	// Backup Color

public:
	CN3UIIcon();
	virtual ~CN3UIIcon();

	virtual uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	virtual void	Render();	
};

#endif // !defined(AFX_N3UIICON_H__DD3FD0B0_334A_4DA5_81E7_F29E82C84D6D__INCLUDED_)

// ===== END WarFare/N3UIIcon.h =====

// ===== BEGIN WarFare/N3UIWndBase.cpp =====
#line 1 "WarFare/N3UIWndBase.cpp"
﻿// N3UIWndBase.cpp: implementation of the CN3UIWndBase class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3UIWndBase.h"

#include "GameProcMain.h"
#include "UIImageTooltipDlg.h"
#include "UITransactionDlg.h"
#include "UIManager.h"
#include "CountableItemEditDlg.h"

#include <N3Base/N3UITooltip.h>
#include <N3Base/N3SndObj.h>

#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

__InfoSelectedIcon		CN3UIWndBase::s_sSelectedIconInfo;
__RecoveryJobInfo		CN3UIWndBase::s_sRecoveryJobInfo;
__SkillSelectInfo		CN3UIWndBase::s_sSkillSelectInfo;

CN3UIImage* CN3UIWndBase::s_pSelectionImage = nullptr;
CCountableItemEditDlg*	CN3UIWndBase::s_pCountableItemEdit = nullptr;

CN3SndObj* CN3UIWndBase::s_pSnd_Item_Etc = nullptr;
CN3SndObj* CN3UIWndBase::s_pSnd_Item_Weapon = nullptr;
CN3SndObj* CN3UIWndBase::s_pSnd_Item_Armor = nullptr;
CN3SndObj* CN3UIWndBase::s_pSnd_Gold = nullptr;
CN3SndObj* CN3UIWndBase::s_pSnd_Repair = nullptr;
int CN3UIWndBase::s_iRefCount = 0;

CN3UIWndBase::CN3UIWndBase()
{
	s_pSelectionImage = new CN3UIImage();
	s_pSelectionImage->Init(CGameProcedure::s_pUIMgr);
	s_pSelectionImage->SetUVRect(0.0f, 0.0f, 1.0f, 1.0f);

	if(s_iRefCount == 0)
	{
		s_pSnd_Item_Etc		= s_SndMgr.CreateObj(ID_SOUND_ITEM_ETC_IN_INVENTORY);
		s_pSnd_Item_Weapon	= s_SndMgr.CreateObj(ID_SOUND_ITEM_WEAPON_IN_INVENTORY);
		s_pSnd_Item_Armor	= s_SndMgr.CreateObj(ID_SOUND_ITEM_ARMOR_IN_INVENTORY);
		s_pSnd_Gold			= s_SndMgr.CreateObj(ID_SOUND_GOLD_IN_INVENTORY);	
		s_pSnd_Repair		= s_SndMgr.CreateObj(ID_SOUND_ITEM_IN_REPAIR);	
	}
	s_iRefCount++; // 참조 카운트
}

CN3UIWndBase::~CN3UIWndBase()
{
	s_iRefCount--; // 참조 카운트
	if(s_iRefCount == 0)
	{
		CN3Base::s_SndMgr.ReleaseObj(&s_pSnd_Item_Etc);
		CN3Base::s_SndMgr.ReleaseObj(&s_pSnd_Item_Weapon);
		CN3Base::s_SndMgr.ReleaseObj(&s_pSnd_Item_Armor);
		CN3Base::s_SndMgr.ReleaseObj(&s_pSnd_Gold);
		CN3Base::s_SndMgr.ReleaseObj(&s_pSnd_Repair);
	}
}

void CN3UIWndBase::InitIconWnd(e_UIWND eWnd)
{
	m_eUIWnd = eWnd;
}

CN3UIArea* CN3UIWndBase::GetChildAreaByiOrder(eUI_AREA_TYPE eUAT, int iOrder)
{
	std::string szID = std::to_string(iOrder);
	for (CN3UIBase* pChild : m_Children)
	{
		if (pChild->UIType() == UI_TYPE_AREA
			&& static_cast<CN3UIArea*>(pChild)->m_eAreaType == eUAT
			&& pChild->GetID() == szID)
			return static_cast<CN3UIArea*>(pChild);
	}

	return nullptr;
}

CN3UIString* CN3UIWndBase::GetChildStringByiOrder(int iOrder)
{
	std::string szID = std::to_string(iOrder);
	for (CN3UIBase* pChild : m_Children)
	{
		if (pChild->UIType() == UI_TYPE_STRING
			&& pChild->GetID() == szID)
			return static_cast<CN3UIString*>(pChild);
	}

	return nullptr;
}

void CN3UIWndBase::AllHighLightIconFree()
{
	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( pChild->UIType() == UI_TYPE_ICON )
			pChild->SetStyle(pChild->GetStyle() & (~UISTYLE_ICON_HIGHLIGHT));	
	}
}

uint32_t CN3UIWndBase::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

	// 아이콘을 가진 윈도우는 자기 윈도우 영역을 벗어 났을때도 자식의 메시지를 받을수 있어야 한다.. ^^

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE == m_eState)
	{
		if (dwFlags&UI_MOUSE_LBCLICKED)
		{
			SetState(UI_STATE_COMMON_NONE);
		}
		else
		{
			MoveOffset(ptCur.x - ptOld.x, ptCur.y - ptOld.y);
		}
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if(false == IsIn(ptCur.x, ptCur.y))	// 영역 밖이면
	{
		if(false == IsIn(ptOld.x, ptOld.y))
		{
			if ( GetState() != UI_STATE_ICON_MOVING )
				return dwRet;// 이전 좌표도 영역 밖이면 
		}
		dwRet |= UI_MOUSEPROC_PREVINREGION;	// 이전 좌표는 영역 안이었다.
	}
	else
	{
		// tool tip 관련
		if (s_pTooltipCtrl != nullptr)
			s_pTooltipCtrl->SetText(m_szToolTip, m_crToolTip);
	}

	dwRet |= UI_MOUSEPROC_INREGION;	// 이번 좌표는 영역 안이다.

	// child에게 메세지 전달
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		uint32_t dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{	
			// 이경우에는 먼가 포커스를 받은 경우이다.
			dwRet |= (UI_MOUSEPROC_CHILDDONESOMETHING|UI_MOUSEPROC_DONESOMETHING);
			return dwRet;
		}
	}

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE != m_eState && 
			PtInRect(&m_rcMovable, ptCur) && (dwFlags&UI_MOUSE_LBCLICK) )
	{
		// 인벤토리 윈도우이고 상거래 중이면..
		if ( (UIType() == UI_TYPE_ICON_MANAGER) && (m_eUIWnd == UIWND_INVENTORY) 
			&& (CGameProcedure::s_pProcMain->m_pUITransactionDlg->IsVisible()) )
			return dwRet;
		SetState(UI_STATE_COMMON_MOVE);
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	return dwRet;
}

void CN3UIWndBase::PlayItemEtcSound()
{
	if (s_pSnd_Item_Etc)	s_pSnd_Item_Etc->Play();
}

void CN3UIWndBase::PlayItemWeaponSound()
{
	if (s_pSnd_Item_Weapon)	s_pSnd_Item_Weapon->Play();
}

void CN3UIWndBase::PlayItemArmorSound()
{
	if (s_pSnd_Item_Armor)	s_pSnd_Item_Armor->Play();
}

void CN3UIWndBase::PlayGoldSound()
{
	if (s_pSnd_Gold)	s_pSnd_Gold->Play();
}

void CN3UIWndBase::PlayRepairSound()
{
	if (s_pSnd_Repair)	s_pSnd_Repair->Play();
}

void CN3UIWndBase::PlayItemSound(__TABLE_ITEM_BASIC* pBasic)
{
	if (!pBasic) return;
	switch (pBasic->dwID/100000000)
	{
		case 1:
			PlayItemWeaponSound();
			break;

		case 2:
			PlayItemArmorSound();
			break;

		default:
			PlayItemEtcSound();
			break;
	}
}

// ===== END WarFare/N3UIWndBase.cpp =====

// ===== BEGIN WarFare/N3UIWndBase.h =====
#line 1 "WarFare/N3UIWndBase.h"
﻿// N3UIWndBase.h: interface for the CN3UIWndBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3UIWNDBASE_H__A30E8AD0_2EB8_4F27_8E0D_3E0979560761__INCLUDED_)
#define AFX_N3UIWNDBASE_H__A30E8AD0_2EB8_4F27_8E0D_3E0979560761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include <N3Base/N3UIArea.h>
#include "N3UIIcon.h"
#include "GameProcedure.h"
#include "GameDef.h"
#include "IconItemSkill.h"

#include <string>

//////////////////////////////////////////////////////////////////////

// Wnd Info..
enum e_UIWND				{ 
								UIWND_INVENTORY = 0,		// Inventory Wnd..
								UIWND_TRANSACTION, 			// Transaction Wnd..
								UIWND_DROPITEM,				// Drop Item Wnd..
								UIWND_PER_TRADE,			// 개인간 거래..
								UIWND_SKILL_TREE,			// Skill Icon Info Wnd..
								UIWND_HOTKEY,				// Hot Key Wnd..
								UIWND_PER_TRADE_EDIT,		// Per Trade Edit Wnd..
								UIWND_WARE_HOUSE,			// 보관함..
								UIWND_UNKNOWN,				// Wnd Unknown..
							};

// District Info..
enum e_UIWND_DISTRICT		{	
								UIWND_DISTRICT_INVENTORY_SLOT = 0,	// Slot district of Inventory Wnd..
								UIWND_DISTRICT_INVENTORY_INV,		// Inv district of Inventory Wnd..
								UIWND_DISTRICT_TRADE_NPC,			// Transaction district of Transaction Wnd of Npc..
								UIWND_DISTRICT_PER_TRADE_MY,		// My Transaction district of Per Transaction Wnd..
								UIWND_DISTRICT_PER_TRADE_OTHER,		// Other Transaction district of Per Transaction Wnd..
								UIWND_DISTRICT_DROPITEM,			// Dropitem district of Drop item wnd..
								UIWND_DISTRICT_SKILL_TREE,			// Skillicon district of Skill icon wnd..
								UIWND_DISTRICT_SKILL_HOTKEY,		// Skillicon district of Hotkey icon wnd..
								UIWND_DISTRICT_TRADE_MY,			// Npc 와의 거래에서 내 영역..
								UIWND_DISTRICT_PER_TRADE_INV,		// Inv District of Per Trade Wnd ..
								UIWND_DISTRICT_UNKNOWN,				// District Unknown..
							};

enum e_UIIconState			{
								UIICON_SELECTED = 0,				// Icon Selected..
								UIICON_NOT_SELECTED_BUT_HIGHLIGHT,	// Icon Not Selected But Highlight..
							};

// Total Wnd Info.. 
struct __UIWndIconInfo		{
								e_UIWND				UIWnd;
								e_UIWND_DISTRICT	UIWndDistrict;
								int					iOrder;
							};

// enum Icon Type Info..//
enum e_UIIconType			{						
								UIICON_TYPE_ITEM = 0,				// Icon type item..
								UIICON_TYPE_SKILL,					// Icon type skill..
							};

// Select Icon Info..
struct __InfoSelectedIcon	{
								__UIWndIconInfo		UIWndSelect;
								__IconItemSkill*	pItemSelect;					
								
								__InfoSelectedIcon()
								{
									UIWndSelect = {};
									pItemSelect = nullptr;
								}
							};								

// Recovery Job Info..
struct __RecoveryJobInfo	{ 
								__IconItemSkill*	pItemSource;					
								__UIWndIconInfo		UIWndSourceStart;
								__UIWndIconInfo		UIWndSourceEnd;
								__IconItemSkill*	pItemTarget;
								__UIWndIconInfo		UIWndTargetStart;
								__UIWndIconInfo		UIWndTargetEnd;
								int					m_iPage;
							};

struct __SkillSelectInfo	{
								e_UIWND				UIWnd;
								int					iOrder;
								__IconItemSkill*	pSkillDoneInfo;
							};

const int UIITEM_TYPE_ONLYONE = 0;
const int UIITEM_TYPE_COUNTABLE = 1;
const int UITEIM_TYPE_GOLD = 2;
const int UIITEM_TYPE_COUNTABLE_SMALL = 3;
const int UIITEM_TYPE_SOMOONE = 4;

const int UIITEM_TYPE_USABLE_ID_MIN = 450000;

const int UIITEM_COUNT_MANY = 9999;
const int UIITEM_COUNT_FEW = 500;

//////////////////////////////////////////////////////////////////////

class CUIImageTooltipDlg;
class CCountableItemEditDlg;

// Class ^^
class CN3UIWndBase  : public CN3UIBase		// 가상 함수로 자식의 Area 갯수를 파악할 수 있는 함수가 있어야 하지 않을 까???
											// int GetChildCountByAreaType(eAreatype .. ) ^^
{
	void				PlayItemEtcSound();
	void				PlayItemWeaponSound();
	void				PlayItemArmorSound();

public:
	static __InfoSelectedIcon		s_sSelectedIconInfo;
	static __RecoveryJobInfo		s_sRecoveryJobInfo;
	static __SkillSelectInfo		s_sSkillSelectInfo;
	static CN3UIImage*				s_pSelectionImage;
	static CCountableItemEditDlg*	s_pCountableItemEdit;

protected:
	e_UIWND						m_eUIWnd;

	static int					s_iRefCount; // 참조 카운트...
	static CN3SndObj*			s_pSnd_Item_Etc;
	static CN3SndObj*			s_pSnd_Item_Weapon;
	static CN3SndObj*			s_pSnd_Item_Armor;
	static CN3SndObj*			s_pSnd_Gold;
	static CN3SndObj*			s_pSnd_Repair;

protected:
	virtual void				InitIconWnd(e_UIWND eWnd);
	virtual void				InitIconUpdate() = 0;

public:
	CN3UIWndBase();
	virtual ~CN3UIWndBase();

	e_UIWND						GetUIWnd() { return m_eUIWnd; }

	virtual CN3UIArea*			GetChildAreaByiOrder(eUI_AREA_TYPE eUAT, int iOrder);
	virtual CN3UIString*		GetChildStringByiOrder(int iOrder);

	virtual uint32_t				MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	virtual void				AllHighLightIconFree();

	virtual __IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon) = 0;
	virtual void				IconRestore() {}	
	virtual bool				CheckIconDropFromOtherWnd(__IconItemSkill* spItem) { return false; }
	virtual bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur) { return false; }
	virtual void				CancelIconDrop(__IconItemSkill* spItem) {}
	virtual void				AcceptIconDrop(__IconItemSkill* spItem) {}

	virtual void				PlayItemSound(__TABLE_ITEM_BASIC* pBasic);
	virtual void				PlayGoldSound();
	virtual void				PlayRepairSound();
};

#endif // !defined(AFX_N3UIWNDBASE_H__A30E8AD0_2EB8_4F27_8E0D_3E0979560761__INCLUDED_)

// ===== END WarFare/N3UIWndBase.h =====

// ===== BEGIN WarFare/N3WorldBase.cpp =====
#line 1 "WarFare/N3WorldBase.cpp"
﻿// N3WorldBase.cpp: implementation of the CN3WorldBase class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3WorldBase.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3WorldBase::CN3WorldBase()
{
}

CN3WorldBase::~CN3WorldBase()
{

}

// ===== END WarFare/N3WorldBase.cpp =====

// ===== BEGIN WarFare/N3WorldBase.h =====
#line 1 "WarFare/N3WorldBase.h"
﻿// N3WorldBase.h: interface for the CN3WorldBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3WORLDBASE_H__8064AFB4_48C5_4CFB_8435_635B9F6F321D__INCLUDED_)
#define AFX_N3WORLDBASE_H__8064AFB4_48C5_4CFB_8435_635B9F6F321D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3BaseFileAccess.h>
#include <N3Base/N3SkyMng.h>

#include "GameBase.h"

class CN3Shape;
class CN3Terrain;
class CN3SkyMng;

class CN3WorldBase : public CN3BaseFileAccess, public CGameBase
{
	friend class CN3WorldManager;

public:
	//..
	virtual CN3Terrain* GetTerrainRef() = 0;
	virtual CN3SkyMng* GetSkyRef() = 0;

	//..
	virtual void InitWorld(int iZoneID, const __Vector3& vPosPlayer) = 0;
	virtual void Tick() = 0;

	// Terrain..
	virtual bool CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP) = 0;
	virtual float GetHeightWithTerrain(float x, float z, bool bWarp = false) = 0;
	virtual BOOL PickWideWithTerrain(int x, int y, __Vector3& vPick) = 0;
	virtual bool CheckCollisionWithTerrain(__Vector3& vPos, __Vector3& vDir, float fVelocity, __Vector3* vCol) = 0;
	virtual void GetNormalWithTerrain(float x, float z, __Vector3& vNormal) = 0;
	virtual float GetWidthByMeterWithTerrain() = 0; 
	virtual bool IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore = __Vector3()) = 0;
	virtual bool CheckInclineWithTerrain(const __Vector3& vPos, const __Vector3& vDir, float fIncline) = 0;

	// Shapes..
	virtual bool CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP) = 0;
	virtual float GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr) = 0; 
	virtual void RenderCollisionWithShape(const __Vector3& vPos) = 0;
	virtual float GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal = nullptr) = 0; 
	virtual CN3Shape* ShapeGetByIDWithShape(int iID) = 0;
	virtual CN3Shape* PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr) = 0;
	virtual bool CheckCollisionWithShape(	const __Vector3& vPos,			// 충돌 위치
														const __Vector3& vDir,					    // 방향 벡터
														float fSpeedPerSec,							 // 초당 움직이는 속도
														__Vector3* pvCol = nullptr,				  // 충돌 지점
														__Vector3* pvNormal = nullptr,				// 충돌한면의 법선벡터
														__Vector3* pVec = nullptr) = 0;			// 충돌한 면 의 폴리곤 __Vector3[3]

	// Sky..
	virtual D3DCOLOR GetSkyColorWithSky()	{	return 0x00000000;	}
	virtual float GetSunAngleByRadinWithSky()	{ 	return -FLT_MAX;	}
	virtual void RenderWeatherWithSky()	{}
	virtual void SetGameTimeWithSky(int iYear, int iMonth, int iDay, int iHour, int iMin)	{}
	virtual void SetWeatherWithSky(int iWeather, int iPercentage)	{}
	virtual D3DCOLOR GetLightDiffuseColorWithSky(int iIndex)	{	return 0xffffffff;	}
	virtual D3DCOLOR GetLightAmbientColorWithSky(int iIndex)	{	return 0xffffffff;	}
	virtual D3DCOLOR GetFogColorWithSky()	{	return 0xffffffff;	}
	//virtual CN3Sun*	GetSunPointerWithSky()	{	return nullptr;	}

	// Bird..

	// Grass..
	virtual void InitWithGrass(__Vector3 CamPo)	{}

	// Rendering..
	virtual void RenderTerrain() = 0;
	virtual void RenderShape() = 0;	
	virtual void RenderSky() {}
	virtual void RenderGrass() {}
	virtual void RenderBirdMgr() {}
	virtual void RenderSkyWeather() {}

public:
	CN3WorldBase();
	virtual ~CN3WorldBase();
};

#endif // !defined(AFX_N3WORLDBASE_H__8064AFB4_48C5_4CFB_8435_635B9F6F321D__INCLUDED_)

// ===== END WarFare/N3WorldBase.h =====

// ===== BEGIN WarFare/N3WorldManager.cpp =====
#line 1 "WarFare/N3WorldManager.cpp"
﻿// N3WorldManager.cpp: implementation of the CN3WorldManager class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "N3WorldManager.h"
#include "N3TerrainManager.h"
#include "DungeonManager.h"
#include "APISocket.h"
#include "GameProcedure.h"
#include "PlayerMySelf.h"
#include "GameEng.h"

//#include "text_resources.h"

#include <N3Base/LogWriter.h>
#include <N3Base/N3SndObj.h>
#include <N3Base/N3SndObjStream.h>
#include <N3Base/N3SndMgr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CN3WorldManager::CN3WorldManager()
{
	m_pActiveWorld = nullptr;
	m_bIndoor = true;
}

CN3WorldManager::~CN3WorldManager()
{
	if (m_pActiveWorld)
		delete m_pActiveWorld;
	m_pActiveWorld = nullptr;
}

void CN3WorldManager::InitWorld(int iZoneID, const __Vector3& vPosPlayer)
{
	CLogWriter::Write("CN3WorldManager::InitWorld Pre delete"); // TmpLog_11_22

	if (m_pActiveWorld)
		delete m_pActiveWorld;

	// Zone 선택..
	if (iZoneID != 51)	// N3Terrain..
	{
		CLogWriter::Write("CN3WorldManager::InitWorld Pre new Terrain ZoneID({})", iZoneID); // TmpLog_11_22

		m_pActiveWorld = new CN3TerrainManager();	
		m_bIndoor = false;
	}
	else
	{
		CLogWriter::Write("CN3WorldManager::InitWorld Pre new Dungeon ZoneID({})", iZoneID); // TmpLog_11_22

		m_pActiveWorld = new CDungeonManager();
		m_bIndoor = true;
	}

	// Zone 초기화..
	m_pActiveWorld->InitWorld(iZoneID, vPosPlayer);
}

void CN3WorldManager::Tick()
{
	if (m_pActiveWorld)
		m_pActiveWorld->Tick();
}








// ===== END WarFare/N3WorldManager.cpp =====

// ===== BEGIN WarFare/N3WorldManager.h =====
#line 1 "WarFare/N3WorldManager.h"
﻿// N3WorldManager.h: interface for the CN3WorldManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_N3WORLDMANAGER_H__624E2205_DA37_483B_815A_B77C12F6C352__INCLUDED_)
#define AFX_N3WORLDMANAGER_H__624E2205_DA37_483B_815A_B77C12F6C352__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameBase.h"
#include "N3WorldBase.h"

class CN3Shape;
class CN3Sun;

class CN3WorldManager : public CGameBase  
{
	bool									m_bIndoor;
	CN3WorldBase*				   m_pActiveWorld;

public:
	void InitWorld(int iZoneID, const __Vector3& vPosPlayer);

	CN3WorldManager();
	virtual ~CN3WorldManager();

	void Tick();

	bool IsIndoor() {	return m_bIndoor;	}
	
	//..
	CN3WorldBase* GetActiveWorld() 
	{
//		__ASSERT(0, "No Acitive World!!");
		return m_pActiveWorld;	
	}
};

#endif // !defined(AFX_N3WORLDMANAGER_H__624E2205_DA37_483B_815A_B77C12F6C352__INCLUDED_)

// ===== END WarFare/N3WorldManager.h =====

// ===== BEGIN WarFare/OrderMessage.cpp =====
#line 1 "WarFare/OrderMessage.cpp"
﻿// OrderMessage.cpp: implementation of the COrderMessage class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "OrderMessage.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

COrderMessage::COrderMessage()
{

}

COrderMessage::~COrderMessage()
{

}

// ===== END WarFare/OrderMessage.cpp =====

// ===== BEGIN WarFare/OrderMessage.h =====
#line 1 "WarFare/OrderMessage.h"
﻿// OrderMessage.h: interface for the COrderMessage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ORDERMESSAGE_H__D4499630_BD7A_41F0_B4B8_0E0BBA84218C__INCLUDED_)
#define AFX_ORDERMESSAGE_H__D4499630_BD7A_41F0_B4B8_0E0BBA84218C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class COrderMessage  
{
public:
	COrderMessage();
	virtual ~COrderMessage();

};

#endif // !defined(AFX_ORDERMESSAGE_H__D4499630_BD7A_41F0_B4B8_0E0BBA84218C__INCLUDED_)

// ===== END WarFare/OrderMessage.h =====

// ===== BEGIN WarFare/PacketDef.h =====
#line 1 "WarFare/PacketDef.h"
﻿#ifndef __PACKET_DEF_H_
#define __PACKET_DEF_H_

const int SOCKET_PORT_GAME = 15001;
const int SOCKET_PORT_LOGIN = 15100;

#include <shared/packets.h>

	enum e_ChatMode {	N3_CHAT_NORMAL = 1,
						N3_CHAT_PRIVATE,
						N3_CHAT_PARTY,
						N3_CHAT_FORCE,
						N3_CHAT_SHOUT,
						N3_CHAT_CLAN,
						N3_CHAT_PUBLIC,
						N3_CHAT_WAR,
						N3_CHAT_TITLE,						//맨윗줄에 갈 공지
						N3_CHAT_TITLE_DELETE,				//맨윗줄에 있는 공지 삭제
						N3_CHAT_CONTINUE,					//지속 공지
						N3_CHAT_CONTINUE_DELETE,			//지속 공지 삭제
						N3_CHAT_UNKNOWN = 0xffffffff };

	enum e_SubPacket_Trade		{	N3_SP_TRADE_BUY  = 0x01,
									N3_SP_TRADE_SELL = 0x02,
									N3_SP_TRADE_MOVE = 0x03	};

	enum e_SubPacket_State {	N3_SP_STATE_CHANGE_SITDOWN = 0x01,
								N3_SP_STATE_CHANGE_RECRUIT_PARTY = 0x02,
								N3_SP_STATE_CHANGE_SIZE = 0x03,
								N3_SP_STATE_CHANGE_ACTION = 0x04,			// 1 - 인사, 11 - 도발
								N3_SP_STATE_CHANGE_VISIBLE = 0x05 };		// 투명 0 ~ 255

	// Sub Packet
	enum e_SubPacket_Party {	N3_SP_PARTY_OR_FORCE_CREATE			= 0x01,	// Send - s1(ID)	| Recv b1(YesNoErr)
								N3_SP_PARTY_OR_FORCE_PERMIT			= 0x02,	// Send - b1(YesNo) | Recv - s1(ID)
								N3_SP_PARTY_OR_FORCE_INSERT			= 0x03,	// Send - s1(ID) | Recv - s3(ID, HPMax, HP) b2(Level, Class) - 문자열은 ID 로 알아낸다.. ID 가 -1 이면.. 파티에 들어오는것을 상대방이 거절한거다..
								N3_SP_PARTY_OR_FORCE_REMOVE			= 0x04,	// Send - s1(ID) | Recv - s1(ID) - 자기 자신이면 파티를 깨야 한다..
								N3_SP_PARTY_OR_FORCE_DESTROY		= 0x05,	// Send
								N3_SP_PARTY_OR_FORCE_HP_CHANGE		= 0x06,	// Recv - s3(ID, HPMax, HP, iMPMax, MP)
								N3_SP_PARTY_OR_FORCE_LEVEL_CHANGE	= 0x07,	// Recv - s1(ID), b1(Level)
								N3_SP_PARTY_OR_FORCE_CLASS_CHANGE	= 0x08,	// Recv - s1(ID), b1(Class)드물지만 전직할때...
								N3_SP_PARTY_OR_FORCE_STATUS_CHANGE	= 0x09 };	// Recv - s1(ID), b1(Status)독, 저주, 지속성마법, 축복

	// Sub Packet
	enum e_SubPacket_PerTrade {	N3_SP_PER_TRADE_REQ =			0x01, 
								N3_SP_PER_TRADE_AGREE =			0x02,
								N3_SP_PER_TRADE_ADD =			0x03,
								N3_SP_PER_TRADE_OTHER_ADD =		0x04,
								N3_SP_PER_TRADE_DECIDE	=		0x05,
								N3_SP_PER_TRADE_OTHER_DECIDE =	0x06,
								N3_SP_PER_TRADE_DONE =			0x07,
								N3_SP_PER_TRADE_CANCEL =		0x08 };	

	// Sub Packet
	enum e_SubPacket_Magic {	N3_SP_MAGIC_CASTING =	0x01,
								N3_SP_MAGIC_FLYING =	0x02,
								N3_SP_MAGIC_EFFECTING =	0x03,
								N3_SP_MAGIC_FAIL = 		0x04,
								N3_SP_MAGIC_TYPE4BUFFTYPE = 0x05,
								N3_SP_MAGIC_CANCEL = 0x06								
	};

	// Sub Packet..
	enum e_SubPacket_ClassChange_Main {
		N3_SP_CLASS_CHANGE_PURE = 0x01,		// Class Change Real..
		N3_SP_CLASS_CHANGE_REQ  = 0x02,		// Class Change Req..
		N3_SP_CLASS_ALL_POINT   = 0x03,		// Class Change All Point..
		N3_SP_CLASS_SKILL_POINT = 0x04,
		N3_SP_CLASS_POINT_CHANGE_PRICE_QUERY = 0x05,
		N3_SP_CLASS_PROMOTION = 0x06	};

	enum e_SubPacket_ClassChange {	N3_SP_CLASS_CHANGE_SUCCESS	= 0x01,		// Success..
									N3_SP_CLASS_CHANGE_NOT_YET	= 0x02,		// Not yet..
									N3_SP_CLASS_CHANGE_ALREADY = 0x03,		// Already..
									N3_SP_CLASS_CHANGE_ITEM_IN_SLOT = 0x04,		// Item in Slot..
									N3_SP_CLASS_CHANGE_FAILURE	= 0x00 };	// Failure..

	enum e_SubPacket_Knights {	N3_SP_KNIGHTS_CREATE =				0x01, // 생성 Send - s1(Name Length) str1 | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_JOIN =				0x02, // 가입 Send - s1(Knights ID) | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_WITHDRAW =			0x03, // 탈퇴 Send - | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_MEMBER_REMOVE =		0x04, // 멤버 삭제 - 
								N3_SP_KNIGHTS_DESTROY	=			0x05, // 뽀개기 Send - | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_MEMBER_JOIN_ADMIT =	0x06, // 멤버 가입 허가 Send - s1(Knights ID) | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_MEMBER_JOIN_REJECT =	0x07, // 멤버 가입 거절 Send - s1(Knights ID) | Recv - b1(1:성공 0:실패)
								N3_SP_KNIGHTS_MEMBER_PUNISH =		0x08, // 멤버 징계 - 가입과 같음
								N3_SP_KNIGHTS_APPOINT_CHIEF =		0x09, // 단장 임명 - 가입과 같음
								N3_SP_KNIGHTS_APPOINT_VICECHIEF =	0x0A, // 부단장 임명 - 가입과 같음
								N3_SP_KNIGHTS_APPOINT_OFFICER =		0x0B, // 장교임명 - 가입과 같음
								N3_SP_KNIGHTS_GRADE_CHANGE_ALL =	0x0C, // 전 기사단의 등급 및 순위 변경 Recv - s1(count) Loop { s1(Knights ID) b2(Grade Rank) }
								N3_SP_KNIGHTS_MEMBER_INFO_ALL =		0x0D, // 모든 멤버 요청 Send - s1(page) | s1(Member Count) Loop { s1(Name Length) str1 (Name) }
								N3_SP_KNIGHTS_MEMBER_INFO_ONLINE =	0x0E, // 현재 접속 리스트 Send - s1(page) | s1(Member Count) Loop { s1(Name Length) str1 (Name) }
								N3_SP_KNIGHTS_STASH =				0x0F, // 기사단 창고
								N3_SP_KNIGHTS_DUTY_CHANGE =			0x10, // 멤버의 직위 변경.. 해당 멤버에게 간다.. Recv - s1(Knights ID) b1(직위);
								N3_SP_KNIGHTS_JOIN_REQ =			0x11, // 기사단 인덱스
								N3_SP_KNIGHTS_UNKNOWN };

	enum e_SubPacket_KNights_Create {	N3_SP_KNIGHTS_CREATE_FAIL_DBFAIL =			0x00,
										N3_SP_KNIGHTS_CREATE_SUCCESS =				0x01,
										N3_SP_KNIGHTS_CREATE_FAIL_LOWLEVEL =		0x02,
										N3_SP_KNIGHTS_CREATE_FAIL_DUPLICATEDNAME =	0x03,
										N3_SP_KNIGHTS_CREATE_FAIL_LOWMONEY =		0x04,
										N3_SP_KNIGHTS_CREATE_FAIL_ALREADYJOINED =	0x05,
										N3_SP_KNIGHTS_CREATE_FAIL_UNKNOWN =			0x06,
										N3_SP_KNIGHTS_CREATE_FAIL_INVALIDDAY =		0x07,
										N3_SP_KNIGHTS_CREATE_FAIL_INVALIDSERVER =	0x08 };

	enum e_SubPacket_KNights_Common {	N3_SP_KNIGHTS_COMMON_DBFAIL =				0x00,	//DB검색 실패..
										N3_SP_KNIGHTS_COMMON_SUCCESS =				0x01,	//성공
										N3_SP_KNIGHTS_COMMON_FAIL_NONE_USER =		0x02,	//없는 유저..
										N3_SP_KNIGHTS_COMMON_FAIL_DEAD_USER =		0x03,	//상대유저가 죽어 있음..
										N3_SP_KNIGHTS_COMMON_FAIL_ENEMY_USER =		0x04,	//상대유저의 국가가 다름..
										N3_SP_KNIGHTS_COMMON_FAIL_OTHER_CLAN_USER =	0x05,	//상대유저가 이미 다른 클랜이나 기사단에 가입되어 있음..
										N3_SP_KNIGHTS_COMMON_FAIL_INVALIDRIGHT =	0x06,	//권한이 없음..
										N3_SP_KNIGHTS_COMMON_FAIL_NONE_CLAN =		0x07,	//존재하지 않는 기사단..									
										N3_SP_KNIGHTS_COMMON_FAIL_FULL =			0x08,	//인원이 풀..
										N3_SP_KNIGHTS_COMMON_FAIL_ME =				0x09,	//자기자신을 선택한 경우..
										N3_SP_KNIGHTS_COMMON_FAIL_NOT_JOINED =		0x0A,	//기사단이나 클랜에 가입되어 있지 않음...
										N3_SP_KNIGHTS_COMMON_FAIL_REJECT =			0x0B,	//상대편에서 거절...
										N3_SP_KNIGHTS_COMMON_FAIL_BATTLEZONE =		0x0C	// 전쟁존에서의 거부..
								};	// join, appoint, leave, withdraw 모두 쓴다.....
	
	enum e_SubPacket_KnightsList {	N3_SP_KNIGHTS_LIST_BASIC_ALL = 0x01,  // Receive - s1(knights Count) { s21(id, 이름길이), str1(이름) }
									N3_SP_KNIGHTS_LIST_BASIC_INSERT = 0x02, // Receive - s2(id, 이름길이), str1(이름)
									N3_SP_KNIGHTS_LIST_BASIC_REMOVE = 0x03 }; // Receive - s1(id)

	enum e_SubPacket_Administrator { N3_SP_ADMINISTRATOR_ARREST = 0x01, // 그 유저 있는 곳으로 존체인지.. Send b1(Type) s1(유저이름길이), str1(유저이름)
									N3_SP_ADMINISTRATOR_FORBID_CONNECT = 0x02, // 접속금지 및 쫓아내기.. Send b1(Type) s1(유저이름길이), str1(유저이름)
									N3_SP_ADMINISTRATOR_CHAT_FORBID = 0x03, // 채팅금지 Send b1(Type) s1(유저이름길이), str1(유저이름)
									N3_SP_ADMINISTRATOR_CHAT_PERMIT = 0x04 }; // 채팅허가 Send b1(Type) s1(유저이름길이), str1(유저이름)
									
	enum e_SubPacket_WareHouse {	N3_SP_WARE_OPEN = 				0x01,	// Open..
									N3_SP_WARE_GET_IN =				0x02,	// 堅?.
									N3_SP_WARE_GET_OUT =			0X03,	// 빼기..
									N3_SP_WARE_WARE_MOVE =			0x04,	// 이동..
									N3_SP_WARE_INV_MOVE =			0x05,	// 이동..
									N3_SP_WARE_INN =				0x10,	// 맨처음..여관주인임을 받음..
									N3_SP_WARE_UNKNOWN };

	enum e_Party_BBS {	N3_SP_PARTY_REGISTER						= 0x01,		// 파티 게시판에 등록
						N3_SP_PARTY_REGISTER_CANCEL					= 0x02,		// 파티 게시판에서 등록 취소
						N3_SP_PARTY_BBS_DATA						= 0x03};	// 파티 게시 정보 요구

	enum e_Trade_BBS_Kind { N3_SP_TRADE_BBS_BUY						= 0x01,		// 사는 물건 목록
							N3_SP_TRADE_BBS_SELL					= 0x02};		// 파는 물건 목록

	enum e_Trade_BBS_Sub  { N3_SP_TYPE_REGISTER						= 0x01,		// 물건 등록하기
							N3_SP_TYPE_REGISTER_CANCEL				= 0x02,		// 등록 해제하기
							N3_SP_TYPE_BBS_DATA						= 0x03,		// 게시판 정보 요구
							N3_SP_TYPE_BBS_OPEN						= 0x04,		// 상거래 게시판 열기
							N3_SP_TYPE_BBS_TRADE					= 0x05};	// 게시판에서 거래 신청하기

#endif // end of #ifndef __PACKET_DEF_H_

// ===== END WarFare/PacketDef.h =====

// ===== BEGIN WarFare/PlayerBase.cpp =====
#line 1 "WarFare/PlayerBase.cpp"
﻿// CPlayerBase.cpp: implementation of the CPlayerBase class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PlayerBase.h"
#include "N3WorldManager.h"
#include "N3FXMgr.h"

#include "text_resources.h"

#include <N3Base/DFont.h>
#include <N3Base/N3ShapeExtra.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

static const __Vector3 s_vLightOffset = __Vector3(10.0f, 40.0f, 30.0f);
CN3SndObj*	CPlayerBase::m_pSnd_MyMove = nullptr;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPlayerBase::CPlayerBase()
{
	m_ePlayerType = PLAYER_BASE; // Player Type ... Base, NPC, OTher, MySelf

	m_Chr.PartAlloc(PART_POS_COUNT); // 기본적으로 파트와 플러그 세팅..
	m_Chr.PlugAlloc(PLUG_POS_COUNT);

	m_Chr.PosSet(__Vector3(0.0f, 0.0f, 0.0f));

	m_pLooksRef = nullptr;				// 기본적인 모습과 기본 정보 참조 테이블
	memset(m_pItemPlugBasics, 0, sizeof(m_pItemPlugBasics)); // 캐릭터에 붙은 무기들..
	memset(m_pItemPlugExts, 0, sizeof(m_pItemPlugExts));
	memset(m_pItemPartBasics, 0, sizeof(m_pItemPartBasics)); // 캐릭터에 붙은 갑옷들..
	memset(m_pItemPartExts, 0, sizeof(m_pItemPartExts)); // 캐릭터에 붙은 갑옷들..

	m_iIDTarget	= -1;
	m_iMagicAni = 0;
	m_bGuardSuccess	= false;	// 방어에 성공했는지에 대한 플래그..
	m_bVisible = true;			// 보이는지??

	m_iDroppedItemID				= 0;	// 죽은후 떨어트린 아이템

	m_Chr.m_nJointPartStarts[0]		= 1;	// 상체 - 에니메이션을 분리해 처리하는데... 조인트 인덱스이다.
	m_Chr.m_nJointPartEnds[0]		= 15;	// 상체

	m_Chr.m_nJointPartStarts[1]		= 16;	// 하체
	m_Chr.m_nJointPartEnds[1]		= 23;	// 하체

	m_cvDuration.a = m_cvDuration.r = m_cvDuration.g = m_cvDuration.b = 1.0f; // 지속 컬러 값
	m_fDurationColorTimeCur = 0; // 현재 시간..
	m_fDurationColorTime = 0; // 지속시간..

	m_fFlickeringFactor = 1.0f; // 깜박거림 알파 값 1.0 이면 깜박이지 않는다....
	m_fFlickeringTime = 0; // 깜박거림 시간..

	m_fTimeAfterDeath = 0; // 죽는 모션을 취하는 타이머 - 5초정도면 적당한가?? 그전에 공격을 받으면 바로 죽는다.

	m_eStateNext = m_eState = PSA_BASIC;
	m_eStateMove = PSM_STOP; // 첨에 정지..
	m_eStateDying = PSD_UNKNOWN; // 죽을때 방법
	m_fTimeDying = 0; // 죽는 모션 취할때 지난 시간..

	m_fRotRadianPerSec = DegreesToRadians(270.0f); // 초당 회전 라디안값
	m_fMoveSpeedPerSec = 0; // 초당 움직임 값.. 이값은 기본값이고 상태(걷기, 달리기, 뒤로, 저주등) 에 따라 가감해서 쓴다..
	m_fYawCur = 0; // 현재 회전값..
	m_fYawToReach = 0;

	m_fGravityCur = 0;			// 중력값..
	m_fYNext = 0;				// 오브젝트 혹은 지형의 충돌 체크에 따른 높이값..

	m_fScaleToSet = 1.0f;			// 점차 스케일 값변화..
	m_fScalePrev = 1.0f;

	m_pSnd_Move = nullptr;
	m_pSnd_Attack_0 = nullptr;
//	m_pSnd_Attack_1 = nullptr;
	m_pSnd_Struck_0 = nullptr;
//	m_pSnd_Struck_1 = nullptr;
	m_pSnd_Breathe_0 = nullptr;
//	m_pSnd_Breathe_1 = nullptr;
	m_pSnd_Blow = nullptr;
	m_bSoundAllSet = false;

	m_InfoBase.Init();				// 첨엔 종족값을 모른다..

	m_pShapeExtraRef = nullptr;					// 이 NPC 가 성문이나 집등 오브젝트의 형태이면 이 포인터를 세팅해서 쓴,다..

	m_fCastFreezeTime = 0.0f;
	m_fAttackDelta = 1.0f;			// 스킬이나 마법에 의해 변하는 공격 속도.. 1.0 이 기본이고 클수록 더 빨리 공격한다.
	m_fMoveDelta = 1.0f;			// 스킬이나 마법에 의해 변하는 이동 속도 1.0 이 기본이고 클수록 더 빨리 움직인다.

	m_vDirDying.Set(0,0,1); // 죽을때 밀리는 방향..

	// 그림자 초기화
//	By : Ecli666 ( On 2002-03-29 오후 4:23:36 )
/*
	m_pTexShadow = nullptr;
	m_pTexShadow = s_MngTex.Get("Chr\\Shadow_Character.tga"); 
	m_vShadows[0].Set(-0.7f, 0, 0.7f, 0, 0);
	m_vShadows[1].Set( 0.7f, 0, 0.7f, 1, 0);
	m_vShadows[2].Set( 0.7f, 0,-0.7f, 1, 1);
	m_vShadows[3].Set(-0.7f, 0,-0.7f, 0, 1);
*/
//	~(By Ecli666 On 2002-03-29 오후 4:23:36 )

	// 폰트 초기화... // 정보 표시용 폰트와 풍선용은 따로 생성한다..
	m_pIDFont = nullptr;
	m_pClanFont = nullptr;
	m_pInfoFont = nullptr;
	m_pBalloonFont = nullptr;
	m_fTimeBalloon = 0;

	m_bAnimationChanged = false;	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..

	m_pvVertex[0].Set(-SHADOW_PLANE_SIZE, 0.0f,  SHADOW_PLANE_SIZE, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f);
	m_pvVertex[1].Set( SHADOW_PLANE_SIZE, 0.0f,  SHADOW_PLANE_SIZE, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f);
	m_pvVertex[2].Set( SHADOW_PLANE_SIZE, 0.0f, -SHADOW_PLANE_SIZE, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f);
	m_pvVertex[3].Set(-SHADOW_PLANE_SIZE, 0.0f, -SHADOW_PLANE_SIZE, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f);

	uint16_t*		pIdx = m_pIndex;

	// 아랫면.
	*pIdx++ = 0;  *pIdx++ = 1;  *pIdx++ = 3;
	*pIdx++ = 2;  *pIdx++ = 3;  *pIdx++ = 1;

	m_N3Tex.Create(SHADOW_SIZE, SHADOW_SIZE, D3DFMT_A4R4G4B4, 0);	
}

CPlayerBase::~CPlayerBase()
{
//	By : Ecli666 ( On 2002-03-29 오후 4:24:14 )
//
//	s_MngTex.Delete(m_pTexShadow);

//	~(By Ecli666 On 2002-03-29 오후 4:24:14 )
	delete m_pClanFont; m_pClanFont = nullptr;
	delete m_pIDFont; m_pIDFont = nullptr;
	delete m_pInfoFont; m_pInfoFont = nullptr;
	delete m_pBalloonFont; m_pBalloonFont = nullptr;

	m_bSoundAllSet = false;
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Move);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Blow);

	if(m_pShapeExtraRef) m_pShapeExtraRef->m_bVisible = false; // 안보이게 한다..
}

void CPlayerBase::Release()
{
	m_AnimationDeque.clear();

	m_Chr.Release();
	m_Chr.PartAlloc(PART_POS_COUNT); // 기본적으로 파트와 플러그 세팅..
	m_Chr.PlugAlloc(PLUG_POS_COUNT);

	m_bSoundAllSet = false;
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Move);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Blow);

	m_pLooksRef = nullptr;				// 기본적인 모습과 기본 정보 참조 테이블
	memset(m_pItemPlugBasics, 0, sizeof(m_pItemPlugBasics)); // 캐릭터에 붙은 무기들..
	memset(m_pItemPlugExts, 0, sizeof(m_pItemPlugExts));
	memset(m_pItemPartBasics, 0, sizeof(m_pItemPartBasics)); // 캐릭터에 붙은 갑옷들..
	memset(m_pItemPartExts, 0, sizeof(m_pItemPartExts)); // 캐릭터에 붙은 갑옷들..

	m_iIDTarget	= -1;
	m_bGuardSuccess = false; // 방어에 성공했는지에 대한 플래그..
	m_bVisible = true;			// 보이는지??

	m_cvDuration.a = m_cvDuration.r = m_cvDuration.g = m_cvDuration.b = 1.0f; // 지속 컬러 값
	m_fDurationColorTimeCur = 0; // 현재 시간..
	m_fDurationColorTime = 0; // 지속시간..

	m_fFlickeringFactor = 1.0f; // 깜박거림 알파 값 1.0 이면 깜박이지 않는다....
	m_fFlickeringTime = 0; // 깜박거림 시간..

	m_fTimeAfterDeath = 0; // 죽는 모션을 취하는 타이머 - 5초정도면 적당한가?? 그전에 공격을 받으면 바로 죽는다.

	m_eStateNext = m_eState = PSA_BASIC;
	m_eStateMove = PSM_STOP; // 첨에 정지..
	m_eStateDying = PSD_UNKNOWN; // 죽을때 방법
	m_fTimeDying = 0; // 죽는 모션 취할때 지난 시간..

	m_fRotRadianPerSec = DegreesToRadians(270.0f); // 초당 회전 라디안값
	m_fMoveSpeedPerSec = 0; // 초당 움직임 값.. 이값은 기본값이고 상태(걷기, 달리기, 뒤로, 저주등) 에 따라 가감해서 쓴다..
	m_fYawCur = 0; // 현재 회전값..
	m_fYawToReach = 0;

	m_fGravityCur = 0;			// 중력값..
	m_fYNext = 0;				// 오브젝트 혹은 지형의 충돌 체크에 따른 높이값..

	m_fScaleToSet = 1.0f;			// 점차 스케일 값변화..
	m_fScalePrev = 1.0f;

	m_InfoBase.Init();				// 첨엔 종족값을 모른다..

	m_pShapeExtraRef = nullptr;					// 이 NPC 가 성문이나 집등 오브젝트의 형태이면 이 포인터를 세팅해서 쓴,다..

	m_fCastFreezeTime = 0.0f;
	m_fAttackDelta = 1.0f;		// 스킬이나 마법에 의해 변하는 공격 속도.. 1.0 이 기본이고 클수록 더 빨리 공격한다.
	m_fMoveDelta = 1.0f;			// 스킬이나 마법에 의해 변하는 이동 속도 1.0 이 기본이고 클수록 더 빨리 움직인다.
	m_vDirDying.Set(0,0,1); // 죽을때 밀리는 방향..

	m_bAnimationChanged = false;	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..

	if(m_pShapeExtraRef) m_pShapeExtraRef->m_bVisible = false; // 안보이게 한다..

	CGameBase::Release();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

void CPlayerBase::SetSoundAndInitFont(uint32_t dwFontFlag)
{
	if (m_pLooksRef == nullptr)
		return;

	if (m_bSoundAllSet)
		return;

	m_bSoundAllSet = true;
	
	if (m_pSnd_Move == nullptr)
		m_pSnd_Move = s_SndMgr.CreateObj(m_pLooksRef->iSndID_Move);

	if (m_pSnd_Struck_0 == nullptr)
		m_pSnd_Struck_0 = s_SndMgr.CreateObj(m_pLooksRef->iSndID_Struck0);

	if (m_pSnd_Breathe_0 == nullptr)
		m_pSnd_Breathe_0 = s_SndMgr.CreateObj(m_pLooksRef->iSndID_Breathe0);

	if (m_pSnd_Blow == nullptr)
		m_pSnd_Blow = s_SndMgr.CreateObj(100);

	// 무기에 해당되는 사운드...
	__TABLE_ITEM_BASIC* pItemBasic = m_pItemPlugBasics[PLUG_POS_RIGHTHAND];
	if (pItemBasic == nullptr)
		pItemBasic = m_pItemPlugBasics[PLUG_POS_LEFTHAND];

	SetSoundPlug(pItemBasic);

	// Font 초기화..
	if (m_pIDFont == nullptr) 
	{
		std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

		m_pIDFont = new CDFont(szFontID, 12, dwFontFlag);//D3DFONT_BOLD);
		m_pIDFont->InitDeviceObjects( s_lpD3DDev );
		m_pIDFont->RestoreDeviceObjects();

		m_pIDFont->SetText(m_InfoBase.szID); // 폰트에 텍스트 지정.
		m_pIDFont->SetFontColor(m_InfoBase.crID);
	}
}

void CPlayerBase::SetSoundPlug(__TABLE_ITEM_BASIC* pItemBasic)
{
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_1);
	
	if(pItemBasic) //사운드 넣어라..
	{
		m_pSnd_Attack_0 = CN3Base::s_SndMgr.CreateObj(pItemBasic->dwSoundID0);
//		m_pSnd_Attack_1 = CN3Base::s_SndMgr.CreateObj(pItemBasic->dwSoundID1); // 맞는 소리..
	}
	else
	{
		m_pSnd_Attack_0 = CN3Base::s_SndMgr.CreateObj(m_pLooksRef->iSndID_Attack0); // 휘두르는 소리.
//		m_pSnd_Attack_1 = CN3Base::s_SndMgr.CreateObj(m_pLooksRef->iSndID_Attack1); // 휘두르는 소리.
	}
}

void CPlayerBase::ReleaseSoundAndFont()
{
	if(false == m_bSoundAllSet) return;
	m_bSoundAllSet = false;

	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Move);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Attack_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Struck_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_0);
//	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Breathe_1);
	CN3Base::s_SndMgr.ReleaseObj(&m_pSnd_Blow);

	delete m_pIDFont; m_pIDFont = nullptr;
	delete m_pInfoFont; m_pInfoFont = nullptr;
	delete m_pClanFont; m_pClanFont = nullptr;
	delete m_pBalloonFont; m_pBalloonFont = nullptr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

void CPlayerBase::InfoStringSet(const std::string& szInfo, D3DCOLOR crFont)
{
	if (szInfo.empty())
	{
		delete m_pInfoFont;
		m_pInfoFont = nullptr;
		return;
	}

	if (m_pInfoFont == nullptr)
	{
		std::string szFontInfo = fmt::format_text_resource(IDS_FONT_INFO);

		m_pInfoFont = new CDFont(szFontInfo, 12, D3DFONT_BOLD);
		m_pInfoFont->InitDeviceObjects(s_lpD3DDev);
		m_pInfoFont->RestoreDeviceObjects();
	}
	m_pInfoFont->SetText(szInfo, D3DFONT_BOLD); // 폰트에 텍스트 지정.
	m_pInfoFont->SetFontColor(crFont);
}

void CPlayerBase::BalloonStringSet(const std::string& szBalloon, D3DCOLOR crFont)
{
	if (szBalloon.empty())
	{
		delete m_pBalloonFont;
		m_pBalloonFont = nullptr;
		m_fTimeBalloon = 0; // 풍선말 표시시간..
		return;
	}

	if (m_pBalloonFont == nullptr)
	{
		std::string szFontBalloon = fmt::format_text_resource(IDS_FONT_BALLOON);

		m_pBalloonFont = new CDFont(szFontBalloon, 12);
		m_pBalloonFont->InitDeviceObjects(s_lpD3DDev);
		m_pBalloonFont->RestoreDeviceObjects();
	}

	m_fTimeBalloon = szBalloon.size() * 0.2f;

	m_pBalloonFont->SetText(szBalloon.c_str(), 0); // 폰트에 텍스트 지정.
	m_pBalloonFont->SetFontColor(crFont);
}

void CPlayerBase::IDSet(int iID, const std::string& szID, D3DCOLOR crID)
{
	m_InfoBase.iID = iID;
	m_InfoBase.szID = szID; // 이름으로 ID 를 대체한다.
	m_InfoBase.crID = crID;

#ifdef _DEBUG
	m_Chr.m_szName = szID; // 디버깅을 위해서 이름을 넣어논다.. 그래야 구별 가능하다..
#endif
}

void CPlayerBase::KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank)
{
	std::string szPlug;
	if (iGrade > 0 && iGrade <= 5)
	{
		// 종족과 등급으로 플러그 이름을 만든다..
		szPlug = fmt::format("Item\\ClanAddOn_{:03}_{}.n3cplug",
			static_cast<int>(m_InfoBase.eRace), iGrade);
	}

	m_InfoBase.iKnightsID = iID;

	CN3CPlugBase* pPlug = PlugSet(PLUG_POS_KNIGHTS_GRADE, szPlug, nullptr, nullptr);
	if (pPlug == nullptr)
		return;

	__TABLE_FX* pFXClanRank = s_pTbl_FXSource.Find(FXID_CLAN_RANK_1);

	std::string szFXMain, szFXTail;
	if (pFXClanRank != nullptr
		&& iRank <= 5
		&& iRank >= 1)
		szFXMain = pFXClanRank->szFN;

	static_cast<CN3CPlug*>(pPlug)->InitFX(szFXMain, szFXTail, 0xffffffff);
}

/*
void CPlayerBase::RenderShadow()
{
//	By : Ecli666 ( On 2002-03-29 오후 4:22:59 )
/*
	LPDIRECT3DTEXTURE8 lpTex = nullptr;
	if(m_pTexShadow) lpTex = m_pTexShadow->Get();

	__AlphaPrimitive* pAP = s_AlphaMgr.Add();
	if(pAP)
	{
		pAP->bUseVB				= FALSE;
		pAP->dwBlendDest		= D3DBLEND_INVSRCALPHA;
		pAP->dwBlendSrc			= D3DBLEND_SRCALPHA;
		pAP->dwFVF				= FVF_XYZT1;
		pAP->nPrimitiveCount	= 2;
		pAP->ePrimitiveType		= D3DPT_TRIANGLEFAN;
		pAP->dwPrimitiveSize	= sizeof(__VertexXyzT1);
		pAP->fCameraDistance	= (s_CameraData.vEye - m_Chr.m_Matrix.Pos()).Magnitude();
		pAP->lpTex				= lpTex;
		pAP->nRenderFlags		= RF_NOTZWRITE;
		pAP->nVertexCount		= 4;
	//	pAP->MtxWorld			= &m_Matrix;
		pAP->pVertices			= m_vShadows;
		pAP->pwIndices			= nullptr;

		pAP->MtxWorld.Identity();
		pAP->MtxWorld.PosSet(m_Chr.m_Matrix.Pos());
		pAP->MtxWorld.m[3][1] = 0.05f;
	}

	for(int i = 0; i < 4; i++)
		m_vShadows[i].y = s_pTerrain->GetHeight(pAP->MtxWorld.m[3][0] + m_vShadows[i].x, pAP->MtxWorld.m[3][2] + m_vShadows[i].z);

	return; // 렌더링 안하지롱.
*/

//	~(By Ecli666 On 2002-03-29 오후 4:22:59 )

/*
	// 그림자 렌더링.
	// backup
	uint32_t dwAlpha;
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);

	// render state 세팅
	if(FALSE == dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

	// texture state 세팅 (alpha)
	LPDIRECT3DTEXTURE8 lpTex = m_pTexShadow->Get();
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetTexture(0, lpTex);
	
	static __Matrix44 mtx;
	mtx.Identity();
	mtx.PosSet(m_Chr.m_Matrix.Pos());
	mtx.m[3][0] += 0.1f;
	mtx.m[3][1] = 0.05f;
	mtx.m[3][2] -= 0.1f;
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());
	s_lpD3DDev->SetFVF(FVF_XYZT1);

	for(int i = 0; i < 4; i++)
		m_vShadows[i].y = s_pTerrain->GetHeight(mtx.m[3][0] + m_vShadows[i].x, mtx.m[3][2] + m_vShadows[i].z);
	
	s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_vShadows, sizeof(__VertexXyzT1));

	// restore
	if(FALSE == dwAlpha) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);

}*/

void CPlayerBase::RenderChrInRect(CN3Chr* pChr, const RECT& Rect)
{
	if (nullptr == pChr) return;

	// 2002년 2월 15일 Dino 재수정..
	// viewport 영역을 0보다 작은곳에서부터 (즉 front buffer의 영역을 벗어나게) 지정할 수 없기 때문에 계산이 복잡해졌다.

	RECT rcViewport;	// viewport 영역을 다시 계산한다. (front buffer의 크기를 벗어나지 않게..)
	if ( Rect.left < 0 ) rcViewport.left = 0;
	else rcViewport.left = Rect.left;
	if ( Rect.top < 0 ) rcViewport.top = 0;
	else rcViewport.top = Rect.top;
	if ( Rect.right > (int)(s_CameraData.vp.X + s_CameraData.vp.Width)) rcViewport.right = s_CameraData.vp.X + s_CameraData.vp.Width;
	else rcViewport.right = Rect.right;
	if ( Rect.bottom > (int)(s_CameraData.vp.Y + s_CameraData.vp.Height)) rcViewport.bottom = s_CameraData.vp.Y + s_CameraData.vp.Height;
	else rcViewport.bottom = Rect.bottom;

	// set viewport
	D3DVIEWPORT9 vp;
	vp.X = rcViewport.left;
	vp.Y = rcViewport.top;
	vp.Width = rcViewport.right - rcViewport.left;
	vp.Height = rcViewport.bottom - rcViewport.top;
	vp.MinZ = 0.0f;
	vp.MaxZ = 1.0f;
	if (vp.Width <= 0 ||
		vp.Height <= 0 || 
		vp.Width > s_CameraData.vp.Width || 
		vp.Height > s_CameraData.vp.Height) return;	// front buffer보다 Width또는 Height가 크면 그리지 않는다.

	s_lpD3DDev->SetViewport(&vp);

	// set matrix
	__Matrix44 mtxProj, mtxView;
	float fChrHeight = pChr->Height()+0.2f;	// 캐릭터의 키에 20cm정도 더한값
	float fVCenter = fChrHeight*0.5f;
	int iWidth = Rect.right - Rect.left;
	int iHeight = Rect.bottom - Rect.top;
	float fViewVolumeHeight = fChrHeight * vp.Height / iHeight;	// 캐릭터의 키(클리핑 될 경우 클리핑 되는 비율에 맞게 좁혀준다.)
	float fViewVolumeWidth = fChrHeight * vp.Width / iHeight;	// 가로는 pRect의 가로 세로 비율에 맞게 (클리핑 될 경우 클리핑 되는 비율에 맞게 좁혀준다.)
																// 원래는 이거 : fChrHeight * iWidth / iHeight * vp.Width / iWidth;
	mtxProj.OrthoLH(fViewVolumeWidth, fViewVolumeHeight, 0, 20);
	
	float fCameraMoveX = ((fChrHeight*iWidth/iHeight)-fViewVolumeWidth)/2.0f;	// 클리핑에 따른 카메라 이동 수치
	float fCameraMoveY = (fChrHeight-fViewVolumeHeight)/2.0f;
	if (rcViewport.left != Rect.left) fCameraMoveX = -fCameraMoveX;		// 왼쪽 영역이 짤리게 그려야 하므로 카메라를 오른쪽(카메라가 -Z축을 바라보기 때문에 카메라의 오른쪽은 -X쪽이다.)으로 이동
	if (rcViewport.top != Rect.top) fCameraMoveY = -fCameraMoveY;			// 위쪽 영역이 짤리게 그려야 하므로 카메라를 아래쪽으로 이동

//	mtxView.LookAtLH(	{ 0.0f + fCameraMoveX, fVCenter+2.0f + fCameraMoveY, 10.0f },	// 여기서 View matrix는 카메라 각도와 상관있다. 거리는 원근에 아무 영향을 미치지 않는다.
//						{ 0.0f + fCameraMoveX, fVCenter + fCameraMoveY, 0.0f },	// fVCenter: 캐릭터 키의 중간을 바라보기
//						{ 0.0f, 1.0f, 0.0f } );
	const __Vector3& vChrPos = pChr->Pos();

	// 여기서 View matrix는 카메라 각도와 상관있다. 거리는 원근에 아무 영향을 미치지 않는다.
	// fVCenter: 캐릭터 키의 중간을 바라보기
	const __Vector3 vEye(
		vChrPos.x + fCameraMoveX,
		vChrPos.y + fVCenter + 2.0f + fCameraMoveY,
		vChrPos.z + 10.0f);

	const __Vector3 vAt(
		vChrPos.x + fCameraMoveX,
		vChrPos.y + fVCenter + fCameraMoveY,
		vChrPos.z + 0.0f);

	const __Vector3 vUp(
		0.0f, 1.0f, 0.0f);

	mtxView.LookAtLH(vEye, vAt, vUp);
	s_lpD3DDev->SetTransform(D3DTS_VIEW, mtxView.toD3D());
	s_lpD3DDev->SetTransform(D3DTS_PROJECTION, mtxProj.toD3D());

	// backup render state
	DWORD dwFog, dwZEnable;//, dwLighting;
	s_lpD3DDev->GetRenderState( D3DRS_ZENABLE, &dwZEnable );
//	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLighting );	// lighting은 외부에서 조정할 수 있게 하자.
	s_lpD3DDev->GetRenderState( D3DRS_FOGENABLE , &dwFog );

	// set render state
	if (D3DZB_TRUE != dwZEnable) s_lpD3DDev->SetRenderState( D3DRS_ZENABLE, D3DZB_TRUE);
//	if (FALSE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, FALSE);
	if (FALSE != dwFog) s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, FALSE);

	// render
	D3DRECT rc = { Rect.left, Rect.top, Rect.right, Rect.bottom };
	s_lpD3DDev->Clear(1, &rc, D3DCLEAR_ZBUFFER, 0, 1.0f, 0); // Z Buffer Clear

	int iLODPrev = CN3Chr::LODDelta();
	CN3Chr::LODDeltaSet(0);
	pChr->m_nLOD = 1;	// LOD를 0으로 만든다.(최대한 디테일하게..)
	pChr->Render();
	CN3Chr::LODDeltaSet(iLODPrev);

	// restore
	if (D3DZB_TRUE != dwZEnable) s_lpD3DDev->SetRenderState( D3DRS_ZENABLE, dwZEnable);
//	if (FALSE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLighting);
	if (FALSE != dwFog) s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, dwFog);
    s_lpD3DDev->SetTransform( D3DTS_PROJECTION, s_CameraData.mtxProjection.toD3D());
	s_lpD3DDev->SetTransform( D3DTS_VIEW, s_CameraData.mtxView.toD3D());
	s_lpD3DDev->SetViewport(&(s_CameraData.vp));
}

void CPlayerBase::DurationColorSet(const _D3DCOLORVALUE &color, float fDurationTime)
{
	m_fDurationColorTime = fDurationTime;
	m_fDurationColorTimeCur = 0;
	m_cvDuration = color;
}

void CPlayerBase::FlickerFactorSet(float fAlpha)
{
	if(fAlpha < 0.1f) fAlpha = 0.1f;
	if(fAlpha > 1.0f) fAlpha = 1.0f;

	m_fFlickeringFactor = fAlpha; // 깜박거림 알파 값 1.0 이면 깜박이지 않는다....
	m_fFlickeringTime = 0; // 깜박거림 시간..
}

void CPlayerBase::RotateTo(float fYaw, bool bImmediately)
{
	int iLot = (int)(fYaw/__PI2);
	if(iLot) fYaw -= iLot * __PI2; // 0 ~ 360 도 사이로 맞추고..

	iLot = (int)(fYaw/__PI);
	if(iLot) fYaw -= iLot * __PI2; // -180 ~ 180 사이로 맞춘다..

	m_fYawToReach = fYaw;
	if(bImmediately) m_fYawCur = fYaw; // 바로 돌려야 하면..
}

void CPlayerBase::RotateTo(CPlayerBase* pOther)
{
	if(nullptr == pOther || pOther == this) return;

	__Vector3 vDir = pOther->Position() - m_Chr.Pos();
	vDir.y = 0.0f;
	vDir.Normalize();

	float fYaw = ::_Yaw2D(vDir.x, vDir.z);
	this->RotateTo(fYaw, false); // 방향을 돌리고

}

void CPlayerBase::TickYaw()
{
	if(m_fYawCur != m_fYawToReach && this->IsAlive()) // 회전을 해야 한다면.. 살아 있는 넘만...
	{
		float fYawDiff = m_fYawToReach - m_fYawCur; // 회전값 차이.
		float fYawDelta = m_fRotRadianPerSec * s_fSecPerFrm; // 회전할 양
		if(std::abs(fYawDiff) <= fYawDelta)
		{
			m_fYawCur = m_fYawToReach; // 회전할 양이 작으면.. 바로 세팅
		}
		else
		{
			if(fYawDiff > 0)
			{
				if(fYawDiff < __PI) fYawDelta *= 1.0f;
				else if(fYawDiff >= __PI) fYawDelta *= -1.0f;
			}
			else
			{
				if(fYawDiff > -__PI) fYawDelta *= -1.0f;
				else if(fYawDiff <= -__PI) fYawDelta *= 1.0f;
			}

			m_fYawCur += fYawDelta; // 회전..

			if(std::abs(m_fYawCur) > __PI)
			{
				int iLot = (int)(m_fYawCur/__PI);
				if(iLot) m_fYawCur -= iLot * __PI2; // 0 ~ 360 도 사이로 맞추고..

				iLot = (int)(m_fYawCur/__PI);
				if(iLot) m_fYawCur -= iLot * __PI2; // -180 ~ 180 사이로 맞춘다..
			}
		}
	}

	// 회전값 적용..
	__Quaternion qtRot;
	qtRot.RotationAxis(0,1,0,m_fYawCur); // 회전 ....
	m_Chr.RotSet(qtRot);
}

void CPlayerBase::TickAnimation()
{
	// 걷고 뛰고, 에니메이션등... 속도 적용
	float fAniSpeedDelta = 1.0f;
	if(PSM_STOP != m_eStateMove) fAniSpeedDelta = m_fMoveDelta; // 이동중이면 스피드 적용..
	else if(PSA_ATTACK == m_eState) fAniSpeedDelta = m_fAttackDelta; // 공격중이면 공격 스피드 적용..
	__ASSERT(fAniSpeedDelta >= 0.1f && fAniSpeedDelta < 10.0f, "Invalid Animation Speed Delta!!!");
	m_Chr.AniSpeedDeltaSet(fAniSpeedDelta); // 에니메이션 스피드 실제 적용..
	m_Chr.Tick(); // 에니메이션 틱..

	m_bAnimationChanged = false;	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..
	if(	m_Chr.IsAnimEnd() )// 에니메이션이 끝나면..
	{
		m_bAnimationChanged = true;	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..
		if(m_AnimationDeque.empty()) // 에니메이션 데크가 비어 있으면..
		{
			CPlayerBase* pTarget = this->CharacterGetByID(m_iIDTarget, true);
			this->Action(m_eStateNext, true, pTarget); // 상태 돌리기..
		}
		else // 에니메이션 데크가 비어 있지 않고 시킬 동작이 있으면..
		{
			e_Ani eAniToSet = m_AnimationDeque[0]; // 데크에서 하나 빼오고..
			m_AnimationDeque.pop_front();
			m_Chr.AniCurSet(eAniToSet);
//			TRACE("      Animation : %d\n", eAniToSet);
		}
	}
}

void CPlayerBase::TickDurationColor()
{
	if(m_fDurationColorTime <= 0) return;

	if(m_fDurationColorTimeCur > m_fDurationColorTime) 
	{
		m_fDurationColorTime = 0;
		m_fDurationColorTimeCur = 0;

		for (CN3CPart* pPart : m_Chr.m_Parts)
			pPart->m_Mtl = pPart->m_MtlOrg; // 원래 색대로 돌린다.
	}
	else
	{
		float fD = m_fDurationColorTimeCur / m_fDurationColorTime;
		for (CN3CPart* pPart : m_Chr.m_Parts)
		{
//			pPart->m_Mtl.Ambient.a = pPart->m_MtlOrg.Ambient.a * fD + m_cvDuration.a * (1.0f - fD);
			pPart->m_Mtl.Ambient.r = pPart->m_MtlOrg.Ambient.r * fD + m_cvDuration.r * (1.0f - fD);
			pPart->m_Mtl.Ambient.g = pPart->m_MtlOrg.Ambient.g * fD + m_cvDuration.g * (1.0f - fD);
			pPart->m_Mtl.Ambient.b = pPart->m_MtlOrg.Ambient.b * fD + m_cvDuration.b * (1.0f - fD);

//			pPart->m_Mtl.Diffuse.a = pPart->m_MtlOrg.Diffuse.a * fD + m_cvDuration.a * (1.0f - fD);
			pPart->m_Mtl.Diffuse.r = pPart->m_MtlOrg.Diffuse.r * fD + m_cvDuration.r * (1.0f - fD);
			pPart->m_Mtl.Diffuse.g = pPart->m_MtlOrg.Diffuse.g * fD + m_cvDuration.g * (1.0f - fD);
			pPart->m_Mtl.Diffuse.b = pPart->m_MtlOrg.Diffuse.b * fD + m_cvDuration.b * (1.0f - fD);
		}
	}

	m_fDurationColorTimeCur += s_fSecPerFrm;
}

void CPlayerBase::TickSound()
{
	__Vector3 vPos = this->Position();

	if(PSA_ATTACK == m_eState) // 공격 일때..
	{
//		if(m_pSnd_Attack_0 && m_Chr.NeedPlaySound0())
//			m_pSnd_Attack_0->Play(&vPos); // 공격 1 중일때..
//		if(m_pSnd_Attack_1 && m_Chr.NeedPlaySound1())
//			m_pSnd_Attack_1->Play(&vPos); // 공격 2 중일때..
		if(m_pSnd_Attack_0 && (m_Chr.NeedPlaySound0() || m_Chr.NeedPlaySound1()))
			m_pSnd_Attack_0->Play(&vPos); // 공격 1 중일때..
//		if(m_pSnd_Attack_1 && m_Chr.NeedPlaySound1())
//			m_pSnd_Attack_1->Play(&vPos); // 공격 2 중일때..
	}
	
	if(PSM_STOP == m_eStateMove)
	{
		if(PSA_DYING == m_eState && m_Chr.NeedPlaySound0())
		{
			int DeadSoundID = (rand()%2) ? m_pLooksRef->iSndID_Dead0 : m_pLooksRef->iSndID_Dead1;
			CN3Base::s_SndMgr.PlayOnceAndRelease(DeadSoundID, &vPos);
		}
		else if(PSA_BASIC == m_eState && m_Chr.NeedPlaySound0())
		{
//			CN3SndObj* pSndBreath = (rand()%2) ? m_pSnd_Breathe_0 : m_pSnd_Breathe_1;
//			if(pSndBreath) 
//				pSndBreath->Play(&vPos);
			if(m_pSnd_Breathe_0)
				m_pSnd_Breathe_0->Play(&vPos);
		}		
	}
	else if(PSM_WALK == m_eStateMove ||
			PSM_RUN == m_eStateMove ||
			PSM_WALK_BACKWARD == m_eStateMove )
	{
		if(m_pSnd_Move && m_pSnd_Move != m_pSnd_MyMove && m_Chr.NeedPlaySound0()) 
			m_pSnd_Move->Play(&vPos);
		if(m_pSnd_Move && m_pSnd_Move != m_pSnd_MyMove && m_Chr.NeedPlaySound1()) 
			m_pSnd_Move->Play(&vPos);
	}
}

void CPlayerBase::Tick()  // 회전, 지정된 에니메이션 Tick 및 색깔 지정 처리.. 등등..
{
	if(m_pShapeExtraRef) // 오브젝트이면..
	{
		m_pShapeExtraRef->Tick(FRAME_SELFPLAY);
		return;
	}

	// 중력값 적용.
	__Vector3 vPos = this->Position();
	if(vPos.y > m_fYNext)
	{
		m_fGravityCur += 9.8f * CN3Base::s_fSecPerFrm;
		vPos.y -= m_fGravityCur;
		this->PositionSet(vPos, false);
	}

	/*
	// TEMP search "player position" to get here
	static int loopCount = 0;
	if(loopCount==0) {
		//vPos.x = vPos.x+5.0f;
		//vPos.z = vPos.z + 5.0f;
		//this->PositionSet(vPos, false);

		// NOTE: old karus_start
		vPos.x = 358.0f;
		vPos.y = 120.0f;
		vPos.z = 1610.0f;
		this->PositionSet(vPos, false);

		// NOTE: old/new moradon
		//vPos.x = 361.278503f;
		//vPos.y = 2.822370f;
		//vPos.z = 137.339859f;
		//this->PositionSet(vPos, false);

		loopCount++;
	}
	// TEMP
	*/

	if(vPos.y < m_fYNext)
	{
		vPos.y = m_fYNext;
		this->PositionSet(vPos, false);
		m_fGravityCur = 0;
	}

	// 점차 커지는 스케일 적용
	if(m_fScaleToSet != m_fScalePrev)
	{
		float fScale = m_Chr.Scale().y;
		if(m_fScaleToSet > m_fScalePrev) // 커져야 한다..
		{
			fScale += (m_fScaleToSet - m_fScalePrev) * s_fSecPerFrm;
			if(fScale > m_fScaleToSet)
			{
				m_fScalePrev = fScale = m_fScaleToSet;
			}
		}
		else // 작아져야 한다면..
		{
			fScale -= (m_fScalePrev - m_fScaleToSet) * s_fSecPerFrm;
			if(fScale < m_fScaleToSet)
			{
				m_fScalePrev = fScale = m_fScaleToSet;
			}
		}
		m_Chr.ScaleSet(fScale, fScale, fScale);
	}

	this->TickYaw();
	this->TickAnimation();
	this->TickDurationColor();
	this->TickSound();

	// 죽는 것 처리..
	if(m_fTimeAfterDeath > 0) m_fTimeAfterDeath += s_fSecPerFrm; // 죽는 모션을 취하는 타이머 - 5초정도면 적당한가?? 그전에 공격을 받으면 바로 죽는다.
	if(PSA_DYING == m_eState) 
	{
		if(PSD_DISJOINT == m_eStateDying || PSD_KNOCK_DOWN == m_eStateDying) // 뒤로 밀린다..
		{
			float fAD = 0;
			if(m_fTimeDying <= 0.2f) fAD = 5.0f;
			else if(m_fTimeDying < 0.4f) fAD = 5.0f * (0.4f - m_fTimeDying);

			if(fAD > 0) 
			{
				float fDelta = (fAD * (0.3f + 0.7f / m_Chr.Radius()));
				vPos -= m_vDirDying * (fDelta * s_fSecPerFrm); // 덩치에 반비례하게 밀린다..
				vPos.y = ACT_WORLD->GetHeightWithTerrain(vPos.x, vPos.z);
				m_Chr.PosSet(vPos);
			}
		}
		else
		{
		}

		m_fTimeDying += s_fSecPerFrm; // 죽는 동작을 취하는 시간
	}

	// 풍선말 처리..
	if(m_fTimeBalloon > 0)
	{
		m_fTimeBalloon -= s_fSecPerFrm;
		if(m_fTimeBalloon < 0)
		{
			m_fTimeBalloon = 0;
			this->BalloonStringSet("", 0); // 시간 榮?!!
		}
	}
}

void CPlayerBase::Render(float fSunAngle)
{
	if(m_Chr.m_nLOD < 0 || m_Chr.m_nLOD >= MAX_CHR_LOD) return;

#ifdef _DEBUG
	if(m_pShapeExtraRef) // 오브젝트 형식이면...
	{
		m_pShapeExtraRef->RenderCollisionMesh();
		return;
	}
#endif

	
	
	
	
	
	float fFactorToApply = 1.0f;
	if(m_fTimeAfterDeath > TIME_CORPSE_REMAIN - TIME_CORPSE_REMOVE) // 투명하게 만든다..
		fFactorToApply = (TIME_CORPSE_REMAIN - m_fTimeAfterDeath) / TIME_CORPSE_REMOVE;
	else if(m_fFlickeringFactor != 1.0f)
	{
		m_fFlickeringTime += s_fSecPerFrm;
		if(m_fFlickeringTime < 0.5f)
			fFactorToApply = m_fFlickeringFactor;
		else if(m_fFlickeringTime < 1.0f)
			fFactorToApply = m_fFlickeringFactor * 0.5f;
		else
		{
			m_fFlickeringTime = 0;
			fFactorToApply = m_fFlickeringFactor;
		}
	}


	if(fFactorToApply != 0) // 투명도가 적용되야 한다면..
	{
		DWORD dwAlphaBlend, dwAlphaOP, dwAlphaArg1, dwTexFactor, dwSrcBlend, dwDestBlend; // , dwZEnable;
		
		// backup state
		s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaBlend);
		s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
		s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
//			s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZEnable);
		s_lpD3DDev->GetRenderState(D3DRS_TEXTUREFACTOR, &dwTexFactor);	// alpha factor 설정
		s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAlphaOP);
		s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAlphaArg1);

		DWORD dwFactorToApply = ((DWORD)(255.0f * fFactorToApply)) << 24; // 투명도 계산..

		// render state 세팅
		s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
//			s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
		s_lpD3DDev->SetRenderState(D3DRS_TEXTUREFACTOR, dwFactorToApply);	// alpha factor 설정
		
		// texture state 세팅(alpha)
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);

		m_Chr.Render();

		// restore state
		s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlend);
		s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
		s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	//			s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZEnable);
		s_lpD3DDev->SetRenderState(D3DRS_TEXTUREFACTOR, dwTexFactor);	// alpha factor 설정
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAlphaOP);
		s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAlphaArg1);
	}
	else
	{
		m_Chr.Render();
	}

	if (s_Options.iUseShadow) this->RenderShadow(fSunAngle);




















#ifdef _DEBUG
	if(m_Chr.CollisionMesh()) // 충돌 체크용 박스..
	{
		s_lpD3DDev->SetTransform(D3DTS_WORLD, m_Chr.m_Matrix.toD3D());
		m_Chr.CollisionMesh()->Render(0xffff0000);
	}

	__Vector3 vLine[3];
	vLine[0] = m_Chr.Pos(); vLine[0].y += 1.3f;
	vLine[1] = m_vPosFromServer; vLine[1].y += 1.3f;
	vLine[2] = vLine[1]; vLine[2].y += 3.0f;
	__Matrix44 mtx; mtx.Identity();
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtx.toD3D());
	CN3Base::RenderLines(vLine, 2, 0xff00ffff);
#endif

	if(m_InfoBase.bRenderID && m_pIDFont)
	{
		float fDist = (m_Chr.Pos() - s_CameraData.vEye).Magnitude();

		// NOTE(srmeier): this will prevent the NPC text from displaying past a certain distance
		if(fDist < 48.0f)
		{
			__Vector3 vHead = this->HeadPosition();
			vHead.y += this->Height() / 10.0f;
			if(PSA_SITDOWN == m_eState) vHead.y += this->RootPosition().y - this->Height()/2.0f; // 앉아 있으면..
			_POINT pt = ::_Convert3D_To_2DCoordinate(vHead, s_CameraData.mtxView, s_CameraData.mtxProjection, s_CameraData.vp.Width, s_CameraData.vp.Height);

			SIZE size = m_pIDFont->GetSize();
			pt.y -= size.cy + 5;
			D3DCOLOR crFont = m_pIDFont->GetFontColor();

			m_pIDFont->DrawText(pt.x - (size.cx / 2) - 1.0f, pt.y - 1.0f, 0xff000000, 0);
			m_pIDFont->DrawText(pt.x - (size.cx / 2) + 1.0f, pt.y + 1.0f, 0xff000000, 0);
			m_pIDFont->DrawText(pt.x - (size.cx / 2) + 0.0f, pt.y + 0.0f, crFont, 0);

			//Knight & clan 렌더링..
			if(m_pClanFont && m_pClanFont->IsSetText())
			{
				size = m_pClanFont->GetSize();
				pt.y -= size.cy + 5;
				crFont = m_pClanFont->GetFontColor();
				m_pClanFont->DrawText(pt.x - (size.cx / 2) - 1.0f, pt.y - 1.0f, 0xff000000, 0);
				m_pClanFont->DrawText(pt.x - (size.cx / 2) + 1.0f, pt.y + 1.0f, 0xff000000, 0);
				m_pClanFont->DrawText(pt.x - (size.cx / 2) + 0.0f, pt.y + 0.0f, crFont, 0);
			}
			
			// 파티 모집...
			if(m_pInfoFont && m_pInfoFont->IsSetText())//->GetFontHeight() > 0)
			{
				size = m_pInfoFont->GetSize();
				pt.y -= size.cy + 5;
				crFont = m_pInfoFont->GetFontColor();
				m_pInfoFont->DrawText(pt.x - (size.cx / 2) - 1.0f, pt.y - 1.0f, 0xff000000, 0);
				m_pInfoFont->DrawText(pt.x - (size.cx / 2) + 1.0f, pt.y + 1.0f, 0xff000000, 0);
				m_pInfoFont->DrawText(pt.x - (size.cx / 2) + 0.0f, pt.y + 0.0f, crFont, 0);
			}

			// 풍선 메시지..
			if(m_pBalloonFont && m_pBalloonFont->IsSetText())//->GetFontHeight())
			{
				crFont = m_pBalloonFont->GetFontColor();
				if(m_fTimeBalloon < 2.0f) // 천천히 흐릿하게 없앤다..
				{
					uint32_t crFont = m_pBalloonFont->GetFontColor();
					crFont = (crFont & 0x00ffffff) | ((uint32_t)(255 * (m_fTimeBalloon/2.0f))<<24);
					m_pBalloonFont->SetFontColor(crFont);
				}

				size = m_pBalloonFont->GetSize();
				pt.y -= size.cy + 5;
				m_pBalloonFont->DrawText(pt.x - (size.cx / 2) - 1.0f, pt.y - 1.0f, 0xff000000, 0);
				m_pBalloonFont->DrawText(pt.x - (size.cx / 2) + 1.0f, pt.y + 1.0f, 0xff000000, 0);
				m_pBalloonFont->DrawText(pt.x - (size.cx / 2) + 0.0f, pt.y + 0.0f, crFont, D3DFONT_BOLD);
			}
		}
	}
}

__Vector3 CPlayerBase::HeadPosition()
{
	__Vector3 vHead = m_Chr.Pos();
	vHead.y += m_Chr.Height();

	return vHead;
}

float CPlayerBase::Height()
{
	if(m_pShapeExtraRef) 
	{
		return (m_pShapeExtraRef->Max().y - m_pShapeExtraRef->Min().y) * m_pShapeExtraRef->Scale().y;
	}
	else
	{
		return m_Chr.Height();
	}
}

float CPlayerBase::Radius()
{
	if(m_pShapeExtraRef) 
	{
		return m_pShapeExtraRef->Radius();
	}
	else
	{
		return m_Chr.Radius();
	}
}

__Vector3 CPlayerBase::Direction()
{
	__Vector3 vDir(0,0,1);
	__Matrix44 mtxRot = m_Chr.Rot();
	vDir *= mtxRot;

	return vDir;
}

bool CPlayerBase::Action(e_StateAction eState, bool bLooping, CPlayerBase* pTarget, bool bForceSet)
{
	if(false == bForceSet)
	{
		// State Table Action
		static BOOL sTableAction[PSA_COUNT][PSA_COUNT] =
		{
			//---------------------------------------------------------------------------------------------------------------------------
			//	BASIC,	   ATTACK,		GUARD,	   STRUCK, 		DYING,		DEATH, SPELL_MAGIC,	  SITDOWN
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			1,			1,			1,			1,			0,			1,			1 }, // PSA_BASIC		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			1,			0,			0, 			1,			0,			1,			0 }, // PSA_ATTACK		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			1,			1,			0, 			1,			0,			1,			0 }, // PSA_GUARD		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			1,			1,			1,			1,			0,			1,			0 }, // PSA_STRUCK		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		0,			0,			0,			0,			0,			1,			0,			0 }, // PSA_DYING		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		0,			0,			0,			0,			0,			0,			0,			0 }, // PSA_DEATH		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			0,			0,			0,			1,			1,			1,			0 }, // PSA_SPELL_MAGIC	-> ??
			//---------------------------------------------------------------------------------------------------------------------------
			{		1,			0,			0,			0,			1,			0,			0,			0 } // PSA_SITDOWN		-> ??
			//---------------------------------------------------------------------------------------------------------------------------
		}; 

		if(FALSE == sTableAction[m_eState][eState])
			return false;
	}

//	if(m_szName == "알라딘")
//	{
//		bool bBReak = true;
//		std::string szSt1 = "??";
//		if(PSA_BASIC == m_eState) szSt1 = "보통";
//		else if(PSA_SPELLMAGIC == m_eState) szSt1 = "매직쇼~";
//		TRACE("%s(%.1f) - %s\n", m_szName.c_str(), CN3Base::TimeGet(), szSt1.c_str());
//	}

	bool bNPC = (RACE_NPC == m_InfoBase.eRace ? true : false);
	bool bNeedUpperAnimationOnly = false; // 몸 전체에 에니메이션을 적요하는가... -1 : 전체, 0 : 하체 1 : 상체
	bool bOnceAndFreeze = false;
	e_Ani eAni = ANI_UNKNOWN;
	e_Ani eAniToRestore = ANI_UNKNOWN;
	float fFreezeTime = 0.0f;
	e_StateAction eStatePrev = m_eState;
	m_eStateNext = m_eState = eState; // 일단 캐릭터의 상태 유지..
	
	switch(eState) 
	{
	case PSA_BASIC:
		if(PSM_STOP == m_eStateMove)
		{
			if(PSA_SITDOWN == eStatePrev) // 앉아 있던중이면..
			{
				eAni = ANI_STANDUP; // 일어선다.
				if(PSM_STOP == m_eStateMove) eAniToRestore = this->JudgeAnimationBreath(); // 멈추어 있으면 기본자세.. 판단.
				bOnceAndFreeze = true;
			}
			else eAni = this->JudgeAnimationBreath(); // 멈추어 있으면 기본자세.. 판단.
		}
		else if(PSM_WALK == m_eStateMove) eAni = this->JudgeAnimationWalk(); // 걷고 있으면 걷는 자세
		else if(PSM_RUN == m_eStateMove) eAni = this->JudgeAnimationRun(); // 뛰고 있으면...
		else if(PSM_WALK_BACKWARD == m_eStateMove) eAni = this->JudgeAnimationWalkBackward(); // 뒤로 걷고 있으면...
		else eAni = this->JudgeAnimationBreath(); // 그밖에 ??
		break;

	case PSA_ATTACK:
		if (pTarget != nullptr)
		{
			// 같은 국가이면
			if (!IsHostileTarget(pTarget))
				return false;
			
			if(	!bNPC && IsMovingNow() )	// 플레이어이고.. 이동중이었으면..
			{
				if(m_pItemPlugBasics[0]) eAni = ANI_ATTACK_WITH_WEAPON_WHEN_MOVE;		// 오른손에 무기를 들고 있으면.. 에니메이션 정해주기..
				else eAni = ANI_ATTACK_WITH_NAKED_WHEN_MOVE;						// 에니메이션 정해주기..
				bNeedUpperAnimationOnly = true;										// 상체는 한번 플레이하고 멈춘다..
			}
			else
			{
				eAni = this->JudgeAnimationAttack();			// 에니메이션 정해주기..
			}

			if(!bLooping) // 루핑이 아니면..
			{
				m_eStateNext = PSA_BASIC;	// 돌아갈 상태를 기억
			}
		}
		break;

	case PSA_GUARD:
		{
			m_eStateNext = PSA_BASIC;
			eAni = this->JudgeAnimationGuard();

			if(!bNPC) bNeedUpperAnimationOnly = true; // NPC 가 아니면.. 상체
			fFreezeTime = 1.5f; // 좀 길게 막는다.
		}
		break;
	
	case PSA_STRUCK:
		{
			m_eStateNext = PSA_BASIC;
			eAni = this->JudgeAnimationStruck();
			if(!bNPC) bNeedUpperAnimationOnly = true; // NPC 가 아니면.. 상체
		}
		break;
	
	case PSA_DYING:
		m_eStateNext = PSA_DEATH; // 죽인다..!!
		m_eStateMove = PSM_STOP;
		eAni = this->JudgeAnimationDying();
		bOnceAndFreeze = true; // 죽고 바닥에 뻗어서 멈춰라...
		break;

	case PSA_DEATH:
		m_eStateNext = PSA_DEATH;
		if(true == bForceSet) // 강제로 걍 죽이는 거면..
		{
			eAni = this->JudgeAnimationDying(); // 죽는 동작...
			m_Chr.AniFixToLastFrame(eAni); // 마지막 프레임으로 고정..
		}
		this->RegenerateCollisionMesh();  // 최대 최소값을 다시 찾고 충돌메시를 다시 만든다.. -> 죽은 넘 피킹을 정확하게 하기위해서이다.
		return true; // 돌아간다!!!

	case PSA_SITDOWN:
		eAni = ANI_SITDOWN;
		eAniToRestore = ANI_SITDOWN_BREATH;
		bOnceAndFreeze = true;
		break;

	case PSA_SPELLMAGIC:
		m_eStateNext = PSA_BASIC;
		fFreezeTime = m_fCastFreezeTime;
		eAni = this->JudgetAnimationSpellMagic();
		bOnceAndFreeze = true;
		break;

	default: 
		return false;
	}

	float fBlendTime = FLT_MIN;
	if(bForceSet) // 강제 설정이면..
	{
		bNeedUpperAnimationOnly = false; // NPC 가 아니면.. 상체
		fBlendTime = 0;
		m_Chr.m_FrmCtrl.Init();
	}

	// 에니메이션 세팅..
	this->AnimationClear(); // 에니메이션 큐의 내용을 지운다.. 그래야 바로 에니메이션이 나간다.
	if(ANI_UNKNOWN != eAniToRestore) this->AnimationAdd(eAniToRestore, false); // 다음 에니메이션이 있으면 데크에 집어 넣는다.

	if(bNeedUpperAnimationOnly) // 상체만 한다..
		m_Chr.AniUpperSet(eAni, fFreezeTime);
	else // 걍 에니메이션..
	{
		m_Chr.AniCurSet(eAni, bOnceAndFreeze, fBlendTime, fFreezeTime);
	}

	if(bForceSet && m_Chr.m_FrmCtrl.pAniData) // 강제 설정이면..
	{
		m_Chr.m_FrmCtrl.fFrmCur = m_Chr.m_FrmCtrl.pAniData->fFrmEnd; // 끝프레임으로 강제 설정한다..
	}

	return true;
}

bool CPlayerBase::ActionMove(e_StateMove eMove)
{
	if(this->IsDead()) return false;
	
	static int sStateTableMove[PSM_COUNT][PSM_COUNT] = // State Table Move
	{
		//---------------------------------------------------------------------------------------------------------------------------------------
		//	STOP,	WALK,	RUN,	WALK_BACKWARD
		//---------------------------------------------------------------------------------------------------------------------------------------
		{	0,		1,		1,		1 }, // PSM_STOP
		//---------------------------------------------------------------------------------------------------------------------------------------
		{	1,		0,		1,		1 }, // PSM_WALK
		//---------------------------------------------------------------------------------------------------------------------------------------
		{	1,		1,		0,		1 }, // PSM_RUN
		//---------------------------------------------------------------------------------------------------------------------------------------
		{	1,		1,		1,		0 } // PSM_WALK_BACKWARD
		//---------------------------------------------------------------------------------------------------------------------------------------
	};

	if(FALSE == sStateTableMove[m_eStateMove][eMove]) return false;
	
	m_eStateNext = m_eState; // 돌아갈 상태를 현재 상태와 맞게 강제 지정..
	m_eStateMove = eMove;

	e_Ani eAni = ANI_UNKNOWN;
	switch(eMove)
	{
	case PSM_STOP:
		eAni = this->JudgeAnimationBreath();
		break;

	case PSM_WALK:
		eAni = this->JudgeAnimationWalk();
		break;

	case PSM_RUN:
		eAni = this->JudgeAnimationRun();
		break;

	case PSM_WALK_BACKWARD:
		eAni = this->JudgeAnimationWalkBackward();
		break;

	default:
		return false;
	}

	this->Action(PSA_BASIC, true); // 딴짓 못하게 건다..

	// 에니메이션 세팅..
	this->AnimationClear(); // 에니메이션 큐의 내용을 지운다.. 그래야 바로 에니메이션이 나간다.
	m_Chr.AniCurSet(eAni, false, FLT_MIN, 0, false); // 상체 에니메이션을 중지시키지 않고 걷거나 뛴다...

	return true;
}

void CPlayerBase::ActionDying(e_StateDying eSD, const __Vector3& vDir)
{
	this->ActionMove(PSM_STOP);
	this->Action(PSA_DYING, false); // 죽이고..
	m_eStateDying = eSD;
	m_vDirDying = vDir; // 죽을때 밀리는 방향..

	e_Ani eAni = ANI_DEAD_NEATLY;
	if(eSD == PSD_KEEP_POSITION)
	{
		if(RACE_NPC == m_InfoBase.eRace) eAni = ANI_NPC_DEAD0; // NPC 일경우 
		else eAni = ANI_DEAD_NEATLY; // 플레이어 일경우..
	}
	else if(eSD == PSD_DISJOINT)
	{
		if(RACE_NPC == m_InfoBase.eRace) eAni = ANI_NPC_DEAD1; // NPC 일경우 
		else eAni = ANI_DEAD_ROLL; // 플레이어 일경우.. 몸이 휙 돌아가서 죽기..
	}
	else if(eSD == PSD_KNOCK_DOWN) // 뒤로 밀리며 죽기.
	{
		if(RACE_NPC == m_InfoBase.eRace) eAni = ANI_NPC_DEAD1; // NPC 일경우 
		else eAni = ANI_DEAD_KNOCKDOWN; // 플레이어 일경우..
	}
	else
	{
		if(RACE_NPC == m_InfoBase.eRace) eAni = ANI_NPC_DEAD0; // NPC 일경우 
		else eAni = ANI_DEAD_NEATLY; // 플레이어 일경우..
	}

	m_Chr.AniCurSet(eAni, true, FLT_MIN, 0, true);
}

bool CPlayerBase::ProcessAttack(CPlayerBase* pTarget)
{
	bool bAttackSuccess = false;
	// we assign/check our target ourselves
	//if (pTarget == nullptr) 
	//	return false;

	// check character animation state
	if (PSA_ATTACK != m_eState
		&& PSA_SPELLMAGIC != m_eState)
		return bAttackSuccess;

	
	// make sure it's time to process an auto-attack
	if(!(m_Chr.NeedStrike0() || m_Chr.NeedStrike1()))
	{
		return bAttackSuccess;
	}
	
	//CPlayerBase*
	pTarget = TargetPointerCheck(false);
	if(pTarget == nullptr)
		return bAttackSuccess;

	__Vector3 vCol(0,0,0);

	// Check that our weapons can collide with the target's mesh
	if(!this->CheckCollisionToTargetByPlug(pTarget, 0, &vCol)
		&& !this->CheckCollisionToTargetByPlug(pTarget, 1, &vCol)) 
	{
		// Get the transform of this object and its target
		const __Matrix44* pMtxMine = m_Chr.MatrixGet(0); 
		const __Matrix44* pMtxTarget = pTarget->m_Chr.MatrixGet(0);

		__Vector3 v0, v1;
		if(pMtxMine)
		{
			// Use the transform of our weapon if available, otherwise use character position
			CN3CPlug* pPlug = m_Chr.Plug(0); 
			if(pPlug != nullptr)
			{
				__Matrix44 mtx = *(m_Chr.MatrixGet(pPlug->m_nJointIndex));
				v0.Set( 0.0f, pPlug->m_fTrace1, 0.0f );
				v0 *= pPlug->m_Matrix;
				v0 *= mtx;
				v0 *= m_Chr.m_Matrix;
			}
			else
				v0 = m_Chr.Pos() + pMtxMine->Pos();
		}
		else
		{
			v0 = m_Chr.Pos();
			v0.y += m_Chr.Height() / 2.0f;
		}

		if(pMtxTarget != nullptr)
		{
			v1 = pMtxTarget->Pos() + pTarget->Position();
			// does the target's mesh collide with a line between v0---v1
			if(!pTarget->CheckCollisionByBox(v0, v1, &vCol, nullptr)) 
			{
				__Vector3 vDir = v0 - v1;
				vDir.Normalize();
				// 안되면 캐릭 사이의 값으로 한다..
				vCol = v1 + vDir * (pTarget->Height() / 3.0f); 
			}
		}
		else if(pTarget->m_pShapeExtraRef && pTarget->m_pShapeExtraRef->CollisionMesh())
		{
			__Vector3 vDir = this->Direction(); vDir.Normalize();
			v1 = v0 + (vDir * 256.0f);

			CN3VMesh* pVMesh = pTarget->m_pShapeExtraRef->CollisionMesh();
			
			if(pVMesh == nullptr || !pVMesh->CheckCollision(pTarget->m_pShapeExtraRef->m_Matrix, v0, v1, &vCol))
			{
				v1 = pTarget->m_pShapeExtraRef->Pos(); v1.y += pTarget->Height() / 2.0f;
				vDir = v1 - v0;
				vDir.Normalize();
				// 안되면 캐릭 사이의 값으로 한다..
				vCol = v0 + vDir * Radius(); 
			}
		}
		else
		{
			return false;
		}
	}
	bAttackSuccess = true;

	if(pTarget->m_fTimeAfterDeath > 0 && !pTarget->IsDead())
	{
		// set target death animation state based off of weapon type
		e_ItemClass eICR = this->ItemClass_RightHand(); 
		e_StateDying deathState = PSD_KEEP_POSITION;
		if(ITEM_CLASS_SWORD_2H == eICR || ITEM_CLASS_AXE_2H == eICR || ITEM_CLASS_MACE_2H == eICR || ITEM_CLASS_POLEARM == eICR)
			deathState = PSD_DISJOINT;
		else if(ITEM_CLASS_SWORD == eICR || ITEM_CLASS_AXE == eICR || ITEM_CLASS_MACE == eICR || ITEM_CLASS_SPEAR == eICR)
			deathState = PSD_KNOCK_DOWN;
		
		__Vector3 vTarget = pTarget->Position();
		// 퍽하고 무기 맞는 소리..
		if(pTarget->m_pSnd_Blow)
			pTarget->m_pSnd_Blow->Play(&vTarget); 

		// trigger weapon-based visual effects
		bool bAffected = false;
		if(m_pItemPlugExts[PLUG_POS_RIGHTHAND])
		{
			bAffected = TryWeaponElementEffect(PLUG_POS_RIGHTHAND, *pTarget, vCol);
		}
		if(m_pItemPlugExts[PLUG_POS_LEFTHAND] && !bAffected)
		{
			bAffected = TryWeaponElementEffect(PLUG_POS_LEFTHAND, *pTarget, vCol);
		}
		
		// if no elemental effect played, trigger the standard effect
		if(!bAffected)
			CGameProcedure::s_pFX->TriggerBundle(pTarget->IDNumber(), 0, FXID_BLOOD, vCol);

		__Vector3 vDirDeath = this->Position() - vTarget;
		vDirDeath.Normalize();
		pTarget->ActionDying(deathState, vDirDeath);
	}
	else if(pTarget->IsAlive())
	{
		// if the target failed to defend, process hit
		if(!pTarget->m_bGuardSuccess)
		{
			__Vector3 vTarget = pTarget->Position();

			// play on-hit sound effect
			if(pTarget->m_pSnd_Blow)
				pTarget->m_pSnd_Blow->Play(&vTarget);

			// trigger weapon-based visual effects
			bool bAffected = false;
			if(m_pItemPlugExts[PLUG_POS_RIGHTHAND])
			{
				bAffected = TryWeaponElementEffect(PLUG_POS_RIGHTHAND, *pTarget, vCol);
			}
			if(m_pItemPlugExts[PLUG_POS_LEFTHAND] && !bAffected)
			{
				bAffected = TryWeaponElementEffect(PLUG_POS_LEFTHAND, *pTarget, vCol);
			}

			// if no elemental effect played, trigger the standard effect
			if (!bAffected) {
				CGameProcedure::s_pFX->TriggerBundle(pTarget->IDNumber(), 0, FXID_BLOOD, vCol);	//일반무기...
				//CGameProcedure::s_pFX->TriggerBundle(pTarget->IDNumber(), 0, 13000, vCol, 0, -1, N3FORMAT_VER_2062);
			}

			D3DCOLORVALUE crHit = { 1.0f, 0.2f, 0.2f, 1.0f };
			pTarget->DurationColorSet(crHit, 0.3f);

//				int iRand = rand()%2; // 얻어 맞아 신음 소리..
//				if(iRand == 0) { if(pTarget->m_pSnd_Struck_0) pTarget->m_pSnd_Struck_0->Play(&vTarget); }
//				else if(iRand == 1) { if(pTarget->m_pSnd_Struck_1) pTarget->m_pSnd_Struck_1->Play(&vTarget); }
			if(pTarget->m_pSnd_Struck_0)
				pTarget->m_pSnd_Struck_0->Play(&vTarget);

			// TODO: Update this (and all of its outer logic)
			pTarget->Action(PSA_STRUCK, false);
		}
		// target successfully defended
		else 
		{
			// pTarget->Action(PSA_GUARD, false);
		}
	}

	return bAttackSuccess;
}

/// \brief applies any on-hit elemental effects associated with a weapon
bool CPlayerBase::TryWeaponElementEffect(e_PlugPosition plugPosition, const CPlayerBase& target, __Vector3 collisionPosition)
{
	bool affected = false;
	// only process for weapons
	if (plugPosition != PLUG_POS_LEFTHAND
		&& plugPosition != PLUG_POS_RIGHTHAND)
	{
		return affected;
	}
	int iFXID = -1;
	if((m_pItemPlugExts[plugPosition]->byMagicOrRare==ITEM_ATTRIB_UNIQUE
		&& m_pItemPlugExts[plugPosition]->byDamageFire > 0)
		|| m_pItemPlugExts[plugPosition]->byDamageFire >= LIMIT_FX_DAMAGE)
		iFXID = FXID_SWORD_FIRE_TARGET;
	else if((m_pItemPlugExts[plugPosition]->byMagicOrRare==ITEM_ATTRIB_UNIQUE
		&& m_pItemPlugExts[plugPosition]->byDamageIce > 0)
		|| m_pItemPlugExts[plugPosition]->byDamageIce >= LIMIT_FX_DAMAGE)
		iFXID = FXID_SWORD_ICE_TARGET;
	else if((m_pItemPlugExts[plugPosition]->byMagicOrRare==ITEM_ATTRIB_UNIQUE
		&& m_pItemPlugExts[plugPosition]->byDamagePoison > 0)
		|| m_pItemPlugExts[plugPosition]->byDamagePoison >= LIMIT_FX_DAMAGE)
		iFXID = FXID_SWORD_POISON_TARGET;
	else if((m_pItemPlugExts[plugPosition]->byMagicOrRare==ITEM_ATTRIB_UNIQUE
		&& m_pItemPlugExts[plugPosition]->byDamageThuner > 0)
		|| m_pItemPlugExts[plugPosition]->byDamageThuner >= LIMIT_FX_DAMAGE)
		iFXID = FXID_SWORD_LIGHTNING_TARGET;

	if(iFXID >= 0)
	{
		affected = true;
		CGameProcedure::s_pFX->TriggerBundle(target.IDNumber(), 0, iFXID, collisionPosition);
	}

	return affected;
}

e_Ani CPlayerBase::JudgeAnimationAttack()
{
	e_Ani eAni = ANI_BREATH;

	if(RACE_NPC == m_InfoBase.eRace) // NPC 일경우 
	{
		eAni = (e_Ani)(ANI_NPC_ATTACK0 + rand()%2);
	}
	else // 플레이어 일경우..
	{
		if(-1 != m_iIDTarget) // 타겟이 있으면..
		{
			e_ItemClass eICR = this->ItemClass_RightHand(); // 오른손 무기에 따라서..
			if(ITEM_CLASS_STAFF == eICR) // 지팡이 일경우 창 공격으로 한다. ???
			{
				eAni = ANI_DAGGER_ATTACK_A0;
			}
			else
			{
				eAni = (e_Ani)(this->JudgeAnimationBreath() + 1 + rand()%2);
			}
		}
	}

	return eAni;
}

e_Ani CPlayerBase::JudgeAnimationBreath()
{
	e_Ani eAni = ANI_BREATH;

	if(RACE_NPC == m_InfoBase.eRace) // NPC 일경우 
	{
		if(rand()%10 != 0) eAni = ANI_NPC_BREATH;
		else eAni = (e_Ani)(ANI_NPC_TALK0 + rand()%4);
	}
	else // 플레이어 일경우..
	{
		CPlayerBase* pTarget = TargetPointerCheck(false);

		// 타겟이 있고 국가가 다르면..
		if (pTarget != nullptr
			&& IsHostileTarget(pTarget))
		{
			e_ItemClass eICR = this->ItemClass_RightHand();
			e_ItemClass eICL = this->ItemClass_LeftHand();

			float fIWR = 0; // , fIWL = 0; // Item Weight RightHand, LeftHand
			if(m_pItemPlugBasics[PLUG_POS_RIGHTHAND]) fIWR = m_pItemPlugBasics[PLUG_POS_RIGHTHAND]->siWeight / 10.f;
//			if(m_pItemPlugBasics[PLUG_POS_LEFTHAND]) fIWL = m_pItemPlugBasics[PLUG_POS_LEFTHAND]->siWeight / 10.f;

			if(	(ITEM_CLASS_SWORD == eICR && ITEM_CLASS_SWORD == eICL) ||
				(ITEM_CLASS_AXE == eICR && ITEM_CLASS_AXE == eICL) ||
				(ITEM_CLASS_SWORD == eICR && ITEM_CLASS_AXE == eICL) ||
				(ITEM_CLASS_AXE == eICR && ITEM_CLASS_SWORD == eICL) )
			{
				if(ITEM_CLASS_SWORD == eICR) // 오른손 기준으로 무기 무게 판단..
				{
					if(fIWR < WEAPON_WEIGHT_STAND_SWORD) eAni = ANI_DUAL_BREATH_A;
					else eAni = ANI_DUAL_BREATH_B;
				}
				else // if(ITEM_CLASS_AXE == eICR) // 오른손 기준으로 무기 무게 판단..
				{
					if(fIWR < WEAPON_WEIGHT_STAND_AXE) eAni = ANI_DUAL_BREATH_A;
					else eAni = ANI_DUAL_BREATH_B;
				}
			}
			else if(ITEM_CLASS_DAGGER == eICR) // 단검
				eAni = ANI_DAGGER_BREATH_A;
			else if(ITEM_CLASS_SWORD == eICR) // 걍 보통칼
			{
				if(fIWR < WEAPON_WEIGHT_STAND_SWORD) eAni = ANI_SWORD_BREATH_A;
				else eAni = ANI_SWORD_BREATH_B;
			}
			else if(ITEM_CLASS_SWORD_2H == eICR) // 양수검
				eAni = ANI_SWORD2H_BREATH_A;
			else if(ITEM_CLASS_AXE == eICR)
			{
				if(fIWR < WEAPON_WEIGHT_STAND_AXE) eAni = ANI_AXE_BREATH_A;
				else eAni = ANI_AXE_BREATH_B;
			}
			else if(ITEM_CLASS_AXE_2H == eICR || ITEM_CLASS_MACE_2H == eICR) // 양손 도끼 혹은 둔기..
				eAni = ANI_BLUNT2H_BREATH_A; 
			else if(ITEM_CLASS_MACE == eICR)
			{
				if(fIWR < WEAPON_WEIGHT_STAND_BLUNT) eAni = ANI_BLUNT_BREATH_A;
				else eAni = ANI_BLUNT_BREATH_B;
			}
			else if(ITEM_CLASS_SPEAR == eICR) // 창
				eAni = ANI_SPEAR_BREATH_A;
			else if(ITEM_CLASS_POLEARM == eICR)
				eAni = ANI_POLEARM_BREATH_A; 
			else if(eICR == ITEM_CLASS_UNKNOWN && eICL == ITEM_CLASS_BOW) // 왼손 장착하는 활..
				eAni = ANI_BOW_BREATH;
			else if(eICR == ITEM_CLASS_BOW_CROSS && eICL == ITEM_CLASS_UNKNOWN) // 오른손 장착하는 석궁..
				eAni = ANI_CROSS_BOW_BREATH;
			else if(eICR == ITEM_CLASS_LAUNCHER && eICL >= ITEM_CLASS_UNKNOWN) // 오른손 장착하는 창 런처..
				eAni = ANI_LAUNCHER_BREATH;
			else if(eICR == ITEM_CLASS_UNKNOWN && eICL >= ITEM_CLASS_SHIELD) // 왼손 장착하는 방패..
			{
				eAni = ANI_SHIELD_BREATH_A;
			}
			else if(eICR == ITEM_CLASS_STAFF) // 지팡이..
			{
				eAni = ANI_BREATH; // 걍숨쉰다..
			}
			else // 무기 없다..
			{
				eAni = ANI_NAKED_BREATH_A;
			}
		}
		else
		{
			eAni = ANI_BREATH;
		}
	}

	return eAni;
}

e_Ani CPlayerBase::JudgeAnimationWalk() // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
{
	e_Ani eAni = ANI_WALK;

	if(RACE_NPC == m_InfoBase.eRace) // NPC 일경우 
	{
		eAni = ANI_NPC_WALK; 
	}
	else // 플레이어 일경우..
	{
		eAni = ANI_WALK; // 이 자리에 가진 무기에 따라 다른 에니메이션을 판단한다.
	}

	return eAni;
}

e_Ani CPlayerBase::JudgeAnimationRun() // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
{
	e_Ani eAni = ANI_RUN;

	if(RACE_NPC == m_InfoBase.eRace) // NPC 일경우 
	{
		eAni = ANI_NPC_RUN; 
	}
	else // 플레이어 일경우..
	{
		eAni = ANI_RUN; // 이 자리에 가진 무기에 따라 다른 에니메이션을 판단한다.
	}

	return eAni;
}

e_Ani CPlayerBase::JudgeAnimationWalkBackward() // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
{
	e_Ani eAni = ANI_WALK_BACKWARD;

	if(RACE_NPC == m_InfoBase.eRace) // NPC 일경우 
	{
		eAni = ANI_NPC_WALK_BACKWARD; 
	}
	else // 플레이어 일경우..
	{
		eAni = ANI_WALK_BACKWARD; // 이 자리에 가진 무기에 따라 다른 에니메이션을 판단한다.
	}

	return eAni;
}

e_Ani CPlayerBase::JudgeAnimationStruck()
{
	if(RACE_NPC == m_InfoBase.eRace) return (e_Ani)(ANI_NPC_STRUCK0 + rand()%3); // NPC 일경우 
	else return (e_Ani)(ANI_STRUCK0 + rand()%3); // 플레이어 일경우..
}

e_Ani CPlayerBase::JudgeAnimationGuard()
{
	if(RACE_NPC == m_InfoBase.eRace) return ANI_NPC_GUARD; // NPC 일경우 
	else return ANI_GUARD; // 플레이어 일경우..
}

e_Ani CPlayerBase::JudgeAnimationDying()
{
	if(RACE_NPC == m_InfoBase.eRace) return (e_Ani)(ANI_NPC_DEAD0); // NPC 일경우 
	else return (e_Ani)(ANI_DEAD_NEATLY + rand()%3); // 플레이어 일경우..
}

e_Ani CPlayerBase::JudgetAnimationSpellMagic()
{
	if(RACE_NPC == m_InfoBase.eRace) return (e_Ani)(m_iMagicAni); // NPC 일경우 
	else return (e_Ani)(m_iMagicAni); // 플레이어 일경우..
}

bool CPlayerBase::CheckCollisionByBox(const __Vector3& v0, const __Vector3& v1, __Vector3* pVCol, __Vector3* pVNormal)
{
	CN3VMesh* pvMesh = m_Chr.CollisionMesh();
	if(pvMesh == nullptr)
		return false;
	return pvMesh->CheckCollision(m_Chr.m_Matrix, v0, v1, pVCol, pVNormal);
}

bool CPlayerBase::CheckCollisionToTargetByPlug(CPlayerBase* pTarget, int nPlug, __Vector3* pVCol)
{
	if(pTarget == nullptr)
		return false;
	
	// requires an equipped weapon
	CN3CPlug* pPlug = m_Chr.Plug(nPlug);
	if(pPlug == nullptr)
		return false;
	
	// berserk
	//	if(pPlug->m_ePlugType == PLUGTYPE_CLOAK)	return false;
	//	CN3CPlug *pPlugNormal = (CN3CPlug*)pPlug;
	//	if(pPlugNormal->m_fTrace0 >= pPlugNormal->m_fTrace1) return false; // 무기의 길이 정보가 없거나 이상하면 충돌체크 하지 않는다.
	
	// "If there is no information about the length of the weapon or if it is strange, do not check for collisions."
	if(pPlug->m_fTrace0 >= pPlug->m_fTrace1)
		return false;
	// do not check for collision against dead targets
	if(PSA_DYING == pTarget->State() || PSA_DEATH == pTarget->State())
		return false;

	////////////////////////////////////////////////////////////////////////
	// 칼 궤적이 남는 시점이 아니면 충돌체크를 하지 않는다.
	//	__AnimData* pAni = m_Chr.AniCur(0);
	//	if(nullptr == pAni) return false;
	//	float fFrmCur = m_Chr.FrmCur(0);
	//	if(fFrmCur < pAni->fFrmPlugTraceStart || fFrmCur > pAni->fFrmPlugTraceEnd) return false; 
	// 칼 궤적이 남는 시점이 아니면 충돌체크를 하지 않는다.
	////////////////////////////////////////////////////////////////////////

	__Vector3 v1, v2;
	__Matrix44 mtx = *(m_Chr.MatrixGet(pPlug->m_nJointIndex));
	
	v1.Set( 0.0f, pPlug->m_fTrace0, 0.0f );
	v2.Set( 0.0f, pPlug->m_fTrace1, 0.0f );

	v1 *= pPlug->m_Matrix;
	v1 *= mtx;
	v1 *= m_Chr.m_Matrix;

	v2 *= pPlug->m_Matrix;
	v2 *= mtx;
	v2 *= m_Chr.m_Matrix;

	// 길이를 두배로 = "double the length", but we're multiplying by 1
	v2 += (v2 - v1)*1.0f; 

#ifdef _DEBUG
	s_lpD3DDev->BeginScene();

	__Vector3 vLines[2] = { v1, v2 };
	__Matrix44 mtxTmp; mtxTmp.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxTmp.toD3D());
	RenderLines(vLines, 1, (D3DCOLOR)0xffff8080); // 선을 그려본다..

	if(m_pShapeExtraRef && m_pShapeExtraRef->CollisionMesh())
	{
		s_lpD3DDev->SetTransform(D3DTS_WORLD, m_pShapeExtraRef->m_Matrix.toD3D());
		m_pShapeExtraRef->CollisionMesh()->Render((D3DCOLOR)0xffff0000); // 충돌 박스를 그려본다.
	}
	s_lpD3DDev->EndScene();
	s_lpD3DDev->Present(nullptr, nullptr, s_hWndBase, nullptr);
#endif

	if(m_pShapeExtraRef && m_pShapeExtraRef->CollisionMesh())
	{
		CN3VMesh* pVMesh = m_pShapeExtraRef->CollisionMesh();
		if(pVMesh)
		{
			return pVMesh->CheckCollision(m_pShapeExtraRef->m_Matrix, v1, v2, pVCol);
		}
	}

	// check if the target's mesh collides with the bounds created from our plug
	return pTarget->CheckCollisionByBox(v1, v2, pVCol, nullptr);	
}

CN3CPlugBase* CPlayerBase::PlugSet(e_PlugPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt)
{
	if(ePos < PLUG_POS_RIGHTHAND || ePos >= PLUG_POS_COUNT)
	{
		__ASSERT(0, "Invalid Plug Position");
		return nullptr;
	}

	int iJoint = 0;
	if(PLUG_POS_RIGHTHAND == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
		iJoint = m_pLooksRef->iJointRH;
	}
	else if(PLUG_POS_LEFTHAND == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
		if(pItemBasic)
		{
			if(pItemBasic->byClass == ITEM_CLASS_SHIELD) iJoint = m_pLooksRef->iJointLH2; // 방패인 경우
			else iJoint = m_pLooksRef->iJointLH; // 왼손 끝..
		}
	}
	else if(PLUG_POS_KNIGHTS_GRADE == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
	}
	else if (PLUG_POS_BACK == ePos)
	{
		//m_pItemPlugBasics[PLUG_POS_BACK] = pItem;
	}
	else { __ASSERT(0, "Invalid Plug Item position"); }


	CN3CPlugBase* pPlug = m_Chr.PlugSet(ePos, szFN);
	if(nullptr == pPlug) return nullptr;

	if (PLUG_POS_LEFTHAND == ePos || PLUG_POS_RIGHTHAND == ePos)
	{
		float fScale = m_Chr.Height() / 1.8f;  // 키에 비례해서 크게 키운다. 기본키는 1.8 미터이다.
		fScale *= pPlug->Scale().y / m_Chr.Scale().y;
		pPlug->ScaleSet(__Vector3(fScale, fScale, fScale));
		pPlug->m_nJointIndex = iJoint; // 붙는 위치 정하기..
	}
//	else if(PLUG_POS_BACK == ePos)
//	{
//		CN3CPlug_Cloak *pPlugCloak = (CN3CPlug_Cloak*)pPlug;
//	}

	if(pPlug && nullptr == pItemBasic && nullptr == pItemExt) pPlug->TexOverlapSet(""); // 기본 착용이면..

	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
	// plug 효과 붙여라..^^	
	if(pItemExt)
	{
		if((pItemExt->byMagicOrRare==ITEM_ATTRIB_UNIQUE && pItemExt->byDamageFire > 0) || (pItemExt->byDamageFire >= LIMIT_FX_DAMAGE)) // 17 추가데미지 - 불
		{
			CN3CPlug* pCPlug = (CN3CPlug*)pPlug;
			__TABLE_FX* pFXMain = s_pTbl_FXSource.Find(FXID_SWORD_FIRE_MAIN);
			__TABLE_FX* pFXTail = s_pTbl_FXSource.Find(FXID_SWORD_FIRE_TAIL);
			
			std::string szFXMain, szFXTail;
			if(pFXMain) szFXMain = pFXMain->szFN;
			else szFXMain = "";
			if(pFXTail) szFXTail = pFXTail->szFN;
			else szFXTail = "";
			pCPlug->InitFX(szFXMain, szFXTail, 0xffffff00);
		}
		else if((pItemExt->byMagicOrRare==ITEM_ATTRIB_UNIQUE && pItemExt->byDamageIce > 0) || (pItemExt->byDamageIce >= LIMIT_FX_DAMAGE))// 18 추가데미지 - 얼음
		{
			CN3CPlug* pCPlug = (CN3CPlug*)pPlug;
			__TABLE_FX* pFXMain = s_pTbl_FXSource.Find(FXID_SWORD_ICE_MAIN);
			__TABLE_FX* pFXTail = s_pTbl_FXSource.Find(FXID_SWORD_ICE_TAIL);
			
			std::string szFXMain, szFXTail;
			if(pFXMain) szFXMain = pFXMain->szFN;
			else szFXMain = "";
			if(pFXTail) szFXTail = pFXTail->szFN;
			else szFXTail = "";

			pCPlug->InitFX(szFXMain, szFXTail, 0xff0000ff);
		}
		else if((pItemExt->byMagicOrRare==ITEM_ATTRIB_UNIQUE && pItemExt->byDamageThuner > 0) || (pItemExt->byDamageThuner >= LIMIT_FX_DAMAGE))// 19 추가데미지 - 전격			
		{
			CN3CPlug* pCPlug = (CN3CPlug*)pPlug;
			__TABLE_FX* pFXMain = s_pTbl_FXSource.Find(FXID_SWORD_LIGHTNING_MAIN);
			__TABLE_FX* pFXTail = s_pTbl_FXSource.Find(FXID_SWORD_LIGHTNING_TAIL);
			
			std::string szFXMain, szFXTail;
			if(pFXMain) szFXMain = pFXMain->szFN;
			else szFXMain = "";
			if(pFXTail) szFXTail = pFXTail->szFN;
			else szFXTail = "";
			
			pCPlug->InitFX(szFXMain, szFXTail, 0xffffffff);
		}
		else if((pItemExt->byMagicOrRare==ITEM_ATTRIB_UNIQUE && pItemExt->byDamagePoison > 0) || (pItemExt->byDamagePoison >= LIMIT_FX_DAMAGE))// 20 추가데미지 - 독			
		{
			CN3CPlug* pCPlug = (CN3CPlug*)pPlug;
			__TABLE_FX* pFXMain = s_pTbl_FXSource.Find(FXID_SWORD_POISON_MAIN);
			__TABLE_FX* pFXTail = s_pTbl_FXSource.Find(FXID_SWORD_POISON_TAIL);

			std::string szFXMain, szFXTail;
			if(pFXMain) szFXMain = pFXMain->szFN;
			else szFXMain = "";
			if(pFXTail) szFXTail = pFXTail->szFN;
			else szFXTail = "";
			
			pCPlug->InitFX(szFXMain, szFXTail, 0xffff00ff);
		}
	}
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////

	return pPlug;
}

CN3CPart* CPlayerBase::PartSet(e_PartPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt)
{
	if(ePos < PART_POS_UPPER || ePos >= PART_POS_COUNT)
	{
		__ASSERT(0, "Invalid Item Position");
		return nullptr;
	}

	if(PART_POS_UPPER == ePos) // 상체일 경우 특별한 처리가 필요..
	{
		if(pItemBasic) // 입히는 경우
		{
			if(pItemBasic->byIsRobeType && m_Chr.Part(PART_POS_LOWER)) // 로브 타입의 통짜 윗옷이고 아래에 뭔가 입고 있으면..
			{
				this->PartSet(PART_POS_LOWER, "", m_pItemPartBasics[PART_POS_LOWER], m_pItemPartExts[PART_POS_LOWER]); // 아래를 비워준다..
			}
		}
		else // 상체를 벗는 경우
		{
			if(m_pItemPartBasics[ePos] && m_pItemPartBasics[ePos]->byIsRobeType) // 전에 착용했던게 로브면..
			{
				if(m_pItemPartBasics[PART_POS_LOWER]) // 하체에 아이템이 입혀있으면..
				{
					std::string szFN2;
					e_PartPosition ePartPos2 = PART_POS_UNKNOWN;
					e_PlugPosition ePlugPos2 = PLUG_POS_UNKNOWN;

					MakeResrcFileNameForUPC(m_pItemPartBasics[PART_POS_LOWER], m_pItemPartExts[PART_POS_LOWER], &szFN2, nullptr, ePartPos2, ePlugPos2, m_InfoBase.eRace);
					this->PartSet(PART_POS_LOWER, szFN2, m_pItemPartBasics[PART_POS_LOWER], m_pItemPartExts[PART_POS_LOWER]); // 하체에 전의 옷을 입힌다..
				}
				else // 하체에 입고 있었던 아이템이 없다면..
				{
					__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..
					this->PartSet(PART_POS_LOWER, pLooks->szPartFNs[PART_POS_LOWER], nullptr, nullptr); // 하체에 기본옷을 입힌다.
				}
			}
		}
	}
	else if(PART_POS_LOWER == ePos) // 하체일 경우..
	{
		if(pItemBasic) // 착용하는 경우
		{
			if(m_pItemPartBasics[PART_POS_UPPER] && m_pItemPartBasics[PART_POS_UPPER]->byIsRobeType) // 전에 상체에 착용했던게 로브면..
			{
				m_pItemPartBasics[ePos] = pItemBasic;
				m_pItemPartExts[ePos] = pItemExt;
				return m_Chr.PartSet(ePos, ""); // 하체는 벗기고(?) 돌아간다.
			}
		}
	}

	CN3CPart* pPart = nullptr;
	if(szFN.empty()) // 파일 이름이 없는거면.. 기본 착용..
	{
		if(PART_POS_HAIR_HELMET == ePos)
		{
			this->InitHair();
			pPart = m_Chr.Part(ePos);
		}
		else if(PART_POS_FACE == ePos)
		{
			this->InitFace();
			pPart = m_Chr.Part(ePos);
		}
		else
		{
			__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);	// Player Character Skin 구조체 포인터..
			if(pLooks)
			{
				pPart = m_Chr.PartSet(ePos, pLooks->szPartFNs[ePos]);
				if(pPart) pPart->TexOverlapSet("");
			}
		}
	}
	else
	{
		pPart = m_Chr.PartSet(ePos, szFN);
	}

	m_pItemPartBasics[ePos] = pItemBasic; // 아이템 적용
	m_pItemPartExts[ePos] = pItemExt;

	if(pPart && nullptr == pItemBasic && nullptr == pItemExt) pPart->TexOverlapSet(""); // 기본 착용이면..

	return pPart;
}

void CPlayerBase::DurabilitySet(e_ItemSlot eSlot, int iDurability)
{
	e_PartPosition ePartPos = PART_POS_UNKNOWN;

	if(ITEM_SLOT_HAND_RIGHT == eSlot || ITEM_SLOT_HAND_LEFT == eSlot)
	{
		e_PlugPosition ePos = PLUG_POS_LEFTHAND;
		if(ITEM_SLOT_HAND_RIGHT == eSlot) ePos = PLUG_POS_RIGHTHAND;
		if(nullptr == m_pItemPlugBasics[ePos] || nullptr == m_pItemPlugExts[ePos])
		{
			if(0 != iDurability)
			{
				__ASSERT(0, "NULL Item");
			}
			return;
		}

		int iDuMax = m_pItemPlugBasics[ePos]->siMaxDurability + m_pItemPlugExts[ePos]->siMaxDurability;
		if(iDuMax <= 0)
		{
			__ASSERT(0, "최대 내구력 없음");
			return;
		}

		CN3CPlug* pPlug = m_Chr.Plug(ePos);
		if(nullptr == pPlug) 
		{
			__ASSERT(0, "NULL Plug");
			return;
		}

		int iPercentage = iDurability * 100 / iDuMax;
		std::string szFN;
		if(iPercentage <= 30) szFN = "Misc\\Dust_Hard.dxt";
		else if(iPercentage <= 70) szFN = "Misc\\Dust_Soft.dxt";

		pPlug->TexOverlapSet(szFN);
	}
	else if(ITEM_SLOT_UPPER == eSlot) ePartPos = PART_POS_UPPER;
	else if(ITEM_SLOT_LOWER == eSlot) ePartPos = PART_POS_LOWER;
	else if(ITEM_SLOT_GLOVES == eSlot) ePartPos = PART_POS_HANDS;
	else if(ITEM_SLOT_SHOES == eSlot) ePartPos = PART_POS_FEET;
	else if(ITEM_SLOT_HEAD == eSlot) ePartPos = PART_POS_HAIR_HELMET;

	if(PART_POS_UNKNOWN != ePartPos)
	{
		CN3CPart* pPart = m_Chr.Part(ePartPos);
		if(pPart)
		{
			if(m_pItemPartBasics[ePartPos] && m_pItemPartExts[ePartPos])
			{
				int iDuMax = m_pItemPartBasics[ePartPos]->siMaxDurability + m_pItemPartExts[ePartPos]->siMaxDurability; // 기본내구력 + 확장 내구력
				int iPercentage = iDurability * 100 / iDuMax;
			
				std::string szFN;
				if(iPercentage <= 30) szFN = "Misc\\Dust_Hard.dxt";
				else if(iPercentage <= 70) szFN = "Misc\\Dust_Soft.dxt";
				pPart->TexOverlapSet(szFN);
			}
			else
			{
				pPart->TexOverlapSet("");
			}
		}
		else
		{
			__ASSERT(0, "Invalid Item Position");
		}
	}
}

bool CPlayerBase::InitChr(__TABLE_PLAYER_LOOKS* pTbl)
{
	if (pTbl == nullptr)
		return false;

	m_pLooksRef = pTbl;

	if (!pTbl->szChrFN.empty())
	{
		__Vector3 vPos = Position();
		m_Chr.LoadFromFile(pTbl->szChrFN);
		m_Chr.PosSet(vPos);
	}
	else
	{
		m_Chr.JointSet(pTbl->szJointFN);
		m_Chr.AniCtrlSet(pTbl->szAniFN);

		// 상,하체 따로 놀 준비..
		if (RACE_NPC != m_InfoBase.eRace)
		{
			m_Chr.JointPartSet(0, 16, 23); // 하체
			m_Chr.JointPartSet(1, 1, 15); // 상체
		}

		if (!pTbl->szFXPlugFN.empty())
			m_Chr.FXPlugSet(pTbl->szFXPlugFN);
	}

	return true;
}


void CPlayerBase::RegenerateCollisionMesh() // 최대 최소값을 다시 찾고 충돌메시를 다시 만든다..
{
	m_Chr.RegenerateCollisionMesh();
}

CPlayerBase* CPlayerBase::TargetPointerCheck(bool bMustAlive)
{
	CPlayerBase* pTarget = this->CharacterGetByID(m_iIDTarget, bMustAlive);
//	if(pTarget && (PSA_DEATH == pTarget->State())) pTarget = nullptr; //픽킹에 의해서 선택된 캐릭을 중간의 임의적으로 수정 못하게 막음

//	if(nullptr == pTarget) { m_iIDTarget = -1; }
	return pTarget;
}

bool CPlayerBase::JointPosGet(int nJointIdx, __Vector3& vPos)
{
	const __Matrix44* pMtx = m_Chr.MatrixGet(nJointIdx);
	if(!pMtx) return false;

	vPos = pMtx->Pos();
	vPos *= m_Chr.m_Matrix;

	return true;
}

void CPlayerBase::AnimationAdd(e_Ani eAni, bool bImmediately)
{
	if(bImmediately)
	{
		this->AnimationClear(); // 데크에서 지우고..
		m_Chr.AniCurSet(eAni); // 바로 세팅..
	}
	else
	{
		m_AnimationDeque.push_back(eAni);
	}
}

const __Matrix44 CPlayerBase::CalcShadowMtxBasicPlane(__Vector3 vOffs)
{
	__Matrix44	mtx;	
	mtx.Identity();

	mtx.m[1][0] = -vOffs.x/vOffs.y;
	mtx.m[1][1] = 0.0f;
	mtx.m[1][2] = -vOffs.z/vOffs.y;

	mtx.m[3][0]	= vOffs.x/vOffs.y;
	mtx.m[3][1]	= 1.0f;
	mtx.m[3][2]	= vOffs.z/vOffs.y;

	return mtx;
}

void CPlayerBase::RenderShadow(float fAngle)
{
	if(nullptr == m_Chr.Joint()) return;
	if(m_Chr.m_nLOD < 0 || m_Chr.m_nLOD > MAX_CHR_LOD) return;
	
	int iLODTemp = m_Chr.m_nLOD; // 그림자는 부하를 적게 줄여 찍는다..
	iLODTemp += 2;
	if(iLODTemp >= MAX_CHR_LOD) return;

	__Matrix44 mV, mVvar, mVBack, mtxRotX, mtxRotZ;	mV.Identity(); 
	__Vector3 vPosBack, vNom;
	CN3Base::s_lpD3DDev->GetTransform(D3DTS_WORLD, (_D3DMATRIX* )&mVBack); 
	vPosBack = m_Chr.m_Matrix.Pos();	
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mV.toD3D());
	ACT_WORLD->GetNormalWithTerrain(vPosBack.x, vPosBack.z, vNom);	vNom.Normalize();

	mV.PosSet(0.0f, 0.0f, 0.0f);
	float fXRad, fZRad;
	fZRad = asin(vNom.z);
	mtxRotZ.RotationX(fZRad);
	fXRad = asin(-vNom.x);
	mtxRotX.RotationZ(fXRad);
	mV *= mtxRotX;
	mV *= mtxRotZ;
	vPosBack.y += 0.1f;

	mV.PosSet(vPosBack);
	mVvar = mV;

	for( int i = 0; i < SHADOW_SIZE; i++ )
		m_bitset[i].Resize(SHADOW_SIZE);

	for ( int i = 0; i < 4; i++ )
	{
		m_vTVertex[i]  = m_pvVertex[i];	
		m_vTVertex[i] *= mV;
	}

	// 캐릭터의 크기에 따라 스캐일링 한다..
	float fScale = Height() * Radius();
	m_fShaScale = 1.0f;
	__Matrix44 mtPos;	mtPos.Identity(); mtPos.PosSet(mV.Pos());
	if (fScale > 6.6f)
	{
		m_fShaScale = 2.2f;
		for ( int i = 0; i < 4; i++ )
		{
			m_vTVertex[i]  = m_pvVertex[i];	
			m_vTVertex[i] *= m_fShaScale;
			m_vTVertex[i] *= mtPos;
		}
	}
	else
	{
		for ( int i = 0; i < 4; i++ )
		{
			m_vTVertex[i]  = m_pvVertex[i];	
			m_vTVertex[i] *= mtPos;
		}
	}

	// 태양 위치를 제대로 계산해서 넣기만 하면 된다..
	if ( (fAngle < 4.0f) || (fAngle > 6.1f) )
	{
		if (fAngle > 3.14f)
		{
			fAngle -= 3.14f;
			fAngle = 3.14f - fAngle;
		}
	}
	float fAngleDeg = RadiansToDegrees(fAngle);

	float zVal = s_vLightOffset.Magnitude();
	int iDiv = (int)((int)fAngleDeg)%((int)(180));
	fAngleDeg = (float)iDiv;

	if ( (fAngleDeg >= 0.0f) && (fAngleDeg < 50.0f) )
		fAngleDeg = 50.0f;
	else if ( (fAngleDeg > 130.0f) && (fAngleDeg <= 180.0f) )
		fAngleDeg = 130.0f;

	__Matrix44 mtxRZ; mtxRZ.RotationZ(DegreesToRadians(fAngleDeg));
	__Vector3 vLP; vLP.Set(-zVal, 0.0f, 0.0f );	vLP *= mtxRZ;	vLP.Normalize();

	int iPC = m_Chr.PartCount();
	for( int i = 0; i < iPC; i++)
	{
		CalcPart(m_Chr.Part(i), iLODTemp, vLP);
	}

	iPC = m_Chr.PlugCount();
	for(int i = 0; i < iPC; i++)
	{
		CalcPlug(m_Chr.Plug(i), m_Chr.MatrixGet(m_Chr.Plug(i)->m_nJointIndex), mVvar, vLP);
	}

	// 렌더링하기 전에 스케일을 줄인다..
	if (fScale > 6.6f)
	{
		for ( int i = 0; i < 4; i++ )
		{
			m_vTVertex[i]  = m_pvVertex[i];	
			m_vTVertex[i] *= 0.82f;	
			m_vTVertex[i] *= m_fShaScale;
			m_vTVertex[i] *= mV;
		}
	}
	else
	{
		for ( int i = 0; i < 4; i++ )
		{
			m_vTVertex[i]  = m_pvVertex[i];	
			m_vTVertex[i] *= 0.5f;	
			m_vTVertex[i] *= mV;
		}
	}

	D3DLOCKED_RECT LR;
	if (!m_N3Tex.Get()) return;
	HRESULT hr = m_N3Tex.Get()->LockRect(0, &LR, 0, 0); 
	if (hr != D3D_OK)
		return;

	LPWORD pDst16 = (LPWORD)LR.pBits;
	uint16_t dwColor = SHADOW_COLOR;
	dwColor = dwColor << 12;
	for( int i = 0; i < SHADOW_SIZE; i++ )
	{
		for(int j = 0; j < SHADOW_SIZE; j++ )
		{
			if (m_bitset[i].On(j))
				pDst16[SHADOW_SIZE*i+j] = dwColor;
			else
				pDst16[SHADOW_SIZE*i+j] = 0x0000;
		}
	}

	m_N3Tex.Get()->UnlockRect(0);
 
	DWORD dwAlpha, dwFog, dwCull, dwColorVertex, dwMaterial, dwZWrite,
		dwColorOp0, dwColorArg01, dwColorArg02, dwColorOp1, dwColorArg11, dwColorArg12, 
		dwAlphaOp0, dwAlphaArg01, dwAlphaArg02, dwAlphaOp1, dwAlphaArg11, dwAlphaArg12, dwSrcBlend, dwDestBlend, dwBlendOp,
		dwMagFilter0, dwMinFilter0, dwMagFilter1, dwMinFilter1;

	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_CULLMODE, &dwCull);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_COLORVERTEX, &dwColorVertex);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, &dwMaterial);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZWRITEENABLE, &dwZWrite);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwColorOp0);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorArg01);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG2, &dwColorArg02);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLOROP, &dwColorOp1);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG1, &dwColorArg11);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_COLORARG2, &dwColorArg12);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAlphaOp0);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAlphaArg01);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG2, &dwAlphaArg02);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_ALPHAOP, &dwAlphaOp1);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_ALPHAARG1, &dwAlphaArg11);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_ALPHAARG2, &dwAlphaArg12);
	/*
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_MAGFILTER, &dwMagFilter0);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_MINFILTER, &dwMinFilter0);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_MAGFILTER, &dwMagFilter1);
	CN3Base::s_lpD3DDev->GetTextureStageState(1, D3DTSS_MINFILTER, &dwMinFilter1);
	*/
	CN3Base::s_lpD3DDev->GetSamplerState(0, D3DSAMP_MAGFILTER, &dwMagFilter0);
	CN3Base::s_lpD3DDev->GetSamplerState(0, D3DSAMP_MINFILTER, &dwMinFilter0);
	CN3Base::s_lpD3DDev->GetSamplerState(1, D3DSAMP_MAGFILTER, &dwMagFilter1);
	CN3Base::s_lpD3DDev->GetSamplerState(1, D3DSAMP_MINFILTER, &dwMinFilter1);

	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_BLENDOP, &dwBlendOp);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_COLORVERTEX, TRUE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);

	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP,  D3DTOP_MODULATE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP,  D3DTOP_MODULATE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
	CN3Base::s_lpD3DDev->SetTexture(0, m_N3Tex.Get());

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	/*
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	*/
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);

	CN3Base::s_lpD3DDev->SetFVF(FVF_VNT1);
	CN3Base::s_lpD3DDev->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, m_pIndex, D3DFMT_INDEX16, m_vTVertex, sizeof(__VertexT1) );

	//..
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwColorOp0);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwColorArg01);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG2, dwColorArg02);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLOROP, dwColorOp1);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG1, dwColorArg11);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_COLORARG2, dwColorArg12);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAlphaOp0);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAlphaArg01);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG2, dwAlphaArg02);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_ALPHAOP, dwAlphaOp1);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_ALPHAARG1, dwAlphaArg11);
	CN3Base::s_lpD3DDev->SetTextureStageState(1, D3DTSS_ALPHAARG2, dwAlphaArg12);

	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER, dwMagFilter0);
	CN3Base::s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER, dwMinFilter0);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MAGFILTER, dwMagFilter1);
	CN3Base::s_lpD3DDev->SetSamplerState(1, D3DSAMP_MINFILTER, dwMinFilter1);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_COLORVERTEX, dwColorVertex);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, dwMaterial);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZWRITEENABLE, dwZWrite);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog); 
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, dwCull);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_BLENDOP, dwBlendOp);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);

	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, (_D3DMATRIX *)&mVBack); 
}

void CPlayerBase::CalcPart(CN3CPart* pPart, int nLOD, __Vector3 vDir)
{
	if(nullptr == pPart) return;
	if(nLOD < 0 || nLOD > MAX_CHR_LOD) return;
	if(nullptr == pPart->Skins() || nullptr == pPart->Skin(nLOD) || pPart->Skin(nLOD)->VertexCount() <= 0) return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nChr_Part++; // Rendering Information Update...
	CN3Base::s_RenderInfo.nChr_Polygon += pPart->Skin(nLOD)->FaceCount();
#endif

	int iTotalCount = pPart->Skin(nLOD)->VertexCount();	
	if (iTotalCount < 0 || iTotalCount >  10000 ) return;

	__Vector3 vec, A, B, C, vPick;
	CN3Skin* part00 = pPart->Skin(nLOD);
	__VertexXyzNormal* pVDest = part00->m_pVertices;
	float t, u, v, fx, fz;

	for ( int i = 0; i < iTotalCount; i++ )
	{
		if (pVDest)
		{
			vec = pVDest[i];	
			vec *= m_Chr.m_Matrix;
			//vec.x = vec.x*m_Chr.m_Matrix.m[0][0] + vec.y*m_Chr.m_Matrix.m[1][0] + vec.z*m_Chr.m_Matrix.m[2][0] + m_Chr.m_Matrix.m[3][0];
			//vec.y = vec.x*m_Chr.m_Matrix.m[0][1] + vec.y*m_Chr.m_Matrix.m[1][1] + vec.z*m_Chr.m_Matrix.m[2][1] + m_Chr.m_Matrix.m[3][1];
			//vec.z = vec.x*m_Chr.m_Matrix.m[0][2] + vec.y*m_Chr.m_Matrix.m[1][2] + vec.z*m_Chr.m_Matrix.m[2][2] + m_Chr.m_Matrix.m[3][2];

			int iX, iZ;
			
			A = m_vTVertex[m_pIndex[0]];			B = m_vTVertex[m_pIndex[1]];			C = m_vTVertex[m_pIndex[2]];
			if (::_IntersectTriangle(vec, vDir, A, B, C, t, u, v, &vPick))
			{
				fx = (vPick.x - C.x) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				fz = (vPick.z - C.z) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				iX = (int)(fx*SHADOW_SIZE);
				iZ = (int)(fz*SHADOW_SIZE);
				if ( (iX > 0) && (iX < SHADOW_SIZE) && (iZ > 0) && (iZ < SHADOW_SIZE) )
					m_bitset[iZ].Set(iX);
			}

			A = m_vTVertex[m_pIndex[3]];			B = m_vTVertex[m_pIndex[4]];			C = m_vTVertex[m_pIndex[5]];
			if (::_IntersectTriangle(vec, vDir, A, B, C, t, u, v, &vPick))
			{
				fx = (vPick.x - B.x) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				fz = (vPick.z - B.z) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				iX = (int)(fx*SHADOW_SIZE);
				iZ = (int)(fz*SHADOW_SIZE);
				if ( (iX > 0) && (iX < SHADOW_SIZE) && (iZ > 0) && (iZ < SHADOW_SIZE) )
					m_bitset[iZ].Set(iX);
			}
		}
	}
}

void CPlayerBase::CalcPlug(CN3CPlugBase* pPlug, const __Matrix44* pmtxJoint, __Matrix44& mtxMV, __Vector3 vDir)
{
	if(nullptr == pPlug || nullptr == pPlug->PMeshInst()) return;
	if(pPlug->PMeshInst()->GetNumVertices() <= 0) return;

#ifdef _DEBUG
	CN3Base::s_RenderInfo.nChr_Plug++; // Rendering Information Update...
	CN3Base::s_RenderInfo.nChr_Plug_Polygon += pPlug->PMeshInst()->GetNumIndices() / 3; // Rendering Information Update...
#endif

	static __Matrix44 mtx, mtxBack;
	mtx = pPlug->m_Matrix;
	mtx *= (*pmtxJoint);
	mtx *= m_Chr.m_Matrix;
	
	int iTotalCount = pPlug->PMeshInst()->GetNumVertices();	
	if (iTotalCount < 0 || iTotalCount >  10000 ) return;

	__Vector3 vec, A, B, C, vPick;
	float t, u, v, fx, fz;

	__VertexT1*	pVerT1 = nullptr;
	pVerT1 = pPlug->PMeshInst()->GetVertices();

	for ( int i = 0; i < iTotalCount; i++ )
	{
		if (pVerT1)
		{
			vec = pVerT1[i];
			vec *= mtx;

			int iX, iZ;			

			A = m_vTVertex[m_pIndex[0]];			B = m_vTVertex[m_pIndex[1]];			C = m_vTVertex[m_pIndex[2]];
			if (::_IntersectTriangle(vec, vDir, A, B, C, t, u, v, &vPick))
			{
				fx = (vPick.x - C.x) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				fz = (vPick.z - C.z) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				iX = (int)(fx*SHADOW_SIZE);
				iZ = (int)(fz*SHADOW_SIZE);
				if ( (iX > 0) && (iX < SHADOW_SIZE) && (iZ > 0) && (iZ < SHADOW_SIZE) )
					m_bitset[iZ].Set(iX);
			}

			A = m_vTVertex[m_pIndex[3]];			B = m_vTVertex[m_pIndex[4]];			C = m_vTVertex[m_pIndex[5]];
			if (::_IntersectTriangle(vec, vDir, A, B, C, t, u, v, &vPick))
			{
				fx = (vPick.x - B.x) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				fz = (vPick.z - B.z) / (SHADOW_PLANE_SIZE*2.0f*m_fShaScale);
				iX = (int)(fx*SHADOW_SIZE);
				iZ = (int)(fz*SHADOW_SIZE);
				if ( (iX > 0) && (iX < SHADOW_SIZE) && (iZ > 0) && (iZ < SHADOW_SIZE) )
					m_bitset[iZ].Set(iX);
			}
		}
	}
}

__Vector3 CPlayerBase::Max()
{
	if (m_pShapeExtraRef != nullptr)
		return m_pShapeExtraRef->Max();

	return m_Chr.Max();
}

__Vector3 CPlayerBase::Min()
{
	if (m_pShapeExtraRef != nullptr)
		return m_pShapeExtraRef->Min();

	return m_Chr.Min();
}

__Vector3 CPlayerBase::Center()
{
	__Vector3 vCenter;

	if (m_pShapeExtraRef != nullptr)
	{
		vCenter = m_pShapeExtraRef->Min() + (m_pShapeExtraRef->Max() - m_pShapeExtraRef->Min()) * 0.5f;
		return vCenter;
	}

	return (m_Chr.Min() + (m_Chr.Max() - m_Chr.Min()) * 0.5f);
}

bool CPlayerBase::IsHostileTarget(const CPlayerBase* rhs) const
{
	if (rhs == nullptr)
		return false;

	if (rhs == this)
		return false;

	if (m_InfoBase.iAuthority == AUTHORITY_LIMITED_MANAGER)
		return false;

	// TODO: Tile support

	switch (GetCurrentZoneAbilityType())
	{
		case ZONE_ABILITY_SPECTATOR:
			if (rhs->PlayerType() == PLAYER_NPC
				&& rhs->Nation() != NATION_NOTSELECTED)
				return false;

			return true;

		case ZONE_ABILITY_NEUTRAL:
			if (m_InfoBase.iKnightsWarEnemyID != 0
				&& m_InfoBase.iKnightsWarEnemyID == rhs->m_InfoBase.iKnightsID)
				return true;

			if (PlayerType() != PLAYER_NPC
				&& rhs->PlayerType() != PLAYER_NPC)
				return false;

			if (Nation() != NATION_NOTSELECTED)
			{
				if (rhs->Nation() != NATION_NOTSELECTED)
					return false;
			}
			else if (rhs->Nation() != NATION_NOTSELECTED)
			{
				return false;
			}

			return true;

		case ZONE_ABILITY_PVP:
			if (m_InfoBase.iKnightsWarEnemyID != 0
				&& m_InfoBase.iKnightsWarEnemyID == rhs->m_InfoBase.iKnightsID)
				return true;

			return Nation() != rhs->Nation();

		case ZONE_ABILITY_PVP_NEUTRAL_NPCS:
			if (Nation() == rhs->Nation())
				return false;

			if (PlayerType() == PLAYER_NPC
				|| rhs->PlayerType() == PLAYER_NPC)
			{
				if (Nation() != NATION_NOTSELECTED)
				{
					if (rhs->Nation() != NATION_NOTSELECTED)
						return false;
				}
				else
				{
					if (rhs->Nation() == NATION_NOTSELECTED)
						return false;
				}
			}

			return true;

		case ZONE_ABILITY_SIEGE_TYPE_1:
			if (rhs->m_InfoBase.iKnightsID <= 0
				&& rhs->PlayerType() == PLAYER_NPC)
			{
				if (rhs->Nation() != NATION_NOTSELECTED)
					return false;
			}

			if (m_InfoBase.iKnightsID > 0
				&& m_InfoBase.iKnightsID == rhs->m_InfoBase.iKnightsID)
				return false;

			return true;

		case ZONE_ABILITY_SIEGE_TYPE_2:
			if (rhs->m_InfoBase.iKnightsID <= 0
				&& rhs->PlayerType() == PLAYER_NPC
				&& rhs->Nation() != NATION_NOTSELECTED)
				return false;

			if (m_InfoBase.iAllianceID > 0)
			{
				if (m_InfoBase.iAllianceID == rhs->m_InfoBase.iAllianceID)
					return false;
			}
			else
			{
				if (m_InfoBase.iKnightsID > 0
					&& m_InfoBase.iKnightsID == rhs->m_InfoBase.iKnightsID)
					return false;
			}

			return true;

		case ZONE_ABILITY_SIEGE_TYPE_3:
			return true;

		case ZONE_ABILITY_SIEGE_DISABLED:
			if (rhs->PlayerType() == PLAYER_NPC
				&& rhs->Nation() != NATION_NOTSELECTED)
				return false;

			if (m_InfoBase.iKnightsID > 0
				&& rhs->m_InfoBase.iKnightsID == m_InfoBase.iKnightsID)
				return false;

			return true;

		case ZONE_ABILITY_CAITHAROS_ARENA:
			if (rhs->PlayerType() == PLAYER_NPC
				&& rhs->Nation() != NATION_NOTSELECTED)
				return false;

			if (m_InfoBase.iKnightsID > 0
				&& rhs->m_InfoBase.iKnightsID == m_InfoBase.iKnightsID)
				return false;

			return true;
	}

	return true;
}

// ===== END WarFare/PlayerBase.cpp =====

// ===== BEGIN WarFare/PlayerBase.h =====
#line 1 "WarFare/PlayerBase.h"
﻿// CPlayerBase.h: interface for the CPlayerBase class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PlayerBase_H__B8B8986B_3635_462D_8C38_A052CA75B331__INCLUDED_)
#define AFX_PlayerBase_H__B8B8986B_3635_462D_8C38_A052CA75B331__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameBase.h"
#include "GameDef.h"
#include "Bitset.h"
#include <deque>
#include <string>

#include <N3Base/N3Chr.h>

//	By : Ecli666 ( On 2002-07-22 오전 9:59:19 )
//
#define SHADOW_SIZE 32			// 2의 승수만 된다..
#define SHADOW_PLANE_SIZE 4.6f	
#define SHADOW_COLOR 0xa;		// 16진수 한자리.. 알파
//	~(By Ecli666 On 2002-07-22 오전 9:59:19 )

const float TIME_CORPSE_REMAIN = 90.0f;	// 시체가 남는 시간..
const float TIME_CORPSE_REMOVE = 10.0f; // 투명해지면서 없앨시간..

class CDFont;
class CN3SndObj;

struct __InfoPlayerBase
{
	int			iID;			// 고유 ID
	std::string szID;			// 이름
	D3DCOLOR	crID;			// 이름 색깔..
	e_Race		eRace;			// 캐릭터 골격에 따른 종족
	e_Nation	eNation;		// 소속 국가..
	e_Class		eClass;			// 직업
	int			iLevel;			// 레벨
	int			iHPMax;
	int			iHP;
	int			iMP;
	int			iMPMax;
	int			iAuthority;		// 권한 - 0 관리자, 1 - 일반유저, 255 - 블럭당한 유저...
	int			iKnightsID;		// Clan ID
	int			iAllianceID;
	int			iKnightsWarEnemyID;

	bool		bRenderID;		// 화면에 ID 를 찍는지..

	void Init()
	{
		iID = 0;					// 고유 ID
		szID.clear();				// 이름
		crID = 0;					// 이름 색깔..
		eRace = RACE_UNKNOWN;		// 캐릭터 골격에 따른 종족
		eNation = NATION_UNKNOWN;	// 소속 국가..
		eClass = CLASS_UNKNOWN;		// 직업
		iLevel = 0;					// 레벨
		iHPMax = 0;
		iHP = 0;
		iMP = 0;
		iMPMax = 0;
		iAuthority = 1;				// 권한 - 0 관리자, 1 - 일반유저, 255 - 블럭당한 유저...
		iKnightsID = 0;
		iAllianceID = 0;
		iKnightsWarEnemyID = 0;
		bRenderID = true;
	}
};

class CPlayerBase : public CGameBase
{
	friend class CPlayerBase;
	friend class CPlayerOtherMgr;

protected:
	e_PlayerType				m_ePlayerType; // Player Type ... Base, NPC, OTher, MySelf
	
	std::deque<e_Ani>			m_AnimationDeque;		// 에니메이션 큐... 여기다 집어 넣으면 tick 을 돌면서 차례대로 한다..
	bool						m_bAnimationChanged;	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..

	CN3Chr						m_Chr;									// 캐릭터 기본 객체...
	__TABLE_PLAYER_LOOKS*		m_pLooksRef;							// 기본 참조 테이블 - 캐릭터에 관한 리소스 정보, 관절 위치, 사운드 파일등등..
	__TABLE_ITEM_BASIC*			m_pItemPartBasics[PART_POS_COUNT];	// 캐릭터에 붙은 무기들..
	__TABLE_ITEM_EXT*			m_pItemPartExts[PART_POS_COUNT];		// 캐릭터에 붙은 무기들..
	__TABLE_ITEM_BASIC*			m_pItemPlugBasics[PLUG_POS_COUNT];	// 캐릭터에 붙은 무기들..
	__TABLE_ITEM_EXT*			m_pItemPlugExts[PLUG_POS_COUNT];		// 캐릭터에 붙은 무기들..

	// ID 
	CDFont*				m_pClanFont;			// clan or knights..이름 찍는데 쓰는 Font.. -.-;
	CDFont*				m_pIDFont;				// ID 찍는데 쓰는 Font.. -.-;
	CDFont*				m_pInfoFont;			// 파티원 모집등.. 기타 정보 표시..
	CDFont*				m_pBalloonFont;			// 풍선말 표시...
	float				m_fTimeBalloon;			// 풍선말 표시 시간..

	e_StateAction		m_eState;				// 행동 상태..
	e_StateAction		m_eStatePrev;			// 직전에 세팅된 행동 상태..
	e_StateAction		m_eStateNext;			// 직전에 세팅된 행동 상태..
	e_StateMove			m_eStateMove;			// 움직이는 상태..
	e_StateDying		m_eStateDying;			// 죽을때 어떻게 죽는가..??
	float				m_fTimeDying;			// 죽는 모션을 취하는 시간..

	// by tigger
//	By : Ecli666 ( On 2002-03-29 오후 4:22:25 )
//
//	CN3Texture*			m_pTexShadow;			// 그림자 텍스처...
//	__VertexXyzT1		m_vShadows[4];			// 그림자 폴리곤..

//	~(By Ecli666 On 2002-03-29 오후 4:22:25 )
	
	D3DCOLORVALUE	m_cvDuration;			// 지속 컬러 값
	float			m_fDurationColorTimeCur;// 현재 시간..
	float			m_fDurationColorTime;	// 지속시간..

	float 			m_fFlickeringFactor;	// 깜박거림..
	float			m_fFlickeringTime;		// 깜박거림 시간..

	float			m_fRotRadianPerSec;		// 초당 회전 라디안값
	float			m_fMoveSpeedPerSec;		// 초당 움직임 값.. 이값은 기본값이고 상태(걷기, 달리기, 뒤로, 저주등) 에 따라 가감해서 쓴다..

	float			m_fYawCur;				// 현재 회전값..
	float			m_fYawToReach;			// 이 회전값을 목표로 Tick 에서 회전한다..

	float			m_fYNext;				// 오브젝트 혹은 지형의 충돌 체크에 따른 높이값..
	float			m_fGravityCur;			// 중력값..

	float			m_fScaleToSet;			// 점차 스케일 값변화..
	float			m_fScalePrev;

public:
	class CN3ShapeExtra*	m_pShapeExtraRef;			// 이 NPC 가 성문이나 집등 오브젝트의 형태이면 이 포인터를 세팅해서 쓴,다..

	int					m_iMagicAni;
	int					m_iIDTarget;			// 타겟 ID...
	int					m_iDroppedItemID;		// 죽은후 떨어트린 아이템
	bool				m_bGuardSuccess;		// 방어에 성공했는지에 대한 플래그..
	bool				m_bVisible;				// 보이는지??

	__InfoPlayerBase	m_InfoBase;				// 캐릭터 정보..
	__Vector3			m_vPosFromServer;		// 최근에 서버에게서 받은 현재 위치..	

	float				m_fTimeAfterDeath;		// 죽은지 지난시간 - 5초정도면 적당한가?? 그전에 공격을 받으면 바로 죽는다.

	float				m_fAttackDelta;			// 스킬이나 마법에 의해 변하는 공격 속도.. 1.0 이 기본이고 클수록 더 빨리 공격한다.
	float				m_fMoveDelta;			// 스킬이나 마법에 의해 변하는 이동 속도 1.0 이 기본이고 클수록 더 빨리 움직인다.
	__Vector3			m_vDirDying;			// 죽을때 밀리는 방향..

	//sound..
	bool			m_bSoundAllSet;
	CN3SndObj*		m_pSnd_Attack_0;
//	CN3SndObj*		m_pSnd_Attack_1;
	CN3SndObj*		m_pSnd_Move;
	CN3SndObj*		m_pSnd_Struck_0;
//	CN3SndObj*		m_pSnd_Struck_1;
//	CN3SndObj*		m_pSnd_Dead_0;
//	CN3SndObj*		m_pSnd_Dead_1;
	CN3SndObj*		m_pSnd_Breathe_0;
//	CN3SndObj*		m_pSnd_Breathe_1;

	CN3SndObj*		m_pSnd_Blow;

	float			m_fCastFreezeTime;

// 함수...
//	By : Ecli666 ( On 2002-03-29 오후 1:32:12 )
//	
	CBitset				m_bitset[SHADOW_SIZE];			// Used in Quake3.. ^^
	__VertexT1			m_pvVertex[4];
	uint16_t			m_pIndex[6];
	__VertexT1			m_vTVertex[4];
	float				m_fShaScale;
	CN3Texture			m_N3Tex; 
	static CN3SndObj*	m_pSnd_MyMove;

	bool			IsHostileTarget(const CPlayerBase* rhs) const;

	const __Matrix44 CalcShadowMtxBasicPlane(__Vector3 vOffs);
	void			CalcPart(CN3CPart* pPart, int nLOD, __Vector3 vLP);
	void			CalcPlug(CN3CPlugBase* pPlug, const __Matrix44* pmtxJoint, __Matrix44& mtxMV, __Vector3 vLP);

protected:
	void			RenderShadow(float fSunAngle);
//	~(By Ecli666 On 2002-03-29 오후 1:32:12 )

	virtual bool	ProcessAttack(CPlayerBase* pTarget); // 공격 루틴 처리.. 타겟 포인터를 구하고 충돌체크까지 하며 충돌하면 참을 리턴..

	/// \brief applies any on-hit elemental effects associated with a weapon
	bool TryWeaponElementEffect(e_PlugPosition plugPosition, const CPlayerBase& target, __Vector3 collisionPosition);

public:
	const __Matrix44*	JointMatrixGet(int nJointIndex) { return m_Chr.MatrixGet( nJointIndex); }
	bool 				JointPosGet(int iJointIdx, __Vector3& vPos);
	
	e_PlayerType PlayerType() const
	{
		return m_ePlayerType;
	}

	e_Race Race() const
	{
		return m_InfoBase.eRace;
	}

	e_Nation Nation() const
	{
		return m_InfoBase.eNation;
	}

	virtual void	SetSoundAndInitFont(uint32_t dwFontFlag = 0UL);
	void			SetSoundPlug(__TABLE_ITEM_BASIC* pItemBasic);
	void			ReleaseSoundAndFont();
	void			RegenerateCollisionMesh(); // 최대 최소값을 다시 찾고 충돌메시를 다시 만든다..
	e_StateAction	State() { return m_eState; } // 행동 상태...
	e_StateMove		StateMove() { return m_eStateMove; } // 움직이는 상태

	e_ItemClass		ItemClass_RightHand() const
	{
		if(m_pItemPlugBasics[PLUG_POS_RIGHTHAND]) return (e_ItemClass)(m_pItemPlugBasics[PLUG_POS_RIGHTHAND]->byClass); // 아이템 타입 - 오른손
		else return ITEM_CLASS_UNKNOWN;
	}
	e_ItemClass		ItemClass_LeftHand() const
	{
		if(m_pItemPlugBasics[PLUG_POS_LEFTHAND]) return (e_ItemClass)(m_pItemPlugBasics[PLUG_POS_LEFTHAND]->byClass); // 아이템 타입 - 오른손
		else return ITEM_CLASS_UNKNOWN;
	}
	
	e_Ani	JudgeAnimationBreath(); // 숨쉬기 모션 판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
	e_Ani	JudgeAnimationWalk(); // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
	e_Ani	JudgeAnimationRun(); // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
	e_Ani	JudgeAnimationWalkBackward(); // 걷기 모드판단하기.. 가진 아이템과 타겟이 있는냐에 따라 다른 에니메이션 인덱스를 리턴.
	e_Ani	JudgeAnimationAttack(); // 공격 모션 판단하기.. 가진 아이템에 따라 다른 에니메이션 인덱스를 리턴.
	e_Ani	JudgeAnimationStruck(); // 단지 NPC 와 유저를 구별해서 에니메이션 인덱스를 리턴
	e_Ani	JudgeAnimationGuard(); // 막는 동작 판단하기.  단지 NPC 와 유저를 구별해서 에니메이션 인덱스를 리턴
	e_Ani	JudgeAnimationDying(); // 단지 NPC 와 유저를 구별해서 에니메이션 인덱스를 리턴
	e_Ani	JudgetAnimationSpellMagic(); // 마법 동작 

	bool			IsDead() { return ( PSA_DYING == m_eState || PSA_DEATH == m_eState ); } // 죽어있는지?
	bool			IsAlive() { return !IsDead(); } // 살아있는지?
	bool			IsMovingNow() { if(PSM_WALK == m_eStateMove || PSM_RUN == m_eStateMove || PSM_WALK_BACKWARD == m_eStateMove) return true; return false; } // 움직이고 있는지?

	void			AnimationAdd(e_Ani eAni, bool bImmediately);
	void AnimationClear()
	{
		m_AnimationDeque.clear();
	}

	int AnimationCountRemain() const
	{
		return static_cast<int>(m_AnimationDeque.size()) + 1;
	}

	// 큐에 넣은 에니메이션이 변하는 순간만 세팅된다..
	bool IsAnimationChange() const
	{
		return m_bAnimationChanged;
	}

	bool			Action(e_StateAction eState, bool bLooping, CPlayerBase* pTarget = nullptr, bool bForceSet = false); // 행동 테이블에 따른 행동을 한다..
	bool			ActionMove(e_StateMove eMove); // 움직이기..
	void			ActionDying(e_StateDying eSD, const __Vector3& vDir); // 죽는 방법 결정하기..

	float			Yaw() { return m_fYawCur; } // 회전값..
	float			MoveSpeed() { return m_fMoveSpeedPerSec; }
	const __Vector3&	Position() const { return m_Chr.Pos(); }
	void			PositionSet(const __Vector3& vPos, bool bForcely) { m_Chr.PosSet(vPos); if(bForcely) m_fYNext = vPos.y; }
	float			Distance(const __Vector3& vPos) { return (m_Chr.Pos() - vPos).Magnitude(); }
	__Vector3		Scale() { return m_Chr.Scale(); }
	void			ScaleSet(float fScale) { m_fScaleToSet = m_fScalePrev = fScale; m_Chr.ScaleSet(fScale, fScale, fScale); }
	void			ScaleSetGradually(float fScale) { m_fScaleToSet = fScale; m_fScalePrev = m_Chr.Scale().y; } // 점차 스케일 변화..
	__Vector3		Direction();
	const __Quaternion&	Rotation() const { return m_Chr.Rot(); }
	void			RotateTo(float fYaw, bool bImmediately);
	void			RotateTo(CPlayerBase* pOther); // 이넘을 바라본다.
	float			Height();
	float			Radius();
	__Vector3		HeadPosition(); // 항상 변하는 머리위치를 가져온다..
	__Vector3		RootPosition() { if(!m_Chr.m_MtxJoints.empty()) return m_Chr.m_MtxJoints[0].Pos(); return __Vector3(0,0,0); }
	int				LODLevel() { return m_Chr.m_nLOD; }

	__Vector3		Max();
	__Vector3		Min();
	__Vector3		Center();

	void			DurationColorSet(const _D3DCOLORVALUE& color, float fDurationTime); // 컬러를 정하는 시간대로 유지하면서 원래색대로 돌아간다.
	void			FlickerFactorSet(float fAlpha);

	void			InfoStringSet(const std::string& szInfo, D3DCOLOR crFont);
	void			BalloonStringSet(const std::string& szBalloon, D3DCOLOR crFont);
	void			IDSet(int iID, const std::string& szID, D3DCOLOR crID);
	virtual void	KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank);
	const std::string&	IDString() { return m_InfoBase.szID; } // ID 는 Character 포인터의 이름으로 대신한다.
	int				IDNumber() const { return m_InfoBase.iID; }
	CPlayerBase*	TargetPointerCheck(bool bMustAlive);

	////////////////////
	// 충돌 체크 함수들...
	bool				CheckCollisionByBox(const __Vector3& v0, const __Vector3& v1, __Vector3* pVCol, __Vector3* pVNormal);
	bool				CheckCollisionToTargetByPlug(CPlayerBase* pTarget, int nPlug, __Vector3* pVCol);

	virtual bool			InitChr(__TABLE_PLAYER_LOOKS* pTbl);
	virtual void			InitHair() {};
	virtual void			InitFace() {};
	CN3CPart*				Part(e_PartPosition ePos) { return m_Chr.Part(ePos); }
	CN3CPlugBase*			Plug(e_PlugPosition ePos) { return m_Chr.Plug(ePos); }
	virtual CN3CPart*		PartSet(e_PartPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt);
	virtual CN3CPlugBase*	PlugSet(e_PlugPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt);
	virtual void			DurabilitySet(e_ItemSlot eSlot, int iDurability);

	void TickYaw();				// 회전값 처리.
	void TickAnimation();		// 에니메이션 처리.
	void TickDurationColor();	// 캐릭터 색깔 변화 처리.
	void TickSound();			// Sound 처리..

	virtual void		Tick();
	virtual void		Render(float fSunAngle);
#ifdef _DEBUG
	virtual void		RenderCollisionMesh() { m_Chr.RenderCollisionMesh(); }
#endif
	void				RenderChrInRect(CN3Chr* pChr, const RECT& Rect);	// Dino 추가, 지정된 사각형안에 캐릭터를 그린다. 

	void				Release();

	CPlayerBase();
	virtual				~CPlayerBase();

	int GetNPCOriginID() const
	{
		if (m_pLooksRef != nullptr)
			return m_pLooksRef->dwID;

		return -1;
	}
};

#endif // !defined(AFX_PlayerBase_H__B8B8986B_3635_462D_8C38_A052CA75B331__INCLUDED_)

// ===== END WarFare/PlayerBase.h =====

// ===== BEGIN WarFare/PlayerMySelf.cpp =====
#line 1 "WarFare/PlayerMySelf.cpp"
﻿// PlayerMgr.cpp: implementation of the CPlayerMySelf class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PlayerMySelf.h"
#include "PacketDef.h"
#include "PlayerOtherMgr.h"
#include "N3WorldManager.h"
#include "GameProcMain.h"
#include "UIInventory.h"
#include "MagicSkillMng.h"
#include "GameEng.h"
#include "text_resources.h"

#include <N3Base/DFont.h>
#include <N3Base/N3Camera.h>
#include <N3Base/N3ShapeMgr.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


CPlayerMySelf::CPlayerMySelf()
{
	m_ePlayerType = PLAYER_MYSELF; // Player Type ... Base, NPC, OTher, MySelf

	m_bRunning = false;				// 뛰는지..
	m_bMoveContinous = false;		// 계속 움직이는지..
	m_bAttackContinous = false;		// 계속 공격하는 상태인지..
	m_bSitDown = false;				// 앉아있는 상태인지....
	m_bRecruitParty = false;		// 파티모집중??
	
	m_bStun = false;				// 기절..
	m_fStunTime = 0.0f;				// 기절한 시간..


	m_fAttackTimeRecent = CN3Base::TimeGet();	// 최근에 공격한 시간..
	m_bTempMoveTurbo = false;

	m_InfoExt.Init();

	// Inventory..
	m_ChrInv.PartAlloc(PART_POS_COUNT);
	m_ChrInv.PlugAlloc(PLUG_POS_COUNT);

	m_iSendRegeneration = 0;	// 한번 보내면 다시 죽을때까지 안보내는 플래그	

	m_dwMagicID = 0xffffffff;
	m_fCastingTime = 0.0f;
	m_pObjectTarget = nullptr; // 타겟 오브젝트 포인터..
}

CPlayerMySelf::~CPlayerMySelf()
{
}



//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////



void CPlayerMySelf::Release()
{
	m_bTargetOrPosMove = false;
	m_iMoveTarget = -1;

	m_bRunning = false;				// 뛰는지..
	m_bMoveContinous = false;		// 계속 움직이는지..
	m_bAttackContinous = false;		// 계속 공격하는 상태인지..
	m_bSitDown = false;				// 앉아있는 상태인지....
	m_bRecruitParty = false;		// 파티모집중??

	m_bStun = false;				// 기절..
	m_fStunTime = 0.0f;				// 기절한 시간..

	m_fAttackTimeRecent = CN3Base::TimeGet();	// 최근에 공격한 시간..
	m_bTempMoveTurbo = false;

	m_InfoExt.Init();

	// Inventory..
	m_ChrInv.Release();
	m_ChrInv.PartAlloc(PART_POS_COUNT);
	m_ChrInv.PlugAlloc(PLUG_POS_COUNT);

	m_pObjectTarget = nullptr; // 타겟 오브젝트 포인터..

	CPlayerBase::Release();
}

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////

void CPlayerMySelf::SetMoveTargetID(int iID)
{
	m_bTargetOrPosMove	= true;
	m_iMoveTarget		= iID;
}

void CPlayerMySelf::SetMoveTargetPos(__Vector3 vPos)
{
	m_vTargetPos		= vPos;
	m_bTargetOrPosMove	= true;
	m_iMoveTarget		= -1;
}

void CPlayerMySelf::Tick()
{
	BOOL bAnim = TRUE;

	if (PSA_DEATH == m_eState)  // 죽는 상태이고... 죽는 에니메이션이 끝나면.. // 한번 보내면 다시 죽을때까지 안보내는 플래그
	{
		if (0 == m_iSendRegeneration)
		{
//			std::string szMsg = fmt::format_text_resource(IDS_REGENERATION);
//			CGameProcedure::MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_REGENERATION);
//			CLogWriter::Write("Dead!!!");
			m_iSendRegeneration = 1;
		}
		return;
	}

	if(m_fTimeAfterDeath > 0) // 강제로 죽여야 한다..
	{
		if(m_fTimeAfterDeath > 3.0f)
			this->Action(PSA_DYING, false); // 3 초가 지나야 죽는다.
		CPlayerBase::Tick();  // 회전, 지정된 에니메이션 Tick 및 색깔 지정 처리.. 등등..
		return;
	}
	
	if(IsDead()) // 죽은 상태면 돌아간다.
	{
		CGameProcedure::s_pProcMain->CommandEnableAttackContinous(false, nullptr);
		CPlayerBase::Tick();  // 회전, 지정된 에니메이션 Tick 및 색깔 지정 처리.. 등등..
		return;
	}

	////////////////////////////////////////////////////////////////////////////////
	// 내 플레이어는 움직이는게 다른넘들과 다르기 때문에 특별하게 처리..
	if(	PSM_WALK == m_eStateMove ||
		PSM_WALK_BACKWARD  == m_eStateMove ||
		PSM_RUN == m_eStateMove ) // 앞뒤로 걸어가거나 달려가면.
	{
		this->MoveSpeedCalculationAndCheckCollision(); // 움직이는 속도 및 충돌체크...
		if(m_fMoveSpeedPerSec == 0.0f) // 속도가 없으면 충돌체크 결과 못가는 거다...
		{
			this->ActionMove(PSM_STOP);
			CGameProcedure::s_pProcMain->MsgSend_Move(false, false); // 정지 패킷 보내기..
		}

		__Vector3 vPos = this->Position();
		CPlayerBase::m_pSnd_MyMove = m_pSnd_Move;
		if(m_pSnd_Move && m_Chr.NeedPlaySound0()) 
			m_pSnd_Move->Play(&vPos);
		if(m_pSnd_Move && m_Chr.NeedPlaySound1()) 
			m_pSnd_Move->Play(&vPos);

		TargetOrPosMove();
	}
	else 
	{
		m_pSnd_MyMove = nullptr;
		m_fMoveSpeedPerSec = 0;
	}
	// 내 플레이어는 움직이는게 다른넘들과 다르기 때문에 특별하게 처리..
	////////////////////////////////////////////////////////////////////////////////

	CPlayerBase* pTarget = nullptr;
	if (m_bAttackContinous)
	{
		pTarget = TargetPointerCheck(false);
		if(pTarget == nullptr)
		{
			CGameProcedure::s_pProcMain->CommandEnableAttackContinous(false, nullptr);
		}
		else
		{
			float fTime = TimeGet();
			
			// process an archery auto-attack
			if(	(m_pItemPlugBasics[PLUG_POS_LEFTHAND] && ITEM_CLASS_BOW == m_pItemPlugBasics[PLUG_POS_LEFTHAND]->byClass ) || 
				(m_pItemPlugBasics[PLUG_POS_LEFTHAND] && ITEM_CLASS_BOW_LONG == m_pItemPlugBasics[PLUG_POS_LEFTHAND]->byClass ) || 
				(m_pItemPlugBasics[PLUG_POS_RIGHTHAND] && ITEM_CLASS_BOW_CROSS == m_pItemPlugBasics[PLUG_POS_RIGHTHAND]->byClass) )
			{
				__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(102003); // 스킬 테이블에서 기본 활 스킬을 찾고
				if(pSkill)
				{
					if(pTarget->IsAlive())//임시 유저가 살아 있는 상태에서만...
					{
						float fInterval = (pSkill->iCastTime / 10.f) + 0.15f;
						if(m_fAttackDelta > 0) fInterval /= m_fAttackDelta;
						if(fTime > m_fAttackTimeRecent + fInterval) // 공격 간격이 넘으면.. 공격!
						{
							if(CGameProcedure::s_pProcMain->m_pMagicSkillMng->MsgSend_MagicProcess(m_iIDTarget, pSkill))
							{// 스킬 패킷 보내기에 성공하면.
								//TRACE("%.2f\n", fTime - m_fAttackTimeRecent);
							}
							m_fAttackTimeRecent = fTime;	// 최근에 공격한 시간..
						}
					}
				}
			}
			// a "javelin launcher" attack
			else if( m_pItemPlugBasics[PLUG_POS_RIGHTHAND]
				&& ITEM_CLASS_LAUNCHER == m_pItemPlugBasics[PLUG_POS_RIGHTHAND]->byClass )
			{
				__TABLE_UPC_SKILL* pSkill = s_pTbl_Skill.Find(102009); // 스킬 테이블에서 기본 활 스킬을 찾고
				if(pSkill && fTime > m_fAttackTimeRecent + (pSkill->iCastTime / 10.f)) // 공격 간격이 넘으면.. 공격!
				{
					if(pTarget->IsAlive())//임시 유저가 살아 있는 상태에서만
					{
						CGameProcedure::s_pProcMain->m_pMagicSkillMng->MsgSend_MagicProcess(m_iIDTarget, pSkill); // 스킬 패킷 보내기에 성공하면.
						//TRACE("%.2f\n", fTime - m_fAttackTimeRecent);
						m_fAttackTimeRecent = fTime;	// 최근에 공격한 시간..
					}
				}
			}
			// melee weapon auto-attack
			else
			{
				float fIntervalTable = 1.0f;
				if(m_pItemPlugBasics[PLUG_POS_RIGHTHAND] && m_pItemPlugExts[PLUG_POS_RIGHTHAND]) // 공격 간격 정의
				{
					fIntervalTable = (m_pItemPlugBasics[PLUG_POS_RIGHTHAND]->siAttackInterval / 100.0f)
						* (m_pItemPlugExts[PLUG_POS_RIGHTHAND]->siAttackIntervalPercentage / 100.0f); // 100 은 1초 110 이면 1.1 초등.. 퍼센트로 간다...
				}
				
				float fInterval = fIntervalTable;
				// scale for attack speed modifiers
				if(m_fAttackDelta > 0)
					fInterval /= m_fAttackDelta; 

				if(	fTime > m_fAttackTimeRecent + fInterval)
				{
					// cannot auto-attack while casting
					bool bCastingNow = CGameProcedure::s_pProcMain->m_pMagicSkillMng->IsCasting();
					if(!bCastingNow)
					{
						if(IsAttackableTarget(pTarget))
						{
							float fDistance = s_pPlayer->DistanceExceptRadius(pTarget);
							CGameProcedure::s_pProcMain->MsgSend_Attack(pTarget->IDNumber(), fIntervalTable, fDistance);

							// start the auto-attack animation loop if it isn't already playing
							if (PSA_SPELLMAGIC != m_eState
								&& PSA_ATTACK != m_eState
								&& m_fFlickeringFactor == 1.0f)
								this->Action(PSA_ATTACK, true, pTarget);
							
							m_fAttackTimeRecent = fTime;
						}
						else 
						{
							if(CGameProcedure::s_pEng->ViewPoint() == VP_THIRD_PERSON)
							{
								RotateTo(pTarget); // 방향을 돌린다.

								float fDist = (pTarget->Position() - m_Chr.Pos()).Magnitude(); // 공격 거리를 구하고..
								float fDistLimit = this->AttackableDistance(pTarget);

								if(fDist > fDistLimit && !m_bTargetOrPosMove)
								{
									CGameProcedure::s_pProcMain->CommandMove(MD_FORWARD, true);
									s_pPlayer->SetMoveTargetID(pTarget->IDNumber());
								}
							}

							// If not casting a spell or sitting down, loop auto-attack animation
							if (PSA_SPELLMAGIC != m_eState
								&& PSA_SITDOWN != m_eState)
								this->Action(PSA_BASIC, true);
						}
					}
				}
			}

			// if an attack was triggered this tick, make the character stand
			if(fTime == m_fAttackTimeRecent)
				CGameProcedure::s_pProcMain->CommandSitDown(false, false);
		}
	}


	// process stun cooldown
	if(m_bStun) 
	{
		m_fStunTime -= s_fSecPerFrm;
		if(m_fStunTime < 0)
			this->StunRelease();
	}

	// if the character is in an attack animation state, attempt to process an auto-attack
	if (PSA_ATTACK == m_eState
		|| PSA_SPELLMAGIC == m_eState)
	{
		if(pTarget == nullptr)
			pTarget = TargetPointerCheck(false);
		CPlayerBase::ProcessAttack(pTarget); 
	}

	if(m_dwMagicID != 0xffffffff) 
		m_fCastingTime += CN3Base::s_fSecPerFrm;

	// call super to rotate, animation tick, etc
	CPlayerBase::Tick();
}

void CPlayerMySelf::Render(float fSunAngle)
{
	// 강제로 LOD 레벨 + 1
	m_Chr.m_nLOD--;
	if(m_Chr.m_nLOD < 0) m_Chr.m_nLOD = 0;

	int iLODDeltaPrev = CN3Chr::LODDelta(); // 내캐릭은 좀더 정교하게 그리자..
	CN3Chr::LODDeltaSet(0);
	CPlayerBase::Render(fSunAngle);
	CN3Chr::LODDeltaSet(iLODDeltaPrev);
}




bool CPlayerMySelf::ToggleAttackContinous()
{
	if(!IsAlive()) return false;

	if(false == m_bAttackContinous) // 타겟이 있는지 본다..
	{
		CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(m_iIDTarget, true);
		if(pTarget) //  && !IsOutOfAttackRange(pTarget)) // 타겟이 있고 공격 가능한 범위에 있을때만
		{
			this->m_bAttackContinous = true;
		}
	}
	else
	{
		m_bAttackContinous = false;
	}

	return m_bAttackContinous;
}

bool CPlayerMySelf::ToggleRunMode()
{
	m_bRunning = !m_bRunning; // 뛰는지..
	if(true == m_bRunning)
	{
		if(PSM_WALK == m_eStateMove) 
		{
			m_eStateMove = PSM_RUN;
			m_Chr.AniCurSet(ANI_RUN);
		}
	}
	else
	{
		if(PSM_RUN == m_eStateMove) 
		{
			m_eStateMove = PSM_WALK;
			m_Chr.AniCurSet(ANI_WALK);
		}
	}

	return m_bRunning;
}

void CPlayerMySelf::ToggleMoveMode()
{
	m_bMoveContinous = !m_bMoveContinous; // 계속 움직이는지..
	
	int nAni = ANI_BREATH;
	if(m_bMoveContinous) // 계속 움직여야 하면..
	{
		if(m_bRunning) // 뛰면..
		{
			m_eStateMove = PSM_RUN;
			nAni = ANI_RUN;
		}
		else
		{
			m_eStateMove = PSM_WALK;
			nAni = ANI_WALK;
		}

		float fSpeed = this->MoveSpeedCalculationAndCheckCollision(); // 움직이는 속도 및 충돌체크...
		if(0 == fSpeed) // 갈수 없으면...
		{
			m_bMoveContinous = false;
			m_eStateMove = PSM_STOP;
			m_eState = PSA_BASIC;
			nAni = this->JudgeAnimationBreath(); // 타겟이 있으면. 들고 있는 무기에 따라 기본 에니메이션 판다.. 없으면 걍 기본 에니메이션
		}
	} 
	else
	{
		m_eStateMove = PSM_STOP;
		m_eState = PSA_BASIC;
		nAni = this->JudgeAnimationBreath(); // 타겟이 있으면. 들고 있는 무기에 따라 기본 에니메이션 판다.. 없으면 걍 기본 에니메이션
	}

	this->AnimationClear();
	m_Chr.AniCurSet(nAni); // 통째로 걷고 뒤기, 멈추기 적용
}

__Vector3 CPlayerMySelf::NextPos(float fTimeAfter)
{
	__Matrix44 mtxRot = m_Chr.Rot();
	__Vector3 vDir(0,0,1);
	__Vector3 vNextPos = m_Chr.Pos() + ((vDir * mtxRot) * m_fMoveSpeedPerSec * fTimeAfter);

	return vNextPos;
}

void CPlayerMySelf::RotAdd(const float fRotRadianPerSec)			// y 축을 기준으로 초당 회전하는 속도를 넣어준다.
{
	m_fYawCur += fRotRadianPerSec * s_fSecPerFrm;

	if(m_fYawCur >= DegreesToRadians(180.0f) * 2) m_fYawCur -= DegreesToRadians(180.0f) * 2;
	if(m_fYawCur <= -DegreesToRadians(180.0f) * 2) m_fYawCur += DegreesToRadians(180.0f) * 2;
	m_fYawToReach = m_fYawCur; // 바로 돌린다..
}

void CPlayerMySelf::InventoryChrRender(const RECT& Rect)
{
/*
	uint32_t dwUsefog = TRUE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_FOGENABLE , &dwUsefog );

	uint32_t dwUseLighting=TRUE;
	CN3Base::s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwUseLighting );

	int	bLight[8];
	for ( int i = 0; i < 8; i++ )	CN3Base::s_lpD3DDev->GetLightEnable(i, &bLight[i]);

	if (dwUseLighting) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, TRUE );
	if (dwUsefog) CN3Base::s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE, FALSE );
	// set render states
	for ( i = 1; i < 8; i++ )	CN3Base::s_lpD3DDev->LightEnable(i, FALSE);
	CN3Base::s_lpD3DDev->LightEnable(0, TRUE);

	D3DLIGHT8 lgt0;
	
	memset(&lgt0, 0, sizeof(D3DLIGHT8));
	lgt0.Type = D3DLIGHT_POINT;
	lgt0.Attenuation0 = 0.5f;
	lgt0.Range = 100.0f;
	lgt0.Position = __Vector3(0.0f, 2.0f, -10.0f);
	lgt0.Diffuse.r = 220/255.0f; lgt0.Diffuse.g = 255/255.0f; lgt0.Diffuse.b = 220/255.0f;
	CN3Base::s_lpD3DDev->SetLight(0, &lgt0);

	//캐릭터 찍기..
	//
	__Matrix44 mtxproj, mtxview, mtxworld, mtxprojback, mtxviewback, mtxworldback;

	CN3Base::s_lpD3DDev->GetTransform(D3DTS_PROJECTION, mtxprojback.toD3D());
	CN3Base::s_lpD3DDev->GetTransform(D3DTS_VIEW, mtxviewback.toD3D());
	CN3Base::s_lpD3DDev->GetTransform(D3DTS_WORLD, mtxworldback.toD3D());

	mtxproj.OrthoLH(12.0f, 9.0f, 0, 100);  
    CN3Base::s_lpD3DDev->SetTransform(D3DTS_PROJECTION, mtxproj.toD3D());

    mtxview.LookAtLH(
		{ 0.0f, 2.0f,-10.0f },
		{ 0.0f, 0.0f, 0.0f },
		{ 0.0f, 1.0f, 0.0f });
    CN3Base::s_lpD3DDev->SetTransform(D3DTS_VIEW, mtxview.toD3D());

	mtxworld.Identity();
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxworld.toD3D());


///////////////////////////////////////////////////////////////
// 2d 좌표 구함..

	// 2d -> 3d..
	__Vector3 vPos;
	vPos.x = (float)((Rect.right - Rect.left)/2.0f + Rect.left);
	vPos.y = (float)(Rect.bottom) - (Rect.bottom - Rect.top)/16.0f;
	vPos.z = 0.11f;

	float fWidth, fHeight;
	fWidth = s_CameraData.vp.Width;	fHeight = s_CameraData.vp.Height;	fWidth *= 0.5f;	fHeight *= 0.5f;

	vPos.x = (vPos.x - fWidth)/fWidth;
	vPos.y = (fHeight - vPos.y)/fHeight;

	__Matrix44 mtxProjInv, mtxViewInv;
	mtxProjInv = mtxproj.Inverse();
	mtxViewInv = mtxview.Inverse();

	vPos *= mtxProjInv;
	vPos *= mtxViewInv;

	m_ChrInv.PosSet(vPos.x, vPos.y, 1.0f);
	__Quaternion qt;
	qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(198.0f));
	m_ChrInv.RotSet(qt);

	CGameProcedure::s_pEng->ClearZBuffer(nullptr);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	m_ChrInv.m_nLOD = 0;
	m_ChrInv.Render();

	CN3Base::s_lpD3DDev->SetTransform(D3DTS_PROJECTION, mtxprojback.toD3D());
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_VIEW, mtxviewback.toD3D());
	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxworldback.toD3D());

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_AMBIENT, 0x00000000);

	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwUseLighting );
	CN3Base::s_lpD3DDev->SetRenderState( D3DRS_FOGENABLE , dwUsefog );
	for ( i = 0; i < 8; i++ )	CN3Base::s_lpD3DDev->LightEnable(i, bLight[i]);
*/
	// 아래로 dino수정
	// backup render state
	DWORD dwLighting;
	__D3DLight9 BackupLight0;

	s_lpD3DDev->GetRenderState( D3DRS_LIGHTING, &dwLighting );
	BOOL bLight[8];
	for ( int i = 0; i < 8; ++i )	s_lpD3DDev->GetLightEnable(i, &(bLight[i]));
	s_lpD3DDev->GetLight(0, BackupLight0.toD3D());

	// set render state
	if (TRUE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, TRUE );
	for ( int i = 1; i < 8; ++i )	s_lpD3DDev->LightEnable(i, FALSE);
	s_lpD3DDev->LightEnable(0, TRUE);

	// 0번 light 설정
	__D3DLight9 Light0;
	memset(&Light0, 0, sizeof(__D3DLight9));
	Light0.Type = D3DLIGHT_POINT;
	Light0.Attenuation0 = 0.5f;
	Light0.Range = 100.0f;
	Light0.Position = { 0.0f, 2.0f, 10.0f };
	Light0.Diffuse.r = 220/255.0f; Light0.Diffuse.g = 255/255.0f; Light0.Diffuse.b = 220/255.0f;
	s_lpD3DDev->SetLight(0, Light0.toD3D());

	// 캐릭터 위치와 방향 세팅
	m_ChrInv.PosSet(0, 0, 0);
	__Quaternion qt;
	qt.RotationAxis(0.0f, 1.0f, 0.0f, DegreesToRadians(18.0f));	// 약간 비스듬하게 서있게..
	m_ChrInv.RotSet(qt);

	// render
	RenderChrInRect(&m_ChrInv, Rect);

	// restore
	if (TRUE != dwLighting) s_lpD3DDev->SetRenderState( D3DRS_LIGHTING, dwLighting );
	for (int i = 0; i < 8; ++i )	s_lpD3DDev->LightEnable(i, bLight[i]);
	s_lpD3DDev->SetLight(0, BackupLight0.toD3D());
}

void CPlayerMySelf::InventoryChrTick()
{
	// Inventory Animation Tick..
	m_ChrInv.PosSet(m_Chr.Pos());
	m_ChrInv.Tick();
}



void CPlayerMySelf::InventoryChrAnimationInitialize()
{
	int iAniTmp = m_ChrInv.AniCtrl()->Count() - 1;
	m_ChrInv.AniCurSet(iAniTmp, false, 0);
	m_ChrInv.AniCurSet(ANI_BREATH, false, 0);
	m_ChrInv.Tick(); // 한번 해준다..
}

CN3CPlugBase* CPlayerMySelf::PlugSet(e_PlugPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt)
{
	int iJoint = 0;
	if(PLUG_POS_RIGHTHAND == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
		iJoint = m_pLooksRef->iJointRH;
	}
	else if(PLUG_POS_LEFTHAND == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
		if(pItemBasic)
		{
			if(pItemBasic->byClass == ITEM_CLASS_SHIELD) iJoint = m_pLooksRef->iJointLH2; // 방패인 경우
			else iJoint = m_pLooksRef->iJointLH; // 왼손 끝..
		}
	}
	else if (PLUG_POS_KNIGHTS_GRADE == ePos)
	{
		m_pItemPlugBasics[ePos] = pItemBasic;
		m_pItemPlugExts[ePos] = pItemExt;
		iJoint = m_pLooksRef->iJointRH - 2; // 오른쪽 팔목
	}
	else if (PLUG_POS_BACK == ePos)
	{
		//m_pItemBasicPlugRefs[PLUG_POS_BACK] = pItem;
	}
	else { __ASSERT(0, "Invalid Plug Item position"); }

	CN3CPlugBase* pPlug = m_ChrInv.PlugSet(ePos, szFN);
	if(nullptr == pPlug) return nullptr;

	if(PLUG_POS_LEFTHAND == ePos || PLUG_POS_RIGHTHAND == ePos) // 키에 비례해서 크게 키운다. 기본키는 1.8 미터이다. 
	{
		float fScale = m_Chr.Height() / 1.8f;
		fScale *= pPlug->Scale().y / m_Chr.Scale().y;
		pPlug->ScaleSet(__Vector3(fScale, fScale, fScale));
		pPlug->m_nJointIndex = iJoint; // 관절 번호 세팅..
	}
//	else if(PLUG_POS_BACK == ePos)
//	{
//		CN3CPlug_Cloak *pPlugCloak = (CN3CPlug_Cloak*)pPlug;
//	}

	this->SetSoundPlug(pItemBasic);
	return CPlayerBase::PlugSet(ePos, szFN, pItemBasic, pItemExt);
}

CN3CPart* CPlayerMySelf::PartSet(e_PartPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt)
{
	if(ePos < PART_POS_UPPER || ePos >= PART_POS_COUNT)
	{
		__ASSERT(0, "Invalid Item Position");
		return nullptr;
	}

	if(PART_POS_UPPER == ePos) // 상체일 경우 특별한 처리가 필요..
	{
		if(pItemBasic) // 입히는 경우
		{
			if(pItemBasic->byIsRobeType && m_Chr.Part(PART_POS_LOWER)) // 로브 타입의 통짜 윗옷이고 아래에 뭔가 입고 있으면..
			{
				m_ChrInv.PartSet(PART_POS_LOWER, ""); // 아래를 비워준다..
				m_Chr.PartSet(PART_POS_LOWER, "");
			}
		}
		else // 상체를 벗는 경우
		{
			if(m_pItemPartBasics[ePos] && m_pItemPartBasics[ePos]->byIsRobeType) // 전에 착용했던게 로브면..
			{
				if(m_pItemPartBasics[PART_POS_LOWER]) // 하체에 아이템이 입혀있으면..
				{
					std::string szFN2;
					e_PartPosition ePartPos2 = PART_POS_UNKNOWN;
					e_PlugPosition ePlugPos2 = PLUG_POS_UNKNOWN;
					MakeResrcFileNameForUPC(m_pItemPartBasics[PART_POS_LOWER], m_pItemPartExts[PART_POS_LOWER], &szFN2, nullptr, ePartPos2, ePlugPos2, m_InfoBase.eRace);
					
					m_ChrInv.PartSet(PART_POS_LOWER, szFN2); // 하체에 전의 옷을 입힌다..
					m_Chr.PartSet(PART_POS_LOWER, szFN2);
				}
				else // 하체에 입고 있었던 아이템이 없다면..
				{
					__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..
					m_ChrInv.PartSet(PART_POS_LOWER, pLooks->szPartFNs[PART_POS_LOWER]); // 하체에 기본옷을 입힌다.
					m_Chr.PartSet(PART_POS_LOWER, pLooks->szPartFNs[PART_POS_LOWER]); // 하체에 기본옷을 입힌다.
				}
			}
		}
	}
	else if(PART_POS_LOWER == ePos) // 하체일 경우..
	{
		// 아이템을 착용하건 벗건간에...
		if(m_pItemPartBasics[PART_POS_UPPER] && m_pItemPartBasics[PART_POS_UPPER]->byIsRobeType) // 전에 상체에 착용했던게 로브면..
		{
			m_pItemPartBasics[ePos] = pItemBasic; // 아이템 적용
			m_pItemPartExts[ePos] = pItemExt;
			m_ChrInv.PartSet(ePos, "");
			m_Chr.PartSet(ePos, ""); // 하체는 벗기고(?)..
			return nullptr; // 돌아간다.
		}
	}

	CN3CPart* pPart = nullptr;
	if(szFN.empty()) // 파일 이름이 없는거면.. 기본 착용..
	{
		if(PART_POS_HAIR_HELMET == ePos)
		{
			this->InitHair();
			pPart = m_Chr.Part(ePos);
		}
		else if(PART_POS_FACE == ePos)
		{
			this->InitFace();
			pPart = m_Chr.Part(ePos);
		}
		else
		{
			__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);	// Player Character Skin 구조체 포인터..
			if(pLooks)
			{
				m_ChrInv.PartSet(ePos, pLooks->szPartFNs[ePos]);
				pPart = m_Chr.PartSet(ePos, pLooks->szPartFNs[ePos]);
				if(pPart) pPart->TexOverlapSet("");
			}
		}
	}
	else
	{
		m_ChrInv.PartSet(ePos, szFN);
		pPart = m_Chr.PartSet(ePos, szFN);
	}

	m_pItemPartBasics[ePos] = pItemBasic; // 아이템 적용
	m_pItemPartExts[ePos] = pItemExt;

	return pPart;
}

bool CPlayerMySelf::InitChr(__TABLE_PLAYER_LOOKS* pTbl)
{
	CPlayerBase::InitChr(pTbl);

	m_ChrInv.JointSet(pTbl->szJointFN);
	m_ChrInv.AniCtrlSet(pTbl->szAniFN);
	
	float fScale = 2.1f / m_Chr.Height();
	m_ChrInv.ScaleSet(fScale, fScale, fScale); // 인벤토리 창에 들어가게 크기를 줄여준다..

	return true;
}

float CPlayerMySelf::AttackableDistance(CPlayerBase* pTarget)
{
	if(nullptr == pTarget) return 0;

	float fDistLimit = (m_Chr.Radius() + pTarget->Radius())/2.0f; // 공격 거리제한..
	if(m_pItemPlugBasics[0])
		fDistLimit += m_pItemPlugBasics[0]->siAttackRange / 10.0f; // 아이템을 들고 있으면..
	else if(m_pItemPlugBasics[1] && ITEM_POS_TWOHANDLEFT == m_pItemPlugBasics[1]->byAttachPoint) // 왼손에 투핸드레프트(활) 아이템을 들고 있으면..
		fDistLimit += m_pItemPlugBasics[1]->siAttackRange / 10.0f;

	return fDistLimit;
}

float CPlayerMySelf::DistanceExceptRadius(CPlayerBase* pTarget)
{
	if(nullptr == pTarget) return 0;

	float fDist = (pTarget->Position() - m_Chr.Pos()).Magnitude();
	float fDistRadius = (m_Chr.Radius() + pTarget->Radius())/2.0f; // 공격 거리제한..

	return fDist - fDistRadius;
}

/// \brief checks to see if an attack can be performed on the target
/// \param pTarget
/// \param bMeasureAngle does the target need to be in front of the attacker?
/// \returns true if attack would be valid, false otherwise
bool CPlayerMySelf::IsAttackableTarget(CPlayerBase* pTarget, bool bMeasureAngle)
{
	if (pTarget == nullptr || pTarget->IsDead())
		return false;

	// cannot attack when invulnerable 
	if (m_fFlickeringFactor != 1.0f)
		return false;

	if (!IsHostileTarget(pTarget))
		return false;

	// make sure the target is within range
	float fDist = (pTarget->Position() - m_Chr.Pos()).Magnitude();
	float fDistLimit = this->AttackableDistance(pTarget);
	if(fDist > fDistLimit)
		return false;

	// check that the target is in front of the attacker
	if(bMeasureAngle)
	{
		__Vector3 vDir = this->Direction();
		vDir.y = 0;
		vDir.Normalize();
		__Vector3 vDirTarget = pTarget->Position() - m_Chr.Pos();
		vDirTarget.y = 0;
		vDirTarget.Normalize();
		float fDot = vDir.Dot(vDirTarget);
		if(fDot > 0.7f)
			return true;
		
		return false;
	}

	return true;
}

// TODO(Gilad): It'd probably be better to refactor this one as it modifies the m_fYNext variable which is part of the PlayerBase
// class and when the packet is sent to the game server, it reads the next Y coordinates to climb the terrain height.
// Why? Because we just checking if collision detected and it should just check if collision detected and not modify any global members
// or pointers. It would be more partical to check the whole thing if authority = GM when more code is implemented here in the future.
// Another option would be to send a packet to the server validate the collision through the game server and let the game server check 
// against wall hacking.
bool CPlayerMySelf::CheckCollision()
{
	float fSpeed = m_fMoveSpeedPerSec * CN3Base::s_fSecPerFrm; // The speed at which the current moving speed is calculated.
	if(0 == fSpeed) return false; // If it does not move, do not check collision.

	__Vector3 vPos = this->Position();

	__Vector3 vDir(0,0,1); // Find the rotation value ...
	__Matrix44 mtxRot = this->Rotation(); 
	vDir *= mtxRot; // Find the direction of rotation.
	if(fSpeed < 0)
	{
		fSpeed *= -1.0f;
		vDir *= -1.0f;
	}
	__Vector3 vPosNext = vPos + (vDir * fSpeed); // 다음 위치 계산..
	if (s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && 
		false == ACT_WORLD->IsInTerrainWithTerrain(vPosNext.x, vPosNext.z, vPos) )
		return true; // 경계 안에 있지 않으면..


	//////////////////////////////////
	// 다른 플레이어와 체크..
	CPlayerOther* pUPC = nullptr;
	float fHeightSum, fMag;
	it_UPC it = s_pOPMgr->m_UPCs.begin(), itEnd = s_pOPMgr->m_UPCs.end();
	for(; it != itEnd; it++)
	{
		pUPC = it->second;

		//죽어 있는 상태의 캐릭터는 충돌체크를 하지 않는다.
		if (pUPC->IsDead())
			continue;

		// 같은 국가...
		if (!IsHostileTarget(pUPC))
			continue;
		
		fMag = (pUPC->Position() - vPos).Magnitude();
		if(fMag < 32.0f)
		{
			fHeightSum = (pUPC->Height() + m_Chr.Height()) / 2.5f;
			if(fMag < fHeightSum) // 거리가 키의 합보다 작으면..
			{
				float fMag2 = (pUPC->Position() - vPosNext).Magnitude(); // 다음위치가 더 가까우면.
				if(s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && fMag2 < fMag)
					return true;
			}
		}
	}
	// 다른 플레이어와 체크..
	//////////////////////////////////

//	__TABLE_ZONE* pZoneInfo = s_pTbl_Zones.Find(m_InfoExt.iZoneCur);
//	if(pZoneInfo && pZoneInfo->bNPCCollisionCheck) //this_zone

	//적국 엔피씨는 충돌 체크를 한다.
	CPlayerNPC* pNPC = nullptr;
	it_NPC it_N = s_pOPMgr->m_NPCs.begin(),	it_NEnd	= s_pOPMgr->m_NPCs.end();
	for(; it_N != it_NEnd; it_N++)
	{
		pNPC = it_N->second;

		if(pNPC->m_pShapeExtraRef) continue; // 성문등의 형태이면 충돌체크를 하지 않는다..

		// 같은 국가...
		if (!IsHostileTarget(pNPC))
			continue;

		fMag = (pNPC->Position() - vPos).Magnitude();
		if(fMag < 32.0f)
		{
			fHeightSum = (pNPC->Height() + m_Chr.Height()) / 2.5f;
			if(fMag < fHeightSum) // 거리가 키의 합보다 작으면..
			{
				float fMag2 = (pNPC->Position() - vPosNext).Magnitude(); // 다음위치가 더 가까우면.
				if(s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && fMag2 < fMag)
					return true;
			}
		}
	}//for(


	// 오브젝트와 충돌체크..
	__Vector3 vPos2 = vPos, vCol, vNormal;
	if (!s_pWorldMgr->IsIndoor())
		vPos2.y += 0.5f; // 캐릭터 발높이에서 0.5 미터 높이 위에서 충돌체크한다.
	else
		vPos2.y += 0.6f; // 캐릭터 발높이에서 0.6 미터 높이 위에서 충돌체크한다.	이 함수 내에서 쓰는 0.6은 PvsMgr의 m_fVolumeOffs.. ^^
	bool bColShape = ACT_WORLD->CheckCollisionWithShape(vPos2, vDir, fSpeed, &vCol, &vNormal);
	if(s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && bColShape) return true; // 오브젝트와 충돌값이 있으면 

	////////////////////////////////////////////////////////////////////////////////
	// 지면과 오브젝트의 높이값 구하기..
	float fYTerrain = ACT_WORLD->GetHeightWithTerrain(vPosNext.x, vPosNext.z);		// 지면의 높이값..
	float fYClimb = ACT_WORLD->GetHeightNearstPosWithShape(vPosNext, CN3Base::s_fSecPerFrm * 30.0f, &vNormal); // 충돌 체크 오브젝트의 높이값..
	vNormal.y = 0; // 이래야 정상적인 경사를 얻을수 있다..
	
	if (!s_pWorldMgr->IsIndoor())
	{
		if(fYClimb > fYTerrain && fYClimb < vPosNext.y + ((30.0f/CN3Base::s_fFrmPerSec) * 0.5f)) // 충돌 체크 오브젝트 높이값이 있고 지형보다 높을 경우만 높이값 적용
		{
			if(s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && 
				vNormal.Magnitude() > MAX_INCLINE_CLIMB && vNormal.Dot(vDir) <= 0.0f) // 경사 체크..
			{
				return true;
			}
			m_fYNext = fYClimb;
		}
		else
		{
			// 지형의 경사가 45 도 이하인지 체크
			if(s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER && 
				true == ACT_WORLD->CheckInclineWithTerrain(vPosNext, vDir, MAX_INCLINE_CLIMB))
			{
				return true;
			}
			m_fYNext = fYTerrain; // 다음 위치를 맞추고..
		}
	}
	else	// 일단..
	{
		if ((fYClimb > fYTerrain) && (fYClimb < vPosNext.y + 0.6f))
			m_fYNext = fYClimb;
		else
			m_fYNext = fYTerrain; // 다음 위치를 맞추고..

		if ((m_fYNext > vPos.y + 0.6f) || (m_fYNext < vPos.y - 0.6f*2.0f))
		{
			m_fYNext = vPos.y;
			if (s_pPlayer->m_InfoBase.iAuthority != AUTHORITY_MANAGER) return true;
		}
	}

//	else // 올라갈수 없는 곳이면 지형과의 기울기 체크..
//	{
//		// 방향을 구해서.. 기울기에 따라 다른 속도를 적용
//		s_pTerrain->GetNormal(vPos.x, vPos.z, vNormal);
//		vNormal.Normalize();
//		vNormal.y	= 0.0f;
//		float fM = vNormal.Magnitude();
//		float fD = vNormal.Dot(vDir);
//		if(fSpeed < 0) fD *= -1.0f;
//		if(fD < 0) fSpeed *= 1.0f - (fM / 0.7071f); // 기울기에 따른 팩터 적용
//
//		vPosNext = vPos + (vDir * fSpeed); // 다음 위치 계산..
//		m_fYNext = s_pTerrain->GetHeight(vPosNext.x, vPosNext.z);
//	}

	this->PositionSet(vPosNext, false);

	///////////////////////////////////////////////////////////////
	// 캐릭터 충돌 체크..
//	int iSize = s_pOPMgr->m_OPCs.size();
//	it_UPC it = s_pOPMgr->m_OPCs.begin();
//	for( int i = 0; i < iSize; i++, it++ )
//	{
//		if ( ((*it)->Position() - vPosAfter).Magnitude() < 1.2f )
//			return vPosBefore;
//	}

	return false;
}


void CPlayerMySelf::InitFace()
{
	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);

	// 아이템이 있고 얼굴 이름이 있으면..
	if (pLooks != nullptr
		&& !pLooks->szPartFNs[PART_POS_FACE].empty())
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pLooks->szPartFNs[PART_POS_FACE].c_str(), nullptr, szDir, szFName, szExt);
		
		std::string szFN = fmt::format("{}{}{:02}{}", szDir, szFName, m_InfoExt.iFace, szExt);
		PartSet(PART_POS_FACE, szFN, nullptr, nullptr);
	}
}

void CPlayerMySelf::InitHair()
{
	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);

	// 아이템이 있고 얼굴 이름이 있으면..
	if (pLooks != nullptr
		&& !pLooks->szPartFNs[PART_POS_HAIR_HELMET].empty())
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pLooks->szPartFNs[PART_POS_HAIR_HELMET].c_str(), nullptr, szDir, szFName, szExt);

		std::string szFN = fmt::format("{}{}{:02}{}", szDir, szFName, m_InfoExt.iHair, szExt);
		PartSet(PART_POS_HAIR_HELMET, szFN, nullptr, nullptr);
	}
	else
	{
		m_Chr.PartSet(PART_POS_HAIR_HELMET, "");
		m_ChrInv.PartSet(PART_POS_HAIR_HELMET, "");
	}
}

void CPlayerMySelf::KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank)
{
	CPlayerBase::KnightsInfoSet(iID, szName, iGrade, iRank);

	m_InfoExt.szKnights = szName;
	m_InfoExt.iKnightsGrade = iGrade;
	m_InfoExt.iKnightsRank = iRank;

	if (m_InfoExt.szKnights.empty())
	{
		delete m_pClanFont;
		m_pClanFont = nullptr;
		return;
	}

	if (m_pClanFont == nullptr)
	{
		std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

		m_pClanFont = new CDFont(szFontID, 12, D3DFONT_BOLD);
		m_pClanFont->InitDeviceObjects(s_lpD3DDev);
		m_pClanFont->RestoreDeviceObjects();
	}

	m_pClanFont->SetText(m_InfoExt.szKnights.c_str()); // 폰트에 텍스트 지정.
	m_pClanFont->SetFontColor(KNIGHTS_FONT_COLOR);
}

void CPlayerMySelf::SetSoundAndInitFont(uint32_t dwFontFlag)
{
	CPlayerBase::SetSoundAndInitFont();

	if (m_InfoExt.szKnights.empty())
	{
		delete m_pClanFont;
		m_pClanFont = nullptr;
		return;
	}

	if (m_pClanFont == nullptr)
	{
		std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

		m_pClanFont = new CDFont(szFontID, 12, D3DFONT_BOLD);
		m_pClanFont->InitDeviceObjects(s_lpD3DDev);
		m_pClanFont->RestoreDeviceObjects();
	}

	m_pClanFont->SetText(m_InfoExt.szKnights.c_str()); // 폰트에 텍스트 지정.
	m_pClanFont->SetFontColor(KNIGHTS_FONT_COLOR);
}

float CPlayerMySelf::MoveSpeedCalculationAndCheckCollision() // 속도를 구하고 그 속도로 충돌 체크를 한다. 리턴값이 0 이면 충돌이다..
{
	m_fMoveSpeedPerSec = MOVE_SPEED_WHEN_WALK;
	if(PSM_RUN == m_eStateMove) m_fMoveSpeedPerSec *= MOVE_DELTA_WHEN_RUNNING;
	else if(PSM_STOP == m_eStateMove) m_fMoveSpeedPerSec = 0.0f;
	else if(PSM_WALK_BACKWARD == m_eStateMove) m_fMoveSpeedPerSec *= -1.0f;
	m_fMoveSpeedPerSec *= m_fMoveDelta; // 이동 속도 변하기에 따라서... 곱해준다.

	if(m_bTempMoveTurbo) // 개발용 플래그...
	{
		m_fMoveSpeedPerSec *= 10.0f;
	}

	if(this->CheckCollision()) // 충돌 체크면..
	{
		if(CGameProcedure::s_pProcMain)
			CGameProcedure::s_pProcMain->CommandMove(MD_STOP, true);
		m_fMoveSpeedPerSec = 0;
	}

	// 방향을 구해서.. 기울기에 따라 다른 속도를 적용
/*	__Vector3 vDir = this->Direction();
	__Vector3 vPos = m_Chr.Pos(), vNormal(0,1,0);
	s_pTerrain->GetNormal(vPos.x, vPos.z, vNormal);
	vNormal.Normalize();
	vNormal.y	= 0.0f;
	float fM = vNormal.Magnitude();
	float fD = vNormal.Dot(vDir);
	if(fSpeed < 0) fD *= -1.0f;
//	if (fM > MAX_INCLINE_CLIMB && fD <= 0.0f )
//	{
//	}
	if(fD < 0) fSpeed *= 1.0f - (fM / 0.7071f); // 기울기에 따른 팩터 적용
*/	
	return m_fMoveSpeedPerSec;

}

void CPlayerMySelf::Stun(float fTime) // 일정한 시간동안 기절 시키기.
{
	m_bStun = true;				// 기절..
	m_fStunTime = fTime;		// 기절한 시간..

	CGameProcedure::s_pProcMain->CommandEnableAttackContinous(false, nullptr); // 공격 멈추고..
	CGameProcedure::s_pProcMain->CommandMove(MD_STOP, true); // 움직임을 멈추게 하고..
}

void CPlayerMySelf::StunRelease() // 기절 풀기..
{
	m_bStun = false;			// 기절..
	m_fStunTime = 0.0f;			// 기절한 시간..
}

void CPlayerMySelf::TargetOrPosMove()
{
	if (!m_bTargetOrPosMove)
		return;

	m_vTargetPos.y = m_Chr.Pos().y;

	if (m_iMoveTarget >= 0)
	{
		CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(m_iMoveTarget, true);
		if(pTarget != nullptr)
		{
			m_vTargetPos = pTarget->Position();
		}
		else
		{
			this->ActionMove(PSM_STOP);
			CGameProcedure::s_pProcMain->MsgSend_Move(false, false); // 정지 패킷 보내기..
		}
	}

	__Vector3 vDir = m_vTargetPos - s_pPlayer->Position();
	vDir.y = 0.0f;
	vDir.Normalize();

	float fYaw = ::_Yaw2D(vDir.x, vDir.z);
	this->RotateTo(fYaw, true); // 방향을 돌리고

	if( m_iMoveTarget >= 0 )
	{
		CPlayerNPC* pTarget = s_pOPMgr->CharacterGetByID(m_iMoveTarget, true);

		float fDist = (pTarget->Position() - m_Chr.Pos()).Magnitude(); // 공격 거리를 구하고..
		float fDistLimit = this->AttackableDistance(pTarget);

		if(fDist < fDistLimit)
		{
			CGameProcedure::s_pProcMain->CommandEnableAttackContinous(true, pTarget);
			this->ActionMove(PSM_STOP);
			CGameProcedure::s_pProcMain->MsgSend_Move(false, false); // 정지 패킷 보내기..
		}
	}
	else
	{
		float fDist = (m_vTargetPos - Position()).Magnitude();
		if( fDist < 0.5f )
		{
			this->ActionMove(PSM_STOP);
			CGameProcedure::s_pProcMain->MsgSend_Move(false, false); // 정지 패킷 보내기..
		}
	}
}

bool CPlayerMySelf::HasWeaponEquipped() const
{
	// TODO: Handle transformations (should use the inventory in that case)
	if (IsItemClassWeapon(ItemClass_RightHand())
		|| IsItemClassWeapon(ItemClass_LeftHand()))
		return true;

	return false;
}

// ===== END WarFare/PlayerMySelf.cpp =====

// ===== BEGIN WarFare/PlayerMySelf.h =====
#line 1 "WarFare/PlayerMySelf.h"
﻿// PlayerMgr.h: interface for the CPlayerMySelf class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PLAYERMGR_H__036554E3_CDCC_4B13_97B2_34C5D4D63E8C__INCLUDED_)
#define AFX_PLAYERMGR_H__036554E3_CDCC_4B13_97B2_34C5D4D63E8C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <list>
#include "PlayerBase.h"

//////////////////////////////////////////////////////////////////////
class CPlayerMySelf : public CPlayerBase
{
protected:
	bool			m_bRunning; // 뛰는지..

	/// \brief the last time an attack/skill message was sent to the server
	float			m_fAttackTimeRecent;

	__Vector3		m_vCollisionOffsets[3]; // 허리 부분 2개의 충돌 체크 + 머리 부분 1개의 충돌 체크..

public:	
	__InfoPlayerMySelf	m_InfoExt;
	CN3Chr				m_ChrInv;				// 캐릭터 기본 객체...
	bool				m_bMoveContinous;		// 계속 움직이는지..
	bool				m_bAttackContinous;		// 계속 공격하는 상태인지..
	bool				m_bSitDown;				// 앉아있는 상태인지....
	bool				m_bRecruitParty;		// 파티 모집중??

	bool				m_bStun;				// 기절..
	float				m_fStunTime;			// 기절한 시간..

	int					m_iSendRegeneration;	// 한번 보내면 다시 죽을때까지 안보내는 플래그 0 일때는 메시지 박스를 띄운다..
	bool				m_bTempMoveTurbo;		// 개발을 위해 임시로 넣은 코드.. 무지 빠르게 움직이게 한다.. Tick 참조.

	uint32_t				m_dwMagicID;			// 쓰고 있는 마법..
	float				m_fCastingTime;			// 마법 주문 거는 시간..
	
	class CN3Shape*		m_pObjectTarget;		// 타겟 오브젝트 포인터..

	bool				m_bTargetOrPosMove;		// 타겟이나 지점 이동 여부
	int					m_iMoveTarget;			// 타겟 아이디
	__Vector3			m_vTargetPos;			// 이동할 지점 위치
	void				SetMoveTargetID(int iID);
	void				SetMoveTargetPos(__Vector3 vPos);

public:	
	void			TargetOrPosMove();
	void			Stun(float fTime); // 일정한 시간동안 기절 시키기.
	void			StunRelease(); // 기절 풀기..

	float			MoveSpeedCalculationAndCheckCollision(); // 속도를 구하고 그 속도로 충돌 체크를 한다. 리턴값이 0 이면 충돌이다..

	void			InitFace(); // 갖고 있는 정보로 얼굴을 초기화 한다..
	void			InitHair(); // 갖고 있는 정보로 머리카락을 초기화 한다..
	void			KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank);
	void			SetSoundAndInitFont(uint32_t dwFontFlag = 0UL);

	float			AttackableDistance(CPlayerBase* pTarget);
	float			DistanceExceptRadius(CPlayerBase* pTarget);

	/// \brief checks to see if an attack can be performed on the target
	/// \param pTarget
	/// \param bMeasureAngle does the target need to be in front of the attacker?
	/// \returns true if attack would be valid, false otherwise
	bool			IsAttackableTarget(CPlayerBase* pTarget, bool bMeasureAngle = true); // 공격 가능한 범위에 있는지..
	bool			IsRunning() { return m_bRunning; }
	bool			CheckCollision();		// 움직이는 처리와 충돌체크를 한다. 충돌되는게 있으면 움직이지 않는다.
	//.. 
	bool			InitChr(__TABLE_PLAYER_LOOKS* pTblUPC);
	CN3CPart*		PartSet(e_PartPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt);
	CN3CPlugBase*	PlugSet(e_PlugPosition ePos, const std::string& szFN, __TABLE_ITEM_BASIC* pItemBasic, __TABLE_ITEM_EXT* pItemExt);

	void			Tick();
	void			Render(float fSunAngle);

	__Vector3		NextPos(float fTimeAfter);
	void			RotAdd(const float fRotRadianPerSec);			// y 축을 기준으로 초당 회전하는 속도를 넣어준다.
	
	bool			ToggleAttackContinous();
	bool			ToggleRunMode();
	void			ToggleMoveMode();

	// Inventory..
	void			InventoryChrRender(const RECT& Rect);
	void			ChrCreateChrRender(const RECT& Rect);
	void			InventoryChrTick();
	void			InventoryChrAnimationInitialize();

	bool			HasWeaponEquipped() const;

	void			Release();
	CPlayerMySelf();
	virtual	~CPlayerMySelf();
};


#endif // !defined(AFX_PLAYERMGR_H__036554E3_CDCC_4B13_97B2_34C5D4D63E8C__INCLUDED_)

// ===== END WarFare/PlayerMySelf.h =====

// ===== BEGIN WarFare/PlayerNPC.cpp =====
#line 1 "WarFare/PlayerNPC.cpp"
﻿// PlayerNPC.cpp: implementation of the CPlayerNPC class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PlayerNPC.h"
#include "GameProcMain.h"
#include "N3WorldManager.h"
#include "PlayerMySelf.h"

#include <N3Base/N3Shape.h>
#include <N3Base/N3ShapeMgr.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPlayerNPC::CPlayerNPC()
{
	m_ePlayerType = PLAYER_NPC; // Player Type ... Base, NPC, OTher, MySelf
	m_vPosFromServer = m_Chr.Pos(); // 서버에게 받은 위치.
}

CPlayerNPC::~CPlayerNPC()
{
}

void CPlayerNPC::Tick()
{
	if(m_pShapeExtraRef) // 오브젝트이면..
	{
		CPlayerBase::Tick();
		return;
	}

	if(m_fTimeAfterDeath > 0) // 죽어야하거나 죽은 넘이면...
	{
		if(m_fTimeAfterDeath > 3.0f)
			this->Action(PSA_DYING, false); // 5 초가 지나야 죽는다.
		CPlayerBase::Tick();  // 회전, 지정된 에니메이션 Tick 및 색깔 지정 처리.. 등등..
		return;
	}

	__Vector3 vPos = m_Chr.Pos();
	if(	m_vPosFromServer.x != vPos.x || m_vPosFromServer.z != vPos.z ) // 조금 더 가야한다.
	{
		if(m_fMoveSpeedPerSec == 0)
		{
			__Vector3 vT1(m_vPosFromServer.x, 0, m_vPosFromServer.z), vT2(vPos.x, 0, vPos.z);
			m_fMoveSpeedPerSec = (vT2 - vT1).Magnitude();
		}

		__Vector3 vOffset = m_vPosFromServer - vPos; vOffset.y = 0;
		__Vector3 vDir = vOffset; vDir.Normalize();  // 방향.. 

		float fSpeedAbsolute = (m_fMoveSpeedPerSec > 0) ? m_fMoveSpeedPerSec : -m_fMoveSpeedPerSec; // 속도 절대값
		float fDist = vOffset.Magnitude(); // 거리
		if(fDist < fSpeedAbsolute * CN3Base::s_fSecPerFrm) // 움직이는 거리가 거의 다온거면..
		{
			vPos.x = m_vPosFromServer.x; // 위치를 고정해주고..
			vPos.z = m_vPosFromServer.z; // 위치를 고정해주고..
//			m_fMoveSpeedPerSec = 0; // 움직이는 속도를 0으로!
			this->ActionMove(PSM_STOP); // 움직이는 모션 처리..
		}
		else 
		{
			float fYaw = (m_fMoveSpeedPerSec < 0) ? ::_Yaw2D(-vDir.x, -vDir.z) : ::_Yaw2D(vDir.x, vDir.z); // 방향을 계산해서..
			this->RotateTo(fYaw, false); // 진행 방향으로 돌리고..

			e_StateMove eMove = PSM_STOP; // 움직임...
			// 플레이어면 걷는 속도가 기준 나머지는 덩치에 반비례..
			float fStandWalk = ((PLAYER_OTHER == m_ePlayerType) ? (MOVE_SPEED_WHEN_WALK * 2.0f) : (MOVE_SPEED_WHEN_WALK * m_Chr.Radius() * 2.0f));
			if(m_fMoveSpeedPerSec < 0) eMove = PSM_WALK_BACKWARD; // 뒤로 걷기..
			else if(m_fMoveSpeedPerSec < fStandWalk) eMove = PSM_WALK; // 앞으로 걷기..
			else eMove = PSM_RUN; // if(fDN > 5.0f) // 다음 위치의 거리가 일정 이상이면 뛰어간다.
			this->ActionMove(eMove); // 움직이는 모션 처리..

			vPos += vDir * (fSpeedAbsolute * s_fSecPerFrm); // 이동..
		}

		float fYTerrain = ACT_WORLD->GetHeightWithTerrain(vPos.x, vPos.z); // 지면의 높이값..
		float fYMesh = ACT_WORLD->GetHeightNearstPosWithShape(vPos, 1.0f); // 충돌 체크 오브젝트의 높이값..
		if(fYMesh != -FLT_MAX && fYMesh > fYTerrain && fYMesh < m_fYNext + 1.0f) m_fYNext = fYMesh; // 올라갈수 있는 오브젝트이고 높이값이 지면보다 높으면.
		else m_fYNext = fYTerrain;
		this->PositionSet(vPos, false); // 위치 최종 적용..
	}

	// 공격 중이거나 스킬 사용중이면..
	if (PSA_ATTACK == m_eState
		|| PSA_SPELLMAGIC == m_eState)
	{
		CPlayerBase* pTarget = this->TargetPointerCheck(false);
		CPlayerBase::ProcessAttack(pTarget); // 공격에 관한 루틴 처리.. 에니메이션 세팅과 충돌만 처리할뿐 패킷은 처리 안한다..
	}

	CPlayerBase::Tick(); // 회전. 이동, 에니메이션 틱.. 상태 바뀜 등을 처리한다.
}

void CPlayerNPC::MoveTo(float fPosX, float fPosY, float fPosZ, float fSpeed, int iMoveMode)
{
	m_vPosFromServer.Set(fPosX, fPosY, fPosZ);
	if(m_pShapeExtraRef) return; // 오브젝트 형식이면 움직일수가 없다..

	// iMoveMode : 현재 움직이는 상태.. 0 -정지 1 움직임시작 2 - 1초마다 한번 연속움직임..
	if(0 == iMoveMode) 
	{
	}
	else if(iMoveMode) // 움직임 시작.. // 계속 움직임
	{
		m_fMoveSpeedPerSec = fSpeed;
		__Vector3 vPos = m_Chr.Pos(); vPos.y = 0;
		__Vector3 vPosS(fPosX, 0, fPosZ);
	
		if(fSpeed) m_fMoveSpeedPerSec *= ((vPosS - vPos).Magnitude() / (fSpeed * PACKET_INTERVAL_MOVE)) * 0.85f; // 속도보간.. 동기화때문에 그런다.. 약간 줄여주는 이유는 멈칫하는걸 방지하기 위해서이다..
		else m_fMoveSpeedPerSec = ((vPosS - vPos).Magnitude() / (fSpeed * PACKET_INTERVAL_MOVE)) * 0.85f; // 속도보간.. 동기화때문에 그런다.. 약간 줄여주는 이유는 멈칫하는걸 방지하기 위해서이다..
		if(fSpeed < 0) m_fMoveSpeedPerSec *= -1.0f; // 뒤로 간다..
	}
	else
	{
//		__ASSERT(0, "Invalid Move Mode");
	}
}

void CPlayerNPC::SetSoundAndInitFont(uint32_t dwFontFlag)
{
	CPlayerBase::SetSoundAndInitFont(dwFontFlag);

	if (s_pPlayer->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
	{
		// NOTE: Type is the AI state (not the NPC's type as you'd expect), but it's not sent at all here,
		// and is rarely ever even sent officially, so we'll just placeholder it to 0 for now.
		std::string szInfo = fmt::format("ID({}) : TYPE({})", m_InfoBase.iID, 0);
		InfoStringSet(szInfo, D3DCOLOR_XRGB(0, 255, 0));
	}
}

// ===== END WarFare/PlayerNPC.cpp =====

// ===== BEGIN WarFare/PlayerNPC.h =====
#line 1 "WarFare/PlayerNPC.h"
﻿// PlayerNPC.h: interface for the CPlayerNPC class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PLAYERNPC_H__8A79604A_EFA6_408E_A0EB_4B7BF4FDDAB4__INCLUDED_)
#define AFX_PLAYERNPC_H__8A79604A_EFA6_408E_A0EB_4B7BF4FDDAB4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PlayerBase.h"
#include "GameBase.h"

//////////////////////////
// Other Player..
#include "PlayerBase.h"

class CPlayerNPC : public CPlayerBase
{
	friend class CPlayerOtherMgr;
public:
	void	MoveTo(float fPosX, float fPosY, float fPosZ, float fMoveSpeed, int iMoveMode); // 이 위치로 이동..
	void	Tick() override;
	void	SetSoundAndInitFont(uint32_t dwFontFlag = 0UL) override;

	CPlayerNPC();
	virtual ~CPlayerNPC();
};

#endif // !defined(AFX_PLAYERNPC_H__8A79604A_EFA6_408E_A0EB_4B7BF4FDDAB4__INCLUDED_)

// ===== END WarFare/PlayerNPC.h =====

// ===== BEGIN WarFare/PlayerOther.cpp =====
#line 1 "WarFare/PlayerOther.cpp"
﻿// PlayerOther.cpp: implementation of the CPlayerOther class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "GameProcedure.h"
#include "PlayerOther.h"
#include "PlayerMySelf.h"

#include <N3Base/DFont.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPlayerOther::CPlayerOther()
{
	m_ePlayerType = PLAYER_OTHER; // Player Type ... Base, NPC, OTher, MySelf

	m_InfoExt.Init();
	m_bSit = false;
}

CPlayerOther::~CPlayerOther()
{
}

void CPlayerOther::Tick()
{
	if( m_bSit )
		CPlayerBase::Tick();  // 회전, 지정된 에니메이션 Tick 및 색깔 지정 처리.. 등등..
	else
		CPlayerNPC::Tick();
}

bool CPlayerOther::Init(e_Race eRace, int iFace, int iHair, uint32_t* pdwItemIDs, int* piItenDurabilities)
{
	if(nullptr == pdwItemIDs || nullptr == piItenDurabilities) return false;

	m_InfoBase.eRace = eRace;
	m_InfoExt.iFace = iFace;
	m_InfoExt.iHair = iHair;

	// 이제 패킷에 따라 캐릭터를 치장..(?) 시켜준다.. 아이템장착, 무기 장착등...
	__TABLE_PLAYER_LOOKS* pLooks = s_pTbl_UPC_Looks.Find(eRace);	// 테이블에서 기본 스킨 ..
	if(nullptr == pLooks) 
	{
		CLogWriter::Write("CPlayerOther::Init() Basic Resource Pointer is NULL Race({})",
			static_cast<int>(eRace));
		return false;
	}
	this->InitChr(pLooks); // 관절 세팅..

	for(int i = 0; i < MAX_ITEM_SLOT_OPC; i++)
	{
		std::string szFN;
		e_PartPosition ePart = PART_POS_UNKNOWN;
		e_PlugPosition ePlug = PLUG_POS_UNKNOWN;
		e_ItemSlot eSlot = ITEM_SLOT_UNKNOWN;
		__TABLE_ITEM_BASIC* pItem = nullptr;
		__TABLE_ITEM_EXT* pItemExt = nullptr;

		if(0 == pdwItemIDs[i]) 
		{
			if(0 == i) { ePart = PART_POS_UPPER;			szFN = pLooks->szPartFNs[0]; }
			else if(1 == i) { ePart = PART_POS_LOWER;		szFN = pLooks->szPartFNs[1]; }
//			else if(2 == i) { ePart = PART_POS_HAIR_HELMET; szFN = pLooks->szPartFNs[5]; }
			else if(3 == i) { ePart = PART_POS_HANDS;		szFN = pLooks->szPartFNs[3]; }
			else if(4 == i) { ePart = PART_POS_FEET;		szFN = pLooks->szPartFNs[4]; }
			else if(5 == i) { } // 망토
//			else if(6 == i) { ePlug = PLUG_POS_RIGHTHAND; }
//			else if(7 == i) { ePlug = PLUG_POS_LEFTHAND; }
		}
		else
		{
			pItem = s_pTbl_Items_Basic.Find(pdwItemIDs[i]/1000*1000);	// 유저 플레이어 아이템 얻기..
			if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
				pItemExt = s_pTbl_Items_Exts[pItem->byExtIndex].Find(pdwItemIDs[i]%1000);
			if(nullptr == pItem || nullptr == pItemExt)
			{
				__ASSERT(0, "NULL Item!!!");
				continue;
			}


			e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, &szFN, nullptr, ePart, ePlug, m_InfoBase.eRace); // 리소스 파일 이름을 만들고..

			if(0 == i) { ePart = PART_POS_UPPER;			eSlot = ITEM_SLOT_UPPER; }
			else if(1 == i) { ePart = PART_POS_LOWER;		eSlot = ITEM_SLOT_LOWER; }
			else if(2 == i) { ePart = PART_POS_HAIR_HELMET; eSlot = ITEM_SLOT_HEAD; }
			else if(3 == i) { ePart = PART_POS_HANDS;		eSlot = ITEM_SLOT_GLOVES; }
			else if(4 == i) { ePart = PART_POS_FEET;		eSlot = ITEM_SLOT_SHOES; }
			else if(5 == i) { } // 망토
			else if(6 == i) { ePlug = PLUG_POS_RIGHTHAND;	eSlot = ITEM_SLOT_HAND_RIGHT; }
			else if(7 == i) { ePlug = PLUG_POS_LEFTHAND;	eSlot = ITEM_SLOT_HAND_LEFT; }
		}

		if(PART_POS_UPPER == ePart || PART_POS_LOWER == ePart || PART_POS_HANDS == ePart || PART_POS_FEET == ePart)
		{
			this->PartSet(ePart, szFN, pItem, pItemExt);
		}
		else if(PART_POS_HAIR_HELMET == ePart) // 머리카락 혹은 헬멧이면..
		{
			this->PartSet(ePart, szFN, pItem, pItemExt);
		}
		else if(5 == i) 
		{
		}
		else if((6 == i || 7 == i) && PLUG_POS_UNKNOWN != ePlug)
		{
			this->PlugSet(ePlug, szFN, pItem, pItemExt);
		}

		if(ITEM_SLOT_UNKNOWN != eSlot)
			this->DurabilitySet(eSlot, piItenDurabilities[i]);
	}

	// 얼굴은 따로하자..
	this->InitFace();
	CN3CPart* pPartHairHelmet = this->Part(PART_POS_HAIR_HELMET);
	if(pPartHairHelmet->FileName().empty()) // 헬멧에 해당되는게 없으면.. 머리카락 붙이기..
		this->InitHair();

	return true;
}

void CPlayerOther::InitFace()
{
	__TABLE_PLAYER_LOOKS* pItem = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);

	// 아이템이 있고 얼굴 이름이 있으면..
	if (pItem != nullptr
		&& !pItem->szPartFNs[PART_POS_FACE].empty())
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pItem->szPartFNs[PART_POS_FACE].c_str(), nullptr, szDir, szFName, szExt);

		std::string szFN = fmt::format("{}{}{:02}{}", szDir, szFName, m_InfoExt.iFace, szExt);
		PartSet(PART_POS_FACE, szFN, nullptr, nullptr);
	}
}

void CPlayerOther::InitHair()
{
	__TABLE_PLAYER_LOOKS* pItem = s_pTbl_UPC_Looks.Find(m_InfoBase.eRace);
	if (pItem && !pItem->szPartFNs[PART_POS_HAIR_HELMET].empty()) // 아이템이 있고 얼굴 이름이 있으면..
	{
		char szDir[_MAX_DIR] = {}, szFName[_MAX_FNAME] = {}, szExt[_MAX_EXT] = {};
		_splitpath(pItem->szPartFNs[PART_POS_HAIR_HELMET].c_str(), nullptr, szDir, szFName, szExt);

		std::string szFN = fmt::format("{}{}{:02}{}", szDir, szFName, m_InfoExt.iHair, szExt);
		PartSet(PART_POS_HAIR_HELMET, szFN, nullptr, nullptr);
	}
	else
	{
		m_Chr.PartSet(PART_POS_HAIR_HELMET, "");
	}
}

void CPlayerOther::KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank)
{
	CPlayerBase::KnightsInfoSet(iID, szName, iGrade, iRank);

	m_InfoExt.szKnights = szName;
	m_InfoExt.iKnightsGrade = iGrade;
	m_InfoExt.iKnightsRank = iRank;

	if (m_InfoExt.szKnights.empty())
	{
		delete m_pClanFont;
		m_pClanFont = nullptr;
	}

	float fDist = Distance(CGameBase::s_pPlayer->Position());
	if (fDist < SOUND_RANGE_TO_SET)
	{
		if (m_pClanFont == nullptr)
		{
			std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

			m_pClanFont = new CDFont(szFontID, 12);
			m_pClanFont->InitDeviceObjects(s_lpD3DDev);
			m_pClanFont->RestoreDeviceObjects();
		}

		m_pClanFont->SetText(m_InfoExt.szKnights.c_str(), D3DFONT_BOLD); // 폰트에 텍스트 지정.
		m_pClanFont->SetFontColor(KNIGHTS_FONT_COLOR);
	}
}

void CPlayerOther::SetSoundAndInitFont(uint32_t dwFontFlag)
{
	CPlayerBase::SetSoundAndInitFont();

	if (m_InfoExt.szKnights.empty())
	{
		delete m_pClanFont;
		m_pClanFont = nullptr;
		return;
	}

	if (m_pClanFont == nullptr)
	{
		std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

		m_pClanFont = new CDFont(szFontID, 12, D3DFONT_BOLD); // 좀 작게 만든다..
		m_pClanFont->InitDeviceObjects(s_lpD3DDev);
		m_pClanFont->RestoreDeviceObjects();
	}

	m_pClanFont->SetText(m_InfoExt.szKnights.c_str()); // 폰트에 텍스트 지정.
	m_pClanFont->SetFontColor(KNIGHTS_FONT_COLOR);
}

// ===== END WarFare/PlayerOther.cpp =====

// ===== BEGIN WarFare/PlayerOther.h =====
#line 1 "WarFare/PlayerOther.h"
﻿// PlayerOther.h: interface for the CPlayerOther class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PlayerOther_H__06F94EA0_0640_4532_B8CC_7FB9A99291AB__INCLUDED_)
#define AFX_PlayerOther_H__06F94EA0_0640_4532_B8CC_7FB9A99291AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameBase.h"
#include "PlayerNPC.h"

class CPlayerOther : public CPlayerNPC
{
	friend class CPlayerOtherMgr;
public:
	__InfoPlayerOther	m_InfoExt;					// 캐릭터 정보 확장..
	bool				m_bSit;

public:
	void	InitFace();
	void	InitHair();
	void	KnightsInfoSet(int iID, const std::string& szName, int iGrade, int iRank);
	void	SetSoundAndInitFont(uint32_t dwFontFlag = 0UL);

	bool	Init(enum e_Race eRace, int iFace, int iHair, uint32_t* pdwItemIDs, int* piItenDurabilities);
	void	Tick();

	CPlayerOther();
	virtual ~CPlayerOther();
};


#endif // !defined(AFX_PlayerOther_H__06F94EA0_0640_4532_B8CC_7FB9A99291AB__INCLUDED_)

// ===== END WarFare/PlayerOther.h =====

// ===== BEGIN WarFare/PlayerOtherMgr.cpp =====
#line 1 "WarFare/PlayerOtherMgr.cpp"
﻿// PlayerOtherMgr.cpp: implementation of the CPlayerOtherMgr class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "PlayerOtherMgr.h"
#include "PlayerMySelf.h"

#include <N3Base/DFont.h>
#include <N3Base/N3ShapeExtra.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPlayerOtherMgr::CPlayerOtherMgr()
{
	m_iChrCountToRender = 0; // 렌더링되는 캐릭 카운트
}

CPlayerOtherMgr::~CPlayerOtherMgr()
{
	ReleaseUPCs();
	ReleaseNPCs();
	ReleaseCorpses();
}

void CPlayerOtherMgr::ReleaseUPCs()
{
	it_UPC it = m_UPCs.begin(), itEnd = m_UPCs.end();
	for(; it != itEnd; it++) delete it->second;
	m_UPCs.clear();
}

void CPlayerOtherMgr::ReleaseNPCs()
{
	it_NPC it = m_NPCs.begin(), itEnd = m_NPCs.end();
	for(; it != itEnd; it++)  delete it->second;
	m_NPCs.clear();
}

void CPlayerOtherMgr::ReleaseCorpses()
{
	it_NPC it = m_Corpses.begin(), itEnd = m_Corpses.end();
	for(; it != itEnd; it++)  delete it->second;
	m_Corpses.clear();
}
//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
void CPlayerOtherMgr::Release()
{
	ReleaseUPCs();
	ReleaseNPCs();
	ReleaseCorpses();
}

//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
void CPlayerOtherMgr::Tick(const __Vector3& vPosPlayer)
{
	// 자동 캐릭터 LOD 조절..
	int iLOD = 0;
	int iLODTotal = 0;

	it_UPC it = m_UPCs.begin(), itEnd = m_UPCs.end();
	CPlayerNPC* pNPC = nullptr;
	for(; it != itEnd; )
	{
		pNPC = it->second;
		
		pNPC->Tick();
		iLOD = pNPC->LODLevel();
		if(iLOD >= 0 && iLOD < MAX_CHR_LOD) iLODTotal += MAX_CHR_LOD - iLOD; // 자동 LOD 계산할때 필요한 값..

		float fDist = pNPC->Distance(vPosPlayer);
		if(fDist < SOUND_RANGE_TO_SET) pNPC->SetSoundAndInitFont(); // SOUND_RANGE 안에 있으면.
		else if(fDist > SOUND_RANGE_TO_RELEASE) pNPC->ReleaseSoundAndFont();
		it++;
	}

	it_NPC it2 = m_NPCs.begin(), itEnd2 = m_NPCs.end();
	for(; it2 != itEnd2; )
	{
		pNPC = it2->second;

		pNPC->Tick();
		iLOD = pNPC->LODLevel();
		if(iLOD >= 0 && iLOD < MAX_CHR_LOD) iLODTotal += MAX_CHR_LOD - iLOD; // 자동 LOD 계산할때 필요한 값..

		if(PSA_DEATH == pNPC->State())
		{
			it2 = m_NPCs.erase(it2);
			this->CorpseAdd(pNPC);
		}
		else if (pNPC->m_InfoBase.eNation==NATION_KARUS || pNPC->m_InfoBase.eNation==NATION_ELMORAD)
		{
			// TODO(srmeier): in 1299 the NPCs seem to have their own distance parameters
			// keeping them the same for now but will probably want to look into this

			// NOTE(srmeier): CPlayerBase::Tick() places a limit to the distance for which the names
			// get displayed

			float fDist = pNPC->Distance(vPosPlayer);
			if (fDist < SOUND_RANGE_TO_SET) pNPC->SetSoundAndInitFont(D3DFONT_BOLD); // SOUND_RANGE 안에 있으면.
			else if (fDist > SOUND_RANGE_TO_RELEASE) pNPC->ReleaseSoundAndFont();
			it2++;
		}
		else
		{
			float fDist = pNPC->Distance(vPosPlayer);
			if(fDist < SOUND_RANGE_TO_SET) pNPC->SetSoundAndInitFont(D3DFONT_BOLD); // SOUND_RANGE 안에 있으면.
			else if(fDist > SOUND_RANGE_TO_RELEASE) pNPC->ReleaseSoundAndFont();
			it2++;
		}
	}

	// 죽은놈 처리..
	CPlayerBase* pCorpse = nullptr;
	it_NPC it3 = m_Corpses.begin(), itEnd3 = m_Corpses.end();
	for(; it3 != itEnd3; )
	{
		pCorpse = it3->second;
		pCorpse->ReleaseSoundAndFont();

		pCorpse->Tick();
		iLOD = pCorpse->LODLevel();
		if(iLOD >= 0 && iLOD < MAX_CHR_LOD) iLODTotal += MAX_CHR_LOD - iLOD; // 자동 LOD 계산할때 필요한 값..

		if(pCorpse->m_fTimeAfterDeath >= TIME_CORPSE_REMAIN) // 죽은지 일정한 시간이 지나면..
		{
			delete pCorpse;
			it3 = m_Corpses.erase(it3); // 죽은놈 지우고..
		}
		else
		{
			it3++;
		}
	}

	// 자동 캐릭터 LOD 조절..
	int iLODDelta = 0;
	if(iLODTotal >= 100) iLODDelta = 3;
	else if(iLODTotal >= 60) iLODDelta = 2;
	else if(iLODTotal >= 30) iLODDelta = 1;
	CN3Chr::LODDeltaSet(iLODDelta);
}



void CPlayerOtherMgr::Render(float fSunAngle)
{

//	CPlayerOther*	pUPC = nullptr;
//	it_UPC it = m_UPCs.begin(), itEnd = m_UPCs.end();
//	for(; it != itEnd; it++)
//	{
//		pUPC = it->second;
//		
//		if(pUPC->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
//			continue;//this_authority
//
//		pUPC->Render(true, fSunAngle);
//	}

	// 카메라 거리순으로 정렬
	int iUPCSize = static_cast<int>(m_UPCs.size());
	if (iUPCSize > 0)
	{
		std::vector<CPlayerOther*> UPCs;
		UPCs.reserve(iUPCSize);

		for (auto& [_, pUPC] : m_UPCs)
			UPCs.push_back(pUPC);

		qsort(&UPCs[0], UPCs.size(), sizeof(CPlayerOther*), SortByCameraDistance);

		for(int i = iUPCSize - 1; i >= 0; i--)
		{
			if (!UPCs[i]->m_bVisible) continue;
			/*
			if(UPCs[i]->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
				continue;//this_authority
			*/

			UPCs[i]->Render(fSunAngle);
		}
	}
	
//	CPlayerNPC* pNPC = nullptr;
//	it_NPC it2 = m_NPCs.begin(), itEnd2 = m_NPCs.end();
//	for(; it2 != itEnd2; it2++)
//	{
//		pNPC = it2->second;
//		
//		pNPC->Render(true, fSunAngle);
//	}
	// 카메라 거리순으로 정렬
	int iNPCSize = static_cast<int>(m_NPCs.size());
	if (iNPCSize > 0)
	{
		std::vector<CPlayerNPC*> NPCs;
		NPCs.reserve(iNPCSize);

		for (auto& [_, pNpc] : m_NPCs)
			NPCs.push_back(pNpc);

		qsort(&NPCs[0], NPCs.size(), sizeof(CPlayerNPC*), SortByCameraDistance);

		for (int i = iNPCSize - 1; i >= 0; i--)
			NPCs[i]->Render(fSunAngle);
	}


	// 죽은놈도 렌더링..
//	CPlayerBase* pCorpse = nullptr;
//	it_NPC it3 = m_Corpses.begin(), itEnd3 = m_Corpses.end();
//	for(; it3 != itEnd3; it3++)
//	{
//		pCorpse = it3->second;
//		pCorpse->Render(false, fSunAngle);
//	}
	// 카메라 거리순으로 정렬
	int iCorpseSize = static_cast<int>(m_Corpses.size());
	if (iCorpseSize > 0)
	{
		std::vector<CPlayerNPC*> Corpses;
		Corpses.reserve(iCorpseSize);

		for (auto& [_, pCorpse] : m_Corpses)
			Corpses.push_back(pCorpse);

		qsort(&Corpses[0], iCorpseSize, sizeof(CPlayerNPC*), SortByCameraDistance);

		for (int i = iCorpseSize - 1; i >= 0; i--)
		{
			Corpses[i]->m_InfoBase.bRenderID = false;
			Corpses[i]->Render(fSunAngle);
		}
	}
}

CPlayerNPC*	CPlayerOtherMgr::NPCGetByPos(const __Vector3& vPos)
{
	CPlayerNPC*	pNPC = nullptr;
	it_NPC it = m_NPCs.begin(), itEnd = m_NPCs.end();
	for(; it != itEnd; it++)
	{
		pNPC = it->second;

		if(pNPC)
		{
			if(pNPC->m_vPosFromServer.x == vPos.x && pNPC->m_vPosFromServer.z == vPos.z)
				return pNPC;
		}
	}

	return nullptr;
}

CPlayerNPC* CPlayerOtherMgr::Pick(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick)
{
	CPlayerNPC* pNPC = this->PickNPC(ixScreen, iyScreen, iIDResult, pvPick);
	if(pNPC) return pNPC;

	CPlayerOther* pUPC = this->PickUPC(ixScreen, iyScreen, iIDResult, pvPick);
	if(pUPC) return pUPC;

	return nullptr;
}

CPlayerOther* CPlayerOtherMgr::PickUPC(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick)
{
	iIDResult = -1;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	if (!m_UPCs.empty())
	{
		// 카메라 거리순으로 정렬
		std::vector<CPlayerOther*> UPCs;
		UPCs.reserve(m_UPCs.size());

		for (auto& [_, pUPC] : m_UPCs)
			UPCs.push_back(pUPC);

		qsort(&UPCs[0], UPCs.size(), sizeof(CPlayerOther*), SortByCameraDistance);

		for (CPlayerOther* pUPC : UPCs)
		{
			// Level Of Detail 이 없는건 지나간다.
			if (pUPC->LODLevel() < 0 || pUPC->LODLevel() >= MAX_CHR_LOD)
				continue;

			CN3VMesh* pvMesh = pUPC->m_Chr.CollisionMesh();
			if(nullptr != pvMesh && pvMesh->Pick(pUPC->m_Chr.m_Matrix, vPos, vDir, pvPick)) 
			{
				iIDResult = pUPC->IDNumber();
				return pUPC;
			}
		}
	}

	return nullptr;
}

CPlayerNPC* CPlayerOtherMgr::PickNPC(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick)
{
	iIDResult = -1;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);
	
	if(!m_NPCs.empty())
	{
		// 카메라 거리순으로 정렬
		std::vector<CPlayerNPC*> NPCs;
		NPCs.reserve(m_NPCs.size());

		for (auto& [_, pNPC] : m_NPCs)
			NPCs.push_back(pNPC);

		qsort(&NPCs[0], NPCs.size(), sizeof(CPlayerNPC*), SortByCameraDistance);

		for (auto itr = NPCs.begin(); itr != NPCs.end(); ++itr)
		{
			auto pNPC = *itr;
			if(pNPC->LODLevel() < 0 || pNPC->LODLevel() >= MAX_CHR_LOD) continue; // Level Of Detail 이 없는건 지나간다.

			CN3VMesh* pvMesh = nullptr;
			__Matrix44* pMtx = nullptr;
			if(pNPC->m_pShapeExtraRef && pNPC->m_pShapeExtraRef->m_bVisible)
			{
				pvMesh = pNPC->m_pShapeExtraRef->CollisionMesh();
				pMtx = &(pNPC->m_pShapeExtraRef->m_Matrix);
			}
			if(nullptr == pvMesh)
			{
				pvMesh = pNPC->m_Chr.CollisionMesh();
				pMtx = &(pNPC->m_Chr.m_Matrix);
			}

			if(nullptr == pvMesh) continue;

			bool bPick = pvMesh->Pick(*pMtx, vPos, vDir, pvPick);
			if(bPick)
			{
				iIDResult = pNPC->IDNumber();
				return pNPC;
			}
		}
	}

	return nullptr;
}

CPlayerNPC* CPlayerOtherMgr::PickCorpse(int ixScreen, int iyScreen, int& iIDResult)
{
	iIDResult = -1;
	if(m_Corpses.empty()) return nullptr;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	// 카메라 거리순으로 정렬
	std::vector<CPlayerNPC*> Corpses;
	Corpses.reserve(m_Corpses.size());

	for (auto& [_, pCorpse] : m_Corpses)
		Corpses.push_back(pCorpse);

	qsort(&Corpses[0], m_Corpses.size(), sizeof(CPlayerNPC*), SortByCameraDistance);

	for (CPlayerNPC* pCorpse : Corpses)
	{
		// Level Of Detail 이 없는건 지나간다.
		if (pCorpse->LODLevel() < 0 || pCorpse->LODLevel() >= MAX_CHR_LOD)
			continue;

		CN3VMesh* pvMesh = pCorpse->m_Chr.CollisionMesh();
		if (pvMesh != nullptr && pvMesh->Pick(pCorpse->m_Chr.m_Matrix, vPos, vDir))
		{
			iIDResult = pCorpse->IDNumber();
			return pCorpse;
		}
	}

	return nullptr;
}

bool CPlayerOtherMgr::IsValidCharacter(CPlayerBase *pCharacter)
{
	CPlayerOther*	pUPC = nullptr;
	it_UPC it = m_UPCs.begin(), itEnd = m_UPCs.end();
	for(; it != itEnd; it++)
	{
		pUPC = it->second;
		if(pCharacter == pUPC) return true;
	}

	CPlayerNPC*	pNPC = nullptr;
	it_NPC it2 = m_NPCs.begin(), itEnd2 = m_NPCs.end();
	for(; it2 != itEnd2; it2++)
	{
		pNPC = it2->second;
		if(pCharacter == pNPC) return true;
	}

	CPlayerBase* pCorpse = nullptr;
	it_NPC it3 = m_Corpses.begin(), itEnd3 = m_Corpses.end();
	for(; it3 != itEnd3; it3++)
	{
		pCorpse = it3->second;
		if(pCharacter == pCorpse) return true;
	}

	return false;
}


void CPlayerOtherMgr::CorpseRemove(CPlayerNPC *pCorpse, bool bRemoveImmediately)
{
	if(nullptr == pCorpse) return;
	if(pCorpse->m_fTimeAfterDeath >= TIME_CORPSE_REMAIN - TIME_CORPSE_REMOVE) return;

	if(bRemoveImmediately)
		pCorpse->m_fTimeAfterDeath = TIME_CORPSE_REMAIN; // 죽은 시간을 늘려서 바로 없애준다..
	else
		pCorpse->m_fTimeAfterDeath = TIME_CORPSE_REMAIN - TIME_CORPSE_REMOVE; // 자 이제 없어질 시간이다.. 나머지는 Tick 에서 한다..
}

void CPlayerOtherMgr::CorpseAdd(CPlayerNPC* pNPC)
{
	if(nullptr == pNPC) return;
	std::pair<it_NPC, bool> result = m_Corpses.insert(val_NPC(pNPC->IDNumber(), pNPC));
	if(false == result.second) // 중복되었으면..
	{
		delete result.first->second; // 전의걸 지워주고..
		result.first->second = pNPC; // 새로 포인터 넣는다...
	}
}

CPlayerNPC*	CPlayerOtherMgr::CorpseGetNearstNPC(bool bMustHaveItem, e_Nation eNation, const __Vector3& vPosPlayer) // 가장 가까운 적 시체 가져오기..
{
	CPlayerNPC* pTarget = nullptr;
	float fDistMin = FLT_MAX, fDistTmp = 0;

	it_NPC it2 = m_NPCs.begin(), itEnd2 = m_NPCs.end();
	for(; it2 != itEnd2; it2++)
	{
		CPlayerNPC* pNPC = it2->second;
		if(eNation == pNPC->m_InfoBase.eNation) continue;
		if(bMustHaveItem && pNPC->m_iDroppedItemID <= 0) continue;
		
		fDistTmp = pNPC->Distance(vPosPlayer);
		if(fDistTmp < fDistMin)
		{
			pTarget = pNPC;
			fDistMin = fDistTmp;
		}
	}

	return pTarget;
}

void CPlayerOtherMgr::MoveToCorpsesForcely(CPlayerNPC* pNPC, bool bErase)
{
	if(nullptr == pNPC) return;

	int iID = pNPC->IDNumber();
	pNPC->Action(PSA_DEATH, false, nullptr, true); // 강제로 죽인다..
	if(bErase) pNPC->m_fTimeAfterDeath = TIME_CORPSE_REMAIN - 10.0f; // 죽은 시간을 세팅...
	else pNPC->m_fTimeAfterDeath = 0.1f;

	it_UPC it = m_UPCs.find(iID); // User를 찾아보고...
	if(it != m_UPCs.end())
	{
		if( bErase ) //삭제일때는 시체로 만든다
		{//중복으로 인해서 캐릭터를 시체로 만든다.
			CPlayerOther* pUPC = it->second;
			this->CorpseAdd(pUPC); // 시체로 만들고..
			m_UPCs.erase(it); // 맵에서 지운다.
		}

//		CPlayerOther* pUPC = it->second;
//		this->CorpseAdd(pUPC); // 시체로 만들고..
//		m_UPCs.erase(it); // 맵에서 지운다.
	}
	else
	{
		it_NPC it2 = m_NPCs.find(iID);
		if(it2 != m_NPCs.end())
		{
			CPlayerNPC* pNPC = it2->second; 
			this->CorpseAdd(pNPC); // 시체로 만들고..
			m_NPCs.erase(it2); // 맵에서 지운다.
		}
	}
}

CPlayerNPC*	CPlayerOtherMgr::CharacterGetByNearestEnemy(const __Vector3& vPosPlayer) // 가장 가까운 적 가져오기..
{
	CPlayerNPC* pTarget = nullptr;
	float fDistMin = FLT_MAX, fDistTmp = 0;

	it_UPC it = m_UPCs.begin(), itEnd = m_UPCs.end();
	CPlayerNPC* pNPC = nullptr;
	for(; it != itEnd; it++)
	{
		pNPC = it->second;
		if (!s_pPlayer->IsHostileTarget(pNPC))
			continue;

		fDistTmp = pNPC->Distance(vPosPlayer);
		if(fDistTmp < fDistMin)
		{
			pTarget = pNPC;
			fDistMin = fDistTmp;
		}
	}

	it_NPC it2 = m_NPCs.begin(), itEnd2 = m_NPCs.end();
	for(; it2 != itEnd2; it2++)
	{
		pNPC = it2->second;
		if (!s_pPlayer->IsHostileTarget(pNPC))
			continue;
	
		fDistTmp = pNPC->Distance(vPosPlayer);
		if(fDistTmp < fDistMin)
		{
			pTarget = pNPC;
			fDistMin = fDistTmp;
		}
	}

	return pTarget;
}

bool CPlayerOtherMgr::CharacterDelete(int iID) // User, NPC 안 가리고 지운다..
{
	it_UPC it = m_UPCs.find(iID); // User를 찾아보고...
	if(it != m_UPCs.end())
	{
		CPlayerOther* pUPC = it->second;
		delete pUPC;
		m_UPCs.erase(it); // 맵에서 지운다.
		return true;
	}

	it_NPC it2 = m_NPCs.find(iID);
	if(it2 != m_NPCs.end())
	{
		CPlayerNPC* pNPC = it2->second; 
		delete pNPC;
		m_NPCs.erase(it2); // 맵에서 지운다.
		return true;
	}

	return false;
}

CPlayerNPC* CPlayerOtherMgr::CharacterGetByNearestNPC(const __Vector3& vPosPlayer)
{
	CPlayerNPC* pTarget = nullptr;

	const float fMaxViewDistance = static_cast<float>(s_Options.iViewDist);
	float fDistMin = FLT_MAX;

	for (const auto& [_, pNPC] : m_NPCs)
	{
		float fDist = pNPC->Distance(vPosPlayer);

		// filter out NPCs that are further away than max view distance
		if (fDist > fMaxViewDistance)
			continue;

		if (fDist < fDistMin)
		{
			fDistMin = fDist;
			pTarget = pNPC;
		}
	}

	return pTarget;
}

int CPlayerOtherMgr::SortByCameraDistance(const void* pArg1, const void* pArg2)
{
	CPlayerBase* pPlayer1 = *((CPlayerBase**)pArg1);
	CPlayerBase* pPlayer2 = *((CPlayerBase**)pArg2);

	float fDist1 = 0.0f, fDist2 = 0.0f;
	
	if(pPlayer1) fDist1 = (CN3Base::s_CameraData.vEye - pPlayer1->Position()).Magnitude();
	if(pPlayer2) fDist2 = (CN3Base::s_CameraData.vEye - pPlayer2->Position()).Magnitude();

	if(fDist1 < fDist2) return -1; // 가까우면 true;
	else if(fDist1 > fDist2) return 1;
	else return 0;
}

void CPlayerOtherMgr::CorpseAdd(int iID)
{
	it_UPC it = m_UPCs.find(iID); // User를 찾아보고...
	if(it != m_UPCs.end())
	{
		CPlayerOther* pUPC = it->second;

		pUPC->Action(PSA_DEATH, false, nullptr, true); // 강제로 죽인다..
		pUPC->m_fTimeAfterDeath = TIME_CORPSE_REMAIN - 10.0f; // 죽은 시간을 세팅...

		this->CorpseAdd(pUPC); // 시체로 만들고..
		m_UPCs.erase(it); // 맵에서 지운다.
	}
}

CPlayerNPC* CPlayerOtherMgr::PickAllPrecisely(int ixScreen, int iyScreen, int &iIDResult, __Vector3* pvPick)
{
	iIDResult = -1;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	CPlayerNPC* pNPC = nullptr; // NPC라기 보다는 캐릭터 포인터

	// 카메라 거리순으로 정렬
	std::vector<CPlayerNPC*> NPCs;
	std::vector<CPlayerNPC*> NUPCBufs;
	if (m_NPCs.empty() && m_UPCs.empty())
		return nullptr;

	NPCs.reserve(m_NPCs.size() + m_UPCs.size());

	for (auto& [_, pNPC] : m_NPCs)
		NPCs.push_back(pNPC);

	for (auto& [_, pUPC] : m_UPCs)
		NPCs.push_back(pUPC);

	qsort(&NPCs[0], NPCs.size(), sizeof(CPlayerNPC*), SortByCameraDistance);

	for (CPlayerNPC* pNPC : NPCs)
	{
		if (pNPC == nullptr)
			continue;

		// Level Of Detail 이 없는건 지나간다.
		if (pNPC->LODLevel() < 0 || pNPC->LODLevel() >= MAX_CHR_LOD)
			continue;

		CN3VMesh* pvMesh = nullptr;
		__Matrix44* pMtx = nullptr;
		if(pNPC->m_pShapeExtraRef && pNPC->m_pShapeExtraRef->m_bVisible)
		{
			pvMesh = pNPC->m_pShapeExtraRef->CollisionMesh();
			pMtx = &(pNPC->m_pShapeExtraRef->m_Matrix);
			if(nullptr == pvMesh)
			{
				pvMesh = pNPC->m_Chr.CollisionMesh();
				pMtx = &(pNPC->m_Chr.m_Matrix);
			}

			if(nullptr == pvMesh) continue;
			bool bPick = pvMesh->Pick(*pMtx, vPos, vDir, pvPick);
			if(bPick)
			{
				NUPCBufs.push_back(pNPC);
			}
			continue;
		}
		else
		{
			pvMesh = pNPC->m_Chr.CollisionMesh();
			pMtx = &(pNPC->m_Chr.m_Matrix);

			if(nullptr == pvMesh) continue;
			bool bPick = pvMesh->Pick(*pMtx, vPos, vDir, pvPick);
			if(bPick)
			{
				NUPCBufs.push_back(pNPC);
			}
			continue;
		}
	}
	
////////////////////////////////////////////////////////////////////////////
//	NPC와 UPC를 따로 충돌체크를 하게 되면 UPC가 나와 가까이 있어도 
//	뒤에 있는 NPC를 먼저 찾아내기 때문에 UPC와 NPC를 동시에 카메라에 정렬하여
//	충돌 체크를 해줘야 정확한 캐릭터를 찾아 낼수가 있다.
////////////////////////////////////////////////////////////////////////////

	if(NUPCBufs.size() == 1)
	{
		pNPC = NUPCBufs[0];
		if(pNPC)
		{
			iIDResult = pNPC->IDNumber();
			return pNPC;
		}
	}

	for (auto itr = NUPCBufs.begin(); itr != NUPCBufs.end(); ++itr)
	{
		pNPC = *itr;
		if(pNPC->LODLevel() < 0 || pNPC->LODLevel() >= MAX_CHR_LOD) continue; // Level Of Detail 이 없는건 지나간다.

		CN3VMesh* pvMesh = nullptr;
		__Matrix44* pMtx = nullptr;
		if(pNPC->m_pShapeExtraRef && pNPC->m_pShapeExtraRef->m_bVisible)
		{
			iIDResult = pNPC->IDNumber();
			return pNPC;
		}

		if(pNPC->m_Chr.CheckCollisionPrecisely(ixScreen ,iyScreen, pvPick) != -1)
		{
			iIDResult = pNPC->IDNumber();
			return pNPC;
		}
	}

	return nullptr;
}

CPlayerNPC* CPlayerOtherMgr::PickNPCPrecisely(int ixScreen, int iyScreen, int &iIDResult, __Vector3* pvPick)
{
	iIDResult = -1;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);
	
	if(!m_NPCs.empty())
	{
		// 카메라 거리순으로 정렬
		std::vector<CPlayerNPC*> NPCs;
		NPCs.reserve(m_NPCs.size());

		for (auto& [_, pNPC] : m_NPCs)
			NPCs.push_back(pNPC);

		qsort(&NPCs[0], NPCs.size(), sizeof(CPlayerNPC*), SortByCameraDistance);

		// NPC 를 먼저 찍어본다...
		for (CPlayerNPC* pNPC : NPCs)
		{
			// Level Of Detail 이 없는건 지나간다.
			if (pNPC->LODLevel() < 0 || pNPC->LODLevel() >= MAX_CHR_LOD)
				continue;

			CN3VMesh* pvMesh = nullptr;
			__Matrix44* pMtx = nullptr;
			if(pNPC->m_pShapeExtraRef && pNPC->m_pShapeExtraRef->m_bVisible)
			{
				pvMesh = pNPC->m_pShapeExtraRef->CollisionMesh();
				pMtx = &(pNPC->m_pShapeExtraRef->m_Matrix);
				if(nullptr == pvMesh)
				{
					pvMesh = pNPC->m_Chr.CollisionMesh();
					pMtx = &(pNPC->m_Chr.m_Matrix);
				}

				if(nullptr == pvMesh) continue;
				bool bPick = pvMesh->Pick(*pMtx, vPos, vDir, pvPick);
				if(bPick)
				{
					iIDResult = pNPC->IDNumber();
					return pNPC;
				}
				continue;
			}

			if(pNPC->m_Chr.CheckCollisionPrecisely(ixScreen ,iyScreen, pvPick) != -1)
			{
				iIDResult = pNPC->IDNumber();
				return pNPC;
			}
		}
	}

	return nullptr;
}

CPlayerOther* CPlayerOtherMgr::PickUPCPrecisely(int ixScreen, int iyScreen, int &iIDResult, __Vector3* pvPick)
{
	iIDResult = -1;

	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		ixScreen, iyScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	if(!m_UPCs.empty())
	{
		// 카메라 거리순으로 정렬
		std::vector<CPlayerOther*> UPCs;
		UPCs.reserve(m_UPCs.size());

		for (auto& [_, pUPC] : m_UPCs)
			UPCs.push_back(pUPC);

		qsort(&UPCs[0], UPCs.size(), sizeof(CPlayerOther*), SortByCameraDistance);

		CPlayerOther*	pUPC = nullptr;
		for (auto itr = UPCs.begin(); itr != UPCs.end(); ++itr)
		{
			pUPC = *itr;
			if(pUPC->LODLevel() < 0 || pUPC->LODLevel() >= MAX_CHR_LOD) continue; // Level Of Detail 이 없는건 지나간다.

			if(pUPC->m_Chr.CheckCollisionPrecisely(ixScreen ,iyScreen, pvPick) != -1)
			{
				iIDResult = pUPC->IDNumber();
				return pUPC;
			}
		}
	}

	return nullptr;
}

CPlayerNPC* CPlayerOtherMgr::PickPrecisely(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick)
{
	CPlayerNPC* pNPC = this->PickAllPrecisely(ixScreen, iyScreen, iIDResult, pvPick);
	if(pNPC) return pNPC;

	return nullptr;
}

// ===== END WarFare/PlayerOtherMgr.cpp =====

// ===== BEGIN WarFare/PlayerOtherMgr.h =====
#line 1 "WarFare/PlayerOtherMgr.h"
﻿// PlayerOtherMgr.h: interface for the CPlayerOtherMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PlayerOtherMgr_H__B32C59B8_6C08_494E_B9DE_338B3CD026C5__INCLUDED_)
#define AFX_PlayerOtherMgr_H__B32C59B8_6C08_494E_B9DE_338B3CD026C5__INCLUDED_

#include <map>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PlayerOther.h"
#include "GameBase.h"
#include "GameProcedure.h"

//typedef std::list<CPlayerOther*>::iterator it_UPC;
//typedef std::list<CPlayerNPC*>::iterator it_NPC;
//typedef std::list<CPlayerBase*>::iterator it_BPC;

typedef std::map<int, CPlayerOther*>::iterator it_UPC;
typedef std::map<int, CPlayerNPC*>::iterator it_NPC;
typedef std::map<int, CPlayerBase*>::iterator it_BPC;

typedef std::map<int, CPlayerOther*>::value_type val_UPC;
typedef std::map<int, CPlayerNPC*>::value_type val_NPC;
typedef std::map<int, CPlayerBase*>::value_type val_BPC;

class CPlayerOtherMgr : public CGameBase
{
public:
//	std::list<CPlayerNPC*>		m_NPCs;		// NPC
//	std::list<CPlayerOther*>	m_UPCs;		// User Player Character
//	std::list<CPlayerNPC*>		m_Corpses;	// 죽은놈.. 죽는 에니메이션 및 시간이 지나면 없어지게 한다..
	std::map<int, CPlayerNPC*>		m_NPCs;		// NPC
	std::map<int, CPlayerOther*>	m_UPCs;		// User Player Character
	std::map<int, CPlayerNPC*>		m_Corpses;	// 죽은놈.. 죽는 에니메이션 및 시간이 지나면 없어지게 한다..
	int								m_iChrCountToRender; // 렌더링되는 캐릭 카운트

public:
	bool				IsValidCharacter(CPlayerBase* pCharacter);
	void				Tick(const __Vector3& vPosPlayer);
	void				Render(float fSunAngle);

	void				NPCAdd(CPlayerNPC* pNPC);
	bool				NPCDelete(int iID);								// 고유 ID 와 일치하는 NPC를 리스트에서 제거.. 및 리소스 해제 
	void				UPCAdd(CPlayerOther* pPlayer);
	bool				UPCDelete(int iID);								// 고유 ID 와 일치하는 NPC를 리스트에서 제거.. 및 리소스 해제 

//	CPlayerOther*		UPCGetByName(const char* szID);					// User Player Character 와 NPC 를 조사해서 포인터를 가져온다.
	CPlayerOther*		UPCGetByID(int iID, bool bFromAliveOnly);		// User Player Character 와 NPC 를 조사해서 포인터를 가져온다.
//	CPlayerNPC*			NPCGetByName(const char* szID);					// User Player Character 와 NPC 를 조사해서 포인터를 가져온다.
	CPlayerNPC*			NPCGetByID(int iID, bool bFromAliveOnly);		// User Player Character 와 NPC 를 조사해서 포인터를 가져온다.
	CPlayerNPC*			NPCGetByPos(const __Vector3& vPos);
	CPlayerNPC*			CharacterGetByID(int iID, bool bFromAliveOnly); // User, NPC 안 가리고 가져온다..
	CPlayerNPC*			CharacterGetByNearestEnemy(const __Vector3& vPosPlayer); // 가장 가까운 적 가져오기..
	CPlayerNPC*			CharacterGetByNearestNPC(const __Vector3& vPosPlayer);
	bool				CharacterDelete(int iID); // User, NPC 안 가리고 지운다..

	CPlayerBase*		CorpseGetByID(int iID);							// 시체들에서 Player Character 와 NPC 를 조사해서 포인터를 가져온다.
	void				CorpseRemove(CPlayerNPC* pCorpse, bool bRemoveImmediately = false);
	void				CorpseAdd(CPlayerNPC* pNPC);
	void				CorpseAdd(int iID);
	CPlayerNPC*			CorpseGetNearstNPC(bool bMustHaveItem, e_Nation eNation, const __Vector3& vPosPlayer); // 가장 가까운 적 시체 가져오기..
	void				MoveToCorpsesForcely(CPlayerNPC* pNPC, bool bErase);			// 아이디가 겹치거나 하면 강제로 시체를 만든다..


	//.. Picking된 PlayerOther 계산..
	CPlayerNPC*			Pick(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerNPC*			PickNPC(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerOther*		PickUPC(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerNPC*			PickPrecisely(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerNPC*			PickNPCPrecisely(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerOther*		PickUPCPrecisely(int ixScreen, int iyScreen, int& iIDResult, __Vector3* pvPick = nullptr);
	CPlayerNPC*			PickAllPrecisely(int ixScreen, int iyScreen, int &iIDResult, __Vector3* pvPick);
	CPlayerNPC*			PickCorpse(int ixScreen, int iyScreen, int& iIDResult); // 시체중 클릭..
	static int			SortByCameraDistance(const void* pArg1, const void* pArg2);

	void				ReleaseUPCs();
	void				ReleaseNPCs();
	void				ReleaseCorpses();
	void				Release();

	CPlayerOtherMgr();
	virtual ~CPlayerOtherMgr();
};

inline CPlayerOther* CPlayerOtherMgr::UPCGetByID(int iID, bool bFromAliveOnly)
{
	it_UPC it = m_UPCs.find(iID);
	if(it != m_UPCs.end())
	{
		CPlayerOther* pUPC = it->second;
		if(bFromAliveOnly)
		{
			if(PSA_DEATH != pUPC->m_eState) return pUPC;
			else return nullptr;
		}
		else return pUPC;
	}
	else return nullptr;
}

inline CPlayerNPC* CPlayerOtherMgr::NPCGetByID(int iID, bool bFromAliveOnly)
{
	it_NPC it = m_NPCs.find(iID);
	if(it != m_NPCs.end())
	{
		CPlayerNPC* pNPC = it->second;
		if(bFromAliveOnly)
		{
			if(PSA_DEATH != pNPC->m_eState) return pNPC;
			else return nullptr;
		}
		else return pNPC;
	}
	else return nullptr;
}

inline CPlayerBase* CPlayerOtherMgr::CorpseGetByID(int iID)
{
	it_NPC it = m_Corpses.find(iID);
	if(it != m_Corpses.end()) return it->second;
	else return nullptr;
}

inline CPlayerNPC* CPlayerOtherMgr::CharacterGetByID(int iID, bool bFromAliveOnly)
{
	if(iID < 0) return 0;

	CPlayerNPC* pBPC = this->NPCGetByID(iID, bFromAliveOnly);		// 먼저  NPC 중에서 찾아보고..
	if(nullptr == pBPC) pBPC = this->UPCGetByID(iID, bFromAliveOnly);			// 없음 User 들도 찾아본다..

	return pBPC;
}

inline void CPlayerOtherMgr::UPCAdd(CPlayerOther* pUPC)
{
	it_UPC it = m_UPCs.find(pUPC->IDNumber());
	if(it == m_UPCs.end()) // 중복된게 없으면..
	{
		m_UPCs.insert(val_UPC(pUPC->IDNumber(), pUPC));
	}
	else // 중복되었으면..
	{
		delete it->second;
		it->second = pUPC;
	}
}

inline bool CPlayerOtherMgr::UPCDelete(int iID)
{
	it_UPC it = m_UPCs.find(iID);
	if(it == m_UPCs.end()) return false;

	delete it->second;
	m_UPCs.erase(it);
	return true;
}

inline void CPlayerOtherMgr::NPCAdd(CPlayerNPC* pNPC)
{
	it_NPC it = m_NPCs.find(pNPC->IDNumber());
	if(it == m_NPCs.end()) // 중복된게 없으면..
	{
		m_NPCs.insert(val_NPC(pNPC->IDNumber(), pNPC));
	}
	else // 중복되었으면..
	{
		delete it->second;
		it->second = pNPC;
	}
}

inline bool CPlayerOtherMgr::NPCDelete(int iID)
{
	it_NPC it = m_NPCs.find(iID);
	if(it == m_NPCs.end()) return false;

	delete it->second;
	m_NPCs.erase(it);
	return true;
}

#endif // !defined(AFX_PlayerOtherMgr_H__B32C59B8_6C08_494E_B9DE_338B3CD026C5__INCLUDED_)

// ===== END WarFare/PlayerOtherMgr.h =====

// ===== BEGIN WarFare/PortalVolume.cpp =====
#line 1 "WarFare/PortalVolume.cpp"
﻿// PortalVolume.cpp: implementation of the CPortalVolume class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PortalVolume.h"
#include "GameBase.h"
#include "PlayerMySelf.h"

#include "PvsMgr.h"

#include <N3Base/N3ShapeMgr.h>
#include <N3Base/N3ShapeExtra.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPortalVolume::CPortalVolume()	: m_fOffs(0.001f), m_fHeightOffs(0.01f), m_fVolOffs(0.001f), m_fPickIncline(0.6f), m_fCameraOffs(0.4f)
{
	m_pvVertex[0].Set(-fBaseVolumnSize, -fBaseVolumnSize,  fBaseVolumnSize);
	m_pvVertex[1].Set( fBaseVolumnSize, -fBaseVolumnSize,  fBaseVolumnSize);
	m_pvVertex[2].Set( fBaseVolumnSize, -fBaseVolumnSize, -fBaseVolumnSize);
	m_pvVertex[3].Set(-fBaseVolumnSize, -fBaseVolumnSize, -fBaseVolumnSize);
	m_pvVertex[4].Set(-fBaseVolumnSize,  fBaseVolumnSize,  fBaseVolumnSize);
	m_pvVertex[5].Set( fBaseVolumnSize,  fBaseVolumnSize,  fBaseVolumnSize);
	m_pvVertex[6].Set( fBaseVolumnSize,  fBaseVolumnSize, -fBaseVolumnSize);
	m_pvVertex[7].Set(-fBaseVolumnSize,  fBaseVolumnSize, -fBaseVolumnSize);

	uint16_t*		pIdx = m_pIndex;

	// 아랫면.
	*pIdx++ = 0;  *pIdx++ = 1;  *pIdx++ = 3;
	*pIdx++ = 2;  *pIdx++ = 3;  *pIdx++ = 1;

	// 앞면..
	*pIdx++ = 7;  *pIdx++ = 3;  *pIdx++ = 6;
	*pIdx++ = 2;  *pIdx++ = 6;  *pIdx++ = 3;

	// 왼쪽..
	*pIdx++ = 4;  *pIdx++ = 0;  *pIdx++ = 7;
	*pIdx++ = 3;  *pIdx++ = 7;  *pIdx++ = 0;

	// 오른쪽..
	*pIdx++ = 6;  *pIdx++ = 2;  *pIdx++ = 5;
	*pIdx++ = 1;  *pIdx++ = 5;  *pIdx++ = 2;

	// 뒷면..
	*pIdx++ = 5;  *pIdx++ = 1;  *pIdx++ = 4;
	*pIdx++ = 0;  *pIdx++ = 4;  *pIdx++ = 1;

	// 윗면..	
	*pIdx++ = 4;  *pIdx++ = 7;  *pIdx++ = 5;
	*pIdx++ = 6;  *pIdx++ = 5;  *pIdx++ = 7;

	m_iID = -1;
	m_pManager = nullptr;
	m_iPriority = 100;

	m_eRenderType = TYPE_UNKNOWN;
}

CPortalVolume::~CPortalVolume()
{
	DeleteAllPvsObj();
}

void CPortalVolume::DeleteAllPvsObj()
{
	ShapeInfo* pSI;
	siiter siit = m_plShapeInfoList.begin();
	while(siit != m_plShapeInfoList.end())
	{
		pSI = *siit++;
		delete pSI;
	}
	m_plShapeInfoList.clear();	

	ShapePart* pSP;
	spiter spit = m_lpShapePartList.begin();
	while(spit != m_lpShapePartList.end())
	{
		pSP = *spit++;
		pSP->Clear();
		delete pSP;
	}
	m_lpShapePartList.clear();

	__ColIndex* pCI;
	ciiter ciit = m_lpShapeColPartList.begin();
	while(ciit != m_lpShapeColPartList.end())
	{
		pCI = *ciit++;
		delete pCI;
	}
	m_lpShapeColPartList.clear();

	m_piVisibleIDList.clear();
	m_pVisiblePvsList.clear();
}

bool CPortalVolume::IsInVolumn(__Vector3 vec)
{
	__Vector3 vec2[8];
	for( int i = 0; i < 8; i++)
	{
		vec2[i] = m_pvVertex[i];
		vec2[i] *= m_Matrix;
	}

	if (vec.x >= vec2[0].x && vec.x <= vec2[1].x && vec.y >= vec2[0].y && vec.y <= vec2[4].y && vec.z >=  vec2[2].z && vec.z <= vec2[0].z )
		return true;

	return false;
}

void CPortalVolume::Render()
{
	DWORD dwAlpha, dwFog, dwLight, dwPointSize;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_LIGHTING, &dwLight);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_POINTSIZE , &dwPointSize);
	
	if(dwFog) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	if(dwAlpha) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	if(dwLight) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, FALSE);

	static __Material smtl;
	static bool bInit = false;
	if(false == bInit)
	{
		smtl.Init();
		bInit = true;
	}

	__Matrix44 mtxWorld;
	mtxWorld.Identity();

	CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D());
	CN3Base::s_lpD3DDev->SetTexture(0, nullptr);

	// Shape..
	RenderShape();	

#ifdef _DEBUG
	RenderCollision();	
#endif 

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_POINTSIZE, dwPointSize);
	if(dwFog) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	if(dwAlpha) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	if(dwLight) CN3Base::s_lpD3DDev->SetRenderState(D3DRS_LIGHTING, dwLight);
}

void CPortalVolume::RenderShape()
{
	ShapeInfo* pSI;
	siiter siit = m_plShapeInfoList.begin();
	while(siit != m_plShapeInfoList.end())
	{
		pSI = *siit++;

		pSI->m_pShape->PosSet(pSI->Pos());
		pSI->m_pShape->RotSet(pSI->Rot());
		pSI->m_pShape->ScaleSet(pSI->Scale());
		pSI->m_pShape->Tick(-1000);
		pSI->m_pShape->m_bDontRender = false;
		pSI->m_pShape->Render();

		// 로딩할때 미리 계산해 놓은 월드 행렬 적용..
		__Matrix44 mtxBackup;
		CN3Base::s_lpD3DDev->GetTransform(D3DTS_WORLD, mtxBackup.toD3D());
		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, pSI->m_pShape->m_Matrix.toD3D());

#ifdef _DEBUG
		if (pSI->m_pShape->CollisionMesh())
			pSI->m_pShape->CollisionMesh()->Render(0xffffffff);
#endif 

		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxBackup.toD3D());
	}

	ShapePart* pSP = nullptr;
	spiter spit = m_lpShapePartList.begin();
	while( spit != m_lpShapePartList.end())
	{
		pSP = *spit++;

		viter vit =	pSP->m_viIndex.begin();
		__VPI vpi;

		while (vit != pSP->m_viIndex.end())
		{
			vpi = *vit++;

			size_t vecSize = vpi.m_ivVector.size();

			LPWORD pIndices;
			pIndices = new uint16_t[vecSize];
			memset(pIndices, 0, sizeof(uint16_t) * vecSize);

			for (size_t k = 0; k < vecSize; k++)
				pIndices[k] = vpi.m_ivVector[k];

			pSI = CPvsMgr::GetShapeInfoByManager(pSP->m_iID);
			pSI->m_pShape->PosSet(pSI->Pos());
			pSI->m_pShape->RotSet(pSI->Rot());
			pSI->m_pShape->ScaleSet(pSI->Scale());
			pSI->m_pShape->Part(vpi.m_iPartIndex)->m_bOutOfCameraRange = FALSE;
			pSI->m_pShape->PartialRender(vpi.m_iPartIndex, static_cast<int>(vecSize), pIndices);
			delete pIndices;
		}
	}
}

void CPortalVolume::RenderCollision()
{
	__ColIndex * pCI = nullptr;
	ShapeInfo* pSI = nullptr;

	ciiter ciit = m_lpShapeColPartList.begin();
	while(ciit != m_lpShapeColPartList.end())
	{
		pCI = *ciit++;

		// 행렬 계산..
		__Matrix44 mtxWorld;
		mtxWorld.Identity();

		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D());

		size_t vecSize = pCI->m_ivVector.size();
		uint32_t* pIndices = new uint32_t[vecSize];
		memset(pIndices, 0, sizeof(uint32_t) * vecSize);

		for (size_t k = 0; k < vecSize; k++)
			pIndices[k] = pCI->m_ivVector[k];

		__Matrix44 mtxBackup;
		CN3Base::s_lpD3DDev->GetTransform(D3DTS_WORLD, mtxBackup.toD3D());
		pSI = CPvsMgr::GetShapeInfoByManager(pCI->m_iID);
		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, pSI->m_Matrix.toD3D());
		pSI->m_pShape->PartialColRender(
			static_cast<int>(vecSize),
			reinterpret_cast<int*>(pIndices));
		delete pIndices;

		CN3Base::s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxBackup.toD3D());
	}
}

//////////////////////////////////////////////////////////////////////

bool CPortalVolume::Load(File& file)
{
	CN3Transform::Load(file);

	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];

	// 자신의 데이터 로드..
	std::string strSrc, strDest;

	// 링크된 갯수를 로드..	일단 읽구 버린다..
	int iLinkedCount = 0, iTID, iEWT;
	file.Read(&iLinkedCount, sizeof(int));
	for( int i = 0; i < iLinkedCount; i++ )
	{
		file.Read(&iTID, sizeof(int));
		file.Read(&iEWT, sizeof(int));
	}

	// 링크된 Shape 갯수 로드..
	int iCount = 0;
	file.Read(&iCount, sizeof(int));
	for (int i = 0; i < iCount; i++)
	{
		ShapeInfo*	pSI = new ShapeInfo;
		file.Read(&pSI->m_iID, sizeof(int));

		// 문자열 길이..
		strSrc = CPvsMgr::ReadDecryptString(file);
		_splitpath(strSrc.c_str(), szDrive, szDir, szFName, szExt);
		strDest = szFName;	strDest +=  szExt;
		pSI->m_strShapeFile = m_pManager->GetIndoorFolderPath() + strDest;
		file.Read(&pSI->m_iBelong, sizeof(int));	
		file.Read(&pSI->m_iEventID, sizeof(int));	
		file.Read(&pSI->m_iEventType, sizeof(int));	
		file.Read(&pSI->m_iNPC_ID, sizeof(int));	
		file.Read(&pSI->m_iNPC_Status, sizeof(int));	
		if (pSI->m_iEventID || pSI->m_iEventType || pSI->m_iNPC_ID || pSI->m_iNPC_Status ) // 이벤트가 있으면
			pSI->m_pShape = CPvsMgr::s_MngShapeExt.Get(m_pManager->GetIndoorFolderPath() + strDest);
		else
			pSI->m_pShape = CPvsMgr::s_MngShape.Get(m_pManager->GetIndoorFolderPath() + strDest);

		__ASSERT(pSI->m_pShape, "Shape Not Found");
		pSI->Load(file);
		m_plShapeInfoList.push_back(pSI);		
	}

	// Visible..
	IDAndPriority IDAP;
	file.Read(&iCount, sizeof(int));

	for(int i = 0; i < iCount; i++ )
	{
		file.Read(&IDAP.m_iID, sizeof(int));
		file.Read(&IDAP.m_iPriority, sizeof(int));
		__ASSERT(IDAP.m_iPriority != -1, "잘못된 파일");
		m_piVisibleIDList.push_back(IDAP);
	}

	file.Read(&iCount, sizeof(int));

	int iSize_2 = 0, iSize_3 = 0;
	for(int i = 0; i < iCount; i++ )
	{
		ShapePart* pSP = new ShapePart;
		file.Read(&pSP->m_iID, sizeof(int));
		
		file.Read(&iSize_2, sizeof(int));
		for( int j = 0; j <iSize_2; j++ )
		{
			__VPI vpi;
			file.Read(&vpi.m_iPartIndex, sizeof(int));

			file.Read(&iSize_3, sizeof(int));
			for( int k = 0; k < iSize_3; k++ )
			{
				int iV = 0;
				file.Read(&iV, sizeof(int));
				vpi.m_ivVector.push_back(iV);
			}

			pSP->m_viIndex.push_back(vpi);	
		}

		m_lpShapePartList.push_back(pSP);
	}

	file.Read(&iCount, sizeof(int));

	for(int i = 0; i < iCount; i++ )
	{
		__ColIndex* pCI = new __ColIndex;
		file.Read(&pCI->m_iID, sizeof(int));		

		file.Read(&iSize_2, sizeof(int));
		for( int j = 0; j <iSize_2; j++ )
		{
			int iV = 0;			
			file.Read(&iV, sizeof(int));
			pCI->m_ivVector.push_back(iV);
		}

		m_lpShapeColPartList.push_back(pCI);
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////////

bool CPortalVolume::CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	float fPlayerHeight = CGameBase::s_pPlayer->Position().y;

	bool bCollision = false;
	bool bColl = false;
	__Vector3 vDir = vEyeResult- vAt;	vDir.Normalize();
	__ColIndex * pCI = nullptr;

	ciiter ciit = m_lpShapeColPartList.begin();
	while(ciit != m_lpShapeColPartList.end())
	{
		pCI = *ciit++;

		size_t vecSize = pCI->m_ivVector.size();
		__Vector3 vA, vB, vC, vPick;
		float t, u, v;

		ShapeInfo* pSI = CPvsMgr::GetShapeInfoByManager(pCI->m_iID);
		pSI->m_pShape->PosSet(pSI->Pos());
		pSI->m_pShape->RotSet(pSI->Rot());
		pSI->m_pShape->ScaleSet(pSI->Scale());
		pSI->m_pShape->Tick(-1000);
		CN3Shape* pShape = pSI->m_pShape;

		for (size_t k = 0; k < vecSize / 3; k++)
		{
			pShape->PartialGetCollision(pCI->m_ivVector[k*3], vA);			vA *= pShape->m_Matrix;		vA.y += m_fCameraOffs;
			pShape->PartialGetCollision(pCI->m_ivVector[k*3+1], vB);		vB *= pShape->m_Matrix;		vB.y += m_fCameraOffs;
			pShape->PartialGetCollision(pCI->m_ivVector[k*3+2], vC);		vC *= pShape->m_Matrix;		vC.y += m_fCameraOffs;

			__Vector3 vEdge1 = vB - vA;
			__Vector3 vEdge2 = vC - vA;
			__Vector3 pVec;	
			pVec.Cross(vEdge1, vEdge2);	pVec.Normalize();	pVec *= m_fOffs;	vA += pVec;	vB += pVec; vC += pVec;

			bColl = ::_IntersectTriangle(vAt, vDir, vA, vB, vC, t, u, v, &vPick);
			if (bColl)
			{
				if ((vPick - vAt).Magnitude() < fNP)	
				{
					vEyeResult = vPick;
					bCollision = true;
				}
			}
		}
	}

	return bCollision;
}

bool CPortalVolume::CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	bool bCollision = false;
	bool bColl = false;
	__Vector3 vDir = vEyeResult- vAt;	vDir.Normalize();
	ShapeInfo* pSI = nullptr;

	siiter siit = m_plShapeInfoList.begin();
	while(siit != m_plShapeInfoList.end())
	{
		pSI = *siit++;

		int iSize = pSI->m_pShape->GetColIndexbufferCount();
		__Vector3 vA, vB, vC, vPick;
		float t,u,v;

		for( int k = 0; k < iSize/3; k++)
		{
			vA = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3));		 vA *= pSI->m_Matrix;
			vB = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+1));		 vB *= pSI->m_Matrix;
			vC = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+2));		 vC *= pSI->m_Matrix;

			__Vector3 vEdge1 = vB - vA;
			__Vector3 vEdge2 = vC - vA;
			__Vector3 pVec;	
			pVec.Cross(vEdge1, vEdge2);	pVec.Normalize();	pVec *= m_fOffs;	vA += pVec;	vB += pVec; vC += pVec;

			bColl = ::_IntersectTriangle(vAt, vDir, vA, vB, vC, t, u, v, &vPick);
			if (bColl)
			{
				if ((vPick - vAt).Magnitude() < fNP)	
				{
					vEyeResult = vPick;
					bCollision = true;
				}
			}
		}
	}

	return bCollision;
}

bool CPortalVolume::GetHeightWithTerrain(float fx, float fz, float& fy)
{
	CPortalVolume* pVol = nullptr;

	VisPortalPriority vPP;
	vppiter vppit = m_pVisiblePvsList.begin();
	while( vppit != m_pVisiblePvsList.end())
	{
		vPP = *vppit++;
		if (vPP.m_iPriority > 1)
			continue;	

		pVol = vPP.m_pVol;

		__ColIndex * pCI = nullptr;
		ciiter ciit = pVol->m_lpShapeColPartList.begin();
		while(ciit != pVol->m_lpShapeColPartList.end())
		{
			pCI = *ciit++;

			size_t vecSize = pCI->m_ivVector.size();
			__Vector3 vA, vB, vC;
			ShapeInfo* pSI = CPvsMgr::GetShapeInfoByManager(pCI->m_iID);
			pSI->m_pShape->PosSet(pSI->Pos());
			pSI->m_pShape->RotSet(pSI->Rot());
			pSI->m_pShape->ScaleSet(pSI->Scale());
			pSI->m_pShape->Tick(-1000);
			CN3Shape* pShape = pSI->m_pShape;

			for (size_t k = 0; k < vecSize / 3; k++)
			{
				pShape->PartialGetCollision(pCI->m_ivVector[k*3], vA);		 vA *= pShape->m_Matrix;
				pShape->PartialGetCollision(pCI->m_ivVector[k*3+1], vB);	vB *= pShape->m_Matrix;
				pShape->PartialGetCollision(pCI->m_ivVector[k*3+2], vC);	vC *= pShape->m_Matrix;

				float a, b, c;
				a = ((vB.x-vA.x)*(fz-vA.z)) - ((vB.z-vA.z)*(fx-vA.x));
				b = ((vC.x-vB.x)*(fz-vB.z)) - ((vC.z-vB.z)*(fx-vB.x));
				c = ((vA.x-vC.x)*(fz-vC.z)) - ((vA.z-vC.z)*(fx-vC.x));

				if((a<=0 && b<=0 && c<=0) || (a>=0 && b>=0 && c>=0))
				{
					__Vector3 vAB, vAC, vAxis;
					vAB.Set(vB.x - vA.x, vB.y - vA.y, vB.z - vA.z);
					vAC.Set(vC.x - vA.x, vC.y - vA.y, vC.z - vA.z);

					vAxis.Cross(vAB, vAC);
					if (vAxis.y <= 0.0f )
						continue;

					fy = (vAxis.x*(vA.x-fx)+vAxis.z*(vA.z-fz))/vAxis.y + vA.y;
					fy += m_fHeightOffs;
		
					return true;
				}
			}
		}
	}

	return false;
}

float CPortalVolume::GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal)
{
	float fHeight = FLT_MIN;
	ShapeInfo* pSI = nullptr;

	siiter siit = m_plShapeInfoList.begin();
	while(siit != m_plShapeInfoList.end())
	{
		pSI = *siit++;

		int iSize = pSI->m_pShape->GetColIndexbufferCount();
		__Vector3 vA, vB, vC;
		for (int k = 0; k < iSize / 3; k++)
		{
			vA = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3));		 vA *= pSI->m_Matrix;
			vB = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+1));		 vB *= pSI->m_Matrix;
			vC = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+2));		 vC *= pSI->m_Matrix;

			float a, b, c;
			a = ((vB.x-vA.x)*(vPos.z-vA.z)) - ((vB.z-vA.z)*(vPos.x-vA.x));
			b = ((vC.x-vB.x)*(vPos.z-vB.z)) - ((vC.z-vB.z)*(vPos.x-vB.x));
			c = ((vA.x-vC.x)*(vPos.z-vC.z)) - ((vA.z-vC.z)*(vPos.x-vC.x));

			if((a<=0 && b<=0 && c<=0) || (a>=0 && b>=0 && c>=0))
			{
				__Vector3 vAB, vAC, vAxis;
				vAB.Set(vB.x - vA.x, vB.y - vA.y, vB.z - vA.z);
				vAC.Set(vC.x - vA.x, vC.y - vA.y, vC.z - vA.z);

				vAxis.Cross(vAB, vAC);
				if (vAxis.y <= 0.0f )
					continue;
 
				fHeight = (vAxis.x*(vA.x-vPos.x)+vAxis.z*(vA.z-vPos.z))/vAxis.y + vA.y;
				fHeight += m_fHeightOffs;

				if (pvNormal)
				{
					__Vector3 vEdge1 = vB - vA;
					__Vector3 vEdge2 = vC - vA;
					pvNormal->Cross(vEdge1, vEdge2);	pvNormal->Normalize();
				}
	
				return fHeight;
			}
		}
	}

	return fHeight;
}

bool CPortalVolume::IsInTerrainWithTerrain(__Vector3& vec)
{
	__Vector3 vec2[3];
	for( int i = 0; i < 3; i++)
	{
		vec2[i] = m_pvVertex[i];
		vec2[i] *= m_Matrix;
	}

	if (vec.x >= vec2[0].x && vec.x <= vec2[1].x && 
		vec.z >=  vec2[2].z && vec.z <= vec2[0].z )
		return GetHeightWithTerrain(vec.x, vec.z, vec.y);

	return false;
}

BOOL CPortalVolume::PickWideWithTerrain(int x, int y, __Vector3& vPick)
{
	BOOL bColl = FALSE;

	// Compute the vector of the pick ray in screen space
	__Vector3 vTmp;
	vTmp.x =  ( ( ( 2.0f * x ) / (CN3Base::s_CameraData.vp.Width) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[0][0];
	vTmp.y = -( ( ( 2.0f * y ) / (CN3Base::s_CameraData.vp.Height) ) - 1 ) / CN3Base::s_CameraData.mtxProjection.m[1][1];
	vTmp.z =  1.0f;

	// Transform the screen space pick ray into 3D space
	__Matrix44* pMtxVI = &CN3Base::s_CameraData.mtxViewInverse;
	__Vector3 vDir;
	vDir.x  = vTmp.x * pMtxVI->m[0][0] + vTmp.y * pMtxVI->m[1][0] + vTmp.z * pMtxVI->m[2][0];
	vDir.y  = vTmp.x * pMtxVI->m[0][1] + vTmp.y * pMtxVI->m[1][1] + vTmp.z * pMtxVI->m[2][1];
	vDir.z  = vTmp.x * pMtxVI->m[0][2] + vTmp.y * pMtxVI->m[1][2] + vTmp.z * pMtxVI->m[2][2];
	__Vector3 vPos = pMtxVI->Pos();
	__Vector3 vPosCur = vPos;

	vDir.Normalize();

	__Vector3 A, B, C;
	float t, u, v;
	__ColIndex * pCI = nullptr;

	ciiter ciit = m_lpShapeColPartList.begin();
	while(ciit != m_lpShapeColPartList.end())
	{
		pCI = *ciit++;

		ShapeInfo* pSI = CPvsMgr::GetShapeInfoByManager(pCI->m_iID);
		pSI->m_pShape->PosSet(pSI->Pos());
		pSI->m_pShape->RotSet(pSI->Rot());
		pSI->m_pShape->ScaleSet(pSI->Scale());
		pSI->m_pShape->Tick(-1000);
		CN3Shape *pShape = pSI->m_pShape;

		size_t vecSize = pCI->m_ivVector.size();
		for (size_t k = 0; k < vecSize / 3; k++)
		{
			pShape->PartialGetCollision(pCI->m_ivVector[k*3], A);		 A *= pShape->m_Matrix;
			pShape->PartialGetCollision(pCI->m_ivVector[k*3+1], B);		B *= pShape->m_Matrix;
			pShape->PartialGetCollision(pCI->m_ivVector[k*3+2], C);		C *= pShape->m_Matrix;

			if (::_IntersectTriangle(vPos, vDir, A, B, C, t, u, v, &vPick))
			{
				bool bNom = false;
				__Vector3 vEdge1 = B - A;
				__Vector3 vEdge2 = C - A;
				__Vector3 pVec;	
				pVec.Cross(vEdge1, vEdge2);	pVec.Normalize();	pVec.y = 0.0f;	
				if (pVec.Magnitude() < m_fPickIncline)	// 기울기..
					return TRUE;
				else
				{
					int kk = 0;
				}
			}
		}
	}

	return FALSE;
}

CN3Shape* CPortalVolume::PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick)
{
	__Vector3 vPos, vDir;
	::_Convert2D_To_3DCoordinate(
		iXScreen, iYScreen,
		s_CameraData.mtxView, s_CameraData.mtxProjection,
		s_CameraData.vp.Width, s_CameraData.vp.Height,
		vPos, vDir);

	// 거리순으로 정렬..
	std::vector<ShapeInfo*> Shapes;
	ShapeInfo* pSI = nullptr;
	CPortalVolume* pVol = nullptr;
	VisPortalPriority vPP;
	vppiter vppit = m_pVisiblePvsList.begin();
	while( vppit != m_pVisiblePvsList.end())
	{
		vPP = *vppit++;
		pVol = vPP.m_pVol;

		siiter siit = pVol->m_plShapeInfoList.begin();
		while(siit != pVol->m_plShapeInfoList.end())
		{
			pSI = *siit++;
			Shapes.push_back(pSI);
		}
	}

	// NOTE: This is broken. This is meant to be used with __AlphaPrimitive*, not ShapeInfo*.
	// If called, this would crash.
	// qsort(&Shapes[0], Shapes.size(), sizeof(ShapeInfo*), CN3ShapeMgr::SortByCameraDistance);

	for (ShapeInfo* pShr : Shapes)
	{
		// 이벤트가 있어야 한다면...
		if (bMustHaveEvent && pShr->m_iEventID <= 0)
			continue;

		pShr->m_pShape->PosSet(pShr->Pos());
		pShr->m_pShape->RotSet(pShr->Rot());
		pShr->m_pShape->ScaleSet(pShr->Scale());

		if (pShr->m_pShape->CheckCollisionPrecisely(false, vPos, vDir, pvPick) >= 0)
		{
			pShr->m_pShape->m_iEventID = pShr->m_iEventID;
			pShr->m_pShape->m_iEventType = pShr->m_iEventType;
			pShr->m_pShape->m_iNPC_ID = pShr->m_iNPC_ID;
			pShr->m_pShape->m_iNPC_Status = pShr->m_iNPC_Status;
			return pShr->m_pShape;
		}
	}

	return nullptr;
}

CN3Shape* CPortalVolume::ShapeGetByIDWithShape(int iID)
{
	ShapeInfo* pSI = nullptr;
	CPortalVolume* pVol = nullptr;
	VisPortalPriority vPP;
	vppiter vppit = m_pVisiblePvsList.begin();
	while( vppit != m_pVisiblePvsList.end())
	{
		vPP = *vppit++;
		pVol = vPP.m_pVol;

		siiter siit = pVol->m_plShapeInfoList.begin();
		while(siit != pVol->m_plShapeInfoList.end())
		{
			pSI = *siit++;
			if (pSI->m_iEventID == iID)
			{
				pSI->m_pShape->m_iEventID			= pSI->m_iEventID;
				pSI->m_pShape->m_iEventType		 = pSI->m_iEventType;
				pSI->m_pShape->m_iNPC_ID		   = pSI->m_iNPC_ID;
				pSI->m_pShape->m_iNPC_Status	 = pSI->m_iNPC_Status;
				return pSI->m_pShape;
			}
		}
	}

	return nullptr;
}

bool CPortalVolume::CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
																				const __Vector3& vDir,				   // 방향 벡터
																				float fSpeedPerSec,					    // 초당 움직이는 속도
																				__Vector3* pvCol,						 // 충돌 지점
																				__Vector3* pvNormal,				  // 충돌한면의 법선벡터
																				__Vector3* pVec)						// 충돌한 면 의 폴리곤 __Vector3[3]
{
	__Vector3 vPosNext = vPos + (vDir * fSpeedPerSec); // 다음 위치
	float fMcs = (vPosNext - vPos).Magnitude();

	bool bCollision = false;
	bool bColl = false;
	CPortalVolume* pVol = nullptr;
	ShapeInfo* pSI = nullptr;

	VisPortalPriority vPP;
	vppiter vppit = m_pVisiblePvsList.begin();
	while( vppit != m_pVisiblePvsList.end())
	{
		vPP = *vppit++;
		if (vPP.m_iPriority > 1)
			continue;	

		pVol = vPP.m_pVol;
		
		siiter siit = pVol->m_plShapeInfoList.begin();
		while(siit != pVol->m_plShapeInfoList.end())
		{
			pSI = *siit++;

			int iSize = pSI->m_pShape->GetColIndexbufferCount();
			__Vector3 vA, vB, vC, vPick;
			float t,u,v;

			for( int k = 0; k < iSize/3; k++)
			{
				vA = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3));		 vA *= pSI->m_Matrix;
				vB = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+1));		 vB *= pSI->m_Matrix;
				vC = pSI->m_pShape->GetColVertexByIndex(pSI->m_pShape->GetColIndexByiOrder(k*3+2));		 vC *= pSI->m_Matrix;

				__Vector3 vEdge1 = vB - vA;
				__Vector3 vEdge2 = vC - vA;
				__Vector3 pVecto;	
				pVecto.Cross(vEdge1, vEdge2);	pVecto.Normalize();	pVecto *= m_fOffs;	vA += pVecto;	vB += pVecto; vC += pVecto;

				bColl = ::_IntersectTriangle(vPos, vDir, vA, vB, vC, t, u, v, &vPick);
				if (bColl)
				{
					if ((vPick - vPos).Magnitude() < fMcs)	
					{
						if(pvCol) *pvCol = vPick;
						if(pvNormal)
						{
							(*pvNormal).Cross(vB - vA, vC - vA);
							(*pvNormal).Normalize();
						}
						if (pVec)
						{
							pVec[0] = vA;
							pVec[1] = vB;
							pVec[2] = vC;
						}
						bCollision = true;
					}
				}
			}
		}
	}

	return bCollision;
}

// ===== END WarFare/PortalVolume.cpp =====

// ===== BEGIN WarFare/PortalVolume.h =====
#line 1 "WarFare/PortalVolume.h"
﻿// PortalVolume.h: interface for the CPortalVolume class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PORTALVOLUME_H__81823A3C_844B_4385_8D5B_F62606F89593__INCLUDED_)
#define AFX_PORTALVOLUME_H__81823A3C_844B_4385_8D5B_F62606F89593__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Shape.h>
#include <list>

#define INDOOR_FOLDER "N3Indoor\\"
const float fBaseVolumnSize = 1.0f;

enum e_ExtBool	{ TYPE_UNKNOWN = 0, TYPE_TRUE };

class CPvsMgr;
class CPortalVolume;

//////////////////////////////////////////////////////////////////
typedef struct tagShapeInfo	: public CN3Transform	
{
	int									m_iID;
	std::string						m_strShapeFile;

	int									m_iBelong;				// 소속 - 0:소속 없음 1:엘모라드 2:카루스 3:?? ....
	int									m_iEventID;				 // Event ID
	int									m_iEventType;		  // Event Type
	int									m_iNPC_ID;			   // NPC 로 쓰는 오브젝트일 경우 NPC ID
	int									m_iNPC_Status;	    // NPC 로 쓰는 오브젝트일 경우 Default Status

	CN3Shape*					m_pShape;

	//..
	tagShapeInfo()
	{
		m_iID = -1;
		m_strShapeFile = "";
		m_pShape = nullptr;		

		m_iBelong = 0;
		m_iEventID = 0;	
		m_iEventType = 0;
		m_iNPC_ID = 0;	
		m_iNPC_Status = 0;	
	}
	
	const tagShapeInfo& operator = (const tagShapeInfo& si)
	{
		m_iID = si.m_iID;
		m_strShapeFile = si.m_strShapeFile;
		m_pShape = si.m_pShape;
		m_iBelong = si.m_iBelong;
		m_iEventID = si.m_iEventID;	
		m_iEventType = si.m_iEventType;
		m_iNPC_ID = si.m_iNPC_ID;	
		m_iNPC_Status = si.m_iNPC_Status;
		return *this;
	}

} ShapeInfo;

typedef struct tagVisPartIndex {
	int m_iPartIndex;
	std::vector<int> m_ivVector;
} __VPI;
typedef std::list<__VPI>::iterator	viter;

typedef struct tagShapePart
{
	int									m_iID;
	std::list<__VPI>			 m_viIndex;									// Visible Index List..				

	tagShapePart()
	{
		m_iID = -1;
	}	
	void Clear()
	{
		__VPI vpi;
		viter vit =	m_viIndex.begin();	
		while (vit != m_viIndex.end())
		{
			vpi = *vit++;
			vpi.m_ivVector.clear();
		}
		m_viIndex.clear();
	}
	~tagShapePart()
	{
		Clear();
	}
} ShapePart;

typedef struct tagCollisionIndex
{
	int m_iID;
	std::vector<uint32_t> m_ivVector;
	tagCollisionIndex()
	{
		m_iID = -1;
	}
} __ColIndex;

typedef struct tagIDAndPriority
{
	int						m_iID;
	int						m_iPriority;
}	IDAndPriority;

typedef struct tagVisPortalPriority
{
	CPortalVolume* m_pVol;
	int						m_iPriority;

	tagVisPortalPriority()
	{
		m_pVol = nullptr;
		m_iPriority = 100;
	}
}	VisPortalPriority;

typedef std::list<VisPortalPriority>::iterator vppiter;
typedef std::list<ShapePart*>::iterator spiter;
typedef std::list<ShapeInfo*>::iterator siiter;
typedef std::list<__ColIndex*>::iterator ciiter;
typedef std::list<IDAndPriority>::iterator idapiter;
//////////////////////////////////////////////////////////////////

class CPortalVolume	: public CN3Transform
{
	friend class CPvsMgr;

	int m_iID;
	CPvsMgr* m_pManager;

	e_ExtBool	m_eRenderType;

	const float m_fOffs;				// 일반적인 옵셋..
	const float m_fHeightOffs;		// 높이 옵셋..
	const float m_fVolOffs;			  // Volume 법위 옵셋..
	const float m_fPickIncline;		// 픽킹 기울기 체크..
	const float m_fCameraOffs;		// 카메라 높이..
	
	//////////////////////////////////////////////////////////////////////////////////////
	std::list<ShapeInfo* > m_plShapeInfoList;
	std::list<IDAndPriority>	m_piVisibleIDList;						// 로드에 필요한 중간 데이터..		
	std::list<ShapePart* > m_lpShapePartList;	
	std::list<__ColIndex* >	m_lpShapeColPartList;
	std::list<VisPortalPriority>	m_pVisiblePvsList;		
	//////////////////////////////////////////////////////////////////////////////////////

	__Vector3					  m_pvVertex[8];
	uint16_t			   m_pIndex[36];

	int									m_iPriority;							//.. 100 정도로 초기화..

private:
	void DeleteAllPvsObj();
	bool Load(File& file) override;
	bool IsInVolumn(__Vector3 vec);

	void Render();
	void RenderShape();
	void RenderCollision();

	////////////////////////////////////////////////////////////////
	bool CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	bool CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	bool GetHeightWithTerrain(float fx, float fz, float& fy);
	float GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr); 
	bool IsInTerrainWithTerrain(__Vector3& vec);
	BOOL PickWideWithTerrain(int x, int y, __Vector3& vPick);
	CN3Shape* PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr);
	CN3Shape* ShapeGetByIDWithShape(int iID);
	bool CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
														const __Vector3& vDir,				   // 방향 벡터
														float fSpeedPerSec,					    // 초당 움직이는 속도
														__Vector3* pvCol,						 // 충돌 지점
														__Vector3* pvNormal,				  // 충돌한면의 법선벡터
														__Vector3* pVec);						// 충돌한 면 의 폴리곤 __Vector3[3]

public:
	CPortalVolume();
	~CPortalVolume() override;
};

#endif // !defined(AFX_PORTALVOLUME_H__81823A3C_844B_4385_8D5B_F62606F89593__INCLUDED_)

// ===== END WarFare/PortalVolume.h =====

// ===== BEGIN WarFare/PvsMgr.cpp =====
#line 1 "WarFare/PvsMgr.cpp"
﻿// PvsMgr.cpp: implementation of the CPvsMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PvsMgr.h"
#include "GameBase.h"
#include "PlayerMySelf.h"
#include "GameProcedure.h"
#include "GameEng.h"

#include <N3Base/N3Camera.h>
#include <N3Base/N3ShapeMgr.h>
#include <N3Base/N3ShapeExtra.h>

#define INDOOR_FOLDER "N3Indoor\\"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

CN3Mng <class CN3Shape>		CPvsMgr::s_MngShape; 
CN3Mng <class CN3ShapeExtra>	CPvsMgr::s_MngShapeExt; 
std::list<ShapeInfo* > CPvsMgr::s_plShapeInfoList;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
 
CPvsMgr::CPvsMgr()	: m_IndoorFolder("N3Indoor\\"), m_fVolumeOffs(0.6f)	//..
{
	s_plShapeInfoList.clear();
	m_pCurVol = nullptr;
}

CPvsMgr::~CPvsMgr()
{
	DeleteAllPvsObj();
}

void CPvsMgr::DeleteAllPvsObj()
{
	iter it = m_pPvsList.begin();

	while (it != m_pPvsList.end())	
	{
		CPortalVolume* pvs = *it;
		if (pvs) delete pvs;
		it++;
	}	
	m_pPvsList.clear();

	ShapeInfo* pSI;
	siiter siit = s_plShapeInfoList.begin();
	while(siit != s_plShapeInfoList.end())
	{
		pSI = *siit++;
		delete pSI;
	}
	s_plShapeInfoList.clear();
	s_MngShape.Release();
	s_MngShapeExt.Release();
}

ShapeInfo* CPvsMgr::GetShapeInfoByManager(int iID)
{
	ShapeInfo* pSI;
	siiter siit = s_plShapeInfoList.begin();
	while(siit != s_plShapeInfoList.end())
	{
		pSI = *siit++;
		if (pSI->m_iID == iID)
			return pSI;
	}

	return nullptr;
}

void CPvsMgr::Tick(bool bWarp, __Vector3 vPos)
{
	CPortalVolume* pVol = nullptr;
	__Vector3 vec = CGameBase::s_pPlayer->Position();	
	if(bWarp)
		vec = vPos;

	vec.y += m_fVolumeOffs;
	m_pCurVol = nullptr;
	
	iter it = m_pPvsList.begin();
	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if (pVol->IsInVolumn(vec))
		{
			m_pCurVol = pVol;
			break;
		}
	}

	it = m_pPvsList.begin();
	while(it != m_pPvsList.end())
	{
		pVol = *it++;
		pVol->m_eRenderType = TYPE_UNKNOWN;
	}

	if (!m_pCurVol) return;

	VisPortalPriority vPP;
	vppiter vppit = m_pCurVol->m_pVisiblePvsList.begin();
	while(vppit != m_pCurVol->m_pVisiblePvsList.end())
	{
		vPP = *vppit++;
		vPP.m_pVol->m_eRenderType = TYPE_TRUE;
	}		
}

void CPvsMgr::Render()
{
	CPortalVolume* pVol = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if ( pVol->m_eRenderType == TYPE_TRUE )
		{
			pVol->Render();
		}
	}
}

bool CPvsMgr::LoadOldVersion(File& file, int iVersionFromData)
{
	//..

	return true;
}

bool CPvsMgr::Load(File& file)
{
	int iT;

	file.Read(&iT, sizeof(int));
	if (iT != ciVersion)
		return LoadOldVersion(file, iT);

	// N3Scene 화일.. 안쓴다.. -.-;
	std::string strSrc = ReadDecryptString(file), strDest;

	// 전체 이동값.. 안슨다.. -.-;
	file.Read(&iT, sizeof(int));
	file.Read(&iT, sizeof(int));	
	file.Read(&iT, sizeof(int));	

	char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
	int iCount;

	file.Read(&iCount, sizeof(int));	

	for (int i = 0; i < iCount; i++ )
	{
		ShapeInfo*	pSI = new ShapeInfo;
		file.Read(&pSI->m_iID, sizeof(int));
		
		// 문자열 길이..
		strSrc = ReadDecryptString(file);
		_splitpath(strSrc.c_str(), szDrive, szDir, szFName, szExt);
		strDest = szFName;	strDest +=  szExt;
		pSI->m_strShapeFile = m_IndoorFolder + strDest;
		pSI->m_pShape = s_MngShape.Get(m_IndoorFolder + strDest);
		__ASSERT(pSI->m_pShape, "Shape Not Found");
	
		file.Read(&pSI->m_iBelong, sizeof(int));	
		file.Read(&pSI->m_iEventID, sizeof(int));	
		file.Read(&pSI->m_iEventType, sizeof(int));	
		file.Read(&pSI->m_iNPC_ID, sizeof(int));	
		file.Read(&pSI->m_iNPC_Status, sizeof(int));	
		pSI->Load(file);
		s_plShapeInfoList.push_back(pSI);
	}

	// Total Count.. 
	file.Read(&iCount, sizeof(int));

	CPortalVolume* pVol = nullptr, *pVolTo = nullptr;
	int iID;

	for(int i = 0; i < iCount; i++ )
	{
		file.Read(&iID, sizeof(int));

		pVol = new CPortalVolume;
		pVol->m_pManager = this;
		pVol->m_iID	= iID;	 
		pVol->Load(file);
		m_pPvsList.push_back(pVol);
	}

	iter it = m_pPvsList.begin();
	idapiter idapit;
	IDAndPriority IDAP;
	VisPortalPriority vPP;

	while(it != m_pPvsList.end())
	{
		pVol = *it++;

		idapit = pVol->m_piVisibleIDList.begin();
		while (idapit != pVol->m_piVisibleIDList.end())
		{
			 IDAP = *idapit++;
			 pVolTo = GetPortalVolPointerByID(IDAP.m_iID);
			 vPP.m_pVol = pVolTo;
			 vPP.m_iPriority = IDAP.m_iPriority;
			 pVol->m_pVisiblePvsList.push_back(vPP);
		}

		pVol->m_piVisibleIDList.clear();
	}

	return true;
}

CPortalVolume* CPvsMgr::GetPortalVolPointerByID(int iID)
{
	CPortalVolume* pVol = nullptr;

	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		// 자신의 데이터 저장..
		pVol = *it++;
		if (pVol->m_iID == iID)
			return pVol;
	}

	return nullptr;	
}

#define CRY_KEY 0x0816

std::string CPvsMgr::ReadDecryptString(File& file)
{
	int iCount;

	file.Read(&iCount, sizeof(int));

	std::string strDest;
	if (iCount > 0)
	{
		strDest.assign(iCount, '\0');
		file.Read(&strDest[0], iCount);

		for (int i = 0; i < iCount; i++)
			strDest[i] ^= CRY_KEY;
	}

	return strDest;
}


//////////////////////////////////////////////////////////////////////////////////

bool CPvsMgr::CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	fNP = (vAt - vEyeResult).Magnitude();
	bool bCollision = false;
	float fNPMin = fNP, fTemp = 0.0f;

	CPortalVolume* pVol = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if ( (pVol->m_eRenderType == TYPE_TRUE ) && pVol->CheckCollisionCameraWithTerrain(vEyeResult, vAt, fNP))
		{
			bCollision = true;
			fTemp = (vEyeResult- vAt).Magnitude(); 
			if (fTemp < fNPMin)
				fNPMin = fTemp;
		}
	}

	if (bCollision && (fNPMin < fNP))
	{
		__Vector3 vT; vT.Zero();
		vT = vEyeResult - vAt; vT.Normalize();	vT *= fNPMin; vEyeResult = vT + vAt;
	}
	
	return bCollision;
}

bool CPvsMgr::CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP)
{
	fNP = (vAt - vEyeResult).Magnitude();
	bool bCollision = false;
	float fNPMin = fNP, fTemp = 0.0f;

	CPortalVolume* pVol = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if ( (pVol->m_eRenderType == TYPE_TRUE ) && pVol->CheckCollisionCameraWithShape(vEyeResult, vAt, fNP))
		{
			bCollision = true;
			fTemp = (vEyeResult- vAt).Magnitude(); 
			if (fTemp < fNPMin)
				fNPMin = fTemp;
		}
	}

	if (bCollision && (fNPMin < fNP))
	{
		__Vector3 vT; vT.Zero();
		vT = vEyeResult - vAt; vT.Normalize();	vT *= fNPMin; vEyeResult = vT + vAt;	
	}
	
	return bCollision;
}

float CPvsMgr::GetHeightWithTerrain(float x, float z, bool bWarp)
{
	if (!m_pCurVol)
		Tick();

	float fHeight = FLT_MIN;
	if (!m_pCurVol)
		return fHeight;

	m_pCurVol->GetHeightWithTerrain(x, z, fHeight);
	return fHeight;
}

float CPvsMgr::GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal)
{
	float fHeightMax = FLT_MIN, fHeight;

	CPortalVolume* pVol = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if ( pVol->m_eRenderType == TYPE_TRUE )
		{
			fHeight = pVol->GetHeightNearstPosWithShape(vPos, fDist, pvNormal);
			if (fHeightMax < fHeight)
				fHeightMax = fHeight;
		}		
	}
	
	return fHeightMax;
}

bool CPvsMgr::IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore)
{
	if (!m_pCurVol)
		Tick();

	float fHeight = FLT_MIN;
	if (!m_pCurVol)
		return false;

	return m_pCurVol->GetHeightWithTerrain(x, z, fHeight);
}

float CPvsMgr::GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal)
{
	float fHeightMax = FLT_MIN, fHeight;

	CPortalVolume* pVol = nullptr, *pVolNe = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		fHeight = pVol->GetHeightNearstPosWithShape(__Vector3(fX, FLT_MIN, fZ), 0.0f);
		if (fHeightMax < fHeight)
		{
			fHeightMax = fHeight;
			pVolNe = pVol;
		}
	}		
	
	__Vector3 vPos; vPos.Set(fX, fHeightMax, fZ);
	if (pVolNe && pVolNe->m_eRenderType != TYPE_TRUE)
		Tick(true, vPos);

	return fHeightMax;
}

BOOL CPvsMgr::PickWideWithTerrain(int x, int y, __Vector3& vPick)
{
	BOOL bColl = FALSE;
	__Vector3 vCamPo = CGameProcedure::s_pEng->CameraGetActive()->EyePos(), vPT;
	float fDistMax = FLT_MAX, fDT;

	CPortalVolume* pVol = nullptr, *pVolNe = nullptr;
	iter it = m_pPvsList.begin();

	while(it != m_pPvsList.end())
	{
		pVol = *it++;	
		if ((pVol->m_eRenderType == TYPE_TRUE) && (pVol->PickWideWithTerrain(x, y, vPT)) )
		{	
			fDT = (vPT - vCamPo).Magnitude();
			if (fDT <= fDistMax)
			{
				fDistMax = fDT;
				vPick = vPT;
				bColl = TRUE;
			}
		}
	}
	
	return bColl;
}

CN3Shape* CPvsMgr::PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick)
{
	if (!m_pCurVol)
		Tick();

	if (!m_pCurVol)
		return nullptr;

	return m_pCurVol->PickWithShape(iXScreen, iYScreen, bMustHaveEvent, pvPick);
}

bool CPvsMgr::CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
																	const __Vector3& vDir,				   // 방향 벡터
																	float fSpeedPerSec,					    // 초당 움직이는 속도
																	__Vector3* pvCol,						 // 충돌 지점
																	__Vector3* pvNormal,				  // 충돌한면의 법선벡터
																	__Vector3* pVec)						// 충돌한 면 의 폴리곤 __Vector3[3]
{
	if (!m_pCurVol)
		Tick();

	if (!m_pCurVol)
		return false;

	return m_pCurVol->CheckCollisionWithShape(vPos, vDir, fSpeedPerSec, pvCol, pvNormal, pVec);
}

CN3Shape* CPvsMgr::ShapeGetByIDWithShape(int iID)
{
	if (!m_pCurVol)
		Tick();

	if (!m_pCurVol)
		return nullptr;

	return m_pCurVol->ShapeGetByIDWithShape(iID);
}

// ===== END WarFare/PvsMgr.cpp =====

// ===== BEGIN WarFare/PvsMgr.h =====
#line 1 "WarFare/PvsMgr.h"
﻿// PvsMgr.h: interface for the CPvsMgr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PVSMGR_H__7E562A54_E3B8_4484_A861_7ADD71D4411D__INCLUDED_)
#define AFX_PVSMGR_H__7E562A54_E3B8_4484_A861_7ADD71D4411D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "PortalVolume.h"
#include <string>

const int ciVersion = 1;

typedef std::list<CPortalVolume*>::iterator iter;

class CPvsMgr : public CN3BaseFileAccess
{
	friend class CDungeonManager;
	friend class CPortalVolume;

	const std::string m_IndoorFolder;
	const float m_fVolumeOffs;		// Volume 체크 높이..

	std::list<CPortalVolume*> m_pPvsList;

	//.. Current Portal Volume.. ^^
	CPortalVolume* m_pCurVol;

public:
	static CN3Mng <class CN3Shape> s_MngShape;
	static CN3Mng <class CN3ShapeExtra> s_MngShapeExt;
	static std::list<ShapeInfo* > s_plShapeInfoList;
	static ShapeInfo* GetShapeInfoByManager(int iID);

private:
	void Tick(bool bWarp = false, __Vector3 vPos = __Vector3());
	void Render();

	void DeleteAllPvsObj();

	// String Cryptograph.. ^^
	static std::string ReadDecryptString(File& file);
	std::string GetIndoorFolderPath() {	return m_IndoorFolder; }

	CPortalVolume* GetPortalVolPointerByID(int iID);

	////////////////////////////////////////////////////////////////
	bool CheckCollisionCameraWithTerrain(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	bool CheckCollisionCameraWithShape(__Vector3& vEyeResult, const __Vector3& vAt, float fNP);
	float GetHeightWithTerrain(float x, float z, bool bWarp = false );
	float GetHeightNearstPosWithShape(const __Vector3& vPos, float fDist, __Vector3* pvNormal = nullptr); 
	bool IsInTerrainWithTerrain(float x, float z, __Vector3 vPosBefore = __Vector3());
	float GetHeightWithShape(float fX, float fZ, __Vector3* pvNormal = nullptr); 
	BOOL PickWideWithTerrain(int x, int y, __Vector3& vPick);
	CN3Shape* PickWithShape(int iXScreen, int iYScreen, bool bMustHaveEvent, __Vector3* pvPick = nullptr);
	CN3Shape* ShapeGetByIDWithShape(int iID);
	bool CheckCollisionWithShape(	const __Vector3& vPos,				 // 충돌 위치
														const __Vector3& vDir,				   // 방향 벡터
														float fSpeedPerSec,					    // 초당 움직이는 속도
														__Vector3* pvCol,						 // 충돌 지점
														__Vector3* pvNormal,				  // 충돌한면의 법선벡터
														__Vector3* pVec);						// 충돌한 면 의 폴리곤 __Vector3[3]

public:
	CPvsMgr();
	~CPvsMgr() override;

	//..
	bool Load(File& file) override;
	bool LoadOldVersion(File& file, int iVersionFromData);
};

#endif // !defined(AFX_PVSMGR_H__7E562A54_E3B8_4484_A861_7ADD71D4411D__INCLUDED_)

// ===== END WarFare/PvsMgr.h =====

// ===== BEGIN WarFare/ServerMesh.cpp =====
#line 1 "WarFare/ServerMesh.cpp"
﻿// ServerMesh.cpp: implementation of the CServerMesh class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "ServerMesh.h"
#include "N3Terrain.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static const float SGRID_SIZE = 64.0f;
static const int SMAP_SIZE  = 4096;


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServerMesh::CServerMesh()
{

}

CServerMesh::~CServerMesh()
{

}



void CServerMesh::Tick(CN3Terrain* pTerrain, const __Vector3& vPosPlayer)
{
	__Vector3 pos = vPosPlayer;
	float ixposL, ixposR, izposL, izposR, ixpos, izpos;
	float fHeightLB, fHeightRB, fHeightTop, fHeightBottom;	

	ixpos   = ((int)pos.x)/SGRID_SIZE; 
	ixpos *= SGRID_SIZE;
	izpos   = ((int)pos.z)/SGRID_SIZE;
	izpos *= SGRID_SIZE;

	D3DCOLOR color = D3DCOLOR_RGBA(50,25,25,0);

	// 제일 왼쪽..	
	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos - SGRID_SIZE;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 0 );	

	// 왼쪽 두번째..

	ixposL = ixpos;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 6 );	

	// 왼쪽 세번째..

	ixposL = ixpos + SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 12 );	

	// 왼쪽에서 끝..

	ixposL = ixpos + SGRID_SIZE*2;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 18 );	

	// 밑에서 첫번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos - SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos - SGRID_SIZE;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 24 );	

	// 밑에서 두번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 30 );	
	
	// 밑에서 세번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos + SGRID_SIZE;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 36 );	

	// 밑에서 끝번째..

	ixposL = ixpos - SGRID_SIZE;
	izposL = izpos + SGRID_SIZE*2;
	ixposR = ixpos + SGRID_SIZE*2;
	izposR = izpos + SGRID_SIZE*2;

	fHeightLB	=	pTerrain->GetHeight(ixposL, izposL);
	fHeightRB	=	pTerrain->GetHeight(ixposR, izposR);

	if ( fHeightLB >= fHeightRB ) 
	{
		fHeightTop	=	fHeightLB;
		fHeightBottom = fHeightRB;
	}
	else
	{
		fHeightTop	=	fHeightRB;
		fHeightBottom = fHeightLB;
	}
	fHeightTop		+= 1.0f;

	AutoConcMesh( color, ixposL, ixposR, izposL, izposR, fHeightBottom, fHeightTop, 42);
}


void CServerMesh::AutoConcMesh(D3DCOLOR color, float left, float right, float bottom, float top, float low, float high , int iStart)
{
	// left, right  : x
	// bottom, top  : z
	// low, high	: y

	switch(iStart)
	{
		case 0:
		case 6:
		case 12:
		case 18:
			m_vSMesh[iStart].Set( left, low, bottom);
			m_vSMesh[iStart+1].Set( left, high, bottom);
			m_vSMesh[iStart+2].Set( left, low, top);
			m_vSMesh[iStart+3].Set( left, high, top);
			m_vSMesh[iStart+4].Set( left, low, top);
			m_vSMesh[iStart+5].Set( left, high, bottom);
			break;

		case 24:
		case 30:
		case 36:
		case 42:
			m_vSMesh[iStart].Set( left, low, top);
			m_vSMesh[iStart+1].Set( left, high, top);
			m_vSMesh[iStart+2].Set( right, low, top);
			m_vSMesh[iStart+3].Set( right, high, top);
			m_vSMesh[iStart+4].Set( right, low, top);
			m_vSMesh[iStart+5].Set( left, high, top);
			break;
	}
}



void CServerMesh::Render()
{
    __Matrix44 mtxWorld;
	mtxWorld.Identity();
	s_lpD3DDev->SetTransform(D3DTS_WORLD, mtxWorld.toD3D());
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	
	DWORD dwFillPrev;
	s_lpD3DDev->GetRenderState(D3DRS_FILLMODE, &dwFillPrev);

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	s_lpD3DDev->SetTexture(0, nullptr);

	s_lpD3DDev->SetFVF(D3DFVF_XYZ);
	s_lpD3DDev->DrawPrimitiveUP( D3DPT_TRIANGLELIST, 16, &m_vSMesh, sizeof(__Vector3));

	s_lpD3DDev->SetRenderState(D3DRS_FILLMODE, dwFillPrev);
	s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
}

// ===== END WarFare/ServerMesh.cpp =====

// ===== BEGIN WarFare/ServerMesh.h =====
#line 1 "WarFare/ServerMesh.h"
﻿// ServerMesh.h: interface for the CServerMesh class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVERMESH_H__5D0D1E4F_E427_462E_9D72_CB0C4FC02C82__INCLUDED_)
#define AFX_SERVERMESH_H__5D0D1E4F_E427_462E_9D72_CB0C4FC02C82__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3Base.h>

class CN3Terrain;
class CServerMesh : public CN3Base
{
	__Vector3		m_vSMesh[48];
	void	AutoConcMesh(D3DCOLOR color, float left, float right, float bottom, float top, float low, float high, int iStart );

public:
	CServerMesh();
	virtual ~CServerMesh();

	void	Tick(CN3Terrain* pTerrain, const __Vector3& vPosPlayer);
	void	Render();
};

#endif // !defined(AFX_SERVERMESH_H__5D0D1E4F_E427_462E_9D72_CB0C4FC02C82__INCLUDED_)

// ===== END WarFare/ServerMesh.h =====

// ===== BEGIN WarFare/StdAfx.cpp =====
#line 1 "WarFare/StdAfx.cpp"
﻿#include "StdAfx.h"

// ===== END WarFare/StdAfx.cpp =====

// ===== BEGIN WarFare/StdAfx.h =====
#line 1 "WarFare/StdAfx.h"
﻿#pragma once

#include <N3Base/My_3DStruct.h>
#include <filesystem>

#if __has_include(<warfare_config.h>)
#include <warfare_config.h>
#endif

// ===== END WarFare/StdAfx.h =====

// ===== BEGIN WarFare/SubProcPerTrade.cpp =====
#line 1 "WarFare/SubProcPerTrade.cpp"
﻿// SubProcPerTrade.cpp: implementation of the CSubProcPerTrade class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SubProcPerTrade.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "PlayerOtherMgr.h"
#include "UIManager.h"
#include "UIMessageBox.h"
#include "UIInventory.h"
#include "UIDroppedItemDlg.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "UIPerTradeDlg.h"
#include "UITradeEditDlg.h"
#include "UIHotKeyDlg.h"
#include "UISkillTreeDlg.h"
#include "N3UIIcon.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSubProcPerTrade::CSubProcPerTrade()
{
	m_pUIPerTradeDlg = nullptr;
	m_pUITradeEditDlg = nullptr;
	m_ePerTradeState = PER_TRADE_STATE_NONE;
	m_iOtherID		 = -1;
	m_iGoldOffsetBackup = 0;
	m_szMsg = ""; //MessagBox key
}

CSubProcPerTrade::~CSubProcPerTrade()
{

}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::Release()
{
	if (m_pUIPerTradeDlg)	
	{
		m_pUIPerTradeDlg->Release();
		delete m_pUIPerTradeDlg;
		m_pUIPerTradeDlg = nullptr;
	}

	if (m_pUITradeEditDlg)
	{
		m_pUITradeEditDlg->Release();
		delete m_pUITradeEditDlg;
		m_pUITradeEditDlg = nullptr;
	}

	m_szMsg = "";//MessageBox key
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::InitPerTradeDlg(CUIManager* pUIManager)
{
	int iW = CN3Base::s_CameraData.vp.Width;
	RECT rc;

	e_Nation eNation = s_pPlayer->m_InfoBase.eNation;		// 국가....
	__TABLE_UI_RESRC* pTbl = s_pTbl_UI.Find(eNation);

	// UIPerTradeDlg.. ^^
	m_pUIPerTradeDlg = new CUIPerTradeDlg();
	m_pUIPerTradeDlg->Init(pUIManager);
	m_pUIPerTradeDlg->m_pSubProcPerTrade = this;
	m_pUIPerTradeDlg->LoadFromFile(pTbl->szPersonalTrade);
	rc = m_pUIPerTradeDlg->GetRegion();
	m_pUIPerTradeDlg->SetPos(iW - (rc.right-rc.left), 10);
	m_pUIPerTradeDlg->SetVisible(false);	
	m_pUIPerTradeDlg->InitIconWnd(UIWND_PER_TRADE);
	m_pUIPerTradeDlg->SetUIType(UI_TYPE_ICON_MANAGER);
	m_pUIPerTradeDlg->SetState(UI_STATE_COMMON_NONE);

	// UITradeEditDlg.. ^^
	m_pUITradeEditDlg = new CUITradeEditDlg();
	m_pUITradeEditDlg->Init(pUIManager);
	m_pUITradeEditDlg->m_pSubProcPerTrade = this;
	m_pUITradeEditDlg->LoadFromFile(pTbl->szPersonalTradeEdit);
	m_pUITradeEditDlg->SetStyle(UISTYLE_ALWAYSTOP);
	// 위치 계산 ..
	int iXPos, iYPos;
	int iH = CN3Base::s_CameraData.vp.Height;
	iXPos = (iW/2) - (m_pUITradeEditDlg->GetRegion().right - m_pUITradeEditDlg->GetRegion().left)/2;
	iYPos = (iH/2) - (m_pUITradeEditDlg->GetRegion().bottom - m_pUITradeEditDlg->GetRegion().top)/2;
	m_pUITradeEditDlg->SetPos(iXPos, iYPos);	
	m_pUITradeEditDlg->Close();
	m_pUITradeEditDlg->SetUIType(UI_TYPE_BASE);
	m_pUITradeEditDlg->SetState(UI_STATE_COMMON_NONE);

	// 일단은 돈 아이콘으로 픽스.. ^^
	N3_VERIFY_UI_COMPONENT(m_pUITradeEditDlg->m_pArea, m_pUITradeEditDlg->GetChildByID<CN3UIArea >("area_trade_icon"));

	m_pUITradeEditDlg->m_pImageOfIcon = new CN3UIImage;
	m_pUITradeEditDlg->m_pImageOfIcon->Init(m_pUITradeEditDlg);
	// 돈 아이콘 문자열 찾기.. 아이디로 찾는 기능밖에 없다.. ㅠ.ㅠ
	__TABLE_ITEM_BASIC*	pItem = s_pTbl_Items_Basic.Find(dwGold);	// 열 데이터 얻기..

	std::string szIconFN;
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	CGameBase::MakeResrcFileNameForUPC(pItem, nullptr, nullptr, &szIconFN, ePart, ePlug); // 아이템에 따른 파일 이름을 만들어서
	m_pUITradeEditDlg->m_pImageOfIcon->SetTex(szIconFN);
	float fUVAspect = (float)45.0f/(float)64.0f;
	m_pUITradeEditDlg->m_pImageOfIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
	m_pUITradeEditDlg->m_pImageOfIcon->SetRegion(m_pUITradeEditDlg->m_pArea->GetRegion());
	m_pUITradeEditDlg->m_pImageOfIcon->SetMoveRect(m_pUITradeEditDlg->m_pArea->GetRegion());	
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::EnterWaitMsgFromServerStatePerTradeReq()
{
	CPlayerOther* pTarget = s_pOPMgr->UPCGetByID(s_pPlayer->m_iIDTarget, false);
	if (pTarget == nullptr)
		return;

	m_ePerTradeState = PER_TRADE_STATE_WAIT_FOR_REQ;

	// 메시지 박스 텍스트 표시..
	std::string szMsg = fmt::format_text_resource(IDS_PERSONAL_TRADE_FMT_WAIT,
		s_pPlayer->IDString(), pTarget->IDString());
	m_szMsg = CGameProcedure::MessageBoxPost(szMsg, "", MB_CANCEL, BEHAVIOR_PERSONAL_TRADE_FMT_WAIT);

	SecureCodeBegin();
}

void CSubProcPerTrade::EnterWaitMsgFromServerStatePerTradeReq(std::string szName)
{
	m_ePerTradeState = PER_TRADE_STATE_WAIT_FOR_REQ;

	// 메시지 박스 텍스트 표시..
	std::string szMsg = fmt::format_text_resource(IDS_PERSONAL_TRADE_FMT_WAIT,
		s_pPlayer->IDString(), szName);
	m_szMsg = CGameProcedure::MessageBoxPost(szMsg, "", MB_CANCEL, BEHAVIOR_PERSONAL_TRADE_FMT_WAIT);

	SecureCodeBegin();
}

void CSubProcPerTrade::EnterWaitMyDecisionToPerTrade(int iOtherID)			// 내가 타인에게서 아이템 거래를 신청 받은 상태..
{
	CPlayerOther* pTarget = s_pOPMgr->UPCGetByID(iOtherID, false);
	if (pTarget == nullptr)
		return;

	m_iOtherID = iOtherID;
	m_ePerTradeState = PER_TRADE_STATE_WAIT_FOR_MY_DECISION_AGREE_OR_DISAGREE;

	// 메시지 박스 텍스트 표시..
	std::string szMsg = fmt::format_text_resource(IDS_PERSONAL_TRADE_PERMIT,
		s_pPlayer->IDString(), pTarget->IDString());
	m_szMsg = CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_PERSONAL_TRADE_PERMIT);

	SecureCodeBegin();
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::SecureCodeBegin()
{
	// 1.상거래 중이면 개인 거래 신청이 않된다.. -> 해당 부분..	ok
	// 2.상거래 중에 개인 거래 신청을 받으면 거절.. -> 해당 부분.. ok

	// 3.유저가 움직이고 있는 중이면 멈춘다..
	if ( s_pPlayer->IsMovingNow() )	s_pPlayer->ToggleMoveMode();				// 자동 전진 토글.. 

	// 4.아이콘 매니저 윈도우는 모두 닫는다..
	//   인벤토리 윈도우이면..
	if ( CGameProcedure::s_pProcMain->m_pUIInventory->IsVisible() )
		CGameProcedure::s_pProcMain->m_pUIInventory->Close();

	//   Drop Item 윈도우이면..
	if ( CGameProcedure::s_pProcMain->m_pUIDroppedItemDlg->IsVisible() )
		CGameProcedure::s_pProcMain->m_pUIDroppedItemDlg->LeaveDroppedState();

	// 5.인풋을 막는다..	-> 해당 부분..	ok	(키입력과 메시지..)

	// 6.거래창의 편집 Control의 값을 Clear..
	CN3UIString* pStrMy = nullptr, *pStrOther = nullptr;
	N3_VERIFY_UI_COMPONENT(pStrMy, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_my"));
	pStrMy->SetString("0");

	N3_VERIFY_UI_COMPONENT(pStrOther, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_other"));
	pStrOther->SetString("0");

	// 7.개인 거래 창의 처크 버튼들 원래대로..
	CN3UIButton* pButtonMy = nullptr, *pButtonOther = nullptr;
	N3_VERIFY_UI_COMPONENT(pButtonMy, m_pUIPerTradeDlg->GetChildByID<CN3UIButton>("btn_trade_my"));
	pButtonMy->SetState(UI_STATE_BUTTON_NORMAL);

	N3_VERIFY_UI_COMPONENT(pButtonOther, m_pUIPerTradeDlg->GetChildByID<CN3UIButton>("btn_trade_other"));
	pButtonOther->SetState(UI_STATE_BUTTON_NORMAL);

	// 8.상대방 거래 버튼은 Click할 수 없다. uif 자체 기능..
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::FinalizePerTrade()
{
	m_ePerTradeState = PER_TRADE_STATE_NONE;

	if ( m_pUIPerTradeDlg->IsVisible() )
		m_pUIPerTradeDlg->SetVisible(false);

	CGameProcedure::MessageBoxClose(m_szMsg);
	m_szMsg = "";

	if ( m_pUITradeEditDlg->IsVisible() )
	{
		m_pUITradeEditDlg->SetQuantity(0);
		m_pUITradeEditDlg->Close();
	}
}

void CSubProcPerTrade::PerTradeCompleteSuccess()						// 개인 거래 최종 성공..
{
	// 개인 거래 창에 있는 아이템 삭제..
	for ( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if (m_pUIPerTradeDlg->m_pPerTradeMy[i] != nullptr)	
		{
			__IconItemSkill* spItem;
			spItem = m_pUIPerTradeDlg->m_pPerTradeMy[i];

			// 매니저에서 제거..
			m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

			// 리소스 제거..
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
			m_pUIPerTradeDlg->m_pPerTradeMy[i] = nullptr;
		}

		if (m_pUIPerTradeDlg->m_pPerTradeOther[i] != nullptr)	
		{
			__IconItemSkill* spItem;
			spItem = m_pUIPerTradeDlg->m_pPerTradeOther[i];

			// 매니저에서 제거..
			m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

			// 리소스 제거..
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
			m_pUIPerTradeDlg->m_pPerTradeOther[i] = nullptr;
		}
	}

	m_pUIPerTradeDlg->LeavePerTradeState();
}

void CSubProcPerTrade::PerTradeCompleteCancel()							// 개인 거래 취소..	
{
	std::string str;
	int iGold,			// 거래창의 값..
		iMyMoney;		// 인벤토리의 값..

	if ( (int)m_ePerTradeState >= (int)PER_TRADE_STATE_NORMAL )
	{
		// 먼저 돈을 검사 한다..
		// 거래 창의 내 현재 돈을 얻어 온다..
		CN3UIString* pStrMy = nullptr;
		N3_VERIFY_UI_COMPONENT(pStrMy, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_my"));
		str = pStrMy->GetString();
		iGold = atoi(str.c_str());

		// 현재 내가 가진 돈을 얻어 온다..
		iMyMoney = s_pPlayer->m_InfoExt.iGold;
		// 돈을 복구 한다..
		iMyMoney += iGold;
		s_pPlayer->m_InfoExt.iGold = iMyMoney;

		// 그다음 아이템을 검사한다..
		// 아이템들을 원래 대로..
		for ( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
		{
			if (m_pUIPerTradeDlg->m_pPerTradeMy[i] != nullptr)	
			{
				if( (m_pUIPerTradeDlg->m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) ||  
					(m_pUIPerTradeDlg->m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
				{
					// 활이나 물약등 아이템인 경우..
					__IconItemSkill* spItem;
					spItem = m_pUIPerTradeDlg->m_pPerTradeMy[i];
					
					// 기존에 아이콘이 있다면.. 
					if ( m_pUIPerTradeDlg->m_pPerTradeInv[m_pUIPerTradeDlg->m_iBackupiOrder[i]] )
					{
						// 숫자 업데이트 하고..
						m_pUIPerTradeDlg->m_pPerTradeInv[m_pUIPerTradeDlg->m_iBackupiOrder[i]]->iCount 
							+= m_pUIPerTradeDlg->m_pPerTradeMy[i]->iCount;

						// 매니저에서 제거..
						m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

						// 리소스 제거..
						spItem->pUIIcon->Release();
						delete spItem->pUIIcon;
						spItem->pUIIcon = nullptr;
						delete spItem;
						spItem = nullptr;
						m_pUIPerTradeDlg->m_pPerTradeMy[i] = nullptr;
					}
					// 없다면 그대로 이동한다..
					else
					{
						__IconItemSkill* spItem;
						spItem = m_pUIPerTradeDlg->m_pPerTradeMy[i];

						spItem->pUIIcon->SetParent(m_pUIPerTradeDlg);

						// 인벤토리 윈도우에 세팅하고..
						m_pUIPerTradeDlg->m_pPerTradeInv[m_pUIPerTradeDlg->m_iBackupiOrder[i]] = spItem;

						// 내 거래 윈도우에서 클리어..
						m_pUIPerTradeDlg->m_pPerTradeMy[i] = nullptr;

						CN3UIArea* pArea;

						pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, m_pUIPerTradeDlg->m_iBackupiOrder[i]);
						if ( pArea )
						{
							spItem->pUIIcon->SetRegion(pArea->GetRegion());
							spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
						}
					}
				}
				else
				{
					__IconItemSkill* spItem;
					spItem = m_pUIPerTradeDlg->m_pPerTradeMy[i];

					spItem->pUIIcon->SetParent(m_pUIPerTradeDlg);

					// 인벤토리 윈도우에 세팅하고..
					m_pUIPerTradeDlg->m_pPerTradeInv[m_pUIPerTradeDlg->m_iBackupiOrder[i]] = spItem;

					// 내 거래 윈도우에서 클리어..
					m_pUIPerTradeDlg->m_pPerTradeMy[i] = nullptr;

					CN3UIArea* pArea;

					pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, m_pUIPerTradeDlg->m_iBackupiOrder[i]);
					if ( pArea )
					{
						spItem->pUIIcon->SetRegion(pArea->GetRegion());
						spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
					}
				}
			}

			if (m_pUIPerTradeDlg->m_pPerTradeOther[i] != nullptr)	
			{
				__IconItemSkill* spItem;
				spItem = m_pUIPerTradeDlg->m_pPerTradeOther[i];

				// 매니저에서 제거..
				m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

				// 리소스 제거..
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;
				m_pUIPerTradeDlg->m_pPerTradeOther[i] = nullptr;
			}
		}

		m_pUIPerTradeDlg->LeavePerTradeState();
	}
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::LeavePerTradeState(e_PerTradeResultCode ePTRC)	// 아이템 거래가 취소되는 상태를 정의..
{
	uint8_t byBuff[4];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	char szBuf[256] = "";
	std::string szMsg; 

	switch ( ePTRC )
	{
		case PER_TRADE_RESULT_MY_CANCEL:								// 거래를 신청한 내가 거래 신청을 취소..
			// 서버에게 패킷 만들어서 날림..
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_CANCEL);
			CGameProcedure::s_pSocket->Send(byBuff, iOffset);								// 보냄..

			// 뒷 마무리..
			PerTradeCompleteCancel();
			FinalizePerTrade();
			//TRACE("내가 거래를 취소 상대방과 내가 취소됨.. 서버에게 보냄..\n");
			break;

		case PER_TRADE_RESULT_MY_DISAGREE:								// 거래를 신청받은 내가 거래 신청을 취소..
			// 서버에게 패킷 만들어서 날림..
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_AGREE);		
			CAPISocket::MP_AddByte(byBuff, iOffset, 0x00);		

			CGameProcedure::s_pSocket->Send(byBuff, iOffset);								// 보냄..

			// 뒷 마무리..
			FinalizePerTrade();
			//TRACE("내가 거래를 거절.. 상대방과 내가 취소됨 서버에게 보냄..\n");
			break;

		case PER_TRADE_RESULT_OTHER_DISAGREE:							// 거래를 신청받은 상대방이 거래 신청을 취소..
			//TRACE("상대방이 거래를 거절.. \n");
			//this_ui
			// 메시지 박스 텍스트 표시..
			szMsg = fmt::format_text_resource(IDS_OTHER_PER_TRADE_ID_NO);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			// 뒷 마무리..
			FinalizePerTrade();
			break;
	}
}

void CSubProcPerTrade::ProcessProceed(e_PerTradeProceedCode ePTPC)		// 아이템 거래가 계속되는 상태를 정의..
{
	uint8_t byBuff[4];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	switch ( ePTPC )
	{
		case PER_TRADE_RESULT_MY_AGREE:									// 거래를 신청받은 내가 거래 신청을 허락..
			// 서버에게 패킷 만들어서 날림..
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_AGREE);		
			CAPISocket::MP_AddByte(byBuff, iOffset, 0x01);		

			CGameProcedure::s_pSocket->Send(byBuff, iOffset);				// 보냄..

			CGameProcedure::MessageBoxClose(m_szMsg);
			m_szMsg = "";

			// Trade Core Start..
			PerTradeCoreStart();
			break;

		case PER_TRADE_RESULT_OTHER_AGREE:								// 거래를 신청받은 상대방이 거래 신청을 허락..
			CGameProcedure::MessageBoxClose(m_szMsg);
			m_szMsg = "";

			// Trade Core Start..
			PerTradeCoreStart();
			break;	
	}
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::PerTradeCoreStart()
{
	m_ePerTradeState = PER_TRADE_STATE_NORMAL;

	m_pUIPerTradeDlg->SetVisible(true);
	m_pUIPerTradeDlg->EnterPerTradeState();

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->IsVisible())
		CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->Close();
}

void CSubProcPerTrade::PerTradeCoreInvDisable()
{
	RECT rect = { 0, 0, 0 ,0 };

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pUIPerTradeDlg->m_pPerTradeInv[i] != nullptr )
			m_pUIPerTradeDlg->m_pPerTradeInv[i]->pUIIcon->SetMoveRect(rect);
	}
}

///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::RequestItemCountEdit()
{
	if ( m_ePerTradeState != PER_TRADE_STATE_NORMAL ) return;
	m_ePerTradeState = PER_TRARE_STATE_EDITTING;

	m_pUITradeEditDlg->Open(true);
	m_pUIPerTradeDlg->PlayGoldSound();
}

void CSubProcPerTrade::ItemCountEditOK()
{
	std::string str;
	int iGold,			// 거래창의 값..
		iGoldOffset,	// 편집창의 값..
		iMyMoney;		// 인벤토리의 값..

	// 거래 창의 내 현재 돈을 얻어 온다..
	CN3UIString* pStrMy = nullptr;
	N3_VERIFY_UI_COMPONENT(pStrMy, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_my"));
	str = pStrMy->GetString();
	iGold = atoi(str.c_str());

	//  입력 창의 값을 얻어서 
	iGoldOffset = m_pUITradeEditDlg->GetQuantity();

	// Gold Offset Backup..
	m_iGoldOffsetBackup = iGoldOffset;

	// 현재 내가 가진 돈을 얻어 온다..
	iMyMoney = s_pPlayer->m_InfoExt.iGold;

	if ( iGoldOffset <= 0 ) return;
	if ( iGoldOffset > iMyMoney ) return;

	// 돈을 감소 시킨다..
	iMyMoney -= iGoldOffset;
	s_pPlayer->m_InfoExt.iGold = iMyMoney;

	// 돈 표시.. 인벤토리..
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
	if(m_pUIPerTradeDlg->m_pStrMyGold) m_pUIPerTradeDlg->m_pStrMyGold->SetStringAsInt(iMyMoney);

	// 돈 표시.. 개인 거래 창..
	iGold += iGoldOffset;
	pStrMy->SetStringAsInt(iGold);

	// 서버에게 전송한다..
	uint8_t byBuff[16];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	// 서버에게 패킷 만들어서 날림..
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_ADD);		
	CAPISocket::MP_AddByte(byBuff, iOffset, 0xff);		
	CAPISocket::MP_AddDword(byBuff, iOffset, dwGold);		
	CAPISocket::MP_AddDword(byBuff, iOffset, iGoldOffset);		

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);			// 보냄..

	m_pUITradeEditDlg->SetQuantity(0);

	// 상태를 변화시키고.. 창을 닫고..
	CN3UIBase::s_bWaitFromServer = true;
	m_ePerTradeState = PER_TRADE_STATE_NORMAL;
	m_ePerTradeItemKindBackup = PER_TRADE_ITEM_MONEY;
	m_pUITradeEditDlg->Close();

	m_pUIPerTradeDlg->PlayGoldSound();
}

void CSubProcPerTrade::ItemCountEditCancel()
{
	m_pUITradeEditDlg->SetQuantity(0);

	// 상태를 변화시키고.. 창을 닫고..
	m_ePerTradeState = PER_TRADE_STATE_NORMAL;
	m_pUITradeEditDlg->Close();

	m_pUIPerTradeDlg->PlayGoldSound();
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::PerTradeMyDecision()							// 내가 거래를 결정 했다..
{
	std::string szFN = "btn_trade_my";
	CN3UIButton* pButton;
	pButton = (CN3UIButton* )m_pUIPerTradeDlg->GetChildButtonByName(szFN);

	// 서버에게 전송한다..
	uint8_t byBuff[4];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	// 서버에게 패킷 만들어서 날림..
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_DECIDE);		

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);			// 보냄..

	// 내 결정 버튼 Disable..
	if(pButton) pButton->SetState(UI_STATE_BUTTON_DISABLE);
	SecureJobStuffByMyDecision();
}

void CSubProcPerTrade::SecureJobStuffByMyDecision()
{
	m_ePerTradeState = PER_TRADE_STATE_MY_TRADE_DECISION_DONE;

	// 1. 인벤토리 영역 Icon 움직임 방지..
	PerTradeCoreInvDisable();

	// 2. 돈 입력창 클릭 방지..		해당 부분..

	// 3. 올려놓는 버튼 금지..		해당 부분..

}

void CSubProcPerTrade::PerTradeOtherDecision()						// 다른 사람이 거래를 결정 했다..
{
	CN3UIButton* pButtonOther = nullptr;
	N3_VERIFY_UI_COMPONENT(pButtonOther, m_pUIPerTradeDlg->GetChildByID<CN3UIButton>("btn_trade_other"));
	pButtonOther->SetState(UI_STATE_BUTTON_DISABLE);
}


///////////////////////////////////////////////////////////////////////

void CSubProcPerTrade::ReceiveMsgPerTradeReq(int iOtherID)
{
	EnterWaitMyDecisionToPerTrade(iOtherID);							// 내가 타인에게서 아이템 거래를 신청 받은 상태..
}

void CSubProcPerTrade::ReceiveMsgPerTradeAgree(uint8_t bResult)
{
	switch ( bResult )
	{
		case 0x01:														// 성공..
			ProcessProceed(PER_TRADE_RESULT_OTHER_AGREE);
			break;

		case 0x00:														// 실패..
			LeavePerTradeState(PER_TRADE_RESULT_OTHER_DISAGREE);
			break;
	}
}

void CSubProcPerTrade::ReceiveMsgPerTradeAdd(uint8_t bResult)
{
	// 상태를 변화시키고.. 창을 닫고..
	CN3UIBase::s_bWaitFromServer = false;

	std::string str;
	int iGold,			// 거래창의 값..
		iMyMoney;		// 인벤토리의 값..
	
	switch ( bResult )
	{
		case 0x01:
			break;

		case 0x00:			// 실패 했을 경우.. 복구한다..	
			// 전에 작업한 아이템 종류가 돈인 경우..
			switch ( m_ePerTradeItemKindBackup )
			{
				case PER_TRADE_ITEM_MONEY:
					{
						// 거래 창의 내 현재 돈을 얻어 온다..
						CN3UIString* pStrMy = nullptr;
						N3_VERIFY_UI_COMPONENT(pStrMy, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_my"));
						str = pStrMy->GetString();
						iGold = atoi(str.c_str());

						// 현재 내가 가진 돈을 얻어 온다..
						iMyMoney = s_pPlayer->m_InfoExt.iGold;
						// 돈을 증가 시킨다..
						iMyMoney += m_iGoldOffsetBackup;
						s_pPlayer->m_InfoExt.iGold = iMyMoney;

						// 돈 표시.. 인벤토리..
						CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
						if(m_pUIPerTradeDlg->m_pStrMyGold) m_pUIPerTradeDlg->m_pStrMyGold->SetStringAsInt(iMyMoney);

						// 돈 표시.. 개인 거래 창..
						iGold -= m_iGoldOffsetBackup;
						pStrMy->SetStringAsInt(iGold);
					}
					break;

				case PER_TRADE_ITEM_OTHER:
					{
						// 전에 작업한 아이템 종류가 아이템인 경우..
						if( (m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->
							pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) ||
							(m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->
							pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
						{
							// 활이나 물약등 아이템인 경우..
							bool bFound = false;

							// 인벤토리에 아이템이 없어진 경우.. 만든다..
							if ( !m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] )
							{
								bFound = true;
								// 인벤토리에 만들고 아이템의 갯수를 정해준다..
								__IconItemSkill *spItem, *spItemNew = nullptr;
								spItem = m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

								// 아이콘이 없으면 아이콘을 만드록 갯수는 0으로..
								spItemNew				= new __IconItemSkill;
								spItemNew->pItemBasic	= spItem->pItemBasic;
								spItemNew->pItemExt		= spItem->pItemExt;
								spItemNew->szIconFN		= spItem->szIconFN; // 아이콘 파일 이름 복사..
								spItemNew->iCount		= m_pUIPerTradeDlg->m_iBackupiCount;
								spItemNew->iDurability	= spItem->iDurability;

								// 아이콘 리소스 만들기..
								spItemNew->pUIIcon		= new CN3UIIcon;
								float fUVAspect			= (float)45.0f/(float)64.0f;
								spItemNew->pUIIcon->Init(m_pUIPerTradeDlg); 
								spItemNew->pUIIcon->SetTex(spItemNew->szIconFN);
								spItemNew->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
								spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
								spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
								spItemNew->pUIIcon->SetVisible(true);
								CN3UIArea* pArea;
								pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
								if ( pArea )
								{
									spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
									spItemNew->pUIIcon->SetMoveRect(pArea->GetRegion());
								}

								m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemNew;

								// 내 거래창의 아이템이 있는 경우 .. 갯수 갱신..
								if ( m_pUIPerTradeDlg->m_iBackupiCount != 
									m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount )
								{
									m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount
										-= m_pUIPerTradeDlg->m_iBackupiCount;
								}
							}

							// 아이콘이 내 거래창의 슬롯에 생긴경우.. 삭제한다..
							if ( m_pUIPerTradeDlg->m_iBackupiCount == 
								m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount )
							{
								bFound = true;

								__IconItemSkill* spItem;
								spItem = m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

								// 매니저에서 제거..
								m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

								// 리소스 제거..
								spItem->pUIIcon->Release();
								delete spItem->pUIIcon;
								spItem->pUIIcon = nullptr;
								delete spItem;
								spItem = nullptr;
								m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

								// 인벤토리에 아이템이 있는 경우.. 갯수 갱신..
								if ( m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] )
								{
									m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount
										+= m_pUIPerTradeDlg->m_iBackupiCount;
								}
							}

							// 위에서 갯수 보정한게 아니면.. 갯수만 보정한다..
							if ( !bFound)
							{
								// 내 거래창과 인벤토리의 아이템의 갯수를 정해준다..
								m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount
									+= m_pUIPerTradeDlg->m_iBackupiCount;

								m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount
									-= m_pUIPerTradeDlg->m_iBackupiCount;
							}
						}
						else
						{
							__IconItemSkill* spItem;
							spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;
							spItem->pUIIcon->SetParent(m_pUIPerTradeDlg);

							// 인벤토리 윈도우에 세팅하고..
							m_pUIPerTradeDlg->m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItem;

							// 내 거래 윈도우에서 클리어..
							m_pUIPerTradeDlg->m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

							CN3UIArea* pArea;
							pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
							if ( pArea )
							{
								spItem->pUIIcon->SetRegion(pArea->GetRegion());
								spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
							}
						}
					}
					break;
			}
			break;
	}
}

void CSubProcPerTrade::ReceiveMsgPerTradeOtherAdd(int iItemID, int iCount, int iDurability)
{
	std::string str;
	int iGold, iDestiOrder;			// 거래창의 값..

	if ( iItemID == dwGold )
	{
		// 거래 창의 다른 사람의 현재 돈을 얻어 온다..
		CN3UIString* pStrOther = nullptr;
		N3_VERIFY_UI_COMPONENT(pStrOther, m_pUIPerTradeDlg->GetChildByID<CN3UIString>("string_money_other"));
		str = pStrOther->GetString();
		iGold = atoi(str.c_str());
		
		// 돈을 더한 다음..
		iGold += iCount;

		// 돈 표시.. 개인 거래 창..
		pStrOther->SetStringAsInt(iGold);
	}
	else
	{
		// 아이템이 들어갈 수 있는지 확인, 아이템이 들어 가는 자리 계산..
		bool  bFound = false;

		// 아이템 만들어서 넣기..
		__TABLE_ITEM_BASIC*	pItem = nullptr;
		__TABLE_ITEM_EXT*	pItemExt = nullptr;
		pItem = s_pTbl_Items_Basic.Find(iItemID/1000*1000);	// 열 데이터 얻기..
		if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
			pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemID%1000);
		if(nullptr == pItem || nullptr == pItemExt)
		{
			__ASSERT(0, "아이템 포인터 테이블에 없음!!");
			return;
		}

		if( (pItem->byContable == UIITEM_TYPE_COUNTABLE) || (pItem->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
		{
			for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
			{
				if( (m_pUIPerTradeDlg->m_pPerTradeOther[i]) && (m_pUIPerTradeDlg->m_pPerTradeOther[i]->pItemBasic->dwID == pItem->dwID) )
				{
					bFound = true;
					iDestiOrder = i;
					break;
				}
			}

			// 못찾았으면.. 
			if ( !bFound )
			{
				// 인벤토리 빈슬롯을 찾아 들어간다..
				for(int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
				{
					if ( !m_pUIPerTradeDlg->m_pPerTradeOther[i] )
					{
						bFound = true;
						iDestiOrder = i;
						break;
					}
				}

				if ( !bFound )	// 빈 슬롯을 찾지 못했으면..
					return;
			}

			if ( m_pUIPerTradeDlg->m_pPerTradeOther[iDestiOrder] )	// 해당 위치에 아이콘이 있으면..
			{
				m_pUIPerTradeDlg->m_pPerTradeOther[iDestiOrder]->iCount += iCount;
			}
			else
			{
				std::string szIconFN;
				e_PartPosition ePart;
				e_PlugPosition ePlug;
				CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, RACE_UNKNOWN); // 아이템에 따른 파일 이름을 만들어서

				__IconItemSkill* spItem;

				spItem				= new __IconItemSkill;
				spItem->pItemBasic	= pItem;
				spItem->pItemExt	= pItemExt;
				spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
				spItem->iCount		= iCount;
				spItem->iDurability = iDurability;
				float fUVAspect		= (float)45.0f/(float)64.0f;
				spItem->pUIIcon		= new CN3UIIcon;
				spItem->pUIIcon->Init(m_pUIPerTradeDlg); 
				spItem->pUIIcon->SetTex(szIconFN);
				spItem->pUIIcon->SetUVRect(0,0,fUVAspect,fUVAspect);
				spItem->pUIIcon->SetUIType(UI_TYPE_ICON);
				spItem->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
				spItem->pUIIcon->SetVisible(true);

				CN3UIArea* pArea = nullptr;
				//pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_OTHER, i);
				if ( pArea )
				{
					spItem->pUIIcon->SetRegion(pArea->GetRegion());
					// 움직일 수 없다..
					RECT rect = { 0, 0, 0, 0 };
					spItem->pUIIcon->SetMoveRect(rect);
				}

				//m_pUIPerTradeDlg->m_pPerTradeOther[i] = spItem;
			}
		}
		else
		{
			for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
			{
				if (m_pUIPerTradeDlg->m_pPerTradeOther[i] == nullptr)	
				{
					bFound = true;
					break;
				}
			}

			if ( !bFound )	return;	// 못 찾았으므로.. 실패..

			std::string szIconFN;
			e_PartPosition ePart;
			e_PlugPosition ePlug;
			CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, RACE_UNKNOWN); // 아이템에 따른 파일 이름을 만들어서

			__IconItemSkill* spItem;

			spItem				= new __IconItemSkill;
			spItem->pItemBasic	= pItem;
			spItem->pItemExt	= pItemExt;
			spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
			spItem->iCount		= 1;
			spItem->iDurability = iDurability;
			float fUVAspect		= (float)45.0f/(float)64.0f;
			spItem->pUIIcon		= new CN3UIIcon;
			spItem->pUIIcon->Init(m_pUIPerTradeDlg); 
			spItem->pUIIcon->SetTex(szIconFN);
			spItem->pUIIcon->SetUVRect(0,0,fUVAspect,fUVAspect);
			spItem->pUIIcon->SetUIType(UI_TYPE_ICON);
			spItem->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
			spItem->pUIIcon->SetVisible(true);

			CN3UIArea* pArea = nullptr;
			//pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_OTHER, i);
			if ( pArea )
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				// 움직일 수 없다..
				RECT rect = { 0, 0, 0, 0 };
				spItem->pUIIcon->SetMoveRect(rect);
			}

			if ( spItem->iDurability == 0 )
				spItem->pUIIcon->SetStyle(spItem->pUIIcon->GetStyle() | UISTYLE_DURABILITY_EXHAUST);	

			//m_pUIPerTradeDlg->m_pPerTradeOther[i] = spItem;
		}
	}
}

void CSubProcPerTrade::ReceiveMsgPerTradeOtherDecide()
{
	PerTradeOtherDecision();
}

void CSubProcPerTrade::ReceiveMsgPerTradeDoneSuccessBegin(int iTotalGold)
{
	s_pPlayer->m_InfoExt.iGold = iTotalGold;
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
}

void CSubProcPerTrade::ReceiveMsgPerTradeDoneItemMove(uint8_t bItemPos, int iItemID, int iCount, int iDurability)
{
	__IconItemSkill* spItem;

	// 아이템 인벤토리 INV 영역에 추가..
	// 아이템이 들어갈 수 있는지 확인..
	if ( m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos] != nullptr )
	{
		if ( iItemID != (m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->pItemBasic->dwID/1000*1000)+
			(m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->pItemExt->dwID%1000) )
		{
			// 기존 아이콘을 클리어..
			spItem =  m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos];

			// 매니저에서 제거..
			m_pUIPerTradeDlg->RemoveChild(spItem->pUIIcon);

			// 리소스 제거..
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
			m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos] = nullptr;

			// 서버가 준 아이디로 아이콘을 만든다..
			goto Make_Icon;	
		}

		switch (m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->pItemBasic->byContable)
		{
			case UIITEM_TYPE_COUNTABLE:						 // 화살 같은 종류..
				m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount += iCount;
				if (m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount > UIITEM_COUNT_MANY)
					m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount = UIITEM_COUNT_MANY;
				return;
				break;

			case UIITEM_TYPE_COUNTABLE_SMALL:			// 물약같은 종류..		
				m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount += iCount;
				if (m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount > UIITEM_COUNT_FEW)
					m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos]->iCount = UIITEM_COUNT_FEW;
				return;
				break;
		}		
	}

Make_Icon:

	// 아이템 만들어서 넣기..
	__TABLE_ITEM_BASIC*	pItem = nullptr;
	__TABLE_ITEM_EXT*	pItemExt = nullptr;
	pItem = s_pTbl_Items_Basic.Find(iItemID/1000*1000);	// 열 데이터 얻기..
	if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemID%1000);
	if(nullptr == pItem || nullptr == pItemExt)
	{
		__ASSERT(0, "아이템 포인터 테이블에 없음!!");
		return;
	}

	std::string szIconFN;
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, RACE_UNKNOWN); // 아이템에 따른 파일 이름을 만들어서

	spItem				= new __IconItemSkill;
	spItem->pItemBasic	= pItem;
	spItem->pItemExt	= pItemExt;
	spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
	spItem->iCount		= iCount;
	spItem->iDurability = iDurability;

	float fUVAspect		= (float)45.0f/(float)64.0f;
	spItem->pUIIcon		= new CN3UIIcon;
	spItem->pUIIcon->Init(m_pUIPerTradeDlg); 
	spItem->pUIIcon->SetTex(szIconFN);
	spItem->pUIIcon->SetUVRect(0,0,fUVAspect,fUVAspect);
	spItem->pUIIcon->SetUIType(UI_TYPE_ICON);
	spItem->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
	spItem->pUIIcon->SetVisible(true);

	CN3UIArea* pArea = nullptr;
	pArea = m_pUIPerTradeDlg->GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, bItemPos);
	if ( pArea )
	{
		spItem->pUIIcon->SetRegion(pArea->GetRegion());
		spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	if ( spItem->iDurability == 0 )
		spItem->pUIIcon->SetStyle(spItem->pUIIcon->GetStyle() | UISTYLE_DURABILITY_EXHAUST);	

	m_pUIPerTradeDlg->m_pPerTradeInv[bItemPos] = spItem;	
}

void CSubProcPerTrade::ReceiveMsgPerTradeDoneSuccessEnd()
{
	// 뒷 마무리..
	PerTradeCompleteSuccess();
	FinalizePerTrade();

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg) CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();
	if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg) CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CSubProcPerTrade::ReceiveMsgPerTradeDoneFail()
{
	if (s_pOPMgr->UPCGetByID(m_iOtherID, false) != nullptr)
	{
		std::string szMsg = fmt::format_text_resource(IDS_PER_TRADE_FAIL);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffffffff);

		szMsg = fmt::format_text_resource(IDS_ITEM_TOOMANY_OR_HEAVY);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}

	PerTradeCompleteCancel();
	FinalizePerTrade();
}

void CSubProcPerTrade::ReceiveMsgPerTradeCancel()
{
	// 메시지 박스 텍스트 표시..
	CPlayerOther* pUPC = s_pOPMgr->UPCGetByID(m_iOtherID, false);
	if (pUPC != nullptr)
	{
		std::string szMsg = fmt::format_text_resource(IDS_OTHER_PER_TRADE_CANCEL,
			pUPC->IDString());
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}

	// 뒷 마무리..
	PerTradeCompleteCancel();
	FinalizePerTrade();
}

void CSubProcPerTrade::ItemCountOK()
{
	m_pUIPerTradeDlg->ItemCountOK();
}

void CSubProcPerTrade::ItemCountCancel()
{
	m_pUIPerTradeDlg->ItemCountCancel();
}

// ===== END WarFare/SubProcPerTrade.cpp =====

// ===== BEGIN WarFare/SubProcPerTrade.h =====
#line 1 "WarFare/SubProcPerTrade.h"
﻿// SubProcPerTrade.h: interface for the CSubProcPerTrade class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SUBPROCPERTRADE_H__555E4865_7877_425D_8F29_DD028F251889__INCLUDED_)
#define AFX_SUBPROCPERTRADE_H__555E4865_7877_425D_8F29_DD028F251889__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

enum e_PerTradeState	{												// 아이템 개인 거래 상태..
							PER_TRADE_STATE_NONE = 0,					// 아무것도 아님..
							PER_TRADE_STATE_WAIT_FOR_REQ,				// 상대방에게 요청하고 응답을 기다림..
							PER_TRADE_STATE_WAIT_FOR_MY_DECISION_AGREE_OR_DISAGREE,	// 상대방에게서 요청받고 내 결정을 기다림..
							PER_TRADE_STATE_NORMAL,						// 아이템 개인 거래 정상적인 상태..
							PER_TRADE_STATE_ADD_AND_WAIT_FROM_SERVER,	// 아이템을 더하고 서버로 부터 응답을 기다림..	
							PER_TRARE_STATE_EDITTING,					// 아이템 개인 거래 금액이나 갯수등 편집중..
							PER_TRADE_STATE_MY_TRADE_DECISION_DONE,		// 내 거래 버튼 누른 상태..	
						};

enum e_PerTradeResultCode	{										// 아이템 거래가 해제되는 코드 정의..								
								PER_TRADE_RESULT_MY_DISAGREE = 0,	// 거래를 신청받은 내가 거래 신청을 취소..
								PER_TRADE_RESULT_OTHER_DISAGREE,	// 거래를 신청받은 상대방이 거래 신청을 취소..
								PER_TRADE_RESULT_MY_CANCEL,			// 거래를 신청한 내가 거래 신청을 취소..


							};

enum e_PerTradeProceedCode	{										// 아이템 거래가 계속되는 상태를 정의..
								PER_TRADE_RESULT_MY_AGREE = 0,		// 거래를 신청받은 내가 거래 신청을 허락..
								PER_TRADE_RESULT_OTHER_AGREE,		// 거래를 신청받은 상대방이 거래 신청을 허락..



							};

enum e_PerTradeItemKindBackup	{
									PER_TRADE_ITEM_MONEY = 0,		// 전에 개인 거래창으로 ADD한 것이 돈이다..
									PER_TRADE_ITEM_OTHER,			// 전에 개인 거래창으로 ADD한 것이 아이템이다..
								};

const uint32_t dwGold = 900000000;	// 음...

class CUIManager;
class CUIPerTradeDlg;
class CUITradeEditDlg;

#include "GameBase.h"

class CSubProcPerTrade : public CGameBase
{
protected:
	int					m_iOtherID;
	int					m_iGoldOffsetBackup;

	std::string			m_szMsg;	// MessageBox key

public:
	CUIPerTradeDlg*				m_pUIPerTradeDlg;
	CUITradeEditDlg*			m_pUITradeEditDlg;

	e_PerTradeState				m_ePerTradeState;
	e_PerTradeItemKindBackup	m_ePerTradeItemKindBackup;

public:
	CSubProcPerTrade();
	virtual ~CSubProcPerTrade();

	void	Release();

	void	InitPerTradeDlg(CUIManager* pUIManager);

	void	EnterWaitMsgFromServerStatePerTradeReq();			// 내가 아이템 거래를 타인에게 신청한 상태..
	void	EnterWaitMsgFromServerStatePerTradeReq(std::string szName);			// 내가 아이템 거래를 타인에게 신청한 상태..
	void	EnterWaitMyDecisionToPerTrade(int iOtherID);		// 내가 타인에게서 아이템 거래를 신청 받은 상태..
	void	LeavePerTradeState(e_PerTradeResultCode ePTRC);		// 아이템 거래 상태가 해제되는 코드..
	void	ProcessProceed(e_PerTradeProceedCode ePTPC);		// 아이템 거래가 계속되는 상태를 정의..

	void	SecureCodeBegin();									// 보호 코드..

	void	PerTradeCoreStart();
	void	PerTradeCoreInvDisable();

	void	RequestItemCountEdit();
	void	ItemCountEditOK();
	void	ItemCountEditCancel();

	void	FinalizePerTrade();									// 말 그대로 최종 뒷처리..
	void	PerTradeCompleteSuccess();							// 개인 거래 최종 성공..
	void	PerTradeCompleteCancel();							// 개인 거래 취소..	

	void	PerTradeMyDecision();								// 내가 거래를 결정 했다..
	void	PerTradeOtherDecision();							// 다른 사람이 거래를 결정 했다..

	void	SecureJobStuffByMyDecision();

	void	ReceiveMsgPerTradeReq(int iOtherID);
	void	ReceiveMsgPerTradeAgree(uint8_t bResult);
	void	ReceiveMsgPerTradeAdd(uint8_t bResult);
	void	ReceiveMsgPerTradeOtherAdd(int iItemID, int iCount, int iDurability);
	void	ReceiveMsgPerTradeOtherDecide();
	void	ReceiveMsgPerTradeDoneSuccessBegin(int iTotalGold);
	void	ReceiveMsgPerTradeDoneItemMove(uint8_t bItemPos, int iItemID, int iCount, int iDurability);
	void	ReceiveMsgPerTradeDoneSuccessEnd();
	void	ReceiveMsgPerTradeDoneFail();
	void	ReceiveMsgPerTradeCancel();

	// Item Count OK..
	void	ItemCountOK();
	void	ItemCountCancel();
};

#endif // !defined(AFX_SUBPROCPERTRADE_H__555E4865_7877_425D_8F29_DD028F251889__INCLUDED_)

// ===== END WarFare/SubProcPerTrade.h =====

// ===== BEGIN WarFare/UICharacterCreate.cpp =====
#line 1 "WarFare/UICharacterCreate.cpp"
﻿// UICharacterCreate.cpp: implementation of the CUICharacterCreate class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "UICharacterCreate.h"
#include "GameProcCharacterCreate.h"
#include "PlayerMySelf.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIArea.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UITooltip.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICharacterCreate::CUICharacterCreate()
{
	memset(m_pBtn_Races, 0, sizeof(m_pBtn_Races));
	memset(m_pBtn_Classes, 0, sizeof(m_pBtn_Classes));
	memset(m_pImg_Disable_Classes, 0, sizeof(m_pImg_Disable_Classes));
	memset(m_pStr_Stats, 0, sizeof(m_pStr_Stats));
	memset(m_pArea_Stats, 0, sizeof(m_pArea_Stats));
	m_pStr_Desc = nullptr;
	m_pStr_Bonus = nullptr;

	m_pBtn_Face_Left = nullptr;
	m_pBtn_Face_Right = nullptr;
	m_pBtn_Hair_Left = nullptr;
	m_pBtn_Hair_Right = nullptr;

	m_pArea_Character = nullptr;

	m_iBonusPoint = m_iMaxBonusPoint = 0;
}

CUICharacterCreate::~CUICharacterCreate()
{
}

void CUICharacterCreate::Release()
{
	CN3UIBase::Release();

	memset(m_pBtn_Races, 0, sizeof(m_pBtn_Races));
	memset(m_pBtn_Classes, 0, sizeof(m_pBtn_Classes));
	memset(m_pImg_Disable_Classes, 0, sizeof(m_pImg_Disable_Classes));
	memset(m_pStr_Stats, 0, sizeof(m_pStr_Stats));
	memset(m_pArea_Stats, 0, sizeof(m_pArea_Stats));

	m_pStr_Desc = nullptr;
	m_pStr_Bonus = nullptr;

	m_pBtn_Face_Left = nullptr;
	m_pBtn_Face_Right = nullptr;
	m_pBtn_Hair_Left = nullptr;
	m_pBtn_Hair_Right = nullptr;

	m_pArea_Character = nullptr;

	m_iBonusPoint = m_iMaxBonusPoint = 0;
}

bool CUICharacterCreate::Load(File& file)
{
	CN3UIBase::Load(file);

	// 캐릭터 초기화..
	__InfoPlayerBase* pInfoBase = &(CGameBase::s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

	pInfoBase->eRace = RACE_UNKNOWN;
	pInfoBase->eClass = CLASS_UNKNOWN;

	N3_VERIFY_UI_COMPONENT(m_pEdit_Name, GetChildByID<CN3UIEdit>("edit_name"));
	if(m_pEdit_Name) m_pEdit_Name->SetString("");
	
	N3_VERIFY_UI_COMPONENT(m_pStr_Desc, GetChildByID<CN3UIString>("text_desc"));
	e_Nation eNation = pInfoBase->eNation;
	if(m_pStr_Desc)
	{
		if(NATION_KARUS == eNation)
		{
			std::string szMsg = fmt::format_text_resource(IDS_SETTING_KARUS_SCREEN);
			m_pStr_Desc->SetString(szMsg);
		}
		else if(NATION_ELMORAD == eNation)
		{
			std::string szMsg = fmt::format_text_resource(IDS_SETTING_ELMORAD_SCREEN);
			m_pStr_Desc->SetString(szMsg);
		}
	}

	N3_VERIFY_UI_COMPONENT(m_pArea_Character, GetChildByID<CN3UIArea>("area_character"));
	
	std::string szTexts[MAX_STATS] = { "text_str", "text_sta", "text_dex", "text_int", "text_map" };
	std::string szAreas[MAX_STATS] = { "area_str", "area_sta", "area_dex", "area_int", "area_map" };
	std::string szImgs[MAX_STATS] = { "img_str", "img_sta", "img_dex", "img_int", "img_map" };
	uint32_t dwResrcIDs[MAX_STATS] = { IDS_NEWCHR_POW, IDS_NEWCHR_STA, IDS_NEWCHR_DEX, IDS_NEWCHR_INT, IDS_NEWCHR_MAP };
	for(int i = 0; i < MAX_STATS; i++)
	{
		N3_VERIFY_UI_COMPONENT(m_pStr_Stats[i],			GetChildByID<CN3UIString>(szTexts[i]));
		N3_VERIFY_UI_COMPONENT(m_pArea_Stats[i],		GetChildByID<CN3UIArea>(szAreas[i]));
		N3_VERIFY_UI_COMPONENT(m_pStr_Stat_Labels[i],	GetChildByID<CN3UIString>(szImgs[i]));

		if (m_pArea_Stats[i] != nullptr)
			m_pArea_Stats[i]->SetTooltipText(fmt::format_text_resource(dwResrcIDs[i]));
	}

	N3_VERIFY_UI_COMPONENT(m_pStr_Bonus, GetChildByID<CN3UIString>("text_bonus"));
	

	N3_VERIFY_UI_COMPONENT(m_pBtn_Face_Left, GetChildByID<CN3UIButton>("btn_face_left"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Face_Right, GetChildByID<CN3UIButton>("btn_face_right"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Hair_Left, GetChildByID<CN3UIButton>("btn_hair_left"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Hair_Right, GetChildByID<CN3UIButton>("btn_hair_right"));
	
	std::string szBtnIDs[MAX_RACE_SELECT];
	uint32_t dwResrcID_Races[MAX_RACE_SELECT];

	if (eNation == NATION_KARUS)
	{
		szBtnIDs[0] = "btn_race_ka_at";
		szBtnIDs[1] = "btn_race_ka_tu";
		szBtnIDs[2] = "btn_race_ka_wt";
		szBtnIDs[3] = "btn_race_ka_pt";
		dwResrcID_Races[0] = IDS_NEWCHR_KA_ARKTUAREK; // 3211 
		dwResrcID_Races[1] = IDS_NEWCHR_KA_TUAREK; // 3216
		dwResrcID_Races[2] = IDS_NEWCHR_KA_WRINKLETUAREK; // 3218
		dwResrcID_Races[3] = IDS_NEWCHR_KA_PURITUAREK; // 3214
	}
	else // if (eNation == NATION_ELMORAD)
	{
		szBtnIDs[0] = "btn_race_el_ba";
		szBtnIDs[1] = "btn_race_el_rm";
		szBtnIDs[2] = "btn_race_el_rf";
		szBtnIDs[3] = "";
		dwResrcID_Races[0] = IDS_NEWCHR_EL_BABA;
		dwResrcID_Races[1] = IDS_NEWCHR_EL_MALE;
		dwResrcID_Races[2] = IDS_NEWCHR_EL_FEMALE;
		dwResrcID_Races[3] = -1;
	}

	for(int i = 0; i < MAX_RACE_SELECT; i++)
	{
		if(szBtnIDs[i].empty()) continue;
		N3_VERIFY_UI_COMPONENT(m_pBtn_Races[i], GetChildByID<CN3UIButton>(szBtnIDs[i]));

		if (m_pBtn_Races[i] != nullptr)
			m_pBtn_Races[i]->SetTooltipText(fmt::format_text_resource(dwResrcID_Races[i]));
	}

	std::string szBtns[MAX_CLASS_SELECT] = { "btn_class_warrior", "btn_class_rogue", "btn_class_mage", "btn_class_priest" };
	std::string szImgs2[MAX_CLASS_SELECT] = { "img_warrior", "img_rogue", "img_mage", "img_priest" };
	uint32_t dwResrcID_Classes[MAX_CLASS_SELECT];
	if (eNation == NATION_KARUS)
	{
		dwResrcID_Classes[0] = IDS_NEWCHR_KA_WARRIOR;
		dwResrcID_Classes[1] = IDS_NEWCHR_KA_ROGUE;
		dwResrcID_Classes[2] = IDS_NEWCHR_KA_MAGE;
		dwResrcID_Classes[3] = IDS_NEWCHR_KA_PRIEST;
	}
	else // if (eNation == NATION_ELMORAD)
	{
		dwResrcID_Classes[0] = IDS_NEWCHR_EL_WARRIOR;
		dwResrcID_Classes[1] = IDS_NEWCHR_EL_ROGUE;
		dwResrcID_Classes[2] = IDS_NEWCHR_EL_MAGE;
		dwResrcID_Classes[3] = IDS_NEWCHR_EL_PRIEST;
	}

	for(int i = 0; i < MAX_CLASS_SELECT; i++)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_Classes[i],			GetChildByID<CN3UIButton>(szBtns[i]));
		N3_VERIFY_UI_COMPONENT(m_pImg_Disable_Classes[i],	GetChildByID<CN3UIImage>(szImgs2[i]));

		if (m_pBtn_Classes[i] != nullptr)
			m_pBtn_Classes[i]->SetTooltipText(fmt::format_text_resource(dwResrcID_Classes[i]));
	}

	RECT rc = this->GetRegion();
	int iX = ((int)s_CameraData.vp.Width - (rc.right - rc.left))/2;
	int iY = ((int)s_CameraData.vp.Height - (rc.bottom - rc.top))/2;
	this->SetPos(iX, iY);
	this->Reset();

	return true;
}

bool CUICharacterCreate::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		__InfoPlayerBase* pInfoBase = &(CGameBase::s_pPlayer->m_InfoBase);
		__InfoPlayerMySelf* pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

		//종족 고르기..
		e_Nation eNation = pInfoBase->eNation;
		e_Race eRacePrev = pInfoBase->eRace;
		bool bNeedUpdateRaceButtons = false;
		if(eNation == NATION_ELMORAD)
		{
			if ( pSender == m_pBtn_Races[0] )
			{
				pInfoBase->eRace = RACE_EL_BABARIAN;
				bNeedUpdateRaceButtons = true;
			}
			else if ( pSender == m_pBtn_Races[1] )
			{
				pInfoBase->eRace = RACE_EL_MAN;
				bNeedUpdateRaceButtons = true;
			}
			else if ( pSender == m_pBtn_Races[2] )
			{
				pInfoBase->eRace = RACE_EL_WOMEN;
				bNeedUpdateRaceButtons = true;
			}
		}
		else if(eNation ==NATION_KARUS)
		{
			if ( pSender == m_pBtn_Races[0] )
			{
				pInfoBase->eRace = RACE_KA_ARKTUAREK;
				bNeedUpdateRaceButtons = true;
			}
			else if ( pSender == m_pBtn_Races[1] )
			{
				pInfoBase->eRace = RACE_KA_TUAREK;
				bNeedUpdateRaceButtons = true;
			}
			else if ( pSender == m_pBtn_Races[2] )
			{
				pInfoBase->eRace = RACE_KA_WRINKLETUAREK;
				bNeedUpdateRaceButtons = true;
			}
			else if ( pSender == m_pBtn_Races[3] )
			{
				pInfoBase->eRace = RACE_KA_PURITUAREK;
				bNeedUpdateRaceButtons = true;
			}
		}

		if(	bNeedUpdateRaceButtons ) // 몬가 바뀌었으면..
		{
			if(eRacePrev != pInfoBase->eRace) // 종족을 바꿨을때만..
				CGameProcedure::s_pProcCharacterCreate->SetChr(); // 캐릭터 세팅..
			this->UpdateRaceAndClassButtons(pInfoBase->eRace);
		}

		int iFacePrev = pInfoExt->iFace;
		int iHairPrev = pInfoExt->iHair;

		if ( pSender->m_szID == "btn_cancel" )
		{
			CGameProcedure::ProcActiveSet((CGameProcedure*)CGameProcedure::s_pProcCharacterSelect); // 캐릭터 선택 프로시저로 한다..
			return true;
		}
		else if ( pSender->m_szID == "btn_create" && m_pEdit_Name)
		{
			CGameBase::s_pPlayer->IDSet(0, m_pEdit_Name->GetString(), 0); // 이름을 넣어주고...
			return CGameProcedure::s_pProcCharacterCreate->MsgSendCharacterCreate(); // 캐릭터 만들기 메시지 보내기...
		}
		else if ( pSender == m_pBtn_Face_Left ) // 얼굴
		{
			pInfoExt->iFace--;
			if(pInfoExt->iFace < 0) pInfoExt->iFace = 0;
		}
		else if ( pSender == m_pBtn_Face_Right )
		{
			pInfoExt->iFace++;
			if(pInfoExt->iFace > 3) pInfoExt->iFace = 3;
		}
		else if ( pSender == m_pBtn_Hair_Left ) // 머리카락..
		{
			pInfoExt->iHair--;
			if(pInfoExt->iHair < 0) pInfoExt->iHair = 0;
		}
		else if ( pSender == m_pBtn_Hair_Right )
		{
			pInfoExt->iHair++;
			if(pInfoExt->iHair > 2) pInfoExt->iHair = 2;
		}

		if(	iFacePrev != pInfoExt->iFace ) CGameBase::s_pPlayer->InitFace(); // 얼굴이 바뀌면..
		if(	iHairPrev != pInfoExt->iHair ) CGameBase::s_pPlayer->InitHair(); // 머리카락이 바뀌면..

		//직업 고르기..
		bool bNeedUpdateClassButton = false;
		if ( pSender == m_pBtn_Classes[0] ) // 전사
		{
			if(	NATION_KARUS == eNation ) pInfoBase->eClass = CLASS_KA_WARRIOR;
			else if(NATION_ELMORAD == eNation) pInfoBase->eClass = CLASS_EL_WARRIOR;
			bNeedUpdateClassButton = true;
		}
		else if ( pSender == m_pBtn_Classes[1] ) // 로그
		{
			if(	NATION_KARUS == eNation ) pInfoBase->eClass = CLASS_KA_ROGUE;
			else if(NATION_ELMORAD == eNation) pInfoBase->eClass = CLASS_EL_ROGUE;
			bNeedUpdateClassButton = true;
		}
		else if ( pSender == m_pBtn_Classes[2] ) // 마법사
		{
			if(	NATION_KARUS == eNation ) pInfoBase->eClass = CLASS_KA_WIZARD;
			else if(NATION_ELMORAD == eNation) pInfoBase->eClass = CLASS_EL_WIZARD;
			bNeedUpdateClassButton = true;
		}
		else if ( pSender == m_pBtn_Classes[3] ) // 사제
		{
			if(	NATION_KARUS == eNation ) pInfoBase->eClass = CLASS_KA_PRIEST;
			else if(NATION_ELMORAD == eNation) pInfoBase->eClass = CLASS_EL_PRIEST;
			bNeedUpdateClassButton = true;
		}
		
		if(bNeedUpdateClassButton)
			this->UpdateClassButtons(pInfoBase->eClass);

		//수치 올리기..
		if ( pSender->m_szID == "btn_str_right" ) // 힘
		{
			if(m_iBonusPoint>0)
			{
				pInfoExt->iStrength++;
				m_iBonusPoint--;

				if(m_pStr_Stats[0]) m_pStr_Stats[0]->SetStringAsInt(pInfoExt->iStrength);
				if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
			}
		}
		else if ( pSender->m_szID == "btn_sta_right" ) // 체력
		{
			if(m_iBonusPoint>0)
			{
				pInfoExt->iStamina++;
				m_iBonusPoint--;

				if(m_pStr_Stats[1]) m_pStr_Stats[1]->SetStringAsInt(pInfoExt->iStamina);
				if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
			}
		}
		else if ( pSender->m_szID == "btn_dex_right" ) // 민첩
		{
			if(m_iBonusPoint>0)
			{
				pInfoExt->iDexterity++;
				m_iBonusPoint--;

				if(m_pStr_Stats[2]) m_pStr_Stats[2]->SetStringAsInt(pInfoExt->iDexterity);
				if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);				
			}
		}
		else if ( pSender->m_szID == "btn_int_right" ) // 지능
		{
			if(m_iBonusPoint>0)
			{
				pInfoExt->iIntelligence++;
				m_iBonusPoint--;

				if(m_pStr_Stats[3]) m_pStr_Stats[3]->SetStringAsInt(pInfoExt->iIntelligence);
				if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
			}
		}
		else if ( pSender->m_szID == "btn_map_right" ) // 마력
		{
			if(m_iBonusPoint>0)
			{
				pInfoExt->iMagicAttak++;
				m_iBonusPoint--;

				if(m_pStr_Stats[4]) m_pStr_Stats[4]->SetStringAsInt(pInfoExt->iMagicAttak);
				if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
			}
		}

		__TABLE_NEW_CHR* pTbl = CGameProcedure::s_pProcCharacterCreate->m_Tbl_InitValue.Find(
			(pInfoBase->eRace * 10000) + pInfoBase->eClass);

		if(pTbl)
		{
			//수치 내리기..
			if ( pSender->m_szID == "btn_str_left" ) // 힘
			{
				if( m_iBonusPoint < m_iMaxBonusPoint && pInfoExt->iStrength > pTbl->iStr )
				{
					pInfoExt->iStrength--;
					m_iBonusPoint++;

					if(m_pStr_Stats[0]) m_pStr_Stats[0]->SetStringAsInt(pInfoExt->iStrength);
					if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
				}
			}
			else if ( pSender->m_szID == "btn_sta_left" ) // 체력
			{
				if( m_iBonusPoint < m_iMaxBonusPoint && pInfoExt->iStamina > pTbl->iSta )
				{
					pInfoExt->iStamina--;
					m_iBonusPoint++;

					if(m_pStr_Stats[1]) m_pStr_Stats[1]->SetStringAsInt(pInfoExt->iStamina);
					if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
				}
			}
			else if ( pSender->m_szID == "btn_dex_left" ) // 민첩
			{
				if( m_iBonusPoint < m_iMaxBonusPoint && pInfoExt->iDexterity > pTbl->iDex )
				{
					pInfoExt->iDexterity--;
					m_iBonusPoint++;

					if(m_pStr_Stats[2]) m_pStr_Stats[2]->SetStringAsInt(pInfoExt->iDexterity);
					if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
				}
			}
			else if ( pSender->m_szID == "btn_int_left" ) // 지능
			{
				if( m_iBonusPoint < m_iMaxBonusPoint && pInfoExt->iIntelligence > pTbl->iInt )
				{
					pInfoExt->iIntelligence--;
					m_iBonusPoint++;

					if(m_pStr_Stats[3]) m_pStr_Stats[3]->SetStringAsInt(pInfoExt->iIntelligence);
					if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
				}
			}
			else if ( pSender->m_szID == "btn_map_left" ) // 마력
			{
				if( m_iBonusPoint < m_iMaxBonusPoint && pInfoExt->iMagicAttak > pTbl->iMAP )
				{
					pInfoExt->iMagicAttak--;
					m_iBonusPoint++;
	
					if(m_pStr_Stats[4]) m_pStr_Stats[4]->SetStringAsInt(pInfoExt->iMagicAttak);
					if(m_pStr_Bonus) m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
				}
			}
		}
	}
	return true;
}

void CUICharacterCreate::Reset()
{
	__InfoPlayerBase* pInfoBase = &(CGameBase::s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf* pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

	if(m_pArea_Character) 
		CGameProcedure::s_pProcCharacterCreate->m_rcChr = m_pArea_Character->GetRegion();

	for(int i = 0; i < MAX_CLASS_SELECT; i++)
	{
		if(m_pImg_Disable_Classes[i]) m_pImg_Disable_Classes[i]->SetVisible(true);
		if(m_pBtn_Classes[i]) m_pBtn_Classes[i]->SetVisible(false);
	}

	this->UpdateStats();
}

void CUICharacterCreate::UpdateStats()
{
	__InfoPlayerMySelf* pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);
	int iStats[MAX_STATS] = { pInfoExt->iStrength, pInfoExt->iStamina, pInfoExt->iDexterity, pInfoExt->iIntelligence, pInfoExt->iMagicAttak };

	for (int i = 0; i < MAX_STATS; i++)
	{
		if (m_pStr_Stat_Labels[i] != nullptr)
			m_pStr_Stat_Labels[i]->SetVisible(false);

		if (m_pStr_Stats[i] != nullptr)
			m_pStr_Stats[i]->SetStringAsInt(iStats[i]);
	}

	if (m_pStr_Bonus != nullptr)
		m_pStr_Bonus->SetStringAsInt(m_iBonusPoint);
}

uint32_t CUICharacterCreate::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	if(m_pStr_Desc)
	{
		m_pStr_Desc->SetColor(0xffffff00);
		for(int i = 0; i < MAX_STATS; i++)
		{
			if(m_pArea_Stats[i] && m_pArea_Stats[i]->IsIn(ptCur.x, ptCur.y))
			{
				m_pStr_Desc->SetString(m_pArea_Stats[i]->m_szToolTip);
				break;
			}
		}
		for(int i = 0; i < MAX_CLASS_SELECT; i++)
		{
			if(m_pBtn_Classes[i] && m_pBtn_Classes[i]->IsIn(ptCur.x, ptCur.y))
			{
				m_pStr_Desc->SetString(m_pBtn_Classes[i]->m_szToolTip);
				break;
			}
		}
		for(int i = 0; i < MAX_RACE_SELECT; i++)
		{
			if(m_pBtn_Races[i] && m_pBtn_Races[i]->IsIn(ptCur.x, ptCur.y))
			{
				m_pStr_Desc->SetString(m_pBtn_Races[i]->m_szToolTip);
				break;
			}
		}
	}

	CN3UIBase::s_pTooltipCtrl->SetVisible(false);

	return CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
}

void CUICharacterCreate::UpdateRaceAndClassButtons(e_Race eRace) // 종족에 따라 직업 버튼 다시 설정..
{
	eUI_STATE eUIStateRaces[4] = {	UI_STATE_BUTTON_NORMAL, // 종족 0
									UI_STATE_BUTTON_NORMAL,
									UI_STATE_BUTTON_NORMAL,
									UI_STATE_BUTTON_NORMAL };

	eUI_STATE eUIStateClasses[4] = {	UI_STATE_BUTTON_DISABLE, // 직업 0
										UI_STATE_BUTTON_DISABLE,
										UI_STATE_BUTTON_DISABLE,
										UI_STATE_BUTTON_DISABLE  };

	switch(eRace)
	{
		case RACE_EL_BABARIAN: // 전사만 가능
			eUIStateRaces[0] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[0] = UI_STATE_BUTTON_NORMAL;
			break;
		case RACE_EL_MAN: // 모든 직업 가능
			eUIStateRaces[1] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[0] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[1] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[2] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[3] = UI_STATE_BUTTON_NORMAL;
			break;
		case RACE_EL_WOMEN: // 모든 직업 가능
			eUIStateRaces[2] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[0] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[1] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[2] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[3] = UI_STATE_BUTTON_NORMAL;
			break;
		
		case RACE_KA_ARKTUAREK: // 전사만 가능
			eUIStateRaces[0] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[0] = UI_STATE_BUTTON_NORMAL;
			break;
		case RACE_KA_TUAREK: // 로그, 사제 가능
			eUIStateRaces[1] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[1] = UI_STATE_BUTTON_NORMAL;
			eUIStateClasses[3] = UI_STATE_BUTTON_NORMAL;
			break;
		case RACE_KA_WRINKLETUAREK: // 마법사만 가능..
			eUIStateRaces[2] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[2] = UI_STATE_BUTTON_NORMAL;
			break;
		case RACE_KA_PURITUAREK: // 사제만 가능..
			eUIStateRaces[3] = UI_STATE_BUTTON_DOWN;
			eUIStateClasses[3] = UI_STATE_BUTTON_NORMAL;
			break;

		default:
			break;
	}

	// 기본 요건들 초기화..
	__InfoPlayerBase*	pInfoBase = &(CGameBase::s_pPlayer->m_InfoBase);	
	pInfoBase->eRace = eRace;
	pInfoBase->eClass = CLASS_UNKNOWN;
	
	for(int i = 0; i < MAX_RACE_SELECT; i++)
		if(m_pBtn_Races[i]) m_pBtn_Races[i]->SetState(eUIStateRaces[i]);

	for(int i = 0; i < MAX_CLASS_SELECT; i++)
	{
		if(m_pBtn_Classes[i]) m_pBtn_Classes[i]->SetState(eUIStateClasses[i]);
	
		bool bVisible = (UI_STATE_BUTTON_DISABLE == eUIStateClasses[i]) ? true : false;
		if(m_pImg_Disable_Classes[i]) m_pImg_Disable_Classes[i]->SetVisible(bVisible);
		if(m_pBtn_Classes[i]) m_pBtn_Classes[i]->SetVisible(!bVisible);
	}
}

void CUICharacterCreate::UpdateClassButtons(e_Class eClass)
{
	eUI_STATE eUIStates[MAX_CLASS_SELECT] = {	UI_STATE_BUTTON_NORMAL, // 직업 0
								UI_STATE_BUTTON_NORMAL,
								UI_STATE_BUTTON_NORMAL,
								UI_STATE_BUTTON_NORMAL  };

	bool bVisibles[MAX_STATS] = { false, false, false, false, false };

	CGameProcedure::s_pProcCharacterCreate->SetStats();

	switch(eClass)
	{
	case CLASS_EL_WARRIOR:
	case CLASS_KA_WARRIOR:
		eUIStates[0] = UI_STATE_BUTTON_DOWN;
		bVisibles[0] = true; // 힘
		bVisibles[1] = true; // 체력
		break;
	case CLASS_EL_ROGUE:
	case CLASS_KA_ROGUE:
		eUIStates[1] = UI_STATE_BUTTON_DOWN;
		bVisibles[1] = true; // 힘  changed main stats focus str to dex ([0] to [1] index)
		bVisibles[2] = true; // 민첩
		break;
	case CLASS_EL_WIZARD:
	case CLASS_KA_WIZARD:
		eUIStates[2] = UI_STATE_BUTTON_DOWN;
		bVisibles[3] = true; // 지능
		bVisibles[4] = true; // 마력
		break;
	case CLASS_EL_PRIEST:
	case CLASS_KA_PRIEST:
		eUIStates[3] = UI_STATE_BUTTON_DOWN;
		bVisibles[0] = true; // 힘
		bVisibles[3] = true; // 지능
		break;
	}

	for (int i = 0; i < MAX_CLASS_SELECT; i++)
	{
		if (m_pBtn_Classes[i] != nullptr)
			m_pBtn_Classes[i]->SetState(eUIStates[i]);
	}

	for (int i = 0; i < MAX_STATS; i++)
	{
		if (m_pStr_Stat_Labels[i] != nullptr)
			m_pStr_Stat_Labels[i]->SetVisible(bVisibles[i]);
	}
}

// ===== END WarFare/UICharacterCreate.cpp =====

// ===== BEGIN WarFare/UICharacterCreate.h =====
#line 1 "WarFare/UICharacterCreate.h"
﻿// UICharacterCreate.h: interface for the CUICharacterCreate class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICharacterCreate_H__603E8EF7_2789_4162_9F7D_011306807491__INCLUDED_)
#define AFX_UICharacterCreate_H__603E8EF7_2789_4162_9F7D_011306807491__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include <N3Base/N3UIBase.h>

class CN3UIButton;
class CN3UIString;
class CN3UIImage;

const int MAX_RACE_SELECT = 4;
const int MAX_CLASS_SELECT = 4;
const int MAX_STATS = 5; // 힘, 체력, 민첩, 지능, 마력

class CUICharacterCreate : public CN3UIBase
{
public:
	int				m_iBonusPoint;
	int				m_iMaxBonusPoint;


	CN3UIButton*	m_pBtn_Races[MAX_RACE_SELECT];
	CN3UIButton*	m_pBtn_Classes[MAX_CLASS_SELECT];
	CN3UIImage*		m_pImg_Disable_Classes[MAX_CLASS_SELECT];
	CN3UIString*	m_pStr_Stat_Labels[MAX_STATS];
	CN3UIString*	m_pStr_Stats[MAX_STATS];
	CN3UIArea*		m_pArea_Stats[MAX_STATS];

	CN3UIString*	m_pStr_Desc;
	CN3UIString*	m_pStr_Bonus;

	CN3UIButton*	m_pBtn_Face_Left;
	CN3UIButton*	m_pBtn_Face_Right;
	CN3UIButton*	m_pBtn_Hair_Left;
	CN3UIButton*	m_pBtn_Hair_Right;

	CN3UIArea*		m_pArea_Character;

	CN3UIEdit*		m_pEdit_Name;

public:
	void Reset();
	void UpdateStats();
	void UpdateRaceAndClassButtons(e_Race eRace);
	void UpdateClassButtons(e_Class eClass);

	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool Load(File& file) override;
	void Release() override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUICharacterCreate();
	~CUICharacterCreate() override;
};

#endif // !defined(AFX_UICharacterCreate_H__603E8EF7_2789_4162_9F7D_011306807491__INCLUDED_)

// ===== END WarFare/UICharacterCreate.h =====

// ===== BEGIN WarFare/UICharacterSelect.cpp =====
#line 1 "WarFare/UICharacterSelect.cpp"
﻿// UICharacterSelect.cpp: implementation of the UICharacterSelect class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UICharacterSelect.h"
#include "APISocket.h"
#include "GameProcCharacterSelect.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UITooltip.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICharacterSelect::CUICharacterSelect()
{
	m_eType = UI_TYPE_BASE;
	CUICharacterSelect::Release();

	m_pBtnLeft		= nullptr;
	m_pBtnRight		= nullptr;
	m_pBtnExit		= nullptr;
	m_pBtnDelete	= nullptr;
	m_pBtnBack		= nullptr;
	m_pUserInfoStr	= nullptr;
}

CUICharacterSelect::~CUICharacterSelect()
{
}

void CUICharacterSelect::Release()
{
	m_pBtnLeft		= nullptr;
	m_pBtnRight		= nullptr;
	m_pBtnExit		= nullptr;
	m_pBtnDelete	= nullptr;
	m_pBtnBack		= nullptr;
	m_pUserInfoStr	= nullptr;

	CN3UIBase::Release();
}

bool CUICharacterSelect::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtnLeft, GetChildByID("bt_left"));
	N3_VERIFY_UI_COMPONENT(m_pBtnRight, GetChildByID("bt_right"));
	N3_VERIFY_UI_COMPONENT(m_pBtnExit, GetChildByID("bt_exit"));
	N3_VERIFY_UI_COMPONENT(m_pBtnDelete, GetChildByID("bt_delete"));
	N3_VERIFY_UI_COMPONENT(m_pBtnBack, GetChildByID("bt_back"));
	N3_VERIFY_UI_COMPONENT(m_pUserInfoStr, GetChildByID<CN3UIString>("text00"));

	// 위치를 화면 해상도에 맞게 바꾸기...
	POINT pt;
	RECT rc = GetRegion();
	float fRatio = (float) s_CameraData.vp.Width / (rc.right - rc.left);

	if (m_pBtnLeft != nullptr)
	{
		pt = m_pBtnLeft->GetPos();
		pt.x = (int) (pt.x * fRatio);
		pt.y = s_CameraData.vp.Height - 10 - m_pBtnLeft->GetHeight();
		m_pBtnLeft->SetPos(pt.x, pt.y);
	}

	if (m_pBtnRight != nullptr)
	{
		pt = m_pBtnRight->GetPos();
		pt.x = (int) (pt.x * fRatio);
		pt.y = s_CameraData.vp.Height - 10 - m_pBtnRight->GetHeight();
		m_pBtnRight->SetPos(pt.x, pt.y);
	}

	if (m_pBtnExit != nullptr)
	{
		pt = m_pBtnExit->GetPos();
		pt.x = (int) (pt.x * fRatio);
		pt.y = s_CameraData.vp.Height - 10 - m_pBtnExit->GetHeight();
		m_pBtnExit->SetPos(pt.x, pt.y);
	}

	if (m_pBtnBack != nullptr)
	{
		// Previous point in sane cases should be be the exit button.
		// There's a 15 pixel gap between them in the UIF's layout.
		POINT ptPrev = pt;
		pt = m_pBtnBack->GetPos();
		pt.x = (int) (pt.x * fRatio);
		pt.y = ptPrev.y - 15 - m_pBtnBack->GetHeight();
		m_pBtnBack->SetPos(pt.x, pt.y);
	}

	if (m_pBtnDelete != nullptr)
	{
		pt = m_pBtnDelete->GetPos();
		pt.x = (int) (pt.x * fRatio);
		pt.y = 20;
		m_pBtnDelete->SetPos(pt.x, pt.y);
	}

	SetRect(&rc, 0, 0, s_CameraData.vp.Width, s_CameraData.vp.Height);
	SetRegion(rc);

	return true;
}

void CUICharacterSelect::Tick()
{
	CN3UIBase::Tick();
}

bool CUICharacterSelect::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (!CGameProcedure::s_pUIMgr->EnableOperation())
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		// Rotate Left..
		if (pSender == m_pBtnLeft)
		{
			CGameProcedure::s_pProcCharacterSelect->DoJobLeft();
		}
		// Rotate Right..
		else if (pSender == m_pBtnRight)
		{
			CGameProcedure::s_pProcCharacterSelect->DojobRight();
		}
		else if (pSender == m_pBtnExit)
		{
//			CGameProcedure::ProcActiveSet((CGameProcedure*)CGameProcedure::s_pProcLogIn); // 로그인으로 돌아간다..
			std::string szMsg = fmt::format_text_resource(IDS_CONFIRM_EXIT_GAME);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_EXIT);
		}
		else if (pSender == m_pBtnBack)
		{
			CGameProcedure::s_bNeedReportConnectionClosed = false;
			CGameProcedure::s_pSocket->Disconnect();
			CGameProcedure::s_bNeedReportConnectionClosed = true;

			CGameProcedure::ProcActiveSet((CGameProcedure*) CGameProcedure::s_pProcLogIn); // 로그인으로 돌아간다..
		}
		else if (pSender == m_pBtnDelete)
		{
			std::string szMsg = fmt::format_text_resource(IDS_CONFIRM_DELETE_CHR);

			// NOTE: Character deletion is disabled and this resource is changed appropriately.
			// As such, rather than prompt to delete, we should simply show the new message.
#if 0
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_DELETE_CHR);
#else
			CGameProcedure::MessageBoxPost(szMsg, "", MB_OK);
#endif
		}
	}

	return true;
}

void CUICharacterSelect::DisplayChrInfo(__CharacterSelectInfo* pCSInfo)
{
	std::string szTotal;

	if (!pCSInfo->szID.empty())
	{
		std::string szClass;
		CGameBase::GetTextByClass(pCSInfo->eClass, szClass);

		// Level: %d\nSpecialty: %s\nID: %s
		szTotal = fmt::format_text_resource(IDS_CHR_SELECT_FMT_INFO,
			pCSInfo->iLevel, szClass, pCSInfo->szID);
	}
	else
	{
		szTotal = fmt::format_text_resource(IDS_CHR_SELECT_HINT);
	}

	if (m_pUserInfoStr != nullptr)
	{
		m_pUserInfoStr->SetVisible(true);
		((CN3UIString*) m_pUserInfoStr)->SetString(szTotal);
	}
}

void CUICharacterSelect::DontDisplayInfo()
{
	CN3UIBase*	m_pUserInfoStr;
	N3_VERIFY_UI_COMPONENT(m_pUserInfoStr, GetChildByID("text00"));

	if ( m_pUserInfoStr ) m_pUserInfoStr->SetVisible(false);
}

bool CUICharacterSelect::OnKeyPress(int iKey)
{
	if(CGameProcedure::s_pUIMgr->EnableOperation())
	{
		switch(iKey)
		{
		case DIK_ESCAPE:
			ReceiveMessage(m_pBtnExit, UIMSG_BUTTON_CLICK);
			return true;
		case DIK_LEFT:
			ReceiveMessage(m_pBtnLeft, UIMSG_BUTTON_CLICK);
			return true;
		case DIK_RIGHT:
			ReceiveMessage(m_pBtnRight, UIMSG_BUTTON_CLICK);
			return true;
		case DIK_NUMPADENTER:
		case DIK_RETURN:
			CGameProcedure::s_pProcCharacterSelect->CharacterSelectOrCreate();
			return true;
		}
	}

	return CN3UIBase::OnKeyPress(iKey);
}

uint32_t CUICharacterSelect::MouseProc(uint32_t dwFlags, const POINT &ptCur, const POINT &ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE == m_eState)
	{
		if (dwFlags&UI_MOUSE_LBCLICKED)
		{
			SetState(UI_STATE_COMMON_NONE);
		}
		else
		{
			MoveOffset(ptCur.x - ptOld.x, ptCur.y - ptOld.y);
		}
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	if(false == IsIn(ptCur.x, ptCur.y))	// 영역 밖이면
	{
		if(false == IsIn(ptOld.x, ptOld.y))
		{
			return dwRet;// 이전 좌표도 영역 밖이면 
		}
	}
	else
	{
		// tool tip 관련
		if (s_pTooltipCtrl != nullptr)
			s_pTooltipCtrl->SetText(m_szToolTip, m_crToolTip);
	}

	if(m_pChildUI && m_pChildUI->IsVisible())
		return dwRet;

	// child에게 메세지 전달
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		uint32_t dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{	// 이경우에는 먼가 포커스를 받은 경우이다.

			dwRet |= (UI_MOUSEPROC_CHILDDONESOMETHING|UI_MOUSEPROC_DONESOMETHING);
			return dwRet;
		}
	}

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE != m_eState && 
			PtInRect(&m_rcMovable, ptCur) && (dwFlags&UI_MOUSE_LBCLICK) )
	{
		SetState(UI_STATE_COMMON_MOVE);
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	return dwRet;
}

// ===== END WarFare/UICharacterSelect.cpp =====

// ===== BEGIN WarFare/UICharacterSelect.h =====
#line 1 "WarFare/UICharacterSelect.h"
﻿// UICharacterSelect.h: interface for the UICharacterSelect class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICharacterSelect_H__665CADA6_E25B_47D6_B962_6DA49673048F__INCLUDED_)
#define AFX_UICharacterSelect_H__665CADA6_E25B_47D6_B962_6DA49673048F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

struct __CharacterSelectInfo;
class CUICharacterSelect : public CN3UIBase
{
protected:
	CN3UIBase*		m_pBtnLeft;
	CN3UIBase*		m_pBtnRight;
	CN3UIBase*		m_pBtnExit;
	CN3UIBase*		m_pBtnDelete;
	CN3UIBase*		m_pBtnBack;
	CN3UIString*	m_pUserInfoStr;

public:
	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool OnKeyPress(int iKey) override;
	CUICharacterSelect();
	~CUICharacterSelect() override;

	void Release() override;
	bool Load(File& file) override;
	void Tick() override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	void DisplayChrInfo(__CharacterSelectInfo* pCSInfo);
	void DontDisplayInfo();
};

#endif // !defined(AFX_UICharacterSelect_H__665CADA6_E25B_47D6_B962_6DA49673048F__INCLUDED_)

// ===== END WarFare/UICharacterSelect.h =====

// ===== BEGIN WarFare/UIChat.cpp =====
#line 1 "WarFare/UIChat.cpp"
﻿// UIChat.cpp: implementation of the CUIChat class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIChat.h"
#include "PacketDef.h"
#include "GameProcMain.h"
#include "UIMessageWnd.h"
#include "UIManager.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UIScrollBar.h>
#include <N3Base/N3UIEdit.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIChat::CUIChat()													//생성자 와 파괴자에서 Release안 불러 주나??
{
	m_pChatOut = nullptr;
	m_pScrollbar = nullptr;
	m_iChatLineCount = 0;
	m_ppUILines = nullptr;
	m_iCurContinueMsg = 0;
	ZeroMemory(&m_rcChatOutRegion, sizeof(m_rcChatOutRegion));

	m_eChatMode = N3_CHAT_NORMAL;
//	m_eChatBuffer = CHAT_BUFFER_NORMAL;

	m_pBtn_Normal = nullptr;
	m_pBtn_Private = nullptr;
	m_pBtn_PartyOrForce = nullptr;
	m_pBtn_KnightsOrGuild = nullptr;
	m_pBtn_Shout = nullptr;
	m_pNoticeTitle = nullptr;
	m_pBtn_Fold = nullptr;
	m_pEdit = nullptr;													//son, chat_in

	m_bChatNormal	= true;
	m_bChatPrivate	= true;
	m_bChatClan		= true;
	m_bChatShout	= true;
	m_bChatParty	= true;

	m_bKillFocus	= false;
}

CUIChat::~CUIChat()
{
	if (m_ppUILines) {delete [] m_ppUILines; m_ppUILines = nullptr;}	// m_ppUILines[n]의 포인터는 메모리 할당되어 있어도 부모가 해제될때 자동으로 해제하므로 안지워야 한다.

	ChatListItor itor;
//	for(int i = 0; i < CHAT_BUFFER_COUNT; i++)
//	{
//		for(itor = m_ChatBuffers[i].begin(); m_ChatBuffers[i].end() != itor; ++itor)
		for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pChatInfo = (*itor);
			if (pChatInfo) delete pChatInfo;
		}
//		m_ChatBuffers[i].clear();
		m_ChatBuffer.clear();

//		for(itor = m_LineBuffers[i].begin(); m_LineBuffers[i].end() != itor; ++itor)
		for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pChatInfo = (*itor);
			if (pChatInfo) delete pChatInfo;
		}
//		m_LineBuffers[i].clear();
		m_LineBuffer.clear();
//	}

	DeleteContinueMsg();
}

void CUIChat::Release()
{
	CN3UIBase::Release();

	m_pEdit = nullptr;													//son, chat_in

	m_pChatOut = nullptr;
	m_pScrollbar = nullptr;
	m_iChatLineCount = 0;
	if (m_ppUILines) {delete [] m_ppUILines; m_ppUILines = nullptr;}	// m_ppUILines[n]의 포인터는 메모리 할당되어 있어도 부모가 해제될때 자동으로 해제하므로 안지워야 한다.
	ZeroMemory(&m_rcChatOutRegion, sizeof(m_rcChatOutRegion));

	ChatListItor itor;
//	for(int i = 0; i < CHAT_BUFFER_COUNT; i++)
//	{
//		for(itor = m_ChatBuffers[i].begin(); m_ChatBuffers[i].end() != itor; ++itor)
		for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pChatInfo = (*itor);
			if (pChatInfo) delete pChatInfo;
		}
//		m_ChatBuffers[i].clear();
		m_ChatBuffer.clear();

//		for(itor = m_LineBuffers[i].begin(); m_LineBuffers[i].end() != itor; ++itor)
		for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pChatInfo = (*itor);
			if (pChatInfo) delete pChatInfo;
		}
//		m_LineBuffers[i].clear();
		m_LineBuffer.clear();
//	}

	m_eChatMode = N3_CHAT_NORMAL;
//	m_eChatBuffer = CHAT_BUFFER_NORMAL;

	m_pBtn_Normal = nullptr;
	m_pBtn_Private = nullptr;
	m_pBtn_PartyOrForce = nullptr;
	m_pBtn_KnightsOrGuild = nullptr;
	m_pBtn_Shout = nullptr;
	m_pBtn_Fold = nullptr;
}

bool CUIChat::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if(dwMsg == UIMSG_BUTTON_CLICK)
	{
		e_ChatMode eCM = N3_CHAT_UNKNOWN;

		if(pSender == m_pBtn_Normal) eCM = N3_CHAT_NORMAL;
		else if(pSender == m_pBtn_Private) eCM = N3_CHAT_PRIVATE;
		else if(pSender == m_pBtn_PartyOrForce) eCM = N3_CHAT_PARTY;
		else if(pSender == m_pBtn_KnightsOrGuild) eCM = N3_CHAT_CLAN;
		else if(pSender == m_pBtn_Shout) eCM = N3_CHAT_SHOUT;
		else if(pSender == m_pBtn_Check) ChatListenEnable();
		else if (pSender == m_pBtn_Fold)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIChat();
			return true;
		}

		if(N3_CHAT_UNKNOWN != eCM)
			this->ChangeChattingMode(eCM); // 채팅 모드가 바뀌면..
	}
	else if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		// 스크롤바에 맞는 채팅 Line 설정
		int iCurLinePos = m_pScrollbar->GetCurrentPos();
		SetTopLine(iCurLinePos);
		return true;
	}
	//son, chat_in
	else if (dwMsg == UIMSG_EDIT_RETURN)
	{													
		CN3UIEdit* pEdit = (CN3UIEdit*)pSender;
		//채팅 m_pEdit->SetString(""); 해버린 후에는 m_pEdit->GetString();해서 얻어온 포인터가
		// 유효하지 않은 포인터가 되므로 주의..

		// buffer에 카피해둠.
		m_szString = m_pEdit->GetString();

		int iStrLen = static_cast<int>(m_szString.size());
		if (iStrLen > 0)
		{
			if (iStrLen > 1 && '/' == m_szString[0])
			{
				CGameProcedure::s_pProcMain->ParseChattingCommand(m_szString);
			}
			else if (iStrLen > 1 && '@' == m_szString[0])
			{
				size_t pos = m_szString.find(' ');
				if (pos > 0)
				{
					std::string szID = m_szString.substr(1, pos - 1);
					std::string szMsg = m_szString.substr(pos);

					size_t pos2 = szMsg.find_first_not_of(" ");
					szMsg = szMsg.substr(pos2);

					CGameProcedure::s_pProcMain->MsgSend_ChatSelectTarget(szID);
					CGameProcedure::s_pProcMain->MsgSend_Chat(N3_CHAT_PRIVATE, szMsg);//&(m_szString[1]));
				}
			}
			else if (iStrLen > 1 && '#' == m_szString[0]) // 파티
			{
				CGameProcedure::s_pProcMain->MsgSend_Chat(N3_CHAT_PARTY, &m_szString[1]);
			}
			else if (iStrLen > 1 && '$' == m_szString[0]) // 클랜
			{
				CGameProcedure::s_pProcMain->MsgSend_Chat(N3_CHAT_CLAN, &m_szString[1]);
			}
			else if (iStrLen > 1 && '!' == m_szString[0]) // 외치기
			{
				CGameProcedure::s_pProcMain->MsgSend_Chat(N3_CHAT_SHOUT, &m_szString[1]);
			}
			else
			{
				CGameProcedure::s_pProcMain->MsgSend_Chat(m_eChatMode, m_szString);
//				this->SetFocus();
			}
		}

		// 화면에 표시되는 글씨는 지운다.
//		this->SetString("");
//		::SetWindowText(s_hWndEdit, "");

		SetEnableKillFocus(true);
		return true;
	}
	//son, chat_in

	return true;
}

void CUIChat::CreateLines()
{
	int i;
	if (m_ppUILines) {
		for (i=0; i<m_iChatLineCount; ++i)
		{
			if (m_ppUILines[i]) {delete m_ppUILines[i]; m_ppUILines[i] = nullptr;}
		}
		delete [] m_ppUILines; m_ppUILines = nullptr;
	}
	SIZE size;
	if (m_pChatOut && m_pChatOut->GetTextExtent("가", lstrlen("가"), &size) && size.cy>0)
	{
		m_iChatLineCount = (m_rcChatOutRegion.bottom - m_rcChatOutRegion.top)/size.cy;
	}
	else return;
	const std::string& szFontName = m_pChatOut->GetFontName();
	uint32_t dwFontHeight = m_pChatOut->GetFontHeight();
	uint32_t dwFontFlag = m_pChatOut->GetFontFlags();

	if (m_iChatLineCount<=0 || szFontName.empty()) return;

	m_ppUILines = new CN3UIString*[m_iChatLineCount];
	for (i=0; i<m_iChatLineCount; ++i)
	{
		RECT rc;
		SetRect(&rc, m_rcChatOutRegion.left, m_rcChatOutRegion.top+(i*size.cy),
									m_rcChatOutRegion.right, m_rcChatOutRegion.top+((i+1)*size.cy));
		m_ppUILines[i] = new CN3UIString();
		m_ppUILines[i]->Init(this);
		m_ppUILines[i]->SetRegion(rc);
		m_ppUILines[i]->SetStyle(UISTYLE_STRING_SINGLELINE|UISTYLE_STRING_ALIGNLEFT|UISTYLE_STRING_ALIGNTOP);
		m_ppUILines[i]->SetFont(szFontName, dwFontHeight, dwFontFlag & D3DFONT_BOLD, dwFontFlag & D3DFONT_ITALIC);
	}
}

bool CUIChat::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;
	N3_VERIFY_UI_COMPONENT(m_pChatOut, GetChildByID<CN3UIString>("text0"));
	N3_VERIFY_UI_COMPONENT(m_pScrollbar, GetChildByID<CN3UIScrollBar>("scroll"));
	N3_VERIFY_UI_COMPONENT(m_pNoticeTitle, GetChildByID<CN3UIString>("text_notice_title"));

	m_rcChatOutRegion = m_pChatOut->GetRegion();
	CreateLines();

	__ASSERT(0<m_iChatLineCount,"채팅창이 너무 작아요");

	//son, chat_in
	N3_VERIFY_UI_COMPONENT(m_pEdit, GetChildByID<CN3UIEdit>("edit0"));
	m_pEdit->SetMaxString(256); // 채팅 문자열 길이 제한..
	//son, chat_in

	N3_VERIFY_UI_COMPONENT(m_pBtn_Normal, GetChildByID("btn_normal"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Private, GetChildByID("btn_private"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_PartyOrForce, GetChildByID("btn_party_force"));
	//N3_VERIFY_UI_COMPONENT(m_pBtn_KnightsOrGuild, GetChildByID("btn_knights_guild"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_KnightsOrGuild, GetChildByID("btn_knights"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Shout, GetChildByID("btn_shout"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Check, GetChildByID("btn_check_normal"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Fold, GetChildByID("btn_off"));

	this->ChangeChattingMode(N3_CHAT_NORMAL); // 보통 채팅 모드이다..

	return true;
}

void CUIChat::AddChatMsg(e_ChatMode eCM, const std::string& szString, D3DCOLOR color)
{
	if(szString.empty()) return;

	switch(eCM)
	{
	case N3_CHAT_NORMAL:
		if(!m_bChatNormal) return;
		break;
	case N3_CHAT_PRIVATE:
		if(!m_bChatPrivate) return;
		break;
	case N3_CHAT_PARTY:
	case N3_CHAT_FORCE:
		if(!m_bChatParty) return;
		break;
	case N3_CHAT_CLAN:
		if(!m_bChatClan) return;
		break;
	case N3_CHAT_SHOUT:
		if(!m_bChatShout) return;
		break;
	}

//	N3_CHAT_NORMAL = 1, N3_CHAT_PRIVATE, N3_CHAT_PARTY, N3_CHAT_FORCE, N3_CHAT_SHOUT, N3_CHAT_KNIGHTS, N3_CHAT_PUBLIC
//	e_ChatBuffer eCB = CHAT_BUFFER_NORMAL; // Chatting Mode Index 0 - Normal, shout, notice | 1 - private | 2 - party force | 3 - Knights
//	switch(eCM)
//	{
//	case N3_CHAT_NORMAL:
//	case N3_CHAT_SHOUT:
//	case N3_CHAT_PUBLIC:
//		eCB = CHAT_BUFFER_NORMAL;
//		break;
//	case N3_CHAT_PRIVATE: 
//		eCB = CHAT_BUFFER_PRIVATE;
//		break;
//	case N3_CHAT_PARTY:
//	case N3_CHAT_FORCE:
//		eCB = CHAT_BUFFER_PARTY;
//		break;
//	case N3_CHAT_KNIGHTS:
//		eCB = CHAT_BUFFER_KNIGHTS;
//		break;
//	}

	// 일반 ChatBuffer에 넣기
//	if(CHAT_BUFFER_NORMAL != eCB)
//	{
		__ChatInfo* pChatInfo = new __ChatInfo(szString, color);
//		m_ChatBuffers[CHAT_BUFFER_NORMAL].push_back(pChatInfo);
		m_ChatBuffer.push_back(pChatInfo);
//		if (m_ChatBuffers[CHAT_BUFFER_NORMAL].size() > 255)	// 255개가 넘으면 앞에서부터 지우기
		if (m_ChatBuffer.size() > 255)	// 255개가 넘으면 앞에서부터 지우기
		{
//			__ChatInfo* pTemp = m_ChatBuffers[CHAT_BUFFER_NORMAL].front();
			__ChatInfo* pTemp = m_ChatBuffer.front();
			if (pTemp) delete pTemp;

//			m_ChatBuffers[CHAT_BUFFER_NORMAL].pop_front();
			m_ChatBuffer.pop_front();
		}
//		this->AddLineBuffer(CHAT_BUFFER_NORMAL, szString, color); // line buffer 에 넣기
		this->AddLineBuffer(szString, color); // line buffer 에 넣기
//	}

	// ChatBuffer에 넣기
//	__ChatInfo* pChatInfo = new __ChatInfo(szString, color);
//	m_ChatBuffers[eCB].push_back(pChatInfo);
//	if (m_ChatBuffers[eCB].size() > 255)	// 255개가 넘으면 앞에서부터 지우기
//	{
//		__ChatInfo* pTemp = m_ChatBuffers[eCB].front();
//		if (pTemp) delete pTemp;
//
//		m_ChatBuffers[eCB].pop_front();
//	}
//	this->AddLineBuffer(eCB, szString, color); // line buffer 에 넣기

	this->AdjustScroll(); // 스크롤 바 및 스크롤 위치등 조정..
}

void CUIChat::AdjustScroll()
{
	// Line buffer 갯수 조절
	int iCurLinePos = m_pScrollbar->GetCurrentPos();	// 현재 scroll bar가 가리키고 있는 line
	BOOL bAutoScroll = (m_pScrollbar->GetMaxPos() == iCurLinePos) ? TRUE : FALSE;

//	while (m_LineBuffers[m_eChatBuffer].size() > MAX_CHAT_LINES && 0 < iCurLinePos)	// MAX_CHAT_LINES은 최대 line의 수 (단 스크롤바가 0인 곳에 있으면 line을 지우지 않으므로 500개를 넘길 수 있다)
	while (m_LineBuffer.size() > MAX_CHAT_LINES && 0 < iCurLinePos)	// MAX_CHAT_LINES은 최대 line의 수 (단 스크롤바가 0인 곳에 있으면 line을 지우지 않으므로 500개를 넘길 수 있다)
	{
		// 한줄 지우기
//		__ChatInfo* pTemp = m_LineBuffers[m_eChatBuffer].front();
		__ChatInfo* pTemp = m_LineBuffer.front();
		if (pTemp) delete pTemp;
//		m_LineBuffers[m_eChatBuffer].pop_front();
		m_LineBuffer.pop_front();
		--iCurLinePos;	
	}

//	int iLineBufferSize = m_LineBuffers[m_eChatBuffer].size();
	int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
	int iMaxScrollPos = iLineBufferSize - m_iChatLineCount;
	if (iMaxScrollPos < 0) iMaxScrollPos = 0;
	m_pScrollbar->SetRange(0, iMaxScrollPos);	// scroll bar range 설정

	// 자동으로 스크롤이면
	if ( bAutoScroll) iCurLinePos = iMaxScrollPos;
	if (iCurLinePos < 0) iCurLinePos = 0;

	// 스크롤바 현재 위치 재설정
	m_pScrollbar->SetCurrentPos(iCurLinePos);

	// 스크롤바에 맞는 채팅 Line 설정
	SetTopLine(iCurLinePos);
}

//void CUIChat::AddLineBuffer(e_ChatBuffer eCB, const std::string& szString, D3DCOLOR color)
void CUIChat::AddLineBuffer(const std::string& szString, D3DCOLOR color)
{
	if (szString.empty())
		return;

	__ASSERT(m_pChatOut, "");

	const int iStrLen = static_cast<int>(szString.size());

	// line buffer 넣기
	SIZE size;
	if (!m_pChatOut->GetTextExtent(szString, iStrLen, &size))
	{
		__ASSERT(0, "no device context");
		return;
	}

	const int iRegionWidth = m_rcChatOutRegion.right - m_rcChatOutRegion.left;

	// 글자 자르는 코드, 영역 밖으로 벗어나는 글자는 자르고 밑에 줄에..
	int iCX=0;
	int iCount = 0;
	int iLineStart = 0;

	while(iCount<iStrLen)
	{
		if ('\n' == szString[iCount])		// \n
		{
			__ChatInfo* pLineInfo = new __ChatInfo;
//			m_LineBuffers[eCB].push_back(pLineInfo);
			m_LineBuffer.push_back(pLineInfo);

			pLineInfo->color = color;
			if ((iCount - iLineStart)>0)
			{
				int iLineLength = iCount - iLineStart + 1;
				std::string szLine;
				pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
			}	// 연속된 \n일 경우 pszLine = nullptr이 될 수 있다.

			++iCount;
			iLineStart = iCount;
			iCX = 0;
		}
		else
		{
			int iCC=0;
			if (0x80 & szString[iCount])	iCC = 2;	// 2BYTE 문자
			else							iCC = 1;	// 1BYTE 문자

			BOOL bFlag = m_pChatOut->GetTextExtent(&(szString[iCount]), iCC, &size);
			__ASSERT(bFlag, "cannot get size of dfont");
			if ((iCX+size.cx) > iRegionWidth)	// 가로 길이가 넘었으면
			{
				// 한 라인 더 추가하기
				
				int iLineLength = iCount - iLineStart;
				if (iLineLength>0)
				{
					__ChatInfo* pLineInfo = new __ChatInfo;
//					m_LineBuffers[eCB].push_back(pLineInfo);
					m_LineBuffer.push_back(pLineInfo);

					pLineInfo->color = color;
					pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
				}
				else
				{
					__ASSERT(iRegionWidth>15, "너무 좁아서 한글자도 찍을 수가 없다");
					break;
				}
				iLineStart = iCount;
				iCX = 0;
			}
			// 글자 더하기
			iCount += iCC;
			iCX += size.cx;
		}
	}

	// 맨 마지막 출 처리
	int iLineLength = iStrLen - iLineStart;
	if (iLineLength>0)
	{
		__ChatInfo* pLineInfo = new __ChatInfo;
//		m_LineBuffers[eCB].push_back(pLineInfo);
		m_LineBuffer.push_back(pLineInfo);

		pLineInfo->color = color;
		pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
	}
}

void CUIChat::SetTopLine(int iTopLine)
{
	if (m_iChatLineCount<=0) return;

//	const int iLineBufferSize = m_LineBuffers[m_eChatBuffer].size();
	const int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
	if (iTopLine < 0)
		iTopLine = 0;
	else if (iTopLine > iLineBufferSize)
		iTopLine = iLineBufferSize;

	int i;
	// 앞줄서부터 차례로 임시버퍼에 저장하고 string 길이 측정
	__ChatInfo** ppLineInfos  = new __ChatInfo*[m_iChatLineCount];
	ZeroMemory(ppLineInfos, sizeof(__ChatInfo*)*m_iChatLineCount);

	int iCurLine = 0;
	for (i=0; i<m_iChatLineCount; ++i)
	{
		iCurLine = iTopLine + i;
		if (iLineBufferSize <= iCurLine) break;
//		ppLineInfos[i] = m_LineBuffers[m_eChatBuffer][iCurLine];
		ppLineInfos[i] = m_LineBuffer[iCurLine];
	}

	__ASSERT(m_ppUILines, "null pointer");
	// 앞에서부터 맞게 차례로 각각 버퍼에 넣기
	int iRealLine = i;	// 실제 출력되는 줄 수
	int iRealLineCount = 0;
	for (i=0; i<iRealLine; ++i)
	{
		++iRealLineCount;
		if (nullptr == m_ppUILines[i]) continue;
		m_ppUILines[i]->SetColor(ppLineInfos[i]->color);
		m_ppUILines[i]->SetString(ppLineInfos[i]->szChat);
	}
	for (i=iRealLineCount; i<m_iChatLineCount; ++i)
	{
		if (nullptr == m_ppUILines[i]) continue;
		m_ppUILines[i]->SetString("");	// 나머지는 빈칸 만들기
	}
	delete [] ppLineInfos;
}

void CUIChat::RecalcLineBuffers()	// 채팅창 사이즈가 변했을때 호출해주면 line buffer를 다시 계산해서 넣어준다.
{
	int iMaxScrollPos = 0;
//	for(int i = 0; i < CHAT_BUFFER_COUNT; i++)
//	{
		// line buffer 초기화하기
		ChatListItor itor;
//		for(itor = m_LineBuffers[i].begin(); m_LineBuffers[i].end() != itor; ++itor)
		for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pLineBuff = (*itor);
			if (pLineBuff) delete pLineBuff;
		}
//		m_LineBuffers[i].clear();
		m_LineBuffer.clear();

		// Line buffer 다시 넣기
//		for(itor = m_ChatBuffers[i].begin(); m_ChatBuffers[i].end() != itor; ++itor)
		for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
		{
			__ChatInfo* pChatBuff = (*itor);
//			if (pChatBuff) AddLineBuffer((e_ChatBuffer)i, pChatBuff->szChat, pChatBuff->color);
			if (pChatBuff) AddLineBuffer(pChatBuff->szChat, pChatBuff->color);
		}

		// Line buffer 갯수 조절
//		while (m_LineBuffers[i].size() > MAX_CHAT_LINES)	// MAX_CHAT_LINES은 최대 line의 수
		while (m_LineBuffer.size() > MAX_CHAT_LINES)	// MAX_CHAT_LINES은 최대 line의 수
		{
			// 한줄 지우기
//			__ChatInfo* pLineBuff = m_LineBuffers[i].front();
			__ChatInfo* pLineBuff = m_LineBuffer.front();
			if (pLineBuff) delete pLineBuff;
//			m_LineBuffers[i].pop_front();
			m_LineBuffer.pop_front();
		}

//		if(i == m_eChatBuffer)
//		{
//			int iLineBufferSize = m_LineBuffers[i].size();
			int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
			iMaxScrollPos = iLineBufferSize - m_iChatLineCount;
//		}
//	}

	// 스크롤바 현재 위치 재설정
	if (iMaxScrollPos<0) iMaxScrollPos = 0;
	m_pScrollbar->SetRange(0, iMaxScrollPos);	// scroll bar range 설정
	m_pScrollbar->SetCurrentPos(iMaxScrollPos);
	
	// 스크롤바에 맞는 채팅 Line 설정
	SetTopLine(iMaxScrollPos);
}

//son, chat_in
void CUIChat::SetFocus()
{
	SetEnableKillFocus(false);
	this->SetString("");
	if (m_pEdit) m_pEdit->SetFocus();
}

void CUIChat::KillFocus()
{
	this->SetString("");
	if (m_pEdit) m_pEdit->KillFocus();
}

BOOL CUIChat::IsChatMode()
{
	return ((m_pEdit && GetFocusedEdit() == m_pEdit) ? TRUE : FALSE);			//	TRUE --> 체팅모드가 아닐때 
}
//son, chat_in

void CUIChat::SetString(const std::string& szChat)
{
	m_szString = szChat;

	if (m_pEdit != nullptr)
	{
		m_pEdit->SetString(m_szString);
		m_pEdit->SetCaretPos(m_szString.size());
	}
}

void CUIChat::SetCaretPos(int iPos)
{
	if (IsChatMode() && m_pEdit)
	{
		m_pEdit->SetCaretPos(iPos);
	}
}

BOOL CUIChat::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (0 == iOffsetX && 0 == iOffsetY) return FALSE;
	// ui 영역
	m_rcRegion.left += iOffsetX;		m_rcRegion.top += iOffsetY;
	m_rcRegion.right += iOffsetX;		m_rcRegion.bottom += iOffsetY;

	// movable 영역
	m_rcMovable.left += iOffsetX;		m_rcMovable.top += iOffsetY;
	m_rcMovable.right += iOffsetX;		m_rcMovable.bottom += iOffsetY;

	// children 좌표 갱신
	CN3UIBase* pCUI = nullptr; // Child UI...
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		pCUI = (*itor);
		__ASSERT(pCUI, "child UI pointer is NULL!");
		pCUI->MoveOffset(iOffsetX, iOffsetY);
	}

	/*if(CGameProcedure::s_pProcMain->m_pUIMsgDlg)
	{
	POINT pt = CGameProcedure::s_pProcMain->m_pUIMsgDlg->GetPos();
	RECT rt = this->GetRegion();
	if( (rt.right != pt.x) || (rt.top != pt.y) )
	{
	CGameProcedure::s_pProcMain->m_pUIMsgDlg->SetPos(rt.right, rt.top);
	}
	}*/

	//NOTE: (madpew) Don't stick them together, so chat and info can move freely, but sync with the folded version instead
	POINT pt = this->GetPos();
	RECT rc = this->GetRegion();
	RECT rc2 = CGameProcedure::s_pProcMain->m_pUIChatDlg2->GetRegion();
	CGameProcedure::s_pProcMain->m_pUIChatDlg2->SetPos(pt.x, rc.bottom + (rc2.top - rc2.bottom));

	return true;
}

void CUIChat::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	// 자식들을 적당히 배치한다.
	// m_rcChatOutRegion = ;	// 채팅 출력 영역을 다시 지정해준다.
	//CreateLines();	// 채팅 라인을 몇줄 들어갈지 계산하고 다시 만든다.
	//RecalcLineBuffers();	// 라인 버퍼를 다 지우고 다시 만들어주고 글씨를 표시한다.
}

void CUIChat::ChangeChattingMode(e_ChatMode eCM)
{
	m_eChatMode = eCM;
//	e_ChatBuffer eCBPrev = m_eChatBuffer;

	bool bNBDs[5] = { false, false, false, false, false };
	bool bICLs[5] = { m_bChatNormal, m_bChatPrivate, m_bChatParty, m_bChatClan, m_bChatShout };
	CN3UIBase* pBtns[5] = { m_pBtn_Normal, m_pBtn_Private, m_pBtn_PartyOrForce, m_pBtn_KnightsOrGuild, m_pBtn_Shout };

	switch(m_eChatMode)
	{
	case N3_CHAT_NORMAL:
	case N3_CHAT_PUBLIC:
	case N3_CHAT_CONTINUE:
//		m_eChatBuffer = CHAT_BUFFER_NORMAL;
		bNBDs[0] = true;
		break;
	case N3_CHAT_PRIVATE:
//		m_eChatBuffer = CHAT_BUFFER_PRIVATE;
		bNBDs[1] = true;
		break;
	case N3_CHAT_PARTY:
	case N3_CHAT_FORCE:
//		m_eChatBuffer = CHAT_BUFFER_PARTY; 
		bNBDs[2] = true;
		break;
	case N3_CHAT_CLAN:
//		m_eChatBuffer = CHAT_BUFFER_KNIGHTS;
		bNBDs[3] = true;
		break;
	case N3_CHAT_SHOUT:
//		m_eChatBuffer = CHAT_BUFFER_NORMAL;
		bNBDs[4] = true;
		break;
	}

	for(int i = 0; i < 5; i++)
	{
		if(nullptr == pBtns[i]) continue;
		
		if(bNBDs[i])
		{
			if(m_pBtn_Check)
			{
				if(bICLs[i])	m_pBtn_Check->SetState(UI_STATE_BUTTON_DOWN);
				else			m_pBtn_Check->SetState(UI_STATE_BUTTON_NORMAL);
			}
			pBtns[i]->SetState(UI_STATE_BUTTON_DOWN);
		}
		else pBtns[i]->SetState(UI_STATE_BUTTON_NORMAL);
	}

//	if(eCBPrev != m_eChatBuffer) this->AdjustScroll(); // 채팅 모드가 달라지면..
}

void CUIChat::ChatListenEnable()
{
	switch(m_eChatMode)
	{
	case N3_CHAT_NORMAL:
		m_bChatNormal = !m_bChatNormal;
		break;
	case N3_CHAT_PRIVATE:
		m_bChatPrivate = !m_bChatPrivate;
		break;
	case N3_CHAT_PARTY:
	case N3_CHAT_FORCE:
		m_bChatParty = !m_bChatParty;
		break;
	case N3_CHAT_CLAN:
		m_bChatClan = !m_bChatClan;
		break;
	case N3_CHAT_SHOUT:
		m_bChatShout = !m_bChatShout;
		break;
	}
}

bool CUIChat::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if(pFocus && pFocus != this) pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIChat::AddContinueMsg(e_ChatMode eCM, const std::string& szString, D3DCOLOR color)
{
	__ChatInfo* pChatInfo = new __ChatInfo(szString, color);
	m_ContinueMsg.push_back(pChatInfo);

	AddChatMsg(eCM, szString, color);	
}

void CUIChat::DeleteContinueMsg()
{
	m_iCurContinueMsg = 0;

	ChatListItor itor;
	for(itor = m_ContinueMsg.begin(); m_ContinueMsg.end() != itor; ++itor)
	{
		__ChatInfo* pChatInfo = (*itor);
		if (pChatInfo) delete pChatInfo;
	}
	m_ContinueMsg.clear();
}

void CUIChat::ShowContinueMsg()
{
	int iSize = static_cast<int>(m_ContinueMsg.size());
	if (m_iCurContinueMsg > iSize)
		m_iCurContinueMsg = 0;

	int iCnt = 0;
	for (__ChatInfo* pChatInfo : m_ContinueMsg)
	{
		// NOTE: This behaviour looks wrong but iCnt hasn't been touched.
		if (iCnt != m_iCurContinueMsg)
			continue;

		m_iCurContinueMsg++;

		if (pChatInfo != nullptr)
			AddChatMsg(N3_CHAT_CONTINUE, pChatInfo->szChat, pChatInfo->color);
	}
}

void CUIChat::SetNoticeTitle(const std::string& szString, D3DCOLOR color)
{
	if (m_pNoticeTitle != nullptr)
	{
		m_pNoticeTitle->SetString(szString);
		m_pNoticeTitle->SetColor(color);
	}
}


// CHAT 2 (FOLDED)

CUIChat2::CUIChat2()
{
	m_pBtn_Fold = nullptr;
}

bool CUIChat2::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;
	N3_VERIFY_UI_COMPONENT(m_pBtn_Fold, GetChildByID("btn_on"));
	return true;
}

bool CUIChat2::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (nullptr == pSender) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Fold)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIChat();
			return true;
		}
	}

	return false;
}

void CUIChat2::Release()
{
	CN3UIBase::Release();
	m_pBtn_Fold = nullptr;
}

// ===== END WarFare/UIChat.cpp =====

// ===== BEGIN WarFare/UIChat.h =====
#line 1 "WarFare/UIChat.h"
﻿// UIChat.h: interface for the CUIChat class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICHAT_H__2CFECA0D_EA38_4900_86BB_BAFD4D5EE6F7__INCLUDED_)
#define AFX_UICHAT_H__2CFECA0D_EA38_4900_86BB_BAFD4D5EE6F7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include <deque>

//enum e_ChatBuffer { CHAT_BUFFER_NORMAL = 0, CHAT_BUFFER_PRIVATE, CHAT_BUFFER_PARTY, CHAT_BUFFER_KNIGHTS, CHAT_BUFFER_COUNT };

struct __ChatInfo
{
	std::string szChat; // 문자열
	D3DCOLOR	color; // 문자열 색깔

	__ChatInfo() {};
	__ChatInfo(const std::string& szChat_Arg, D3DCOLOR color_Arg) { szChat = szChat_Arg; color = color_Arg; }
};

typedef std::deque<__ChatInfo*>		ChatList;
typedef ChatList::iterator			ChatListItor;
typedef ChatList::reverse_iterator	ChatListReverseItor;
const int MAX_CHAT_LINES = 100;

class CUIChat : public CN3UIBase  
{
protected:
//	ChatList		m_ChatBuffers[CHAT_BUFFER_COUNT];		// 채팅 packet기준으로 된 buffer
//	ChatList		m_LineBuffers[CHAT_BUFFER_COUNT];		// Line 기준으로 된 buffer
	ChatList		m_ChatBuffer;		// 채팅 packet기준으로 된 buffer
	ChatList		m_LineBuffer;		// Line 기준으로 된 buffer
	ChatList		m_ContinueMsg;		// 지속적으로 공지해주는 메시지 buffer
	int				m_iCurContinueMsg;

	CN3UIString*	m_pNoticeTitle;		// 채팅창 맨윗줄에 표시될 공지...
	CN3UIString*	m_pChatOut;			// 채팅이 출력되는 UIString 참조포인터(실제 m_Child로 관리), 글씨체와 초기 영역만 참조한다.
	CN3UIScrollBar* m_pScrollbar;		// scrollbar 참조포인터(실제 m_Child로 관리)
	int				m_iChatLineCount;	// 채팅창에 출력되는 line의 수(채팅창 사이즈가 변했을때 다시 계산해주자.)
	RECT			m_rcChatOutRegion;	// 채팅이 출력되는 영역
	CN3UIString**	m_ppUILines;		// 채팅이 출력되는 UIString 배열포인터(채팅창 사이즈가 변하므로 배열도 변한다.

	CN3UIEdit*		m_pEdit;			//son, chat_in
	std::string		m_szString;			//son, chat_in

	CN3UIBase*		m_pBtn_Normal;
	CN3UIBase*		m_pBtn_Private;
	CN3UIBase*		m_pBtn_PartyOrForce;
	CN3UIBase*		m_pBtn_KnightsOrGuild;
	CN3UIBase*		m_pBtn_Shout;
	CN3UIBase*		m_pBtn_Check;
	CN3UIBase*		m_pBtn_Fold;

	enum e_ChatMode	m_eChatMode;

	bool			m_bChatNormal;
	bool			m_bChatPrivate;
	bool			m_bChatClan;
	bool			m_bChatShout;
	bool			m_bChatParty;

	bool			m_bKillFocus;
//	e_ChatBuffer	m_eChatBuffer; // 채팅 표시 모드 .. 버퍼가 나누어져있다..
	
/*
	ChatList		m_MsgBuffer;		// 채팅 packet기준으로 된 buffer
	ChatList		m_MsgLineBuffer;	// Line 기준으로 된 buffer

	CN3UIString*	m_pMsgOut;		// 채팅이 출력되는 UIString 참조포인터(실제 m_Child로 관리)
	CN3UIScrollBar* m_pMsgScrollbar;	// scrollbar 참조포인터(실제 m_Child로 관리)
	int				m_iMsgLineCount;	// 채팅창에 출력되는 line의 수(채팅창 사이즈가 변했을때 다시 계산해주자.)
*/

protected:
	void			SetTopLine(int iTopLine);		// 맨 윗줄을 지정해준다.
//	void			AddLineBuffer(e_ChatBuffer eCB, const std::string& szString, D3DCOLOR color);	// line 버퍼를 만들어준다.(너무 길면 알아서 2줄로 만들어준다.)
	void			AddLineBuffer(const std::string& szString, D3DCOLOR color);	// line 버퍼를 만들어준다.(너무 길면 알아서 2줄로 만들어준다.)
	void			RecalcLineBuffers();		// 채팅창 사이즈가 변했을때 호출해주면 line buffer를 다시 계산해서 넣어준다.
	void			CreateLines();

// Operations
public:
	void			SetNoticeTitle(const std::string& szString, D3DCOLOR color);
	void			ShowContinueMsg();
	void			DeleteContinueMsg();
	bool			OnKeyPress(int iKey);
	bool			GetEnableKillFocus() { return m_bKillFocus; }
	void			SetEnableKillFocus(bool bKillFocus) { m_bKillFocus = bKillFocus; }
	void			ChatListenEnable();
	void			ChangeChattingMode(e_ChatMode eCM);
	BOOL			MoveOffset(int iOffsetX, int iOffsetY) override;	// Offset만큼 이동해준다.(region, children, move rect 이동)
	bool			ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void			Release() override;
	bool			Load(File& file) override;
	void			SetRegion(const RECT& Rect) override;	// 영역 지정(사이즈가 변할때 호출된다. 단순 이동은 호출되지 않는다.(단순이동은 MoveOffset이 호출))

	void				SetString(const std::string& szChat);
	void				SetCaretPos(int iPos);
	const std::string&	GetString() const {return m_szString;}				//son, chat_in
	void				AddChatMsg(e_ChatMode eCM, const std::string& szString, D3DCOLOR color = 0xffffffff);		// 채팅 메세지를 저장하고 알맞은 형태로 화면에 출력해준다.
	void				AddContinueMsg(e_ChatMode eCM, const std::string& szString, D3DCOLOR color = 0xffffffff);
	void				AdjustScroll(); // 스크롤 위치등 조정..

	BOOL			IsChatMode();
	void			SetFocus();
	void			KillFocus();

	CUIChat();
	~CUIChat() override;
};

// TODO: Use official name for this
class CUIChat2 : public CN3UIBase
{
protected:
	CN3UIBase*		m_pBtn_Fold;

public:
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Release() override;
	bool Load(File& file) override;

	CUIChat2();
};

#endif // !defined(AFX_UICHAT_H__2CFECA0D_EA38_4900_86BB_BAFD4D5EE6F7__INCLUDED_)



// ===== END WarFare/UIChat.h =====

// ===== BEGIN WarFare/UIClassChange.cpp =====
#line 1 "WarFare/UIClassChange.cpp"
﻿// UIClassChange.cpp: implementation of the CUIClassChange class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIClassChange.h"
#include "PacketDef.h"
#include "PlayerMySelf.h"
#include "GameProcMain.h"
#include "UISkillTreeDlg.h"
#include "APISocket.h"
#include "UIVarious.h"
#include "UIHotkeyDlg.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIClassChange::CUIClassChange()
{
	m_pBtn_Ok		= nullptr;
	m_pBtn_Cancel	= nullptr;
	m_pBtn_Class	= nullptr;

	m_pText_Warning	= nullptr;
	m_pText_Info	= nullptr;
	m_pText_Title	= nullptr;
	m_pText_Message	= nullptr;
}

CUIClassChange::~CUIClassChange()
{

}

bool CUIClassChange::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Ok, GetChildByID<CN3UIButton>("Btn_Ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel, GetChildByID<CN3UIButton>("Btn_Cancel"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Class, GetChildByID<CN3UIButton>("Btn_Class"));

	N3_VERIFY_UI_COMPONENT(m_pText_Warning, GetChildByID<CN3UIString>("Text_Waring"));
	N3_VERIFY_UI_COMPONENT(m_pText_Info, GetChildByID<CN3UIString>("Text_info"));
	N3_VERIFY_UI_COMPONENT(m_pText_Message, GetChildByID<CN3UIString>("Text_Message"));

	return true;
}

void CUIClassChange::Open(int iCode)
{
	SetVisible(true);

	__InfoPlayerBase*	pInfoBase = &CGameBase::s_pPlayer->m_InfoBase;
	__InfoPlayerMySelf*	pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

	std::string szSuccess, szNotYet, szAlready, szItemInSlot;
	szSuccess = fmt::format_text_resource(IDS_CLASS_CHANGE_SUCCESS);
	szNotYet = fmt::format_text_resource(IDS_CLASS_CHANGE_NOT_YET);
	szAlready = fmt::format_text_resource(IDS_CLASS_CHANGE_ALREADY);
	szItemInSlot = fmt::format_text_resource(IDS_MSG_HASITEMINSLOT);

	m_pBtn_Ok->SetVisible(false);
	m_pBtn_Cancel->SetVisible(false);
	m_pBtn_Class->SetVisible(false);

	m_pText_Warning->SetVisible(false);
	m_pText_Info->SetVisible(false);
	m_pText_Message->SetVisible(true);

	std::string szClassTmp;

	switch ( iCode )
	{
		case N3_SP_CLASS_CHANGE_SUCCESS:
			m_pText_Message->SetString(szSuccess);
			m_pBtn_Class->SetVisible(true);
			m_pBtn_Cancel->SetVisible(true);

			m_pText_Info->SetVisible(true);

			m_eClass = pInfoBase->eClass;
			switch ( pInfoBase->eClass )
			{
				case CLASS_KA_WARRIOR:
					CGameBase::GetTextByClass(CLASS_KA_BERSERKER, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_KA_ROGUE:
					CGameBase::GetTextByClass(CLASS_KA_HUNTER, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_KA_WIZARD:
					CGameBase::GetTextByClass(CLASS_KA_SORCERER, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_KA_PRIEST:
					CGameBase::GetTextByClass(CLASS_KA_SHAMAN, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_EL_WARRIOR:
					CGameBase::GetTextByClass(CLASS_EL_BLADE, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_EL_ROGUE:
					CGameBase::GetTextByClass(CLASS_EL_RANGER, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_EL_WIZARD:
					CGameBase::GetTextByClass(CLASS_EL_MAGE, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
				case CLASS_EL_PRIEST:
					CGameBase::GetTextByClass(CLASS_EL_CLERIC, szClassTmp); m_pText_Info->SetString(szClassTmp);
					break;
			}
			break;

		case N3_SP_CLASS_CHANGE_NOT_YET:
			m_pText_Message->SetString(szNotYet);
			m_pBtn_Ok->SetVisible(true);
			break;

		case N3_SP_CLASS_CHANGE_ALREADY:
			m_pText_Message->SetString(szAlready);
			m_pBtn_Ok->SetVisible(true);
			break;

		case IDS_MSG_HASITEMINSLOT: // TODO: FIXME. This is not a valid subopcode!
			m_pText_Message->SetString(szItemInSlot);
			m_pBtn_Ok->SetVisible(true);
			break;
	}
}

bool CUIClassChange::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	__InfoPlayerBase*	pInfoBase = &(CGameBase::s_pPlayer->m_InfoBase);
	__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if (pSender == m_pBtn_Ok
			|| pSender == m_pBtn_Cancel)
		{
			Close();
		}
		else if (pSender == m_pBtn_Class)
		{
			switch (pInfoBase->eClass)
			{
				case CLASS_KA_WARRIOR:
					pInfoBase->eClass = CLASS_KA_BERSERKER;
					break;
				case CLASS_KA_ROGUE:
					pInfoBase->eClass = CLASS_KA_HUNTER;
					break;
				case CLASS_KA_WIZARD:
					pInfoBase->eClass = CLASS_KA_SORCERER;
					break;
				case CLASS_KA_PRIEST:
					pInfoBase->eClass = CLASS_KA_SHAMAN;
					break;
				case CLASS_EL_WARRIOR:
					pInfoBase->eClass = CLASS_EL_BLADE;
					break;
				case CLASS_EL_ROGUE:
					pInfoBase->eClass = CLASS_EL_RANGER;
					break;
				case CLASS_EL_WIZARD:
					pInfoBase->eClass = CLASS_EL_MAGE;
					break;
				case CLASS_EL_PRIEST:
					pInfoBase->eClass = CLASS_EL_CLERIC;
					break;
			}

			CGameProcedure::s_pProcMain->m_pUIVar->UpdateAllStates(pInfoBase, pInfoExt); // 상태창 수치를 모두 적용

			uint8_t byBuff[4];
			int iOffset = 0;
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CLASS_CHANGE);
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_CLASS_CHANGE_REQ);
			CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t) pInfoBase->eClass);
			CGameProcedure::s_pSocket->Send(byBuff, iOffset);

			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->InitIconUpdate();

			// 전직하는 순간..  핫키 정보를 모두 없앤다..
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->ClassChangeHotkeyFlush();
			Close();
		}
	}

	return true;
}

void CUIClassChange::Close()
{
	SetVisible(false);
}

void CUIClassChange::RestorePrevClass()
{
	__InfoPlayerBase*	pInfoBase = &CGameBase::s_pPlayer->m_InfoBase;
	__InfoPlayerMySelf*	pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

	pInfoBase->eClass = m_eClass;
	CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->InitIconUpdate();

	CGameProcedure::s_pProcMain->m_pUIVar->UpdateAllStates(pInfoBase, pInfoExt); // 상태창 수치를 모두 적용
}

void CUIClassChange::ChangeToNormalState()
{
	m_pBtn_Ok->SetVisible(false);
	m_pBtn_Cancel->SetVisible(true);
	m_pBtn_Class->SetVisible(true);

	m_pText_Warning->SetVisible(false);
	m_pText_Info->SetVisible(true);
	m_pText_Message->SetVisible(true);
}

// ===== END WarFare/UIClassChange.cpp =====

// ===== BEGIN WarFare/UIClassChange.h =====
#line 1 "WarFare/UIClassChange.h"
﻿// UIClassChange.h: interface for the CUIClassChange class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICLASSCHANGE_H__74E2A304_165D_44C9_88C5_00746B408CCF__INCLUDED_)
#define AFX_UICLASSCHANGE_H__74E2A304_165D_44C9_88C5_00746B408CCF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUIClassChange : public CN3UIBase  
{
	CN3UIButton*		m_pBtn_Ok;
	CN3UIButton*		m_pBtn_Cancel;
	CN3UIButton*		m_pBtn_Class;
	
	CN3UIString*		m_pText_Warning;
	CN3UIString*		m_pText_Info;
	CN3UIString*		m_pText_Title;
	CN3UIString*		m_pText_Message;

	e_Class				m_eClass;

public:
	CUIClassChange();
	~CUIClassChange() override;

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
		    
	void Open(int iCode);
	void Close();
		    
	void RestorePrevClass();
	void ChangeToWarningState();
	void ChangeToNormalState();
};

#endif // !defined(AFX_UICLASSCHANGE_H__74E2A304_165D_44C9_88C5_00746B408CCF__INCLUDED_)

// ===== END WarFare/UIClassChange.h =====

// ===== BEGIN WarFare/UICmd.cpp =====
#line 1 "WarFare/UICmd.cpp"
﻿// UICmd.cpp: implementation of the CUICmd class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UICmd.h"
#include "GameProcMain.h"
#include "PlayerOtherMgr.h"
#include "PlayerMyself.h"
#include "UITransactionDlg.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICmd::CUICmd()
{
	m_pBtn_Exit = nullptr;			// 나가기

	m_pBtn_Act = nullptr;			// 행동
	m_pBtn_Act_Walk = nullptr;		// 걷기
	m_pBtn_Act_Run = nullptr;		// 달리기
	m_pBtn_Act_Attack = nullptr;	// 공격
	
	m_pBtn_Act_StandUp = nullptr;	// 일어서기.
	m_pBtn_Act_SitDown = nullptr;	// 앉기

	m_pBtn_Camera = nullptr;		// 카메라
	m_pBtn_Inventory = nullptr;		// 아이템 창 
	m_pBtn_Party_Invite = nullptr;	// 파티 초대
	m_pBtn_Party_Disband = nullptr;	// 파티 탈퇴
	m_pBtn_CmdList = nullptr;		// 옵션
	m_pBtn_Character = nullptr;		// 자기 정보창   
	m_pBtn_Skill = nullptr;			// 스킬트리 또는 마법창 
	m_pBtn_Map = nullptr;			// 미니맵
}

CUICmd::~CUICmd()
{
}

bool CUICmd::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;
	
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act,				GetChildByID<CN3UIButton>("btn_control"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act_Walk,			GetChildByID<CN3UIButton>("btn_walk"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act_Run,			GetChildByID<CN3UIButton>("btn_run"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act_Attack,		GetChildByID<CN3UIButton>("btn_attack"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act_StandUp,		GetChildByID<CN3UIButton>("btn_stand"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Act_SitDown,		GetChildByID<CN3UIButton>("btn_sit"));

	// 일어서기 버튼은 미리 죽여놓는다..
	if (m_pBtn_Act_StandUp != nullptr)
		m_pBtn_Act_StandUp->SetVisible(false); 
	
	N3_VERIFY_UI_COMPONENT(m_pBtn_Character,		GetChildByID<CN3UIButton>("btn_character"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Inventory,		GetChildByID<CN3UIButton>("btn_inventory"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_CmdList,			GetChildByID<CN3UIButton>("btn_option"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Camera,			GetChildByID<CN3UIButton>("btn_camera"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Party_Invite,		GetChildByID<CN3UIButton>("btn_invite"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Party_Disband,	GetChildByID<CN3UIButton>("btn_disband"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Skill,			GetChildByID<CN3UIButton>("btn_skill"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Exit,				GetChildByID<CN3UIButton>("btn_exit"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Map,				GetChildByID<CN3UIButton>("btn_map"));

//	this->SetVisibleActButtons(true);
//	this->SetVisibleOptButtons(false);

	return true;
}

bool CUICmd::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if ( CGameProcedure::s_pProcMain->m_pUITransactionDlg->IsVisible() )	
			return true;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtn_CmdList)
		{
			CGameProcedure::s_pProcMain->CommandToggleCmdList();
		}

		if(pSender == m_pBtn_Act)
		{
//			this->SetVisibleActButtons(true);
//			this->SetVisibleOptButtons(false);
		}

		else if(pSender == m_pBtn_Act_Walk)
		{
			CGameProcedure::s_pProcMain->CommandToggleWalkRun();
		}
			
		else if(pSender == m_pBtn_Act_Run)
		{
			CGameProcedure::s_pProcMain->CommandToggleWalkRun();
		}

		else if(pSender == m_pBtn_Act_Attack)
		{
			CGameProcedure::s_pProcMain->CommandToggleAttackContinous();
		}

		else if(pSender == m_pBtn_Inventory)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIInventory();
		}
		
		else if(pSender == m_pBtn_Character)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIState();
		}

		else if(pSender == m_pBtn_Exit) 
		{
			//m_bSuppressNextMouseFocus = true;
			CGameProcedure::s_pProcMain->RequestExit();
		}

		else if(pSender == m_pBtn_Camera)
		{
			CGameProcedure::s_pProcMain->CommandCameraChange(); 
		}

		else if(pSender == m_pBtn_Party_Invite)
		{
			CPlayerOther* pUPC = CGameProcedure::s_pOPMgr->UPCGetByID(CGameBase::s_pPlayer->m_iIDTarget, true);

			// 국가 체크
			if (pUPC != nullptr
				&& !CGameBase::s_pPlayer->IsHostileTarget(pUPC))
				CGameProcedure::s_pProcMain->MsgSend_PartyOrForceCreate(0, pUPC->IDString()); // 파티 초대하기..
		}

		else if(pSender == m_pBtn_Party_Disband)
		{
			CGameProcMain* pMain = CGameProcedure::s_pProcMain;
			CPlayerMySelf* pPlayer = CGameBase::s_pPlayer;

			bool bIAmLeader = false, bIAmMemberOfParty = false;
			int iMemberIndex = -1;
			CPlayerBase* pTarget = nullptr;
			pMain->PartyOrForceConditionGet(bIAmLeader, bIAmMemberOfParty, iMemberIndex, pTarget); // 파티의 상황을 보고..
			
			std::string szMsg;
			if(bIAmLeader) // 내가 리더면..
			{
				if(iMemberIndex > 0)
				{
					szMsg = fmt::format_text_resource(IDS_PARTY_CONFIRM_DISCHARGE);
					szMsg = pTarget->IDString() + szMsg;
				}
				else szMsg = fmt::format_text_resource(IDS_PARTY_CONFIRM_DESTROY);
			}
			else if(bIAmMemberOfParty)
			{
				szMsg = fmt::format_text_resource(IDS_PARTY_CONFIRM_LEAVE);
			}

			if(!szMsg.empty()) CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_PARTY_DISBAND); // 파티 해체,축출,탈퇴하기..확인
		}

		else if(pSender == m_pBtn_Act_SitDown)
		{
			CGameProcedure::s_pProcMain->CommandSitDown(true, true);
		}
		
		else if(pSender == m_pBtn_Act_StandUp)
		{
			CGameProcedure::s_pProcMain->CommandSitDown(true, false);
		}

		else if(pSender == m_pBtn_Skill)
		{
			CGameProcedure::s_pProcMain->CommandToggleUISkillTree();
		}

		else if(pSender == m_pBtn_Map)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIMiniMap();
		}
	}

	return true;
}

/*
void CUICmd::SetVisibleActButtons(bool bVisible)
{
	//행동
	if(m_pBtn_Act_Walk) m_pBtn_Act_Walk->SetVisible(bVisible); 
	if(m_pBtn_Act_Run) m_pBtn_Act_Run->SetVisible(bVisible);
	if(m_pBtn_Act_Stop) m_pBtn_Act_Stop->SetVisible(bVisible);
	if(m_pBtn_Act_StandUp) m_pBtn_Act_StandUp->SetVisible(bVisible);
	if(m_pBtn_Act_SitDown) m_pBtn_Act_SitDown->SetVisible(bVisible);
	if(m_pBtn_Act_Attack) m_pBtn_Act_Attack->SetVisible(bVisible);
}
*/

/*
void CUICmd::SetVisibleOptButtons(bool bVisible)
{
	//옵션
	if(m_pBtn_Opt_Quest) m_pBtn_Opt_Quest->SetVisible(bVisible);
	if(m_pBtn_Character) m_pBtn_Character->SetVisible(bVisible);	
	if(m_pBtn_Skill) m_pBtn_Skill->SetVisible(bVisible);
	if(m_pBtn_Opt_Knight) m_pBtn_Opt_Knight->SetVisible(bVisible);
	if(m_pBtn_Inventory) m_pBtn_Inventory->SetVisible(bVisible);	
}
*/

void CUICmd::UpdatePartyButtons(bool bIAmLeader, bool bIAmMemberOfParty, int iMemberIndex, const CPlayerBase* pTarget)
{
	bool bInvite = true;
	if(bIAmLeader) // 내가 리더이면.. 
	{
		if(pTarget) // 타겟이 있고..
		{
			if(iMemberIndex > 0) bInvite = false; // 타겟이 파티원이면..축출 가능하게.
			else bInvite = true;
		}
		else
		{
			bInvite = false; // 리더도 나갈수 있다..
		}
	}
	else
	{
		if(bIAmMemberOfParty) bInvite = false; // 리더는 아니지만 파티에 들어있는 상태이면.. 탈퇴가능..
		else bInvite = true; // 파티에 안들어 있다면 초대 가능...
	}

	if(m_pBtn_Party_Invite) m_pBtn_Party_Invite->SetVisible(bInvite);
	if(m_pBtn_Party_Disband) m_pBtn_Party_Disband->SetVisible(!bInvite);
}

bool CUICmd::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if (pFocus != nullptr && pFocus != this)
				pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UICmd.cpp =====

// ===== BEGIN WarFare/UICmd.h =====
#line 1 "WarFare/UICmd.h"
﻿// UICmd.h: interface for the CUICmd class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICmd_H__CA4F5382_D9A9_447C_B717_7A0A38724715__INCLUDED_)
#define AFX_UICmd_H__CA4F5382_D9A9_447C_B717_7A0A38724715__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUICmd : public CN3UIBase  
{
public:
	CN3UIButton* m_pBtn_Exit;			// 나가기

	CN3UIButton* m_pBtn_Act;			// 행동
	CN3UIButton* m_pBtn_Act_Walk;		// 걷기
	CN3UIButton* m_pBtn_Act_Run;		// 달리기
	CN3UIButton* m_pBtn_Act_Attack;		// 공격
	
	CN3UIButton* m_pBtn_Act_StandUp;	// 일어서기.
	CN3UIButton* m_pBtn_Act_SitDown;	// 앉기

	CN3UIButton* m_pBtn_Camera;			// 카메라
	CN3UIButton* m_pBtn_Inventory;		// 아이템 창 
	CN3UIButton* m_pBtn_Party_Invite;	// 파티 초대
	CN3UIButton* m_pBtn_Party_Disband;	// 파티 탈퇴
	CN3UIButton* m_pBtn_CmdList;		// 옵션
	CN3UIButton* m_pBtn_Character;		// 자기 정보창   
	CN3UIButton* m_pBtn_Skill;			// 스킬트리 또는 마법창 
	CN3UIButton* m_pBtn_Map;			// 미니맵

public:
	CUICmd();
	~CUICmd() override;
//	void SetVisibleOptButtons(bool bVisible);
//	void SetVisibleActButtons(bool bVisible);
	bool OnKeyPress(int iKey) override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void UpdatePartyButtons(bool bIAmLeader, bool bIAmMemberOfParty, int iMemberIndex, const class CPlayerBase* pTarget);
};

#endif // !defined(AFX_UICmd_H__CA4F5382_D9A9_447C_B717_7A0A38724715__INCLUDED_)

// ===== END WarFare/UICmd.h =====

// ===== BEGIN WarFare/UICmdEdit.cpp =====
#line 1 "WarFare/UICmdEdit.cpp"
﻿// UICmdEdit.cpp: implementation of the UINPCEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UICmdEdit.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "PacketDef.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICmdEdit::CUICmdEdit()
{
}

CUICmdEdit::~CUICmdEdit()
{
}

bool CUICmdEdit::Load(File& file)
{
	if (!CN3UIBase::Load(file)) 
		return false;
	
	N3_VERIFY_UI_COMPONENT(m_pText_Title,	GetChildByID<CN3UIString>("Text_cmd"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Ok,		GetChildByID<CN3UIButton>("btn_ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	GetChildByID<CN3UIButton>("btn_cancel"));
	N3_VERIFY_UI_COMPONENT(m_pEdit_Box,		GetChildByID<CN3UIEdit>("edit_cmd"));

	return true;
}

bool CUICmdEdit::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Ok)
		{
			m_szArg1 = m_pEdit_Box->GetString();
			std::string strTempCmd = "/" + m_pText_Title->GetString() + " " + m_szArg1;
			CGameProcedure::s_pProcMain->ParseChattingCommand(strTempCmd);

			SetVisible(false);
			return true;
		}

		if (pSender == m_pBtn_Cancel)
		{
			SetVisible(false);
			return true;
		}
	}
	return true;
}

void CUICmdEdit::Open(const std::string& msg)
{
	m_pText_Title->SetString(msg);
	m_pEdit_Box->SetFocus();
	SetVisible(true);
}

void CUICmdEdit::SetVisible(bool bVisible)
{
	if (bVisible == IsVisible()) 
		return;

	if (!bVisible)
		m_pEdit_Box->KillFocus();

	CN3UIBase::SetVisible(bVisible);
}

// ===== END WarFare/UICmdEdit.cpp =====

// ===== BEGIN WarFare/UICmdEdit.h =====
#line 1 "WarFare/UICmdEdit.h"
﻿// UICmdEdit.h: interface for the UICmdEdit class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__UICMDEDIT_H__)
#define __UICMDEDIT_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUICmdEdit : public CN3UIBase
{
public:
	CN3UIString*	m_pText_Title;
	CN3UIButton*	m_pBtn_Ok;
	CN3UIButton*	m_pBtn_Cancel;
	CN3UIEdit*		m_pEdit_Box;
	std::string		m_szArg1;

public:
	void SetVisible(bool bVisible);
	void Open(const std::string& msg);

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUICmdEdit();
	~CUICmdEdit() override;
};

#endif //#if !defined(__UICMDEDIT_H__)

// ===== END WarFare/UICmdEdit.h =====

// ===== BEGIN WarFare/UICmdList.cpp =====
#line 1 "WarFare/UICmdList.cpp"
﻿// UICmdList.cpp: implementation of the CUICmdList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "GameDef.h"
#include "UICmdList.h"
#include "GameProcedure.h"
#include "LocalInput.h"

#include "GameProcMain.h"
#include "APISocket.h"
#include "PacketDef.h"
#include "PlayerMySelf.h"
#include "UIManager.h"

#include "N3UIDBCLButton.h"

#include <N3Base/N3Texture.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIList.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIProgress.h>
#include <N3Base/N3UIString.h>

#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern std::string g_szCmdMsg[CMD_COUNT];

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICmdList::CUICmdList()
{
	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0.0f; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..
	m_pBtn_Cancel = nullptr;
	m_pList_CmdCat = nullptr;
	m_pList_Cmds = nullptr;
	m_pUICmdEdit = nullptr;
	m_iSelectedCategory = 0;
	m_eSelectedList = CMD_LIST_SEL_CATEGORY;
}

CUICmdList::~CUICmdList()
{
}

bool CUICmdList::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	GetChildByID<CN3UIButton>("btn_cancel"));
	N3_VERIFY_UI_COMPONENT(m_pList_CmdCat,	GetChildByID<CN3UIList>("list_curtailment"));
	N3_VERIFY_UI_COMPONENT(m_pList_Cmds,	GetChildByID<CN3UIList>("list_content"));

	return true;
}

void CUICmdList::Release()
{
	m_bOpenningNow = false; 
	m_bClosingNow = false;	
	m_fMoveDelta = 0.0f;
	m_pBtn_Cancel = nullptr;
	m_pList_CmdCat = nullptr;
	m_pList_Cmds = nullptr;
	m_pUICmdEdit = nullptr;
	m_iSelectedCategory = 0;
	m_eSelectedList = CMD_LIST_SEL_CATEGORY;

	CN3UIBase::Release();
}

void CUICmdList::Render()
{
	if (!m_bVisible)
		return;

	CN3UIBase::Render();

	if (m_eSelectedList == CMD_LIST_SEL_CATEGORY)
		RenderSelectionBorder(m_pList_CmdCat);
	else if (m_eSelectedList == CMD_LIST_SEL_COMMAND)
		RenderSelectionBorder(m_pList_Cmds);
}

void CUICmdList::RenderSelectionBorder(CN3UIList* pListToRender)
{
	if (pListToRender == nullptr)
		return;

	RECT rcList = pListToRender->GetRegion();

	rcList.left -= 2;
	rcList.top -= 2;
	rcList.right += 2;
	rcList.bottom += 2;

	RenderLines(rcList, D3DCOLOR_XRGB(255, 255, 0)); // yellow
}

void CUICmdList::Tick()
{
	if (m_bOpenningNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if (fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width - (int)fWidth;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)m_fMoveDelta;
		if (ptCur.x <= iXLimit) // 다열렸다!!
		{
			ptCur.x = iXLimit;
			m_bOpenningNow = false;
		}

		this->SetPos(ptCur.x, ptCur.y);
	}
	else if (m_bClosingNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if (fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)(fWidth - m_fMoveDelta);
		if (ptCur.x >= iXLimit) // 다 닫혔다..!!
		{
			ptCur.x = iXLimit;
			m_bClosingNow = false;

			this->SetVisibleWithNoSound(false, false, true); // 다 닫혔으니 눈에서 안보이게 한다.
		}

		this->SetPos(ptCur.x, ptCur.y);
	}

	CN3UIBase::Tick();
}

bool CUICmdList::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Cancel)
		{
			Close();
			return true;
		}
	}
	else if (dwMsg == UIMSG_LIST_SELCHANGE)
	{
		if (pSender == m_pList_CmdCat)
		{
			m_iSelectedCategory = m_pList_CmdCat->GetCurSel();
			m_eSelectedList = CMD_LIST_SEL_CATEGORY;
			UpdateCommandList(m_iSelectedCategory);
			return true;
		}
		else if (pSender == m_pList_Cmds)
		{
			m_eSelectedList = CMD_LIST_SEL_COMMAND;
			return true;
		}
	}
	else if (dwMsg == UIMSG_LIST_DBLCLK)
	{
		if (pSender == m_pList_Cmds)
		{
			int iSel = m_pList_Cmds->GetCurSel();
			ExecuteCommand(iSel);
			return true;
		}
	}

	return false;
}

bool CUICmdList::OnMouseWheelEvent(short delta)
{
	if (delta > 0)
		OnKeyPress(DIK_UP);
	else
		OnKeyPress(DIK_DOWN);

	return true;
}

bool CUICmdList::OnKeyPress(int iKey)
{
	switch (iKey)
	{
		case DIK_ESCAPE:
			Close(); // close with animation
			return true;

		case DIK_RETURN:
			if (m_pList_Cmds != nullptr)
				ExecuteCommand(m_pList_Cmds->GetCurSel());
			return true;

		case DIK_DOWN:
			if (m_eSelectedList == CMD_LIST_SEL_CATEGORY)
			{
				int iSelectedIndex = m_pList_CmdCat->GetCurSel();
				int iMaxIndex = m_pList_CmdCat->GetCount() - 1;

				iSelectedIndex = std::clamp(iSelectedIndex + 1, 0, iMaxIndex);

				m_pList_CmdCat->SetCurSel(iSelectedIndex);
				UpdateCommandList(iSelectedIndex);
			}
			else if (m_eSelectedList == CMD_LIST_SEL_COMMAND)
			{
				int iSelectedIndex = m_pList_Cmds->GetCurSel();
				int iMaxIndex = m_pList_Cmds->GetCount() - 1;

				iSelectedIndex = std::clamp(iSelectedIndex + 1, 0, iMaxIndex);

				m_pList_Cmds->SetCurSel(iSelectedIndex);
			}
			return true;

		case DIK_UP:
			if (m_eSelectedList == CMD_LIST_SEL_CATEGORY)
			{
				int iSelectedIndex = m_pList_CmdCat->GetCurSel();
				int iMaxIndex = m_pList_CmdCat->GetCount() - 1;

				iSelectedIndex = std::clamp(iSelectedIndex - 1, 0, iMaxIndex);

				m_pList_CmdCat->SetCurSel(iSelectedIndex);
				UpdateCommandList(iSelectedIndex);
			}
			else if (m_eSelectedList == CMD_LIST_SEL_COMMAND)
			{
				int iSelectedIndex = m_pList_Cmds->GetCurSel();
				int iMaxIndex = m_pList_Cmds->GetCount() - 1;

				iSelectedIndex = std::clamp(iSelectedIndex - 1, 0, iMaxIndex);

				m_pList_Cmds->SetCurSel(iSelectedIndex);
			}
			return true;

		case DIK_TAB:
			if (m_eSelectedList == CMD_LIST_SEL_CATEGORY)
				m_eSelectedList = CMD_LIST_SEL_COMMAND;
			else
				m_eSelectedList = CMD_LIST_SEL_CATEGORY;
			return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUICmdList::Open()
{
	// 스르륵 열린다!!
	SetVisible(true);
	SetPos(CN3Base::s_CameraData.vp.Width, 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = true;
	m_bClosingNow = false;

	// Reset selected command to first in list
	if (m_pList_Cmds != nullptr)
		m_pList_Cmds->SetCurSel(0);
}

void CUICmdList::Close()
{
	RECT rc = GetRegion();
	SetPos(CN3Base::s_CameraData.vp.Width - (rc.right - rc.left), 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = false;
	m_bClosingNow = true;
}

void CUICmdList::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

bool CUICmdList::CreateCategoryList()
{
	if (m_pList_CmdCat == nullptr
		|| m_pList_Cmds == nullptr)
		return false;

	std::string szCategory, szTooltip;	

	for (int i = 0; i < CMD_LIST_CAT_COUNT; i++)
	{
		// category names start with 7800
		int iCategoryResourceID = IDS_PRIVATE_CMD_CAT + i;
		szCategory = fmt::format_text_resource(iCategoryResourceID);
		m_pList_CmdCat->AddString(szCategory);

		// category tips start with 7900
		szTooltip = fmt::format_text_resource(iCategoryResourceID + 100);

		CN3UIString* pChild = m_pList_CmdCat->GetChildStrFromList(szCategory);
		if (pChild != nullptr)
		{
			pChild->SetTooltipColor(D3DCOLOR_XRGB(144, 238, 144)); // green
			pChild->SetTooltipText(szTooltip);
		}
	}

	m_pList_CmdCat->SetFontColor(D3DCOLOR_XRGB(255, 255, 0)); // yellow

	struct CommandCategory
	{
		e_CmdListCategory eCategory;
		e_ChatCmd eBaseCmd;
		int iFirstResourceID;
		int iLastResourceID;
	};

	// Temporarily just map everything together so they can be used as-is.
	// The command index needs to be reworked to behave more like official, where it's handled within CUICmdList and categorised,
	// so that entire translation can be thrown away.
	constexpr CommandCategory commandCategories[] =
	{
		// Category					Base command index	First resource ID		Last resource ID
		{ CMD_LIST_CAT_PRIVATE,		CMD_WHISPER,		IDS_CMD_WHISPER,		IDS_CMD_INDIVIDUAL_BATTLE },
		{ CMD_LIST_CAT_TRADE,		CMD_TRADE,			IDS_CMD_TRADE,			IDS_CMD_MERCHANT },
		{ CMD_LIST_CAT_PARTY,		CMD_PARTY,			IDS_CMD_PARTY,			IDS_CMD_PERMITPARTY },
		{ CMD_LIST_CAT_CLAN,		CMD_JOINCLAN,		IDS_CMD_JOINCLAN,		IDS_CMD_CLAN_BATTLE },
		{ CMD_LIST_CAT_KNIGHTS,		CMD_CONFEDERACY,	IDS_CMD_CONFEDERACY,	IDS_CMD_DECLARATION },
		{ CMD_LIST_CAT_GUARDIAN,	CMD_HIDE,			IDS_CMD_HIDE,			IDS_CMD_DESTROY },
		{ CMD_LIST_CAT_KING,		CMD_ROYALORDER,		IDS_CMD_ROYALORDER,		IDS_CMD_REWARD },
	};

	m_categoryToCommandInfoMap.clear();

	for (const CommandCategory& commandCategory : commandCategories)
		AppendToCommandMap(commandCategory.eCategory, commandCategory.eBaseCmd, commandCategory.iFirstResourceID, commandCategory.iLastResourceID);

	// Unofficial. This isn't displayed officially.
	if (CGameBase::s_pPlayer->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
		AppendToCommandMap(CMD_LIST_CAT_GM, CMD_VISIBLE, IDS_CMD_VISIBLE, IDS_CMD_PLC);

	UpdateCommandList(m_iSelectedCategory); // initialize a cmd list for viewing when opening cmd window

	return true;
}

bool CUICmdList::UpdateCommandList(int iCatIndex)
{
	if (iCatIndex < 0
		|| iCatIndex >= CMD_LIST_CAT_COUNT)
		return false;

	if (m_pList_Cmds == nullptr)
		return false;
	
	m_pList_Cmds->ResetContent();

	e_CmdListCategory eCategory = static_cast<e_CmdListCategory>(iCatIndex);

	const auto range = m_categoryToCommandInfoMap.equal_range(eCategory);
	for (const auto& [_, commandInfo] : std::ranges::subrange(range.first, range.second))
	{
		const std::string& commandName = g_szCmdMsg[commandInfo.Command];
		m_pList_Cmds->AddString(commandName);

		// fill with command name exp: /type %s, to /type ban_user
		std::string cmdTip = fmt::format_text_resource(commandInfo.ResourceID  + 100, commandName);

		CN3UIString* pChild = m_pList_Cmds->GetChildStrFromList(commandName);
		if (pChild != nullptr)
		{
			pChild->SetTooltipColor(D3DCOLOR_XRGB(144, 238, 144)); // green
			pChild->SetTooltipText(cmdTip);
		}
	}

	return true;
}

void CUICmdList::AppendToCommandMap(e_CmdListCategory eCategory, e_ChatCmd eBaseCmd, int iFirstResourceID, int iLastResourceID)
{
	for (int iResourceID = iFirstResourceID, iRealCmdIndex = eBaseCmd;
		iResourceID <= iLastResourceID;
		++iResourceID, ++iRealCmdIndex)
	{
		CommandInfo commandInfo;
		commandInfo.ResourceID	= iResourceID;
		commandInfo.Command		= static_cast<e_ChatCmd>(iRealCmdIndex);
		m_categoryToCommandInfoMap.insert(std::make_pair(eCategory, std::move(commandInfo)));
	}
}

bool CUICmdList::ExecuteCommand(int iCmdIndex)
{
	// Fetch base command index for this category.
	// TODO: This should all ultimately be thrown away; it's based on outdated logic where all
	// commands were thrown into the same array and assigned a relative ID.
	// Officially this got moved into CUICmdList and categorised, so this should be refactored
	// and thrown away.
	e_CmdListCategory eCategory = static_cast<e_CmdListCategory>(m_iSelectedCategory);

	// NOTE: The first command in the category is the base. It is guaranteed to be in insert order.
	auto itr = m_categoryToCommandInfoMap.find(eCategory);
	if (itr == m_categoryToCommandInfoMap.end())
		return false;

	std::string command;
	m_pList_Cmds->GetString(iCmdIndex, command);

	int iRealCmdIndex = itr->second.Command + iCmdIndex;
	if (iRealCmdIndex == CMD_WHISPER)
	{
		CGameProcedure::s_pProcMain->OpenCmdEdit(command);
		return true;
	}

	command = '/' + command;
	CGameProcedure::s_pProcMain->ParseChattingCommand(command);

	return true;
}

// ===== END WarFare/UICmdList.cpp =====

// ===== BEGIN WarFare/UICmdList.h =====
#line 1 "WarFare/UICmdList.h"
﻿// UICmdList.h: interface for the CUICmdList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UICmdList_H)
#define AFX_UICmdList_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#include <unordered_map>

enum e_ChatCmd
{
	// Private
	CMD_WHISPER, CMD_TOWN, CMD_EXIT, CMD_GREETING, CMD_GREETING2, CMD_GREETING3,
	CMD_PROVOKE, CMD_PROVOKE2, CMD_PROVOKE3, CMD_GAME_SAVE, CMD_RECOMMEND, CMD_INDIVIDUAL_BATTLE,
#if 0 // unused officially -- they exist, but aren't loaded (& they're Korean in our data)
	CMDSIT_STAND, CMD_WALK_RUN, CMD_LOCATION,
#endif
	
	// Trade
	CMD_TRADE, CMD_FORBIDTRADE, CMD_PERMITTRADE, CMD_MERCHANT,

	// Party
	CMD_PARTY, CMD_LEAVEPARTY, CMD_RECRUITPARTY, CMD_FORBIDPARTY, CMD_PERMITPARTY,

	// Clan
	CMD_JOINCLAN, CMD_WITHDRAWCLAN, CMD_FIRECLAN, CMD_COMMAND, CMD_CLAN_WAR,
	CMD_SURRENDER, CMD_APPOINTVICECHIEF, CMD_CLAN_CHAT, CMD_CLAN_BATTLE,

	// Knights
	CMD_CONFEDERACY, CMD_BAN_KNIGHTS, CMD_QUIT_KNIGHTS, CMD_BASE, CMD_DECLARATION,

	// GM
	CMD_VISIBLE, CMD_INVISIBLE, CMD_CLEAN, CMD_RAINING, CMD_SNOWING, CMD_TIME, CMD_CU_COUNT,
	CMD_NOTICE, CMD_ARREST, CMD_FORBIDCONNECT, CMD_FORBIDCHAT, CMD_PERMITCHAT, CMD_NOTICEALL,
	CMD_CUTOFF, CMD_VIEW, CMD_UNVIEW, CMD_FORBIDUSER, CMD_SUMMONUSER,
	CMD_ATTACKDISABLE, CMD_ATTACKENABLE, CMD_PLC,

	// Guardian Monster
	CMD_HIDE, CMD_GUARD, CMD_DEFEND, CMD_LOOK_OUT, CMD_STRATEGIC_FORMATION, CMD_REST, CMD_DESTROY,

	// King
	CMD_ROYALORDER, CMD_PRIZE, CMD_EXPERIENCEPOINT, CMD_DROPRATE, CMD_RAIN, CMD_SNOW, CMD_CLEAR, CMD_REWARD,

	CMD_COUNT,
	CMD_UNKNOWN = 0xffffffff
};

class CUICmdEdit;
class CUICmdList : public CN3UIBase
{
protected:
	enum e_CmdListSelection : uint8_t
	{
		CMD_LIST_SEL_CATEGORY = 0,	// Category list
		CMD_LIST_SEL_COMMAND		// Command list
	};

	enum e_CmdListCategory : uint8_t
	{
		CMD_LIST_CAT_PRIVATE = 0,
		CMD_LIST_CAT_TRADE,
		CMD_LIST_CAT_PARTY,
		CMD_LIST_CAT_CLAN,
		CMD_LIST_CAT_KNIGHTS,
		CMD_LIST_CAT_GUARDIAN,
		CMD_LIST_CAT_KING,
		CMD_LIST_CAT_GM,
		CMD_LIST_CAT_COUNT
	};

	CUICmdEdit*			m_pUICmdEdit;

	CN3UIButton*		m_pBtn_Cancel;
	CN3UIList*			m_pList_CmdCat;
	CN3UIList*			m_pList_Cmds;

	bool				m_bOpenningNow;		// 열리고 있다..
	bool				m_bClosingNow;		// 닫히고 있다..
	float				m_fMoveDelta;		// 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..
	int					m_iSelectedCategory;
	e_CmdListSelection	m_eSelectedList;

	struct CommandInfo
	{
		uint32_t			ResourceID;
		e_ChatCmd			Command;
	};

	std::multimap<e_CmdListCategory, CommandInfo>		m_categoryToCommandInfoMap;

public:
	CUICmdList();
	~CUICmdList() override;
	bool Load(File& file) override;
	void Release() override;
	void SetVisible(bool bVisible) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override; // 메시지를 받는다.. 보낸놈, msg
	bool OnKeyPress(int iKey) override;
	void Open();
	void Close();
	bool CreateCategoryList();
	bool UpdateCommandList(int iCatIndex);
	void AppendToCommandMap(e_CmdListCategory eCategory, e_ChatCmd eBaseCmd, int iFirstResourceID, int iLastResourceID);
	bool ExecuteCommand(int iCmdIndex);
	void Tick() override;
	void Render() override;
	void RenderSelectionBorder(CN3UIList* pListToRender);
	bool OnMouseWheelEvent(short delta) override;
};

#endif // !defined(AFX_UICmdList)




// ===== END WarFare/UICmdList.h =====

// ===== BEGIN WarFare/UICreateClanName.cpp =====
#line 1 "WarFare/UICreateClanName.cpp"
﻿// UICreateClanName.cpp: implementation of the UINPCEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UICreateClanName.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "PacketDef.h"
#include "text_resources.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUICreateClanName::CUICreateClanName()
{
}

CUICreateClanName::~CUICreateClanName()
{
}

bool CUICreateClanName::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;
	
	N3_VERIFY_UI_COMPONENT(m_pText_Title,		GetChildByID<CN3UIString>("Text_Message"));
	N3_VERIFY_UI_COMPONENT(m_pEdit_ClanName,	GetChildByID<CN3UIEdit>("Edit_Clan"));

	return true;
}

bool CUICreateClanName::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "btn_yes")	
		{
			m_szClanName = m_pEdit_ClanName->GetString();
			if (!MakeClan())
				return true;

			SetVisible(false);
			return true;
		}

		if(pSender->m_szID == "btn_no")	
		{
			SetVisible(false);
			return true;
		}
	}
	return true;
}

bool CUICreateClanName::MakeClan()
{
	if (m_szClanName.empty())
		return false;

	if (m_szClanName.size() > 20)
		m_szClanName.resize(20);

	std::string szMsg = fmt::format_text_resource(IDS_CLAN_WARNING_COST, CLAN_COST);
	CGameProcedure::s_pProcMain->MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_KNIGHTS_CREATE);
	return true;
}

void CUICreateClanName::MsgSend_MakeClan() const
{
	int iLn = static_cast<int>(m_szClanName.size());
	uint8_t byBuff[40];	// 패킷 버퍼..									
	int iOffset = 0;	// 패킷 오프셋..									
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_CREATE);
	CAPISocket::MP_AddShort(byBuff, iOffset, static_cast<int16_t>(iLn));
	CAPISocket::MP_AddString(byBuff, iOffset, m_szClanName);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUICreateClanName::Open(int msg)
{
	if (msg != 0)
	{
		std::string szMsg = fmt::format_text_resource(msg);
		m_pText_Title->SetString(szMsg);
	}

	m_pEdit_ClanName->SetString("");
	m_pEdit_ClanName->SetFocus();
	SetVisible(true);
}

void CUICreateClanName::SetVisible(bool bVisible)
{
	if (bVisible == IsVisible())
		return;

	if (!bVisible)
		m_pEdit_ClanName->KillFocus();

	CN3UIBase::SetVisible(bVisible);
}

// ===== END WarFare/UICreateClanName.cpp =====

// ===== BEGIN WarFare/UICreateClanName.h =====
#line 1 "WarFare/UICreateClanName.h"
﻿// UICreateClanName.h: interface for the UICreateClanName class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__UICREATECLANNAME_H__)
#define __UICREATECLANNAME_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUICreateClanName : public CN3UIBase  
{
public:
	CN3UIString*	m_pText_Title;
	CN3UIEdit*		m_pEdit_ClanName;
	std::string		m_szClanName;

public:
	CUICreateClanName();
	~CUICreateClanName() override;
	bool Load(File& file) override;
	void SetVisible(bool bVisible) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Open(int msg = 0);
	bool MakeClan();
	void MsgSend_MakeClan() const;
};

#endif //#if !defined(__UICREATECLANNAME_H__)

// ===== END WarFare/UICreateClanName.h =====

// ===== BEGIN WarFare/UIDead.cpp =====
#line 1 "WarFare/UIDead.cpp"
﻿// UIDead.cpp: implementation of the CUIDead class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIDead.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "GameProcedure.h"
#include "GameProcMain.h"
#include "UIManager.h"
#include "PlayerMySelf.h"
#include "UIInventory.h"
#include "UIStateBar.h"
#include "MagicSkillMng.h"
#include "N3FXMgr.h"
#include "text_resources.h"

#include <N3Base/N3UITooltip.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

#define CHILD_UI_REVIVE_MSG				1
#define CHILD_UI_LACK_LIVE_STONE_MSG	2
#define CHILD_UI_LOW_LEVEL				3

#define TIMES_LIFE_STONE				3
#define LIFE_STONE_INDEX				379006000

#define REVIVAL_TYPE_RETURN_TOWN		1
#define REVIVAL_TYPE_LIFE_STONE			2
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIDead::CUIDead()
{
	m_pTextAlive	= nullptr;
	m_pTextTown		= nullptr;
	m_bProcessing	= false;
}

CUIDead::~CUIDead()
{
}

bool CUIDead::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pTextAlive,	GetChildByID<CN3UIString>("Text_Alive"));
	N3_VERIFY_UI_COMPONENT(m_pTextTown,		GetChildByID<CN3UIString>("Text_Town"));

	std::string szMsg = fmt::format_text_resource(IDS_DEAD_REVIVAL);
	if (m_pTextAlive != nullptr)
		m_pTextAlive->SetString(szMsg);

	szMsg = fmt::format_text_resource(IDS_DEAD_RETURN_TOWN);
	if (m_pTextTown != nullptr)
		m_pTextTown->SetString(szMsg);

	__TABLE_UI_RESRC* pTblUI = CGameBase::s_pTbl_UI.Find(NATION_ELMORAD);
	m_MsgBox.LoadFromFile(pTblUI->szMessageBox);

	RECT rt = m_MsgBox.GetRegion();
	POINT pt;
	pt.x = (CN3Base::s_CameraData.vp.Width - (rt.right - rt.left)) / 2;
	pt.y = (CN3Base::s_CameraData.vp.Height - (rt.bottom - rt.top)) / 2;
	m_MsgBox.SetPos(pt.x, pt.y);

	return true;
}

bool CUIDead::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_STRING_LCLICK)
	{
		if (pSender == m_pTextAlive)
		{
			int iItemCnt = 0, iLevel = 0, iNeedItemCnt = 0;
			if (CGameProcedure::s_pProcMain->m_pUIInventory != nullptr)
				iItemCnt = CGameProcedure::s_pProcMain->m_pUIInventory->GetIndexItemCount(LIFE_STONE_INDEX);

			iLevel = CGameBase::s_pPlayer->m_InfoBase.iLevel;
			iNeedItemCnt = iLevel * TIMES_LIFE_STONE;
			std::string szMsg;

			if (iLevel < 6)
			{
				szMsg = fmt::format_text_resource(IDS_DEAD_LOW_LEVEL, iNeedItemCnt);

				m_MsgBox.SetBoxStyle(MB_OK);
				m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
				m_MsgBox.SetTitle("");
				m_MsgBox.SetText(szMsg);
				m_MsgBox.ShowWindow(CHILD_UI_LOW_LEVEL, this);
			}
			else if (iItemCnt >= iNeedItemCnt)
			{
				szMsg = fmt::format_text_resource(IDS_DEAD_REVIVAL_MESSAGE, iNeedItemCnt);

				m_MsgBox.SetBoxStyle(MB_YESNO);
				m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
				m_MsgBox.SetTitle("");
				m_MsgBox.SetText(szMsg);
				m_MsgBox.ShowWindow(CHILD_UI_REVIVE_MSG, this);
			}
			else
			{
				szMsg = fmt::format_text_resource(IDS_DEAD_LACK_LIFE_STONE);

				m_MsgBox.SetBoxStyle(MB_OK);
				m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
				m_MsgBox.SetTitle("");
				m_MsgBox.SetText(szMsg);
				m_MsgBox.ShowWindow(CHILD_UI_LACK_LIVE_STONE_MSG, this);
			}
		}
		else if (pSender == m_pTextTown)
		{
			MsgSend_Revival(REVIVAL_TYPE_RETURN_TOWN);
		}
	}

	return true;
}

uint32_t CUIDead::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible)
		return dwRet;

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE == m_eState)
	{
		if (dwFlags & UI_MOUSE_LBCLICKED)
			SetState(UI_STATE_COMMON_NONE);
		else
			MoveOffset(ptCur.x - ptOld.x, ptCur.y - ptOld.y);

		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	// 영역 밖이면
	if (!IsIn(ptCur.x, ptCur.y))
	{
		// 이전 좌표도 영역 밖이면 
		if (!IsIn(ptOld.x, ptOld.y))
			return dwRet;

		dwRet |= UI_MOUSEPROC_PREVINREGION;	// 이전 좌표는 영역 안이었다.
	}
	else
	{
		// tool tip 관련
		if (s_pTooltipCtrl != nullptr)
			s_pTooltipCtrl->SetText(m_szToolTip, m_crToolTip);
	}

	dwRet |= UI_MOUSEPROC_INREGION;	// 이번 좌표는 영역 안이다.

	if (m_pChildUI != nullptr && m_pChildUI->IsVisible())
		return dwRet;

	// child에게 메세지 전달
	for (UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		uint32_t dwChildRet = 0;

		dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (pChild->IsVisible() && UI_TYPE_STRING == pChild->UIType())
		{
			if (pChild->IsIn(ptCur.x, ptCur.y) && (dwFlags & UI_MOUSE_LBCLICKED))
				dwChildRet |= UI_MOUSEPROC_DONESOMETHING;

			if (pChild->IsIn(ptCur.x, ptCur.y) && (dwFlags & UI_MOUSE_LBDBLCLK))
				dwChildRet |= UI_MOUSEPROC_DONESOMETHING;
		}

		// 이경우에는 먼가 포커스를 받은 경우이다.
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{
			// (아래 코드는 dialog를 관리하는 곳에서 해야 한다. 따라서 막아놓음)
//			m_Children.erase(itor);			// 우선 리스트에서 지우고
//			m_Children.push_front(pChild);	// 맨앞에 넣는다. 그리는 순서를 맨 나중에 그리도록 하려고

			dwRet |= (UI_MOUSEPROC_CHILDDONESOMETHING | UI_MOUSEPROC_DONESOMETHING);
			return dwRet;
		}
	}

	// UI 움직이는 코드
	if (UI_STATE_COMMON_MOVE != m_eState
		&& PtInRect(&m_rcMovable, ptCur)
		&& (dwFlags & UI_MOUSE_LBCLICK))
	{
		SetState(UI_STATE_COMMON_MOVE);
		dwRet |= UI_MOUSEPROC_DONESOMETHING;
		return dwRet;
	}

	return dwRet;
}

void CUIDead::CallBackProc(int iID, uint32_t dwFlag)
{
	//TRACE("OnButton ID:%d Btn %d\n",iID, dwFlag);

	if (iID == CHILD_UI_REVIVE_MSG)
	{
		// OK
		if (dwFlag == 1)
			MsgSend_Revival(REVIVAL_TYPE_LIFE_STONE);
	}
	else if (iID == CHILD_UI_LACK_LIVE_STONE_MSG)
	{
	}
	else if (iID == CHILD_UI_LOW_LEVEL)
	{
	}
}

void CUIDead::MsgSend_Revival(uint8_t byType)
{
	if (m_bProcessing)
		return;

	// 한번 보내면 다시 죽을때까지 안보내는 플래그
	if (CGameBase::s_pPlayer->m_iSendRegeneration >= 2)
		return;

	uint8_t byBuff[4];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_REGENE);
	CAPISocket::MP_AddByte(byBuff, iOffset, byType);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..

	CLogWriter::Write("Send Regeneration");
	CGameBase::s_pPlayer->m_iSendRegeneration = 2; // 한번 보내면 다시 죽을때까지 안보내는 플래그
	//TRACE("보냄 - 다시 살아나기\n");

	m_bProcessing = true;
}

void CUIDead::MsgRecv_Revival(Packet& pkt)
{
	m_bProcessing = false;

	__Vector3 vPosPlayer;
	vPosPlayer.x = static_cast<float>(pkt.read<uint16_t>()) / 10.0f;
	vPosPlayer.z = static_cast<float>(pkt.read<uint16_t>()) / 10.0f;
	vPosPlayer.y = static_cast<float>(pkt.read<int16_t>()) / 10.0f;

	// 플레이어 위치 초기화.. 일으켜 세우고, 기본동작을 취하게 한다.
	CGameProcedure::s_pProcMain->InitPlayerPosition(vPosPlayer);

	// 충돌 메시를 다시 만든다..
	CGameBase::s_pPlayer->RegenerateCollisionMesh();

	// 한번 보내면 다시 죽을때까지 안보내는 플래그
	CGameBase::s_pPlayer->m_iSendRegeneration = 0;

	// 한번 보내면 다시 죽을때까지 안보내는 플래그
	CGameBase::s_pPlayer->m_fTimeAfterDeath = 0;

	// TRACE("받음 - 다시 살아나기(%.1f, %.1f)\n", vPosPlayer.x, vPosPlayer.z);

	// 마법 & 효과 초기화..
	if (CGameProcedure::s_pProcMain->m_pUIStateBarAndMiniMap != nullptr)
		CGameProcedure::s_pProcMain->m_pUIStateBarAndMiniMap->ClearMagic();

	if (CGameProcedure::s_pProcMain->m_pMagicSkillMng != nullptr)
		CGameProcedure::s_pProcMain->m_pMagicSkillMng->ClearDurationalMagic();

	if (CGameProcedure::s_pFX != nullptr)
		CGameProcedure::s_pFX->StopMine();

	CLogWriter::Write("Receive Regeneration");

	int iID = CGameBase::s_pPlayer->IDNumber();
	if (CGameBase::s_pPlayer->Nation() == NATION_KARUS)
		CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_REGEN_KARUS, iID, -1);
	else if (CGameBase::s_pPlayer->Nation() == NATION_ELMORAD)
		CGameProcedure::s_pFX->TriggerBundle(iID, -1, FXID_REGEN_ELMORAD, iID, -1);

	SetVisible(false);
}

void CUIDead::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CUIDead::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	if (!bWork)
		CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);
}

// ===== END WarFare/UIDead.cpp =====

// ===== BEGIN WarFare/UIDead.h =====
#line 1 "WarFare/UIDead.h"
﻿// UIDead.h: interface for the CUIDead class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIDEAD_H__B5FAFAB6_04A4_4708_945E_731AE35257EB__INCLUDED_)
#define AFX_UIDEAD_H__B5FAFAB6_04A4_4708_945E_731AE35257EB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include "UIMessageBox.h"

class CUIDead : public CN3UIBase
{
protected:
	class CN3UIString*		m_pTextAlive;
	class CN3UIString*		m_pTextTown;
	CUIMessageBox			m_MsgBox;
	bool					m_bProcessing;

public:
	CUIDead();
	~CUIDead() override;
	void SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	void SetVisible(bool bVisible) override;
	void MsgRecv_Revival(Packet& pkt);
	void MsgSend_Revival(uint8_t byType);
	void CallBackProc(int iID, uint32_t dwFlag) override;
	uint32_t MouseProc(uint32_t dwFlags, const POINT &ptCur, const POINT &ptOld) override;
	bool ReceiveMessage(CN3UIBase *pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;
};

#endif // !defined(AFX_UIDEAD_H__B5FAFAB6_04A4_4708_945E_731AE35257EB__INCLUDED_)

// ===== END WarFare/UIDead.h =====

// ===== BEGIN WarFare/UIDroppedItemDlg.cpp =====
#line 1 "WarFare/UIDroppedItemDlg.cpp"
﻿// UIDroppedItemDlg.cpp: implementation of the UIDroppedItemDlg class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "UIDroppedItemDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "PlayerMyself.h"
#include "N3UIWndBase.h"
#include "UIImageTooltipDlg.h"
#include "UIInventory.h"
#include "UITransactionDlg.h"
#include "SubProcPerTrade.h"
#include "PlayerOtherMgr.h"
#include "PlayerNPC.h"
#include "UIHotKeyDlg.h"
#include "UISkillTreeDlg.h"
#include "text_resources.h"

#include <N3Base/N3UIArea.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIDroppedItemDlg::CUIDroppedItemDlg()
{
	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		m_pMyDroppedItem[i] = nullptr;
		m_bSendedIconArray[i] = false;
	}

	m_iItemBundleID = 0;
	m_pUITooltipDlg = nullptr;
	m_iBackupiOrder = 0;
}

CUIDroppedItemDlg::~CUIDroppedItemDlg()
{
	Release();
}

void CUIDroppedItemDlg::Release()
{
	CN3UIWndBase::Release();

	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		delete m_pMyDroppedItem[i];
		m_pMyDroppedItem[i] = nullptr;
	}
}

void CUIDroppedItemDlg::Render()
{
	// 보이지 않으면 자식들을 render하지 않는다.
	if (!m_bVisible)
		return;

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	m_pUITooltipDlg->DisplayTooltipsDisable();

	bool bTooltipRender = false;
	__IconItemSkill* spItem = nullptr;

	for (UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		pChild->Render();

		if (pChild->UIType() == UI_TYPE_ICON
			&& (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT))
		{
			bTooltipRender = true;
			spItem = GetHighlightIconItem((CN3UIIcon*) pChild);
		}
	}

	if (bTooltipRender)
		m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem);

	// 갯수 표시되야 할 아이템 갯수 표시..
	CN3UIString* pStr = nullptr;
	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		if (m_pMyDroppedItem[i] != nullptr
			&& ((m_pMyDroppedItem[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE)
			|| (m_pMyDroppedItem[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)))
		{
			// string 얻기..
			pStr = GetChildStringByiOrder(i);
			if (pStr != nullptr)
			{
				if (GetState() == UI_STATE_ICON_MOVING
					&& m_pMyDroppedItem[i] == s_sSelectedIconInfo.pItemSelect)
				{
					pStr->SetVisible(false);
				}
				else if (m_pMyDroppedItem[i]->pUIIcon->IsVisible())
				{
					pStr->SetVisible(true);
					pStr->SetStringAsInt(m_pMyDroppedItem[i]->iCount);
					pStr->Render();
				}
				else
				{
					pStr->SetVisible(false);
				}
			}
		}
		else
		{
			// string 얻기..
			pStr = GetChildStringByiOrder(i);
			if (pStr != nullptr)
				pStr->SetVisible(false);
		}
	}
}

void CUIDroppedItemDlg::InitIconWnd(e_UIWND eWnd)
{
	__TABLE_UI_RESRC* pTblUI = CGameBase::s_pTbl_UI.Find(CGameBase::s_pPlayer->m_InfoBase.eNation);

	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(pTblUI->szItemInfo);
	m_pUITooltipDlg->InitPos();
	m_pUITooltipDlg->SetVisible(false);

	CN3UIWndBase::InitIconWnd(eWnd);
}

void CUIDroppedItemDlg::InitIconUpdate()
{
	float fUVAspect = 45.0f / 64.0f;

	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		if (m_pMyDroppedItem[i] != nullptr)
		{
			m_pMyDroppedItem[i]->pUIIcon = new CN3UIIcon();
			m_pMyDroppedItem[i]->pUIIcon->Init(this);
			m_pMyDroppedItem[i]->pUIIcon->SetTex(m_pMyDroppedItem[i]->szIconFN);
			m_pMyDroppedItem[i]->pUIIcon->SetUVRect(0, 0, fUVAspect, fUVAspect);
			m_pMyDroppedItem[i]->pUIIcon->SetUIType(UI_TYPE_ICON);
			m_pMyDroppedItem[i]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM | UISTYLE_ICON_CERTIFICATION_NEED);

			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_DROP_ITEM, i);
			if (pArea != nullptr)
			{
				m_pMyDroppedItem[i]->pUIIcon->SetRegion(pArea->GetRegion());
				m_pMyDroppedItem[i]->pUIIcon->SetMoveRect(pArea->GetRegion());
			}
		}
	}
}

__IconItemSkill* CUIDroppedItemDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		if (m_pMyDroppedItem[i] != nullptr
			&& m_pMyDroppedItem[i]->pUIIcon == pUIIcon)
			return m_pMyDroppedItem[i];
	}

	return nullptr;
}

void CUIDroppedItemDlg::EnterDroppedState(int xpos, int ypos)
{
	if (!IsVisible())
		SetVisible(true);

	SetPos(xpos, ypos - 150);

	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		m_bSendedIconArray[i] = false;

		if (m_pMyDroppedItem[i] != nullptr)
		{
			if (m_pMyDroppedItem[i]->pUIIcon)
			{
				RemoveChild(m_pMyDroppedItem[i]->pUIIcon);
				m_pMyDroppedItem[i]->pUIIcon->Release();
				delete m_pMyDroppedItem[i]->pUIIcon;
				m_pMyDroppedItem[i]->pUIIcon = nullptr;
			}

			delete m_pMyDroppedItem[i];
			m_pMyDroppedItem[i] = nullptr;
		}
	}

	AllHighLightIconFree();
}

void CUIDroppedItemDlg::LeaveDroppedState()
{
	if (IsVisible())
		SetVisible(false);

	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
		m_bSendedIconArray[i] = false;
}

uint32_t CUIDroppedItemDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!IsVisible())
		return dwRet;

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
	return dwRet;
}

void CUIDroppedItemDlg::AddToItemTable(int iItemID, int iItemCount, int iOrder)
{
	__IconItemSkill* spItem = nullptr;
	__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..
	std::string szIconFN;

	pItem = CGameBase::s_pTbl_Items_Basic.Find(iItemID / 1000 * 1000);	// 열 데이터 얻기..
	if (pItem != nullptr
		&& pItem->byExtIndex >= 0
		&& pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemID % 1000);
	if (pItem == nullptr || pItemExt == nullptr)
	{
		__ASSERT(0, "아이템 포인터 테이블에 없음!!");
		CLogWriter::Write("CUIDroppedItemDlg::AddToItemTable - Invalidate ItemID : {}", iItemID);
		return;
	}

	//TRACE("Dropped item from server to ItemDlg %d \n", iItemID);
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	// 아이템에 따른 파일 이름을 만들어서
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, RACE_UNKNOWN);
	if (ITEM_TYPE_UNKNOWN == eType)
		return;

	spItem = new __IconItemSkill();
	spItem->pItemBasic	= pItem;
	spItem->pItemExt	= pItemExt;
	spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
	spItem->iCount		= iItemCount;
	spItem->iDurability	= pItem->siMaxDurability + pItemExt->siMaxDurability;

	m_pMyDroppedItem[iOrder] = spItem;
}

void CUIDroppedItemDlg::AddToItemTableToInventory(int iItemID, int iItemCount, int iOrder)
{
	__IconItemSkill* spItem = nullptr;
	// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_BASIC* pItem = nullptr;
	// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_EXT* pItemExt = nullptr;
	std::string szIconFN;
	float fUVAspect = 45.0f / 64.0f;

	pItem = CGameBase::s_pTbl_Items_Basic.Find(iItemID / 1000 * 1000);	// 열 데이터 얻기..
	if (pItem != nullptr
		&& pItem->byExtIndex >= 0
		&& pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemID % 1000);

	if (pItem == nullptr || pItemExt == nullptr)
	{
		__ASSERT(0, "아이템 포인터 테이블에 없음!!");
		CLogWriter::Write("CUIDroppedItemDlg::AddToItemTableToInventory - Invalidate ItemID : {}", iItemID);
		return;
	}

	//TRACE("Dropped item from server to ItemDlg %d \n", iItemID);
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	// 아이템에 따른 파일 이름을 만들어서
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug);
	if (ITEM_TYPE_UNKNOWN == eType)
		return;

	spItem = new __IconItemSkill();
	spItem->pItemBasic	= pItem;
	spItem->pItemExt	= pItemExt;
	spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
	spItem->iCount		= iItemCount;
	spItem->iDurability	= pItem->siMaxDurability + pItemExt->siMaxDurability;
	spItem->pUIIcon		= new CN3UIIcon();

	spItem->pUIIcon->Init(CGameProcedure::s_pProcMain->m_pUIInventory);
	spItem->pUIIcon->SetTex(spItem->szIconFN);
	spItem->pUIIcon->SetUVRect(0, 0, fUVAspect, fUVAspect);
	spItem->pUIIcon->SetUIType(UI_TYPE_ICON);
	spItem->pUIIcon->SetStyle(UISTYLE_ICON_ITEM | UISTYLE_ICON_CERTIFICATION_NEED);
	spItem->pUIIcon->SetVisible(true);

	CN3UIArea* pArea = CGameProcedure::s_pProcMain->m_pUIInventory->GetChildAreaByiOrder(UI_AREA_TYPE_INV, iOrder);
	if (pArea != nullptr)
	{
		spItem->pUIIcon->SetRegion(pArea->GetRegion());
		spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iOrder] = spItem;
	PlayItemSound(pItem);
}

bool CUIDroppedItemDlg::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
	CN3UIArea* pArea = nullptr;

	if (!m_bVisible)
		return false;

	// 검사해서 선택된 아이콘을 가진 윈도우에게 결과를 알려줘야 한다..
	switch (s_sSelectedIconInfo.UIWndSelect.UIWnd)
	{
		// 인벤토리 윈도우로부터 온 것이라면..
		case UIWND_INVENTORY:
			CGameProcedure::s_pProcMain->m_pUIInventory->CancelIconDrop(spItem);
			break;

		// 상거래 윈도우로부터 온 것이라면...
		case UIWND_TRANSACTION:
			CGameProcedure::s_pProcMain->m_pUITransactionDlg->CancelIconDrop(spItem);
			break;
	}

	return false;
}

int CUIDroppedItemDlg::GetInventoryEmptyInviOrder(__IconItemSkill* spItem)
{
	if (spItem == nullptr)
	{
		for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		{
			__IconItemSkill* spItemInv = CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[i];
			if (spItemInv == nullptr)
				return i;
		}
	}
	else
	{
		for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		{
			__IconItemSkill* spItemInv = CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[i];
			if (spItemInv != nullptr
				&& spItemInv->pItemBasic->dwID == spItem->pItemBasic->dwID)
				return i;
		}

		for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		{
			__IconItemSkill* spItemInv = CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[i];
			if (spItemInv == nullptr)
				return i;
		}
	}

	return -1;
}

int	CUIDroppedItemDlg::GetItemiOrder(__IconItemSkill* spItem)
{
	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		if (m_pMyDroppedItem[i] != nullptr
			&& m_pMyDroppedItem[i] == spItem)
			return i;
	}

	return -1;
}

bool CUIDroppedItemDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
// Temp Define
#define FAIL_CODE {		\
				s_sSelectedIconInfo.eIconSelectState = UIICON_SELECT_NONE;	\
				return false;	\
			}

// Code Begin
	if (pSender == nullptr)
		return false;

	int iOrder, iOrderInv = -1;

	uint32_t dwBitMask = 0x000f0000;

	__TABLE_ITEM_BASIC* pItem = nullptr;
	__IconItemSkill* spItem = nullptr;
	std::string szIconFN;
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType;

	// 서버에 보내지 않은 아이템이니까.. 서버에 보낸다..
	uint8_t byBuff[16];
	int iOffset = 0;

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_DOWN_FIRST:
			spItem = GetHighlightIconItem((CN3UIIcon*) pSender);
			if (spItem == nullptr)
				break;

			m_iBackupiOrder = GetItemiOrder(spItem);
			break;

		case UIMSG_ICON_UP:
			SetState(UI_STATE_COMMON_NONE);

			// 아이템이 돈인지 검사..
			pItem = nullptr;								// 아이템 테이블 구조체 포인터..
			spItem = GetHighlightIconItem((CN3UIIcon*) pSender);
			if (spItem == nullptr)
				break;

			pItem = CGameBase::s_pTbl_Items_Basic.Find(spItem->pItemBasic->dwID);	// 열 데이터 얻기..
			if (pItem == nullptr)
			{
				__ASSERT(0, "NULL Item!!!");
				CLogWriter::Write("CUIDroppedItemDlg::ReceiveMessage - UIMSG_ICON_UP - NULL Icon : {}", spItem->pItemBasic->dwID);
				break;
			}

			// 아이템에 따른 파일 이름을 만들어서
			eType = CGameBase::MakeResrcFileNameForUPC(pItem, spItem->pItemExt, nullptr, &szIconFN, ePart, ePlug);

			// 보낸 아이콘 배열이랑 비교.. 
			iOrder = GetItemiOrder(spItem);
			if (m_iBackupiOrder != iOrder)
				break;

			// 한번 보냈던 패킷이면 break.. 
			if (m_bSendedIconArray[iOrder])
				break;

			m_bSendedIconArray[iOrder] = true;

			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_GET);
			CAPISocket::MP_AddDword(byBuff, iOffset, m_iItemBundleID);

			// 돈이 아니면 인벤토리 리스트에 추가.... 
			if (ITEM_TYPE_GOLD != eType)
				CAPISocket::MP_AddDword(byBuff, iOffset, spItem->pItemBasic->dwID + spItem->pItemExt->dwID);
			else
				CAPISocket::MP_AddDword(byBuff, iOffset, spItem->pItemBasic->dwID);

			CGameProcedure::s_pSocket->Send(byBuff, iOffset);

			// 보낸 아이콘 정보 셋팅..	
			s_sRecoveryJobInfo.pItemSource						= spItem;
			s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= UIWND_DROPITEM;
			s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict	= UIWND_DISTRICT_DROPITEM;
			s_sRecoveryJobInfo.UIWndSourceStart.iOrder			= iOrder;
			s_sRecoveryJobInfo.UIWndSourceEnd.UIWnd				= UIWND_INVENTORY;
			s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict		= UIWND_DISTRICT_INVENTORY_INV;
			s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iOrderInv;
			break;

		case UIMSG_ICON_DOWN:
			break;

		case UIMSG_ICON_DBLCLK:
			SetState(UI_STATE_COMMON_NONE);
			break;
	}

	return true;
}

void CUIDroppedItemDlg::GetItemByIDToInventory(
	uint8_t bResult, int iItemID, int iGold, int iPos, int iItemCount, int iStrLen, const std::string& characterName)
{
	// 아이템 리스트에서 아이템을 찾고..
	bool bFound = false;
	// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_BASIC* pItem = nullptr;
	__TABLE_ITEM_EXT* pItemExt = nullptr;
	__IconItemSkill* spItem = nullptr;
	int i;
	CN3UIString* pStatic = nullptr;
	__InfoPlayerMySelf* pInfoExt = nullptr;
	std::string stdMsg;

	// 실패..
	if (bResult == 0)
	{
		int iOrderInv = GetInventoryEmptyInviOrder();
		if (iOrderInv == -1)
		{
			// 인벤토리가 꽉 차있으면.. break.. ^^
			stdMsg = fmt::format_text_resource(IDS_INV_ITEM_FULL);
			CGameProcedure::s_pProcMain->MsgOutput(stdMsg, 0xff9b9bff);
		}

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();

		return;
	}

	// 파티 상태에서 노아를 얻는다..
	if (bResult == 2)
	{
		// 돈 갱신..
		pStatic = nullptr;
		pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

		// 돈 업데이트..
		stdMsg = fmt::format_text_resource(IDS_DROPPED_NOAH_GET, iGold - pInfoExt->iGold);
		CGameProcedure::s_pProcMain->MsgOutput(stdMsg, 0xff9b9bff);

		pInfoExt->iGold = iGold;
		CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

		if (!IsVisible())
			return;

		// 돈 아이콘이 있으면 없앤다..
		bFound = false;
		for (i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
		{
			if (m_pMyDroppedItem[i] != nullptr
				&& m_pMyDroppedItem[i]->pItemBasic->dwID == dwGold)
			{
				bFound = true;
				break;
			}
		}

		if (!bFound)
			return;

		spItem = m_pMyDroppedItem[i];
		if (spItem == nullptr)
			return;

		// 매니저에서 제거..
		RemoveChild(spItem->pUIIcon);

		// 리소스 제거..
		spItem->pUIIcon->Release();
		delete spItem->pUIIcon;
		spItem->pUIIcon = nullptr;
		delete spItem;
		spItem = nullptr;
		m_pMyDroppedItem[i] = nullptr;

		PlayGoldSound();

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
	}

	// 파티상태에서 내가 아이템을 습득..
	if (bResult == 3)
	{
		pItem = CGameBase::s_pTbl_Items_Basic.Find(iItemID / 1000 * 1000);	// 열 데이터 얻기..
		pItemExt = nullptr;

		if (pItem != nullptr
			&& pItem->byExtIndex >= 0
			&& pItem->byExtIndex < MAX_ITEM_EXTENSION)
			pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItemID % 1000);

		if (pItem == nullptr || pItemExt == nullptr)
		{
			__ASSERT(0, "아이템 포인터 테이블에 없음!!");
			CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - NULL Icon : {}", iItemID);
			return;
		}

		std::string szMsg = fmt::format_text_resource(IDS_PARTY_ITEM_GET,
			characterName, pItem->szName);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xff9b9bff);

		if (!IsVisible())
			return;

		// 아이템 아이콘이 있으면 없앤다..
		bFound = false;
		for (i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
		{
			if (m_pMyDroppedItem[i] != nullptr
				&& (m_pMyDroppedItem[i]->pItemBasic->dwID + m_pMyDroppedItem[i]->pItemExt->dwID == iItemID))
			{
				bFound = true;
				break;
			}
		}

		if (!bFound)
			return;

		if (m_pMyDroppedItem[i] != nullptr)
			PlayItemSound(m_pMyDroppedItem[i]->pItemBasic);

		spItem = m_pMyDroppedItem[i];
		if (spItem == nullptr)
			return;

		// 매니저에서 제거..
		RemoveChild(spItem->pUIIcon);

		// 리소스 제거..
		spItem->pUIIcon->Release();
		delete spItem->pUIIcon;
		spItem->pUIIcon = nullptr;
		delete spItem;
		spItem = nullptr;
		m_pMyDroppedItem[i] = nullptr;

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();

		return;
	}

	// 파티 상태에서 다른 멤버가 아이템을 습득..
	if (bResult == 4)
	{
		spItem = m_pMyDroppedItem[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
		if (spItem != nullptr)
		{
			// 매니저에서 제거..
			RemoveChild(spItem->pUIIcon);

			// 리소스 제거..
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
		}

		m_pMyDroppedItem[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();

		return;
	}

	// 파티 상태에서 일반적인 아이템 습득..
	if (bResult == 5)
	{
		if (iItemID == dwGold)
		{
			__ASSERT(0, "Invalidate Item ID From Server.. ");
			CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - ID Pos : {}", iPos);
			return;
		}

		if (iPos < 0
			|| iPos >= MAX_ITEM_INVENTORY)
		{
			__ASSERT(0, "Invalidate Item Pos From Server.. ");
			CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - Invalidate Pos : {}", iPos);
			return;
		}

		__IconItemSkill* spItemDest = CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos];

		// 아이템이 있다..
		if (spItemDest != nullptr)
		{
			if (iItemID != (spItemDest->pItemBasic->dwID + spItemDest->pItemExt->dwID))
			{
				// 기존 이이템을 클리어..
				if (spItemDest == nullptr)
					return;

				RemoveChild(spItemDest->pUIIcon);

				// 아이콘 리소스 삭제...
				spItemDest->pUIIcon->Release();
				delete spItemDest->pUIIcon;
				spItemDest->pUIIcon = nullptr;
				delete spItemDest;
				spItemDest = nullptr;

				CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos] = nullptr;

				//  아이템을 새로 만듬.. 갯수 셋팅..
				AddToItemTableToInventory(iItemID, iItemCount, iPos);
			}
			else
			{
				// 갯수 셋팅..
				CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos]->iCount = iItemCount;
				PlayItemSound(CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos]->pItemBasic);
			}
		}
		else
		{
			// 아이템이 없는 경우 .. 새로 만든다.. 갯수 셋팅..
			AddToItemTableToInventory(iItemID, iItemCount, iPos);
		}

		// 열 데이터 얻기..
		pItem = CGameBase::s_pTbl_Items_Basic.Find(iItemID / 1000 * 1000);
		if (pItem == nullptr)
		{
			__ASSERT(0, "아이템 포인터 테이블에 없음!!");
			CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - NULL Icon : {}", iItemID);
			return;
		}

		stdMsg = fmt::format_text_resource(IDS_ITEM_GET_BY_RULE, pItem->szName);
		CGameProcedure::s_pProcMain->MsgOutput(stdMsg, 0xff9b9bff);

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
	}

	if (bResult == 6)
	{
		// 메시지 박스 텍스트 표시..
		std::string szMsg = fmt::format_text_resource(IDS_ITEM_TOOMANY_OR_HEAVY);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}

	if (bResult == 7)
	{
		// 메시지 박스 텍스트 표시..
		std::string szMsg = fmt::format_text_resource(IDS_INV_ITEM_FULL);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}

	if (bResult == 1)
	{
		if (iItemID != dwGold)
		{
			pItem = CGameBase::s_pTbl_Items_Basic.Find(iItemID / 1000 * 1000);
			if (pItem == nullptr)
			{
				__ASSERT(0, "Invalidate Item ID From Server.. ");
				CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - Invalidate Item ID : {}", iItemID);
				return;
			}

			if (iPos < 0
				|| iPos >= MAX_ITEM_INVENTORY)
			{
				__ASSERT(0, "Invalidate Item Pos From Server.. ");
				CLogWriter::Write("CUIDroppedItemDlg::GetItemByIDToInventory - Invalidate Pos : {}", iPos);
				return;
			}

			spItem = nullptr;
			__IconItemSkill* spItemDest = CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos];
			// 아이템이 있다..
			if (spItemDest != nullptr)
			{
				if (iItemID != (spItemDest->pItemBasic->dwID + spItemDest->pItemExt->dwID))
				{
					// 기존 이이템을 클리어..
					if (spItemDest == nullptr)
						return;

					RemoveChild(spItemDest->pUIIcon);

					// 아이콘 리소스 삭제...
					spItemDest->pUIIcon->Release();
					delete spItemDest->pUIIcon;
					spItemDest->pUIIcon = nullptr;
					delete spItemDest;
					spItemDest = nullptr;

					CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos] = nullptr;

					//  아이템을 새로 만듬.. 갯수 셋팅..
					AddToItemTableToInventory(iItemID, iItemCount, iPos);
				}
				else
				{
					// 갯수 셋팅..
					// Picking up countable item which the user already have
					CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos]->iCount = iItemCount;
					PlayItemSound(CGameProcedure::s_pProcMain->m_pUIInventory->m_pMyInvWnd[iPos]->pItemBasic);
				}
			}
			else
			{
				// 아이템이 없는 경우 .. 새로 만든다.. 갯수 셋팅..
				// Picking up countable item for the first time or just a regular non-countable item
				AddToItemTableToInventory(iItemID, iItemCount, iPos);
			}

			std::string szMsg = fmt::format_text_resource(IDS_ITEM_GET_BY_RULE, pItem->szName);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xff9b9bff);

			spItem = m_pMyDroppedItem[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
			if (spItem != nullptr)
			{
				// 매니저에서 제거..
				RemoveChild(spItem->pUIIcon);

				// 리소스 제거..
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;
			}

			m_pMyDroppedItem[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;
		}
		else
		{
			pStatic = nullptr;
			pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

			// 돈 업데이트..
			stdMsg = fmt::format_text_resource(IDS_DROPPED_NOAH_GET,
				iGold - pInfoExt->iGold);
			CGameProcedure::s_pProcMain->MsgOutput(stdMsg, 0xff9b9bff);

			pInfoExt->iGold = iGold;
			//TRACE("돈 업데이트 %d \n", iGold);
			CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

			spItem = s_sRecoveryJobInfo.pItemSource;
			if (spItem == nullptr)
				return;

			// 매니저에서 제거..
			RemoveChild(spItem->pUIIcon);

			// 리소스 제거..
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
			m_pMyDroppedItem[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

			PlayGoldSound();
		}

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
	}

	bFound = false;
	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
	{
		if (m_pMyDroppedItem[i] != nullptr)
			bFound = true;
	}

	if (!bFound)
		LeaveDroppedState();
}

void CUIDroppedItemDlg::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIWndBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	for (int i = 0; i < MAX_ITEM_BUNDLE_DROP_PIECE; i++)
		m_bSendedIconArray[i] = false;
}

// ===== END WarFare/UIDroppedItemDlg.cpp =====

// ===== BEGIN WarFare/UIDroppedItemDlg.h =====
#line 1 "WarFare/UIDroppedItemDlg.h"
﻿// UIDroppedItemDlg.h: interface for the UIDroppedItemDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIDROPPEDITEMDLG_H__1E9B7E7F_FB6F_4D07_8386_6E84E22D73BB__INCLUDED_)
#define AFX_UIDROPPEDITEMDLG_H__1E9B7E7F_FB6F_4D07_8386_6E84E22D73BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

//////////////////////////////////////////////////////////////////////

class CUIDroppedItemDlg  : public CN3UIWndBase
{
public:
	__IconItemSkill*	m_pMyDroppedItem[MAX_ITEM_BUNDLE_DROP_PIECE];
	bool				m_bSendedIconArray[MAX_ITEM_BUNDLE_DROP_PIECE];

	int					m_iItemBundleID;
	CUIImageTooltipDlg*	m_pUITooltipDlg;

	int					m_iBackupiOrder;

protected:
	int			GetInventoryEmptyInviOrder(__IconItemSkill* spItem = nullptr);
	int			GetItemiOrder(__IconItemSkill* spItem);

public:
	CUIDroppedItemDlg();
	~CUIDroppedItemDlg() override;
	void		Release() override;

	void		SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	uint32_t	MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool		ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void		Render() override;
	void		EnterDroppedState(int xpos, int ypos);
	void		LeaveDroppedState();
	void		GetItemByIDToInventory(uint8_t bResult, int iItemId, int iGold, int iPos, int iItemCount, int iStrLen, const std::string& characterName);
	void		AddToItemTable(int iItemId, int iItemCount, int iOrder);
	void		AddToItemTableToInventory(int iItemId, int iItemCount, int iOrder);

	bool		ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur) override;

	void		InitIconWnd(e_UIWND eWnd) override;
	void		InitIconUpdate() override;

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon) override;
};

#endif // !defined(AFX_UIDROPPEDITEMDLG_H__1E9B7E7F_FB6F_4D07_8386_6E84E22D73BB__INCLUDED_)

// ===== END WarFare/UIDroppedItemDlg.h =====

// ===== BEGIN WarFare/UIEndingDisplay.cpp =====
#line 1 "WarFare/UIEndingDisplay.cpp"
﻿// UIEndingDisplay.cpp: implementation of the CUIEndingDisplay class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIEndingDisplay.h"
#include "UIManager.h"
#include "GameEng.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIEndingDisplay::CUIEndingDisplay()
{
}

CUIEndingDisplay::~CUIEndingDisplay()
{
	Release();
}

void CUIEndingDisplay::Release()
{
	CN3UIBase::Release();
}

void CUIEndingDisplay::Render()
{
	// 화면 가운데로 맞추기..
	RECT rc = this->GetRegion();
	int iX = (s_CameraData.vp.Width - (rc.right - rc.left))/2;
	int iY = (s_CameraData.vp.Height - (rc.bottom - rc.top))/2;
	this->SetPos(iX, iY);

	D3DCOLOR crEnv = 0x00000000;
	CGameEng::Clear(crEnv); // 배경은 검은색
	CGameEng::s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...

	CUIManager::RenderStateSet();
	CN3UIBase::Render();
	CUIManager::RenderStateRestore();
	
	CGameEng::s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	CGameEng::Present(CN3Base::s_hWndBase);
}
// ===== END WarFare/UIEndingDisplay.cpp =====

// ===== BEGIN WarFare/UIEndingDisplay.h =====
#line 1 "WarFare/UIEndingDisplay.h"
﻿// UIEndingDisplay.h: interface for the CUIEndingDisplay class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIENDINGDISPLAY_H__6AF00D52_3B84_4E80_A27F_279D266EB238__INCLUDED_)
#define AFX_UIENDINGDISPLAY_H__6AF00D52_3B84_4E80_A27F_279D266EB238__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUIEndingDisplay : public CN3UIBase
{
public:
	void	Render();
	void	Release();

	CUIEndingDisplay();
	virtual ~CUIEndingDisplay();
};

#endif // !defined(AFX_UIENDINGDISPLAY_H__6AF00D52_3B84_4E80_A27F_279D266EB238__INCLUDED_)

// ===== END WarFare/UIEndingDisplay.h =====

// ===== BEGIN WarFare/UIExitMenu.cpp =====
#line 1 "WarFare/UIExitMenu.cpp"
﻿#include "stdafx.h"
#include "UIExitMenu.h"
#include "GameProcMain.h"
#include "UIManager.h"
#include "N3FXMgr.h"
#include "PlayerMySelf.h"
#include "UIChat.h"
#include "text_resources.h"
#include "PacketDef.h"
#include "APISocket.h"

#include <N3Base/N3UIButton.h>

#include <shellapi.h>

CUIExitMenu::CUIExitMenu()
{
	m_pBtn_Chr = nullptr;
	m_pBtn_Option = nullptr;
	m_pBtn_Exit = nullptr;
	m_pBtn_Cancel = nullptr;
}

CUIExitMenu::~CUIExitMenu()
{
}

void CUIExitMenu::SetVisible(
	bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if (bVisible)
	{
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	}
	else
	{
		CGameProcedure::s_pUIMgr->ReFocusUI();

		if (m_pBtn_Chr != nullptr)
			m_pBtn_Chr->SetState(UI_STATE_BUTTON_NORMAL);

		if (m_pBtn_Option != nullptr)
			m_pBtn_Option->SetState(UI_STATE_BUTTON_NORMAL);

		if (m_pBtn_Exit != nullptr)
			m_pBtn_Exit->SetState(UI_STATE_BUTTON_NORMAL);

		if (m_pBtn_Cancel != nullptr)
			m_pBtn_Cancel->SetState(UI_STATE_BUTTON_NORMAL);
	}
}

bool CUIExitMenu::ReceiveMessage(
	CN3UIBase* pSender,
	uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg != UIMSG_BUTTON_CLICK)
		return true;

	if (pSender == m_pBtn_Chr)
	{
		if (CGameProcedure::s_pProcMain == nullptr)
			return true;

		if (CGameProcedure::s_pProcMain->m_fExitTimer == -1.0f)
		{
			/*
			if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			{
				CUIHotKeyDlg::MsgSend_SkillData_Save();
			}
			*/

			//CGameProcedure::s_pProcMain->m_bSeekingPartyChatEnabled = false;
			//CGameProcedure::s_pProcMain->m_bPendingPremiumCafeData = true;

			std::string szMsg = fmt::format_text_resource(IDS_CONNECTING_PLEASE_WAIT);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_OK);
			ReturnToCharacterSelection();
		}
		else if (CGameProcedure::s_pProcMain->m_pUIChatDlg != nullptr)
		{
			std::string szMsg = fmt::format_text_resource(IDS_CANNOT_EXIT_DURING_A_BATTLE);
			CGameProcedure::s_pProcMain->m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
			CGameProcedure::s_pProcMain->m_eExitType = EXIT_TYPE_CHR_SELECT;
			SetVisible(false);
		}

		return true;
	}

	if (pSender == m_pBtn_Option)
	{
		if (CGameProcedure::s_pProcMain == nullptr)
			return true;

		if (CGameProcedure::s_pProcMain->m_fExitTimer == -1.0f)
		{
			/*
			if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
				CUIHotKeyDlg::MsgSend_SkillData_Save();
			*/

			::ShellExecute(nullptr, "open", "Option.exe", nullptr, nullptr, SW_SHOWNORMAL);
			PostQuitMessage(0);
		}
		else if (CGameProcedure::s_pProcMain->m_pUIChatDlg != nullptr)
		{
			std::string szMsg = fmt::format_text_resource(IDS_CANNOT_EXIT_DURING_A_BATTLE);
			CGameProcedure::s_pProcMain->m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
			CGameProcedure::s_pProcMain->m_eExitType = EXIT_TYPE_QUIT;
			SetVisible(false);
		}
	}
	else if (pSender == m_pBtn_Exit)
	{
		if (CGameProcedure::s_pProcMain == nullptr)
			return true;

		if (CGameProcedure::s_pProcMain->m_fExitTimer == -1.0f)
		{
			/*
			if (CGameProcedure::s_pProcMain->_.m_pUIHotKeyDlg != nullptr)
				CUIHotKeyDlg::MsgSend_SkillData_Save();
			*/

			PostQuitMessage(0);
		}
		else if (CGameProcedure::s_pProcMain->m_pUIChatDlg != nullptr)
		{
			std::string szMsg = fmt::format_text_resource(IDS_CANNOT_EXIT_DURING_A_BATTLE);
			CGameProcedure::s_pProcMain->m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
			CGameProcedure::s_pProcMain->m_eExitType = EXIT_TYPE_QUIT;

			SetVisible(false);
		}
	}
	else if (pSender == m_pBtn_Cancel)
	{
		SetVisible(false);
	}

	return true;
}

void CUIExitMenu::ReturnToCharacterSelection()
{	
	if (CGameBase::s_pPlayer != nullptr)
	{
		if (CGameProcedure::s_pFX != nullptr)
		{
			//CGameBase::s_pPlayer->m_bStopTargetPointerAfterTime = false;
			//CGameBase::s_pPlayer->m_fStopTargetPointerAfterTime = 0.0f;
			CGameProcedure::s_pFX->Stop(
				CGameBase::s_pPlayer->IDNumber(),
				CGameBase::s_pPlayer->IDNumber(),
				FXID_TARGET_POINTER,
				FXID_TARGET_POINTER,
				true);
		}

		/*
		if (CGameBase::s_pPlayer->m_bIsMerchanting)
		{
			CGameBase::s_pPlayer->InitMerchant(false, nullptr);

			if (CGameProcedure::s_pProcMain->m_pUITradeInventory != nullptr)
				CGameProcedure::s_pProcMain->m_pUITradeInventory->Close();
		}
		*/
	}

	std::string szIP = CGameProcedure::s_pSocket->GetCurrentIP();
	DWORD dwPort = CGameProcedure::s_pSocket->GetCurrentPort();

	CGameProcedure::s_bNeedReportConnectionClosed = false;
	CGameProcedure::s_pSocket->Disconnect();
	Sleep(4000);

	CGameProcedure::s_pSocket->Connect(s_hWndBase, szIP.c_str(), dwPort);
	CGameProcedure::s_bNeedReportConnectionClosed = true;
	CGameProcedure::s_bIsRestarting = true;
	CGameProcedure::ProcActiveSet((CGameProcedure*) CGameProcedure::s_pProcCharacterSelect);
}

bool CUIExitMenu::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Chr,		GetChildByID<CN3UIButton>("btn_chr"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Option,	GetChildByID<CN3UIButton>("btn_option"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Exit,		GetChildByID<CN3UIButton>("btn_exit"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	GetChildByID<CN3UIButton>("btn_cancel"));

	return true;
}

// ===== END WarFare/UIExitMenu.cpp =====

// ===== BEGIN WarFare/UIExitMenu.h =====
#line 1 "WarFare/UIExitMenu.h"
﻿#pragma once

#include <N3Base/N3UIBase.h>

class CUIExitMenu : public CN3UIBase
{
public:
	CUIExitMenu();
	~CUIExitMenu() override;
	void SetVisible(bool bVisible) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void ReturnToCharacterSelection();
	bool Load(File& file) override;

protected:
	CN3UIButton* m_pBtn_Chr;
	CN3UIButton* m_pBtn_Option;
	CN3UIButton* m_pBtn_Exit;
	CN3UIButton* m_pBtn_Cancel;
};

// ===== END WarFare/UIExitMenu.h =====

// ===== BEGIN WarFare/UIHelp.cpp =====
#line 1 "WarFare/UIHelp.cpp"
﻿// UIHelp.cpp: implementation of the CUIHelp class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIHelp.h"
#include "GameProcedure.h"
#include "UIManager.h"

#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIHelp::CUIHelp()
{
	m_pBtn_Close = nullptr;
	m_pBtn_Prev = nullptr;
	m_pBtn_Next = nullptr;

	for (int i = 0; i < MAX_HELP_PAGE; i++)
		m_pPages[i] = nullptr;
}

CUIHelp::~CUIHelp()
{
}

bool CUIHelp::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	int iPageCount = 0;
	std::string szID;
	for (int i = 0; i < MAX_HELP_PAGE; i++)
	{
		szID = fmt::format("Page{}", i);
		N3_VERIFY_UI_COMPONENT(m_pPages[i], GetChildByID(szID));
		if (m_pPages[i] != nullptr)
		{
			m_pPages[i]->SetVisible(0 == iPageCount);
			iPageCount++;
		}
	}

	N3_VERIFY_UI_COMPONENT(m_pBtn_Close,	GetChildByID<CN3UIButton>("Btn_Close"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Prev,		GetChildByID<CN3UIButton>("Btn_Left"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Next,		GetChildByID<CN3UIButton>("Btn_Right"));

	return true;
}

bool CUIHelp::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		int iPage = -1;
		for (int i = 0; i < MAX_HELP_PAGE; i++)
		{
			if (m_pPages[i] != nullptr && m_pPages[i]->IsVisible())
			{
				iPage = i;
				break;
			}
		}

		int iPagePrev = iPage;

		if (pSender == m_pBtn_Prev)
		{
			iPage--;
			if (iPage < 0)
				iPage = 0;
		}
		else if (pSender == m_pBtn_Next)
		{
			iPage++;
			if (iPage >= MAX_HELP_PAGE)
				iPage = 0;
		}
		else if (pSender == m_pBtn_Close)
		{
			SetVisible(false);
		}

		if (iPagePrev != iPage)
		{
			for (int i = 0; i < MAX_HELP_PAGE; i++)
			{
				if (m_pPages[i] == nullptr)
					continue;

				m_pPages[i]->SetVisible(false);
				if (i == iPage)
					m_pPages[i]->SetVisible(true);
			}
		}
	}

	return false;
}

void CUIHelp::Release()
{
	CN3UIBase::Release();

	m_pBtn_Close = nullptr;
	m_pBtn_Prev = nullptr;
	m_pBtn_Next = nullptr;

	for (int i = 0; i < MAX_HELP_PAGE; i++) 
		m_pPages[i] = nullptr;
}

bool CUIHelp::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_PRIOR:
		ReceiveMessage(m_pBtn_Prev, UIMSG_BUTTON_CLICK);
		return true;

	case DIK_NEXT:
		ReceiveMessage(m_pBtn_Next, UIMSG_BUTTON_CLICK);
		return true;

	case DIK_ESCAPE:
		ReceiveMessage(m_pBtn_Close, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIHelp::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

// ===== END WarFare/UIHelp.cpp =====

// ===== BEGIN WarFare/UIHelp.h =====
#line 1 "WarFare/UIHelp.h"
﻿// UIHelp.h: interface for the CUIHelp class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIHELP_H__EFE9F4A4_295F_4A67_B97A_1DF248F1101A__INCLUDED_)
#define AFX_UIHELP_H__EFE9F4A4_295F_4A67_B97A_1DF248F1101A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUIHelp : public CN3UIBase  
{
public:
	static constexpr int MAX_HELP_PAGE = 3;

	CN3UIBase* m_pPages[MAX_HELP_PAGE];

	CN3UIButton* m_pBtn_Prev;
	CN3UIButton* m_pBtn_Next;
	CN3UIButton* m_pBtn_Close;

public:
	CUIHelp();
	~CUIHelp() override;

	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	void Release() override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
};

#endif // !defined(AFX_UIHELP_H__EFE9F4A4_295F_4A67_B97A_1DF248F1101A__INCLUDED_)

// ===== END WarFare/UIHelp.h =====

// ===== BEGIN WarFare/UIHotKeyDlg.cpp =====
#line 1 "WarFare/UIHotKeyDlg.cpp"
﻿// UIHotKeyDlg.cpp: implementation of the CUIHotKeyDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIHotKeyDlg.h"
#include "LocalInput.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "UISkillTreeDlg.h"
#include "MagicSkillMng.h"
#include "UIManager.h"
#include "UIInventory.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>

#include <cmath>
#include <algorithm>
#include <format>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIHotKeyDlg::CUIHotKeyDlg()
{
	m_iCurPage		= 0;
	m_iSelectIndex	= -1;
	m_iSelectPage	= -1;

	for( int i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
		for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
			m_pMyHotkey[i][j] = nullptr;

	for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
	{
		m_pCountStr[j] = nullptr;
		m_pTooltipStr[j] = nullptr;
	}
}

CUIHotKeyDlg::~CUIHotKeyDlg()
{
	Release();	
}

void CUIHotKeyDlg::Release()
{
	for( int i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
			{
				delete m_pMyHotkey[i][j];
				m_pMyHotkey[i][j] = nullptr;
			}
		}
	}

	for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
	{
		m_pCountStr[j] = nullptr;
		m_pTooltipStr[j] = nullptr;
	}

	m_iCurPage		= 0;
	m_iSelectIndex	= -1;
	m_iSelectPage	= -1;

	CN3UIBase::Release();
}

void CUIHotKeyDlg::ReleaseItem()
{
	for( int i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
			{
				if ( m_pMyHotkey[i][j]->pUIIcon )
				{
					RemoveChild(m_pMyHotkey[i][j]->pUIIcon);
					m_pMyHotkey[i][j]->pUIIcon->Release();
					delete m_pMyHotkey[i][j]->pUIIcon;
					m_pMyHotkey[i][j]->pUIIcon = nullptr;
				}

				delete m_pMyHotkey[i][j];
				m_pMyHotkey[i][j] = nullptr;
			}
		}
	}

	m_iCurPage = 0;
}

uint32_t CUIHotKeyDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if ( !IsVisible() ) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }
	// 실제로 쓰진 않는다..
	if (s_bWaitFromServer) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	// 드래그 되는 아이콘 갱신..
	if ( GetState() == UI_STATE_ICON_MOVING ) 
	{
		if(CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo)
		{
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetRegion(GetSampleRect());
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetMoveRect(GetSampleRect());
		}
	}

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

bool CUIHotKeyDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	//..
	if(pSender->m_szID == "btn_up")
		PageUp();
	if(pSender->m_szID == "btn_down")
		PageDown();

	__IconItemSkill* spSkill;

	uint32_t dwBitMask = 0x0f0f0000;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_DOWN_FIRST:
			// Get Item..
			spSkill = GetHighlightIconItem((CN3UIIcon* )pSender);

			// Save Select Info..
			CN3UIWndBase::s_sSkillSelectInfo.UIWnd = UIWND_HOTKEY;
			CN3UIWndBase::s_sSkillSelectInfo.iOrder = GetAreaiOrder();
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = spSkill;

			// Calc Move Rect Offset..
			if ( !CalcMoveOffset() )
				SetState(UI_STATE_COMMON_NONE);			
			break;

		case UIMSG_ICON_DOWN:
			if ( GetState()  == UI_STATE_ICON_MOVING )
			{
				CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetRegion(GetSampleRect());
				CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetMoveRect(GetSampleRect());
			}
			break;

		case UIMSG_ICON_RUP:
			// Hot Key 윈도우를 돌아 다니면서 검사..
			if ( IsIn(ptCur.x, ptCur.y) )
			{
				int iOrder = GetAreaiOrder();
				if(m_pMyHotkey[m_iCurPage][iOrder])
				{
					m_iSelectIndex	= iOrder;
					m_iSelectPage	= m_iCurPage;
				}
			}
			SetState(UI_STATE_COMMON_NONE);
			break;

		case UIMSG_ICON_UP:
			// Hot Key 윈도우를 돌아 다니면서 검사..
			if ( IsIn(ptCur.x, ptCur.y) )
			{
				int iOrder = GetAreaiOrder();
				if ( CN3UIWndBase::s_sSkillSelectInfo.iOrder == iOrder )	// 실행..
				{
					CN3UIArea* pArea;
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, iOrder);
					if (pArea) 
					{
						m_pMyHotkey[m_iCurPage][iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
						m_pMyHotkey[m_iCurPage][iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					}	

					DoOperate(m_pMyHotkey[m_iCurPage][iOrder]);
				}
				else	
				{
					if ( iOrder == -1 )
					{
						// 리소스 Free..
						spSkill = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;

						// 매니저에서 제거..
						RemoveChild(spSkill->pUIIcon);

						// 리소스 제거..
						spSkill->pUIIcon->Release();
						delete spSkill->pUIIcon;
						spSkill->pUIIcon = nullptr;
						delete spSkill;
						spSkill = nullptr;
						m_pMyHotkey[m_iCurPage][CN3UIWndBase::s_sSkillSelectInfo.iOrder] = nullptr;
						if(m_iCurPage == m_iSelectPage && CN3UIWndBase::s_sSkillSelectInfo.iOrder == m_iSelectIndex)
						{
							m_iSelectPage	= -1;
							m_iSelectIndex	= -1;
						}

						CloseIconRegistry();
					}
					else	// 옮기기..
					{
						// 기존 아이콘이 있다면..
						if ( m_pMyHotkey[m_iCurPage][iOrder] )
						{
							// 기존 아이콘을 삭제한다..
							spSkill = m_pMyHotkey[m_iCurPage][iOrder];

							// 매니저에서 제거..
							RemoveChild(spSkill->pUIIcon);

							// 리소스 제거..
							spSkill->pUIIcon->Release();
							delete spSkill->pUIIcon;
							spSkill->pUIIcon = nullptr;
							delete spSkill;
							spSkill = nullptr;
							m_pMyHotkey[m_iCurPage][iOrder] = nullptr;
						}

						spSkill = m_pMyHotkey[m_iCurPage][CN3UIWndBase::s_sSkillSelectInfo.iOrder];
						m_pMyHotkey[m_iCurPage][iOrder] = spSkill;
						m_pMyHotkey[m_iCurPage][CN3UIWndBase::s_sSkillSelectInfo.iOrder] = nullptr;

						if(m_iCurPage == m_iSelectPage && CN3UIWndBase::s_sSkillSelectInfo.iOrder == m_iSelectIndex)
						{
							m_iSelectPage	= -1;
							m_iSelectIndex	= -1;
						}

						CN3UIArea* pArea;
						pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, iOrder);
						if (pArea) 
						{
							m_pMyHotkey[m_iCurPage][iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
							m_pMyHotkey[m_iCurPage][iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
						}

						CloseIconRegistry();
					}
				}
			}
			else		// 삭제..
			{
				// 리소스 Free..
				spSkill = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;

				// 매니저에서 제거..
				RemoveChild(spSkill->pUIIcon);

				// 리소스 제거..
				spSkill->pUIIcon->Release();
				delete spSkill->pUIIcon;
				spSkill->pUIIcon = nullptr;
				delete spSkill;
				spSkill = nullptr;
				m_pMyHotkey[m_iCurPage][CN3UIWndBase::s_sSkillSelectInfo.iOrder] = nullptr;

				if(m_iCurPage == m_iSelectPage && CN3UIWndBase::s_sSkillSelectInfo.iOrder == m_iSelectIndex)
				{
					m_iSelectPage	= -1;
					m_iSelectIndex	= -1;
				}

				CloseIconRegistry();
			}
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
			SetState(UI_STATE_COMMON_NONE);
			break;

		case UIMSG_ICON_DBLCLK:
			break;
	}

	return false;
}

void CUIHotKeyDlg::Render()
{
	bool bTooltipRender = false;
	__IconItemSkill* pSkill = nullptr;

	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.
	DisableTooltipDisplay();
	DisableCountStrDisplay();

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( (GetState() == UI_STATE_ICON_MOVING) && (pChild->UIType() == UI_TYPE_ICON) && (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo) &&
			((CN3UIIcon *)pChild == CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon) )	continue;
			pChild->Render();
	}

	if ( (GetState() == UI_STATE_ICON_MOVING) && (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo) )
		CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->Render();		

	if(m_iCurPage == m_iSelectPage && m_pMyHotkey[m_iSelectPage][m_iSelectIndex])
	{
		CN3UIIcon* pUIIcon = m_pMyHotkey[m_iSelectPage][m_iSelectIndex]->pUIIcon;
		if(pUIIcon)
			RenderSelectIcon(pUIIcon);
	}

	// 현재 페이지에서 
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	int k;
	for (k = 0; k < MAX_SKILL_IN_HOTKEY; k++)
	{
		if (m_pMyHotkey[m_iCurPage][k] != nullptr)
		{
			float fCooldown = CGameProcedure::s_pProcMain->m_pMagicSkillMng->GetCooldown(
				m_pMyHotkey[m_iCurPage][k]->pSkill);
			
			// not on cooldown
			if (fCooldown < 0)
			{
				CN3UIIcon* pUIIcon = m_pMyHotkey[m_iCurPage][k]->pUIIcon;
				if (pUIIcon != nullptr)
					pUIIcon->Render();
			}
			else
			{
				RenderCooldown(m_pMyHotkey[m_iCurPage][k], fCooldown);
			}

			DisplayCountStr(m_pMyHotkey[m_iCurPage][k]);
		}
	}

	for(k = 0; k < MAX_SKILL_IN_HOTKEY; k++ )
	{
		if (m_pMyHotkey[m_iCurPage][k] != nullptr) 
		{
			pArea = nullptr;
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, k);
			if (pArea && pArea->IsIn(ptCur.x, ptCur.y)) 
			{
				bTooltipRender = true;
				break;
			}
		}
	}

	pSkill = m_pMyHotkey[m_iCurPage][k];

	if (bTooltipRender && pSkill)
		DisplayTooltipStr(pSkill);
}

void CUIHotKeyDlg::Open()
{
	SetVisible(true);

}

void CUIHotKeyDlg::Close()
{
	SetVisible(false);

}

void CUIHotKeyDlg::InitIconWnd(e_UIWND eWnd)
{
	CN3UIWndBase::InitIconWnd(eWnd);
}

void CUIHotKeyDlg::InitIconUpdate()
{
	// Get Hotkey Data From Registry.. 
	// First, Getting Hotkey Data Count.. 

	for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
	{
		m_pTooltipStr[j] = GetTooltipStrControl(j);
		m_pCountStr[j] = GetCountStrControl(j);
	}

	int iHCount = 0;
	if (!CGameProcedure::RegGetSetting("Count", &iHCount, sizeof(int)) )
		return;

	if( (iHCount < 0) || (iHCount > 65) )
		return;

	int iSkillCount = 0;
	CHotkeyData HD;
//	uint32_t bitMask;

	while (iHCount--)
	{
		std::string str = "Data" + std::to_string(iSkillCount);
		if (CGameProcedure::RegGetSetting(str.c_str(), &HD, sizeof(CHotkeyData)))
		{
			// Skill Tree Window가 아이디를 갖고 있지 않으면 continue.. 
			if ((HD.iID < UIITEM_TYPE_USABLE_ID_MIN) && (!CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->HasIDSkill(HD.iID)))
				continue;

			__TABLE_UPC_SKILL* pUSkill = CGameBase::s_pTbl_Skill.Find(HD.iID);
			if (!pUSkill)
				continue;

			__IconItemSkill* spSkill = new __IconItemSkill();
			spSkill->pSkill = pUSkill;

			// 아이콘 이름 만들기.. ^^
			spSkill->szIconFN = fmt::format("UI\\skillicon_{:02}_{}.dxt",
				HD.iID % 100, HD.iID / 100);

			// 아이콘 로드하기.. ^^
			spSkill->pUIIcon = new CN3UIIcon;
			spSkill->pUIIcon->Init(this);
			spSkill->pUIIcon->SetTex(spSkill->szIconFN);
			spSkill->pUIIcon->SetUVRect(0,0,1,1);
			spSkill->pUIIcon->SetUIType(UI_TYPE_ICON);
			spSkill->pUIIcon->SetStyle(UISTYLE_ICON_SKILL);

			SetHotKeyTooltip(spSkill);

			CN3UIArea* pArea = nullptr;
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, HD.column);
			if ( pArea )
			{
				spSkill->pUIIcon->SetRegion(pArea->GetRegion());
				spSkill->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			// 아이콘 정보 저장..
			m_pMyHotkey[HD.row][HD.column] = spSkill;
		}
		iSkillCount++;
	}

	SetHotKeyPage(0);
}

void CUIHotKeyDlg::UpdateDisableCheck()
{
	int i, j;
	uint32_t bitMask;

	for( i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
			{
				bitMask = UISTYLE_ICON_SKILL;
				if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(m_pMyHotkey[i][j]->pSkill))
					bitMask |= UISTYLE_DISABLE_SKILL;
				m_pMyHotkey[i][j]->pUIIcon->SetStyle(bitMask);
			}
		}
	}
}

void CUIHotKeyDlg::CloseIconRegistry()
{
	// Save Hotkey Data to Registry.. 
	// First, Saving Hotkey Data Count.. 

	int i, j;

	int iHCount = 0;
	for( i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
				iHCount++;
		}
	}

	CGameProcedure::RegPutSetting("Count", &iHCount, sizeof(int) );

	int iSkillCount = 0;

	for (i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++)
	{
		for (j = 0; j < MAX_SKILL_IN_HOTKEY; j++)
		{
			if (m_pMyHotkey[i][j] == nullptr)
				continue;

			std::string str = "Data" + std::to_string(iSkillCount);

			CHotkeyData HD(i, j, m_pMyHotkey[i][j]->pSkill->dwID);
			CGameProcedure::RegPutSetting(str.c_str(), &HD, sizeof(CHotkeyData));
			iSkillCount++;
		}
	}
}

__IconItemSkill* CUIHotKeyDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for( int k = 0; k < MAX_SKILL_IN_HOTKEY; k++ )
	{
		if ( (m_pMyHotkey[m_iCurPage][k] != nullptr) && 
			(m_pMyHotkey[m_iCurPage][k]->pUIIcon == pUIIcon) )
			return m_pMyHotkey[m_iCurPage][k];
	}

	return nullptr;
}

void CUIHotKeyDlg::AllFactorClear()
{
	__IconItemSkill *spSkill = nullptr;

	for( int i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
			{
				// 리소스 Free..
				spSkill = m_pMyHotkey[i][j];

				// 매니저에서 제거..
				RemoveChild(spSkill->pUIIcon);

				// 리소스 제거..
				spSkill->pUIIcon->Release();
				delete spSkill->pUIIcon;
				spSkill->pUIIcon = nullptr;
				delete spSkill;
				spSkill = nullptr;
				m_pMyHotkey[i][j] = nullptr;
			}
		}
	}

	m_iCurPage = 0;
}

int	CUIHotKeyDlg::GetAreaiOrder()
{
	// 먼저 Area를 검색한다..
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	for( int i = 0; i < MAX_SKILL_IN_HOTKEY; i++ )
	{
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, i);
		if (pArea && pArea->IsIn(ptCur.x, ptCur.y))
			return i;
	}

	return -1;
}

bool CUIHotKeyDlg::IsSelectedSkillInRealIconArea()
{
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	for (int i = 0; i < MAX_SKILL_IN_HOTKEY; i++)
	{
		CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, i);
		if (pArea == nullptr
			|| !pArea->IsIn(ptCur.x, ptCur.y))
			continue;

		if (s_sSkillSelectInfo.pSkillDoneInfo == nullptr)
			return false;

		SetReceiveSelectedSkill(i);
		return true;
	}

	return false;
}

bool CUIHotKeyDlg::GetEmptySlotIndex(int &iIndex)
{
	__IconItemSkill *spSkill = nullptr;

	for( int i = 0; i < MAX_SKILL_IN_HOTKEY; i++ )
	{
		if (!m_pMyHotkey[m_iCurPage][i])
		{
			iIndex = i;
			return true;
		}
	}

	return false;
}

void CUIHotKeyDlg::SetReceiveSelectedSkill(int iIndex)
{
	__IconItemSkill *spSkill = nullptr;

	if (m_pMyHotkey[m_iCurPage][iIndex] != nullptr)
	{
		// 리소스 Free..
		spSkill = m_pMyHotkey[m_iCurPage][iIndex];

		// 매니저에서 제거..
		RemoveChild(spSkill->pUIIcon);

		// 리소스 제거..
		spSkill->pUIIcon->Release();
		delete spSkill->pUIIcon;
		spSkill->pUIIcon = nullptr;
		delete spSkill;
		spSkill = nullptr;
		m_pMyHotkey[m_iCurPage][iIndex] = nullptr;
	}

	CN3UIArea* pArea;
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, iIndex);

	// 그 다음에.. 그 자리에 
	m_pMyHotkey[m_iCurPage][iIndex] = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
	m_pMyHotkey[m_iCurPage][iIndex]->szIconFN = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->szIconFN;
	m_pMyHotkey[m_iCurPage][iIndex]->pUIIcon->SetRegion(pArea->GetRegion());
	m_pMyHotkey[m_iCurPage][iIndex]->pUIIcon->SetMoveRect(pArea->GetRegion());
	m_pMyHotkey[m_iCurPage][iIndex]->pUIIcon->SetParent(this);

	SetHotKeyTooltip(m_pMyHotkey[m_iCurPage][iIndex]);
}

RECT CUIHotKeyDlg::GetSampleRect()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, 0);
	rect = pArea->GetRegion();
	float fWidth = (float)(rect.right - rect.left);
	float fHeight = (float)(rect.bottom - rect.top);
	rect.left = ptCur.x - m_ptOffset.x;  rect.right  = rect.left + (int)fWidth;
	rect.top  = ptCur.y - m_ptOffset.y;  rect.bottom = rect.top + (int)fHeight;
	return rect;
}

void CUIHotKeyDlg::PageUp()
{
	if ( m_iCurPage <= 0 )
		return;

	SetHotKeyPage(--m_iCurPage);
}

void CUIHotKeyDlg::PageDown()
{
	if ( m_iCurPage >= (MAX_SKILL_HOTKEY_PAGE-1) )
		return;

	SetHotKeyPage(++m_iCurPage);
}

void CUIHotKeyDlg::SetHotKeyPage(int iPageNum)
{
	int i, j;
	
	for( i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		if ( i != iPageNum )
		{
			for( j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
				if ( m_pMyHotkey[i][j] != nullptr )
					m_pMyHotkey[i][j]->pUIIcon->SetVisible(false);
		}
		else
		{
			for( j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
				if ( m_pMyHotkey[i][j] != nullptr )
					m_pMyHotkey[i][j]->pUIIcon->SetVisible(true);
		}
	}

	m_iCurPage = iPageNum;
}

bool CUIHotKeyDlg::CalcMoveOffset()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	int iOrder = GetAreaiOrder();
	if ( iOrder == -1 ) return false;
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, iOrder);
	rect = pArea->GetRegion();
	m_ptOffset.x = ptCur.x - rect.left;
	m_ptOffset.y = ptCur.y - rect.top;
	return true;
}

void CUIHotKeyDlg::EffectTriggerByHotKey(int iIndex)
{
	if(iIndex < 0 || iIndex >= 8) return;

	if ( m_pMyHotkey[m_iCurPage][iIndex] && m_pMyHotkey[m_iCurPage][iIndex]->pUIIcon->IsVisible() )
	{
		DoOperate(m_pMyHotkey[m_iCurPage][iIndex]);
	}
}

void CUIHotKeyDlg::DoOperate(__IconItemSkill* pSkill)
{
	if (pSkill == nullptr)
		return;

	// 메시지 박스 출력..	
	// std::string buff = fmt::format("{} 스킬이 사용되었습니다.", pSkill->pSkill->szName);
	// CGameProcedure::s_pProcMain->MsgOutput(buff, 0xffffff00);			

	int iIDTarget = CGameBase::s_pPlayer->m_iIDTarget;
	CGameProcedure::s_pProcMain->m_pMagicSkillMng->MsgSend_MagicProcess(iIDTarget, pSkill->pSkill);
}

void CUIHotKeyDlg::ClassChangeHotkeyFlush()
{
	__IconItemSkill* spSkill;

	for( int i = 0; i < MAX_SKILL_HOTKEY_PAGE; i++ )
	{
		for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
		{
			if ( m_pMyHotkey[i][j] != nullptr )
			{
				// 리소스 Free..
				spSkill = m_pMyHotkey[i][j];

				// 매니저에서 제거..
				RemoveChild(spSkill->pUIIcon);

				// 리소스 제거..
				spSkill->pUIIcon->Release();
				delete spSkill->pUIIcon;
				spSkill->pUIIcon = nullptr;
				delete spSkill;
				spSkill = nullptr;
				m_pMyHotkey[i][j] = nullptr;
			}
		}
	}
}

CN3UIString* CUIHotKeyDlg::GetTooltipStrControl(int iIndex)
{
	std::string str = std::to_string(iIndex + 10);
	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>(str));
	return pStr;
}

CN3UIString* CUIHotKeyDlg::GetCountStrControl(int iIndex)
{
	std::string str = std::to_string(iIndex);
	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>(str));
	return pStr;
}

void CUIHotKeyDlg::DisplayTooltipStr(__IconItemSkill* spSkill)
{
	int iIndex = GetTooltipCurPageIndex(spSkill);
	if (iIndex != -1)
	{
		if (!m_pTooltipStr[iIndex]->IsVisible())	
			m_pTooltipStr[iIndex]->SetVisible(true);

		m_pTooltipStr[iIndex]->SetString(spSkill->pSkill->szName);
		m_pTooltipStr[iIndex]->Render();
	}
}

void CUIHotKeyDlg::DisableTooltipDisplay()
{
	for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
	{
		if (m_pTooltipStr[j])	
			m_pTooltipStr[j]->SetVisible(false);
	}
}

void CUIHotKeyDlg::DisplayCountStr(__IconItemSkill* spSkill)
{
	int iIndex = GetCountCurPageIndex(spSkill);
	if (iIndex != -1)
	{
		if (!m_pCountStr[iIndex]->IsVisible())	
			m_pCountStr[iIndex]->SetVisible(true);

		m_pCountStr[iIndex]->SetStringAsInt(
			CGameProcedure::s_pProcMain->m_pUIInventory->GetCountInInvByID(spSkill->pSkill->dwExhaustItem));
		m_pCountStr[iIndex]->Render();
	}
}

void CUIHotKeyDlg::DisableCountStrDisplay()
{
	for( int j = 0; j < MAX_SKILL_IN_HOTKEY; j++ )
	{
		if (m_pCountStr[j])	
			m_pCountStr[j]->SetVisible(false);
	}
}

int CUIHotKeyDlg::GetTooltipCurPageIndex(__IconItemSkill* pSkill)
{
	for( int k = 0; k < MAX_SKILL_IN_HOTKEY; k++ )
	{
		if ( (m_pMyHotkey[m_iCurPage][k] != nullptr) && 
			(m_pMyHotkey[m_iCurPage][k] == pSkill) )
			return k;
	}

	return -1;
}

int CUIHotKeyDlg::GetCountCurPageIndex(__IconItemSkill* spSkill)
{
	if(spSkill->pSkill->dwExhaustItem <= 0)
		return -1;

	return GetTooltipCurPageIndex(spSkill);
}

bool CUIHotKeyDlg::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
	bool bFound = false;
	// 내가 가졌던 아이콘이 아니면..
	if ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd != UIWND_INVENTORY )
		return false;
	else
	{
		CN3UIArea* pArea = nullptr;

		int iOrder;
		for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
		{
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, i);
			if ( pArea && pArea->IsIn(ptCur.x, ptCur.y) )
			{
				bFound = true;
				iOrder = i;
				break;
			}
		}
		if ( !bFound )
			return false;

		__IconItemSkill* spSkill, *spItem;

		// 기존 아이콘이 있다면..
		if ( m_pMyHotkey[m_iCurPage][iOrder] )
		{
			// 기존 아이콘을 삭제한다..
			spSkill = m_pMyHotkey[m_iCurPage][iOrder];

			// 매니저에서 제거..
			RemoveChild(spSkill->pUIIcon);

			// 리소스 제거..
			spSkill->pUIIcon->Release();
			delete spSkill->pUIIcon;
			spSkill->pUIIcon = nullptr;
			delete spSkill;
			spSkill = nullptr;
			m_pMyHotkey[m_iCurPage][iOrder] = nullptr;
		}

		spItem = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect;

		__TABLE_UPC_SKILL* pUSkill = CGameBase::s_pTbl_Skill.Find(spItem->pItemBasic->dwEffectID1);
		if ( pUSkill == nullptr ) return false;
		if ( pUSkill->dwID < UIITEM_TYPE_USABLE_ID_MIN) return false;

		spSkill = new __IconItemSkill();
		spSkill->pSkill = pUSkill;

		// 아이콘 이름 만들기.. ^^
		spSkill->szIconFN = fmt::format("UI\\skillicon_{:02}_{}.dxt",
			spItem->pItemBasic->dwEffectID1 % 100, spItem->pItemBasic->dwEffectID1 / 100);

		// 아이콘 로드하기.. ^^
		spSkill->pUIIcon = new CN3UIIcon;
		spSkill->pUIIcon->Init(this);
		spSkill->pUIIcon->SetTex(spSkill->szIconFN);
		spSkill->pUIIcon->SetUVRect(0,0,1.0f, 1.0f);
		spSkill->pUIIcon->SetUIType(UI_TYPE_ICON);
		spSkill->pUIIcon->SetStyle(UISTYLE_ICON_SKILL);

		SetHotKeyTooltip(spSkill);

		uint32_t bitMask = UISTYLE_ICON_SKILL;
		if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(spSkill->pSkill))
			bitMask |= UISTYLE_DISABLE_SKILL;
		spSkill->pUIIcon->SetStyle(bitMask);

		if ( pArea )
		{
			spSkill->pUIIcon->SetRegion(pArea->GetRegion());
			spSkill->pUIIcon->SetMoveRect(pArea->GetRegion());
		}

		m_pMyHotkey[m_iCurPage][iOrder] = spSkill;

		CloseIconRegistry();
	}

	return false;
}

bool CUIHotKeyDlg::SetReceiveSelectedItem(int iIndex)
{
	if (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd != UIWND_INVENTORY)
		return false;

	__IconItemSkill* spItem = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect;

	__TABLE_UPC_SKILL* pUSkill = CGameBase::s_pTbl_Skill.Find(spItem->pItemBasic->dwEffectID1);
	if (pUSkill == nullptr)
		return false;

	if (pUSkill->dwID < UIITEM_TYPE_USABLE_ID_MIN)
		return false;

	if (m_pMyHotkey[m_iCurPage][iIndex] != nullptr)
		return false;

	__IconItemSkill* spSkill = new __IconItemSkill();
	spSkill->pSkill = pUSkill;

	// Create the icon name
	spSkill->szIconFN = fmt::format("UI\\skillicon_{:02}_{}.dxt",
		spItem->pItemBasic->dwEffectID1 % 100, spItem->pItemBasic->dwEffectID1 / 100);

	// load icon
	spSkill->pUIIcon = new CN3UIIcon();
	spSkill->pUIIcon->Init(this);
	spSkill->pUIIcon->SetTex(spSkill->szIconFN);
	spSkill->pUIIcon->SetUVRect(0, 0, 1.0f, 1.0f);
	spSkill->pUIIcon->SetUIType(UI_TYPE_ICON);

	SetHotKeyTooltip(spSkill);

	uint32_t bitMask = UISTYLE_ICON_SKILL;
	if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(spSkill->pSkill))
		bitMask |= UISTYLE_DISABLE_SKILL;
	spSkill->pUIIcon->SetStyle(bitMask);

	CN3UIArea* pArea = nullptr;
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_HOTKEY, iIndex);

	if (pArea != nullptr)
	{
		spSkill->pUIIcon->SetRegion(pArea->GetRegion());
		spSkill->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	m_pMyHotkey[m_iCurPage][iIndex] = spSkill;

	CloseIconRegistry();
	return true;
}

bool CUIHotKeyDlg::EffectTriggerByMouse()
{
	if(m_iSelectIndex < 0 || m_iSelectIndex >= 8) return false;
	if(m_iSelectPage < 0 || m_iSelectPage >= 8) return false;

	if ( m_pMyHotkey[m_iSelectPage][m_iSelectIndex] )
	{
		int iIDTarget = CGameBase::s_pPlayer->m_iIDTarget;
		return CGameProcedure::s_pProcMain->m_pMagicSkillMng->MsgSend_MagicProcess(iIDTarget, m_pMyHotkey[m_iSelectPage][m_iSelectIndex]->pSkill);
	}

	return false;
}

void CUIHotKeyDlg::RenderSelectIcon(CN3UIIcon* pUIIcon)
{
	if(!pUIIcon) return;

	RECT rc = pUIIcon->GetRegion(); // 선택 표시

	__VertexTransformedColor vLines[5];
	vLines[0].Set((float)rc.left, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[1].Set((float)rc.right, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[2].Set((float)rc.right, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[3].Set((float)rc.left, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[4] = vLines[0];

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, vLines, sizeof(__VertexTransformedColor));
	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

void CUIHotKeyDlg::RenderCooldown(const __IconItemSkill* pSkill, float fCooldown)
{
	if (pSkill == nullptr)
		return;

	constexpr D3DCOLOR Color = D3DCOLOR_ARGB(0x80, 0xFF, 0x00, 0x00);

	const RECT rc = pSkill->pUIIcon->GetRegion();

	const float centerX = static_cast<float>(rc.left + rc.right) / 2;
	const float centerY = static_cast<float>(rc.top + rc.bottom) / 2;

	const float halfWidth = static_cast<float>(centerX - rc.left);
	const float halfHeight = static_cast<float>(centerY - rc.top);

	const float radius = std::sqrtf(
		std::pow(halfWidth, 2.0f)
		+ std::pow(halfHeight, 2.0f));

	float progress = 0.0f;
	
	if (pSkill->pSkill->iReCastTime > 0)
	{
		progress = (fCooldown / (static_cast<float>(pSkill->pSkill->iReCastTime) / 10.0f));
		progress = std::clamp(progress, 0.0f, 1.0f);
	}

	// arbitrary number of segments. this might be too many for such a small icon.
	const int segments = 64;
	const int segmentCountToDraw = static_cast<int>((segments * progress));

	std::vector<__VertexTransformedColor> vertices;
	vertices.reserve(segments);

	// not 100% sure on the color. Choosing arbitrary 50% opacity.
	vertices.emplace_back(centerX, centerY, UI_DEFAULT_Z, UI_DEFAULT_RHW, Color);

	const float fullCircle = __PI * 2.0f;
	const float maxAngle = fullCircle * progress;
	const float startAngle = -__PI / 2.0f; // 12 o'clock

	std::vector<__VertexTransformedColor> arcVertices;
	arcVertices.reserve(segmentCountToDraw);

	for (int i = 0; i <= segmentCountToDraw; i++)
	{
		float angle = startAngle - maxAngle * (static_cast<float>(i) / segmentCountToDraw);
		float x = centerX + cosf(angle) * radius;
		float y = centerY + sinf(angle) * radius;
		arcVertices.emplace_back(x, y, UI_DEFAULT_Z, UI_DEFAULT_RHW, Color);
	}

	// very crude way but i'd rather keep culling enabled.
	vertices.insert(vertices.end(), arcVertices.rbegin(), arcVertices.rend());

	// disable culling and reverse vectors.
	//for (int i = 0; i <= segmentCountToDraw; i++)
	//{
	//	// Go clockwise by subtracting angle increments
	//	float angle = startAngle - maxAngle * (static_cast<float>(i) / segmentCountToDraw);
	//	float x = centerX + cosf(angle) * radius;
	//	float y = centerY + sinf(angle) * radius;
	//	vertices.emplace_back(x, y, UI_DEFAULT_Z, UI_DEFAULT_RHW, Color);
	//}

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
	CN3Base::s_lpD3DDev->SetScissorRect(&rc);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMED);
	// CN3Base::s_lpD3DDev->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, static_cast<UINT>(vertices.size()) - 2, &vertices[0], sizeof(__VertexTransformedColor));

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

//this_ui_add_start
bool CUIHotKeyDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if(pFocus && pFocus != this) pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}
//this_ui_add_end

void CUIHotKeyDlg::SetHotKeyTooltip(__IconItemSkill* spSkill)
{
	if (spSkill == nullptr
		|| spSkill->pSkill == nullptr
		|| spSkill->pUIIcon == nullptr)
		return;

	std::string szTooltip = fmt::format("[{}] {}", spSkill->pSkill->szName, spSkill->pSkill->szDesc);
	spSkill->pUIIcon->SetTooltipText(szTooltip);
	spSkill->pUIIcon->SetTooltipColor(D3DCOLOR_XRGB(0x80, 0x80, 0xFF));
}

// ===== END WarFare/UIHotKeyDlg.cpp =====

// ===== BEGIN WarFare/UIHotKeyDlg.h =====
#line 1 "WarFare/UIHotKeyDlg.h"
﻿// UIHotKeyDlg.h: interface for the CUIHotKeyDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIHOTKEYDLG_H__9B85201C_0294_4023_8658_923A6A2174BF__INCLUDED_)
#define AFX_UIHOTKEYDLG_H__9B85201C_0294_4023_8658_923A6A2174BF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

//////////////////////////////////////////////////////////////////////

class CUIHotKeyDlg      : public CN3UIWndBase  
{
public:
	POINT				m_ptOffset;
	int					m_iCurPage;
	__IconItemSkill*	m_pMyHotkey[MAX_SKILL_HOTKEY_PAGE][MAX_SKILL_IN_HOTKEY];
	CN3UIString*		m_pTooltipStr[MAX_SKILL_IN_HOTKEY];
	CN3UIString*		m_pCountStr[MAX_SKILL_IN_HOTKEY];

	int					m_iSelectIndex;
	int					m_iSelectPage;

protected:
	RECT				GetSampleRect();

public:
	bool OnKeyPress(int iKey);
	void RenderSelectIcon(CN3UIIcon* pUIIcon);
	bool EffectTriggerByMouse();
	CUIHotKeyDlg();
	virtual ~CUIHotKeyDlg();
	void				Release();
	void				ReleaseItem();

	virtual uint32_t		MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	virtual bool		ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg);
	void				Render();
	void				Open();
	void				Close();

	void				InitIconWnd(e_UIWND eWnd);	
	void				InitIconUpdate();

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon);

	void				SetHotKeyPage(int iPageNum);

	void				PageUp();
	void				PageDown();

	bool				CalcMoveOffset();
	int					GetAreaiOrder();

	void				DoOperate(__IconItemSkill*	pSkill);

	void				EffectTriggerByHotKey(int iIndex);

	void				CloseIconRegistry();
	void				ClassChangeHotkeyFlush();

	CN3UIString*  GetTooltipStrControl(int iIndex);
	CN3UIString*  GetCountStrControl(int iIndex);
	void				DisplayTooltipStr(__IconItemSkill* pSkill);
	void				DisableTooltipDisplay();
	void				DisplayCountStr(__IconItemSkill* pSkill);
	void				DisableCountStrDisplay();
	int					 GetTooltipCurPageIndex(__IconItemSkill* pSkill);
	int					 GetCountCurPageIndex(__IconItemSkill* pSkill);

//	bool				ReceiveSelectedSkill();
	bool				IsSelectedSkillInRealIconArea();
	void				SetReceiveSelectedSkill(int iIndex);
	bool				SetReceiveSelectedItem(int iIndex);
	bool				GetEmptySlotIndex(int &iIndex);

	void				AllFactorClear();
	void				UpdateDisableCheck();

	bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur);
	void				RenderCooldown(const __IconItemSkill* pSkill, float fCooldown);

	void				SetHotKeyTooltip(__IconItemSkill* spSkill);
};

#endif // !defined(AFX_UIHOTKEYDLG_H__9B85201C_0294_4023_8658_923A6A2174BF__INCLUDED_)

// ===== END WarFare/UIHotKeyDlg.h =====

// ===== BEGIN WarFare/UIImageTooltipDlg.cpp =====
#line 1 "WarFare/UIImageTooltipDlg.cpp"
﻿// UIImageTooltipDlg.cpp: implementation of the CUIImageTooltipDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIImageTooltipDlg.h"
#include "PlayerMySelf.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIImageTooltipDlg::CUIImageTooltipDlg()
	: m_CYellow(D3DCOLOR_XRGB(255, 255, 0)), 
	m_CBlue(D3DCOLOR_XRGB(128, 128, 255)),
	m_CGold(D3DCOLOR_XRGB(220, 199, 124)),
	m_CIvory(D3DCOLOR_XRGB(200, 124, 199)),
	m_CGreen(D3DCOLOR_XRGB(128, 255, 0)),
	m_CWhite(D3DCOLOR_XRGB(255, 255, 255)),
	m_CRed(D3DCOLOR_XRGB(255, 60, 60))
{
	m_iPosXBack = 0;
	m_iPosYBack = 0;
	m_pImg = nullptr;
	m_iTooltipNum = 0;

	ResetItem();
}

CUIImageTooltipDlg::~CUIImageTooltipDlg()
{
}

void CUIImageTooltipDlg::Release()
{
	CN3UIBase::Release();

	m_iPosXBack = 0;
	m_iPosYBack = 0;
	m_pImg = nullptr;
	m_iTooltipNum = 0;

	ResetItem();
}

void CUIImageTooltipDlg::InitPos()
{
	std::string str;

	for (int i = 0; i < MAX_TOOLTIP_COUNT; i++)
	{
		str = "string_" + std::to_string(i);
		N3_VERIFY_UI_COMPONENT(m_pStr[i], GetChildByID<CN3UIString>(str));
	}

	N3_VERIFY_UI_COMPONENT(m_pImg, GetChildByID<CN3UIImage>("mins"));
}

void CUIImageTooltipDlg::DisplayTooltipsDisable()
{
	if (IsVisible())
		SetVisible(false);
}

bool CUIImageTooltipDlg::SetTooltipTextColor(int iMyValue, int iTooltipValue)
{
	return iMyValue >= iTooltipValue;
}

bool CUIImageTooltipDlg::SetTooltipTextColor(e_Race eMyValue, e_Race eTooltipValue)
{
	return eMyValue == eTooltipValue;
}

bool CUIImageTooltipDlg::SetTooltipTextColor(e_Class eMyValue, e_Class eTooltipValue)
{
	return eMyValue == eTooltipValue;
}

void CUIImageTooltipDlg::SetPosSomething(int xpos, int ypos)
{
	if (m_iTooltipNum <= 0)
		return;

	int iWidth = 0;
	int iPadding = 8;

	for (int i = 0; i < m_iTooltipNum; i++)
	{
		if (m_pstdstr[i].empty())
			continue;

		int currentWidth = m_pStr[0]->GetStringRealWidth(m_pstdstr[i]);
		if (currentWidth > iWidth)
			iWidth = currentWidth;
	}

	int iHeight = m_pStr[m_iTooltipNum - 1]->GetRegion().bottom - m_pStr[0]->GetRegion().top;

	iWidth += iPadding * 2;
	iHeight += static_cast<int>(iPadding * 1.5);

	RECT rect, rect2;

	int iRight, iTop, iBottom, iX, iY;

	iRight = CN3Base::s_CameraData.vp.Width;
	iTop = 0;
	iBottom = CN3Base::s_CameraData.vp.Height;

	if ((xpos + 26 + iWidth) < iRight)
	{
		rect.left = xpos + 26;
		rect.right = rect.left + iWidth;
		iX = xpos + 26;
	}
	else
	{
		rect.left = xpos - iWidth;
		rect.right = xpos;
		iX = xpos - iWidth;
	}

	if ((ypos - iHeight) > iTop)
	{
		rect.top = ypos - iHeight;
		rect.bottom = ypos;
		iY = ypos - iHeight;
	}
	else
	{
		if ((ypos + iHeight) < iBottom)
		{
			rect.top = ypos;
			rect.bottom = ypos + iHeight;
			iY = ypos;
		}
		else
		{
			rect.top = iBottom - iHeight;
			rect.bottom = iBottom;
			iY = rect.top;
		}
	}

	SetPos(iX, iY);
	SetSize(iWidth, iHeight);

	for (int i = 0; i < m_iTooltipNum; i++)
	{
		if (m_pStr[i] == nullptr)
			continue;

		// add padding to rects
		rect2 = m_pStr[i]->GetRegion();
		rect2.left = rect.left + iPadding;
		rect2.right = rect.right - iPadding;
		m_pStr[i]->SetRegion(rect2);

		if (m_pStr[i]->GetStyle() & UISTYLE_STRING_ALIGNCENTER)
			m_pStr[i]->SetString(m_pstdstr[i]);
		else
			m_pStr[i]->SetString("  " + m_pstdstr[i]);
	}

	for (int i = m_iTooltipNum; i < MAX_TOOLTIP_COUNT; i++)
		m_pStr[i]->SetString("");

	m_pImg->SetRegion(rect);

	m_iPosXBack = xpos;
	m_iPosYBack = ypos;
}

int	CUIImageTooltipDlg::CalcTooltipStringNumAndWrite(__IconItemSkill* spItem, bool bPrice, bool bBuy)
{
	int iIndex = 0;

	__InfoPlayerMySelf*	pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

#define ERROR_EXCEPTION									\
{		\
	if (bPrice && (iIndex > MAX_TOOLTIP_COUNT-2))	 {__ASSERT(0, "Too Many Tooltip Item Info");	goto exceptions;}	\
	if (!bPrice && (iIndex > MAX_TOOLTIP_COUNT-1))	 {__ASSERT(0, "Too Many Tooltip Item Info");	goto exceptions;}	\
}

	if (m_pStr[iIndex] != nullptr)
	{
		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);

		std::string szStr = fmt::format_text_resource(IDS_TOOLTIP_GOLD);
		if ( spItem->pItemBasic->szName == szStr )
		{
			// 돈이면 흰색..
			m_pStr[iIndex]->SetColor(m_CWhite);
			m_pstdstr[iIndex] = fmt::format("{}  {}", spItem->iCount, spItem->pItemBasic->szName);
			iIndex++;			

			for( int i = iIndex; i < MAX_TOOLTIP_COUNT; i++ )
				m_pstdstr[iIndex] = "";

			return iIndex;	
		}
		else
		{
			e_ItemAttrib eTA = (e_ItemAttrib)(spItem->pItemExt->byMagicOrRare);
			switch (eTA)
			{
				case ITEM_ATTRIB_GENERAL:
					m_pStr[iIndex]->SetColor(m_CWhite);
					break;
				case ITEM_ATTRIB_MAGIC:
					m_pStr[iIndex]->SetColor(m_CBlue);
					break;
				case ITEM_ATTRIB_LAIR:
					m_pStr[iIndex]->SetColor(m_CYellow);
					break;
				case ITEM_ATTRIB_CRAFT:
					m_pStr[iIndex]->SetColor(m_CGreen);
					break;
				case ITEM_ATTRIB_UNIQUE:
					m_pStr[iIndex]->SetColor(m_CGold);
					break;
				case ITEM_ATTRIB_UPGRADE:
					m_pStr[iIndex]->SetColor(m_CIvory);
					break;
				default:
					m_pStr[iIndex]->SetColor(m_CWhite);
					break;
			}

			if ((e_ItemAttrib) (spItem->pItemExt->byMagicOrRare) != ITEM_ATTRIB_UNIQUE)
			{
				std::string strtemp;
				if (spItem->pItemExt->dwID % 10 != 0)
					strtemp = fmt::format("(+{})", spItem->pItemExt->dwID % 10);

				m_pstdstr[iIndex] = spItem->pItemBasic->szName + strtemp;
			}
			else
			{
				m_pstdstr[iIndex] = spItem->pItemExt->szHeader;
			}
		}
	}
	iIndex++;

	if ( (spItem->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE) && (spItem->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE_SMALL) )
	{
		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);
		e_ItemClass eIC = (e_ItemClass) (spItem->pItemBasic->byClass);
		CGameBase::GetTextByItemClass(eIC, m_pstdstr[iIndex]); // 아이템 종류에 따라 문자열 만들기..
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}

	e_Race eRace = (e_Race)spItem->pItemBasic->byNeedRace;
	if (eRace != RACE_ALL)
	{
		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);
		CGameBase::GetTextByRace(eRace, m_pstdstr[iIndex]); // 아이템을 찰수 있는 종족에 따른 문자열 만들기.
		if (SetTooltipTextColor(CGameBase::s_pPlayer->m_InfoBase.eRace, eRace))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);
		iIndex++;
	}
	ERROR_EXCEPTION

	if ((int)spItem->pItemBasic->byNeedClass != 0)
	{
		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);
		e_Class eClass = (e_Class) spItem->pItemBasic->byNeedClass;
		CGameBase::GetTextByClass(eClass, m_pstdstr[iIndex]); // 아이템을 찰수 있는 종족에 따른 문자열 만들기.

		switch (eClass)
		{
			case CLASS_KINDOF_WARRIOR:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_WARRIOR:
					case CLASS_KA_BERSERKER:
					case CLASS_KA_GUARDIAN:
					case CLASS_EL_WARRIOR:
					case CLASS_EL_BLADE:
					case CLASS_EL_PROTECTOR:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_ROGUE:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_ROGUE:
					case CLASS_KA_HUNTER:
					case CLASS_KA_PENETRATOR:
					case CLASS_EL_ROGUE:
					case CLASS_EL_RANGER:
					case CLASS_EL_ASSASIN:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_WIZARD:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_WIZARD:
					case CLASS_KA_SORCERER:
					case CLASS_KA_NECROMANCER:
					case CLASS_EL_WIZARD:
					case CLASS_EL_MAGE:
					case CLASS_EL_ENCHANTER:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_PRIEST:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_PRIEST:
					case CLASS_KA_SHAMAN:
					case CLASS_KA_DARKPRIEST:
					case CLASS_EL_PRIEST:
					case CLASS_EL_CLERIC:
					case CLASS_EL_DRUID:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_ATTACK_WARRIOR:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_BERSERKER:
					case CLASS_EL_BLADE:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_DEFEND_WARRIOR:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_GUARDIAN:
					case CLASS_EL_PROTECTOR:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_ARCHER:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_HUNTER:
					case CLASS_EL_RANGER:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_ASSASSIN:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_PENETRATOR:
					case CLASS_EL_ASSASIN:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_ATTACK_WIZARD:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_SORCERER:
					case CLASS_EL_MAGE:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_PET_WIZARD:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_NECROMANCER:
					case CLASS_EL_ENCHANTER:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_HEAL_PRIEST:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_SHAMAN:
					case CLASS_EL_CLERIC:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			case CLASS_KINDOF_CURSE_PRIEST:
				switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
				{
					case CLASS_KA_DARKPRIEST:
					case CLASS_EL_DRUID:
						m_pStr[iIndex]->SetColor(m_CWhite);
						break;
					default:
						m_pStr[iIndex]->SetColor(m_CRed);
						break;
				}
				break;

			default:
				if (SetTooltipTextColor(CGameBase::s_pPlayer->m_InfoBase.eClass, eClass))
					m_pStr[iIndex]->SetColor(m_CWhite);
				else
					m_pStr[iIndex]->SetColor(m_CRed);
				break;
		}					

		iIndex++;
	}
	ERROR_EXCEPTION

	if (spItem->pItemBasic->siDamage+spItem->pItemExt->siDamage != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DAMAGE,
			spItem->pItemBasic->siDamage + spItem->pItemExt->siDamage);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if (spItem->pItemBasic->siAttackInterval * (float) ((float) spItem->pItemExt->siAttackIntervalPercentage / 100.0f) != 0)
	{
		float fValue = spItem->pItemBasic->siAttackInterval * (float) ((float) spItem->pItemExt->siAttackIntervalPercentage / 100.0f);

		if ((0 <= fValue) && (fValue <= 89))
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKINT_VERYFAST);
		else if ((90 <= fValue) && (fValue <= 110))
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKINT_FAST);
		else if ((111 <= fValue) && (fValue <= 130))
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKINT_NORMAL);
		else if ((131 <= fValue) && (fValue <= 150))
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKINT_SLOW);
		else
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKINT_VERYSLOW);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	// 공격시간 감소 없어짐..

	if (spItem->pItemBasic->siAttackRange != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTACKRANGE,
			(float) spItem->pItemBasic->siAttackRange / 10.0f);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siHitRate != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_HITRATE_OVER,
			spItem->pItemExt->siHitRate);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siEvationRate != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_AVOIDRATE_OVER,
			spItem->pItemExt->siEvationRate);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemBasic->siWeight != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_WEIGHT,
			spItem->pItemBasic->siWeight * 0.1f);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemBasic->siMaxDurability+spItem->pItemExt->siMaxDurability != 1)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_MAX_DURABILITY,
			spItem->pItemBasic->siMaxDurability + spItem->pItemExt->siMaxDurability);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_CUR_DURABILITY,
			spItem->iDurability);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemBasic->siDefense+spItem->pItemExt->siDefense != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE,
			spItem->pItemBasic->siDefense + spItem->pItemExt->siDefense);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CWhite);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateDagger != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_DAGGER,
			spItem->pItemExt->siDefenseRateDagger);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateSword != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_SWORD,
			spItem->pItemExt->siDefenseRateSword);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateBlow != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_BLOW,
			spItem->pItemExt->siDefenseRateBlow);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateAxe != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_AXE,
			spItem->pItemExt->siDefenseRateAxe);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateSpear != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_SPEAR,
			spItem->pItemExt->siDefenseRateSpear);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siDefenseRateArrow != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_DEFENSE_RATE_ARROW,
			spItem->pItemExt->siDefenseRateArrow);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byDamageFire != 0)	// 화염속성
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC1,
			spItem->pItemExt->byDamageFire);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byDamageIce != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC2,
			spItem->pItemExt->byDamageIce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byDamageThuner != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC3,
			spItem->pItemExt->byDamageThuner);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byDamagePoison != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC4,
			spItem->pItemExt->byDamagePoison);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byStillHP != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC5,
			spItem->pItemExt->byStillHP);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byDamageMP != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC6,
			spItem->pItemExt->byDamageMP);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->byStillMP != 0)	
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_ATTRMAGIC7,
			spItem->pItemExt->byStillMP);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusStr != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSSTR,
			spItem->pItemExt->siBonusStr);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusSta != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSSTA,
			spItem->pItemExt->siBonusSta);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusHP != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSHP,
			spItem->pItemExt->siBonusHP);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusDex != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSDEX,
			spItem->pItemExt->siBonusDex);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusMSP != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSWIZ,
			spItem->pItemExt->siBonusMSP);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusInt != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSINT,
			spItem->pItemExt->siBonusInt);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siBonusMagicAttak != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BONUSMAGICATTACK,
			spItem->pItemExt->siBonusMagicAttak);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistFire != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTFIRE,
			spItem->pItemExt->siRegistFire);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistIce != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTICE,
			spItem->pItemExt->siRegistIce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistElec != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTELEC,
			spItem->pItemExt->siRegistElec);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistMagic != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTMAGIC,
			spItem->pItemExt->siRegistMagic);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistPoison != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTPOISON,
			spItem->pItemExt->siRegistPoison);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( spItem->pItemExt->siRegistCurse != 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_REGISTCURSE,
			spItem->pItemExt->siRegistCurse);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		m_pStr[iIndex]->SetColor(m_CGreen);
		iIndex++;
	}
	ERROR_EXCEPTION

	if( /*(spItem->pItemBasic->byAttachPoint == ITEM_LIMITED_EXHAUST) &&*/ spItem->pItemBasic->cNeedLevel+spItem->pItemExt->siNeedLevel > 1)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDLEVEL,
			spItem->pItemBasic->cNeedLevel + spItem->pItemExt->siNeedLevel);

		if (SetTooltipTextColor(CGameBase::s_pPlayer->m_InfoBase.iLevel, spItem->pItemBasic->cNeedLevel + spItem->pItemExt->siNeedLevel))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);
		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
		iIndex++;
	}
	ERROR_EXCEPTION

	if ((spItem->pItemBasic->byNeedRank + spItem->pItemExt->siNeedRank) > 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDRANK,
			spItem->pItemBasic->byNeedRank + spItem->pItemExt->siNeedRank);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iRank, spItem->pItemBasic->byNeedRank+spItem->pItemExt->siNeedRank))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);
		iIndex++;
	}
	ERROR_EXCEPTION

	if ((spItem->pItemBasic->byNeedTitle + spItem->pItemExt->siNeedTitle) > 0)
	{
		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDTITLE,
			// TODO: Use title name here.
			std::to_string(spItem->pItemBasic->byNeedTitle + spItem->pItemExt->siNeedTitle));

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iTitle, spItem->pItemBasic->byNeedTitle+spItem->pItemExt->siNeedTitle))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	int iNeedValue;
	iNeedValue = spItem->pItemBasic->byNeedStrength;
	if (iNeedValue != 0)
		iNeedValue += spItem->pItemExt->siNeedStrength;
	if( iNeedValue > 0)
	{
		std::string szReduce;
		if (spItem->pItemExt->siNeedStrength < 0)
		{
			if (spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE_REVERSE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE_REVERSE)
				szReduce = fmt::format_text_resource(IDS_TOOLTIP_REDUCE);
		}

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDSTRENGTH,
			spItem->pItemBasic->byNeedStrength + spItem->pItemExt->siNeedStrength, szReduce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iStrength, spItem->pItemBasic->byNeedStrength+spItem->pItemExt->siNeedStrength))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	iNeedValue = spItem->pItemBasic->byNeedStamina;
	if (iNeedValue != 0)
		iNeedValue += spItem->pItemExt->siNeedStamina;
	if( iNeedValue > 0)		
	{
		std::string szReduce;
		if (spItem->pItemExt->siNeedStamina < 0)
		{
			if (spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE_REVERSE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE_REVERSE)
				szReduce = fmt::format_text_resource(IDS_TOOLTIP_REDUCE);
		}

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDSTAMINA,
			spItem->pItemBasic->byNeedStamina + spItem->pItemExt->siNeedStamina, szReduce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iStamina, spItem->pItemBasic->byNeedStamina+spItem->pItemExt->siNeedStamina)) 
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	iNeedValue = spItem->pItemBasic->byNeedDexterity;
	if (iNeedValue != 0)
		iNeedValue += spItem->pItemExt->siNeedDexterity;
	if( iNeedValue > 0)		
	{
		std::string szReduce;
		if (spItem->pItemExt->siNeedDexterity < 0)
		{
			if (spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE_REVERSE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE_REVERSE)
				szReduce = fmt::format_text_resource(IDS_TOOLTIP_REDUCE);
		}

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDDEXTERITY,
			spItem->pItemBasic->byNeedDexterity + spItem->pItemExt->siNeedDexterity, szReduce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iDexterity, spItem->pItemBasic->byNeedDexterity+spItem->pItemExt->siNeedDexterity))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	iNeedValue = spItem->pItemBasic->byNeedInteli;
	if (iNeedValue != 0)
		iNeedValue += spItem->pItemExt->siNeedInteli;
	if( iNeedValue > 0)			
	{
		std::string szReduce;
		if (spItem->pItemExt->siNeedInteli < 0)
		{
			if (spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE_REVERSE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE_REVERSE)
				szReduce = fmt::format_text_resource(IDS_TOOLTIP_REDUCE);
		}

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDINTELLI,
			spItem->pItemBasic->byNeedInteli + spItem->pItemExt->siNeedInteli, szReduce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iIntelligence, spItem->pItemBasic->byNeedInteli+spItem->pItemExt->siNeedInteli))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	iNeedValue = spItem->pItemBasic->byNeedMagicAttack;
	if (iNeedValue != 0)
		iNeedValue += spItem->pItemExt->siNeedMagicAttack;
	if( iNeedValue > 0)			
	{
		std::string szReduce;
		if (spItem->pItemExt->siNeedMagicAttack < 0)
		{
			if (spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UNIQUE_REVERSE
				|| spItem->pItemExt->byMagicOrRare == ITEM_ATTRIB_UPGRADE_REVERSE)
				szReduce = fmt::format_text_resource(IDS_TOOLTIP_REDUCE);
		}

		m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_NEEDMAGICATTACK,
			spItem->pItemBasic->byNeedMagicAttack + spItem->pItemExt->siNeedMagicAttack, szReduce);

		m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

		if (SetTooltipTextColor(pInfoExt->iMagicAttak, spItem->pItemBasic->byNeedMagicAttack+spItem->pItemExt->siNeedMagicAttack))
			m_pStr[iIndex]->SetColor(m_CWhite);
		else
			m_pStr[iIndex]->SetColor(m_CRed);

		iIndex++;
	}
	ERROR_EXCEPTION

	if (spItem->pItemBasic != nullptr)
	{
		const std::string& szRemark = spItem->pItemBasic->szRemark;
	
		if (!szRemark.empty())
		{
			size_t totalWords = 1;
			for (char c : szRemark)
			{
				if (c == ' ')
					++totalWords;
			}

			if (totalWords >= MIN_WORDS_TO_SPLIT_DESC)
			{
				size_t wordsInFirstHalf = (totalWords + 1) / 2;
				size_t wordsSeen = 1, splitPos = std::string::npos;
				for (size_t i = 0; i < szRemark.size(); i++)
				{
					if (szRemark[i] != ' ')
						continue;

					if (++wordsSeen > wordsInFirstHalf)
					{
						splitPos = i;
						break;
					}
				}

				_ASSERT(splitPos != std::string::npos);

				m_pStr[iIndex]->SetColor(m_CWhite);
				m_pstdstr[iIndex] = fmt::format("*{}", std::string_view(szRemark.data(), splitPos));
				m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);

				iIndex++;
				ERROR_EXCEPTION

				// NOTE: This doesn't perfectly match official's behaviour; they rebuild the lines, always appending a space.
				// This means that there's a guaranteed space after the word here, before the '*'
				// To replicate this behaviour, we can manually add a space in the format string, but it's not really necessary.
				m_pStr[iIndex]->SetColor(m_CWhite);
				m_pstdstr[iIndex] = fmt::format("{}*", std::string_view(szRemark.data() + splitPos, szRemark.size() - splitPos));
				m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);

				iIndex++;
			}
			else
			{
				m_pStr[iIndex]->SetColor(m_CWhite);
				m_pstdstr[iIndex] = fmt::format("*{}*", szRemark);
				m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);

				iIndex++;
			}
		}
	}
	ERROR_EXCEPTION

	if (spItem->pItemExt != nullptr)
	{
		e_ItemAttrib eTA = (e_ItemAttrib) (spItem->pItemExt->byMagicOrRare);
		switch (eTA)
		{
			case ITEM_ATTRIB_UNIQUE:
				m_pStr[iIndex]->SetColor(m_CGreen);
				m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_UNIQUE);
				m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNCENTER);
				iIndex++;
				break;

			case ITEM_ATTRIB_UPGRADE:
				if (spItem->pItemBasic != nullptr && spItem->pItemExt != nullptr)
				{
					const int iItemGrade = (std::min)(3, spItem->pItemBasic->byGrade + spItem->pItemExt->bySoulBind);
					if (iItemGrade == ITEM_GRADE_LOW_CLASS)
						m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_LOW_CLASS);
					else if (iItemGrade == ITEM_GRADE_MIDDLE_CLASS)
						m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_MIDDLE_CLASS);
					else if (iItemGrade == ITEM_GRADE_HIGH_CLASS)
						m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_HIGH_CLASS);
					else
						break;

					m_pStr[iIndex]->SetColor(m_CGreen);
					m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
					iIndex++;
				}
				break;
		}
	}
	ERROR_EXCEPTION

exceptions:;

	if (bPrice)
	{
		if (bBuy)	
		{
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_BUY_PRICE,
				CGameBase::FormatNumber(spItem->GetBuyPrice()));

			m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);

			if (SetTooltipTextColor(pInfoExt->iGold, spItem->pItemBasic->iPrice*spItem->pItemExt->siPriceMultiply))
				m_pStr[iIndex]->SetColor(m_CWhite);
			else
				m_pStr[iIndex]->SetColor(m_CRed);
		}
		else
		{	
			m_pstdstr[iIndex] = fmt::format_text_resource(IDS_TOOLTIP_SELL_PRICE,
				CGameBase::FormatNumber(spItem->GetSellPrice()));

			m_pStr[iIndex]->SetStyle(UI_STR_TYPE_HALIGN, UISTYLE_STRING_ALIGNLEFT);
			m_pStr[iIndex]->SetColor(m_CWhite);
		}

		iIndex++;			
	}

	for (int i = iIndex; i < MAX_TOOLTIP_COUNT; i++)
		m_pstdstr[iIndex].clear();

	return iIndex;	// 임시..	반드시 1보다 크다..
}

void CUIImageTooltipDlg::DisplayTooltipsEnable(int xpos, int ypos, __IconItemSkill* spItem, bool bPrice, bool bBuy)
{
	if (spItem == nullptr)
	{
		ResetItem();
		return;
	}

	if (!IsVisible())
		SetVisible(true);
	
	if (IsItemChanged(spItem))
	{
		UpdateItem(spItem);

		m_iTooltipNum = CalcTooltipStringNumAndWrite(spItem, bPrice, bBuy);
		SetPosSomething(xpos, ypos);
	}
	else if (m_iPosXBack != xpos
		|| m_iPosYBack != ypos)
	{
		SetPosSomething(xpos, ypos);
	}

	Render();
}

bool CUIImageTooltipDlg::IsItemChanged(const __IconItemSkill* spItem) const
{
	if (m_dwID_Basic == spItem->pItemBasic->dwID
		&& m_dwID_Ext == spItem->pItemExt->dwID
		&& m_iDurability == spItem->iDurability
		&& m_iCount == spItem->iCount)
		return false;

	return true;
}

void CUIImageTooltipDlg::UpdateItem(const __IconItemSkill* spItem)
{
	if (spItem == nullptr
		|| spItem->pItemBasic == nullptr)
	{
		ResetItem();
		return;
	}

	m_dwID_Basic = spItem->pItemBasic->dwID;

	if (spItem->pItemExt != nullptr)
		m_dwID_Ext = spItem->pItemExt->dwID;
	else
		m_dwID_Ext = 0;

	m_iCount = spItem->iCount;
	m_iDurability = spItem->iDurability;
}

void CUIImageTooltipDlg::ResetItem()
{
	m_dwID_Basic = 0;
	m_dwID_Ext = 0;
	m_iCount = 0;
	m_iDurability = 0;
}

// ===== END WarFare/UIImageTooltipDlg.cpp =====

// ===== BEGIN WarFare/UIImageTooltipDlg.h =====
#line 1 "WarFare/UIImageTooltipDlg.h"
﻿// UIImageTooltipDlg.h: interface for the CUIImageTooltipDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIIMAGETOOLTIPDLG_H__CC12484D_5DC0_4F7A_ABF7_0506B2F36292__INCLUDED_)
#define AFX_UIIMAGETOOLTIPDLG_H__CC12484D_5DC0_4F7A_ABF7_0506B2F36292__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#include "N3UIWndBase.h" // __IconItemSkill

//////////////////////////////////////////////////////////////////////

class CUIImageTooltipDlg : public CN3UIBase
{
	static constexpr int MAX_TOOLTIP_COUNT			= 30;
	static constexpr int MIN_WORDS_TO_SPLIT_DESC	= 5;

	const D3DCOLOR		m_CYellow;	// 레어...
	const D3DCOLOR		m_CBlue;	// 매직...	
	const D3DCOLOR		m_CGold;	// 유니크...
	const D3DCOLOR		m_CIvory;	// 업그레이드..
	const D3DCOLOR		m_CGreen;	// 옵션...	저항력, 능력치 상승, 마법속성..
	const D3DCOLOR		m_CWhite;	// 일반...
	const D3DCOLOR		m_CRed;		// 뭔가 제한에 걸릴때..
public:
	CN3UIString*		m_pStr[MAX_TOOLTIP_COUNT];			// 스트륑.. ^^
	std::string			m_pstdstr[MAX_TOOLTIP_COUNT];
	CN3UIImage*			m_pImg;

	int					m_iPosXBack;
	int					m_iPosYBack;
	int					m_iTooltipNum;

	uint32_t			m_dwID_Basic;
	uint32_t			m_dwID_Ext;
	int					m_iCount;
	int					m_iDurability;

protected:
	bool				SetTooltipTextColor(int iMyValue, int iTooltipValue);
	bool				SetTooltipTextColor(e_Race eMyValue, e_Race eTooltipValue);
	bool				SetTooltipTextColor(e_Class eMyValue, e_Class eTooltipValue);
	int					CalcTooltipStringNumAndWrite(__IconItemSkill* spItem, bool bPrice, bool bBuy);
	void				SetPosSomething(int xpos, int ypos);

public:
	CUIImageTooltipDlg();
	~CUIImageTooltipDlg() override;
	void	Release() override;
	void	InitPos();

	void	DisplayTooltipsEnable(int xpos, int ypos, __IconItemSkill* spItem, bool bPrice = false, bool bBuy = true);
	void	DisplayTooltipsDisable();

protected:
	bool	IsItemChanged(const __IconItemSkill* spItem) const;
	void	UpdateItem(const __IconItemSkill* spItem);
	void	ResetItem();
};

#endif // !defined(AFX_UIIMAGETOOLTIPDLG_H__CC12484D_5DC0_4F7A_ABF7_0506B2F36292__INCLUDED_)

// ===== END WarFare/UIImageTooltipDlg.h =====

// ===== BEGIN WarFare/UIInn.cpp =====
#line 1 "WarFare/UIInn.cpp"
﻿// UINPCEvent.cpp: implementation of the UINPCEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "text_resources.h"
#include "UIInn.h"
#include "UICreateClanName.h"

#include "GameProcMain.h"
#include "GameProcedure.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "PlayerMySelf.h"
#include "UITradeBBSSelector.h"
#include "UIManager.h"

//#include "StdAfxBase.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIInn::CUIInn()
{
}

CUIInn::~CUIInn()
{
}

bool CUIInn::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender->m_szID == "btn_warehouse")	//창고이용..
		{
			MsgSend_OpenWareHouse();
			SetVisible(false);
			return true;
		}

		if (pSender->m_szID == "btn_makeclan")	//clan 생성..
		{
			__InfoPlayerBase* pInfo = &CGameBase::s_pPlayer->m_InfoBase;
			__InfoPlayerMySelf* pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

			if (pInfo->iLevel < CLAN_LEVEL_LIMIT)
			{
				Message(IDS_CLAN_DENY_LOWLEVEL);
				SetVisible(false);
				return true;
			}

			if (pInfoExt->iGold < CLAN_COST)
			{
				Message(IDS_CLAN_DENY_LOWGOLD);
				SetVisible(false);
				return true;
			}

			if (pInfo->iKnightsID != 0)
			{
				Message(IDS_CLAN_DENY_ALREADYJOINED);
				SetVisible(false);
				return true;
			}

			CGameProcedure::s_pProcMain->m_pUICreateClanName->Open(IDS_CLAN_INPUT_NAME);
			SetVisible(false);
			return true;
		}
		else if (pSender->m_szID == "btn_sale")
		{
			CGameProcedure::s_pProcMain->m_pUITradeBBSSelector->MsgSend_OpenTradeSellBBS();
			SetVisible(false);
			return true;
		}

	}
	return true;
}

void CUIInn::Message(int iMessageID)
{
	std::string szMsg;

	if (iMessageID == IDS_CLAN_DENY_LOWGOLD)
		szMsg = fmt::format_text_resource(iMessageID, CLAN_COST);
	else
		szMsg = fmt::format_text_resource(iMessageID);

	CGameProcedure::MessageBoxPost(szMsg, "", MB_OK, BEHAVIOR_NOTHING);	
}

void CUIInn::MsgSend_OpenWareHouse()
{
	uint8_t byBuff[2];		// 패킷 버퍼..
	int iOffset=0;		// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WAREHOUSE);		
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_WARE_OPEN);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIInn::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

bool CUIInn::OnKeyPress(int iChar)
{
	switch(iChar)
	{
	case DIK_ESCAPE:
		SetVisible(false);
		return true;
	}

	return CN3UIBase::OnKeyPress(iChar);
}

// ===== END WarFare/UIInn.cpp =====

// ===== BEGIN WarFare/UIInn.h =====
#line 1 "WarFare/UIInn.h"
﻿// UIInn.h: interface for the UIInn class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__UIINN_H__)
#define __UIINN_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUIInn : public CN3UIBase
{	
public:
	bool OnKeyPress(int iChar);
	void SetVisible(bool bVisible);
	void Message(int iMessageID);

	void MsgSend_OpenWareHouse();

	CUIInn();
	virtual ~CUIInn();

	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg);
};

#endif //#if !defined(__UIINN_H__)

// ===== END WarFare/UIInn.h =====

// ===== BEGIN WarFare/UIInventory.cpp =====
#line 1 "WarFare/UIInventory.cpp"
﻿// UIInventory.cpp: implementation of the CUIInventory class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIInventory.h"
#include "PlayerMySelf.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "UITransactionDlg.h"
#include "UIImageTooltipDlg.h"
#include "UIManager.h"
#include "SubProcPerTrade.h"
#include "UITradeEditDlg.h"
#include "UIPerTradeDlg.h"
#include "CountableItemEditDlg.h"
#include "UIRepairTooltipDlg.h"
#include "UIHotKeyDlg.h"
#include "UISkillTreeDlg.h"
#include "MagicSkillMng.h"

#include "text_resources.h"

#include <N3Base/LogWriter.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

static bool g_bItemClassGroup[26][26] = {	// [아이템][플레이어]	
//	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }	// 초기그룹
//	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25
	{ 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 },	// 0번 Group
	{ 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1 },	// 1번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },	// 2번 Group
	{ 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1 },	// 3번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },	// 4번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 },	// 5번 Group
	{ 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 },	// 6번 Group
	{ 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },	// 7번 Group
	{ 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },	// 8번 Group
	{ 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1 },	// 9번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0 },	// 10번 Group
	{ 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1 },	// 11번 Group
	{ 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1 },	// 12번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0 },	// 13번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 },	// 14번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },	// 15번 Group
	{ 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0 },	// 16번 Group
	{ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0 },	// 17번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },	// 18번 Group
	{ 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0 },	// 19번 Group
	{ 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0 },	// 20번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 },	// 21번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1 },	// 22번 Group
	{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1 },	// 23번 Group
	{ 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0 },	// 24번 Group
	{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } };	// 25번 Group (모든 Class)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIInventory::CUIInventory()
{
	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )	m_pMySlot[i] = nullptr;
	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )	m_pMyInvWnd[i] = nullptr;

	m_pUITooltipDlg = nullptr;
	s_bWaitFromServer = false;

	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

	m_bDestoyDlgAlive	= false;
	m_pText_Weight = nullptr;

	m_iRBtnDownOffs = -1;
	m_bRBtnProcessing = false;
}

CUIInventory::~CUIInventory()
{
	Release();
}

void CUIInventory::Release()
{
	CN3UIBase::Release();

	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( m_pMySlot[i] != nullptr )
		{
			delete m_pMySlot[i];
			m_pMySlot[i] = nullptr;
		}
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pMyInvWnd[i] != nullptr )
		{
			delete m_pMyInvWnd[i];
			m_pMyInvWnd[i] = nullptr;
		}
	}

	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..
	m_pText_Weight = nullptr;
}

bool CUIInventory::HasAnyItemInSlot()
{
	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( m_pMySlot[i] != nullptr )
			return true;
	}
	return false;	
}

void CUIInventory::ReleaseItem()
{
	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( m_pMySlot[i] != nullptr )
		{
			if ( m_pMySlot[i]->pUIIcon )
			{
				RemoveChild(m_pMySlot[i]->pUIIcon);
				m_pMySlot[i]->pUIIcon->Release();
				delete m_pMySlot[i]->pUIIcon;
				m_pMySlot[i]->pUIIcon = nullptr;
			}

			delete m_pMySlot[i];	
			m_pMySlot[i] = nullptr;
		}
	}

	for(int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pMyInvWnd[i] != nullptr )
		{
			if ( m_pMyInvWnd[i]->pUIIcon )
			{
				RemoveChild(m_pMyInvWnd[i]->pUIIcon);
				m_pMyInvWnd[i]->pUIIcon->Release();
				delete m_pMyInvWnd[i]->pUIIcon;
				m_pMyInvWnd[i]->pUIIcon = nullptr;
			}

			delete m_pMyInvWnd[i];
			m_pMyInvWnd[i] = nullptr;
		}
	}
}

void CUIInventory::Open(e_InvenState eIS)
{
	m_eInvenState = eIS;
	if ( eIS == INV_STATE_REPAIR )
	{
		CGameProcedure::SetGameCursor(CGameProcedure::s_hCursorPreRepair, true);
	}

	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
	
	// 스르륵 열린다!!
	SetVisible(true);
	this->SetPos(CN3Base::s_CameraData.vp.Width, 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = true;
	m_bClosingNow = false;

	m_iRBtnDownOffs = -1;
}

void CUIInventory::GoldUpdate()
{
	CN3UIString* pUITextGold;

	N3_VERIFY_UI_COMPONENT(pUITextGold, GetChildByID<CN3UIString>("text_gold"));

	if (pUITextGold != nullptr)
	{
		std::string szTemp;
		szTemp = CGameBase::FormatNumber(CGameBase::s_pPlayer->m_InfoExt.iGold);
		pUITextGold->SetString(szTemp);
	}
}

void CUIInventory::Close(bool bByKey)
{
	if ( m_eInvenState == INV_STATE_REPAIR )
	{
		if (bByKey) return;
		CGameProcedure::RestoreGameCursor();

		if (CGameProcedure::s_pProcMain->m_pUIRepairTooltip->IsVisible())
		{
			CGameProcedure::s_pProcMain->m_pUIRepairTooltip->m_bBRender = false;
			CGameProcedure::s_pProcMain->m_pUIRepairTooltip->DisplayTooltipsDisable();
		}
	}

	m_eInvenState = INV_STATE_NORMAL;

	if (GetState() == UI_STATE_ICON_MOVING)
		IconRestore();
	SetState(UI_STATE_COMMON_NONE);
	CN3UIWndBase::AllHighLightIconFree();

	// 스르륵 닫힌다..!!
//	SetVisible(false); // 다 닫히고 나서 해준다..
	RECT rc = this->GetRegion();
	this->SetPos(CN3Base::s_CameraData.vp.Width - (rc.right - rc.left), 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = false;
	m_bClosingNow = true;

	if(m_pSnd_CloseUI) m_pSnd_CloseUI->Play(); // 닫는 소리..

	m_iRBtnDownOffs = -1;
}

void CUIInventory::Tick()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 tick하지 않는다.

	if(m_bOpenningNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width - (int)fWidth;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)m_fMoveDelta;
		if(ptCur.x <= iXLimit) // 다열렸다!!
		{
			ptCur.x = iXLimit;
			m_bOpenningNow = false;
		}

		this->SetPos(ptCur.x, ptCur.y);

		CN3UIWndBase::AllHighLightIconFree();
	}
	else if(m_bClosingNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)(fWidth - m_fMoveDelta);
		if(ptCur.x >= iXLimit) // 다 닫혔다..!!
		{
			ptCur.x = iXLimit;
			m_bClosingNow = false;

			this->SetVisibleWithNoSound(false, false, true); // 다 닫혔으니 눈에서 안보이게 한다.
		}

		this->SetPos(ptCur.x, ptCur.y);

		CN3UIWndBase::AllHighLightIconFree();
	}

	CGameBase::s_pPlayer->InventoryChrTick();
	CN3UIBase::Tick();
	CGameBase::s_pPlayer->m_ChrInv.m_nLOD = 1;

	m_cItemRepairMgr.Tick();
}

void CUIInventory::Render()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	m_pUITooltipDlg->DisplayTooltipsDisable();
	RECT rUser = m_pArea_User->GetRegion();

	bool bTooltipRender = false;
	__IconItemSkill* spItem = nullptr;

	RECT rcRegion;
	SetRect(&rcRegion, rUser.left, rUser.top, rUser.right, rUser.bottom);			// 영역 지정
	char strDummy[32];
	lstrcpy(strDummy, "elmo_ecli666");

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( (m_szID != "Base_Iteminfo") && (pChild->GetID() != "area_samma") )
		{
			if ( (GetState() == UI_STATE_ICON_MOVING) && (pChild->UIType() == UI_TYPE_ICON) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) &&
				((CN3UIIcon *)pChild == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon) )	continue;
			pChild->Render();
		}
		if ( pChild->m_szID == strDummy )
			CGameBase::s_pPlayer->InventoryChrRender(rcRegion);
		if ( (pChild->UIType() == UI_TYPE_ICON) && (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT)  && (!m_bOpenningNow) && (!m_bClosingNow))
		{
			bTooltipRender = true;
			spItem = GetHighlightIconItem( (CN3UIIcon* )pChild );
		}
	}

	if (m_bDestoyDlgAlive)
		m_pArea_Destroy->Render();

	if ( (GetState() == UI_STATE_ICON_MOVING) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect))
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->Render();		

	// 갯수 표시되야 할 아이템 갯수 표시..
	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if (m_pMyInvWnd[i] != nullptr
			&& ((m_pMyInvWnd[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE)
				|| (m_pMyInvWnd[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
				|| (m_pMyInvWnd[i]->pItemBasic->byClass == ITEM_CLASS_CONSUMABLE)))
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
			{
				if ( (GetState() == UI_STATE_ICON_MOVING) && (m_pMyInvWnd[i] == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				{
					pStr->SetVisible(false);
				}
				else
				{
					if ( m_pMyInvWnd[i]->pUIIcon->IsVisible() )
					{
						pStr->SetVisible(true);
						
						if (m_pMyInvWnd[i]->pItemBasic->byClass == ITEM_CLASS_CONSUMABLE)
							pStr->SetStringAsInt(m_pMyInvWnd[i]->iDurability);
						else
							pStr->SetStringAsInt(m_pMyInvWnd[i]->iCount);
						
						pStr->Render();
					}
					else
					{
						pStr->SetVisible(false);
					}
				}
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
				pStr->SetVisible(false);
		}
	}

	// 수리모드이면.. 리턴;
	if (m_eInvenState == INV_STATE_REPAIR) { CGameProcedure::s_pProcMain->m_pUIRepairTooltip->Render(); return;	}
	
	if ( bTooltipRender && spItem )
		m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem );
}

void CUIInventory::InitIconWnd(e_UIWND eWnd)
{
	N3_VERIFY_UI_COMPONENT(m_pArea_User, GetChildByID<CN3UIArea>("area_char"));
	if(nullptr == m_pArea_User) return;

	N3_VERIFY_UI_COMPONENT(m_pArea_Destroy, GetChildByID<CN3UIArea>("area_samma"));
	if(nullptr == m_pArea_Destroy) return;

	N3_VERIFY_UI_COMPONENT(m_pText_Weight, GetChildByID<CN3UIString>("text_weight"));
	__TABLE_UI_RESRC* pTblUI = CGameBase::s_pTbl_UI.Find(CGameBase::s_pPlayer->m_InfoBase.eNation);
	__ASSERT(pTblUI, "NULL Pointer UI Table");

	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(pTblUI->szItemInfo);
	m_pUITooltipDlg->InitPos();
	m_pUITooltipDlg->SetVisible(FALSE);	

	CN3UIWndBase::InitIconWnd(eWnd);
}

void CUIInventory::UpdateWeight(std::string str)
{
	if(nullptr == m_pText_Weight) return;

	m_pText_Weight->SetString(str);
}

void CUIInventory::InitIconUpdate()
{
	CN3UIArea* pArea;
	float fUVAspect = (float)45.0f/(float)64.0f;

	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( m_pMySlot[i] != nullptr )
		{
			m_pMySlot[i]->pUIIcon = new CN3UIIcon;
			m_pMySlot[i]->pUIIcon->Init(this);
			m_pMySlot[i]->pUIIcon->SetTex(m_pMySlot[i]->szIconFN);
			m_pMySlot[i]->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
			m_pMySlot[i]->pUIIcon->SetUIType(UI_TYPE_ICON);
			m_pMySlot[i]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, i);
			if ( pArea )
			{
				m_pMySlot[i]->pUIIcon->SetRegion(pArea->GetRegion());
				m_pMySlot[i]->pUIIcon->SetMoveRect(pArea->GetRegion());
			}
			if ( m_pMySlot[i]->iDurability == 0 )
				m_pMySlot[i]->pUIIcon->SetStyle(m_pMySlot[i]->pUIIcon->GetStyle() | UISTYLE_DURABILITY_EXHAUST);	
		}
	}

	for(int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pMyInvWnd[i] != nullptr )
		{
			m_pMyInvWnd[i]->pUIIcon = new CN3UIIcon;
			m_pMyInvWnd[i]->pUIIcon->Init(this);
			m_pMyInvWnd[i]->pUIIcon->SetTex(m_pMyInvWnd[i]->szIconFN);
			m_pMyInvWnd[i]->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
			m_pMyInvWnd[i]->pUIIcon->SetUIType(UI_TYPE_ICON);
			m_pMyInvWnd[i]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
			if ( pArea )
			{
				m_pMyInvWnd[i]->pUIIcon->SetRegion(pArea->GetRegion());
				m_pMyInvWnd[i]->pUIIcon->SetMoveRect(pArea->GetRegion());
			}
			if ( m_pMyInvWnd[i]->iDurability == 0 )
				m_pMyInvWnd[i]->pUIIcon->SetStyle(m_pMyInvWnd[i]->pUIIcon->GetStyle() | UISTYLE_DURABILITY_EXHAUST);	
		}
	}
}

__IconItemSkill* CUIInventory::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( (m_pMySlot[i] != nullptr) && (m_pMySlot[i]->pUIIcon == pUIIcon) )
			return m_pMySlot[i];
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( (m_pMyInvWnd[i] != nullptr) && (m_pMyInvWnd[i]->pUIIcon == pUIIcon) )
			return m_pMyInvWnd[i];
	}
	return nullptr;
}

e_UIWND_DISTRICT CUIInventory::GetWndDistrict(__IconItemSkill* spItem)
{
	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if ( (m_pMySlot[i] != nullptr) && (m_pMySlot[i] == spItem) )
			return UIWND_DISTRICT_INVENTORY_SLOT;
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( (m_pMyInvWnd[i] != nullptr) && (m_pMyInvWnd[i] == spItem) )
			return UIWND_DISTRICT_INVENTORY_INV;
	}
	return UIWND_DISTRICT_UNKNOWN;
}

int CUIInventory::GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist)
{
	int iReturn = -1;
	int i;

	switch ( eWndDist )
	{
		case UIWND_DISTRICT_INVENTORY_SLOT:
			for( i = 0; i < ITEM_SLOT_COUNT; i++ )
			{
				if ( (m_pMySlot[i] != nullptr) && (m_pMySlot[i] == spItem) )
					return i;
			}
			break;

		case UIWND_DISTRICT_INVENTORY_INV:
			for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
			{
				if ( (m_pMyInvWnd[i] != nullptr) && (m_pMyInvWnd[i] == spItem) )
					return i;
			}
			break;
	}

	return iReturn;
}

RECT CUIInventory::GetSampleRect()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, 0);
	rect = pArea->GetRegion();
	float fWidth = (float)(rect.right - rect.left);
	float fHeight = (float)(rect.bottom - rect.top);
	fWidth *= 0.5f; fHeight *= 0.5f;
	rect.left = ptCur.x - (int)fWidth;  rect.right  = ptCur.x + (int)fWidth;
	rect.top  = ptCur.y - (int)fHeight; rect.bottom = ptCur.y + (int)fHeight;
	return rect;
}

uint32_t CUIInventory::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;
	if (s_bWaitFromServer) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	// 수리모드이면.. 리턴;
	if (m_eInvenState == INV_STATE_REPAIR) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	if (m_bDestoyDlgAlive)	
	{ 
		CN3UIImage* pImg = nullptr;
		N3_VERIFY_UI_COMPONENT(pImg, m_pArea_Destroy->GetChildByID<CN3UIImage>("img_Destroy"));

		if (!pImg) return dwRet;
		if (!pImg->IsIn(ptCur.x, ptCur.y))
		{
			//this_ui_add_start
			//파괴하는 창이 열려있을때 그창을 벗어나서 인벤토리창에서 클릭과 같은 행동을 하면 캐릭터가 이동을 해서 방지하는 차원에서...
			if(IsIn(ptCur.x, ptCur.y))
				dwRet |= UI_MOUSEPROC_INREGION;
			//this_ui_add_end

			return dwRet;
		}

		for ( int i = 0; i < m_pArea_Destroy->GetChildrenCount(); i++ )
		{
			CN3UIBase* pChild = m_pArea_Destroy->GetChildByIndex(i);
			if (pChild)	
				dwRet |= pChild->MouseProc(dwFlags, ptCur, ptOld);  
		}
		return dwRet;
	}

	// 드래그 되는 아이콘 갱신..
	if ( (GetState() == UI_STATE_ICON_MOVING) && 
			(CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd == UIWND_INVENTORY) &&
			(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
	{
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
	}

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

void CUIInventory::SendInvMsg(uint8_t bDir, int iItemID, int SrcPos, int DestPos)
{
	uint8_t byBuff[100];												// 버퍼.. 
	int iOffset=0;												// 옵셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_MOVE);				// Item Move
	CAPISocket::MP_AddByte(byBuff, iOffset, bDir);						
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemID);					
	CAPISocket::MP_AddByte(byBuff, iOffset, (byte)SrcPos);				
	CAPISocket::MP_AddByte(byBuff, iOffset, (byte)DestPos);						

	//TRACE("Send Inv Move %d, %d, %d, %d \n", bDir, iItemID, SrcPos, DestPos );

	CGameProcedure::s_pProcMain->s_pSocket->Send(byBuff, iOffset);									// 보냄..
}

int CUIInventory::GetInvDestinationIndex(__IconItemSkill* spItem)
{
	if( CN3UIWndBase::s_sSelectedIconInfo.pItemSelect == nullptr )
		return false;

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if (!m_pMyInvWnd[i])
			return i;
	}

	return -1;
}

int	CUIInventory::GetArmDestinationIndex(__IconItemSkill* spItem)
{
	if( CN3UIWndBase::s_sSelectedIconInfo.pItemSelect == nullptr )
		return false;

	__TABLE_ITEM_BASIC*		pItem;
	__TABLE_ITEM_EXT* pItemExt = nullptr;
	pItem = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic;
	pItemExt = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt;

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
	if(ITEM_TYPE_UNKNOWN == eType) return false;

	if ( IsValidRaceAndClass(pItem, CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt) )
	{
		switch ( pItem->byAttachPoint )
		{
			case ITEM_ATTACH_POS_DUAL:
				if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT] && m_pMySlot[ITEM_SLOT_POS_HAND_LEFT])	// 양쪽에 있는 경우..
					return ITEM_SLOT_POS_HAND_RIGHT;				// 둘다 있으면 오른쪽..
				if (!m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT])	// 오른쪽에 없는 경우..
					return ITEM_SLOT_POS_HAND_RIGHT;
				else
				{
					if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]->pItemBasic->byAttachPoint == ITEM_ATTACH_POS_TWOHAND_RIGHT)
						return ITEM_SLOT_POS_HAND_RIGHT;
					else
						return ITEM_SLOT_POS_HAND_LEFT;
				}
				return -1;

			case ITEM_ATTACH_POS_HAND_RIGHT:
				return ITEM_SLOT_POS_HAND_RIGHT;

			case ITEM_ATTACH_POS_HAND_LEFT:
				return ITEM_SLOT_POS_HAND_LEFT;

			case ITEM_ATTACH_POS_TWOHAND_RIGHT:				// 양손검을 오른손에 찰때..
				if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT] && m_pMySlot[ITEM_SLOT_POS_HAND_LEFT])	// 양쪽에 있는 경우..
					return -1;
				else 
					return ITEM_SLOT_POS_HAND_RIGHT;

			case ITEM_ATTACH_POS_TWOHAND_LEFT:				// 양손검을 오른손에 찰때..
				if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT] && m_pMySlot[ITEM_SLOT_POS_HAND_LEFT])	// 양쪽에 있는 경우..
					return -1;
				else 
					return ITEM_SLOT_POS_HAND_LEFT;

			case ITEM_ATTACH_POS_EAR:
				if (!m_pMySlot[ITEM_SLOT_POS_EAR_RIGHT])	// 오른쪽에 없는 경우..
					return ITEM_SLOT_POS_EAR_RIGHT;
				if (!m_pMySlot[ITEM_SLOT_POS_EAR_LEFT])		// 왼쪽에 없는 경우..
					return ITEM_SLOT_POS_EAR_LEFT;
				return ITEM_SLOT_POS_EAR_RIGHT;				// 둘다 있으면 오른쪽..

			case ITEM_ATTACH_POS_HEAD:		
				return ITEM_SLOT_POS_HEAD;

			case ITEM_ATTACH_POS_NECK:		
				return ITEM_SLOT_POS_NECK;

			case ITEM_ATTACH_POS_UPPER:
				return ITEM_SLOT_POS_UPPER;

			case ITEM_ATTACH_POS_CLOAK:
				return ITEM_SLOT_POS_SHOULDER;

			case ITEM_ATTACH_POS_BELT:
				return ITEM_SLOT_POS_BELT;

			case ITEM_ATTACH_POS_FINGER:
				if (!m_pMySlot[ITEM_SLOT_POS_RING_RIGHT])	// 오른쪽에 없는 경우..
					return ITEM_SLOT_POS_RING_RIGHT;
				if (!m_pMySlot[ITEM_SLOT_POS_RING_LEFT])		// 왼쪽에 없는 경우..
					return ITEM_SLOT_POS_RING_LEFT;
				return ITEM_SLOT_POS_RING_RIGHT;				// 둘다 있으면 오른쪽..

			case ITEM_ATTACH_POS_LOWER:
				return ITEM_SLOT_POS_LOWER;

			case ITEM_ATTACH_POS_ARM:
				return ITEM_SLOT_POS_GLOVES;

			case ITEM_ATTACH_POS_FOOT:
				return ITEM_SLOT_POS_SHOES;
			default:
				return -1;
		}
	}			

	return -1;
}

bool CUIInventory::CheckIconDropIfSuccessSendToServer(__IconItemSkill* spItem)
{
	// 먼저 아이템이 들어갈 수 있는지 검사하고..
	bool  bFound = false;
	bool  bArm = true;
	CN3UIArea* pArea;
	int   i, iDestiOrder;

	if (!m_bRBtnProcessing)
	{
		POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
		for( i = 0; i < ITEM_SLOT_COUNT; i++ )
		{
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, i);
			if ( pArea && pArea->IsIn(ptCur.x, ptCur.y) )
			{
				bFound = true;
				bArm = true;
				iDestiOrder = i;
				break;
			}
		}
		if ( !bFound )
		{
			for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
				if ( pArea && pArea->IsIn(ptCur.x, ptCur.y) )
				{
					bFound = true;
					bArm = false;
					iDestiOrder = i;
					break;
				}
			}
		}

		if ( !bFound )		// 못 찾았으면 인벤토리 캐릭터 영역 검색..
		{
			if ( m_pArea_User->IsIn(ptCur.x, ptCur.y) )
			{	
				// 인벤 영역의 아이콘이 아니면.. false return..
				if (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_INV)
				{
					iDestiOrder = GetArmDestinationIndex(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect);
					if (iDestiOrder != -1)
					{
						bFound = true;
						bArm = true;
					}
				}
			}
		}
	}
	else
	{
		if (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_INV)
		{
			iDestiOrder = GetArmDestinationIndex(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect);
			if (iDestiOrder != -1)
			{
				bFound = true;
				bArm = true;
			}
		}
		else
		{
			iDestiOrder = GetInvDestinationIndex(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect);
			if (iDestiOrder != -1)
			{
				bFound = true;
				bArm = false;
			}				
		}
	}

	if ( !bFound )	return false;	// 못 찾았으므로.. 실패..

	// 본격적으로 Recovery Info를 활용하기 시작한다.. 
	// 먼저 WaitFromServer를 On으로 하고.. Select Info를 Recovery Info로 복사..
	s_bWaitFromServer									= true;
	s_sRecoveryJobInfo.pItemSource						= s_sSelectedIconInfo.pItemSelect;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= s_sSelectedIconInfo.UIWndSelect.UIWnd;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict	= s_sSelectedIconInfo.UIWndSelect.UIWndDistrict;
	s_sRecoveryJobInfo.UIWndSourceStart.iOrder			= s_sSelectedIconInfo.UIWndSelect.iOrder;
	s_sRecoveryJobInfo.UIWndSourceEnd.UIWnd				= UIWND_INVENTORY;
	s_sRecoveryJobInfo.pItemTarget						= nullptr;
	// 검사하는 도중에 Recovery Info중에 pItemTarget를 필요하다면 작성하고 false를 리턴할때는 원래대로..

	// Arm -> Arm
	if ( (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_SLOT) && bArm )
	{
		// 기존 아이콘이 있는지 살펴보고 기존 아이템이 없으면..
		if ( !m_pMySlot[iDestiOrder] )
		{
			if ( IsValidPosFromArmToArm(iDestiOrder) )
			{
				// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
				// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_SLOT;				
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

				// Send To Server.. 
				SendInvMsg(0x04, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
				return true;
			}
			else
			{
				s_bWaitFromServer					= false;
				s_sRecoveryJobInfo.pItemSource		= nullptr;
				s_sRecoveryJobInfo.pItemTarget		= nullptr;
				return false;
			}
		}
		// 기존 아이콘이 있으면..
		else
		{
			// 아이콘이 들어갈 수 있으면..
			if ( IsValidPosFromArmToArm(iDestiOrder) )
			{
				// 기존 아이콘 정보를 pItemTarget과 UIWndTargetStart를 셋팅하고..
				CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[iDestiOrder];
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= iDestiOrder;
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;

				// 그 반대도 가능하면..
				if ( IsValidPosFromArmToArmInverse(CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder) )
				{
					// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
					// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_SLOT;				
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_SLOT;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;

					// Send To Server.. 
					SendInvMsg(0x04, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
						CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
						CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
					return true;
				}
			}
			else
			{
				s_bWaitFromServer					= false;
				s_sRecoveryJobInfo.pItemSource		= nullptr;
				s_sRecoveryJobInfo.pItemTarget		= nullptr;
				return false;
			}
		}
	}
	// Arm -> Inv
	else if ( (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_SLOT) && !bArm )
	{
		// 기존 아이콘이 있는지 살펴보고 기존 아이템이 없으면..
		if ( !m_pMyInvWnd[iDestiOrder] )
		{
			// 아이콘은 당연히 들어갈 수 있당.. ^^
			// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
			// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;				
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

			// Send To Server.. 
			SendInvMsg(0x02, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
				CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
			return true;
		}
		// 기존 아이콘이 있으면..
		else
		{
			// 인벤토리 빈슬롯을 찾아 들어간다..
			bFound = false;
			for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
			{
				if ( !m_pMyInvWnd[i] )
				{
					bFound = true;
					break;
				}
			}

			if ( bFound )	// 빈 슬롯을 찾았으면..
			{
				// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
				// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;				
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= i;

				// Send To Server.. 
				SendInvMsg(0x02, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, i);
				return true;
			}
			else
			{
				s_bWaitFromServer				= false;
				s_sRecoveryJobInfo.pItemSource	= nullptr;
				s_sRecoveryJobInfo.pItemTarget	= nullptr;
				return false;
			}
		}
	}
	// Inv -> Arm
	else if ( (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_INV) && bArm )
	{
		// 검에 장착하는 경우는 기존 아이콘이 있는지 살펴볼 필요가 없다.. 왜냐면, 검사하는 함수가 하니까..
		// 기존 아이콘이 있는지 살펴보고 기존 아이템이 없으면..
		if ( !m_pMySlot[iDestiOrder] )
		{
			if ( IsValidPosFromInvToArm(iDestiOrder) )
			{
				// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
				// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_SLOT;				
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

				// Send To Server.. 
				SendInvMsg(0x01, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
				return true;
			}
			else
			{
				s_bWaitFromServer					= false;
				s_sRecoveryJobInfo.pItemSource		= nullptr;
				s_sRecoveryJobInfo.pItemTarget		= nullptr;
				return false;
			}
		}
		// 기존 아이콘이 있으면..
		else
		{
			if ( IsValidPosFromInvToArm(iDestiOrder) )
			{
				// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
				// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_SLOT;				
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

				// 검에 장착하는 경우가 아니면..
				if ( (iDestiOrder != ITEM_SLOT_POS_HAND_RIGHT) && (iDestiOrder != ITEM_SLOT_POS_HAND_LEFT) )
				{
					CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[iDestiOrder];
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= iDestiOrder;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
				}
				// Send To Server.. 
				SendInvMsg(0x01, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
				return true;
			}
			else
			{
				s_bWaitFromServer					= false;
				s_sRecoveryJobInfo.pItemSource		= nullptr;
				s_sRecoveryJobInfo.pItemTarget		= nullptr;
				return false;
			}
		}
	}
	// Inv -> Inv
	else if ( (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict == UIWND_DISTRICT_INVENTORY_INV) && !bArm )
	{
		// 기존 아이콘이 있는지 살펴보고 기존 아이템이 없으면..
		if ( !m_pMyInvWnd[iDestiOrder] )
		{
			// 아이콘이 들어갈 수 있으면.. 서버가 실패를 줄 경우를 대비해서 백업 정보를 작성.. 
			// 그리고 서버가 성공을 줄 경우 해야할 작업 정보를 작성..
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;				
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

			// Send To Server.. 
			SendInvMsg(0x03, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
				CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
			return true;
		}
		// 기존 아이콘이 있으면.. 
		else
		{
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;				
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder			= iDestiOrder;

			CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMyInvWnd[iDestiOrder];
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_INV;
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= iDestiOrder;
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
			CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
			// Send To Server.. 
			SendInvMsg(0x03, CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
				CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
			return true;
		}
	}
	
	s_bWaitFromServer					= false;
	s_sRecoveryJobInfo.pItemSource		= nullptr;
	s_sRecoveryJobInfo.pItemTarget		= nullptr;
	return false;
}

inline	bool CUIInventory::InvOpsSomething(__IconItemSkill* spItem)
{
	if (!spItem) return false;
	CN3UIArea* pArea = nullptr;

	// 검사한다..성공이면 서버에게 보냄..
	if ( CheckIconDropIfSuccessSendToServer(spItem) )												
	{																								
		// 아이콘 이동.. Source.. 같은 아이콘 내에서 움직이는 거면.. 굳이 제거하고 추가할  필요없이 이동만 하면 된다..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )											
		{																							
			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict )				
			{																						
				case UIWND_DISTRICT_INVENTORY_SLOT:														
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;		
					break;																			

				case UIWND_DISTRICT_INVENTORY_INV:													
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;	
					break;																			
			}																						
		}																							
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )											
		{																							
			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict )				
			{																							
				case UIWND_DISTRICT_INVENTORY_SLOT:													
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder] = nullptr;		
					break;																			

				case UIWND_DISTRICT_INVENTORY_INV:													
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder] = nullptr;	
					break;																				
			}																						
		}																							

		// 아이콘 이동.. Source.. 같은 아이콘 내에서 움직이는 거면.. 굳이 제거하고 추가할  필요없이 이동만 하면 된다..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )											
		{																								
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;				

			// 추가..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict )				
			{																						
				case UIWND_DISTRICT_INVENTORY_SLOT:													
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);	
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItem;												
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());				
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());			
					break;																													

				case UIWND_DISTRICT_INVENTORY_INV:																							
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);	
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItem;											
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());			
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());			
					break;																													
			}																																
		}																																	

		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )																					
		{																																	
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;														

			// 추가..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict )														
			{																																
				case UIWND_DISTRICT_INVENTORY_SLOT:																								
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder);	
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder] = spItem;												
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());				
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());			
					break;																													

				case UIWND_DISTRICT_INVENTORY_INV:																							
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder);		
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder] = spItem;													
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());			
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());			
					break;																													
			}																																
		}																																	

		CN3UIWndBase::AllHighLightIconFree();																								
		SetState(UI_STATE_COMMON_NONE);																										
		return true;																														
	}																																		
	else																																	
	{																																		
		CN3UIWndBase::AllHighLightIconFree();																								
		SetState(UI_STATE_COMMON_NONE);																										
		return false;																														
	}			
}

bool CUIInventory::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
	CN3UIArea* pArea = nullptr;

	if (!m_bVisible) return false;
	if (!spItem) return false;

	// 내가 가졌던 아이콘이 아니면..
	if ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd != m_eUIWnd )
		return false;

	// 내가 가졌던 아이콘이고 인벤토리 내에서 즉, Arm->Arm, Arm->Inv, Inv->Arm, Inv->Inv이다..
	// 선택된 아이콘과 같으면.. 
	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_INVENTORY_SLOT:
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
			break;	

		case UIWND_DISTRICT_INVENTORY_INV:
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
			break;	
	}

	if ( (pArea) && (pArea->IsIn(ptCur.x, ptCur.y)) )
	{
		if (GetState()  == UI_STATE_ICON_MOVING)
		{
			if (spItem) PlayItemSound(spItem->pItemBasic);
			CN3UIWndBase::AllHighLightIconFree();																								
			SetState(UI_STATE_COMMON_NONE);																										
			return false;
		}
	}
	else if ( m_pArea_Destroy->IsIn(ptCur.x, ptCur.y) )
	{
		m_bDestoyDlgAlive = true;

		// 움직일 수 없다..
		RECT rect = { 0, 0, 0, 0 };

		switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
		{
			case UIWND_DISTRICT_INVENTORY_SLOT:
				if ( m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
				{
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(m_pArea_Destroy->GetRegion());
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(rect);
				}
				break;

			case UIWND_DISTRICT_INVENTORY_INV:
				if ( m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
				{
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(m_pArea_Destroy->GetRegion());
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(rect);
				}
				break;
		}

		CN3UIWndBase::s_sRecoveryJobInfo.pItemSource					= CN3UIWndBase::s_sSelectedIconInfo.pItemSelect;
		CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd;
		CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict = CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict;
		CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder		= CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder;

		CN3UIWndBase::AllHighLightIconFree();																								
		SetState(UI_STATE_COMMON_NONE);	
		return true;
	}
	else
		return InvOpsSomething(spItem);

	return false;
}

void CUIInventory::ReceiveResultFromServer(uint8_t bResult)
{
	CN3UIArea* pArea = nullptr;

	if (bResult == 0x01)		// 성공..
	{
		// 아이콘은 바뀌었으니 실제 데이터를 이동..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;
			e_ItemSlot eSlot = ITEM_SLOT_UNKNOWN;

			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					eSlot = (e_ItemSlot)CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
					if (!spItem) return;
					this->ItemDelete(spItem->pItemBasic, spItem->pItemExt, eSlot);
					break;
			}
		}

		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;
			if (!spItem) return;
			e_ItemSlot eSlot = ITEM_SLOT_UNKNOWN;

			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					eSlot = (e_ItemSlot)CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder;
					if (!spItem) return;
					this->ItemDelete(spItem->pItemBasic,  spItem->pItemExt, eSlot);
					break;
			}
		}

		// 아이콘은 바뀌었으니 실제 데이터를 이동..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;
			if (!spItem) return;

			// 추가..
			e_ItemSlot eSlot = ITEM_SLOT_UNKNOWN;
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					eSlot = (e_ItemSlot)CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder;
					if (!spItem) return;
					ItemAdd(spItem->pItemBasic, spItem->pItemExt, eSlot);
					break;
			}
		}

		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;
			if (!spItem) return;
			e_ItemSlot eSlot = ITEM_SLOT_UNKNOWN;

			// 추가..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					eSlot = (e_ItemSlot)CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder;
					if (!spItem) return;
					ItemAdd(spItem->pItemBasic, spItem->pItemExt, eSlot);
					break;
			}
		}
	}
	else						// 실패..
	{
		// 아이콘을 원상태로..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )
		{
			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
					break;
			}
		}

		// 아이콘 이동.. Target..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )
		{
			// 제거..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder] = nullptr;
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder] = nullptr;
					break;
			}
		}

		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;

			// 추가..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItem;
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItem;
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					break;
			}
		}

		// 아이콘 이동.. Target..
		if ( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget )
		{
			__IconItemSkill*	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;

			// 추가..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder);
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder] = spItem;
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder);
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder] = spItem;
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					break;
			}
		}
	}

	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);

	s_bWaitFromServer				= false;
	s_sRecoveryJobInfo.pItemSource	= nullptr;
	s_sRecoveryJobInfo.pItemTarget	= nullptr;

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg) CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();
	if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg) CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CUIInventory::CancelIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIInventory::AcceptIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIInventory::IconRestore()
{
	CN3UIArea* pArea;

	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_INVENTORY_SLOT:
			if ( m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;

		case UIWND_DISTRICT_INVENTORY_INV:
			if ( m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;
	}
}

int CUIInventory::GetIndexInArea(POINT pt)
{
	CN3UIArea* pArea;
	RECT	rect;

	for (int i = 0; i < ITEM_SLOT_COUNT; i++)
	{
		pArea = nullptr;
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, i);
		if (pArea)
		{
			rect = pArea->GetRegion();

			if ( (pt.x >= rect.left) && (pt.x <= rect.right) && (pt.y >= rect.top) && (pt.y <= rect.bottom) )
				return i;
		}
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		pArea = nullptr;
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
		if (pArea)
		{
			rect = pArea->GetRegion();

			if ( (pt.x >= rect.left) && (pt.x <= rect.right) && (pt.y >= rect.top) && (pt.y <= rect.bottom) )
				return i + ITEM_SLOT_COUNT;
		}
	}

	return -1;
}

bool CUIInventory::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
// Temp Define
#define FAIL_CODE {		\
				SetState(UI_STATE_COMMON_NONE);	\
				return false;	\
			}

// Code Begin
	if(nullptr == pSender) return false;
	__IconItemSkill* spItem = nullptr;
	e_UIWND_DISTRICT eUIWnd;
	int iOrder;
	uint32_t dwBitMask = 0x0f1f0000;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if (pSender->m_szID == "btn_close")
		{
			// 인벤토리만 떠 있을때..
			Close();
		}
		else if (pSender->m_szID == "btn_Destroy_ok")
		{
			// 인벤토리만 떠 있을때..
			ItemDestroyOK();
		}
		else if (pSender->m_szID == "btn_Destroy_cancel")
		{
			// 인벤토리만 떠 있을때..
			ItemDestroyCancel();
		}
	}

	if (m_eInvenState == INV_STATE_REPAIR) FAIL_CODE
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_RDOWN_FIRST:
			m_iRBtnDownOffs = GetIndexInArea(ptCur);
			break;

		case UIMSG_ICON_RUP:
			{
				int iRBtn = GetIndexInArea(ptCur);
				if (iRBtn != -1 && m_iRBtnDownOffs != -1 && m_iRBtnDownOffs == iRBtn)
				{
					bool bSlot;
					if ((iRBtn - ITEM_SLOT_COUNT) >= 0)
					{
						bSlot = false;
						iRBtn -= ITEM_SLOT_COUNT;
					}
					else
						bSlot = true;
					
					// Get Item..
					spItem = GetHighlightIconItem((CN3UIIcon* )pSender);
					
					CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd = UIWND_INVENTORY;
					CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder = iRBtn;
					CN3UIWndBase::s_sSelectedIconInfo.pItemSelect = spItem;

					// player right-clicked on an equipped item
					if (bSlot)
					{
						CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
					}
					// player right-clicked on item which is not equipped
					else
					{
						CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = UIWND_DISTRICT_INVENTORY_INV;

						// determine if there's an empty slot on the skillbar (CUIHotKeyDlg)
						// if so, we should allocate an icon there
						CUIHotKeyDlg* pDlg = CGameProcedure::s_pProcMain->m_pUIHotKeyDlg;
						int iIndex;
						if (pDlg->GetEmptySlotIndex(iIndex))
						{
							CN3UIWndBase::s_sSkillSelectInfo.UIWnd = UIWND_INVENTORY;

							if (pDlg->SetReceiveSelectedItem(iIndex))
								return true;
						}
					}

					if (spItem) PlayItemSound(spItem->pItemBasic);

					//..
					m_bRBtnProcessing = true;
					InvOpsSomething(spItem);
					m_bRBtnProcessing = false;
				}
			}
			break;

		// NOTE: These events are the same.
		// UIMSG_AREA_DOWN_FIRST was only used for the inventory, but they're otherwise identical.
		// case UIMSG_AREA_DOWN_FIRST:
		case UIMSG_BUTTON_CLICK:
			// 개인간 거래중이고.. 내 아이디가 "area_gold"이면..  
			// SubProcPerTrade에 함수를 호출..	( 그 함수는 edit하는 중이 아니면.. 호출)
			if ( (CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_ePerTradeState == PER_TRADE_STATE_NORMAL) &&
				(pSender->m_szID.compare("area_gold") == 0)	)
					CGameProcedure::s_pProcMain->m_pSubProcPerTrade->RequestItemCountEdit();
				break;
			break;

		case UIMSG_ICON_DOWN_FIRST:
			CN3UIWndBase::AllHighLightIconFree();

			// Get Item..
			spItem = GetHighlightIconItem((CN3UIIcon* )pSender);

			// Save Select Info..
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd = UIWND_INVENTORY;
			eUIWnd = GetWndDistrict(spItem);
			if ( eUIWnd == UIWND_DISTRICT_UNKNOWN )	FAIL_CODE
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = eUIWnd;
			iOrder = GetItemiOrder(spItem, eUIWnd);
			if ( iOrder == -1 )	FAIL_CODE
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder = iOrder;
			CN3UIWndBase::s_sSelectedIconInfo.pItemSelect = spItem;
			// Do Ops..
			((CN3UIIcon* )pSender)->SetRegion(GetSampleRect());
			((CN3UIIcon* )pSender)->SetMoveRect(GetSampleRect());
			// Sound..
			if (spItem) PlayItemSound(spItem->pItemBasic);
			break;

		case UIMSG_ICON_UP:
			// 아이콘 매니저 윈도우들을 돌아 다니면서 검사..
			if ( !CGameProcedure::s_pUIMgr->BroadcastIconDropMsg(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				// 아이콘 위치 원래대로..
				IconRestore();
			else
			{
				if (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) PlayItemSound(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic);
			}
			SetState(UI_STATE_COMMON_NONE);
			break;

		case UIMSG_ICON_DOWN:
			if ( GetState()  == UI_STATE_ICON_MOVING )
			{
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
			}
			break;

		case UIMSG_ICON_DBLCLK:
			SetState(UI_STATE_COMMON_NONE);

			// 아이콘 위치 원래대로..
			IconRestore();				
			break;			
	}

	return true;
}

bool CUIInventory::IsValidRaceAndClass(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt)
{
	int iNeedValue;

	char szBuf[256] = "";
	bool	bValid = false;

	if (!pItem) return false;

	// 종족..
	switch ( pItem->byNeedRace )
	{
		case 0:
			bValid = true;
			break;

		default:
			if ( pItem->byNeedRace == CGameBase::s_pPlayer->m_InfoBase.eRace )
				bValid = true;
			break;
	}

	__InfoPlayerMySelf*	pInfoExt = nullptr;
	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);
	if (!pInfoExt)	return false;

	std::string szMsg;
	if ( bValid )
	{
		// 직업..		
		if (pItem->byNeedClass != 0)
		{
			switch (pItem->byNeedClass)
			{
				case CLASS_KINDOF_WARRIOR:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_WARRIOR:
						case CLASS_KA_BERSERKER:
						case CLASS_KA_GUARDIAN:
						case CLASS_EL_WARRIOR:
						case CLASS_EL_BLADE:
						case CLASS_EL_PROTECTOR:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_ROGUE:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_ROGUE:
						case CLASS_KA_HUNTER:
						case CLASS_KA_PENETRATOR:
						case CLASS_EL_ROGUE:
						case CLASS_EL_RANGER:
						case CLASS_EL_ASSASIN:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_WIZARD:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_WIZARD:
						case CLASS_KA_SORCERER:
						case CLASS_KA_NECROMANCER:
						case CLASS_EL_WIZARD:
						case CLASS_EL_MAGE:
						case CLASS_EL_ENCHANTER:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_PRIEST:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_PRIEST:
						case CLASS_KA_SHAMAN:
						case CLASS_KA_DARKPRIEST:
						case CLASS_EL_PRIEST:
						case CLASS_EL_CLERIC:
						case CLASS_EL_DRUID:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_ATTACK_WARRIOR:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_BERSERKER:
						case CLASS_EL_BLADE:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_DEFEND_WARRIOR:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_GUARDIAN:
						case CLASS_EL_PROTECTOR:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_ARCHER:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_HUNTER:
						case CLASS_EL_RANGER:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_ASSASSIN:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_PENETRATOR:
						case CLASS_EL_ASSASIN:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_ATTACK_WIZARD:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_SORCERER:
						case CLASS_EL_MAGE:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_PET_WIZARD:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_NECROMANCER:
						case CLASS_EL_ENCHANTER:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_HEAL_PRIEST:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_SHAMAN:
						case CLASS_EL_CLERIC:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				case CLASS_KINDOF_CURSE_PRIEST:
					switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
					{
						case CLASS_KA_DARKPRIEST:
						case CLASS_EL_DRUID:
							break;
						default:
							szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return false;
					}
					break;

				default:
					if (CGameBase::s_pPlayer->m_InfoBase.eClass != pItem->byClass)
					{
						szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return false;
					}
					break;
			}					
		}

		if ( (pItem->byAttachPoint == ITEM_LIMITED_EXHAUST) && (CGameBase::s_pPlayer->m_InfoBase.iLevel < pItem->cNeedLevel+pItemExt->siNeedLevel) )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_LEVEL);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		if ( pInfoExt->iRank < pItem->byNeedRank+pItemExt->siNeedRank )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_RANK);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}
		
		if ( pInfoExt->iTitle < pItem->byNeedTitle+pItemExt->siNeedTitle )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_TITLE);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		iNeedValue = pItem->byNeedStrength;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedStrength;
		if ( pInfoExt->iStrength < iNeedValue )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_POWER);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		iNeedValue = pItem->byNeedStamina;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedStamina;
		if ( pInfoExt->iStamina < iNeedValue )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_STR);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		iNeedValue = pItem->byNeedDexterity;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedDexterity;
		if ( pInfoExt->iDexterity < iNeedValue )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_DEX);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff1010);
			return false;
		}

		iNeedValue = pItem->byNeedInteli;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedInteli;
		if ( pInfoExt->iIntelligence < iNeedValue )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_INT);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		iNeedValue = pItem->byNeedMagicAttack;
		if (iNeedValue != 0)
			iNeedValue += pItemExt->siNeedMagicAttack;
		if ( pInfoExt->iMagicAttak < iNeedValue )
		{
			szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_LOW_CHA);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			return false;
		}

		return true;
	}
	else
	{
		szMsg = fmt::format_text_resource(IDS_MSG_VALID_CLASSNRACE_INVALID_RACE);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}
	return false;
}

bool CUIInventory::IsValidPosFromInvToArm(int iOrder)
{
	if( CN3UIWndBase::s_sSelectedIconInfo.pItemSelect == nullptr )
		return false;

	__TABLE_ITEM_BASIC*		pItem;
	__TABLE_ITEM_EXT* pItemExt;

	pItem = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic;
	pItemExt = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt;

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
	if(ITEM_TYPE_UNKNOWN == eType) return false;

	if ( IsValidRaceAndClass(pItem, CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt) )
	{
		switch ( iOrder )
		{
			case ITEM_SLOT_POS_EAR_RIGHT:
			case ITEM_SLOT_POS_EAR_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_EAR:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HEAD:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_HEAD:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_NECK:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_NECK:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_UPPER:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_UPPER:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_SHOULDER:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_CLOAK:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_RIGHT:				// 오른손..
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
					case ITEM_ATTACH_POS_HAND_RIGHT:
						// 완손에 양손 무기가 있는지 알아본당..
						if ( (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]) 
							&& (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]->pItemBasic->byAttachPoint == ITEM_ATTACH_POS_TWOHAND_LEFT) )
						{
							// 오른손에 무기가 있는 경우 false 리턴.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]) 
								return false;
							// 오른손에 무기가 없는 경우.. 왼손 무기가 인벤토리로.. ^^ 
							else
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_LEFT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_LEFT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
						}
						else	// 왼손에 양손무기가 없는 경우.. 
						{
							// 오른손에 무기가 있는 경우.. Item Exchange.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]) 
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_RIGHT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
							// 오른손에 무기가 없는 경우..  true 리턴..
							else
								return true;
						}
						break;

					case ITEM_ATTACH_POS_TWOHAND_RIGHT:				// 양손검을 오른손에 찰때..
						if ( m_pMySlot[ITEM_SLOT_POS_HAND_LEFT] )	// 왼손에 무기가 있고..
						{
							// 오른손에 무기가 있는 경우 false 리턴.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]) 
								return false;
							// 오른손에 무기가 없는 경우 .. 왼손의 무기가 인벤토리로.. ^^
							else
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_LEFT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_LEFT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
						}
						else										// 왼손에 무기가 없고..	
						{
							// 오른손에 무기가 있는 경우.. Item Exchange.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]) 
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_RIGHT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
							// 오른손에 무기가 없는 경우..  true 리턴..
							else
								return true;
						}
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
					case ITEM_ATTACH_POS_HAND_LEFT:
						// 오른손에 양손 무기가 있는지 알아본당..
						if ( (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]) 
							&& (m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT]->pItemBasic->byAttachPoint == ITEM_ATTACH_POS_TWOHAND_RIGHT) )
						{
							// 왼손에 무기가 있는 경우 false 리턴.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]) 
								return false;
							// 왼손에 무기가 없는 경우.. 오른손 무기가 인벤토리로.. ^^ 
							else
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_RIGHT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
						}
						else	// 오른손에 양손무기가 없는 경우.. 
						{
							// 왼손에 무기가 있는 경우.. Item Exchange.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]) 
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_LEFT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_LEFT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
							// 왼손에 무기가 없는 경우..  true 리턴..
							else
								return true;
						}
						break;

					case ITEM_ATTACH_POS_TWOHAND_LEFT:				// 양손검을 왼손에 찰때..
						if ( m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT] )	// 오른손에 무기가 있고..
						{
							// 왼손에 무기가 있는 경우 false 리턴.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]) 
								return false;
							// 왼손에 무기가 없는 경우.. 오른손 무기가 인벤토리로.. ^^ 
							else
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_RIGHT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_RIGHT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
						}
						else	// 오른손에 양손무기가 없는 경우.. 
						{
							// 왼손에 무기가 있는 경우.. Item Exchange.. ^^
							if (m_pMySlot[ITEM_SLOT_POS_HAND_LEFT]) 
							{
								CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMySlot[ITEM_SLOT_POS_HAND_LEFT];
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_INVENTORY_SLOT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= ITEM_SLOT_POS_HAND_LEFT;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_INVENTORY;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_INVENTORY_INV;
								CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;
								return true;
							}
							// 왼손에 무기가 없는 경우..  true 리턴..
							else
								return true;
						}
						break;
				}
				break;

			case ITEM_SLOT_POS_BELT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_BELT:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_RING_RIGHT:
			case ITEM_SLOT_POS_RING_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_FINGER:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_LOWER:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_LOWER:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_GLOVES:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_ARM:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_SHOES:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_FOOT:
						return true;
						break;
				}
				break;
		}
	}
	return false;
}

bool CUIInventory::IsValidPosFromArmToArm(int iOrder)
{
	if( CN3UIWndBase::s_sRecoveryJobInfo.pItemSource == nullptr )
		return false;

	__TABLE_ITEM_BASIC*		pItem;
	__TABLE_ITEM_EXT* pItemExt;
	pItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic;
	pItemExt = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt;

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
	if(ITEM_TYPE_UNKNOWN == eType) return false;

	if ( IsValidRaceAndClass(pItem, CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt) )
	{
		switch ( iOrder )
		{
			case ITEM_SLOT_POS_EAR_RIGHT:
			case ITEM_SLOT_POS_EAR_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_EAR:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_RIGHT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_RING_RIGHT:
			case ITEM_SLOT_POS_RING_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_FINGER:
						return true;
						break;
				}
				break;
		}
	}
	return false;
}

bool CUIInventory::IsValidPosFromArmToArmInverse(int iOrder)
{
	if( CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget == nullptr )
		return false;

	__TABLE_ITEM_BASIC*		pItem;
	__TABLE_ITEM_EXT* pItemExt;
	pItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget->pItemBasic;
	pItemExt = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget->pItemExt;

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
	if(ITEM_TYPE_UNKNOWN == eType) return false;

	if ( IsValidRaceAndClass(pItem, CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt) )
	{
		switch (iOrder)
		{
			case ITEM_SLOT_POS_EAR_RIGHT:
			case ITEM_SLOT_POS_EAR_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_EAR:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_RIGHT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_HAND_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_DUAL:
						return true;
						break;
				}
				break;

			case ITEM_SLOT_POS_RING_RIGHT:
			case ITEM_SLOT_POS_RING_LEFT:
				switch ( pItem->byAttachPoint )
				{
					case ITEM_ATTACH_POS_FINGER:
						return true;
						break;
				}
				break;
		}
	}

	return false;
}

void CUIInventory::ItemAdd(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt, e_ItemSlot eSlot)
{
	std::string szFN;
	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, &szFN, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서

	if(ITEM_TYPE_PLUG == eType)
	{
		if(ITEM_SLOT_HAND_LEFT == eSlot) ePlug = PLUG_POS_LEFTHAND;
		else if(ITEM_SLOT_HAND_RIGHT == eSlot) ePlug = PLUG_POS_RIGHTHAND;
		else { __ASSERT(0, "Invalid Item Plug Position"); }

		CGameBase::s_pPlayer->PlugSet(ePlug, szFN, pItem, pItemExt); // 플러그 셋팅..
		CGameBase::s_pPlayer->DurabilitySet(eSlot, m_pMySlot[eSlot]->iDurability);
	}
	else if(ITEM_TYPE_PART == eType)
	{
		CGameBase::s_pPlayer->PartSet(ePart, szFN, pItem, pItemExt);
		CGameBase::s_pPlayer->DurabilitySet(eSlot, m_pMySlot[eSlot]->iDurability);
	}
}

void CUIInventory::ItemDelete(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt, e_ItemSlot eSlot)
{
	__TABLE_PLAYER_LOOKS* pLooks = CGameBase::s_pTbl_UPC_Looks.Find(CGameBase::s_pPlayer->m_InfoBase.eRace);	// User Player Character Skin 구조체 포인터..
	__ASSERT(pLooks, "NULL Basic Looks!");
	if(nullptr == pLooks) return;

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, nullptr, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
	
	if(pLooks)
	{
		if(ITEM_TYPE_PLUG == eType)
		{
			if(ITEM_SLOT_HAND_LEFT == eSlot) ePlug = PLUG_POS_LEFTHAND;
			else if(ITEM_SLOT_HAND_RIGHT == eSlot) ePlug = PLUG_POS_RIGHTHAND;

			CGameBase::s_pPlayer->PlugSet(ePlug, "", nullptr, nullptr); // 플러그 셋팅..
		}
		else if(ITEM_TYPE_PART == eType)
		{
			if(PART_POS_HAIR_HELMET == ePart) CGameBase::s_pPlayer->InitHair();
			else CGameBase::s_pPlayer->PartSet(ePart, pLooks->szPartFNs[ePart], nullptr, nullptr);
		}
	}
}

void CUIInventory::DurabilityChange(e_ItemSlot eSlot, int iDurability)
{
	std::string szDur; 

	if ( eSlot < ITEM_SLOT_EAR_RIGHT || eSlot >= ITEM_SLOT_COUNT )
	{
		__ASSERT(0, "Durability Change Item Index Weird.");
		CLogWriter::Write("Durability Change Item Index Weird. Slot({}) Durability({})",
			static_cast<int>(eSlot), iDurability);
		return;
	}

	if ( m_pMySlot[eSlot] )
	{
		m_pMySlot[eSlot]->iDurability = iDurability;
		if ( iDurability == 0 )
		{
			if(m_pMySlot[eSlot]->pUIIcon && m_pMySlot[eSlot]->pItemBasic) 
			{
				m_pMySlot[eSlot]->pUIIcon->SetStyle(m_pMySlot[eSlot]->pUIIcon->GetStyle() | UISTYLE_DURABILITY_EXHAUST);

				// 메시지 박스 출력..
				szDur = fmt::format_text_resource(IDS_DURABILITY_EXOAST,
					m_pMySlot[eSlot]->pItemBasic->szName);
				CGameProcedure::s_pProcMain->MsgOutput(szDur, 0xffff3b3b);
			}
			else
			{
				__ASSERT(0, "Durability Change Item NULL icon or NULL item.");
				CLogWriter::Write("Durability Change Item NULL icon or NULL item. Slot({}) Durability({})",
					static_cast<int>(eSlot), iDurability);
			}
		}
	}
	else
	{
		__ASSERT(0, "Durability Change Item NULL Slot.");
		CLogWriter::Write("Durability Change Item ... NULL Slot. Slot({}) Durability({})",
			static_cast<int>(eSlot), iDurability);
	}
}

void CUIInventory::ReceiveResultFromServer(int iResult, int iUserGold)
{
	m_cItemRepairMgr.ReceiveResultFromServer(iResult, iUserGold);
}

int CUIInventory::GetCountInInvByID(int iID) const
{
	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		__IconItemSkill* spItem = m_pMyInvWnd[i];
		if (spItem == nullptr
			|| spItem->pItemBasic->dwID != (iID / 1000 * 1000)
			|| spItem->pItemExt->dwID != (iID % 1000))
			continue;

		if (spItem->pItemBasic->byClass == ITEM_CLASS_CONSUMABLE)
			return spItem->iDurability;

		return spItem->iCount;
	}

	return 0;
}

void CUIInventory::ItemCountChange(int iDistrict, int iIndex, int iCount, int iID, int iDurability)
{
	__IconItemSkill* spItem;
	switch (iDistrict)
	{
		case 0x00:
			if (m_pMySlot[iIndex] && ( (m_pMySlot[iIndex]->pItemBasic->dwID+m_pMySlot[iIndex]->pItemExt->dwID) != iID ) )	// 엉뚱한 아이템이 있는경우..
			{
				// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
				spItem = m_pMySlot[iIndex];

				// 인벤토리에서도 지운다..
				m_pMySlot[iIndex] = nullptr;

				// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
				RemoveChild(spItem->pUIIcon);

				// 아이콘 리소스 삭제...
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;

				// 아이템을 만들어 넣는다..
				__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..	
				__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..	

				pItem = CGameProcedure::s_pTbl_Items_Basic.Find(iID/1000*1000);	// 열 데이터 얻기..
				if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
					pItemExt = CGameProcedure::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iID%1000);	// 열 데이터 얻기..
				if ( nullptr == pItem || nullptr == pItemExt )
				{
					__ASSERT(0, "NULL Item");
					CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", iID);
					return;
				}

				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szIconFN;
				e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
				if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
				__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
				
				spItem = new __IconItemSkill;
				spItem->pItemBasic	= pItem;
				spItem->pItemExt	= pItemExt;
				spItem->szIconFN = szIconFN; // 아이콘 파일 이름 복사..
				spItem->iCount	= iCount;
				spItem->iDurability = iDurability;
				m_pMySlot[iIndex] = spItem;
				return;
			}
			else if (m_pMySlot[iIndex])
			{
				m_pMySlot[iIndex]->iCount = iCount;
				if (iCount == 0)
				{
					// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
					__IconItemSkill* spItem;
					spItem = m_pMySlot[iIndex];

					// 인벤토리에서도 지운다..
					m_pMySlot[iIndex] = nullptr;

					// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
					RemoveChild(spItem->pUIIcon);

					// 아이콘 리소스 삭제...
					spItem->pUIIcon->Release();
					delete spItem->pUIIcon;
					spItem->pUIIcon = nullptr;
					delete spItem;
					spItem = nullptr;
				}
			}
			else	// 아이템이 없는 경우..
			{
				// 아이템을 만들어 넣는다..
				__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..	
				__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..	

				pItem = CGameProcedure::s_pTbl_Items_Basic.Find(iID/1000*1000);	// 열 데이터 얻기..
				if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
					pItemExt = CGameProcedure::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iID%1000);	// 열 데이터 얻기..
				if ( nullptr == pItem || nullptr == pItemExt )
				{
					__ASSERT(0, "NULL Item");
					CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", iID);
					return;
				}

				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szIconFN;
				e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
				if(ITEM_TYPE_UNKNOWN == eType) 
				{ 
					CLogWriter::Write("MyInfo - slot - Unknown Item");
					__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
					return;
				}
				if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
				__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
				
				spItem = new __IconItemSkill;
				spItem->pItemBasic	= pItem;
				spItem->pItemExt	= pItemExt;
				spItem->szIconFN = szIconFN; // 아이콘 파일 이름 복사..
				spItem->iCount	= iCount;
				spItem->iDurability = iDurability;
				m_pMySlot[iIndex] = spItem;
				return;
			}
			break;

		case 0x01:
			if (m_pMyInvWnd[iIndex] && ( (m_pMyInvWnd[iIndex]->pItemBasic->dwID+m_pMyInvWnd[iIndex]->pItemExt->dwID) != iID ) )	// 엉뚱한 아이템이 있는경우..
			{
				// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
				spItem = m_pMyInvWnd[iIndex];

				// 인벤토리에서도 지운다..
				m_pMyInvWnd[iIndex] = nullptr;

				// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
				RemoveChild(spItem->pUIIcon);

				// 아이콘 리소스 삭제...
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;

				// 아이템을 만들어 넣는다..
				__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..	
				__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..	

				pItem = CGameProcedure::s_pTbl_Items_Basic.Find(iID/1000*1000);	// 열 데이터 얻기..
				if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
					pItemExt = CGameProcedure::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iID%1000);	// 열 데이터 얻기..
				if ( nullptr == pItem || nullptr == pItemExt )
				{
					__ASSERT(0, "NULL Item");
					CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", iID);
					return;
				}

				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szIconFN;
				e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
				if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
				__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
				
				spItem = new __IconItemSkill;
				spItem->pItemBasic	= pItem;
				spItem->pItemExt	= pItemExt;
				spItem->szIconFN = szIconFN; // 아이콘 파일 이름 복사..
				spItem->iCount	= iCount;
				spItem->iDurability = iDurability;
				m_pMyInvWnd[iIndex] = spItem;
				return;
			}
			else if (m_pMyInvWnd[iIndex])
			{
				m_pMyInvWnd[iIndex]->iCount = iCount;
				if (iCount == 0)
				{
					// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
					__IconItemSkill* spItem;
					spItem = m_pMyInvWnd[iIndex];

					// 인벤토리에서도 지운다..
					m_pMyInvWnd[iIndex] = nullptr;

					// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
					RemoveChild(spItem->pUIIcon);

					// 아이콘 리소스 삭제...
					spItem->pUIIcon->Release();
					delete spItem->pUIIcon;
					spItem->pUIIcon = nullptr;
					delete spItem;
					spItem = nullptr;
				}
			}
			else	// 아이템이 없는 경우..
			{
				// 아이템을 만들어 넣는다..
				__TABLE_ITEM_BASIC* pItem = nullptr;								// 아이템 테이블 구조체 포인터..	
				__TABLE_ITEM_EXT* pItemExt = nullptr;								// 아이템 테이블 구조체 포인터..	

				pItem = CGameProcedure::s_pTbl_Items_Basic.Find(iID/1000*1000);	// 열 데이터 얻기..
				if(pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
					pItemExt = CGameProcedure::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iID%1000);	// 열 데이터 얻기..
				if ( nullptr == pItem || nullptr == pItemExt )
				{
					__ASSERT(0, "NULL Item");
					CLogWriter::Write("MyInfo - Inv - Unknown Item {}, IDNumber", iID);
					return;
				}

				e_PartPosition ePart;
				e_PlugPosition ePlug;
				std::string szIconFN;
				e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug, CGameBase::s_pPlayer->m_InfoBase.eRace); // 아이템에 따른 파일 이름을 만들어서
				if(ITEM_TYPE_UNKNOWN == eType) CLogWriter::Write("MyInfo - slot - Unknown Item");
				__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");
				
				spItem = new __IconItemSkill;
				spItem->pItemBasic	= pItem;
				spItem->pItemExt	= pItemExt;
				spItem->szIconFN = szIconFN; // 아이콘 파일 이름 복사..
				spItem->iCount	= iCount;
				spItem->iDurability = iDurability;
				m_pMyInvWnd[iIndex] = spItem;

				m_pMyInvWnd[iIndex]->pUIIcon = new CN3UIIcon;
				m_pMyInvWnd[iIndex]->pUIIcon->Init(this);
				m_pMyInvWnd[iIndex]->pUIIcon->SetTex(m_pMyInvWnd[iIndex]->szIconFN);
				float fUVAspect = (float)45.0f/(float)64.0f;
				m_pMyInvWnd[iIndex]->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
				m_pMyInvWnd[iIndex]->pUIIcon->SetUIType(UI_TYPE_ICON);
				m_pMyInvWnd[iIndex]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
				CN3UIArea* pArea = nullptr;
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, iIndex);
				if ( pArea )
				{
					m_pMyInvWnd[iIndex]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyInvWnd[iIndex]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
				return;
			}
			break;
	}
}

void CUIInventory::ItemDestroyOK()
{
	m_bDestoyDlgAlive = false;

	uint8_t byBuff[32];															// 패킷 버퍼..
	int iOffset=0;																// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_REMOVE);					// 게임 스타트 패킷 커멘드..

	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_INVENTORY_SLOT:
			CAPISocket::MP_AddByte(byBuff, iOffset, 0x01);						// 아이디 길이 패킷에 넣기..
			break;
		case UIWND_DISTRICT_INVENTORY_INV:
			CAPISocket::MP_AddByte(byBuff, iOffset, 0x02);						// 아이디 길이 패킷에 넣기..
			break;
	}
	CAPISocket::MP_AddByte(byBuff, iOffset, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);	// 아이디 길이 패킷에 넣기..
	CAPISocket::MP_AddDword(byBuff, iOffset, CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID+
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt->dwID);	// 아이디 문자열 패킷에 넣기..

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);	

	s_bWaitFromServer = true;
}

void CUIInventory::ItemDestroyCancel()
{
	m_bDestoyDlgAlive = false;
	CN3UIArea* pArea = nullptr;

	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_INVENTORY_SLOT:
			if ( m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;

		case UIWND_DISTRICT_INVENTORY_INV:
			if ( m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;
	}
}

void CUIInventory::ReceiveResultItemRemoveFromServer(int iResult)
{
	CN3UIArea* pArea = nullptr;
	__IconItemSkill* spItem = nullptr;
	s_bWaitFromServer = false;

	switch (iResult)
	{
		case 0x01:			// 성공..
			switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					spItem = m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					// 내 영역에서도 지운다..
					m_pMySlot[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;
					this->ItemDelete(spItem->pItemBasic, spItem->pItemExt, (e_ItemSlot)CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					spItem = m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					// 내 영역에서도 지운다..
					m_pMyInvWnd[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;
					break;
			}

			// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
			if (!spItem) return;
			RemoveChild(spItem->pUIIcon);

			// 아이콘 리소스 삭제...
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
			break;

		case 0x00:			// 실패..
			switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
			{
				case UIWND_DISTRICT_INVENTORY_SLOT:
					if ( m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
					{
						pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SLOT, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
						if ( pArea )
						{
							m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
							m_pMySlot[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
						}
					}
					break;

				case UIWND_DISTRICT_INVENTORY_INV:
					if ( m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
					{
						pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
						if ( pArea )
						{
							m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
							m_pMyInvWnd[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
						}
					}
					break;
			}
			break;
	}

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg) CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();
	if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg) CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
}

bool CUIInventory::CheckWeightValidate(__IconItemSkill* spItem)
{
	std::string szMsg;

	if (!spItem)	return false;

	__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);
	if ( (pInfoExt->iWeight + spItem->pItemBasic->siWeight) > pInfoExt->iWeightMax)
	{	 
		szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);	
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
		return false;	
	}

	return true;
}

//this_ui_add_start
bool CUIInventory::OnKeyPress(int iKey)
{
	if(m_bDestoyDlgAlive && m_pArea_Destroy)
	{
		switch(iKey)
		{
		case DIK_RETURN:
			{
				CN3UIButton* pBtnDestroyOk = nullptr;
				N3_VERIFY_UI_COMPONENT(pBtnDestroyOk, m_pArea_Destroy->GetChildByID<CN3UIButton>("btn_Destroy_ok"));
				if(pBtnDestroyOk) m_pArea_Destroy->ReceiveMessage(pBtnDestroyOk, UIMSG_BUTTON_CLICK);
				else return false;
			}
			return true;
		case DIK_ESCAPE:
			{
				CN3UIButton* pBtnDestroyCancel = nullptr;
				N3_VERIFY_UI_COMPONENT(pBtnDestroyCancel, m_pArea_Destroy->GetChildByID<CN3UIButton>("btn_Destroy_cancel"));
				if(pBtnDestroyCancel) m_pArea_Destroy->ReceiveMessage(pBtnDestroyCancel, UIMSG_BUTTON_CLICK);
				else return false;
			}
			return true;
		}
	}
	else
	{
		switch(iKey)
		{
		case DIK_ESCAPE:
			if(!m_bClosingNow) this->Close();
			if(m_pUITooltipDlg) m_pUITooltipDlg->DisplayTooltipsDisable();
			return true;
		}
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIInventory::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();

	m_iRBtnDownOffs = -1;
}

void CUIInventory::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	if(bWork)
	{
		if ( m_eInvenState == INV_STATE_REPAIR )
		{
			CGameProcedure::RestoreGameCursor();

			if (CGameProcedure::s_pProcMain->m_pUIRepairTooltip->IsVisible())
			{
				CGameProcedure::s_pProcMain->m_pUIRepairTooltip->m_bBRender = false;
				CGameProcedure::s_pProcMain->m_pUIRepairTooltip->DisplayTooltipsDisable();
			}
		}

		m_eInvenState = INV_STATE_NORMAL;

		if (GetState() == UI_STATE_ICON_MOVING)
			IconRestore();
		SetState(UI_STATE_COMMON_NONE);
		CN3UIWndBase::AllHighLightIconFree();

		if(m_pUITooltipDlg) m_pUITooltipDlg->DisplayTooltipsDisable();
	}

	if(bReFocus)
	{
		if(bVisible)
			CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
		else
			CGameProcedure::s_pUIMgr->ReFocusUI();
	}

	m_iRBtnDownOffs = -1;
}

int CUIInventory::GetIndexItemCount(uint32_t dwIndex)
{
	int iCnt = 0;

	for( int i = 0; i < ITEM_SLOT_COUNT; i++ )
	{
		if(m_pMySlot[i] && m_pMySlot[i]->pItemBasic)
		{
			if(m_pMySlot[i]->pItemBasic->dwID == dwIndex)
				iCnt += m_pMySlot[i]->iCount;
		}
	}

	for(int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if(m_pMyInvWnd[i] && m_pMyInvWnd[i]->pItemBasic)
		{
			if(m_pMyInvWnd[i]->pItemBasic->dwID == dwIndex)
				iCnt += m_pMyInvWnd[i]->iCount;
		}
	}

	return iCnt;
}
//this_ui_add_end

// ===== END WarFare/UIInventory.cpp =====

// ===== BEGIN WarFare/UIInventory.h =====
#line 1 "WarFare/UIInventory.h"
﻿// UIInventory.h: interface for the CUIInventory class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIInventory_H__863D2E52_65A8_47E1_BCBE_6281692DDCA2__INCLUDED_)
#define AFX_UIInventory_H__863D2E52_65A8_47E1_BCBE_6281692DDCA2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"
#include "ItemRepairMgr.h"

const int	ITEM_SLOT_POS_EAR_RIGHT			= 0;
const int	ITEM_SLOT_POS_HEAD				= 1;
const int	ITEM_SLOT_POS_EAR_LEFT			= 2;
const int	ITEM_SLOT_POS_NECK				= 3;
const int	ITEM_SLOT_POS_UPPER				= 4;
const int	ITEM_SLOT_POS_SHOULDER			= 5;
const int	ITEM_SLOT_POS_HAND_RIGHT		= 6;
const int	ITEM_SLOT_POS_BELT				= 7;
const int	ITEM_SLOT_POS_HAND_LEFT			= 8;
const int	ITEM_SLOT_POS_RING_RIGHT		= 9;
const int	ITEM_SLOT_POS_LOWER				= 10;
const int	ITEM_SLOT_POS_RING_LEFT			= 11;
const int	ITEM_SLOT_POS_GLOVES			= 12;
const int	ITEM_SLOT_POS_SHOES				= 13;

const int	ITEM_ATTACH_POS_DUAL			= 0;
const int	ITEM_ATTACH_POS_HAND_RIGHT		= 1;
const int	ITEM_ATTACH_POS_HAND_LEFT		= 2;
const int	ITEM_ATTACH_POS_TWOHAND_RIGHT	= 3;
const int	ITEM_ATTACH_POS_TWOHAND_LEFT	= 4;
const int	ITEM_ATTACH_POS_UPPER			= 5;
const int	ITEM_ATTACH_POS_LOWER			= 6;
const int	ITEM_ATTACH_POS_HEAD			= 7;
const int	ITEM_ATTACH_POS_ARM				= 8;
const int	ITEM_ATTACH_POS_FOOT			= 9;
const int	ITEM_ATTACH_POS_EAR				= 10;
const int	ITEM_ATTACH_POS_NECK			= 11;	
const int	ITEM_ATTACH_POS_FINGER			= 12;
const int	ITEM_ATTACH_POS_CLOAK			= 13;
const int	ITEM_ATTACH_POS_BELT			= 14;
const int	ITEM_ATTACH_POS_INVENTORY		= 15;


enum e_InvenState { INV_STATE_NORMAL = 1, INV_STATE_REPAIR, };		// 인벤토리 상태.. 기존의 상태와 구별하기 위해.. 수리 상태가 추가됐다..


//////////////////////////////////////////////////////////////////////

class CUIInventory : public CN3UIWndBase  
{
	bool				m_bDestoyDlgAlive;

protected:
	e_InvenState		  m_eInvenState;
	CItemRepairMgr		m_cItemRepairMgr;

	bool					m_bOpenningNow; // 열리고 있다..
	bool					m_bClosingNow;	// 닫히고 있다..
	float					 m_fMoveDelta; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

	CN3UIArea*			m_pArea_User;
	CN3UIArea*			m_pArea_Destroy;

	CN3UIString*		m_pText_Weight;

	CUIImageTooltipDlg*	m_pUITooltipDlg;

	int							m_iRBtnDownOffs;
	bool					 m_bRBtnProcessing;

public:
	__IconItemSkill*	m_pMySlot[ITEM_SLOT_COUNT];
	__IconItemSkill*	m_pMyInvWnd[MAX_ITEM_INVENTORY];

protected:
	e_UIWND_DISTRICT	GetWndDistrict(__IconItemSkill* spItem);
	int					GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist);

	RECT				GetSampleRect();

	// 검사하는 루틴..
	bool				IsValidRaceAndClass(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt); 
	bool				IsValidPosFromInvToArm(int iOrder);
	bool				IsValidPosFromArmToArm(int iOrder);
	bool				IsValidPosFromArmToArmInverse(int iOrder);

	void				ItemAdd(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt, e_ItemSlot eSlot);
	void				ItemDelete(__TABLE_ITEM_BASIC* pItem, __TABLE_ITEM_EXT* pItemExt, e_ItemSlot eSlot);

	inline	bool		InvOpsSomething(__IconItemSkill* spItem);
	int						GetArmDestinationIndex(__IconItemSkill* spItem);
	int						GetInvDestinationIndex(__IconItemSkill* spItem);

// Operations
public:

	//this_ui_add_start
	int					GetIndexItemCount(uint32_t dwIndex);
	void				SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false);
	void				SetVisible(bool bVisible);
	bool				OnKeyPress(int iKey);
	//this_ui_add_end

	void				Release();
	void				ReleaseItem();

	void				Open(e_InvenState eIS = INV_STATE_NORMAL);
	void				Close(bool bByKey = false);

	void				Tick();
	void				Render();

	void				InitIconWnd(e_UIWND eWnd);	
	void				InitIconUpdate();

	uint32_t				MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	bool				ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg);

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon);

	bool				CheckIconDropIfSuccessSendToServer(__IconItemSkill* spItem);
	void				IconRestore();
	
	bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur);

	void				CancelIconDrop(__IconItemSkill* spItem);
	void				AcceptIconDrop(__IconItemSkill* spItem);

	void				SendInvMsg(uint8_t bDir, int iItemID, int SrcPos, int DestPos);

	void				ReceiveResultFromServer(uint8_t bResult = 0x01);
	void				ReceiveResultItemRemoveFromServer(int iResult);

	// Duration Change..
	void				DurabilityChange(e_ItemSlot eSlot, int iDurability);	
	e_InvenState		GetInvState()	{ return m_eInvenState; }

	void				ReceiveResultFromServer(int iResult, int iUserGold);

	int					GetCountInInvByID(int iID) const;

	// 소모성 아이템을 소비한 경우 or Not..
	void				ItemCountChange(int iDistrict, int iIndex, int iCount, int iID, int iDurability);

	// child dlg func..
	void				ItemDestroyOK();
	void				ItemDestroyCancel();

	bool				CheckWeightValidate(__IconItemSkill* spItem);
	void				GoldUpdate();

	bool				HasAnyItemInSlot();
	void				UpdateWeight(std::string str);

	int					  GetIndexInArea(POINT pt);

	CUIInventory();
	virtual	~CUIInventory();
};

#endif // !defined(AFX_UIInventory_H__863D2E52_65A8_47E1_BCBE_6281692DDCA2__INCLUDED_)




// ===== END WarFare/UIInventory.h =====

// ===== BEGIN WarFare/UIKnightsOperation.cpp =====
#line 1 "WarFare/UIKnightsOperation.cpp"
﻿// UIKnightsOperation.cpp: implementation of the CUIKnightsOperation class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIKnightsOperation.h"
#include "GameProcMain.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIList.h>
#include <N3Base/N3UIScrollBar.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIKnightsOperation::CUIKnightsOperation()
{
	m_iPageCur = 0;

	m_pBtn_Up	= nullptr;
	m_pBtn_Down	= nullptr;
	m_pBtn_Close	= nullptr;

	m_pList_Knights = nullptr;
	m_pBtn_Join = nullptr;
	m_pBtn_Create = nullptr;
	m_pBtn_Destroy = nullptr;
	m_pBtn_Withdraw = nullptr;
	m_pEdit_KnightsName = nullptr;
}

CUIKnightsOperation::~CUIKnightsOperation()
{

}

void CUIKnightsOperation::Release()
{
	CN3UIBase::Release();

	m_iPageCur = 0;
	m_KnightsListExt.clear();

	m_pBtn_Up	= nullptr;
	m_pBtn_Down	= nullptr;
	m_pBtn_Close	= nullptr;

	m_pList_Knights = nullptr;
	m_pBtn_Join = nullptr;
	m_pBtn_Create = nullptr;
	m_pBtn_Destroy = nullptr;
	m_pBtn_Withdraw = nullptr;
	m_pEdit_KnightsName = nullptr;
}

bool CUIKnightsOperation::Load(File& file)
{
	if(false == CN3UIBase::Load(file)) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Up, GetChildByID<CN3UIButton>("btn_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Down, GetChildByID<CN3UIButton>("btn_down"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close, GetChildByID<CN3UIButton>("btn_close"));

	N3_VERIFY_UI_COMPONENT(m_pList_Knights, GetChildByID<CN3UIList>("List_Knights"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Join, GetChildByID<CN3UIButton>("Btn_Join"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Create, GetChildByID<CN3UIButton>("Btn_Create"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Destroy, GetChildByID<CN3UIButton>("Btn_Destroy"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Withdraw, GetChildByID<CN3UIButton>("Btn_Withdraw"));
	N3_VERIFY_UI_COMPONENT(m_pEdit_KnightsName, GetChildByID<CN3UIEdit>("Edit_KnightsName"));

	return true;
}

bool CUIKnightsOperation::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		POINT pt;
		::GetCursorPos(&pt);

		if(pSender == m_pBtn_Up)
		{
			m_iPageCur--;
			if(m_iPageCur < 0)
			{
				m_iPageCur = 0;
			}
			else
			{
				this->MsgSend_KnightsList(m_iPageCur);
			}
		}
		else if(pSender == m_pBtn_Up)
		{
			m_iPageCur--;
			if(m_iPageCur < 0)
			{
				m_iPageCur = 0;
			}
			else
			{
				this->MsgSend_KnightsList(m_iPageCur);
			}
		}
		else if(pSender == m_pBtn_Close) 
		{
			this->Close();
		}
		else if(pSender == m_pBtn_Create)
		{
			this->MsgSend_KnightsCreate();
		}
		else if(pSender == m_pBtn_Join) // 가입
		{
			this->MsgSend_KnightsJoin();
		}
		else if(pSender == m_pBtn_Destroy) // 탈퇴
		{
			std::string szMsg = fmt::format_text_resource(IDS_KNIGHTS_DESTROY_CONFIRM);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_KNIGHTS_DESTROY); // 기사단 해체 물어보기..
		}
		else if(pSender == m_pBtn_Withdraw) // 탈퇴
		{
			std::string szMsg = fmt::format_text_resource(IDS_KNIGHTS_WITHDRAW_CONFIRM);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_KNIGHTS_WITHDRAW); // 기사단 탈퇴 물어보기..
		}
	}
	else if(dwMsg == UIMSG_LIST_SELCHANGE)
	{
		if(pSender == m_pList_Knights)
		{
		}
	}

	return false;
}

void CUIKnightsOperation::KnightsInfoDelete(int iID)
{
	it_KIB it = m_KnightsMapBase.find(iID);
	if(it != m_KnightsMapBase.end()) m_KnightsMapBase.erase(it);
}

void CUIKnightsOperation::KnightsInfoInsert(int iID, const std::string& szName)
{
	__KnightsInfoBase KIB;
	KIB.iID = iID;
	KIB.szName = szName;

	m_KnightsMapBase.insert(val_KIB(iID, KIB));
}

__KnightsInfoBase* CUIKnightsOperation::KnightsInfoFind(int iID)
{
	it_KIB it = m_KnightsMapBase.find(iID);
	if(it != m_KnightsMapBase.end()) return &(it->second);
	return nullptr;
}

void CUIKnightsOperation::KnightsListAdd(	int iID,
											const std::string& szName,
											const std::string& szChiefName,
											int iMemberCount,
											int iPoint)
{
	__KnightsInfoExt KIE;
	KIE.iID = iID;
	KIE.szName = szName;
	KIE.szChiefName = szChiefName;
	KIE.iMemberCount = iMemberCount;
	KIE.iPoint = iPoint;

	m_KnightsListExt.push_back(KIE);
}

void CUIKnightsOperation::KnightsListUpdate()
{
	if(nullptr == m_pList_Knights) return;

	m_pList_Knights->ResetContent();

	std::string szBuff;
	for (const __KnightsInfoExt& KIE : m_KnightsListExt)
	{
		szBuff = fmt::format("{:16} {:12} {:4} {:8}",
			KIE.szName, KIE.szChiefName, KIE.iMemberCount, KIE.iPoint);
		m_pList_Knights->AddString(szBuff);
	}
}

void CUIKnightsOperation::KnightsListClear()
{
	m_KnightsListExt.clear();
	if(m_pList_Knights) m_pList_Knights->ResetContent();
}

void CUIKnightsOperation::ChangeUIByDuty(e_KnightsDuty eDuty)
{
	if(eDuty == KNIGHTS_DUTY_CHIEF) // 기사단장이면 기사단 해체도 가능하다..
	{
		if(m_pBtn_Destroy) m_pBtn_Destroy->SetState(UI_STATE_BUTTON_NORMAL);
		if(m_pBtn_Withdraw) m_pBtn_Withdraw->SetState(UI_STATE_BUTTON_DISABLE); // 기사 단장이 탈퇴한다????!!!!
		if(m_pBtn_Join) m_pBtn_Join->SetState(UI_STATE_BUTTON_DISABLE);
	}
	else 
	{
		if(m_pBtn_Destroy) m_pBtn_Destroy->SetState(UI_STATE_BUTTON_DISABLE);
		if(m_pBtn_Withdraw) m_pBtn_Withdraw->SetState(UI_STATE_BUTTON_NORMAL); // 기사 단장이 탈퇴한다????!!!!
		if(m_pBtn_Join) m_pBtn_Join->SetState(UI_STATE_BUTTON_NORMAL);
	}
}

void CUIKnightsOperation::Open(e_KnightsDuty eDuty)
{
	m_iPageCur = 0;
	this->KnightsListClear(); // 기사단 정보 클리어
	this->SetPosCenter(); // 가운데로 맞추고..
	this->SetVisible(true);

	this->ChangeUIByDuty(eDuty); // 권한에 따라 UI 변경..
}

void CUIKnightsOperation::Close()
{
	this->KnightsListClear(); // 기사단 정보 클리어
	this->SetVisible(false);
	if(m_pEdit_KnightsName) m_pEdit_KnightsName->KillFocus(); // 이래야 다른곳에 문제가 안생긴다..
}

bool CUIKnightsOperation::MsgRecv_KnightsList(Packet& pkt)
{
	m_iPageCur = pkt.read<int16_t>();
	int iKC = pkt.read<int16_t>();
	int iID, iNameLength, iMemberCount, iPoint;
	std::string szName, szChiefName;
	for(int i = 0; i < iKC; i++)
	{
		iID = pkt.read<int16_t>();
		iNameLength = pkt.read<int16_t>();
		pkt.readString(szName, iNameLength);
		iMemberCount = pkt.read<int16_t>();
		iNameLength = pkt.read<int16_t>();
		pkt.readString(szChiefName, iNameLength);
		iPoint = pkt.read<uint32_t>();

		this->KnightsListAdd(iID, szName, szChiefName, iMemberCount, iPoint); // UI 에 추가..
	}
	this->KnightsListUpdate(); // List 에 다 넣었으면 UI Update!!
	this->EnableKnightsUIs(true); // Disable 된 버튼들 Enable 시킨다.

	return true;
}

void CUIKnightsOperation::MsgSend_KnightsCreate()
{
	if(nullptr == m_pEdit_KnightsName) return;

	std::string szKnightsName = m_pEdit_KnightsName->GetString();
	if(szKnightsName.empty()) // 이름이 없으면 에러..
	{
		std::string szMsg = fmt::format_text_resource(IDS_ERR_KNIGHTS_CREATE_FAILED_NAME_EMPTY);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff00ff);
		return;
	}

	int iOffset = 0;
	uint8_t byBuff[128];

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_CREATE); // 생성 Send - s1(Name Length) str1 | Recv - b1(1:성공 0:실패)
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szKnightsName.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szKnightsName);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIKnightsOperation::MsgSend_KnightsDestroy()
{
	int iOffset = 0;
	uint8_t byBuff[8];

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_DESTROY); // 생성 Send - s1(Name Length) str1 | Recv - b1(1:성공 0:실패)

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIKnightsOperation::MsgSend_KnightsJoin()
{
	if(nullptr == m_pList_Knights) return;
	int iCurSel = m_pList_Knights->GetCurSel();
	if (iCurSel < 0
		|| iCurSel >= static_cast<int>(m_KnightsListExt.size()))
		return;

	auto it = m_KnightsListExt.begin();
	std::advance(it, iCurSel);

	__KnightsInfoExt KIE = (*it);

	int iOffset = 0;
	uint8_t byBuff[32];

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_JOIN);
	CAPISocket::MP_AddShort(byBuff, iOffset, KIE.iID);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIKnightsOperation::MsgSend_KnightsWithdraw()
{
	uint8_t byBuff[32];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_WITHDRAW);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIKnightsOperation::MsgSend_KnightsList(int iPage)
{
	int iOffset = 0;
	uint8_t byBuff[32];
	
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_GRADE_CHANGE_ALL);
	CAPISocket::MP_AddShort(byBuff, iOffset, iPage);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	// 페이지를 넘길때는 버튼들을 막아 놓는다.
	this->EnableKnightsUIs(false);
}

void CUIKnightsOperation::EnableKnightsUIs(bool bEnable)
{
	eUI_STATE eState = UI_STATE_BUTTON_NORMAL;
	if(bEnable) eState = UI_STATE_BUTTON_NORMAL;
	else eState = UI_STATE_BUTTON_DISABLE;
	
	if(m_pBtn_Up) m_pBtn_Up->SetState(eState);
	if(m_pBtn_Down) m_pBtn_Down->SetState(eState);
	if(m_pBtn_Close) m_pBtn_Close->SetState(eState);

	if(m_pList_Knights) m_pList_Knights->SetState(eState);
	if(m_pBtn_Join) m_pBtn_Join->SetState(eState);
	if(m_pBtn_Create) m_pBtn_Create->SetState(eState);
	if(m_pBtn_Withdraw) m_pBtn_Withdraw->SetState(eState);
	if(m_pEdit_KnightsName) m_pEdit_KnightsName->SetState(eState);
}

// ===== END WarFare/UIKnightsOperation.cpp =====

// ===== BEGIN WarFare/UIKnightsOperation.h =====
#line 1 "WarFare/UIKnightsOperation.h"
﻿// UIKnightsOperation.h: interface for the CUIKnightsOperation class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIKNIGHTSOPERATION_H__1AE95FA6_E4DE_45DF_9EEA_6AEDE400ECA7__INCLUDED_)
#define AFX_UIKNIGHTSOPERATION_H__1AE95FA6_E4DE_45DF_9EEA_6AEDE400ECA7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#include <list>
#include <string>

struct __KnightsInfoBase
{
	int iID;
	std::string szName;
};

struct __KnightsInfoExt : public __KnightsInfoBase
{
	std::string szChiefName;
	int iMemberCount;
	int iPoint;
};

typedef std::map<int, __KnightsInfoBase>::iterator it_KIB;
typedef std::map<int, __KnightsInfoBase>::value_type val_KIB;

typedef std::list<__KnightsInfoExt>::iterator it_KIE;

class Packet;
class CUIKnightsOperation : public CN3UIBase  
{
protected:
	int				m_iPageCur;
	std::map<int, __KnightsInfoBase>	m_KnightsMapBase;
	std::list<__KnightsInfoExt>			m_KnightsListExt;

	CN3UIButton*	m_pBtn_Up;
	CN3UIButton*	m_pBtn_Down;
	CN3UIButton*	m_pBtn_Close;

	CN3UIList*		m_pList_Knights; //
	CN3UIButton*	m_pBtn_Join;
	CN3UIButton*	m_pBtn_Create;
	CN3UIButton*	m_pBtn_Destroy;
	CN3UIButton*	m_pBtn_Withdraw;
	CN3UIEdit*		m_pEdit_KnightsName;

public:
	void	ChangeUIByDuty(enum e_KnightsDuty eDuty); // 권한에 따라 UI 변경..
	void	Open(enum e_KnightsDuty eDuty);
	void	Close();

	__KnightsInfoBase*	KnightsInfoFind(int iID);
	void				KnightsInfoInsert(int iID, const std::string& szName);
	void				KnightsInfoDelete(int iID);

	void	KnightsListAdd(	int iID,
							const std::string& szName,
							const std::string& szChiefName,
							int iMemberCount,
							int iKnightsPoint);
	void	KnightsListUpdate();
	void	KnightsListClear();

	bool	MsgRecv_KnightsList(Packet& pkt);
	void	MsgSend_KnightsCreate();
	void	MsgSend_KnightsDestroy();
	void	MsgSend_KnightsJoin();
	void	MsgSend_KnightsWithdraw(); // 탈퇴. 
	void	MsgSend_KnightsList(int iPage); // 페이지 단위로 기사단들 정보 요청.. 10 개씩 온다.

	void	EnableKnightsUIs(bool bEnable);
	
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;

	void Release() override;
	CUIKnightsOperation();
	~CUIKnightsOperation() override;

};

#endif // !defined(AFX_UIKNIGHTSOPERATION_H__1AE95FA6_E4DE_45DF_9EEA_6AEDE400ECA7__INCLUDED_)

// ===== END WarFare/UIKnightsOperation.h =====

// ===== BEGIN WarFare/UILevelGuide.cpp =====
#line 1 "WarFare/UILevelGuide.cpp"
﻿// UILevelGuide.cpp: implementation of the CUILevelGuide class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UILevelGuide.h"
#include "GameDef.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIScrollBar.h>
#include <N3Base/N3UIString.h>

#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CUILevelGuide::CUILevelGuide()
{
	m_pEdit_Level			= nullptr;
	m_pText_Page			= nullptr;
	m_pBtn_Check			= nullptr;
	m_pText_Level			= nullptr;
	m_pBtn_Up				= nullptr;
	m_pBtn_Down				= nullptr;
	m_pBtn_Cancel			= nullptr;

	m_iSearchLevel			= 0;
	m_iPageNo				= 0;

	for (int i = 0; i < MAX_QUESTS_PER_PAGE; i++)
	{
		m_pScroll_Guide[i]	= nullptr;
		m_pText_Guide[i]	= nullptr;
		m_pText_Title[i]	= nullptr;
	}
}

CUILevelGuide::~CUILevelGuide()
{
}

void CUILevelGuide::Release()
{
	CN3UIBase::Release();

	m_pEdit_Level			= nullptr;
	m_pText_Page			= nullptr;
	m_pBtn_Check			= nullptr;
	m_pText_Level			= nullptr;
	m_pBtn_Up				= nullptr;
	m_pBtn_Down				= nullptr;
	m_pBtn_Cancel			= nullptr;

	m_iSearchLevel			= 0;
	m_iPageNo				= 0;

	for (int i = 0; i < MAX_QUESTS_PER_PAGE; i++)
	{
		m_pScroll_Guide[i]	= nullptr;
		m_pText_Guide[i]	= nullptr;
		m_pText_Title[i]	= nullptr;
	}
}

bool CUILevelGuide::Load(File& file)
{
	if (!CN3UIBase::Load(file)) 
		return false;

	std::string szID;

	N3_VERIFY_UI_COMPONENT(m_pEdit_Level,			GetChildByID<CN3UIEdit>("edit_level"));
	N3_VERIFY_UI_COMPONENT(m_pText_Page,			GetChildByID<CN3UIString>("text_page"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Check,			GetChildByID<CN3UIButton>("btn_check"));
	N3_VERIFY_UI_COMPONENT(m_pText_Level,			GetChildByID<CN3UIString>("text_level"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Up,				GetChildByID<CN3UIButton>("btn_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Down,				GetChildByID<CN3UIButton>("btn_down"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,			GetChildByID<CN3UIButton>("btn_cancel"));

	for (int i = 0; i < MAX_QUESTS_PER_PAGE; i++)
	{
		szID = "scroll_guide" + std::to_string(i);
		N3_VERIFY_UI_COMPONENT(m_pScroll_Guide[i],	GetChildByID<CN3UIScrollBar>(szID));

		szID = "text_guide" + std::to_string(i);
		N3_VERIFY_UI_COMPONENT(m_pText_Guide[i],	GetChildByID<CN3UIString>(szID));

		szID = "text_title" + std::to_string(i);
		N3_VERIFY_UI_COMPONENT(m_pText_Title[i],	GetChildByID<CN3UIString>(szID));
	}

	return true;
}

void CUILevelGuide::SearchQuests()
{
	if (m_pEdit_Level == nullptr)
		return;

	const std::string& szSearchLevel = m_pEdit_Level->GetString();

	int iSearchLevel = std::atoi(szSearchLevel.c_str());
	if (iSearchLevel == 0)
		return;

	// NOTE: This officially only checks the one way.
	if ((CGameBase::s_pPlayer->m_InfoBase.iLevel + MAX_SEARCH_LEVEL_RANGE) < iSearchLevel)
	{
		std::string szMsg = fmt::format_text_resource(IDS_QUEST_SEARCH_LEVEL_ERROR,
			MAX_SEARCH_LEVEL_RANGE);
		CGameProcedure::MessageBoxPost(szMsg, "", MB_OK);

		iSearchLevel = CGameBase::s_pPlayer->m_InfoBase.iLevel + MAX_SEARCH_LEVEL_RANGE;
	}

	m_iSearchLevel = iSearchLevel;

	SetPageNo(0);

	m_pEdit_Level->SetString("");
	m_pEdit_Level->SetFocus();
}

void CUILevelGuide::SetPageNo(int iPageNo)
{
	int iSearchLevel;

	// if user entered a search level we should use it, otherwise use the user's current level
	if (m_iSearchLevel <= 0)
		iSearchLevel = CGameBase::s_pPlayer->m_InfoBase.iLevel;
	else
		iSearchLevel = m_iSearchLevel;

	// officially shows searched level
	if (m_pText_Level != nullptr)
		m_pText_Level->SetStringAsInt(iSearchLevel);

	// entered level cannot be bigger than max, cannot be smaller than min level
	iSearchLevel = std::clamp(iSearchLevel, 1, MAX_LEVEL);

	// set focus to edit on open
	if (m_pEdit_Level != nullptr)
		m_pEdit_Level->SetFocus();

	e_Class_Represent eCR = CGameBase::GetRepresentClass(CGameBase::s_pPlayer->m_InfoBase.eClass);

	// Build list of eligible quests
	std::vector<const __TABLE_HELP*> eligibleQuests;

	auto& questDataMap = CGameBase::s_pTbl_Help.GetMap();
	for (const auto& [_, questData] : questDataMap)
	{
		if (iSearchLevel < questData.iMinLevel
			|| iSearchLevel > questData.iMaxLevel)
			continue;

		if (questData.iReqClass == CLASS_REPRESENT_UNKNOWN
			|| questData.iReqClass == eCR)
			eligibleQuests.push_back(&questData);
	}

	int iPageCount = (static_cast<int>(eligibleQuests.size()) + MAX_QUESTS_PER_PAGE - 1) / MAX_QUESTS_PER_PAGE;

	// If we're ahead, we should roll it back to the last visible page.
	if (iPageNo >= iPageCount)
		iPageNo = iPageCount - 1;

	if (iPageNo < 0)
		iPageNo = 0;

	m_iPageNo = iPageNo;

	int iStartIndex = iPageNo * MAX_QUESTS_PER_PAGE;
	int iVisibleIndex = 0;

	// Skip straight to the first eligible quest for this page.
	auto itr = eligibleQuests.begin();
	std::advance(itr, iStartIndex);

	// Attempt to display all 3, assuming 3 are present.
	while (itr != eligibleQuests.end())
	{
		const __TABLE_HELP* pQuestData = *itr;

		if (m_pText_Title[iVisibleIndex] != nullptr)
			m_pText_Title[iVisibleIndex]->SetString(pQuestData->szQuestName);

		if (m_pText_Guide[iVisibleIndex] != nullptr)
			m_pText_Guide[iVisibleIndex]->SetString(pQuestData->szQuestDesc);

		if (++iVisibleIndex >= MAX_QUESTS_PER_PAGE)
			break;

		++itr;
	}

	// Reset remaining quests if there weren't enough quests.
	for (int i = iVisibleIndex; i < MAX_QUESTS_PER_PAGE; i++)
	{
		if (m_pText_Title[i] != nullptr)
			m_pText_Title[i]->SetString("");

		if (m_pText_Guide[i] != nullptr)
			m_pText_Guide[i]->SetString("");
	}

	if (m_pText_Page != nullptr)
		m_pText_Page->SetStringAsInt(m_iPageNo + 1);
}

void CUILevelGuide::SetTopLine(CN3UIScrollBar* pScroll, CN3UIString* pTextGuide)
{
	if (pTextGuide == nullptr
		|| pScroll == nullptr)
		return;

	// total number of lines of text
	const int iTotalLineCount = pTextGuide->GetLineCount();

	// max number of lines visible in text area
	const int iVisibleLineCount = 4;

	// return if text is shorter than or equal to 4 lines
	if (iTotalLineCount <= iVisibleLineCount)
		return;

	// limit check for the line which displayed first, topline
	int iTopLine = std::clamp(pScroll->GetCurrentPos(), 0, iTotalLineCount - iVisibleLineCount);
	pTextGuide->SetStartLine(iTopLine);
}

void CUILevelGuide::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if (bVisible)
	{
		SetPageNo(0);
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	}
	else
	{
		if (m_pEdit_Level != nullptr
			&& m_pEdit_Level->HaveFocus())
			m_pEdit_Level->KillFocus();

		CGameProcedure::s_pUIMgr->ReFocusUI();
	}
}

bool CUILevelGuide::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Cancel)
		{
			SetVisible(false);
			return true;
		}
		else if (pSender == m_pBtn_Up)
		{
			SetPageNo(m_iPageNo + 1);
			return true;
		}
		else if (pSender == m_pBtn_Down)
		{
			SetPageNo(m_iPageNo - 1);
			return true;
		}
		else if (pSender == m_pBtn_Check)
		{
			SearchQuests();
			return true;
		}
	}
	else if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		for (int i = 0; i < MAX_QUESTS_PER_PAGE; i++)
		{
			if (pSender != m_pScroll_Guide[i])
				continue;

			if (m_pText_Guide[i] != nullptr)
				SetTopLine(m_pScroll_Guide[i], m_pText_Guide[i]);

			break;
		}

		return true;
	}

	return false;
}

bool CUILevelGuide::OnKeyPress(int iKey)
{
	if (iKey == DIK_ESCAPE)
	{
		SetVisible(false);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UILevelGuide.cpp =====

// ===== BEGIN WarFare/UILevelGuide.h =====
#line 1 "WarFare/UILevelGuide.h"
﻿// UILevelGuide.h: interface for the CUILevelGuide class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UILevelGuide_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_)
#define AFX_UILevelGuide_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUILevelGuide : public CN3UIBase
{
protected:
	static constexpr int MAX_SEARCH_LEVEL_RANGE	= 5;
	static constexpr int MAX_QUESTS_PER_PAGE	= 3;

	CN3UIEdit*		m_pEdit_Level;
	CN3UIScrollBar*	m_pScroll_Guide[MAX_QUESTS_PER_PAGE];
	CN3UIString*	m_pText_Guide[MAX_QUESTS_PER_PAGE];
	CN3UIString*	m_pText_Title[MAX_QUESTS_PER_PAGE];
	CN3UIString*	m_pText_Page;
	CN3UIButton*	m_pBtn_Check;
	CN3UIString*	m_pText_Level;
	CN3UIButton*	m_pBtn_Up;
	CN3UIButton*	m_pBtn_Down;
	CN3UIButton*	m_pBtn_Cancel;

	int				m_iSearchLevel;
	int				m_iPageNo;

public:
	CUILevelGuide();
	~CUILevelGuide() override;
	bool Load(File& file) override;
	void Release() override;
	void SetVisible(bool bVisible) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool OnKeyPress(int iKey) override;
	void SearchQuests();
	void SetPageNo(int iPageNo);

protected:
	void SetTopLine(CN3UIScrollBar* pScroll, CN3UIString* pTextGuide);
};

#endif // !defined(AFX_UIStateBar_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_)

// ===== END WarFare/UILevelGuide.h =====

// ===== BEGIN WarFare/UILoading.cpp =====
#line 1 "WarFare/UILoading.cpp"
﻿// UILoading.cpp: implementation of the UILoading class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UILoading.h"
#include "GameDef.h"
#include "GameEng.h"
#include "GameProcedure.h"
#include "UIManager.h"

#include <N3Base/N3UIProgress.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUILoading::CUILoading()
{
	m_pText_Info = nullptr;
	m_pText_Version = nullptr;
	m_pProgress_Loading = nullptr;
}

CUILoading::~CUILoading()
{
	CUILoading::Release();
}

void CUILoading::Release()
{
	CN3UIBase::Release();

	m_pText_Info = nullptr;
	m_pText_Version = nullptr;
	m_pProgress_Loading = nullptr;
}

bool CUILoading::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pText_Version,		GetChildByID<CN3UIString>("Text_Version"));
	if (m_pText_Version != nullptr)
	{
		std::string version = fmt::format("Ver. {:.3f}", CURRENT_VERSION / 1000.0f);
		m_pText_Version->SetString(version);
	}

	N3_VERIFY_UI_COMPONENT(m_pText_Info,		GetChildByID<CN3UIString>("Text_Info"));
	N3_VERIFY_UI_COMPONENT(m_pProgress_Loading,	GetChildByID<CN3UIProgress>("Progress_Loading"));

	SetPosCenter(); // 가운데로 맞추기..
	m_pText_Version->SetPos(10, 10); // Version 은 맨위에 표시..
	
	if (m_pProgress_Loading != nullptr)
		m_pProgress_Loading->SetRange(0, 100);

	return true;
}

void CUILoading::Render(const std::string& szInfo, int iPercentage)
{
	if(m_pText_Info) m_pText_Info->SetString(szInfo);
	if(m_pProgress_Loading) m_pProgress_Loading->SetCurValue(iPercentage);

	D3DCOLOR crEnv = 0x00000000;
	CGameProcedure::s_pEng->Clear(crEnv); // 배경은 검은색
	CN3Base::s_lpD3DDev->BeginScene();			// 씬 렌더 ㅅ작...
	
	CN3UIBase::Tick();
	CUIManager::RenderStateSet();
	CN3UIBase::Render();
	CUIManager::RenderStateRestore();
	
	CN3Base::s_lpD3DDev->EndScene();			// 씬 렌더 시작...
	CGameProcedure::s_pEng->Present(CN3Base::s_hWndBase);
}

// ===== END WarFare/UILoading.cpp =====

// ===== BEGIN WarFare/UILoading.h =====
#line 1 "WarFare/UILoading.h"
﻿// UILoading.h: interface for the UILoading class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UILoading_H__81E8BA13_2261_4A3D_9A94_BF0E7C49C4DD__INCLUDED_)
#define AFX_UILoading_H__81E8BA13_2261_4A3D_9A94_BF0E7C49C4DD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUILoading : public CN3UIBase
{
protected:
	CN3UIString*	m_pText_Version;
	CN3UIString*	m_pText_Info;
	CN3UIProgress*	m_pProgress_Loading;

public:
	bool Load(File& file) override;
	CUILoading();
	~CUILoading() override;

	virtual void Render(const std::string& szInfo, int iPercentage);
	void Release() override;
};

#endif // !defined(AFX_UILoading_H__81E8BA13_2261_4A3D_9A94_BF0E7C49C4DD__INCLUDED_)

// ===== END WarFare/UILoading.h =====

// ===== BEGIN WarFare/UILogin_1098.cpp =====
#line 1 "WarFare/UILogin_1098.cpp"
﻿#include "stdafx.h"

#if defined(LOGIN_SCENE_VERSION) && LOGIN_SCENE_VERSION == 1098
#include "UILogIn_1098.h"
#include "GameProcLogIn_1098.h"
#include "UIMessageBoxManager.h"
#include "text_resources.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIList.h>

#include <algorithm>
#include <shellapi.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUILogIn_1098::CUILogIn_1098()
{
	m_pEdit_id = nullptr;
	m_pEdit_pw = nullptr;

	m_pBtn_LogIn = nullptr;
	m_pBtn_Connect = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pBtn_Option = nullptr;
	m_pBtn_Join = nullptr;

	m_pGroup_ServerList = nullptr;
	m_pGroup_LogIn = nullptr;

	m_pText_Rights = nullptr;
	m_pImg_MGameLogo = nullptr;
	m_pImg_DaumLogo = nullptr;
	m_pImg_GradeLogo = nullptr;

	m_pList_Server = nullptr;

	m_bOpenningNow = false; // 위에서 아래로 스르륵...열려야 한다면..
	m_fMoveDelta = 0;

	m_bLogIn = false;
}

CUILogIn_1098::~CUILogIn_1098()
{
}

bool CUILogIn_1098::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_LogIn
			&& m_pEdit_id != nullptr
			&& m_pEdit_pw != nullptr)
		{
			CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
			return true;
		}
		else if (pSender == m_pBtn_Connect)
		{
			CGameProcedure::s_pProcLogIn->ConnectToGameServer(); // 고른 게임 서버에 접속
			return true;
		}
		else if (pSender == m_pBtn_Cancel)
		{
			PostQuitMessage(0);	// 종료...
			return true;
		}
		else if (pSender == m_pBtn_Option) // 옵션..
		{
			std::string szMsg = fmt::format_text_resource(IDS_CONFIRM_EXECUTE_OPTION);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_EXECUTE_OPTION);
			return true;
		}
		else if (pSender == m_pBtn_Join)
		{
			if (!CGameProcedure::s_pProcLogIn->m_szRegistrationSite.empty())
			{
				ShellExecute(nullptr, "open", CGameProcedure::s_pProcLogIn->m_szRegistrationSite.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
			}

			return true;
		}
	}
	else if (UIMSG_LIST_DBLCLK == dwMsg)
	{
		CGameProcedure::s_pProcLogIn->ConnectToGameServer(); // 고른 게임 서버에 접속
		return true;
	}
	else if (dwMsg == UIMSG_EDIT_RETURN)
	{
		// TEMP(srmeier): there is a weird issue where the key inputs aren't going
		// through CGameProcedure::ProcessUIKeyInput() so CUILogIn_1098::OnKeyPress() isn't
		// being called...
		if (!m_bLogIn && m_pEdit_id && m_pEdit_pw)
		{
			CN3UIBase* pMsgBox = CGameProcedure::s_pMsgBoxMgr->GetFocusMsgBox();
			if (!(pMsgBox && pMsgBox->IsVisible()))
				CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
		}
		else
		{
			return ReceiveMessage(m_pBtn_Connect, UIMSG_BUTTON_CLICK);
		}
	}

	return false;
}

bool CUILogIn_1098::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pGroup_LogIn,		GetChildByID("Group_LogIn"));

	if (m_pGroup_LogIn != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_LogIn,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("Btn_Login"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("Btn_Cancel"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Option,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("Btn_Option"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Join,		m_pGroup_LogIn->GetChildByID<CN3UIButton>("Btn_Join"));

		N3_VERIFY_UI_COMPONENT(m_pEdit_id,		m_pGroup_LogIn->GetChildByID<CN3UIEdit>("Edit_ID"));
		N3_VERIFY_UI_COMPONENT(m_pEdit_pw,		m_pGroup_LogIn->GetChildByID<CN3UIEdit>("Edit_PW"));

		// N3_VERIFY_UI_COMPONENT(m_pImg_GradeLogo,	m_pGroup_LogIn->GetChildByID("Img_Grade"));
	}

	N3_VERIFY_UI_COMPONENT(m_pText_Rights,		GetChildByID("Text_Rights"));
	N3_VERIFY_UI_COMPONENT(m_pImg_MGameLogo,	GetChildByID("Img_MGame"));
	N3_VERIFY_UI_COMPONENT(m_pImg_DaumLogo,		GetChildByID("Img_Daum"));

	if (m_pText_Rights != nullptr)
		m_pText_Rights->SetVisible(false);

	if (m_pImg_MGameLogo != nullptr)
		m_pImg_MGameLogo->SetVisible(false);

	if (m_pImg_DaumLogo != nullptr)
		m_pImg_DaumLogo->SetVisible(false);

	const std::string szIDsToHide[] =
	{
		"Group_Notice_1",
		"Group_Notice_2",
		"Group_Notice_3",
		"premium"
	};

	for (const std::string& szID : szIDsToHide)
	{
		CN3UIBase* pChild = GetChildByID(szID);
		if (pChild != nullptr)
			pChild->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pGroup_ServerList, GetChildByID("Group_ServerList"));
	if (m_pGroup_ServerList != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pList_Server,	m_pGroup_ServerList->GetChildByID<CN3UIList>("List_Server"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Connect,	m_pGroup_ServerList->GetChildByID<CN3UIButton>("Btn_Connect"));

		m_pGroup_ServerList->SetVisible(false);
	}

	return true;
}

void CUILogIn_1098::AccountIDGet(std::string& szID)
{
	if (m_pEdit_id != nullptr)
		szID = m_pEdit_id->GetString();
	else
		szID.clear();
}

void CUILogIn_1098::AccountPWGet(std::string& szPW)
{
	if (m_pEdit_pw != nullptr)
		szPW = m_pEdit_pw->GetString();
	else
		szPW.clear();
}

void CUILogIn_1098::ConnectButtonSetEnable(bool bEnable)
{
	eUI_STATE eState1 = (bEnable ? UI_STATE_BUTTON_NORMAL : UI_STATE_BUTTON_DISABLE);
	eUI_STATE eState2 = (bEnable ? UI_STATE_LIST_ENABLE : UI_STATE_LIST_DISABLE);

	if (m_pBtn_Connect != nullptr)
		m_pBtn_Connect->SetState(eState1);

	if (m_pList_Server != nullptr)
		m_pList_Server->SetState(eState2);
}

void CUILogIn_1098::FocusToID()
{
	if (m_pEdit_id != nullptr)
		m_pEdit_id->SetFocus();
}

void CUILogIn_1098::FocusCircular()
{
	if (m_pEdit_id == nullptr
		|| m_pEdit_pw == nullptr)
		return;

	if (m_pEdit_id->HaveFocus())
		m_pEdit_pw->SetFocus();
	else
		m_pEdit_id->SetFocus();
}

void CUILogIn_1098::InitEditControls()
{
	if (m_pEdit_id != nullptr)
	{
		m_pEdit_id->SetString("");
		m_pEdit_id->SetFocus();
	}

	if (m_pEdit_pw != nullptr)
		m_pEdit_pw->SetString("");
}

bool CUILogIn_1098::ServerInfoAdd(const __GameServerInfo& GSI)
{
	m_ListServerInfos.push_back(GSI);
	return true;
}

bool CUILogIn_1098::ServerInfoGet(int iIndex, __GameServerInfo& GSI)
{
	if (m_pList_Server == nullptr
		|| iIndex < 0
		|| iIndex >= static_cast<int>(m_ListServerInfos.size()))
		return false;

	GSI = m_ListServerInfos[iIndex];
	return true;
}

bool CUILogIn_1098::ServerInfoGetCur(__GameServerInfo& GSI)
{
	GSI.Init();

	if (m_pList_Server == nullptr)
		return false;

	int iIndex = m_pList_Server->GetCurSel();
	return ServerInfoGet(iIndex, GSI);
}

void CUILogIn_1098::ServerInfoUpdate()
{
	if (m_pList_Server == nullptr)
		return;

	m_pList_Server->ResetContent();
	if (!m_ListServerInfos.empty())
	{
		//sort(m_ListServerInfos.begin(), m_ListServerInfos.end(), not2(__GameServerInfo()));
		for (const __GameServerInfo& GSI : m_ListServerInfos)
			m_pList_Server->AddString(GSI.szName);
	}
}

void CUILogIn_1098::Tick()
{
	CN3UIBase::Tick();

	if (m_pGroup_ServerList != nullptr)
	{
		// 위에서 아래로 스르륵...열려야 한다면..
		if (m_bOpenningNow)
		{
			POINT ptCur = m_pGroup_ServerList->GetPos();
			RECT rc = m_pGroup_ServerList->GetRegion();
			float fHeight = (float) (rc.bottom - rc.top);

			float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
			fDelta *= (fHeight - m_fMoveDelta) / fHeight;
			if (fDelta < 2.0f)
				fDelta = 2.0f;
			m_fMoveDelta += fDelta;

			int iYLimit = 0;
			ptCur.y = (int) (m_fMoveDelta - fHeight);
			if (ptCur.y >= iYLimit) // 다열렸다!!
			{
				ptCur.y = iYLimit;
				m_bOpenningNow = false;
			}

			m_pGroup_ServerList->SetPos(ptCur.x, ptCur.y);
		}
	}
}

void CUILogIn_1098::OpenServerList()
{
	if (m_bOpenningNow
		|| m_pGroup_ServerList == nullptr)
		return;

	// 스르륵 열린다!!
	m_pGroup_ServerList->SetVisible(true);
	RECT rc = m_pGroup_ServerList->GetRegion();
	m_pGroup_ServerList->SetPos(0, -(rc.bottom - rc.top));

	m_fMoveDelta = 0;
	m_bOpenningNow = true;
}

void CUILogIn_1098::SetVisibleLogInUIs(bool bEnable)
{
	// 로그인을 숨긴다..
	if (m_pGroup_LogIn != nullptr)
		m_pGroup_LogIn->SetVisible(bEnable);

	// 로그인한 계정의 구분에 따라 UI 만지기...
	if (m_pText_Rights != nullptr)
		m_pText_Rights->SetVisible(false);

	if (m_pImg_MGameLogo != nullptr)
		m_pImg_MGameLogo->SetVisible(false);

	if (m_pImg_DaumLogo != nullptr)
		m_pImg_DaumLogo->SetVisible(false);

	if (!bEnable)
	{
		if (LIC_MGAME == CGameProcedure::s_eLogInClassification)
		{
			if (m_pText_Rights != nullptr
				&& m_pImg_MGameLogo != nullptr)
			{
				// 아래쪽 중단으로 맞춘다..
				RECT rcView = { 0, 0, (int) s_CameraData.vp.Width, (int) s_CameraData.vp.Height };
				int iX = (rcView.right - (m_pText_Rights->GetWidth() + m_pImg_MGameLogo->GetWidth())) / 2;
				int iY = rcView.bottom - m_pText_Rights->GetHeight() - 20;
				m_pText_Rights->SetPos(iX, iY);

				RECT rc = m_pText_Rights->GetRegion();
				m_pImg_MGameLogo->SetPos(rc.right, rcView.bottom - m_pImg_MGameLogo->GetHeight() - 20);

				m_pText_Rights->SetVisible(true);
				m_pImg_MGameLogo->SetVisible(true);
			}
		}
		else if (LIC_DAUM == CGameProcedure::s_eLogInClassification)
		{
			if (m_pText_Rights != nullptr
				&& m_pImg_DaumLogo != nullptr)
			{
				// 아래쪽 중단으로 맞춘다..
				RECT rcView = { 0, 0, (int) s_CameraData.vp.Width, (int) s_CameraData.vp.Height };
				int iX = (rcView.right - (m_pText_Rights->GetWidth() + m_pImg_DaumLogo->GetWidth())) / 2;
				int iY = rcView.bottom - m_pText_Rights->GetHeight() - 20;
				m_pText_Rights->SetPos(iX, iY);

				RECT rc = m_pText_Rights->GetRegion();
				m_pImg_DaumLogo->SetPos(rc.right, rcView.bottom - m_pImg_DaumLogo->GetHeight() - 20);

				m_pText_Rights->SetVisible(true);
				m_pImg_DaumLogo->SetVisible(true);
			}
		}
		else
		{
			if (m_pText_Rights != nullptr)
			{
				RECT rcView = { 0, 0, (int) s_CameraData.vp.Width, (int) s_CameraData.vp.Height };
				int iX = (rcView.right - m_pText_Rights->GetWidth()) / 2;
				int iY = rcView.bottom - m_pText_Rights->GetHeight() - 20;
				m_pText_Rights->SetPos(iX, iY);

				m_pText_Rights->SetVisible(true);
			}
		}
	}
}

void CUILogIn_1098::RecalcGradePos()
{
	// 이용등급 표시
	if (m_pImg_GradeLogo != nullptr)
	{
		RECT rc = m_pImg_GradeLogo->GetRegion();
		int iX = s_CameraData.vp.Width - (rc.right - rc.left + 10);
		int iY = 10;
		m_pImg_GradeLogo->SetPos(iX, iY);
	}
}

bool CUILogIn_1098::OnKeyPress(int iKey)
{
	if (!m_bLogIn)
	{
		switch (iKey)
		{
		case DIK_TAB:
			FocusCircular();
			return true;
		// case DIK_NUMPADENTER:
		// case DIK_RETURN:
		//	CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
		//	return true;
		}
	}
	else if (!m_bOpenningNow
		&& m_pGroup_ServerList != nullptr
		&& m_pGroup_ServerList->IsVisible())
	{
		switch (iKey)
		{
			case DIK_UP:
			{
				if (m_pList_Server == nullptr)
					return false;

				int iIndex = m_pList_Server->GetCurSel();
				if (iIndex > 0)
					m_pList_Server->SetCurSel(iIndex - 1);
			}
			return true;

			case DIK_DOWN:
			{
				if (m_pList_Server == nullptr)
					return false;

				int iIndex = m_pList_Server->GetCurSel();
				int iCnt = m_pList_Server->GetCount();
				if ((iCnt - iIndex) > 1)
					m_pList_Server->SetCurSel(iIndex + 1);
			}
			return true;

			case DIK_NUMPADENTER:
			case DIK_RETURN:
				ReceiveMessage(m_pBtn_Connect, UIMSG_BUTTON_CLICK);
				return true;
		}
	}

	return CN3UIBase::OnKeyPress(iKey);
}

#endif

// ===== END WarFare/UILogin_1098.cpp =====

// ===== BEGIN WarFare/UILogin_1098.h =====
#line 1 "WarFare/UILogin_1098.h"
﻿#pragma once

#if defined(LOGIN_SCENE_VERSION) && LOGIN_SCENE_VERSION == 1098
#include <string>
#include <vector>

#include <N3Base/N3UIBase.h>

class CUILogIn_1098 : public CN3UIBase  
{
public:
	struct __GameServerInfo
	{
		std::string	szName;
		std::string	szIP;
		int			iConcurrentUserCount;

		void Init()
		{
			szName.clear();
			szIP.clear();
			iConcurrentUserCount = 0;
		}

		bool operator () (const __GameServerInfo& x, const __GameServerInfo& y) const
		{
			return (x.iConcurrentUserCount >= y.iConcurrentUserCount);
		}

		__GameServerInfo()
		{
			Init();
		}

		__GameServerInfo(const std::string& szName2, const std::string& szIP2, int iConcurrentUserCount2)
		{
			szName = szName2;
			szIP = szIP2;
			iConcurrentUserCount = iConcurrentUserCount2;
		}
	};

protected:
	CN3UIEdit*	m_pEdit_id;
	CN3UIEdit*	m_pEdit_pw;
	
	CN3UIButton* m_pBtn_LogIn;
	CN3UIButton* m_pBtn_Connect;
	CN3UIButton* m_pBtn_Cancel;
	CN3UIButton* m_pBtn_Option;
	CN3UIButton* m_pBtn_Join;

	CN3UIBase*	m_pGroup_ServerList;
	CN3UIBase*	m_pGroup_LogIn;
	
	CN3UIBase* m_pText_Rights;
	CN3UIBase* m_pImg_MGameLogo;
	CN3UIBase* m_pImg_DaumLogo;
	CN3UIBase* m_pImg_GradeLogo;

	CN3UIList*	m_pList_Server;
	
	std::vector<__GameServerInfo> m_ListServerInfos;

	bool	m_bOpenningNow; // 위에서 아래로 스르륵...열려야 한다면..
	float 	m_fMoveDelta;
	bool	m_bLogIn; // 로그인 중복 방지..

public:
	void SetRequestedLogIn(bool bLogIn) { m_bLogIn = bLogIn; }
	bool OnKeyPress(int iKey) override;
	void RecalcGradePos();
	void SetVisibleLogInUIs(bool bEnable); // 계정 LogIn 에 필요한 UI 들을 숨긴다..
	void OpenServerList();
	void Tick() override;

	void InitEditControls();
	void FocusCircular();
	void FocusToID();
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override; // 메시지를 받는다.. 보낸놈, msg

	int ServerInfoCount() { return (int) m_ListServerInfos.size(); }
	bool ServerInfoAdd(const __GameServerInfo& GSI);
	bool ServerInfoGet(int iIndex, __GameServerInfo& GSI);
	bool ServerInfoGetCur(__GameServerInfo& GSI);
	void ServerInfoUpdate();

	void AccountIDGet(std::string& szID);
	void AccountPWGet(std::string& szPW);

	void ConnectButtonSetEnable(bool bEnable);

	CUILogIn_1098();
	~CUILogIn_1098() override;
};

#endif

// ===== END WarFare/UILogin_1098.h =====

// ===== BEGIN WarFare/UILogin_1298.cpp =====
#line 1 "WarFare/UILogin_1298.cpp"
﻿#include "stdafx.h"

#if !defined(LOGIN_SCENE_VERSION) || LOGIN_SCENE_VERSION == 1298
#include "UILogIn_1298.h"
#include "GameProcLogIn_1298.h"
#include "UIMessageBoxManager.h"
#include "text_resources.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#include <algorithm>
#include <shellapi.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUILogIn_1298::CUILogIn_1298()
{
	m_pEdit_id = nullptr;
	m_pEdit_pw = nullptr;

	m_pBtn_LogIn = nullptr;
	m_pBtn_Connect = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pBtn_Option = nullptr;
	m_pBtn_Join = nullptr;
	
	m_pGroup_Notice_1 = nullptr;
	m_pGroup_Notice_2 = nullptr;
	m_pGroup_Notice_3 = nullptr;

	m_pText_Notice1_Name_1 = nullptr;
	m_pText_Notice1_Text_1 = nullptr;

	m_pText_Notice2_Name_1 = nullptr;
	m_pText_Notice2_Text_1 = nullptr;
	m_pText_Notice2_Name_2 = nullptr;
	m_pText_Notice2_Text_2 = nullptr;

	m_pText_Notice3_Name_1 = nullptr;
	m_pText_Notice3_Text_1 = nullptr;
	m_pText_Notice3_Name_2 = nullptr;
	m_pText_Notice3_Text_2 = nullptr;
	m_pText_Notice3_Name_3 = nullptr;
	m_pText_Notice3_Text_3 = nullptr;

	m_pBtn_NoticeOK_1 = nullptr;
	m_pBtn_NoticeOK_2 = nullptr;
	m_pBtn_NoticeOK_3 = nullptr;

	m_pGroup_ServerList = nullptr;
	m_pGroup_LogIn = nullptr;

	m_pStr_Premium = nullptr;

	m_iSelectedServerIndex = -1;

	for (int i = 0; i < MAX_SERVERS; i++)
	{
		m_pServer_Group[i] = nullptr;
		m_pArrow_Group[i] = nullptr;
		m_pList_Group[i] = nullptr;
	} 

	m_bIsNewsVisible = false; 
	m_bLogIn = false;
}

CUILogIn_1298::~CUILogIn_1298()
{
}

bool CUILogIn_1298::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_LogIn
			&& m_pEdit_id != nullptr
			&& m_pEdit_pw != nullptr)
		{
			CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
			return true;
		}
		else if (pSender == m_pBtn_Connect)
		{
			CGameProcedure::s_pProcLogIn->ConnectToGameServer(); // 고른 게임 서버에 접속
			return true;
		}
		else if (pSender == m_pBtn_Cancel)
		{
			PostQuitMessage(0);	// 종료...
			return true;
		}
		else if (pSender == m_pBtn_Option) // 옵션..
		{
			std::string szMsg = fmt::format_text_resource(IDS_CONFIRM_EXECUTE_OPTION);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_EXECUTE_OPTION);
			return true;
		}
		else if (pSender == m_pBtn_Join)
		{
			if (!CGameProcedure::s_pProcLogIn->m_szRegistrationSite.empty())
			{
				ShellExecute(nullptr, "open", CGameProcedure::s_pProcLogIn->m_szRegistrationSite.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
			}

			return true;
		}
		else if (pSender == m_pBtn_NoticeOK_1
			|| pSender == m_pBtn_NoticeOK_2
			|| pSender == m_pBtn_NoticeOK_3)
		{
			OpenServerList();
			return true;
		}
	}
	// double click on string
	else if (UIMSG_STRING_LDCLICK == dwMsg)
	{
		for (int i = 0; i < MAX_SERVERS; i++)
		{
			if (m_pList_Group[i] == nullptr)
				continue;

			if (pSender == m_pList_Group[i])
			{
				SelectServer(i);
				CGameProcedure::s_pProcLogIn->ConnectToGameServer();
				return true;
			}
		}
	}
	// change color on left click
	else if (UIMSG_STRING_LCLICK == dwMsg)
	{
		for (int i = 0; i < MAX_SERVERS; i++)
		{
			if (m_pList_Group[i] != nullptr
				&& pSender == m_pList_Group[i])
			{
				SelectServer(i);
				return true;
			}
		}
	}
	else if (dwMsg == UIMSG_EDIT_RETURN)
	{
		// TEMP(srmeier): there is a weird issue where the key inputs aren't going
		// through CGameProcedure::ProcessUIKeyInput() so CUILogIn_1298::OnKeyPress() isn't
		// being called...
		if (!m_bLogIn && m_pEdit_id && m_pEdit_pw)
		{
			CN3UIBase* pMsgBox = CGameProcedure::s_pMsgBoxMgr->GetFocusMsgBox();
			if (!(pMsgBox && pMsgBox->IsVisible()))
				CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
		}
		else
		{
			return ReceiveMessage(m_pBtn_Connect, UIMSG_BUTTON_CLICK);
		}
	}

	return false;
}

bool CUILogIn_1298::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pGroup_LogIn, GetChildByID("Group_LogIn"));

	if (m_pGroup_LogIn != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_LogIn,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("btn_ok"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("btn_cancel"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Option,	m_pGroup_LogIn->GetChildByID<CN3UIButton>("btn_option"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_Join,		m_pGroup_LogIn->GetChildByID<CN3UIButton>("btn_homepage"));

		N3_VERIFY_UI_COMPONENT(m_pEdit_id,		m_pGroup_LogIn->GetChildByID<CN3UIEdit>("Edit_ID"));
		N3_VERIFY_UI_COMPONENT(m_pEdit_pw,		m_pGroup_LogIn->GetChildByID<CN3UIEdit>("Edit_PW"));

		m_pGroup_LogIn->SetVisible(true);
	}

	// get notice boxes
	N3_VERIFY_UI_COMPONENT(m_pGroup_Notice_1,	GetChildByID("Group_Notice_1"));
	N3_VERIFY_UI_COMPONENT(m_pGroup_Notice_2,	GetChildByID("Group_Notice_2"));
	N3_VERIFY_UI_COMPONENT(m_pGroup_Notice_3,	GetChildByID("Group_Notice_3"));
	
	if (m_pGroup_Notice_1 != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_NoticeOK_1,		m_pGroup_Notice_1->GetChildByID<CN3UIButton>("btn_ok"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice1_Name_1,	m_pGroup_Notice_1->GetChildByID<CN3UIString>("text_notice_name_01"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice1_Text_1,	m_pGroup_Notice_1->GetChildByID<CN3UIString>("text_notice_01"));

		m_pGroup_Notice_1->SetVisible(false);
	}

	if (m_pGroup_Notice_2 != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_NoticeOK_2,		m_pGroup_Notice_2->GetChildByID<CN3UIButton>("btn_ok"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice2_Name_1,	m_pGroup_Notice_2->GetChildByID<CN3UIString>("text_notice_name_01"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice2_Text_1,	m_pGroup_Notice_2->GetChildByID<CN3UIString>("text_notice_01"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice2_Name_2,	m_pGroup_Notice_2->GetChildByID<CN3UIString>("text_notice_name_02"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice2_Text_2,	m_pGroup_Notice_2->GetChildByID<CN3UIString>("text_notice_02"));

		m_pGroup_Notice_2->SetVisible(false);
	}

	if (m_pGroup_Notice_3 != nullptr)
	{
		N3_VERIFY_UI_COMPONENT(m_pBtn_NoticeOK_3,		m_pGroup_Notice_3->GetChildByID<CN3UIButton>("btn_ok"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Name_1,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_name_01"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Text_1,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_01"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Name_2,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_name_02"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Text_2,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_02"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Name_3,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_name_03"));
		N3_VERIFY_UI_COMPONENT(m_pText_Notice3_Text_3,	m_pGroup_Notice_3->GetChildByID<CN3UIString>("text_notice_03"));

		m_pGroup_Notice_3->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pStr_Premium,		GetChildByID<CN3UIString>("premium"));

	if (m_pStr_Premium != nullptr)
		m_pStr_Premium->SetVisible(false);

	N3_VERIFY_UI_COMPONENT(m_pGroup_ServerList,	GetChildByID("Group_ServerList_01"));

	if (m_pGroup_ServerList != nullptr)
		m_pGroup_ServerList->SetVisible(false);

	// get List_Server (structure: Group_ServerList_01 -> server_20 -> List_Server )
	for (int i = 0; i < MAX_SERVERS; i++)
	{
		std::string szID = "server_" + std::to_string(i + 1);
		N3_VERIFY_UI_COMPONENT(m_pServer_Group[i],	m_pGroup_ServerList->GetChildByID(szID));

		szID = "img_arrow" + std::to_string(i + 1);
		N3_VERIFY_UI_COMPONENT(m_pArrow_Group[i],	m_pGroup_ServerList->GetChildByID(szID));
		
		N3_VERIFY_UI_COMPONENT(m_pList_Group[i],	m_pServer_Group[i]->GetChildByID<CN3UIString>("List_Server"));
	}

	N3_VERIFY_UI_COMPONENT(m_pBtn_Connect,			m_pGroup_ServerList->GetChildByID<CN3UIButton>("Btn_Connect"));
		
	return true;
}

void CUILogIn_1298::PositionGroups()
{
	if (m_pGroup_LogIn != nullptr)
		m_pGroup_LogIn->SetPosCenter();

	if (m_pGroup_ServerList != nullptr)
		m_pGroup_ServerList->SetPosCenter();

	if (m_pGroup_Notice_1 != nullptr)
		m_pGroup_Notice_1->SetPosCenter();

	if (m_pGroup_Notice_2 != nullptr)
		m_pGroup_Notice_2->SetPosCenter();

	if (m_pGroup_Notice_3 != nullptr)
		m_pGroup_Notice_3->SetPosCenter();
}

void CUILogIn_1298::AccountIDGet(std::string& szID)
{
	if (m_pEdit_id != nullptr)
		szID = m_pEdit_id->GetString();
	else
		szID.clear();
}

void CUILogIn_1298::AccountPWGet(std::string& szPW)
{
	if (m_pEdit_pw != nullptr)
		szPW = m_pEdit_pw->GetString();
	else
		szPW.clear();
}

void CUILogIn_1298::ConnectButtonSetEnable(bool bEnable)
{
	eUI_STATE eState1 = (bEnable ? UI_STATE_BUTTON_NORMAL : UI_STATE_BUTTON_DISABLE);

	if (m_pBtn_Connect != nullptr)
		m_pBtn_Connect->SetState(eState1);
}

void CUILogIn_1298::FocusToID()
{
	if (m_pEdit_id != nullptr)
		m_pEdit_id->SetFocus();
}

void CUILogIn_1298::FocusCircular()
{
	if (m_pEdit_id == nullptr
		|| m_pEdit_pw == nullptr)
		return;

	if (m_pEdit_id->HaveFocus())
		m_pEdit_pw->SetFocus();
	else
		m_pEdit_id->SetFocus();
}

void CUILogIn_1298::InitEditControls()
{
	if (m_pEdit_id != nullptr)
	{
		m_pEdit_id->SetString("");
		m_pEdit_id->SetFocus();
	}

	if (m_pEdit_pw != nullptr)
		m_pEdit_pw->SetString("");
}

bool CUILogIn_1298::ServerInfoAdd(const __GameServerInfo& GSI)
{
	m_ListServerInfos.push_back(GSI);
	return true;
}

bool CUILogIn_1298::ServerInfoGet(int iIndex, __GameServerInfo& GSI)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_ListServerInfos.size()))
		return false;

	GSI = m_ListServerInfos[iIndex];
	return true;
}

bool CUILogIn_1298::ServerInfoGetCur(__GameServerInfo& GSI)
{
	GSI.Init();

	return ServerInfoGet(m_iSelectedServerIndex, GSI);
}

void CUILogIn_1298::ServerInfoUpdate()
{
	if (m_ListServerInfos.empty())
		return;

	// sort(m_ListServerInfos.begin(), m_ListServerInfos.end(), not2(__GameServerInfo()));

	// show ui of existing servers
	int iMaxPlayerCount = 3000;
	int iNumUserForLine = 3000 / 12;
	int iNumLines = 1;

	for (size_t i = 0; i < m_ListServerInfos.size(); i++)
	{
		if (m_pServer_Group[i] == nullptr)
			continue;

		if (m_pList_Group[i] != nullptr)
			m_pList_Group[i]->SetString(m_ListServerInfos[i].szName);

		m_pServer_Group[i]->SetVisible(true); 

		if (m_pArrow_Group[i] != nullptr)
			m_pArrow_Group[i]->SetVisible(true);

		// hide number of lines with respect to user number
		iNumLines = m_ListServerInfos[i].iConcurrentUserCount / iNumUserForLine;

		if (iNumLines < 1) // minimum 1 lines
			iNumLines = 1;

		if (iNumLines > 12) // uif file has max 12 lines 
			iNumLines = 12;

		// ids of lines set as 1,2,3 ... 12 in .uif file
		for (int j = iNumLines + 1; j <= 12; j++)
		{
			// TODO: Pre-load this.
			std::string szID = std::to_string(j);

			CN3UIBase* pChild = m_pServer_Group[i]->GetChildByID(szID);
			if (pChild != nullptr)
				pChild->SetVisible(false);
		}
	}

	// hide ui of extra servers
	for (size_t i = m_ListServerInfos.size(); i < MAX_SERVERS; i++)
	{
		if (m_pServer_Group[i] != nullptr)
			m_pServer_Group[i]->SetVisible(false);

		if (m_pArrow_Group[i] != nullptr)
			m_pArrow_Group[i]->SetVisible(false);
	}
	 
	// TODO: Show Premium info if user have premium
}

void CUILogIn_1298::AddNews(const std::string& strNews)
{
	std::vector<std::string> titles, messages;

	titles.reserve(MAX_NEWS_COUNT);
	messages.reserve(MAX_NEWS_COUNT);

	size_t searchPos = 0;

	std::string_view messageStartView(NEWS_MESSAGE_START, sizeof(NEWS_MESSAGE_START));
	std::string_view messageEndView(NEWS_MESSAGE_END, sizeof(NEWS_MESSAGE_END));

	// NOTE: The official parsing for this is extremely simple.
	// It really doesn't care about the format it uses; it basically
	// just looks for the first and last #, and ignores anything
	// until the next # is found for the next box, and strips out
	// \r, \n as it goes.
	// Since this means that it ends up including characters it shouldn't,
	// e.g. null-terminators (which happen to not get rendered), we'll just
	// be a touch smarter about this and follow the basic format.
	while (titles.size() < MAX_NEWS_COUNT)
	{
		const size_t titlePos = searchPos;

		// Find the start of the message
		size_t startOfMessageBlock = strNews.find(messageStartView, searchPos);
		if (startOfMessageBlock == std::string::npos)
			break;

		// The title precedes the message.
		// It's not directly surrounded by anything of its own.
		std::string title = strNews.substr(titlePos, startOfMessageBlock - titlePos);

		size_t startOfMessage = startOfMessageBlock + sizeof(NEWS_MESSAGE_START);

		size_t startOfEndMessageBlock = strNews.find(messageEndView, startOfMessage);
		if (startOfEndMessageBlock == std::string::npos)
			break;

		std::string message = strNews.substr(startOfMessage, startOfEndMessageBlock - startOfMessage);

		titles.push_back(std::move(title));
		messages.push_back(std::move(message));

		// jump to next block
		searchPos = startOfEndMessageBlock + sizeof(NEWS_MESSAGE_END);
	}

	// No news, skip to server list
	if (titles.empty())
	{
		m_bIsNewsVisible = false;
		OpenServerList();
	}
	else if (titles.size() == 1)
	{
		if (m_pText_Notice1_Name_1 != nullptr)
			m_pText_Notice1_Name_1->SetString(titles[0]);

		if (m_pText_Notice1_Text_1 != nullptr)
			m_pText_Notice1_Text_1->SetString(messages[0]);

		if (m_pGroup_Notice_1 != nullptr)
			m_pGroup_Notice_1->SetVisible(true);
	}
	else if (titles.size() == 2)
	{
		if (m_pText_Notice2_Name_1 != nullptr)
			m_pText_Notice2_Name_1->SetString(titles[0]);

		if (m_pText_Notice2_Text_1 != nullptr)
			m_pText_Notice2_Text_1->SetString(messages[0]);

		if (m_pText_Notice2_Name_2 != nullptr)
			m_pText_Notice2_Name_2->SetString(titles[1]);

		if (m_pText_Notice2_Text_2 != nullptr)
			m_pText_Notice2_Text_2->SetString(messages[1]);

		if (m_pGroup_Notice_2 != nullptr)
			m_pGroup_Notice_2->SetVisible(true);
	}
	else if (titles.size() == 3)
	{
		if (m_pText_Notice3_Name_1 != nullptr)
			m_pText_Notice3_Name_1->SetString(titles[0]);

		if (m_pText_Notice3_Text_1 != nullptr)
			m_pText_Notice3_Text_1->SetString(messages[0]);

		if (m_pText_Notice3_Name_2 != nullptr)
			m_pText_Notice3_Name_2->SetString(titles[1]);

		if (m_pText_Notice3_Text_2 != nullptr)
			m_pText_Notice3_Text_2->SetString(messages[1]);

		if (m_pText_Notice3_Name_3 != nullptr)
			m_pText_Notice3_Name_3->SetString(titles[2]);

		if (m_pText_Notice3_Text_3 != nullptr)
			m_pText_Notice3_Text_3->SetString(messages[2]);

		if (m_pGroup_Notice_3 != nullptr)
			m_pGroup_Notice_3->SetVisible(true);
	}
}

void CUILogIn_1298::OpenNews()
{
	if (m_bIsNewsVisible)
		return;

	if (m_pGroup_Notice_1 == nullptr
		|| m_pGroup_Notice_2 == nullptr
		|| m_pGroup_Notice_3 == nullptr)
		return;

	// set position of notice boxes
	// if it is done in Load function, they are not centered.
	RECT rc = m_pGroup_Notice_1->GetRegion();
	int iX = ((int) s_CameraData.vp.Width - (rc.right - rc.left)) / 2;
	int iY = ((int) s_CameraData.vp.Height - (rc.bottom - rc.top)) / 2;
	m_pGroup_Notice_1->SetPos(iX, iY);

	rc = m_pGroup_Notice_2->GetRegion();
	iX = ((int) s_CameraData.vp.Width - (rc.right - rc.left)) / 2;
	iY = ((int) s_CameraData.vp.Height - (rc.bottom - rc.top)) / 2;
	m_pGroup_Notice_2->SetPos(iX, iY);

	rc = m_pGroup_Notice_3->GetRegion();
	iX = ((int) s_CameraData.vp.Width - (rc.right - rc.left)) / 2;
	iY = ((int) s_CameraData.vp.Height - (rc.bottom - rc.top)) / 2;
	m_pGroup_Notice_3->SetPos(iX, iY);

	m_bIsNewsVisible = true;
}

void CUILogIn_1298::OpenServerList()
{
	if (m_pGroup_ServerList == nullptr)
		return;

	// close all notice boxes
	if (m_pGroup_Notice_1 != nullptr)
		m_pGroup_Notice_1->SetVisible(false);

	if (m_pGroup_Notice_2 != nullptr)
		m_pGroup_Notice_2->SetVisible(false);

	if (m_pGroup_Notice_3 != nullptr)
		m_pGroup_Notice_3->SetVisible(false);

	// 스르륵 열린다!! = open without sound
	if (m_pGroup_ServerList != nullptr)
		m_pGroup_ServerList->SetVisible(true);
	
	if (m_pStr_Premium != nullptr)
		m_pStr_Premium->SetVisible(true);

	// Select first server by default.
	SelectServer(0);

	m_bIsNewsVisible = false;
}

void CUILogIn_1298::SetVisibleLogInUIs(bool bEnable)
{
	if (m_pGroup_LogIn != nullptr)
		m_pGroup_LogIn->SetVisible(bEnable); // 로그인을 숨긴다..
}

bool CUILogIn_1298::OnKeyPress(int iKey)
{
	if (!m_bLogIn)
	{
		switch (iKey)
		{
		case DIK_TAB:
			FocusCircular();
			return true;
		// case DIK_NUMPADENTER:
		// case DIK_RETURN:
		//	CGameProcedure::s_pProcLogIn->MsgSend_AccountLogIn(LIC_KNIGHTONLINE);
		//	return true;
		}
	}
	else if (m_pGroup_ServerList != nullptr
		&& m_pGroup_ServerList->IsVisible())
	{
		switch (iKey)
		{
			case DIK_UP:
			{
				int iServerCount = static_cast<int>(m_ListServerInfos.size());
				if (iServerCount == 0)
					return false;

				--m_iSelectedServerIndex;
				if (m_iSelectedServerIndex < 0)
					m_iSelectedServerIndex = iServerCount - 1;

				SelectServer(m_iSelectedServerIndex);
			}
			return true;

			case DIK_DOWN:
			{
				int iServerCount = static_cast<int>(m_ListServerInfos.size());
				if (iServerCount == 0)
					return false;

				++m_iSelectedServerIndex;
				if (m_iSelectedServerIndex >= iServerCount)
					m_iSelectedServerIndex = 0;

				SelectServer(m_iSelectedServerIndex);
			}
			return true;

			case DIK_NUMPADENTER:
			case DIK_RETURN:
				// connect to the selected server if user presses enter at server select screen
				ReceiveMessage(m_pList_Group[m_iSelectedServerIndex], UIMSG_STRING_LDCLICK);
				return true;
		}
	}
	else if (m_bIsNewsVisible)
	{
		switch (iKey)
		{
			case DIK_RETURN:
				ReceiveMessage(m_pBtn_NoticeOK_1, UIMSG_BUTTON_CLICK);
				return true;
		}
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUILogIn_1298::SelectServer(int iServerListIndex)
{
	m_iSelectedServerIndex = std::clamp(iServerListIndex, 0, MAX_SERVERS - 1);

	for (int i = 0; i < MAX_SERVERS; i++)
	{
		if (m_pList_Group[i] == nullptr)
			continue;

		if (i == m_iSelectedServerIndex)
			m_pList_Group[i]->SetColor(D3DCOLOR_XRGB(0, 255, 0)); // green
		else
			m_pList_Group[i]->SetColor(D3DCOLOR_XRGB(255, 255, 255)); // white
	}
}
#endif

// ===== END WarFare/UILogin_1298.cpp =====

// ===== BEGIN WarFare/UILogin_1298.h =====
#line 1 "WarFare/UILogin_1298.h"
﻿#pragma once

#include <string>
#include <vector>

#include <N3Base/N3UIBase.h>

class CUILogIn_1298 : public CN3UIBase  
{
public:

	struct __GameServerInfo
	{
		std::string	szName;
		std::string	szIP;
		int			iConcurrentUserCount;

		void Init()
		{
			szName.clear();
			szIP.clear();
			iConcurrentUserCount = 0;
		}

		bool operator () (const __GameServerInfo& x, const __GameServerInfo& y) const
		{
			return (x.iConcurrentUserCount >= y.iConcurrentUserCount);
		}

		__GameServerInfo()
		{
			Init();
		}

		__GameServerInfo(const std::string& szName2, const std::string& szIP2, int iConcurrentUserCount2)
		{
			szName = szName2;
			szIP = szIP2;
			iConcurrentUserCount = iConcurrentUserCount2;
		}
	};

protected:
	static constexpr int MAX_SERVERS = 20; // max number of servers in UIF file.

	CN3UIEdit*	m_pEdit_id;
	CN3UIEdit*	m_pEdit_pw;
	
	CN3UIButton* m_pBtn_LogIn;
	CN3UIButton* m_pBtn_Connect;
	CN3UIButton* m_pBtn_Cancel;
	CN3UIButton* m_pBtn_Option;
	CN3UIButton* m_pBtn_Join;
	
	CN3UIButton* m_pBtn_NoticeOK_1;
	CN3UIButton* m_pBtn_NoticeOK_2;
	CN3UIButton* m_pBtn_NoticeOK_3;

	CN3UIString* m_pStr_Premium;

	CN3UIBase*	m_pGroup_ServerList;
	CN3UIBase*	m_pGroup_LogIn;
	
	CN3UIBase* m_pGroup_Notice_1;		 //notice group
	CN3UIString* m_pText_Notice1_Name_1; //notice title
	CN3UIString* m_pText_Notice1_Text_1; //notice text

	CN3UIBase* m_pGroup_Notice_2;
	CN3UIString* m_pText_Notice2_Name_1; 
	CN3UIString* m_pText_Notice2_Text_1; 
	CN3UIString* m_pText_Notice2_Name_2;
	CN3UIString* m_pText_Notice2_Text_2;

	CN3UIBase* m_pGroup_Notice_3;
	CN3UIString* m_pText_Notice3_Name_1;
	CN3UIString* m_pText_Notice3_Text_1;
	CN3UIString* m_pText_Notice3_Name_2;
	CN3UIString* m_pText_Notice3_Text_2;
	CN3UIString* m_pText_Notice3_Name_3;
	CN3UIString* m_pText_Notice3_Text_3;

	CN3UIBase* m_pServer_Group[MAX_SERVERS];
	CN3UIBase* m_pArrow_Group[MAX_SERVERS];
	CN3UIString* m_pList_Group[MAX_SERVERS];

	std::vector<__GameServerInfo> m_ListServerInfos;

	bool	m_bIsNewsVisible;
	bool	m_bLogIn; // 로그인 중복 방지..
	int		m_iSelectedServerIndex;
	std::string m_strNoticeText;

public:
	void SetRequestedLogIn(bool bLogIn) { m_bLogIn = bLogIn; }
	void SelectServer(int iServerListIndex);
	bool OnKeyPress(int iKey) override;
	void SetVisibleLogInUIs(bool bEnable); // 계정 LogIn 에 필요한 UI 들을 숨긴다..
	void OpenServerList();
	void OpenNews();
	void AddNews(const std::string& strNews);

	void InitEditControls();
	void FocusCircular();
	void FocusToID();
	bool Load(File& file) override;
	void PositionGroups();

	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override; // 메시지를 받는다.. 보낸놈, msg

	int ServerInfoCount() { return (int) m_ListServerInfos.size(); }
	bool ServerInfoAdd(const __GameServerInfo& GSI);
	bool ServerInfoGet(int iIndex, __GameServerInfo& GSI);
	bool ServerInfoGetCur(__GameServerInfo& GSI);
	void ServerInfoUpdate();

	void AccountIDGet(std::string& szID);
	void AccountPWGet(std::string& szPW);

	void ConnectButtonSetEnable(bool bEnable);

	CUILogIn_1298();
	~CUILogIn_1298() override;
};

// ===== END WarFare/UILogin_1298.h =====

// ===== BEGIN WarFare/UIManager.cpp =====
#line 1 "WarFare/UIManager.cpp"
﻿// UIManager.cpp: implementation of the CUIManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIManager.h"
#include "LocalInput.h"
#include "N3UIWndBase.h"
#include "GameProcedure.h"
#include "GameProcMain.h"
#include "UIInventory.h"
#include "UITransactionDlg.h"
#include "SubProcPerTrade.h"
#include "CountableItemEditDlg.h"
#include "UIMsgBoxOkCancel.h"
#include "UIWareHouseDlg.h"

#include <N3Base/DFont.h>
#include <N3Base/N3UITooltip.h>

#include <iterator>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CUIManager::__RenderStateForUI CUIManager::s_sRSFU; // RenderStateForUI

CUIManager::CUIManager()
{
	m_dwMouseFlagsCur = 0;
	m_bEnableOperation = true;					// UI 조작이 가능한 상태인가?
	m_pUIFocused = nullptr;
#ifdef _DEBUG
	m_pDFont = nullptr;
#endif;

	m_bDoneSomething = false;					// UI 에서 조작을 했다...
}

CUIManager::~CUIManager()
{
#ifdef _DEBUG
	delete m_pDFont;
#endif
}

void CUIManager::Release()
{
	CN3UIBase::Release();
}

uint32_t CUIManager::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	m_dwMouseFlagsCur = UI_MOUSEPROC_NONE;
	if (!m_bVisible || !m_bEnableOperation) return m_dwMouseFlagsCur;

	if (s_pTooltipCtrl)	s_pTooltipCtrl->MouseProc(dwFlags, ptCur, ptOld);	// 툴팁에게 마우스 메세지 전달.

	// child에게 메세지 전달
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; )
	{
		CN3UIBase* pChild = (*itor);
		// 상거래 중이면 아이콘 매니저 윈도우만 작동..
		if ( CGameProcedure::s_pProcMain && CGameProcedure::s_pProcMain->m_pUITransactionDlg && 
			(CGameProcedure::s_pProcMain->m_pUITransactionDlg->IsVisible()))// && (pChild->UIType() != UI_TYPE_ICON_MANAGER) )
		{	
			if ( CN3UIWndBase::s_pCountableItemEdit->IsLocked() )
			{
				if ( pChild->m_szID.compare("base_tradeedit") != 0 )
					{	++itor; continue;	}
			}
		}
		// 보관함에 보관중이면 아이콘 매니저 윈도우만 작동..
		if ( CGameProcedure::s_pProcMain && CGameProcedure::s_pProcMain->m_pUIWareHouseDlg && 
			(CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->IsVisible()))// && (pChild->UIType() != UI_TYPE_ICON_MANAGER) )
		{	
			if ( CN3UIWndBase::s_pCountableItemEdit->IsLocked() )
			{
				if ( pChild->m_szID.compare("base_tradeedit") != 0 )
					{	++itor; continue;	}
			}
		}
		// 개인간 거래중이면 아이콘 매니저 윈도우만 작동.. 돈 액수나 화살 갯수등을 입력하는 중이면.. 입력 윈도우만 작동..
		if ( CGameProcedure::s_pProcMain && CGameProcedure::s_pProcMain->m_pSubProcPerTrade &&
			(CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE) )
		{	
			if (CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_ePerTradeState == PER_TRARE_STATE_EDITTING) 
			{
				if ( pChild->m_szID.compare("base_tradeedit") != 0 )
					{	++itor; continue;	}
			}

			if ( CN3UIWndBase::s_pCountableItemEdit->IsLocked() )
			{
				if ( pChild->m_szID.compare("base_tradeedit") != 0 )
					{	++itor; continue;	}
			}
		}

		if(pChild->m_pChildUI && pChild->m_pChildUI->IsVisible())
		{
			uint32_t dwRet = pChild->m_pChildUI->MouseProc(dwFlags, ptCur, ptOld);
			if (UI_MOUSEPROC_DONESOMETHING & dwRet)
			{	// 이경우에는 먼가 포커스를 받은 경우이다.
				pChild->MouseProc(0, ptCur, ptOld);
				m_dwMouseFlagsCur |= (UI_MOUSEPROC_DONESOMETHING|UI_MOUSEPROC_CHILDDONESOMETHING);

				SetFocusedUI(pChild);//this_ui

				return m_dwMouseFlagsCur;
			}
			else if ( (	UI_MOUSE_LBCLICK & dwFlags) && (UI_MOUSEPROC_INREGION & dwRet) )
			{	// 영역 안을 클릭 했을때 먼가 일을 했다고 하고 리턴해버린다.
				pChild->MouseProc(0, ptCur, ptOld);
				m_dwMouseFlagsCur |= (UI_MOUSEPROC_DIALOGFOCUS);
				
				SetFocusedUI(pChild);//this_ui

				return m_dwMouseFlagsCur;
			}
		}

		uint32_t dwChildRet = pChild->MouseProc(dwFlags, ptCur, ptOld);
		if (UI_MOUSEPROC_DONESOMETHING & dwChildRet)
		{	// 이경우에는 먼가 포커스를 받은 경우이다.
			m_dwMouseFlagsCur |= (UI_MOUSEPROC_DONESOMETHING|UI_MOUSEPROC_CHILDDONESOMETHING);

			SetFocusedUI(pChild);//this_ui

			return m_dwMouseFlagsCur;
		}
		else if ( (	UI_MOUSE_LBCLICK & dwFlags) && (UI_MOUSEPROC_INREGION & dwChildRet) )
		{	// 영역 안을 클릭 했을때 먼가 일을 했다고 하고 리턴해버린다.
			m_dwMouseFlagsCur |= (UI_MOUSEPROC_DIALOGFOCUS);
			
			SetFocusedUI(pChild);//this_ui

			return m_dwMouseFlagsCur;
		}
		else ++itor;
		//else if (UI_MOUSE_LBCLICKED|UI_MOUSE_MBCLICK|UI_MOUSE_MBCLICKED|UI_MOUSE_RBCLICK|UI_MOUSE_RBCLICKED)

		m_dwMouseFlagsCur |= dwChildRet;
	}

//	if(UI_MOUSE_LBCLICK & dwFlags) m_pUIFocused = nullptr; // 포커스 받은 UI 기록.. 아무것도 안하면.. 널이다..

	return m_dwMouseFlagsCur;
}

void CUIManager::ReorderChildList()	// 다이알로그 순서 재배치
{
	int iChildCount = static_cast<int>(m_Children.size());
	if (iChildCount <= 0)
		return;

	CN3UIBase** ppBuffer = new CN3UIBase* [iChildCount];
	int iAlwaysTopChildCount = 0;

	for (auto itor = m_Children.begin(); m_Children.end() != itor; )
	{
		CN3UIBase* pChild = (*itor);
		if (pChild->GetStyle() & UISTYLE_ALWAYSTOP)
		{
			itor = m_Children.erase(itor);			// 우선 리스트에서 지우고
			ppBuffer[iAlwaysTopChildCount++] = pChild;

			if (iAlwaysTopChildCount >= iChildCount)
				break;
		}
		else ++itor;
	}
	for (int i = iAlwaysTopChildCount - 1; i >= 0; --i)
		m_Children.push_front(ppBuffer[i]);	// 맨앞에 넣는다. 그리는 순서를 맨 나중에 그리도록 하고 메세지를 맨 먼저 받게 하려고

	delete[] ppBuffer;
}

void CUIManager::Tick()
{
	CN3UIBase::Tick();
	if (s_pTooltipCtrl)	s_pTooltipCtrl->Tick();
}

void CUIManager::Render()
{
	this->RenderStateSet();

	CN3UIBase::Render();	// 자식들 render
	if (s_pTooltipCtrl) s_pTooltipCtrl->Render();	// tooltip render

	/*
	NOTE: there is a very weird issue with setting the render state and displaying text.
	- when the debug info is being displayed and you change window focus weird shit happens
	- currently just sticking this in here. it will work here but will end up showing during
	every game procedure which is somewhat unwanted right now...
	*/
	////////////////////////////////////////////////////////
#ifdef _DEBUG
	if (m_pDFont == nullptr)
	{
		m_pDFont = new CDFont("굴림", 10);
		m_pDFont->InitDeviceObjects(CN3Base::s_lpD3DDev);
		m_pDFont->RestoreDeviceObjects();
	}

	static std::string szDebugs[4];

	fmt::format_to(std::back_inserter(szDebugs[0]),
		"nTerrain_Polygon({}), nTerrain_Tile_Polygon({}), nShape({}), nShape_Part({}), nShape_Polygon({})",
		CN3Base::s_RenderInfo.nTerrain_Polygon,
		CN3Base::s_RenderInfo.nTerrain_Tile_Polygon,
		CN3Base::s_RenderInfo.nShape,
		CN3Base::s_RenderInfo.nShape_Part,
		CN3Base::s_RenderInfo.nShape_Polygon);

	fmt::format_to(std::back_inserter(szDebugs[1]),
		"nChr({}), nChr_Part({}), nChr_Polygon({}), nChr_Plug({}), nChr_Plug_Polygon({})",
		CN3Base::s_RenderInfo.nChr,
		CN3Base::s_RenderInfo.nChr_Part,
		CN3Base::s_RenderInfo.nChr_Polygon,
		CN3Base::s_RenderInfo.nChr_Plug,
		CN3Base::s_RenderInfo.nChr_Plug_Polygon);

	fmt::format_to(std::back_inserter(szDebugs[2]),
		"Camera : FieldOfView({:.1f}), NearPlane({:.1f}) FarPlane({:.1f})",
		RadiansToDegrees(CN3Base::s_CameraData.fFOV),
		CN3Base::s_CameraData.fNP,
		CN3Base::s_CameraData.fFP);

	if (CGameProcedure::s_pProcMain != nullptr
		&& CGameBase::ACT_WORLD != nullptr
		&& CGameBase::ACT_WORLD->GetSkyRef() != nullptr)
	{
		int iYear = 0, iMonth = 0, iDay = 0, iH = 0, iM = 0;
		CGameBase::ACT_WORLD->GetSkyRef()->GetGameTime(&iYear, &iMonth, &iDay, &iH, &iM);
		fmt::format_to(std::back_inserter(szDebugs[3]),
			"{:.2f}:FPS, {}/{}/{} : {}:{}",
			CN3Base::s_fFrmPerSec, iYear, iMonth, iDay, iH, iM);
	}
	else
	{
		szDebugs[3].clear();
	}

	for (int i = 0; i < 4; i++)
	{
		if (szDebugs[i].empty())
			continue;

		m_pDFont->SetText(szDebugs[i]);
		m_pDFont->DrawText(0.0f, 0.0f + i * 18, 0xFFFFFFFF, 0);
		szDebugs[i].clear();
	}
#endif
	////////////////////////////////////////////////////////

	this->RenderStateRestore();
}

void CUIManager::RenderStateSet()
{
	if(nullptr == s_lpD3DDev) return;

#ifdef _DEBUG
	__ASSERT(FALSE == s_sRSFU.bSet, "이전에 RenderStateSet()함수를 호출하고 RenderStateRestore()함수가 호출되지 않은 상태입니다.");
	s_sRSFU.bSet = TRUE;
#endif

	// back up old state
	s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &(s_sRSFU.dwZEnable));
	s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &(s_sRSFU.dwAlphaBlend));
	s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &(s_sRSFU.dwSrcBlend));
	s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &(s_sRSFU.dwDestBlend));
	s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &(s_sRSFU.dwFog));
	/*
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_MAGFILTER,   &(s_sRSFU.dwMagFilter));
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_MINFILTER,   &(s_sRSFU.dwMinFilter));
	s_lpD3DDev->GetTextureStageState(0, D3DTSS_MIPFILTER,   &(s_sRSFU.dwMipFilter));
	*/
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_MAGFILTER, &(s_sRSFU.dwMagFilter));
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_MINFILTER, &(s_sRSFU.dwMinFilter));
	s_lpD3DDev->GetSamplerState(0, D3DSAMP_MIPFILTER, &(s_sRSFU.dwMipFilter));

	// set state
	if (D3DZB_FALSE != s_sRSFU.dwZEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	if (TRUE != s_sRSFU.dwAlphaBlend) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	if (D3DBLEND_SRCALPHA != s_sRSFU.dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	if (D3DBLEND_INVSRCALPHA != s_sRSFU.dwDestBlend) s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	if (FALSE != s_sRSFU.dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE   , FALSE);	// 2d도 fog를 먹는다 ㅡ.ㅡ;
	if (D3DTEXF_POINT != s_sRSFU.dwMagFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER,   D3DTEXF_POINT);
	if (D3DTEXF_POINT != s_sRSFU.dwMinFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER,   D3DTEXF_POINT);
	if (D3DTEXF_NONE != s_sRSFU.dwMipFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER,   D3DTEXF_NONE);
}

void CUIManager::RenderStateRestore()
{
#ifdef _DEBUG
	__ASSERT(TRUE == s_sRSFU.bSet, "이전에 RenderStateSet()함수를 호출하지 않았습니다.");
	s_sRSFU.bSet = FALSE;
#endif

	// restore
	if (D3DZB_FALSE != s_sRSFU.dwZEnable) s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, s_sRSFU.dwZEnable);
	if (TRUE != s_sRSFU.dwAlphaBlend) s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, s_sRSFU.dwAlphaBlend);
	if (D3DBLEND_SRCALPHA != s_sRSFU.dwSrcBlend) s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, s_sRSFU.dwSrcBlend);
	if (D3DBLEND_INVSRCALPHA != s_sRSFU.dwDestBlend) s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, s_sRSFU.dwDestBlend);
	if (FALSE != s_sRSFU.dwFog) s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE   , s_sRSFU.dwFog);
	if (D3DTEXF_POINT != s_sRSFU.dwMagFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MAGFILTER,   s_sRSFU.dwMagFilter);
	if (D3DTEXF_POINT != s_sRSFU.dwMinFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MINFILTER,   s_sRSFU.dwMinFilter);
	if (D3DTEXF_NONE != s_sRSFU.dwMipFilter ) s_lpD3DDev->SetSamplerState(0, D3DSAMP_MIPFILTER,   s_sRSFU.dwMipFilter);
}

bool CUIManager::BroadcastIconDropMsg(__IconItemSkill* spItem)
{
	bool bFound = false;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	// 윈도우들을 돌아 다니면서 검사..
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		if ( bFound ) break;
		CN3UIBase* pChild = (*itor);
		if ( pChild->UIType() == UI_TYPE_ICON_MANAGER )
		{
			// 해당 윈도우가 보이고(활성화 되어 있고), 그 윈도우 영역 안에 있으면..
			if ( ((CN3UIWndBase* )pChild)->IsVisible() && ((CN3UIWndBase* )pChild)->IsIn(ptCur.x, ptCur.y) )
				// 해당 윈도우에 아이콘 드롭 메시지 함수를 호출..
				if ( ((CN3UIWndBase* )pChild)->ReceiveIconDrop(spItem, ptCur) )
					return true;
				else
					bFound = true;
		}
	}

	// 어느 누구의 영역에도 속하지 않으면.. 해당 아이콘을 가진 윈도우에게 Cancel 메시지를 날려 준다..
	if ( !bFound )
	{
		switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd )
		{
			case UIWND_INVENTORY:
				CGameProcedure::s_pProcMain->m_pUIInventory->CancelIconDrop(spItem);
				break;

			case UIWND_TRANSACTION:
				CGameProcedure::s_pProcMain->m_pUITransactionDlg->CancelIconDrop(spItem);
				break;

			case UIWND_WARE_HOUSE:
				CGameProcedure::s_pProcMain->m_pUIWareHouseDlg->CancelIconDrop(spItem);
				break;
		}
	}
	return false;
}

CN3UIBase* CUIManager::GetTopUI(bool bVisible)
{
	if(!bVisible) 
	{
		if(m_Children.empty()) return nullptr;
		else return *(m_Children.begin());
	}

	UIListItor it = m_Children.begin(), itEnd = m_Children.end();
	for(; it != itEnd; it++)
	{
		CN3UIBase* pUI = *(it);
		if(pUI->IsVisible()) return pUI;
	}
	
	return nullptr;
}

void CUIManager::SetFocusedUI(CN3UIBase* pUI)
{
	if(nullptr == pUI)
	{
		m_pUIFocused = nullptr;
		return;
	}

	UIListItor it = m_Children.begin(), itEnd = m_Children.end();
	it = m_Children.begin();
	for(; it != itEnd; it++)
	{
		if(pUI == *it) break;
	}
	if(it == itEnd) return;

	it = m_Children.erase(it);			// 우선 리스트에서 지우고
	m_Children.push_front(pUI);	// 맨앞에 넣는다. 그리는 순서를 맨 나중에 그리도록 하고 메세지를 맨 먼저 받게 하려고
	ReorderChildList();	// child list 재정렬(항상 위에 뜨는 dialog 때문에 다시 정렬한다.)

	m_pUIFocused = this->GetTopUI(true);
}

CN3UIBase* CUIManager::ReFocusUI()
{
	SetVisibleFocusedUI(GetEnableFocusTopUI(true));
	return m_pUIFocused;
}

void CUIManager::SetVisibleFocusedUI(CN3UIBase *pUI)
{
	if(nullptr == pUI)
	{
		m_pUIFocused = nullptr;
		return;
	}

	if(!pUI->IsVisible())
		return;

	UIListItor it = m_Children.begin(), itEnd = m_Children.end();

	uint32_t dwUIStyle, dwUIHideStyle;
	CN3UIBase* pUIHide = nullptr;

	dwUIStyle = pUI->GetStyle();
	if(dwUIStyle & UISTYLE_SHOW_ME_ALONE)
	{
		for(; it != itEnd;)
		{
			pUIHide = *it;
			if(pUIHide == nullptr)
			{
				it = m_Children.erase(it);
				continue;
			}

			dwUIHideStyle = pUIHide->GetStyle();
			if(pUIHide->IsVisible() && pUI != pUIHide && !(dwUIHideStyle & UISTYLE_HIDE_UNABLE))
				pUIHide->SetVisibleWithNoSound(false, true);

			it++;
		}//
	}
	else if(!(dwUIStyle & UISTYLE_HIDE_UNABLE))
	{
		for(; it != itEnd;)
		{
			pUIHide = *it;
			if(pUIHide == nullptr)
			{
				it = m_Children.erase(it);
				continue;
			}

			dwUIHideStyle = pUIHide->GetStyle();

			if (pUIHide->IsVisible()
				&& pUI != pUIHide)
			{
				if ((dwUIHideStyle & UISTYLE_SHOW_ME_ALONE) != 0)
					pUIHide->SetVisibleWithNoSound(false, true);
				else if ((dwUIStyle & UISTYLE_POS_LEFT) != 0
					&& (dwUIHideStyle & UISTYLE_POS_LEFT) != 0)
					pUIHide->SetVisibleWithNoSound(false, true);
				else if ((dwUIStyle & UISTYLE_POS_RIGHT) != 0
					&& (dwUIHideStyle & UISTYLE_POS_RIGHT) != 0)
					pUIHide->SetVisibleWithNoSound(false, true);
			}

			it++;
		}
	}

	it = m_Children.begin();
	itEnd = m_Children.end();

	for(; it != itEnd; it++)
	{
		if(pUI == *it) break;
	}
	if(it == itEnd) return;

	if(!(dwUIStyle & UISTYLE_FOCUS_UNABLE))
	{
		it = m_Children.erase(it);			// 우선 리스트에서 지우고
		m_Children.push_front(pUI);	// 맨앞에 넣는다. 그리는 순서를 맨 나중에 그리도록 하고 메세지를 맨 먼저 받게 하려고
		ReorderChildList();	// child list 재정렬(항상 위에 뜨는 dialog 때문에 다시 정렬한다.)
	}

	m_pUIFocused = this->GetEnableFocusTopUI(true);
}

CN3UIBase* CUIManager::GetEnableFocusTopUI(bool bVisible)
{
	if(!bVisible) 
	{
		if(m_Children.empty()) return nullptr;
		else return *(m_Children.begin());
	}

	UIListItor it = m_Children.begin(), itEnd = m_Children.end();
	for(; it != itEnd; it++)
	{
		CN3UIBase* pUI = *(it);
		if(pUI && pUI->IsVisible() &&	//보이고
			!(pUI->GetStyle() & UISTYLE_FOCUS_UNABLE) && //포커스가 가능하고
			!(pUI->GetStyle() & UISTYLE_HIDE_UNABLE)) //닫힐수 있는
			return pUI;
	}
	
	return nullptr;
}

void CUIManager::UserMoveHideUIs()
{
	bool bHide = false;
	UIListItor it = m_Children.begin(), itEnd = m_Children.end();
	for(; it != itEnd; it++)
	{
		CN3UIBase* pUI = *(it);

		if(pUI == nullptr) continue;

		if(pUI->IsVisible() && (pUI->GetStyle() & UISTYLE_USER_MOVE_HIDE))
		{
			bHide = true;
			pUI->SetVisibleWithNoSound(false, true);
		}
	}

	if(bHide) ReFocusUI();
}

// ===== END WarFare/UIManager.cpp =====

// ===== BEGIN WarFare/UIManager.h =====
#line 1 "WarFare/UIManager.h"
﻿// UIManager.h: interface for the CUIManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIMANAGER_H__1EED48B7_90A3_4242_99BD_ABC12040CDDE__INCLUDED_)
#define AFX_UIMANAGER_H__1EED48B7_90A3_4242_99BD_ABC12040CDDE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

struct __IconItemSkill;

class CDFont;
class CUIManager : public CN3UIBase
{
protected:
	struct __RenderStateForUI
	{
		DWORD dwZEnable, dwAlphaBlend, dwSrcBlend, dwDestBlend, dwFog;
		DWORD dwMagFilter, dwMinFilter, dwMipFilter;
#ifdef _DEBUG
		BOOL	bSet;	// 이미 값이 3D device의 값으로 세팅이 되었는지 판단.
#endif
	};
	
	static __RenderStateForUI s_sRSFU;	// RenderStateForUI
	uint32_t		m_dwMouseFlagsCur;
	bool		m_bEnableOperation;		// UI 조작이 가능한 상태인가?
	CN3UIBase*	m_pUIFocused;
#ifdef _DEBUG
	CDFont*		m_pDFont;
#endif

public:
	bool		m_bDoneSomething;		// UI 에서 조작을 했다...

public:
	void UserMoveHideUIs();
	CN3UIBase* GetEnableFocusTopUI(bool bVisible);
	static void	RenderStateRestore();
	static void	RenderStateSet();

	void	EnableOperationSet(bool bEnable) { m_bEnableOperation = bEnable; } // UI 조작 가능/불가능..
	bool	EnableOperation() { return m_bEnableOperation; } // UI 조작이 가능한 상태인가?

	void		Release();
	void		Tick();
	uint32_t		MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	uint32_t		GetCurMouseFlags() { return m_dwMouseFlagsCur; }
	CN3UIBase*	GetFocusedUI() { return m_pUIFocused; } // 찍은 UI 가져오기..
	void		SetFocusedUI(CN3UIBase* pUI); // 찍은 UI 가져오기..
	CN3UIBase*	GetTopUI(bool bVisible); // 최상위에 있는 UI 가져오기.
	void		SetVisibleFocusedUI(CN3UIBase* pUI);
	CN3UIBase*	ReFocusUI();
	void		Render();
	void		ReorderChildList();

	bool		BroadcastIconDropMsg(__IconItemSkill* spItem);

	CUIManager();
	virtual ~CUIManager();
};

#endif // !defined(AFX_UIMANAGER_H__1EED48B7_90A3_4242_99BD_ABC12040CDDE__INCLUDED_)

// ===== END WarFare/UIManager.h =====

// ===== BEGIN WarFare/UIMessageBox.cpp =====
#line 1 "WarFare/UIMessageBox.cpp"
﻿// UIMessageBox.cpp: implementation of the CUIMessageBox class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIMessageBox.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "GameProcCharacterSelect.h"
#include "UIKnightsOperation.h"
#include "UICreateClanName.h"
#include "UIPartyBBS.h"
#include "GameEng.h"
#include "GameProcLogin.h"
#include "LocalInput.h"
#include "UIMessageBoxManager.h"
#include "SubProcPerTrade.h"
#include "APISocket.h"

#include <shellapi.h>

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3Shape.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIMessageBox::CUIMessageBox()
{
	m_pBtn_OK = nullptr;
	m_pBtn_Yes = nullptr;
	m_pBtn_No = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pText_Message = nullptr;
	m_pText_Title = nullptr;
	m_pEdit_Common = nullptr;

	m_eBehavior = BEHAVIOR_NOTHING;
	m_iStyle	= MB_OK;
}

CUIMessageBox::~CUIMessageBox()
{

}

bool CUIMessageBox::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;
	
	N3_VERIFY_UI_COMPONENT(m_pBtn_OK, GetChildByID<CN3UIButton>("Btn_OK"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Yes, GetChildByID<CN3UIButton>("Btn_Yes"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_No, GetChildByID<CN3UIButton>("Btn_No"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel, GetChildByID<CN3UIButton>("Btn_Cancel"));
	N3_VERIFY_UI_COMPONENT(m_pText_Message, GetChildByID<CN3UIString>("Text_Message"));
	N3_VERIFY_UI_COMPONENT(m_pText_Title, GetChildByID<CN3UIString>("Text_Title"));
	N3_VERIFY_UI_COMPONENT(m_pEdit_Common, GetChildByID<CN3UIEdit>("Edit_Common"));

	return true;
}

void CUIMessageBox::SetText(const std::string& szMsg)
{
	m_pText_Message->SetString(szMsg);
}

void CUIMessageBox::SetTitle(const std::string& szTitle)
{
	m_pText_Title->SetString(szTitle);
}

bool CUIMessageBox::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	//s_CameraData.vp;  //불러 오는 과정을 살펴본다 
	//uint32_t mm = s_CameraData.vp.Height;
	//uint32_t ss = s_CameraData.vp.Width;	

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		CPlayerMySelf* pPlayer = CGameBase::s_pPlayer;
		CGameProcMain* pProcMain = CGameProcedure::s_pProcMain;
		CGameProcLogIn* pProcLogIn = CGameProcedure::s_pProcLogIn;
		CGameProcCharacterSelect* pProcChrSelect = CGameProcedure::s_pProcCharacterSelect;
		CN3Shape* pShape = CGameBase::s_pPlayer->m_pObjectTarget;

		if (pSender == m_pBtn_OK || pSender == m_pBtn_Yes)
		{
			//this_ui
			if(m_pParentUI)
				m_pParentUI->CallBackProc(m_iChildID,1);

			switch(m_eBehavior)
			{
				case BEHAVIOR_EXIT :
					{
						if(CGameProcedure::s_pProcActive == pProcMain) // 지금 메인 프로시저이면..
							pProcMain->ReleaseSound();

						::PostQuitMessage(0);
					}
					break; // 끝낸다.. 
				case BEHAVIOR_RESTART_GAME :
					{
						if(CGameProcedure::s_pProcActive == pProcMain) // 지금 메인 프로시저이면..
						{
							std::string szIP = CGameProcedure::s_pSocket->GetCurrentIP();
							uint32_t dwPort = CGameProcedure::s_pSocket->GetCurrentPort();
							
							CGameProcedure::s_bNeedReportConnectionClosed = false; // 서버접속이 끊어진걸 보고해야 하는지..
							CGameProcedure::s_pSocket->Disconnect();
							Sleep(2000); // 2초 딜레이.. 서버가 처리할 시간을 준다.
							//CGameProcedure::s_pSocket->Connect(s_hWndBase, szIP.c_str(), dwPort);
							CGameProcedure::s_bNeedReportConnectionClosed = true; // 서버접속이 끊어진걸 보고해야 하는지..

							CGameProcedure::MsgSend_GameServerLogIn();
							CGameProcedure::ProcActiveSet((CGameProcedure*)CGameProcedure::s_pProcCharacterSelect); // 다시 캐릭터 고르자..
						}
					}
					break;
				case BEHAVIOR_REGENERATION :			pProcMain->MsgSend_Regen(); break;// 부활 메시지 날리기..
				case BEHAVIOR_PARTY_PERMIT :			pProcMain->MsgSend_PartyOrForcePermit(0, true); break;
				case BEHAVIOR_PARTY_DISBAND :			pProcMain->MsgSend_PartyOrForceLeave(0); break;
				case BEHAVIOR_FORCE_PERMIT :			pProcMain->MsgSend_PartyOrForcePermit(1, true); break;
				case BEHAVIOR_FORCE_DISBAND :			pProcMain->MsgSend_PartyOrForceLeave(1); break;
				case BEHAVIOR_REQUEST_BINDPOINT :		if(pShape) pProcMain->MsgSend_ObjectEvent(pShape->m_iEventID, 0); 	break;
				case BEHAVIOR_KNIGHTS_CREATE:			pProcMain->m_pUICreateClanName->MsgSend_MakeClan(); break;
				case BEHAVIOR_KNIGHTS_DESTROY :			pProcMain->m_pUIKnightsOp->MsgSend_KnightsDestroy(); break; // 기사단 뽀개기..
				case BEHAVIOR_KNIGHTS_WITHDRAW :		pProcMain->m_pUIKnightsOp->MsgSend_KnightsWithdraw(); break; // 기사단 탈퇴하기..
				case BEHAVIOR_PERSONAL_TRADE_PERMIT :	pProcMain->m_pSubProcPerTrade->ProcessProceed(PER_TRADE_RESULT_MY_AGREE);	break;	// 내가 허락..
				case BEHAVIOR_MGAME_LOGIN:				/*pProcLogIn->MsgSend_AccountLogIn(LIC_MGAME);*/ break;
				case BEHAVIOR_DELETE_CHR: // 캐릭터 지우기..
					{
						std::string szKey;
						if(m_pEdit_Common) szKey = m_pEdit_Common->GetString();
						pProcChrSelect->MsgSend_DeleteChr(szKey);
					}
					break;
				case BEHAVIOR_CLAN_JOIN: 
					pProcMain->MsgSend_KnightsJoinReq(true);
					break;
				case BEHAVIOR_PARTY_BBS_REGISTER:			if(pProcMain->m_pUIPartyBBS)pProcMain->m_pUIPartyBBS->MsgSend_Register(); break;// 파티 게시판에 등록
				case BEHAVIOR_PARTY_BBS_REGISTER_CANCEL:	if(pProcMain->m_pUIPartyBBS)pProcMain->m_pUIPartyBBS->MsgSend_RegisterCancel(); break;// 파티 게시판에 등록 해제
				case BEHAVIOR_EXECUTE_OPTION:
					{
						::ShellExecute(nullptr, "open", "Option.exe", nullptr, nullptr, SW_SHOWNORMAL); // 홈페이지로 이동..
						PostQuitMessage(0);	// 종료...
					}
					break;
				default: break;
			}
		}
		else if (pSender == m_pBtn_No || pSender == m_pBtn_Cancel)
		{
			//this_ui
			if(m_pParentUI)
				m_pParentUI->CallBackProc(m_iChildID,2);

			this->SetVisible(false);
			this->SetText("");
			this->SetTitle("");

			switch(m_eBehavior)
			{
			case BEHAVIOR_PARTY_PERMIT:				pProcMain->MsgSend_PartyOrForcePermit(0, false); break;
			case BEHAVIOR_FORCE_PERMIT:				pProcMain->MsgSend_PartyOrForcePermit(1, false); break;
			case BEHAVIOR_PERSONAL_TRADE_PERMIT :	pProcMain->m_pSubProcPerTrade->LeavePerTradeState(PER_TRADE_RESULT_MY_DISAGREE);	break;	// 내가 거절..
			case BEHAVIOR_PERSONAL_TRADE_FMT_WAIT:	pProcMain->m_pSubProcPerTrade->LeavePerTradeState(PER_TRADE_RESULT_MY_CANCEL);	break;	// 내가 취소..
			case BEHAVIOR_CLAN_JOIN: pProcMain->MsgSend_KnightsJoinReq(false); break;
			}
		}

		this->SetVisible(false);
		this->SetText("");
		this->SetTitle("");
		this->SetVisibleEditControl(false);
		m_eBehavior = BEHAVIOR_NOTHING;
		pSender->SetState(UI_STATE_BUTTON_NORMAL);
	}

	return true;
}

void CUIMessageBox::SetBoxStyle(int iStyle)
{
	if(m_pBtn_OK) m_pBtn_OK->SetVisible(false);
	if(m_pBtn_Yes) m_pBtn_Yes->SetVisible(false);
	if(m_pBtn_No) m_pBtn_No->SetVisible(false);
	if(m_pBtn_Cancel) m_pBtn_Cancel->SetVisible(false);

	m_iStyle = iStyle;

	if(MB_YESNO == iStyle)
	{
		if(m_pBtn_Yes) m_pBtn_Yes->SetVisible(true);
		if(m_pBtn_No) m_pBtn_No->SetVisible(true);
	}
	else if (MB_CANCEL == iStyle)
	{
		if(m_pBtn_Cancel) m_pBtn_Cancel->SetVisible(true);
	}
	else if(MB_OK == iStyle)
	{
		if(m_pBtn_OK) m_pBtn_OK->SetVisible(true);
	}
	else
	{
		__ASSERT(0, "Not Supported MessageBox Type!!");
		if(m_pBtn_OK) m_pBtn_OK->SetVisible(true);
	}
}

void CUIMessageBox::SetVisibleEditControl(bool bVisible) // Edit Control Visible
{
	if(nullptr == m_pEdit_Common) return;
	
	m_pEdit_Common->SetString("");
	m_pEdit_Common->SetVisible(bVisible);
	if(bVisible) m_pEdit_Common->SetFocus();
	else m_pEdit_Common->KillFocus();
}

void CUIMessageBox::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if(!bVisible)
	{
		if(CGameProcedure::s_pMsgBoxMgr)
			CGameProcedure::s_pMsgBoxMgr->ReFocusMsgBox();
	}
}

bool CUIMessageBox::OnKeyPress(int iKey)
{
	if(!IsVisible())
		return CN3UIBase::OnKeyPress(iKey);

	if(MB_YESNO == m_iStyle)
	{
		switch(iKey)
		{
		case DIK_ESCAPE:
			ReceiveMessage(m_pBtn_No, UIMSG_BUTTON_CLICK);
			return true;
		case DIK_RETURN:
			ReceiveMessage(m_pBtn_Yes, UIMSG_BUTTON_CLICK);
			return true;
		}
	}
	else if (MB_CANCEL == m_iStyle)
	{
		switch(iKey)
		{
		case DIK_ESCAPE:
		case DIK_RETURN:
			ReceiveMessage(m_pBtn_Cancel, UIMSG_BUTTON_CLICK);
			return true;
		}
	}
	else if(MB_OK == m_iStyle)
	{
		switch(iKey)
		{
		case DIK_ESCAPE:
		case DIK_RETURN:
			ReceiveMessage(m_pBtn_OK, UIMSG_BUTTON_CLICK);
			return true;
		}
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIMessageBox.cpp =====

// ===== BEGIN WarFare/UIMessageBox.h =====
#line 1 "WarFare/UIMessageBox.h"
﻿// UIMessageBox.h: interface for the CUIMessageBox class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIMESSAGEBOX_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_)
#define AFX_UIMESSAGEBOX_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include "GameDef.h"

#define MB_CANCEL                 0x00000006L

class CUIMessageBox : public CN3UIBase  
{
protected:
	CN3UIButton*	m_pBtn_OK;
	CN3UIButton*	m_pBtn_Yes;
	CN3UIButton*	m_pBtn_No;
	CN3UIButton*	m_pBtn_Cancel;
	CN3UIString*	m_pText_Message;
	CN3UIString*	m_pText_Title;
	CN3UIEdit*		m_pEdit_Common;

public:
	e_Behavior	m_eBehavior;	// OK 버튼을 누르면 할짓...
	int			m_iStyle;		// 메시지 박스 스타일

public:
	bool OnKeyPress(int iKey) override;
	void SetVisible(bool bVisible) override;
	void SetBoxStyle(int iStyle);
	void SetVisibleEditControl(bool bVisible); // Edit Control Visible
	void SetTitle(const std::string& szTitle);
	void SetText(const std::string& szMsg);
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	
	CUIMessageBox();
	~CUIMessageBox() override;
};

#endif // !defined(AFX_UIMESSAGEBOX_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_)

// ===== END WarFare/UIMessageBox.h =====

// ===== BEGIN WarFare/UIMessageBoxManager.cpp =====
#line 1 "WarFare/UIMessageBoxManager.cpp"
﻿// UIMessageBoxManager.cpp: implementation of the CUIMessageBoxManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIMessageBoxManager.h"
#include "GameProcedure.h"
#include "UIManager.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIMessageBoxManager::CUIMessageBoxManager()
{
	m_pMsgBoxLatestRef = nullptr;
}

CUIMessageBoxManager::~CUIMessageBoxManager()
{
	Release();
}

int CUIMessageBoxManager::GetCount() const
{
	return static_cast<int>(m_UBMs.size());
}

std::string CUIMessageBoxManager::MessageBoxPost(const std::string& szMsg, const std::string& szTitle, int iStyle, e_Behavior eBehavior)
{
	CUIMessageBox*		pMB		= nullptr;
	__TABLE_UI_RESRC*	pTblUI	= nullptr;

	it_UBM it, it_e;

	it		= m_UBMs.find(szMsg);
	it_e	= m_UBMs.end();

	if( it == it_e )
	{
		pMB = new CUIMessageBox();
		if( pMB == nullptr )
			return szMsg;

		pTblUI = CGameBase::s_pTbl_UI.Find(NATION_ELMORAD);

		pMB->LoadFromFile(pTblUI->szMessageBox );
		pMB->SetVisible(false);
		m_UBMs.insert(val_UBM(szMsg, pMB));
	}
	else
	{
		pMB = it->second;
	}

	RECT rt = pMB->GetRegion();
	POINT pt;
	pt.x = (CN3Base::s_CameraData.vp.Width - (rt.right - rt.left)) / 2;
	pt.y = (CN3Base::s_CameraData.vp.Height - (rt.bottom - rt.top)) / 2;
	
	pMB->SetBoxStyle(iStyle);
	if(BEHAVIOR_DELETE_CHR == eBehavior) pMB->SetVisibleEditControl(true); // Edit Control Visible
	else pMB->SetVisibleEditControl(false);


	pMB->m_eBehavior = eBehavior;
	pMB->SetText(szMsg);
	pMB->SetTitle(szTitle);
	
	pMB->SetPos(pt.x, pt.y);
	pMB->SetVisible(true);

	m_pMsgBoxLatestRef = pMB; // 마지막에 띄운 대화상자.. Z 정렬을 위해서 이 포인터를 세팅해준다..

	it		= m_UBMs.begin();
	it_e	= m_UBMs.end();
	while(it!=it_e)
	{
		pMB = it->second;
		if( pMB && !pMB->IsVisible() )
		{
			delete pMB;
			it = m_UBMs.erase(it);
			continue;
		}
		it++;
	}

	return szMsg;
}

void CUIMessageBoxManager::MessageBoxClose(const std::string& szMsg)
{
	it_UBM it_f, it_e;
	it_f = m_UBMs.find(szMsg);
	it_e = m_UBMs.end();

	if(it_f != it_e)
	{
		if(m_pMsgBoxLatestRef == it_f->second)
			m_pMsgBoxLatestRef = nullptr;

		CUIMessageBox* pMB = it_f->second;
		if(pMB) pMB->SetVisible(false);
	}
}

void CUIMessageBoxManager::Render()
{
	it_UBM it = m_UBMs.begin(), it_e = m_UBMs.end();
	for(; it != it_e; it++)
	{
		CUIMessageBox* pMB = it->second;
		if(pMB == nullptr || pMB == m_pMsgBoxLatestRef) continue;
		if(!pMB->IsVisible()) continue;
		CUIManager::RenderStateSet();
		pMB->Render(); // 메시지 박스 렌더링..
		CUIManager::RenderStateRestore();
	}

	if(m_pMsgBoxLatestRef && m_pMsgBoxLatestRef->IsVisible())
	{
		CUIManager::RenderStateSet();
		m_pMsgBoxLatestRef->Render(); // 메시지 박스 렌더링..
		CUIManager::RenderStateRestore();
	}
}

void CUIMessageBoxManager::MessageBoxCloseAll()
{
	it_UBM it = m_UBMs.begin(), it_e = m_UBMs.end();
	for(; it != it_e; it++)
	{
		CUIMessageBox* pMB = it->second;
		if(pMB) pMB->SetVisible(false);
	}

	m_pMsgBoxLatestRef = nullptr;
}

uint32_t CUIMessageBoxManager::MouseProcAndTick(uint32_t &dwFlags, const POINT &ptCur, const POINT &ptOld)
{
	uint32_t dwRet = 0;
	CUIMessageBox *pMB;

	if(m_pMsgBoxLatestRef && m_pMsgBoxLatestRef->IsVisible())
	{
		dwRet = m_pMsgBoxLatestRef->MouseProc(dwFlags, ptCur, ptOld);
		if(dwRet != UI_MOUSEPROC_NONE) dwFlags = 0;
		if(m_pMsgBoxLatestRef) m_pMsgBoxLatestRef->Tick();
	}

	it_UBM it = m_UBMs.begin(), it_e = m_UBMs.end();
	for(; it != it_e; it++)
	{
		pMB = it->second;
		if(false == pMB->IsVisible())	continue;
		if(m_pMsgBoxLatestRef == pMB)	continue;

		dwRet = pMB->MouseProc(dwFlags, ptCur, ptOld);
		if(dwRet != UI_MOUSEPROC_NONE) dwFlags = 0;
		pMB->Tick();
	}

	return dwRet;
}

void CUIMessageBoxManager::Release()
{
	it_UBM it = m_UBMs.begin(), it_e = m_UBMs.end();
	for(; it != it_e; it++)
		delete it->second;
	m_UBMs.clear();

	m_pMsgBoxLatestRef = nullptr;
}

CUIMessageBox* CUIMessageBoxManager::ReFocusMsgBox()
{
	for(rit_UBM itor = m_UBMs.rbegin(); m_UBMs.rend() != itor; ++itor)
	{
		CUIMessageBox* pMsgBox = itor->second;
		if(pMsgBox && pMsgBox->IsVisible())
		{
			m_pMsgBoxLatestRef = pMsgBox;
			return m_pMsgBoxLatestRef;
		}
	}

	m_pMsgBoxLatestRef = nullptr;
	return nullptr;
}

// ===== END WarFare/UIMessageBoxManager.cpp =====

// ===== BEGIN WarFare/UIMessageBoxManager.h =====
#line 1 "WarFare/UIMessageBoxManager.h"
﻿// UIMessageBoxManager.h: interface for the CUIMessageBoxManager class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIMESSAGEBOXMANAGER_H__34454EC5_5C0E_42EE_8321_6C0ECC0EACD0__INCLUDED_)
#define AFX_UIMESSAGEBOXMANAGER_H__34454EC5_5C0E_42EE_8321_6C0ECC0EACD0__INCLUDED_

#include <map>

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "UIMessageBox.h"
#include "GameBase.h"

typedef std::map<std::string, CUIMessageBox*>::iterator it_UBM;
typedef std::map<std::string, CUIMessageBox*>::value_type val_UBM;
typedef std::map<std::string, CUIMessageBox*>::reverse_iterator	rit_UBM;

class CUIMessageBoxManager : public CGameBase
{
public:
	std::map<std::string, CUIMessageBox*>		m_UBMs;
	CUIMessageBox*								m_pMsgBoxLatestRef;

public:
	CUIMessageBox*	ReFocusMsgBox();
	CUIMessageBox*	GetFocusMsgBox(){ return m_pMsgBoxLatestRef; }
	void			Release();
	uint32_t			MouseProcAndTick(uint32_t& dwFlags, const POINT& ptCur, const POINT& ptOld );
	void			MessageBoxCloseAll();
	void			Render();
	int				GetCount() const;

	void			MessageBoxClose(const std::string& szMsg);
	std::string		MessageBoxPost(const std::string& szMsg, const std::string& szTitle, int iStyle, e_Behavior eBehavior = BEHAVIOR_NOTHING);

	CUIMessageBoxManager();
	virtual ~CUIMessageBoxManager();

};

#endif // !defined(AFX_UIMESSAGEBOXMANAGER_H__34454EC5_5C0E_42EE_8321_6C0ECC0EACD0__INCLUDED_)

// ===== END WarFare/UIMessageBoxManager.h =====

// ===== BEGIN WarFare/UIMessageWnd.cpp =====
#line 1 "WarFare/UIMessageWnd.cpp"
﻿// UIMessageWnd.cpp: implementation of the CUIMessageWnd class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIMessageWnd.h"
#include "GameProcMain.h"
#include "PacketDef.h"
#include "UIManager.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UIScrollBar.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIMessageWnd::CUIMessageWnd()
{
	m_pChatOut = nullptr;
	m_pScrollbar = nullptr;
	m_pBtn_Fold = nullptr;
	m_iChatLineCount = 0;
	m_ppUILines = nullptr;
	ZeroMemory(&m_rcChatOutRegion, sizeof(m_rcChatOutRegion));
}

CUIMessageWnd::~CUIMessageWnd()
{
	if (m_ppUILines) {delete [] m_ppUILines; m_ppUILines = nullptr;}	// m_ppUILines[n]의 포인터는 메모리 할당되어 있어도 부모가 해제될때 자동으로 해제하므로 안지워야 한다.

	ChatListItor itor;
	for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pChatInfo = (*itor);
		if (pChatInfo) delete pChatInfo;
	}
	m_ChatBuffer.clear();

	for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pChatInfo = (*itor);
		if (pChatInfo) delete pChatInfo;
	}
	m_LineBuffer.clear();
}

void CUIMessageWnd::Release()
{
	CN3UIBase::Release();

	m_pChatOut = nullptr;
	m_pScrollbar = nullptr;
	m_pBtn_Fold = nullptr;
	m_iChatLineCount = 0;
	if (m_ppUILines) {delete [] m_ppUILines; m_ppUILines = nullptr;}	// m_ppUILines[n]의 포인터는 메모리 할당되어 있어도 부모가 해제될때 자동으로 해제하므로 안지워야 한다.
	ZeroMemory(&m_rcChatOutRegion, sizeof(m_rcChatOutRegion));

	ChatListItor itor;
	for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pChatInfo = (*itor);
		if (pChatInfo) delete pChatInfo;
	}
	m_ChatBuffer.clear();

	for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pChatInfo = (*itor);
		if (pChatInfo) delete pChatInfo;
	}
	m_LineBuffer.clear();
}

BOOL CUIMessageWnd::MoveOffset(int iOffsetX, int iOffsetY)
{
	if (0 == iOffsetX && 0 == iOffsetY) return FALSE;
	// ui 영역
	m_rcRegion.left += iOffsetX;		m_rcRegion.top += iOffsetY;
	m_rcRegion.right += iOffsetX;		m_rcRegion.bottom += iOffsetY;

	// movable 영역
	m_rcMovable.left += iOffsetX;		m_rcMovable.top += iOffsetY;
	m_rcMovable.right += iOffsetX;		m_rcMovable.bottom += iOffsetY;

	// children 좌표 갱신
	CN3UIBase* pCUI = nullptr; // Child UI...
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		pCUI = (*itor);
		__ASSERT(pCUI, "child UI pointer is NULL!");
		pCUI->MoveOffset(iOffsetX, iOffsetY);
	}

	//여기에 채팅창 옮기는 것도 넣어라...
	/*RECT rt = CGameProcedure::s_pProcMain->m_pUIChatDlg->GetRegion();
	POINT pt = this->GetPos();
	if( (pt.x != rt.right) || ( pt.y != rt.top) )
	{
	CGameProcedure::s_pProcMain->m_pUIChatDlg->SetPos(pt.x - (rt.right-rt.left), pt.y);

	}*/

	//NOTE: (madpew) Don't stick them together, so chat and info can move freely, but sync with the folded version instead
	POINT pt = this->GetPos();
	RECT rc = this->GetRegion();
	RECT rc2 = CGameProcedure::s_pProcMain->m_pUIMsgDlg2->GetRegion();
	CGameProcedure::s_pProcMain->m_pUIMsgDlg2->SetPos(pt.x, rc.bottom + (rc2.top - rc2.bottom));
	
	return true;
}

bool CUIMessageWnd::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;
	N3_VERIFY_UI_COMPONENT(m_pChatOut, GetChildByID<CN3UIString>("text_message"));
	N3_VERIFY_UI_COMPONENT(m_pScrollbar, GetChildByID<CN3UIScrollBar>("scroll"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Fold, GetChildByID("btn_off"));

	m_rcChatOutRegion = m_pChatOut->GetRegion();
	CreateLines();

	__ASSERT(0<m_iChatLineCount,"채팅창이 너무 작아요");
	
	return true;
}


//////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////

bool CUIMessageWnd::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		// 스크롤바에 맞는 채팅 Line 설정
		int iCurLinePos = m_pScrollbar->GetCurrentPos();
		SetTopLine(iCurLinePos);
		return true;
	}
	else if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Fold)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIMsgWnd();
			return true;
		}
	}

	return false;
}

void CUIMessageWnd::CreateLines()
{
	int i;
	if (m_ppUILines) {
		for (i=0; i<m_iChatLineCount; ++i)
		{
			if (m_ppUILines[i]) {delete m_ppUILines[i]; m_ppUILines[i] = nullptr;}
		}
		delete [] m_ppUILines; m_ppUILines = nullptr;
	}
	SIZE size;
	if (m_pChatOut && m_pChatOut->GetTextExtent("가", lstrlen("가"), &size) && size.cy>0)
	{
		m_iChatLineCount = (m_rcChatOutRegion.bottom - m_rcChatOutRegion.top)/size.cy;
	}
	else return;
	const std::string& szFontName = m_pChatOut->GetFontName();
	uint32_t dwFontHeight = m_pChatOut->GetFontHeight();
	uint32_t dwFontFlag = m_pChatOut->GetFontFlags();

	if (m_iChatLineCount<=0 || szFontName.size() <= 0) return;

	m_ppUILines = new CN3UIString*[m_iChatLineCount];
	for (i=0; i<m_iChatLineCount; ++i)
	{
		RECT rc;
		SetRect(&rc, m_rcChatOutRegion.left, m_rcChatOutRegion.top+(i*size.cy),
									m_rcChatOutRegion.right, m_rcChatOutRegion.top+((i+1)*size.cy));
		m_ppUILines[i] = new CN3UIString();
		m_ppUILines[i]->Init(this);
		m_ppUILines[i]->SetRegion(rc);
		m_ppUILines[i]->SetStyle(UISTYLE_STRING_SINGLELINE|UISTYLE_STRING_ALIGNLEFT|UISTYLE_STRING_ALIGNTOP);
		m_ppUILines[i]->SetFont(szFontName, dwFontHeight, dwFontFlag & D3DFONT_BOLD, dwFontFlag & D3DFONT_ITALIC);
	}
}

void CUIMessageWnd::AddMsg(const std::string& szString, D3DCOLOR color)
{
	const int iStrLen = static_cast<int>(szString.size());
	__ASSERT(m_pScrollbar, "");
	if (0 >= iStrLen)
		return;

	// ChatBuffer에 넣기
	__ChatInfo* pChatInfo = new __ChatInfo;
	pChatInfo->szChat = szString;
	pChatInfo->color = color;
	m_ChatBuffer.push_back(pChatInfo);
	
	if (m_ChatBuffer.size() > 255)	// 255개가 넘으면 앞에서부터 지우기
	{
		__ChatInfo* pTemp = m_ChatBuffer.front();
		if (pTemp) delete pTemp;

		m_ChatBuffer.pop_front();
	}

	// line buffer 에 넣기
	AddLineBuffer(szString, color);
	
	// Line buffer 갯수 조절
	int iCurLinePos = m_pScrollbar->GetCurrentPos();	// 현재 scroll bar가 가리키고 있는 line
	BOOL bAutoScroll = (m_pScrollbar->GetMaxPos() == iCurLinePos) ? TRUE : FALSE;

	while (m_LineBuffer.size() > MAX_CHAT_LINES && 0 < iCurLinePos)	// MAX_CHAT_LINES은 최대 line의 수 (단 스크롤바가 0인 곳에 있으면 line을 지우지 않으므로 500개를 넘길 수 있다)
	{
		// 한줄 지우기
		__ChatInfo* pTemp = m_LineBuffer.front();
		if (pTemp) delete pTemp;
		m_LineBuffer.pop_front();
		--iCurLinePos;	
	}

	int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
	int iMaxScrollPos = iLineBufferSize - m_iChatLineCount;
	if (iMaxScrollPos < 0)
		iMaxScrollPos = 0;
	m_pScrollbar->SetRange(0, iMaxScrollPos);	// scroll bar range 설정

	// 자동으로 스크롤이면
	if ( bAutoScroll) iCurLinePos = iMaxScrollPos;
	if (iCurLinePos < 0) iCurLinePos = 0;

	// 스크롤바 현재 위치 재설정
	m_pScrollbar->SetCurrentPos(iCurLinePos);

	// 스크롤바에 맞는 채팅 Line 설정
	SetTopLine(iCurLinePos);
}

void CUIMessageWnd::AddLineBuffer(const std::string& szString, D3DCOLOR color)
{
	if (szString.empty())
		return;

	__ASSERT(m_pChatOut, "");

	const int iStrLen = static_cast<int>(szString.size());

	// line buffer 넣기
	SIZE size;
	if (!m_pChatOut->GetTextExtent(szString, iStrLen, &size))
	{
		__ASSERT(0, "no device context");
		return;
	}

	const int iRegionWidth = m_rcChatOutRegion.right - m_rcChatOutRegion.left;

	// 글자 자르는 코드, 영역 밖으로 벗어나는 글자는 자르고 밑에 줄에..
	int iCX=0;
	int iCount = 0;
	int iLineStart = 0;

	while(iCount<iStrLen)
	{
		if ('\n' == szString[iCount])		// \n
		{
			__ChatInfo* pLineInfo = new __ChatInfo;
			m_LineBuffer.push_back(pLineInfo);

			pLineInfo->color = color;
			if ((iCount - iLineStart)>0)
			{
				int iLineLength = iCount - iLineStart + 1;
				std::string szLine;
				pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
			}	// 연속된 \n일 경우 pszLine = nullptr이 될 수 있다.

			++iCount;
			iLineStart = iCount;
			iCX = 0;
		}
		else
		{
			int iCC=0;
			if (0x80 & szString[iCount])	iCC = 2;	// 2BYTE 문자
			else							iCC = 1;	// 1BYTE 문자

			BOOL bFlag = m_pChatOut->GetTextExtent(&(szString[iCount]), iCC, &size);
			__ASSERT(bFlag, "cannot get size of dfont");
			if ((iCX+size.cx) > iRegionWidth)	// 가로 길이가 넘었으면
			{
				// 한 라인 더 추가하기
				
				int iLineLength = iCount - iLineStart;
				if (iLineLength>0)
				{
					__ChatInfo* pLineInfo = new __ChatInfo;
					m_LineBuffer.push_back(pLineInfo);

					pLineInfo->color = color;
					pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
				}
				else
				{
					__ASSERT(iRegionWidth>15, "너무 좁아서 한글자도 찍을 수가 없다");
					break;
				}
				iLineStart = iCount;
				iCX = 0;
			}
			// 글자 더하기
			iCount += iCC;
			iCX += size.cx;
		}
	}

	// 맨 마지막 출 처리
	int iLineLength = iStrLen - iLineStart;
	if (iLineLength>0)
	{
		__ChatInfo* pLineInfo = new __ChatInfo;
		m_LineBuffer.push_back(pLineInfo);

		pLineInfo->color = color;
		pLineInfo->szChat = szString.substr(iLineStart, iLineLength);
	}
}

void CUIMessageWnd::SetTopLine(int iTopLine)
{
	if (m_iChatLineCount<=0) return;

	const int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
	if (iTopLine < 0)
		iTopLine = 0;
	else if (iTopLine > iLineBufferSize)
		iTopLine = iLineBufferSize;
	
	int i;
	// 앞줄서부터 차례로 임시버퍼에 저장하고 string 길이 측정
	__ChatInfo** ppLineInfos = new __ChatInfo* [m_iChatLineCount];
	memset(ppLineInfos, 0, sizeof(__ChatInfo*) * m_iChatLineCount);

	int iCurLine = 0;
	for (i=0; i<m_iChatLineCount; ++i)
	{
		iCurLine = iTopLine + i;
		if (iLineBufferSize <= iCurLine) break;
		ppLineInfos[i] = m_LineBuffer[iCurLine];
	}

	__ASSERT(m_ppUILines, "null pointer");
	// 앞에서부터 맞게 차례로 각각 버퍼에 넣기
	int iRealLine = i;	// 실제 출력되는 줄 수
	int iRealLineCount = 0;
	for (i=0; i<iRealLine; ++i)
	{
		++iRealLineCount;
		if (nullptr == m_ppUILines[i]) continue;
		m_ppUILines[i]->SetColor(ppLineInfos[i]->color);
		m_ppUILines[i]->SetString(ppLineInfos[i]->szChat);
	}
	for (i=iRealLineCount; i<m_iChatLineCount; ++i)
	{
		if (nullptr == m_ppUILines[i]) continue;
		m_ppUILines[i]->SetString("");	// 나머지는 빈칸 만들기
	}
	delete [] ppLineInfos;
}

void CUIMessageWnd::RecalcLineBuffer()	// 채팅창 사이즈가 변했을때 호출해주면 line buffer를 다시 계산해서 넣어준다.
{
	// line buffer 초기화하기
	ChatListItor itor;
	for(itor = m_LineBuffer.begin(); m_LineBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pLineBuff = (*itor);
		if (pLineBuff) delete pLineBuff;
	}
	m_LineBuffer.clear();

	// Line buffer 다시 넣기
	for(itor = m_ChatBuffer.begin(); m_ChatBuffer.end() != itor; ++itor)
	{
		__ChatInfo* pChatBuff = (*itor);
		if (pChatBuff) AddLineBuffer(pChatBuff->szChat, pChatBuff->color);
	}

	// Line buffer 갯수 조절
	while (m_LineBuffer.size() > MAX_CHAT_LINES)	// MAX_CHAT_LINES은 최대 line의 수
	{
		// 한줄 지우기
		delete m_LineBuffer.front();
		m_LineBuffer.pop_front();
	}

	int iLineBufferSize = static_cast<int>(m_LineBuffer.size());
	int iMaxScrollPos = iLineBufferSize - m_iChatLineCount;
	if (iMaxScrollPos < 0)
		iMaxScrollPos = 0;

	m_pScrollbar->SetRange(0, iMaxScrollPos);	// scroll bar range 설정

	// 스크롤바 현재 위치 재설정
	m_pScrollbar->SetCurrentPos(iMaxScrollPos);

	// 스크롤바에 맞는 채팅 Line 설정
	SetTopLine(iMaxScrollPos);
}

void CUIMessageWnd::SetRegion(const RECT& Rect)
{
	CN3UIBase::SetRegion(Rect);
	// 자식들을 적당히 배치한다.
	// m_rcChatOutRegion = ;	// 채팅 출력 영역을 다시 지정해준다.
	//CreateLines();	// 채팅 라인을 몇줄 들어갈지 계산하고 다시 만든다.
	//RecalcLineBuffer();	// 라인 버퍼를 다 지우고 다시 만들어주고 글씨를 표시한다.
}


bool CUIMessageWnd::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if(pFocus && pFocus != this) pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// UI MESSAGE WND 2 (FOLDED)

CUIMessageWnd2::CUIMessageWnd2()
{
	m_pBtn_Fold = nullptr;
}

bool CUIMessageWnd2::Load(File& file)
{
	if (false == CN3UIBase::Load(file)) return false;
	N3_VERIFY_UI_COMPONENT(m_pBtn_Fold, GetChildByID("btn_on"));
	return true;
}

bool CUIMessageWnd2::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (nullptr == pSender) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Fold)
		{
			CGameProcedure::s_pProcMain->CommandToggleUIMsgWnd();
			return true;
		}
	}

	return false;
}

void CUIMessageWnd2::Release()
{
	CN3UIBase::Release();
	m_pBtn_Fold = nullptr;
}

// ===== END WarFare/UIMessageWnd.cpp =====

// ===== BEGIN WarFare/UIMessageWnd.h =====
#line 1 "WarFare/UIMessageWnd.h"
﻿// UIMessageWnd.h: interface for the CUIMessageWnd class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIMESSAGEWND_H__F825624B_A51E_4889_9ADC_BEBF022D010B__INCLUDED_)
#define AFX_UIMESSAGEWND_H__F825624B_A51E_4889_9ADC_BEBF022D010B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include "UIChat.h"

class CUIMessageWnd : public CN3UIBase  
{
protected:
	CN3UIString*	m_pChatOut;		// 채팅이 출력되는 UIString 참조포인터(실제 m_Child로 관리), 글씨체와 초기 영역만 참조한다.
	CN3UIScrollBar* m_pScrollbar;	// scrollbar 참조포인터(실제 m_Child로 관리)
	CN3UIBase*		m_pBtn_Fold;

	ChatList		m_ChatBuffer;		// 채팅 packet기준으로 된 buffer
	ChatList		m_LineBuffer;		// Line 기준으로 된 buffer
	
	int				m_iChatLineCount;	// 채팅창에 출력되는 line의 수(채팅창 사이즈가 변했을때 다시 계산해주자.)
	RECT			m_rcChatOutRegion;	// 채팅이 출력되는 영역
	CN3UIString**	m_ppUILines;		// 채팅이 출력되는 UIString 배열포인터(채팅창 사이즈가 변하므로 배열도 변한다.

protected:
	void			SetTopLine(int iTopLine);		// 맨 윗줄을 지정해준다.
	void			AddLineBuffer(const std::string& szString, D3DCOLOR color);	// line 버퍼를 만들어준다.(너무 길면 알아서 2줄로 만들어준다.)
	void			RecalcLineBuffer();		// 채팅창 사이즈가 변했을때 호출해주면 line buffer를 다시 계산해서 넣어준다.
	void			CreateLines();

// Operations
public:
	bool OnKeyPress(int iKey) override;
	BOOL MoveOffset(int iOffsetX, int iOffsetY) override;	// offsetY만큼 이동해준다.(region, children, move rect 이동)
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Release() override;
	bool Load(File& file) override;
	void SetRegion(const RECT& Rect) override;	// 영역 지정(사이즈가 변할때 호출된다. 단순 이동은 호출되지 않는다.(단순이동은 MoveOffset이 호출))
		    
	void AddMsg(const std::string& szString, D3DCOLOR color = 0xffffffff);		// 채팅 메세지를 저장하고 알맞은 형태로 화면에 출력해준다.

	CUIMessageWnd();
	~CUIMessageWnd() override;
};

// TODO: Use the official name for this
class CUIMessageWnd2 : public CN3UIBase
{
protected:
	CN3UIBase* m_pBtn_Fold;

public:
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Release() override;
	bool Load(File& file) override;

	CUIMessageWnd2();
};
#endif // !defined(AFX_UIMESSAGEWND_H__F825624B_A51E_4889_9ADC_BEBF022D010B__INCLUDED_)

// ===== END WarFare/UIMessageWnd.h =====

// ===== BEGIN WarFare/UIMsgBoxOkCancel.cpp =====
#line 1 "WarFare/UIMsgBoxOkCancel.cpp"
﻿// UIMsgBoxOkCancel.cpp: implementation of the CUIMsgBoxOkCancel class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIMsgBoxOkCancel.h"
#include "LocalInput.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIMsgBoxOkCancel::CUIMsgBoxOkCancel()
{
	m_pBtn_OK = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pText_Msg = nullptr;
}

CUIMsgBoxOkCancel::~CUIMsgBoxOkCancel()
{
}

void CUIMsgBoxOkCancel::Release()
{
	CN3UIBase::Release();

	m_pBtn_OK = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pText_Msg = nullptr;
}

bool CUIMsgBoxOkCancel::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_OK,		GetChildByID<CN3UIButton>("btn_ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,	GetChildByID<CN3UIButton>("btn_cancel"));
	N3_VERIFY_UI_COMPONENT(m_pText_Msg,		GetChildByID<CN3UIString>("text_msg"));

	return true;
}

void CUIMsgBoxOkCancel::SetText(const std::string& szMsg)
{
	if (m_pText_Msg != nullptr)
		m_pText_Msg->SetString(szMsg);
}

bool CUIMsgBoxOkCancel::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_OK)
		{
			if (m_pParentUI != nullptr)
				m_pParentUI->CallBackProc(m_iChildID, CALLBACK_OK);

			SetVisible(false);
			return true;
		}

		if (pSender == m_pBtn_Cancel)
		{
			if (m_pParentUI != nullptr)
				m_pParentUI->CallBackProc(m_iChildID, CALLBACK_CANCEL);

			SetVisible(false);
			return true;
		}
	}

	return CN3UIBase::ReceiveMessage(pSender, dwMsg);
}

bool CUIMsgBoxOkCancel::OnKeyPress(int iKey)
{
	if (iKey == DIK_ESCAPE)
	{
		ReceiveMessage(m_pBtn_Cancel, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIMsgBoxOkCancel.cpp =====

// ===== BEGIN WarFare/UIMsgBoxOkCancel.h =====
#line 1 "WarFare/UIMsgBoxOkCancel.h"
﻿// UIMsgBoxOkCancel.h: interface for the CUIMsgBoxOkCancel class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIMSGBOXOKCANCEL_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_)
#define AFX_UIMSGBOXOKCANCEL_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUIMsgBoxOkCancel : public CN3UIBase
{
public:
	static constexpr int CALLBACK_OK		= 1;
	static constexpr int CALLBACK_CANCEL	= 2;

	CUIMsgBoxOkCancel();
	~CUIMsgBoxOkCancel() override;
	bool Load(File& file) override;
	void Release() override;
	void SetText(const std::string& szMsg);
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool OnKeyPress(int iKey) override;

protected:
	CN3UIButton* m_pBtn_OK;
	CN3UIButton* m_pBtn_Cancel;
	CN3UIString* m_pText_Msg;
};

#endif // !defined(AFX_UIMSGBOXOKCANCEL_H__943941D4_06D0_40A0_BEF2_DA3A27406EDC__INCLUDED_)

// ===== END WarFare/UIMsgBoxOkCancel.h =====

// ===== BEGIN WarFare/UINPCChangeEvent.cpp =====
#line 1 "WarFare/UINPCChangeEvent.cpp"
﻿// UINPCChangeEvent.cpp: implementation of the CUINPCChangeEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UINPCChangeEvent.h"
#include "PacketDef.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "APISocket.h"
#include "UIInventory.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUINPCChangeEvent::CUINPCChangeEvent()
{
	m_pBtn_Repoint0 = nullptr;
	m_pBtn_Repoint1 = nullptr;
	m_pBtn_Close = nullptr;

	m_pDlg = nullptr;

	m_bSendedAllPoint = false;
}

CUINPCChangeEvent::~CUINPCChangeEvent()
{
	delete m_pDlg;
	m_pDlg = nullptr;
}

void CUINPCChangeEvent::Release()
{
	if (m_pDlg != nullptr)
	{
		m_pDlg->Release();
		delete m_pDlg;
		m_pDlg = nullptr;
	}

	CN3UIBase::Release();
}

bool CUINPCChangeEvent::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	int iW = CN3Base::s_CameraData.vp.Width;
	int iH = CN3Base::s_CameraData.vp.Height;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Repoint0, GetChildByID<CN3UIButton>("Btn_repoint0"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Repoint1, GetChildByID<CN3UIButton>("Btn_repoint1"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close, GetChildByID<CN3UIButton>("Btn_close"));

	// UIPointInitDlg.. ^^
	e_Nation eNation = CGameBase::s_pPlayer->m_InfoBase.eNation; // 국가....
	__TABLE_UI_RESRC* pTbl = CGameProcedure::s_pTbl_UI.Find(eNation);

	m_pDlg = new CUIPointInitDlg();
	m_pDlg->LoadFromFile(pTbl->szChangeInitBill);

	// 위치 계산 ..
	int iXPos, iYPos;
	iXPos = (iW / 2) - (m_pDlg->GetRegion().right - m_pDlg->GetRegion().left) / 2;
	iYPos = (iH / 2) - (m_pDlg->GetRegion().bottom - m_pDlg->GetRegion().top) / 2;
	m_pDlg->SetPos(iXPos, iYPos);
	m_pDlg->Close();

	return true;
}

bool CUINPCChangeEvent::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Close)
		{
			Close();
		}
		else if (pSender == m_pBtn_Repoint0 && !s_bWaitFromServer)
		{
			CUIInventory* pInv = CGameProcedure::s_pProcMain->m_pUIInventory;
			if (pInv == nullptr)
			{
				Close();
				return true;
			}

			if (!pInv->HasAnyItemInSlot())
			{
				PointChangePriceQuery(true);
			}
			else
			{
				Close();

				std::string szMsg = fmt::format_text_resource(IDS_MSG_HASITEMINSLOT);
				CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
			}
		}
		else if (pSender == m_pBtn_Repoint1 && !s_bWaitFromServer)
		{
			PointChangePriceQuery(false);
		}
	}

	return true;
}

void CUINPCChangeEvent::Open()
{
	SetVisible(true);
}

void CUINPCChangeEvent::Close()
{
	SetVisible(false);
	if (m_pDlg != nullptr && m_pDlg->IsVisible())
		m_pDlg->Close();
}

void CUINPCChangeEvent::PointChangePriceQuery(bool bAllPoint)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CLASS_CHANGE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_CLASS_POINT_CHANGE_PRICE_QUERY);
	if (bAllPoint)
		CAPISocket::MP_AddByte(byBuff, iOffset, 1);
	else
		CAPISocket::MP_AddByte(byBuff, iOffset, 2);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
	m_bSendedAllPoint = bAllPoint;
}

void CUINPCChangeEvent::ReceivePriceFromServer(int iGold)
{
	if (m_pDlg != nullptr)
	{
		m_pDlg->ShowWindow(-1, this);
		m_pDlg->InitDlg(m_bSendedAllPoint, iGold);
	}
}

void CUINPCChangeEvent::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();
}

bool CUINPCChangeEvent::OnKeyPress(int iKey)
{
	switch (iKey)
	{
		case DIK_ESCAPE:
			ReceiveMessage(m_pBtn_Close, UIMSG_BUTTON_CLICK);
			return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UINPCChangeEvent.cpp =====

// ===== BEGIN WarFare/UINPCChangeEvent.h =====
#line 1 "WarFare/UINPCChangeEvent.h"
﻿// UINPCChangeEvent.h: interface for the CUINPCChangeEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UINPCCHANGEEVENT_H__01943C6E_D7DD_49B1_BBAF_63DE3B65E586__INCLUDED_)
#define AFX_UINPCCHANGEEVENT_H__01943C6E_D7DD_49B1_BBAF_63DE3B65E586__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "UIPointInitDlg.h"

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUINPCChangeEvent : public CN3UIBase
{
	CN3UIButton*		m_pBtn_Repoint0;
	CN3UIButton*		m_pBtn_Repoint1;
	CN3UIButton*		m_pBtn_Close;

	CUIPointInitDlg*	m_pDlg;

	bool				m_bSendedAllPoint;

public:
	bool OnKeyPress(int iKey) override;
	void SetVisible(bool bVisible) override;
	void Release() override;

	CUINPCChangeEvent();
	~CUINPCChangeEvent() override;

	bool	Load(File& file) override;
	bool	ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	void	Open();
	void	Close();

	void	PointChangePriceQuery(bool bAllPoint);
	void	ReceivePriceFromServer(int iGold);
};

#endif // !defined(AFX_UINPCCHANGEEVENT_H__01943C6E_D7DD_49B1_BBAF_63DE3B65E586__INCLUDED_)

// ===== END WarFare/UINPCChangeEvent.h =====

// ===== BEGIN WarFare/UINPCEvent.cpp =====
#line 1 "WarFare/UINPCEvent.cpp"
﻿// UINPCEvent.cpp: implementation of the UINPCEvent class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UINPCEvent.h"
#include "GameProcMain.h"
#include "UIInventory.h"
#include "UITransactionDlg.h"
#include "SubProcPerTrade.h"
#include "UISkillTreeDlg.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUINPCEvent::CUINPCEvent()
{

}

CUINPCEvent::~CUINPCEvent()
{

}

void CUINPCEvent::Release()
{
	CN3UIBase::Release();
}

bool CUINPCEvent::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Repair, GetChildByID<CN3UIButton>("Btn_Repair"));
	N3_VERIFY_UI_COMPONENT(m_pText_Repair, GetChildByID<CN3UIString>("Text_Repair"));
	N3_VERIFY_UI_COMPONENT(m_pText_Title, GetChildByID<CN3UIString>("Text_Title"));

	return true;
}

bool CUINPCEvent::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "Btn_Sale")
		{
			if (CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE) 	/* 개인간 상거래 중이면.. */
				return true;

			Close();
			if (CGameProcedure::s_pProcMain->m_pUIInventory->IsVisible())
				return true;
			if (CGameProcedure::s_pProcMain->m_pUITransactionDlg->IsVisible())
				return true;
			if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->IsVisible())
				CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->Close();
			CGameProcedure::s_pProcMain->DoCommercialTransaction(m_iTradeID);
		}

		if(pSender->m_szID == "Btn_Repair")
		{
			if (CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_ePerTradeState != PER_TRADE_STATE_NONE) 	/* 개인간 상거래 중이면.. */
				return true;

			Close();
			if (CGameProcedure::s_pProcMain->m_pUITransactionDlg->IsVisible())
				return true;
			if (CGameProcedure::s_pProcMain->m_pUIInventory->IsVisible())
				return true;
			if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->IsVisible())
				CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->Close();
			CGameProcedure::s_pProcMain->m_pUIInventory->Open(INV_STATE_REPAIR);

		}


		if(pSender->m_szID == "btn_close")
			Close();
	}

	return true;
}

void CUINPCEvent::Open(e_NpcEvent eNpcEvent, int iTradeId, int iIDTarget)
{
	SetVisible(true);
	m_iIDTarget = iIDTarget;
	m_iTradeID  = iTradeId;
	std::string szStr;

	switch(eNpcEvent)
	{
		case NPC_EVENT_ITEM_TRADE:
			szStr = fmt::format_text_resource(IDS_NPC_EVENT_TITLE_TRADE);
			m_pText_Title->SetString(szStr);
			if (m_pBtn_Repair)
			{
				if (m_pBtn_Repair->IsVisible())
				{
					m_pBtn_Repair->SetVisible(false);
					m_pText_Repair->SetVisible(false);
				}
			}
			break;

		case NPC_EVENT_TRADE_REPAIR:
			szStr = fmt::format_text_resource(IDS_NPCEVENT_TITLE_REPAIR);
			m_pText_Title->SetString(szStr);
			if (m_pBtn_Repair)
			{
				if (!m_pBtn_Repair->IsVisible())
				{
					m_pBtn_Repair->SetVisible(true);
					m_pText_Repair->SetVisible(true);
				}
			}
			break;
	}
}

void CUINPCEvent::Close()
{
	SetVisible(false);
}

bool CUINPCEvent::OnKeyPress(int iKey)
{
	if(DIK_ESCAPE == iKey)
	{
		this->Close();
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUINPCEvent::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

// ===== END WarFare/UINPCEvent.cpp =====

// ===== BEGIN WarFare/UINPCEvent.h =====
#line 1 "WarFare/UINPCEvent.h"
﻿// UINPCEvent.h: interface for the UINPCEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UINPCEVENT_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_)
#define AFX_UINPCEVENT_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

enum e_NpcEvent	{ NPC_EVENT_ITEM_TRADE = 0, NPC_EVENT_TRADE_REPAIR = 1, NPC_EVENT_KNIGHTS = 2 };

//////////////////////////////////////////////////////////////////////

class CUINPCEvent : public CN3UIBase
{
	int					m_iTradeID;
	int					m_iIDTarget;
	CN3UIButton*		m_pBtn_Repair;
	CN3UIString*		m_pText_Repair;
	CN3UIString*		m_pText_Title;

public:
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	void Release() override;

	CUINPCEvent();
	~CUINPCEvent() override;

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	void Open(e_NpcEvent eNpcEvent, int iTradeId = -1, int iIDTarget = -1);
	void Close();
};

#endif // !defined(AFX_UINPCEVENT_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_)

// ===== END WarFare/UINPCEvent.h =====

// ===== BEGIN WarFare/UINationSelectDlg.cpp =====
#line 1 "WarFare/UINationSelectDlg.cpp"
﻿// UINationSelectDlg.cpp: implementation of the CUINationSelectDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UINationSelectDlg.h"
#include "GameProcNationSelect.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUINationSelectDlg::CUINationSelectDlg()
{
	m_pProcNationSelectRef = nullptr;
}

CUINationSelectDlg::~CUINationSelectDlg()
{
	m_pBtnKarus = nullptr;
	m_pBtnElmorad = nullptr;
	m_pBtnBack = nullptr;
}

bool CUINationSelectDlg::Load(File& file)
{
	bool bSuccess = CN3UIBase::Load(file);

	N3_VERIFY_UI_COMPONENT(m_pBtnKarus, GetChildByID("btn_karus_selection"));
	N3_VERIFY_UI_COMPONENT(m_pBtnElmorad, GetChildByID("btn_elmo_selection")); // 
	N3_VERIFY_UI_COMPONENT(m_pBtnBack, GetChildByID("btn_back")); // 
	RECT rc = this->GetRegion();
	int iX = ((int)s_CameraData.vp.Width - (rc.right - rc.left))/2;
	int iY = ((int)s_CameraData.vp.Height - (rc.bottom - rc.top))/2;
	this->SetPos(iX, iY);

	return bSuccess;
}

bool CUINationSelectDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		if ( pSender == m_pBtnKarus )	// Karus
		{
			if(m_pProcNationSelectRef) m_pProcNationSelectRef->MsgSendNationSelect(NATION_KARUS);
		}
		else
		if ( pSender == m_pBtnElmorad )	// Elmorad
		{
			if(m_pProcNationSelectRef) m_pProcNationSelectRef->MsgSendNationSelect(NATION_ELMORAD);
		}
		else
		if ( pSender == m_pBtnBack ) // Back
		{
			CGameProcedure::ProcActiveSet((CGameProcedure*)CGameProcedure::s_pProcLogIn); // 캐릭터 선택 프로시저로 한다..
		}
	}

	return true;
}


// ===== END WarFare/UINationSelectDlg.cpp =====

// ===== BEGIN WarFare/UINationSelectDlg.h =====
#line 1 "WarFare/UINationSelectDlg.h"
﻿// UINationSelectDlg.h: interface for the CUINationSelectDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UINATIONSELECTDLG_H__AC80EE20_C90E_4B08_807A_5431F8F23BF7__INCLUDED_)
#define AFX_UINATIONSELECTDLG_H__AC80EE20_C90E_4B08_807A_5431F8F23BF7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUINationSelectDlg : public CN3UIBase  
{
public:
	CN3UIBase* m_pBtnKarus;
	CN3UIBase* m_pBtnElmorad;
	CN3UIBase* m_pBtnBack;
	class CGameProcNationSelect* m_pProcNationSelectRef;

public:
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUINationSelectDlg();
	~CUINationSelectDlg() override;
};

#endif // !defined(AFX_UINATIONSELECTDLG_H__AC80EE20_C90E_4B08_807A_5431F8F23BF7__INCLUDED_)

// ===== END WarFare/UINationSelectDlg.h =====

// ===== BEGIN WarFare/UINotice.cpp =====
#line 1 "WarFare/UINotice.cpp"
﻿// UINotice.cpp: implementation of the CUINotice class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UINotice.h"
#include "GameProcedure.h"
#include "UIManager.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UIScrollBar.h>
#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUINotice::CUINotice()
{
	m_pText_Notice = nullptr;
	m_pScrollBar = nullptr;
	m_pBtn_OK = nullptr;
}

CUINotice::~CUINotice()
{
	m_Texts.clear();
}

void CUINotice::Release()
{
	m_Texts.clear();
	CN3UIBase::Release();
}

bool CUINotice::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	m_pText_Notice = GetChildByID<CN3UIString>("Text_Notice");
	m_pScrollBar = GetChildByID<CN3UIScrollBar>("ScrollBar");
	m_pBtn_OK = GetChildByID<CN3UIButton>("Btn_Quit");

	if(m_pScrollBar) 
	{
		m_pScrollBar->SetRange(0, 100);
	}

	return true;
}

bool CUINotice::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	//s_CameraData.vp;  //불러 오는 과정을 살펴본다 
	//uint32_t mm = s_CameraData.vp.Height;
	//uint32_t ss = s_CameraData.vp.Width;	

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if(pSender == m_pBtn_OK)
		{
			if(m_pText_Notice) m_pText_Notice->SetString("");
			SetVisible(false);
		}
	}
	else if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		if(pSender == m_pScrollBar)
		{
			// 스크롤바에 맞는 채팅 Line 설정
			// int iCurLinePos = m_pScrollBar->GetCurrentPos();
		}
	}

	return true;
}

void CUINotice::GenerateText()
{
	if (m_pText_Notice == nullptr)
		return;

	// 글자수를 센다..
	size_t textLength = 0;
	auto it = m_Texts.begin(), itEnd = m_Texts.end();
	for (; it != itEnd; it++)
		textLength += it->size() + 3; // LineFeed, Carriage return

	if (textLength == 0)
		return;

	std::string szBuff;
	szBuff.reserve(textLength * 2);

	// 글자들을 붙이고  // LineFeed, Carriage return 을 붙인다.
	it = m_Texts.begin(); itEnd = m_Texts.end();
	for (; it != itEnd; it++)
	{
		szBuff += *it;
		szBuff += "\n";
	}

	m_pText_Notice->SetString(szBuff); // 글자 적용..
}

bool CUINotice::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
	case DIK_RETURN:
		ReceiveMessage(m_pBtn_OK, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUINotice::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CUINotice::RemoveNotice()
{
	m_Texts.clear();
}

// ===== END WarFare/UINotice.cpp =====

// ===== BEGIN WarFare/UINotice.h =====
#line 1 "WarFare/UINotice.h"
﻿// UINotice.h: interface for the CUINotice class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UINOTICE_H__28178F32_B0C2_4742_B3C0_25C8F6034BD2__INCLUDED_)
#define AFX_UINOTICE_H__28178F32_B0C2_4742_B3C0_25C8F6034BD2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>
#include <list>
#include <string>

typedef std::list<std::string>::iterator it_String;

class CUINotice : public CN3UIBase
{
public:
	class CN3UIString*		m_pText_Notice;
	class CN3UIScrollBar*	m_pScrollBar;
	class CN3UIButton*		m_pBtn_OK;

	std::list<std::string>	m_Texts;

public:
	void RemoveNotice();
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	void GenerateText();
	void Release() override;

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUINotice();
	~CUINotice() override;
};

#endif // !defined(AFX_UINOTICE_H__28178F32_B0C2_4742_B3C0_25C8F6034BD2__INCLUDED_)

// ===== END WarFare/UINotice.h =====

// ===== BEGIN WarFare/UIPartyBBS.cpp =====
#line 1 "WarFare/UIPartyBBS.cpp"
﻿// UIPartyBBS.cpp: implementation of the CUIPartyBBS class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIPartyBBS.h"
#include "GameProcMain.h"
#include "UIVarious.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "APISocket.h"
#include "text_resources.h"

#include <N3Base/N3UIList.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define PARTY_BBS_MAXSTRING	69
#define PARTY_BBS_MAXLINE	23
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIPartyBBS::CUIPartyBBS()
{
//	m_pList_Infos			= nullptr;		
	m_pBtn_PageUp			= nullptr;
	m_pBtn_PageDown			= nullptr;
	m_pBtn_Refresh			= nullptr;
	
	m_pBtn_Close			= nullptr;
	m_pBtn_Register			= nullptr;
	m_pBtn_RegisterCancel	= nullptr;
	m_pBtn_Whisper			= nullptr;
	m_pBtn_Party			= nullptr;
	m_pText_Page			= nullptr;

	m_iCurPage				= 0;
	m_bProcessing			= false;
	m_fTime					= 0.0f;
	m_iCurIndex				= -1;

	for(int i = 0 ; i < PARTY_BBS_MAXSTRING ; i++)
	{
		m_pText[i] = nullptr;
	}

}

CUIPartyBBS::~CUIPartyBBS()
{
}

bool CUIPartyBBS::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	// NOTE: This entire UI is outdated. It no longer remotely resembles the original UI.
#if 0
	N3_VERIFY_UI_COMPONENT(m_pBtn_PageUp,			GetChildByID<CN3UIButton>("btn_page_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_PageDown,			GetChildByID<CN3UIButton>("btn_page_down"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Refresh,			GetChildByID<CN3UIButton>("btn_refresh"));
	
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close,			GetChildByID<CN3UIButton>("btn_exit"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Register,			GetChildByID<CN3UIButton>("btn_add"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_RegisterCancel,	GetChildByID<CN3UIButton>("btn_delete"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Whisper,			GetChildByID<CN3UIButton>("btn_whisper"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Party,			GetChildByID<CN3UIButton>("btn_Party"));

	N3_VERIFY_UI_COMPONENT(m_pText_Page,			GetChildByID<CN3UIString>("string_page"));

	std::string szID;
	for (int i = 0; i < PARTY_BBS_MAXSTRING; i++)
	{
		szID = fmt::format("text_{:02}", i);
		N3_VERIFY_UI_COMPONENT(m_pText[i],			GetChildByID<CN3UIString>(szID));
	}
#endif

	m_iCurPage = 0; // 현재 페이지..

	return true;
}

bool CUIPartyBBS::SelectedString(CN3UIBase* pSender, int& iID)
{
	int iIndex = -1;
	for(int i = 0; i < PARTY_BBS_MAXSTRING ; i++)
	{
		if(pSender == m_pText[i])
		{
			iIndex = i % PARTY_BBS_MAXLINE;
			if (iIndex >= static_cast<int>(m_Datas.size()))
				return false;

			iID = iIndex;
//			SetStringColor( iID, 0xffff0000);
			return true;
		}
	}

	return false;
}

bool CUIPartyBBS::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	int iID = -1;
	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		if(pSender == m_pBtn_Refresh)
		{
			this->MsgSend_RefreshData(m_iCurPage);
		}
		else if(pSender == m_pBtn_PageUp)
		{
			int iCurPage = m_iCurPage;
			iCurPage--;
			if(iCurPage >= 0)
			{
				this->MsgSend_RefreshData(iCurPage);
			}
		}
		else if(pSender == m_pBtn_PageDown)
		{
			int iCurPage = m_iCurPage;
			iCurPage++;
			if(iCurPage < m_iMaxPage)
			{
				this->MsgSend_RefreshData(iCurPage);
			}
		}
		else if(pSender == m_pBtn_Close)
		{
			m_iCurPage = 0;
			m_fTime = 0.0f;
			this->SetVisible(false);
		}
		else if(pSender == m_pBtn_Register)
		{
			std::string szMsg = fmt::format_text_resource(IDS_PARTY_BBS_REGISTER);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_PARTY_BBS_REGISTER); // 기사단 해체 물어보기..
		}
		else if(pSender == m_pBtn_RegisterCancel)
		{
			std::string szMsg = fmt::format_text_resource(IDS_PARTY_BBS_REGISTER_CANCEL);
			CGameProcedure::MessageBoxPost(szMsg, "", MB_YESNO, BEHAVIOR_PARTY_BBS_REGISTER_CANCEL); // 기사단 해체 물어보기..
		}
		else if(pSender == m_pBtn_Whisper)
		{
			RequestWhisper();
		}
		else if(pSender == m_pBtn_Party) // 파티 신청
		{
			RequestParty();
		}
	}
	else if( dwMsg == UIMSG_STRING_LCLICK )
	{
		if(SelectedString(pSender, iID))
		{
			m_iCurIndex = iID;
		}
	}

	return true;
}

void CUIPartyBBS::MsgSend_RefreshData(int iCurPage)
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	float fTime = CN3Base::TimeGet();
	if( fTime - m_fTime < 3.0f )
		return;
	m_fTime = fTime;

	uint8_t byBuff[4];
	int iOffset=0;

	int16_t sPage = m_iCurPage;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY_BBS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_BBS_DATA);
	CAPISocket::MP_AddShort(byBuff, iOffset, sPage);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
}

void CUIPartyBBS::MsgRecv_RefreshData(Packet& pkt)
{
	m_bProcessing = false;

	uint8_t byType = pkt.read<uint8_t>();
	uint8_t byResult = pkt.read<uint8_t>();
	if(byResult != 0x01) return; //실패했다면

	switch( byType )
	{
	case N3_SP_PARTY_REGISTER:
		{
			if(!IsVisible())
				SetVisible(true);
		}
	case N3_SP_PARTY_REGISTER_CANCEL:
		{
			PartyStringSet(byType);
			if(!IsVisible()) return;
		}
		break;
	case N3_SP_PARTY_BBS_DATA:
		{
			if(!IsVisible())
				SetVisible(true);
		}
		break;
	}

	m_Datas.clear();

	for( int i = 0 ; i < PARTY_BBS_MAXLINE ; i++ )
	{
		__InfoPartyBBS Info;
		int iNameLen	= pkt.read<int16_t>();
		pkt.readString(Info.szID, iNameLen);
		Info.iLevel		= pkt.read<uint8_t>();
		Info.eClass		= (e_Class)pkt.read<int16_t>();

		if( iNameLen > 0 )
			m_Datas.push_back(Info);
	}

	int16_t sPage = pkt.read<int16_t>();
	int16_t sTotal = pkt.read<int16_t>();

	m_iCurPage = sPage;
	m_iMaxPage = sTotal / PARTY_BBS_MAXLINE;
	if( (sTotal % PARTY_BBS_MAXLINE) > 0 )
		m_iMaxPage++;

	RefreshPage();
}


void CUIPartyBBS::MsgSend_Register()
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	uint8_t byBuff[4];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY_BBS);	
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_REGISTER);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
}

void CUIPartyBBS::MsgSend_RegisterCancel()
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	uint8_t byBuff[4];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_PARTY_BBS);	
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PARTY_REGISTER_CANCEL);	
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
}


void CUIPartyBBS::RefreshPage()
{
	if(m_pText_Page) m_pText_Page->SetStringAsInt(m_iCurPage+1); // 페이지 표시..

	ResetContent();

	it_PartyBBS it = m_Datas.begin();

	std::string szDuty, szClass;
	for( int i = 0 ; i < PARTY_BBS_MAXLINE ; i++ )
	{
		if(it==m_Datas.end()) return;

		__InfoPartyBBS IPB = (*it);
		CGameBase::GetTextByClass(IPB.eClass, szClass);
		SetContentString(i, IPB.szID.c_str(), IPB.iLevel, szClass.c_str());
		it++;
	}
}

void CUIPartyBBS::PartyStringSet(uint8_t byType)
{
	switch(byType)
	{
	case N3_SP_PARTY_REGISTER:
		CGameBase::s_pPlayer->m_bRecruitParty = true;
		break;
	case N3_SP_PARTY_REGISTER_CANCEL:
		CGameBase::s_pPlayer->m_bRecruitParty = false;
		break;
	}

	if (CGameBase::s_pPlayer->m_bRecruitParty)
	{
		int iLevel = CGameBase::s_pPlayer->m_InfoBase.iLevel;
		int iLMin = iLevel - 8;
		if(iLMin < 0) iLMin = 0;
		int iLMax = iLevel + 8;
		if(iLMax > 80) iLMax = 80;

		std::string szMsg = fmt::format_text_resource(IDS_WANT_PARTY_MEMBER, iLMin, iLMax);
		CGameBase::s_pPlayer->InfoStringSet(szMsg, 0xff00ff00);
		CGameProcedure::s_pProcMain->MsgSend_StateChange(N3_SP_STATE_CHANGE_RECRUIT_PARTY, 0x02); // 파티 요청.. 취소
	}
	else
	{
		CGameBase::s_pPlayer->InfoStringSet("", 0);
		CGameProcedure::s_pProcMain->MsgSend_StateChange(N3_SP_STATE_CHANGE_RECRUIT_PARTY, 0x01); // 파티 요청..
	}
}

void CUIPartyBBS::ResetContent()
{
	if(m_Datas.size()>0)
		m_iCurIndex = 0;
	else
		m_iCurIndex = -1;

	for(int i = 0 ; i < PARTY_BBS_MAXSTRING ; i++)
	{
		if(m_pText[i])
		{
			m_pText[i]->SetString("");
			m_pText[i]->SetColor(0xffffffff);
		}
	}
}

void CUIPartyBBS::SetContentString(int iIndex, std::string szID, int iLevel, std::string szClass)
{
	if (m_pText[iIndex] != nullptr)
		m_pText[iIndex]->SetString(szID);

	if (m_pText[iIndex + PARTY_BBS_MAXLINE] != nullptr)
		m_pText[iIndex + PARTY_BBS_MAXLINE]->SetStringAsInt(iLevel);

	if (m_pText[iIndex + PARTY_BBS_MAXLINE * 2] != nullptr)
		m_pText[iIndex + PARTY_BBS_MAXLINE * 2]->SetString(szClass);
}

void CUIPartyBBS::Render()
{
	if(!IsVisible()) return;

	CN3UIBase::Render();
	RenderSelectContent();
}

void CUIPartyBBS::RenderSelectContent()
{
	if(!IsVisible())	return;
	if(m_iCurIndex < 0)	return;
	if(m_iCurIndex >= PARTY_BBS_MAXLINE) return;

	RECT rc, rc1;
	if(m_pText[m_iCurIndex])
	{
		rc = m_pText[m_iCurIndex]->GetRegion();
		if(m_pText[m_iCurIndex + PARTY_BBS_MAXLINE*2])
		{
			rc1 = m_pText[m_iCurIndex + PARTY_BBS_MAXLINE*2]->GetRegion();
			rc.right = rc1.right;
		}
	}
	else
		return;

	__VertexTransformedColor vLines[5];
	vLines[0].Set((float)rc.left, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[1].Set((float)rc.right, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[2].Set((float)rc.right, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[3].Set((float)rc.left, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[4] = vLines[0];

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, vLines, sizeof(__VertexTransformedColor));
	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

void CUIPartyBBS::SetStringColor(int iIndex, uint32_t dwColor)
{
	if(m_pText[iIndex])
		m_pText[iIndex]->SetColor(dwColor);

	if(m_pText[iIndex + PARTY_BBS_MAXLINE])
		m_pText[iIndex + PARTY_BBS_MAXLINE]->SetColor(dwColor);

	if(m_pText[iIndex + PARTY_BBS_MAXLINE*2])
		m_pText[iIndex + PARTY_BBS_MAXLINE*2]->SetColor(dwColor);
}

void CUIPartyBBS::RequestWhisper()
{
	if(m_iCurIndex <= -1)
		return;

	it_PartyBBS it = m_Datas.begin();

	for( int i = 0 ; i < PARTY_BBS_MAXLINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoPartyBBS IPB = (*it);
			//나 자신에게는 귓속말을 못하게 한다...
			if (lstrcmpi(IPB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) != 0)
				CGameProcedure::s_pProcMain->MsgSend_ChatSelectTarget(IPB.szID);
			break;
		}
	}
}

void CUIPartyBBS::RequestParty()
{
	if(m_iCurIndex <= -1)
		return;

	it_PartyBBS it = m_Datas.begin();

	for( int i = 0 ; i < PARTY_BBS_MAXLINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoPartyBBS IPB = (*it);

			// 나 자신에게는 파티 신청을 못하게 한다...
			if (lstrcmpi(IPB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) != 0)
			{
				std::string szMsg;
				if (CGameProcedure::s_pProcMain->MsgSend_PartyOrForceCreate(0, IPB.szID))
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE); // 파티
				else
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE_FAILED); // 파티 초대 실패
				CGameProcedure::s_pProcMain->MsgOutput(IPB.szID + szMsg, 0xffffff00);
				break;
			}
		}
	}
}

void CUIPartyBBS::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

bool CUIPartyBBS::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		SetVisible(false);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIPartyBBS.cpp =====

// ===== BEGIN WarFare/UIPartyBBS.h =====
#line 1 "WarFare/UIPartyBBS.h"
﻿// UIPartyBBS.h: interface for the CUIPartyBBS class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPartyBBS_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_)
#define AFX_UIPartyBBS_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <list>

#include <N3Base/N3UIBase.h>
#include "GameDef.h" // __InfoPartyBBS

typedef std::list<__InfoPartyBBS>::iterator it_PartyBBS;

class CUIPartyBBS : public CN3UIBase // 파티에 관한 UI, 부대와 같은 클래스로 쓴다..
{
protected:
	class CN3UIButton*		m_pBtn_PageUp;
	class CN3UIButton*		m_pBtn_PageDown;
	class CN3UIButton*		m_pBtn_Refresh;
	
	class CN3UIButton*		m_pBtn_Close;
	class CN3UIButton*		m_pBtn_Register;
	class CN3UIButton*		m_pBtn_RegisterCancel;
	class CN3UIButton*		m_pBtn_Whisper;
	class CN3UIButton*		m_pBtn_Party;

	class CN3UIString*		m_pText_Page;
	class CN3UIString*		m_pText[69];

	std::list<__InfoPartyBBS>	m_Datas; // BBS Data
	int			m_iCurPage; // 현재 페이지..
	int			m_iMaxPage;	// 총 페이지..
	int			m_iCurIndex;
	bool		m_bProcessing;
	float		m_fTime;

public:
	bool OnKeyPress(int iKey) override;
	void SetVisible(bool bVisible) override;
	void RequestParty();
	void RequestWhisper();
	void SetStringColor(int iIndex, uint32_t dwColor);
	void RenderSelectContent();
	void Render() override;
	void SetContentString(int iIndex, std::string szID, int iLevel, std::string szClass);
	void ResetContent();
	void MsgSend_Register();
	void MsgSend_RegisterCancel();
	void MsgSend_RefreshData(int iCurPage);

	void MsgRecv_RefreshData(Packet& pkt);

	void PartyStringSet(uint8_t byType);
	void RefreshPage();
	bool Load(File& file) override;
	bool ReceiveMessage(class CN3UIBase* pSender, uint32_t dwMsg) override;
	bool SelectedString(CN3UIBase* pSender, int& iID);
	
	CUIPartyBBS();
	~CUIPartyBBS() override;
};

#endif // !defined(AFX_UIPartyBBS_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_)

// ===== END WarFare/UIPartyBBS.h =====

// ===== BEGIN WarFare/UIPartyBBSSelector.cpp =====
#line 1 "WarFare/UIPartyBBSSelector.cpp"
﻿// UIPartyBBSSelector.cpp: implementation of the CUIPartyBBSSelector class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIPartyBBSSelector.h"
#include "GameProcedure.h"
#include "PacketDef.h"
#include "APISocket.h"

#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIPartyBBSSelector::CUIPartyBBSSelector()
{
	m_pBtn_WantPartyMember	= nullptr;
	m_pBtn_WantParty		= nullptr;
}

CUIPartyBBSSelector::~CUIPartyBBSSelector()
{

}

bool CUIPartyBBSSelector::ReceiveMessage(CN3UIBase *pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "Btn_WantParty")	
		{
			if(m_pBtn_WantParty && m_pBtn_WantParty->IsVisible())
			{
				MsgSend_PartyBBSKind(WANT_PARTY);
			}
			SetVisible(false);
			return true;
		}

		if(pSender->m_szID == "Btn_WantPartyMember")
		{
			if(m_pBtn_WantPartyMember && m_pBtn_WantPartyMember->IsVisible())
			{
				MsgSend_PartyBBSKind(WANT_PARTY_MEMBER);
			}
			SetVisible(false);
			return true;
		}

		if(pSender->m_szID == "Btn_Cancel")	
		{
			SetVisible(false);
			return true;
		}
	}
	return true;
}

bool CUIPartyBBSSelector::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_WantPartyMember, GetChildByID<CN3UIButton>("Btn_WantParty"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_WantParty, GetChildByID<CN3UIButton>("Btn_WantPartyMember"));

	return true;
}

void CUIPartyBBSSelector::MsgSend_PartyBBSKind(uint8_t byKind)
{
	uint8_t byBuff[4];											
	int iOffset=0;											

	CAPISocket::MP_AddByte(byBuff, iOffset, 1);		// 패킷도 정해야 할듯
	CAPISocket::MP_AddByte(byBuff, iOffset, byKind);		// 파티구함인지 파티원 구함인지...
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);		// 패킷을 보냄..
}

// ===== END WarFare/UIPartyBBSSelector.cpp =====

// ===== BEGIN WarFare/UIPartyBBSSelector.h =====
#line 1 "WarFare/UIPartyBBSSelector.h"
﻿// UIPartyBBSSelector.h: interface for the CUIPartyBBSSelector class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPARTYBBSSELECTOR_H__CF79ECBE_7FBE_4251_A740_E6AD08881785__INCLUDED_)
#define AFX_UIPARTYBBSSELECTOR_H__CF79ECBE_7FBE_4251_A740_E6AD08881785__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#define WANT_PARTY			0
#define WANT_PARTY_MEMBER	1

class CUIPartyBBSSelector : public CN3UIBase
{
protected:
	CN3UIButton*	m_pBtn_WantPartyMember;
	CN3UIButton*	m_pBtn_WantParty;

public:
	void MsgSend_PartyBBSKind(uint8_t byKind);
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUIPartyBBSSelector();
	~CUIPartyBBSSelector() override;

};

#endif // !defined(AFX_UIPARTYBBSSELECTOR_H__CF79ECBE_7FBE_4251_A740_E6AD08881785__INCLUDED_)

// ===== END WarFare/UIPartyBBSSelector.h =====

// ===== BEGIN WarFare/UIPartyOrForce.cpp =====
#line 1 "WarFare/UIPartyOrForce.cpp"
﻿// UIPartyOrForce.cpp: implementation of the CUIPartyOrForce class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIPartyOrForce.h"
#include "UIManager.h"
#include "GameProcMain.h"
#include "PlayerOtherMgr.h"

#include <N3Base/N3UIArea.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIProgress.h>
#include <N3Base/N3UIStatic.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIPartyOrForce::CUIPartyOrForce()
{
	for (int i = 0; i < MAX_PARTY_OR_FORCE; i++)
	{
		m_pProgress_HPs[i]			= nullptr;	// 부대원갯수 만큼... HP Gauge
		m_pProgress_HPReduce[i]		= nullptr;	// 부대원갯수 만큼... HP Reduce
		m_pProgress_HPSlow[i]		= nullptr;	// HP Slow
		m_pProgress_HPLasting[i]	= nullptr;	// HP Lasting
		m_pProgress_MP[i]			= nullptr;	// MP Bar
		m_pStatic_IDs[i]			= nullptr;	// Names for each party member
		m_pAreas[i]					= nullptr;
	}

	m_iIndexSelected = -1; // 현재 선택된 멤버인덱스..
}

CUIPartyOrForce::~CUIPartyOrForce()
{
}

void CUIPartyOrForce::Release()
{
	CN3UIBase::Release();

	m_Members.clear();
	m_iIndexSelected = -1; // 현재 선택된 멤버인덱스..

	for (int i = 0; i < MAX_PARTY_OR_FORCE; i++)
	{
		m_pProgress_HPs[i]			= nullptr;	// 부대원갯수 만큼... HP Gauge
		m_pProgress_HPReduce[i]		= nullptr;	// 부대원갯수 만큼... HP Reduce
		m_pProgress_HPSlow[i]		= nullptr;	// HP Slow
		m_pProgress_HPLasting[i]	= nullptr;	// HP Lasting
		m_pProgress_MP[i]			= nullptr;	// MP Bar
		m_pStatic_IDs[i]			= nullptr;	// Names for each party member
		m_pAreas[i]					= nullptr;
	}

}

bool CUIPartyOrForce::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	std::string szID;
	for (int i = 0; i < MAX_PARTY_OR_FORCE; i++) // 빈곳을 찾자..
	{
		szID = fmt::format("progress_hp_{}", i);
		N3_VERIFY_UI_COMPONENT(m_pProgress_HPs[i],			GetChildByID<CN3UIProgress>(szID));
		if (m_pProgress_HPs[i] != nullptr)
		{
			m_pProgress_HPs[i]->SetVisible(false);
			m_pProgress_HPs[i]->SetRange(0, 100);
		}

		szID = fmt::format("progress_hp_{}_slow", i);
		N3_VERIFY_UI_COMPONENT(m_pProgress_HPSlow[i],		GetChildByID<CN3UIProgress>(szID));
		if (m_pProgress_HPSlow[i] != nullptr)
		{
			m_pProgress_HPSlow[i]->SetVisible(false);
			m_pProgress_HPSlow[i]->SetRange(0, 100);
		}

		szID = fmt::format("progress_hp_{}_drop", i);
		N3_VERIFY_UI_COMPONENT(m_pProgress_HPReduce[i],		GetChildByID<CN3UIProgress>(szID));
		if (m_pProgress_HPReduce[i] != nullptr)
		{
			m_pProgress_HPReduce[i]->SetVisible(false);
			m_pProgress_HPReduce[i]->SetRange(0, 100);
		}

		szID = fmt::format("progress_hp_{}_lasting", i);
		N3_VERIFY_UI_COMPONENT(m_pProgress_HPLasting[i],	GetChildByID<CN3UIProgress>(szID));
		if (m_pProgress_HPLasting[i] != nullptr)
		{
			m_pProgress_HPLasting[i]->SetVisible(false);
			m_pProgress_HPLasting[i]->SetRange(0, 100);
		}

		szID = fmt::format("progress_mp_{}_curse", i); 
		N3_VERIFY_UI_COMPONENT(m_pProgress_MP[i],			GetChildByID<CN3UIProgress>(szID));
		if (m_pProgress_MP[i] != nullptr)
		{
			m_pProgress_MP[i]->SetVisible(false);
			m_pProgress_MP[i]->SetRange(0, 100);
		}

		szID = fmt::format("static_name_{}", i);
		N3_VERIFY_UI_COMPONENT(m_pStatic_IDs[i],			GetChildByID<CN3UIStatic>(szID));
		if (m_pStatic_IDs[i] != nullptr)
			m_pStatic_IDs[i]->SetVisible(false);

		szID = fmt::format("Area_{}", i);
		N3_VERIFY_UI_COMPONENT(m_pAreas[i],					GetChildByID<CN3UIArea>(szID));
	}

	MemberInfoReInit();

	return true;
}

bool CUIPartyOrForce::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		__InfoPartyOrForce* pIP = nullptr;
		auto it = m_Members.begin(), itEnd = m_Members.end();
		for(int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
		{
//			if(m_pStatic_IDs[i] && pSender == m_pStatic_IDs[i])
			if(pSender == m_pAreas[i])
			{
				pIP = &(*it);
				m_iIndexSelected = i; // 현재 선택된 멤버인덱스..
				break;
			}
		}

		if(pIP) CGameProcedure::s_pProcMain->TargetSelect(pIP->iID, true);
		else CGameProcedure::s_pProcMain->TargetSelect(-1, false);
	}

	return true;
}

void CUIPartyOrForce::Render()
{
	if(false == m_bVisible) return;

	CN3UIBase::Render();

	if (m_iIndexSelected < 0
		|| m_iIndexSelected >= static_cast<int>(m_Members.size())
		|| m_iIndexSelected >= MAX_PARTY_OR_FORCE)
		return;

	if(nullptr == m_pStatic_IDs[m_iIndexSelected] || nullptr == m_pProgress_HPs[m_iIndexSelected]) return;

	RECT rc1 = m_pStatic_IDs[m_iIndexSelected]->GetRegion();
	rc1.left -= 2; rc1.top -= 2; rc1.right += 2; rc1.bottom += 2;

	RECT rc2 = m_pProgress_HPs[m_iIndexSelected]->GetRegion();
	rc2.left -= 2; rc2.top -= 2; rc2.right += 2; rc2.bottom += 2;

	RECT rc;
	rc.left = (rc1.left < rc2.left) ? rc1.left : rc2.left;
	rc.top = (rc1.top < rc2.top) ? rc1.top : rc2.top;
	rc.right = (rc1.right > rc2.right) ? rc1.right : rc2.right;
	rc.bottom = (rc1.bottom > rc2.bottom) ? rc1.bottom : rc2.bottom;

	CN3Base::RenderLines(rc, 0xff00ff00); // 선택 표시..
}

bool CUIPartyOrForce::TargetByIndex(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Members.size()))
		return false;

	auto it = m_Members.begin();
	std::advance(it, iIndex);

	__InfoPartyOrForce* pIP = &(*it);
	m_iIndexSelected = iIndex; // 현재 선택된 멤버인덱스..

	if(pIP) CGameProcedure::s_pProcMain->TargetSelect(pIP->iID, true);

	return true;
}

const __InfoPartyOrForce* CUIPartyOrForce::MemberInfoGetByID(int iID, int& iIndexResult)
{
	if(m_Members.empty()) return nullptr;

	auto it = m_Members.begin(), itEnd = m_Members.end();
	iIndexResult = 0;
	for(; it != itEnd; it++, iIndexResult++)
	{
		if(iID == it->iID)
		{
			return &(*it);
		}
	}

	iIndexResult = -1;
	return nullptr;
}

const __InfoPartyOrForce* CUIPartyOrForce::MemberInfoGetByIndex(int iIndex)
{
	if (iIndex < 0
		|| iIndex >= static_cast<int>(m_Members.size()))
		return nullptr;

	auto it = m_Members.begin();
	std::advance(it, iIndex);

	return &(*it);
}

CPlayerOther* CUIPartyOrForce::MemberGetByNearst(const __Vector3& vPosPlayer)
{
	if(m_Members.empty()) return nullptr;

	float fDistMin = FLT_MAX, fDistTmp = 0;
	CPlayerOther* pTarget = nullptr;

	auto it = m_Members.begin(), itEnd = m_Members.end();
	for(; it != itEnd; it++)
	{
		CPlayerOther* pUPC = CGameBase::s_pOPMgr->UPCGetByID(it->iID, false);
		if(nullptr == pUPC) continue;

		fDistTmp = pUPC->Distance(vPosPlayer);
		if(fDistTmp < fDistMin)
		{
			pTarget = pUPC;
			fDistMin = fDistTmp;
		}
	}

	return pTarget;
}

const __InfoPartyOrForce* CUIPartyOrForce::MemberAdd(int iID, const std::string& szID, int iLevel, e_Class eClass, int iHP, int iHPMax, int iMP, int iMPMax)
{
	__InfoPartyOrForce InfoTmp;
	InfoTmp.iID = iID;
	InfoTmp.szID = szID;
	InfoTmp.iLevel = iLevel;
	InfoTmp.iHP = iHP;
	InfoTmp.iHPMax = iHPMax;
	InfoTmp.iMP = iMP;
	InfoTmp.iMPMax = iMPMax;
	InfoTmp.eClass = eClass;

	m_Members.push_back(std::move(InfoTmp));

	auto it = m_Members.end();
	it--;
	
	MemberInfoReInit();

	return &(*it);
}

bool CUIPartyOrForce::MemberRemove(int iID)
{
	if(m_Members.empty()) return false;

	auto it = m_Members.begin(), itEnd = m_Members.end();
	for(; it != itEnd; it++)
	{
		if(iID == it->iID)
		{
			m_Members.erase(it);
			this->MemberInfoReInit();
			return true;
		}
	}

	return false;
}

void CUIPartyOrForce::MemberDestroy()
{
	m_Members.clear();

	// 빈곳을 찾자..
	for (int i = 0; i < MAX_PARTY_OR_FORCE; i++)
	{
		if (m_pProgress_HPs[i] != nullptr)
			m_pProgress_HPs[i]->SetVisible(false);

		if (m_pProgress_HPReduce[i] != nullptr)
			m_pProgress_HPReduce[i]->SetVisible(false);

		if (m_pProgress_MP[i] != nullptr)
			m_pProgress_MP[i]->SetVisible(false);

		if (m_pProgress_HPSlow[i] != nullptr)
			m_pProgress_HPSlow[i]->SetVisible(false);

		if (m_pProgress_HPLasting[i] != nullptr)
			m_pProgress_HPLasting[i]->SetVisible(false);

		if (m_pStatic_IDs[i] != nullptr)
			m_pStatic_IDs[i]->SetVisible(false);
	}

	MemberInfoReInit();
}

void CUIPartyOrForce::MemberInfoReInit() // 파티원 구성이 변경될때.. 순서 및 각종 정보 업데이트..
{
	auto it = m_Members.begin(), itEnd = m_Members.end();
	for (int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		__InfoPartyOrForce* pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if (pIP->iHPMax <= 0)
		{
			__ASSERT(0, "Invalid Party memeber HP");
			continue;
		}

		const int iHPPercent = pIP->iHP * 100 / pIP->iHPMax;

		if (m_pProgress_HPs[i] != nullptr)
			m_pProgress_HPs[i]->SetCurValue(iHPPercent);

		if (m_pProgress_HPReduce[i] != nullptr)
			m_pProgress_HPReduce[i]->SetCurValue(iHPPercent);

		if (m_pProgress_HPSlow[i] != nullptr)
			m_pProgress_HPSlow[i]->SetCurValue(iHPPercent);

		if (m_pProgress_HPLasting[i] != nullptr)
			m_pProgress_HPLasting[i]->SetCurValue(iHPPercent);

		if (m_pProgress_MP[i] != nullptr)
			m_pProgress_MP[i]->SetCurValue(pIP->iMP * 100 / pIP->iMPMax);

		if (m_pStatic_IDs[i] != nullptr)
		{
			m_pStatic_IDs[i]->SetString(pIP->szID);
			m_pStatic_IDs[i]->SetVisible(true);
		}
	}

	if (m_Members.empty())
		SetVisible(false); // 멤버가 없으면 숨긴다.
	else
		SetVisible(true); // 멤버가 있으면 보인다.
}

const __InfoPartyOrForce* CUIPartyOrForce::MemberInfoGetSelected()
{
	if (m_iIndexSelected < 0
		|| m_iIndexSelected >= static_cast<int>(m_Members.size()))
		return nullptr;

	auto it = m_Members.begin();
	std::advance(it, m_iIndexSelected);

	return &(*it);
}

void CUIPartyOrForce::MemberHPChange(int iID, int iHP, int iHPMax, int iMP, int iMPMax)
{
	auto it = m_Members.begin(), itEnd = m_Members.end();
	for (int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		__InfoPartyOrForce* pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if (pIP->iID == iID)
		{
			pIP->iHP = iHP;
			pIP->iHPMax = iHPMax;
			pIP->iMP = iMP;
			pIP->iMPMax = iMPMax;

			const int iHPPercent = pIP->iHP * 100 / pIP->iHPMax;

			if (m_pProgress_HPs[i] != nullptr)
				m_pProgress_HPs[i]->SetCurValue(iHPPercent, 0.7f, 50.0f);

			if (m_pProgress_HPReduce[i] != nullptr)
				m_pProgress_HPReduce[i]->SetCurValue(iHPPercent, 0.7f, 50.0f);

			if (m_pProgress_HPSlow[i] != nullptr)
				m_pProgress_HPSlow[i]->SetCurValue(iHPPercent, 0.7f, 50.0f);

			if (m_pProgress_HPLasting[i] != nullptr)
				m_pProgress_HPLasting[i]->SetCurValue(iHPPercent, 0.7f, 50.0f);

			if (m_pProgress_MP[i] != nullptr)
				m_pProgress_MP[i]->SetCurValue(pIP->iMP * 100 / pIP->iMPMax, 0.7f, 50.0f);
			break;
		}
	}
}

void CUIPartyOrForce::MemberStatusChange(int iID, e_PartyStatus ePS, bool bSuffer)
{
	auto it = m_Members.begin(), itEnd = m_Members.end();
	__InfoPartyOrForce* pIP = nullptr;
	for(int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if(pIP->iID == iID)
		{
			if(PARTY_STATUS_DOWN_HP == ePS)	pIP->bSufferDown_HP = bSuffer;
			else if(PARTY_STATUS_DOWN_ETC == ePS) pIP->bSufferDown_Etc = bSuffer;
			break;
		}
	}
}

void CUIPartyOrForce::MemberLevelChange(int iID, int iLevel)
{
	auto it = m_Members.begin(), itEnd = m_Members.end();
	__InfoPartyOrForce* pIP = nullptr;
	for(int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if(pIP->iID == iID)
		{
			pIP->iLevel = iLevel;
			break;
		}
	}
}

void CUIPartyOrForce::MemberClassChange(int iID, e_Class eClass)
{
	auto it = m_Members.begin(), itEnd = m_Members.end();
	__InfoPartyOrForce* pIP = nullptr;
	for(int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if(pIP->iID == iID)
		{
			pIP->eClass = eClass;
			break;
		}
	}
}

void CUIPartyOrForce::Tick()
{
	CN3UIBase::Tick();

	bool bBlink = false;
	uint32_t dwTime = GetTickCount();

	dwTime = dwTime / 1000;
	dwTime %= 2;

	if (dwTime == 1)
		bBlink = true;

	auto it = m_Members.begin(), itEnd = m_Members.end();
	for (int i = 0; it != itEnd && i < MAX_PARTY_OR_FORCE; it++, i++)
	{
		__InfoPartyOrForce* pIP = &(*it); // 디버깅 하기 쉬우라고 이렇게 했다..
		if (m_pProgress_HPs[i] != nullptr)
		{
			if (pIP->bSufferDown_HP || pIP->bSufferDown_Etc)
				m_pProgress_HPs[i]->SetVisible(false);
			else
				m_pProgress_HPs[i]->SetVisible(true);
		}

		if (pIP->bSufferDown_HP && pIP->bSufferDown_Etc)
		{
			if (bBlink)
			{
				if (m_pProgress_HPReduce[i] != nullptr)
					m_pProgress_HPReduce[i]->SetVisible(true);

				if (m_pProgress_MP[i] != nullptr)
					m_pProgress_MP[i]->SetVisible(false);
			}
			else
			{
				if (m_pProgress_HPReduce[i] != nullptr)
					m_pProgress_HPReduce[i]->SetVisible(false);

				if (m_pProgress_MP[i] != nullptr)
					m_pProgress_MP[i]->SetVisible(true);
			}
		}
		else
		{
			if (m_pProgress_HPReduce[i] != nullptr)
			{
				if (pIP->bSufferDown_HP)
					m_pProgress_HPReduce[i]->SetVisible(true);
				else
					m_pProgress_HPReduce[i]->SetVisible(false);
			}

			if (m_pProgress_MP[i] != nullptr)
			{
				if (pIP->bSufferDown_Etc)
					m_pProgress_MP[i]->SetVisible(true);
				else
					m_pProgress_MP[i]->SetVisible(false);
			}
		}

		if (m_pProgress_MP[i] != nullptr)
			m_pProgress_MP[i]->SetVisible(true);
	}
}

bool CUIPartyOrForce::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if(pFocus && pFocus != this) pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIPartyOrForce.cpp =====

// ===== BEGIN WarFare/UIPartyOrForce.h =====
#line 1 "WarFare/UIPartyOrForce.h"
﻿// UIPartyOrForce.h: interface for the CUIPartyOrForce class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPartyOrForce_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_)
#define AFX_UIPartyOrForce_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <list>

#include "GameDef.h"
#include <N3Base/N3UIBase.h>

class CUIPartyOrForce : public CN3UIBase // 파티에 관한 UI, 부대와 같은 클래스로 쓴다..
{
protected:
	CN3UIProgress*	m_pProgress_HPs[MAX_PARTY_OR_FORCE];		// 부대원갯수 만큼... HP Gauge
	CN3UIProgress*	m_pProgress_HPReduce[MAX_PARTY_OR_FORCE];	// 부대원갯수 만큼... HP Reduce
	CN3UIProgress*	m_pProgress_HPSlow[MAX_PARTY_OR_FORCE];		// HP Slow
	CN3UIProgress*	m_pProgress_HPLasting[MAX_PARTY_OR_FORCE];	// HP Lasting
	CN3UIProgress*	m_pProgress_MP[MAX_PARTY_OR_FORCE];			// MP Bar
	CN3UIStatic*	m_pStatic_IDs[MAX_PARTY_OR_FORCE];			// 부대원갯수 만큼... 이름들..
	CN3UIArea*		m_pAreas[MAX_PARTY_OR_FORCE];				// 부대원갯수 만큼... 이름들..

	std::list<__InfoPartyOrForce>	m_Members; // 파티 멤버
	int			m_iIndexSelected; // 현재 선택된 멤버인덱스..

public:
	int			m_iPartyOrForce; // 파티냐? 부대냐?? 1 이면 파티 2 이면 부대..

public:
	bool OnKeyPress(int iKey) override;
	void Tick() override;
	void		MemberClassChange(int iID, e_Class eClass);
	void		MemberLevelChange(int iID, int iLevel);
	void		MemberHPChange(int iID, int iHP, int iHPMax, int iMP, int iMPMax);
	void		MemberStatusChange(int iID, e_PartyStatus ePS, bool bSuffer);

	void		MemberInfoReInit(); // 파티원 구성이 변경될때.. 순서 및 각종 정보 업데이트..
	bool		TargetByIndex(int iIndex); // 순서대로 타겟 잡기..

	int MemberCount() const
	{
		return static_cast<int>(m_Members.size());
	}

	const __InfoPartyOrForce*	MemberInfoGetByID(int iID, int& iIndexResult);
	const __InfoPartyOrForce*	MemberInfoGetByIndex(int iIndex);
	const __InfoPartyOrForce*	MemberInfoGetSelected(); // 현재 선택된 멤버인덱스..
	const __InfoPartyOrForce*	MemberAdd(int iID, const std::string& szID, int iLevel, e_Class eClass, int iHP, int iHPMax, int iMP, int iMPMax);
	class CPlayerOther*			MemberGetByNearst(const __Vector3& vPosPlayer);
	bool						MemberRemove(int iID);
	void						MemberDestroy();

	void MemberSelect(int iMemberIndex)
	{
		if (iMemberIndex < 0
			|| iMemberIndex >= static_cast<int>(m_Members.size()))
			return;

		m_iIndexSelected = iMemberIndex;
	}

	bool Load(File& file) override;
	bool ReceiveMessage(class CN3UIBase* pSender, uint32_t dwMsg) override;
	void Render() override;
	
	void Release() override;
	CUIPartyOrForce();
	~CUIPartyOrForce() override;
};

#endif // !defined(AFX_UIPartyOrForce_H__7B2732B7_C9CA_46A3_89BC_C59934ED3F13__INCLUDED_)

// ===== END WarFare/UIPartyOrForce.h =====

// ===== BEGIN WarFare/UIPerTradeDlg.cpp =====
#line 1 "WarFare/UIPerTradeDlg.cpp"
﻿// UIPerTradeDlg.cpp: implementation of the CUIPerTradeDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIPerTradeDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "PlayerMyself.h"
#include "N3UIWndBase.h"
#include "UIImageTooltipDlg.h"
#include "UIInventory.h"
#include "SubProcPerTrade.h"
#include "CountableItemEditDlg.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIPerTradeDlg::CUIPerTradeDlg()
{
	m_pSubProcPerTrade = nullptr;
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )	m_pPerTradeMy[i] = nullptr;
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )	m_pPerTradeOther[i] = nullptr;
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )	m_iBackupiOrder[i] = -1;
	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )	m_pPerTradeInv[i] = nullptr;

	m_iBackupiCount = 0;
	m_pUITooltipDlg = nullptr;
	m_pStrMyGold    = nullptr;

	this->SetVisible(false);
}

CUIPerTradeDlg::~CUIPerTradeDlg()
{
	Release();
}

///////////////////////////////////////////////////////////////////////

void CUIPerTradeDlg::Release()
{
	CN3UIBase::Release();

	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( m_pPerTradeMy[i] != nullptr )
		{
			delete m_pPerTradeMy[i];
			m_pPerTradeMy[i] = nullptr;
		}
	}

	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( m_pPerTradeOther[i] != nullptr )
		{
			delete m_pPerTradeOther[i];
			m_pPerTradeOther[i] = nullptr;
		}
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pPerTradeInv[i] != nullptr )
		{
			delete m_pPerTradeInv[i];
			m_pPerTradeInv[i] = nullptr;
		}
	}
}

void CUIPerTradeDlg::Render()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	m_pUITooltipDlg->DisplayTooltipsDisable();

	bool bTooltipRender = false;
	__IconItemSkill* spItem = nullptr;

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( (GetState() == UI_STATE_ICON_MOVING) && (pChild->UIType() == UI_TYPE_ICON) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) &&
			((CN3UIIcon *)pChild == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon) )	continue;
			pChild->Render();
		if ( (GetState() == UI_STATE_COMMON_NONE) && 
				(pChild->UIType() == UI_TYPE_ICON) && (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT) )
		{
			bTooltipRender = true;
			spItem = GetHighlightIconItem( (CN3UIIcon* )pChild );
		}
	}

	// 갯수 표시되야 할 아이템 갯수 표시..
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( m_pPerTradeMy[i] && ( (m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || (m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) ) )
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
			{
				pStr->SetVisible(true);
				pStr->SetStringAsInt(m_pPerTradeMy[i]->iCount);
				pStr->Render();
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
				pStr->SetVisible(false);
		}
	}

	// 갯수 표시되야 할 아이템 갯수 표시..
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( m_pPerTradeOther[i] && ( (m_pPerTradeOther[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || (m_pPerTradeOther[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) ) )
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i+100);
			if(pStr) 
			{
				pStr->SetVisible(true);
				pStr->SetStringAsInt(m_pPerTradeOther[i]->iCount);
				pStr->Render();
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i+100);
			if(pStr) 
				pStr->SetVisible(false);
		}
	}

	// 갯수 표시되야 할 아이템 갯수 표시..
	for(int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pPerTradeInv[i] && ( (m_pPerTradeInv[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || (m_pPerTradeInv[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) ) )
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i+200);
			if(pStr) 
			{
				if ( (GetState() == UI_STATE_ICON_MOVING) && (m_pPerTradeInv[i] == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				{
					pStr->SetVisible(false);
				}
				else
				{
					if ( m_pPerTradeInv[i]->pUIIcon->IsVisible() )
					{
						pStr->SetVisible(true);
						pStr->SetStringAsInt(m_pPerTradeInv[i]->iCount);
						pStr->Render();
					}
					else
					{
						pStr->SetVisible(false);
					}
				}
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i+200);
			if(pStr) 
				pStr->SetVisible(false);
		}
	}

	if ( (GetState() == UI_STATE_ICON_MOVING) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->Render();		

	if ( bTooltipRender && spItem )
		m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem );
}


///////////////////////////////////////////////////////////////////////

void CUIPerTradeDlg::InitIconWnd(e_UIWND eWnd)
{
	__TABLE_UI_RESRC* pTblUI = CGameBase::s_pTbl_UI.Find(CGameBase::s_pPlayer->m_InfoBase.eNation);

	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(pTblUI->szItemInfo);
	m_pUITooltipDlg->InitPos();
	m_pUITooltipDlg->SetVisible(FALSE);	

	CN3UIWndBase::InitIconWnd(eWnd);

	// 내 결정 버튼 보통 상태로..
	std::string szFN = "btn_trade_my";
	CN3UIButton* pButton;
	pButton = (CN3UIButton* )GetChildButtonByName(szFN);
	if(pButton) pButton->SetState(UI_STATE_BUTTON_NORMAL);

	N3_VERIFY_UI_COMPONENT(m_pStrMyGold, GetChildByID<CN3UIString>("string_money_inv"));
	if(m_pStrMyGold)
		m_pStrMyGold->SetString("0");
}

void CUIPerTradeDlg::InitIconUpdate()
{
}

__IconItemSkill* CUIPerTradeDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( (m_pPerTradeMy[i] != nullptr) && (m_pPerTradeMy[i]->pUIIcon == pUIIcon) )
			return m_pPerTradeMy[i];
	}

	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if ( (m_pPerTradeOther[i] != nullptr) && (m_pPerTradeOther[i]->pUIIcon == pUIIcon) )
			return m_pPerTradeOther[i];
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( (m_pPerTradeInv[i] != nullptr) && (m_pPerTradeInv[i]->pUIIcon == pUIIcon) ) 
			return m_pPerTradeInv[i];
	}

	return nullptr;
}

void CUIPerTradeDlg::LeavePerTradeState()
{
	// 변수 클리어..
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )	m_iBackupiOrder[i] = -1;
	// 내 결정 버튼 보통 상태로..
	std::string szFN = "btn_trade_my";
	CN3UIButton* pButton;
	pButton = (CN3UIButton* )GetChildButtonByName(szFN);
	if(pButton) pButton->SetState(UI_STATE_BUTTON_NORMAL);

	ItemMoveFromThisToInv();

	if (GetState() == UI_STATE_ICON_MOVING)
		IconRestore();
	SetState(UI_STATE_COMMON_NONE);
	CN3UIWndBase::AllHighLightIconFree();
}

void CUIPerTradeDlg::EnterPerTradeState()
{
	// 변수 초기화..
	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )	m_iBackupiOrder[i] = -1;

	// 내 결정 버튼 보통 상태로..
	std::string szFN = "btn_trade_my";
	CN3UIButton* pButton;
	pButton = (CN3UIButton* )GetChildButtonByName(szFN);
	if(pButton) pButton->SetState(UI_STATE_BUTTON_NORMAL);

	for( int i = 0; i < MAX_ITEM_TRADE; i++ )
	{
		if ( m_pPerTradeMy[i] != nullptr )
		{
			if ( m_pPerTradeMy[i]->pUIIcon )
			{
				RemoveChild(m_pPerTradeMy[i]->pUIIcon);
				m_pPerTradeMy[i]->pUIIcon->Release();
				delete m_pPerTradeMy[i]->pUIIcon;
				m_pPerTradeMy[i]->pUIIcon = nullptr;
			}
			delete m_pPerTradeMy[i];	
			m_pPerTradeMy[i] = nullptr;
		}
	}

	for( int i = 0; i < MAX_ITEM_TRADE; i++ )
	{
		if ( m_pPerTradeOther[i] != nullptr )
		{
			if ( m_pPerTradeOther[i]->pUIIcon )
			{
				RemoveChild(m_pPerTradeOther[i]->pUIIcon);
				m_pPerTradeOther[i]->pUIIcon->Release();
				delete m_pPerTradeOther[i]->pUIIcon;
				m_pPerTradeOther[i]->pUIIcon = nullptr;
			}
			delete m_pPerTradeOther[i];	
			m_pPerTradeOther[i] = nullptr;
		}
	}

	for( int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pPerTradeInv[i] != nullptr )
		{
			if ( m_pPerTradeInv[i]->pUIIcon )
			{
				RemoveChild(m_pPerTradeInv[i]->pUIIcon);
				m_pPerTradeInv[i]->pUIIcon->Release();
				delete m_pPerTradeInv[i]->pUIIcon;
				m_pPerTradeInv[i]->pUIIcon = nullptr;
			}
			delete m_pPerTradeInv[i];	
			m_pPerTradeInv[i] = nullptr;
		}
	}

	ItemMoveFromInvToThis();
	GoldUpdate();
}

void CUIPerTradeDlg::GoldUpdate()
{
	if (m_pStrMyGold != nullptr)
		m_pStrMyGold->SetStringAsInt(CGameBase::s_pPlayer->m_InfoExt.iGold);
}

void CUIPerTradeDlg::ItemMoveFromInvToThis()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if(!pInven) return;

	int i;
	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if(pInven->m_pMyInvWnd[i])
		{
			__IconItemSkill* spItem = pInven->m_pMyInvWnd[i];
			spItem->pUIIcon->SetParent(this);

			pInven->m_pMyInvWnd[i] = nullptr;
			CN3UIArea* pArea;

			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, i);
			if ( pArea )
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}			

			m_pPerTradeInv[i] = spItem;
		}
	}
}

void CUIPerTradeDlg::ItemMoveFromThisToInv()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if(!pInven) return;

	int i;
	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if(m_pPerTradeInv[i])
		{
			__IconItemSkill* spItem = m_pPerTradeInv[i];
			spItem->pUIIcon->SetParent(pInven);

			m_pPerTradeInv[i] = nullptr;

			CN3UIArea* pArea;

			pArea = pInven->GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
			if ( pArea )
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}			

			pInven->m_pMyInvWnd[i] = spItem;
		}
	}
}

void CUIPerTradeDlg::ItemCountOK()
{
	int iGold = CN3UIWndBase::s_pCountableItemEdit->GetQuantity();

	__IconItemSkill* spItem, *spItemNew = nullptr;
	spItem = m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

	if ( iGold <= 0 ) return;
	if ( iGold > spItem->iCount ) return;

	s_bWaitFromServer = true;
	m_iBackupiCount = iGold;	// 전에 옮긴 화살등의 갯수..
	int iOffset = spItem->iCount - iGold;

	// Sound..
	if (spItem) PlayItemSound(spItem->pItemBasic);

	if ( iOffset > 0 )
	{	
		// 숫자 업데이트..
		spItem->iCount = iOffset;

		// 해당 위치에 아이콘이 존재 한다면..
		if ( m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] )
		{
			m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount += iGold;
		}
	}
	else
	{
		// 해당 위치에 아이콘이 존재 한다면..
		if ( m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] )
		{
			m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount += iGold;
		}

		// 인벤토리의 아이콘을 삭제한다..
		__IconItemSkill* spItem;
		spItem = m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

		// 인벤토리에서도 지운다..
		m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

		// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
		RemoveChild(spItem->pUIIcon);

		// 아이콘 리소스 삭제...
		spItem->pUIIcon->Release();
		delete spItem->pUIIcon;
		spItem->pUIIcon = nullptr;
		delete spItem;
		spItem = nullptr;
	}

	// Server에게 보낸다..	
	SendToServerItemAddMsg(CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, 
		m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pItemBasic->dwID+
		m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->pItemExt->dwID, iGold);
	CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget		= nullptr;

	CN3UIWndBase::s_pCountableItemEdit->Close();
}

void CUIPerTradeDlg::ItemCountCancel()
{
	// Sound..
	if (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource) PlayItemSound(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic);

	for( int i = 0; i < MAX_ITEM_PER_TRADE; i++ )
	{
		if( (m_pPerTradeMy[i]) && ( (m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || (m_pPerTradeMy[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) ) )
		{
			if ( m_pPerTradeMy[i]->iCount == 0 )
			{
				// 인벤토리의 아이콘을 삭제한다..
				__IconItemSkill* spItem;
				spItem = m_pPerTradeMy[i];

				// 인벤토리에서도 지운다..
				m_pPerTradeMy[i] = nullptr;

				// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
				RemoveChild(spItem->pUIIcon);

				// 아이콘 리소스 삭제...
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;
			}
		}
	}

	// 취소..
	s_bWaitFromServer				= false;
	s_sRecoveryJobInfo.pItemSource	= nullptr;
	s_sRecoveryJobInfo.pItemTarget	= nullptr;

	s_pCountableItemEdit->Close();
}

void CUIPerTradeDlg::SendToServerItemAddMsg(byte pos, int itemID, int iCount)
{
	// 서버에게 전송한다..
	uint8_t byBuff[16];											// 패킷 버퍼..
	int iOffset=0;											// 패킷 오프셋..

	// 서버에게 패킷 만들어서 날림..
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_EXCHANGE);			
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_PER_TRADE_ADD);		
	CAPISocket::MP_AddByte(byBuff, iOffset, pos);		
	CAPISocket::MP_AddDword(byBuff, iOffset, itemID);		
	CAPISocket::MP_AddDword(byBuff, iOffset, iCount);		

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);			// 보냄..
}

bool CUIPerTradeDlg::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
#define FAIL_RETURN {	\
		CN3UIWndBase::AllHighLightIconFree();	\
		SetState(UI_STATE_COMMON_NONE);	\
		return false;	\
	}

	CN3UIArea* pArea;
	e_UIWND_DISTRICT eUIWnd = UIWND_DISTRICT_UNKNOWN;
	if (!m_bVisible) return false;

	// 내가 가졌던 아이콘이 아니면..
	if (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd != m_eUIWnd)
		FAIL_RETURN
	if (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict != UIWND_DISTRICT_PER_TRADE_INV)
		FAIL_RETURN

	// 내가 가졌던 아이콘이면.. npc영역인지 검사한다..
	int i, iDestiOrder = -1; 
	bool bFound = false;

	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_MY, i);
		if ( (pArea) && (pArea->IsIn(ptCur.x, ptCur.y)) )
		{
			bFound = true;
			eUIWnd = UIWND_DISTRICT_PER_TRADE_MY;
			break;
		}
	}

	if (!bFound)	FAIL_RETURN

	s_bWaitFromServer									= true;
	m_pSubProcPerTrade->m_ePerTradeItemKindBackup		= PER_TRADE_ITEM_OTHER;

	s_sRecoveryJobInfo.pItemSource						= s_sSelectedIconInfo.pItemSelect;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= s_sSelectedIconInfo.UIWndSelect.UIWnd;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict	= s_sSelectedIconInfo.UIWndSelect.UIWndDistrict;
	s_sRecoveryJobInfo.UIWndSourceStart.iOrder			= s_sSelectedIconInfo.UIWndSelect.iOrder;
	s_sRecoveryJobInfo.UIWndSourceEnd.UIWnd				= UIWND_PER_TRADE;
	s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict		= UIWND_DISTRICT_PER_TRADE_MY;

	bFound = false;
	if( (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || 
		(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
	{
		// 활이나 물약등 아이템인 경우..
		// 면저 슬롯에 해당 아이콘이 있는지 알아본다..
		for( i = 0; i < MAX_ITEM_PER_TRADE; i++ )
		{
			if ( bFound )
				break;

			if( (m_pPerTradeMy[i]) && (m_pPerTradeMy[i]->pItemBasic->dwID == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID) &&
				(m_pPerTradeMy[i]->pItemExt->dwID == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt->dwID) )
			{
				bFound = true;
				iDestiOrder = i;
			}
		}

		// 못찾았으면.. 
		if ( !bFound )
		{
			// 빈슬롯을 찾아 들어간다..
			for( i = 0; i < MAX_ITEM_PER_TRADE; i++ )
			{
				if ( !m_pPerTradeMy[i] )
				{
					bFound = true;
					iDestiOrder = i;
					break;
				}
			}

			if ( !bFound )	// 빈 슬롯을 찾지 못했으면..
			{
				s_bWaitFromServer  = false;
				s_sRecoveryJobInfo.pItemSource		= nullptr;
				s_sRecoveryJobInfo.pItemTarget		= nullptr;
				FAIL_RETURN
			}
		}		

		CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;

		// 아이콘이 있는지 없는지 살펴보고.. 
		if ( !m_pPerTradeMy[iDestiOrder] )
		{
			__IconItemSkill *spItemNew = nullptr;
			spItem = CN3UIWndBase::s_sSelectedIconInfo.pItemSelect;

			// 아이콘이 없으면 아이콘을 만드록 갯수는 0으로..
			spItemNew				= new __IconItemSkill;
			spItemNew->pItemBasic	= spItem->pItemBasic;
			spItemNew->pItemExt		= spItem->pItemExt;
			spItemNew->szIconFN		= spItem->szIconFN; // 아이콘 파일 이름 복사..
			spItemNew->iCount		= 0;
			spItemNew->iDurability	= spItem->iDurability;

			// 아이콘 리소스 만들기..
			spItemNew->pUIIcon		= new CN3UIIcon;
			float fUVAspect			= (float)45.0f/(float)64.0f;
			spItemNew->pUIIcon->Init(this); 
			spItemNew->pUIIcon->SetTex(spItemNew->szIconFN);
			spItemNew->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
			spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
			spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
			spItemNew->pUIIcon->SetVisible(true);
			CN3UIArea* pArea;
			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
			if ( pArea )
			{
				spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
				// 움직일 수 없다..
				RECT rect = { 0, 0, 0, 0 };
				spItemNew->pUIIcon->SetMoveRect(rect);
			}

			m_pPerTradeMy[iDestiOrder] = spItemNew;
		}

		m_iBackupiOrder[i] = CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder;

		// 활이나 물약등 아이템인 경우..
		s_bWaitFromServer = false;
		s_pCountableItemEdit->Open(UIWND_PER_TRADE, UIWND_DISTRICT_PER_TRADE_MY, false);
		FAIL_RETURN
	}
	else
	{
		// 아이템이 들어갈 수 있는지 확인, 아이템이 들어 가는 자리 계산..
		for( i = 0; i < MAX_ITEM_PER_TRADE; i++ )
		{
			if (m_pPerTradeMy[i] == nullptr)	
			{
				bFound = true;
				break;
			}
		}

		if ( !bFound )	
		{
			s_bWaitFromServer = false;
			FAIL_RETURN	// 못 찾았으므로.. 실패..
		}

		CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder				= i;
		m_iBackupiOrder[i] = CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder;

		// Server에게 보낸다..	현재 아이템 갯수는 1..^^
		SendToServerItemAddMsg(m_iBackupiOrder[i], CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID+
			CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt->dwID, 1);
		CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget		= nullptr;
	}

	// 내 거래 영역에 세팅하고..
	m_pPerTradeMy[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItem;
	// 영역 윈도우에서 클리어..
	m_pPerTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

	pArea = GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
	if ( pArea )
	{
		spItem->pUIIcon->SetRegion(pArea->GetRegion());
		spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);

	return true;
}

void CUIPerTradeDlg::CancelIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIPerTradeDlg::AcceptIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIPerTradeDlg::IconRestore()
{
	CN3UIArea* pArea;

	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_PER_TRADE_INV:
			if ( m_pPerTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_INV, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pPerTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pPerTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break; 
	}
}

uint32_t CUIPerTradeDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if ( !IsVisible() ) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }
	if (s_bWaitFromServer) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	// 드래그 되는 아이콘 갱신..
	if ( (GetState() == UI_STATE_ICON_MOVING) && 
			(CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd == UIWND_PER_TRADE) )
	{
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
	}

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

int	CUIPerTradeDlg::GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist)
{
	int iReturn = -1;
	int i;

	switch ( eWndDist )
	{
		case UIWND_DISTRICT_PER_TRADE_INV:
			for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
			{
				if ( (m_pPerTradeInv[i] != nullptr) && (m_pPerTradeInv[i] == spItem) )
					return i;
			}
			break;
	}

	return iReturn;
}

RECT CUIPerTradeDlg::GetSampleRect()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_PER_TRADE_MY, 0);
	rect = pArea->GetRegion();
	float fWidth = (float)(rect.right - rect.left);
	float fHeight = (float)(rect.bottom - rect.top);
	fWidth *= 0.5f; fHeight *= 0.5f;
	rect.left = ptCur.x - (int)fWidth;  rect.right  = ptCur.x + (int)fWidth;
	rect.top  = ptCur.y - (int)fHeight; rect.bottom = ptCur.y + (int)fHeight;
	return rect;
}

bool CUIPerTradeDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
// Temp Define
#define FAIL_CODE {		\
				SetState(UI_STATE_COMMON_NONE);	\
				return false;	\
			}

	if(nullptr == pSender) return false;

	if ( (dwMsg == UIMSG_BUTTON_CLICK) && (pSender->m_szID == "btn_close") && (m_pSubProcPerTrade != nullptr) && 
		((m_pSubProcPerTrade->m_ePerTradeState == PER_TRADE_STATE_NORMAL) || 
		(m_pSubProcPerTrade->m_ePerTradeState == PER_TRADE_STATE_MY_TRADE_DECISION_DONE)) )
			// 정상 상태와 내가 거래 결정 버튼을 누른 상태에서만 취소할 수 있다..
			m_pSubProcPerTrade->LeavePerTradeState(PER_TRADE_RESULT_MY_CANCEL);

	if ( (dwMsg == UIMSG_BUTTON_CLICK) && (pSender->m_szID == "btn_trade_my") && (m_pSubProcPerTrade != nullptr) && 
		(m_pSubProcPerTrade->m_ePerTradeState == PER_TRADE_STATE_NORMAL) )		// 정상 상태에서만 결정할 수 있다..
				m_pSubProcPerTrade->PerTradeMyDecision();

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "btn_gold")
		{
			// 인벤토리만 떠 있을때..
			CGameProcedure::s_pProcMain->m_pSubProcPerTrade->RequestItemCountEdit();
		}
	}

	__IconItemSkill* spItem = nullptr;
	int iOrder;

	uint32_t dwBitMask = 0x000f0000;

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_DOWN_FIRST:
			//..
			CN3UIWndBase::AllHighLightIconFree();

			// Get Item..
			spItem = GetHighlightIconItem((CN3UIIcon* )pSender);

			// Save Select Info..
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd = UIWND_PER_TRADE;
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = UIWND_DISTRICT_PER_TRADE_INV;
			iOrder = GetItemiOrder(spItem, UIWND_DISTRICT_PER_TRADE_INV);
			if ( iOrder == -1 )	FAIL_CODE
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder = iOrder;
			CN3UIWndBase::s_sSelectedIconInfo.pItemSelect = spItem;

			// Do Ops..
			((CN3UIIcon* )pSender)->SetRegion(GetSampleRect());
			((CN3UIIcon* )pSender)->SetMoveRect(GetSampleRect());
			// Sound..
			if (spItem) PlayItemSound(spItem->pItemBasic);
			break;

		case UIMSG_ICON_DOWN:
			if ( GetState()  == UI_STATE_ICON_MOVING )
			{
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
			}
			break;

		case UIMSG_ICON_UP:
			// 아이콘 매니저 윈도우들을 돌아 다니면서 검사..
			if ( !CGameProcedure::s_pUIMgr->BroadcastIconDropMsg(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				// 아이콘 위치 원래대로..
				IconRestore();
			// Sound..
			if (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) PlayItemSound(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic);			
			break;
	}

	return true;
}

CN3UIBase* CUIPerTradeDlg::GetChildButtonByName(const std::string& szFN)
{
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (CN3UIBase* )(*itor);
		if ( (pChild->UIType() == UI_TYPE_BUTTON) && (szFN.compare(pChild->m_szID) == 0) )
			return pChild;
	}

	return nullptr;
}


// ===== END WarFare/UIPerTradeDlg.cpp =====

// ===== BEGIN WarFare/UIPerTradeDlg.h =====
#line 1 "WarFare/UIPerTradeDlg.h"
﻿// UIPerTradeDlg.h: interface for the CUIPerTradeDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPERTRADEDLG_H__8C9B06AA_B16D_4135_B198_4AB3C6B09FEA__INCLUDED_)
#define AFX_UIPERTRADEDLG_H__8C9B06AA_B16D_4135_B198_4AB3C6B09FEA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

//////////////////////////////////////////////////////////////////////

class CSubProcPerTrade;
class CUIPerTradeDlg : public CN3UIWndBase
{
	friend class CUIInventory;

public:
	CSubProcPerTrade*	m_pSubProcPerTrade;

// 직접 접근해야 할 객체 참조 포인터
	__IconItemSkill*		m_pPerTradeMy[MAX_ITEM_PER_TRADE];
	__IconItemSkill*		m_pPerTradeOther[MAX_ITEM_PER_TRADE];
	__IconItemSkill*		m_pPerTradeInv[MAX_ITEM_INVENTORY];

	int						m_iBackupiOrder[MAX_ITEM_PER_TRADE];

	CUIImageTooltipDlg*		m_pUITooltipDlg;
	int						m_iBackupiCount;	// 전에 옮긴 화살등의 갯수..

	CN3UIString*			m_pStrMyGold;

protected:
	int					GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist);
	RECT				GetSampleRect();

	void				ItemMoveFromInvToThis();
	void				ItemMoveFromThisToInv();

public:
	CUIPerTradeDlg();
	virtual ~CUIPerTradeDlg();
	void				Release();

	virtual uint32_t		MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld);
	virtual bool		ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg);
	void				Render();
	void				LeavePerTradeState();
	void				EnterPerTradeState();

	void				InitIconWnd(e_UIWND eWnd);	
	void				InitIconUpdate();

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon);

	void				IconRestore();	

	bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur);

	void				CancelIconDrop(__IconItemSkill* spItem);
	void				AcceptIconDrop(__IconItemSkill* spItem);

	void				SendToServerItemAddMsg(byte pos, int itemID, int iCount);

	CN3UIBase*			GetChildButtonByName(const std::string& szFN);

	// Item Count OK..
	void				ItemCountOK();
	void				ItemCountCancel();

	void				GoldUpdate();
};


#endif // !defined(AFX_UIPERTRADEDLG_H__8C9B06AA_B16D_4135_B198_4AB3C6B09FEA__INCLUDED_)

// ===== END WarFare/UIPerTradeDlg.h =====

// ===== BEGIN WarFare/UIPointInitDlg.cpp =====
#line 1 "WarFare/UIPointInitDlg.cpp"
﻿// UIPointInitDlg.cpp: implementation of the UIPointInitDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIPointInitDlg.h"
#include "PacketDef.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "APISocket.h"
#include "N3UIWndBase.h"
#include "UIManager.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIPointInitDlg::CUIPointInitDlg()
{
	m_pBtn_Ok			= nullptr;
	m_pBtn_Cancel		= nullptr;

	m_pText_NeedGold	= nullptr;
}

CUIPointInitDlg::~CUIPointInitDlg()
{

}

void CUIPointInitDlg::Release()
{
	CN3UIBase::Release();
}

bool CUIPointInitDlg::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Ok, GetChildByID<CN3UIButton>("btn_ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel, GetChildByID<CN3UIButton>("btn_cancel"));

	N3_VERIFY_UI_COMPONENT(m_pText_NeedGold, GetChildByID<CN3UIString>("string_gold"));

	return true;
}

bool CUIPointInitDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtn_Ok)
		{
			Close();
			PushOkButton();
		}
		else if(pSender == m_pBtn_Cancel)
			Close();
	}

	return true;
}

void CUIPointInitDlg::Close()
{
	SetVisible(false);
}

void CUIPointInitDlg::PushOkButton()
{
	uint8_t byBuff[32];
	int iOffset = 0;

	switch (m_bAllpoint)
	{
		case true:
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CLASS_CHANGE);
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_CLASS_ALL_POINT);
			break;

		case false:
			CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_CLASS_CHANGE);
			CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_CLASS_SKILL_POINT);
			break;
	}

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

//this_ui_add_start
bool CUIPointInitDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_RETURN:
		ReceiveMessage(m_pBtn_Ok, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtn_Cancel, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIPointInitDlg::InitDlg(bool bAllpoint, int iGold)
{
	m_bAllpoint = bAllpoint;
	if (m_pText_NeedGold) 
	{
		switch (bAllpoint)
		{
			case true: 
				m_pText_NeedGold->SetStringAsInt(iGold);
				break;
			case false: 
				m_pText_NeedGold->SetStringAsInt(iGold);
				break;
		}
	}
}

//this_ui_add_end

// ===== END WarFare/UIPointInitDlg.cpp =====

// ===== BEGIN WarFare/UIPointInitDlg.h =====
#line 1 "WarFare/UIPointInitDlg.h"
﻿// UIPointInitDlg.h: interface for the UIPointInitDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIPOINTINITDLG_H__D784EB22_FE0A_4A62_83FF_4664854DE2EC__INCLUDED_)
#define AFX_UIPOINTINITDLG_H__D784EB22_FE0A_4A62_83FF_4664854DE2EC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CUIPointInitDlg : public CN3UIBase
{
	CN3UIButton*		m_pBtn_Ok;
	CN3UIButton*		m_pBtn_Cancel;

	CN3UIString*		m_pText_NeedGold;
	bool				m_bAllpoint;

public:
	CUIPointInitDlg();
	~CUIPointInitDlg() override;

	void InitDlg(bool bAllpoint, int iGold);
	bool OnKeyPress(int iKey) override;
	void Release() override;

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Close();

	void PushOkButton();
};

#endif // !defined(AFX_UIPOINTINITDLG_H__D784EB22_FE0A_4A62_83FF_4664854DE2EC__INCLUDED_)

// ===== END WarFare/UIPointInitDlg.h =====

// ===== BEGIN WarFare/UIQuestMenu.cpp =====
#line 1 "WarFare/UIQuestMenu.cpp"
﻿#include "stdafx.h"
#include "GameDef.h"
#include "GameBase.h"
#include "GameProcedure.h"
#include "UIQuestMenu.h"
#include "UIManager.h"
#include "PlayerOtherMgr.h"
#include "APISocket.h"

#include <N3Base/N3UIScrollBar.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UITooltip.h>

#include <algorithm>

CUIQuestMenu::CUIQuestMenu()
{
	m_iMenuCnt = 0;

	m_pTextTitle   = nullptr;
	m_pTextSample  = nullptr;

	m_pBtnClose    = nullptr;
	m_pStrNpcName  = nullptr;
	m_pScrollBar   = nullptr;
	m_pBtnMenu     = nullptr;
	m_pImageBtn    = nullptr;
	m_pImageBottom = nullptr;
	m_pImageMenu   = nullptr;

	for (int i = 0; i < MAX_STRING_MENU; ++i)
	{
		m_pTextMenu[i]      = nullptr;
		m_pTextMenuImg[i]   = nullptr;
		m_pTextMenuImgBk[i] = nullptr;
		m_pTextMenuBtn[i]   = nullptr;
	}
}

CUIQuestMenu::~CUIQuestMenu()
{
	InitBase();
	
	delete m_pTextSample;
	delete m_pBtnMenu;
	delete m_pImageBtn;
	delete m_pImageMenu;
}

void CUIQuestMenu::InitBase(void)
{
	SetPos(0, 0);

	m_iMenuCnt = 0;

	for (int i = 0; i < MAX_STRING_MENU; i++)
	{
		delete m_pTextMenu[i];
		m_pTextMenu[i] = nullptr;

		delete m_pTextMenuImg[i];
		m_pTextMenuImg[i] = nullptr;

		delete m_pTextMenuImgBk[i];
		m_pTextMenuImgBk[i] = nullptr;

		delete m_pTextMenuBtn[i];
		m_pTextMenuBtn[i] = nullptr;
	}
}

bool CUIQuestMenu::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pTextSample,	GetChildByID<CN3UIString>("Text_Menu"));
	N3_VERIFY_UI_COMPONENT(m_pTextTitle,	GetChildByID<CN3UIString>("Text_Title"));

	N3_VERIFY_UI_COMPONENT(m_pBtnClose,		GetChildByID<CN3UIButton>("btn_close"));
	N3_VERIFY_UI_COMPONENT(m_pStrNpcName,	GetChildByID<CN3UIString>("Text_Npcname"));
	N3_VERIFY_UI_COMPONENT(m_pScrollBar,	GetChildByID<CN3UIScrollBar>("scroll"));
	N3_VERIFY_UI_COMPONENT(m_pBtnMenu,		GetChildByID<CN3UIButton>("btn_menu"));

	// the background image for the button
	N3_VERIFY_UI_COMPONENT(m_pImageBtn,		GetChildByID<CN3UIImage>("img_button_menu"));

	// this is the bottom of the quest menu UI
	N3_VERIFY_UI_COMPONENT(m_pImageBottom,	GetChildByID<CN3UIImage>("img_Bottom"));

	// this is the background image for the background image for the button
	N3_VERIFY_UI_COMPONENT(m_pImageMenu,	GetChildByID<CN3UIImage>("img_menu"));

	// NOTE: some of these components are meant only to be copied
	RemoveChild(m_pTextSample);
	RemoveChild(m_pBtnMenu);
	RemoveChild(m_pImageBtn);
	RemoveChild(m_pImageMenu);

	return true;
}

bool CUIQuestMenu::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_STRING_LCLICK)
	{
		for (int i = 0; i < MAX_STRING_MENU; i++)
		{
			if (pSender == m_pTextMenu[i])
			{
				MsgSend_SelectMenu(i);
				SetVisible(false);
				return true;
			}
		}
	}
	else if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtnClose)
		{
			SetVisible(false);
			return true;
		}
	}
	else if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		if (pSender == m_pScrollBar)
		{
			UpdateTextForScroll();
			return true;
		}
	}

	return true;
}

void CUIQuestMenu::MsgSend_SelectMenu(uint8_t index)
{
	uint8_t byBuff[10];
	int iOffset = 0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_SELECT_MSG);
	CAPISocket::MP_AddByte(byBuff, iOffset, index);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIQuestMenu::Open(Packet& pkt)
{
	InitBase();

	if (m_pTextSample == nullptr
		|| m_pImageBtn == nullptr
		|| m_pImageMenu == nullptr
		|| m_pBtnMenu == nullptr)
		return;

	std::string szTitle;
	std::string szMenu[MAX_STRING_MENU];

	// NOTE: set the NPC name
	int iNpcID = pkt.read<int16_t>();

	CPlayerNPC* pNPC = CGameProcedure::s_pOPMgr->NPCGetByID(iNpcID, false);
	if (pNPC == nullptr)
		return;

	m_pStrNpcName->SetString(pNPC->IDString());

	// NOTE: get the quest's main text
	int index = pkt.read<uint32_t>();

	__TABLE_QUEST_TALK* pTbl_Quest_Talk = CGameBase::s_pTbl_QuestTalk.Find(index);
	if (pTbl_Quest_Talk == nullptr)
		return;

	szTitle = pTbl_Quest_Talk->szTalk;
	CGameBase::ConvertPipesToNewlines(szTitle);
	m_pTextTitle->SetString(szTitle);

	m_iMenuCnt = 0;

	for (int j = 0; j < MAX_STRING_MENU; j++)
	{
		int iMenu = pkt.read<uint32_t>();
		if (iMenu >= 0)
		{
			__TABLE_QUEST_MENU* pTbl_Quest_Menu = CGameBase::s_pTbl_QuestMenu.Find(iMenu);
			if (pTbl_Quest_Menu != nullptr)
				szMenu[j] = pTbl_Quest_Menu->szMenu;

			m_iMenuCnt++;
		}
	}

	if (m_iMenuCnt == 0)
		return;

	// reset scrollbar position
	if (m_pScrollBar != nullptr)
		m_pScrollBar->SetCurrentPos(0);

	SetVisible(true);

	int iIH;
	RECT rcImage, rcText;

	rcImage = m_pImageMenu->GetRegion();
	iIH = rcImage.bottom - rcImage.top;

	for (int i = 0; i < m_iMenuCnt; i++)
	{
		m_pTextMenu[i] = new CN3UIString();
		__ASSERT(m_pTextMenu[i], "NULL UI Component!!!");

		if (m_pTextMenu[i] != nullptr)
		{
			*(m_pTextMenu[i]) = *m_pTextSample;

			m_pTextMenu[i]->SetString(szMenu[i]);
			m_pTextMenu[i]->MoveOffset(0, i * iIH);
		}

		m_pTextMenuImg[i] = new CN3UIImage();
		m_pTextMenuImgBk[i] = new CN3UIImage();
		m_pTextMenuBtn[i] = new CN3UIButton();

		*(m_pTextMenuImg[i]) = *m_pImageBtn;
		*(m_pTextMenuImgBk[i]) = *m_pImageMenu;
		*(m_pTextMenuBtn[i]) = *m_pBtnMenu;

		m_pTextMenuImg[i]->MoveOffset(0, i * iIH);
		m_pTextMenuImgBk[i]->MoveOffset(0, i * iIH);
		m_pTextMenuBtn[i]->MoveOffset(0, i * iIH);

		m_pTextMenuImgBk[i]->SetParent(this);
		m_pTextMenuImg[i]->SetParent(this);
		m_pTextMenuBtn[i]->SetParent(this);
		m_pTextMenu[i]->SetParent(this);
	}

	rcText = m_pTextMenuImgBk[m_iMenuCnt - 1]->GetRegion();
	m_pImageBottom->SetPos(0, rcText.bottom);

	const int iWidth = CN3Base::s_CameraData.vp.Width;
	const int iHeight = CN3Base::s_CameraData.vp.Height;
	int iX = 0, iY = 0;

	rcText = GetRegion();
	rcText.bottom = m_pImageBottom->GetRegion().bottom;
	SetRegion(rcText);

	iX = (iWidth - (rcText.right - rcText.left)) / 2;
	iY = (iHeight - (rcText.bottom - rcText.top)) / 2;
	SetPos(iX, iY);
}

bool CUIQuestMenu::OnKeyPress(int iKey)
{
	switch (iKey)
	{
		case DIK_ESCAPE:
			SetVisible(false);
			return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIQuestMenu::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();
}

void CUIQuestMenu::UpdateTextForScroll()
{
	if (m_pTextTitle == nullptr
		|| m_pScrollBar == nullptr)
		return;

	// scrollbar's current position
	const int iScrollPosition = m_pScrollBar->GetCurrentPos();

	// total number of lines of text
	const int iTotalLineCount = m_pTextTitle->GetLineCount();

	// max number of lines visible in text area
	const int iVisibleLineCount = 8;

	const int iMaxScrollableLines = iTotalLineCount - iVisibleLineCount;
	m_pScrollBar->SetRangeMax(iMaxScrollableLines);

	// return if text is shorter than or equal to the visible line count
	if (iTotalLineCount <= iVisibleLineCount)
		return;

	// limit check for the line which displayed first, topline
	int iTopLine = std::clamp(
		iScrollPosition,
		0,
		iTotalLineCount - iVisibleLineCount);

	m_pTextTitle->SetStartLine(iTopLine);
}

// ===== END WarFare/UIQuestMenu.cpp =====

// ===== BEGIN WarFare/UIQuestMenu.h =====
#line 1 "WarFare/UIQuestMenu.h"
﻿// UIQuestMenu.h: interface for the CUIQuestMenu class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIQUESTMENU_H__B74550FB_798B_4DB8_91DD_EE5994976EDE__INCLUDED_)
#define AFX_UIQUESTMENU_H__B74550FB_798B_4DB8_91DD_EE5994976EDE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>


class Packet;
class CUIQuestMenu   : public CN3UIBase
{
protected:
	static constexpr int MAX_STRING_MENU = 10;

	CN3UIString*	m_pTextTitle;
	CN3UIString*	m_pTextSample;
	CN3UIString*	m_pTextMenu[MAX_STRING_MENU];

	int				m_iMenuCnt;

	CN3UIImage*		m_pTextMenuImg[MAX_STRING_MENU];
	CN3UIImage*		m_pTextMenuImgBk[MAX_STRING_MENU];
	CN3UIButton*	m_pTextMenuBtn[MAX_STRING_MENU];

	CN3UIButton*	m_pBtnClose;
	CN3UIString*	m_pStrNpcName;
	CN3UIScrollBar*	m_pScrollBar;
	CN3UIButton*	m_pBtnMenu;
	CN3UIImage*		m_pImageBtn;
	CN3UIImage*		m_pImageBottom;
	CN3UIImage*		m_pImageMenu;

public:
	CUIQuestMenu();
	~CUIQuestMenu() override;
	bool Load(File& file) override;
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void MsgSend_SelectMenu(uint8_t index);
	void InitBase();
	void Open(Packet& pkt);

protected:
	void UpdateTextForScroll();
};

#endif // !defined(AFX_UIQUESTMENU_H__B74550FB_798B_4DB8_91DD_EE5994976EDE__INCLUDED_)

// ===== END WarFare/UIQuestMenu.h =====

// ===== BEGIN WarFare/UIQuestTalk.cpp =====
#line 1 "WarFare/UIQuestTalk.cpp"
﻿// UIQuestTalk.cpp: implementation of the CUIQuestTalk class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIQuestTalk.h"
#include "GameDef.h"
#include "GameProcedure.h"
#include "UIManager.h"
#include "APISocket.h"

#include <N3Base/N3UIScrollBar.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIButton.h>

#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIQuestTalk::CUIQuestTalk()
{
	m_pTextTalk			= nullptr;
	m_pBtnOk			= nullptr;
	m_pBtnClose			= nullptr;
	m_pBtnUpperEvent	= nullptr;
	m_pBtnNext			= nullptr;
	m_pBtnOkRight		= nullptr;
	m_pBtnPre			= nullptr;
	m_pScrollBar		= nullptr;
	m_iNumTalk			= 0;
	m_iCurTalk			= 0;
}

CUIQuestTalk::~CUIQuestTalk()
{
}

void CUIQuestTalk::Open(Packet& pkt)
{
	m_iNumTalk = 0;
	m_iCurTalk = 0;

	// NOTE(srmeier): two -1s before text ids
	int index = pkt.read<uint32_t>();
	index = pkt.read<uint32_t>();

	for(int i=0;i<MAX_STRING_TALK;i++)
	{
		m_szTalk[i] = "";

		index = pkt.read<uint32_t>();
		__TABLE_QUEST_TALK* pTbl_Quest_Talk = CGameBase::s_pTbl_QuestTalk.Find(index);
		if(pTbl_Quest_Talk)
		{
			m_szTalk[i] = pTbl_Quest_Talk->szTalk;
			CGameBase::ConvertPipesToNewlines(m_szTalk[i]);
			m_iNumTalk++;
		}
	}

	m_pTextTalk->SetString(m_szTalk[m_iCurTalk]);

	// reset scrollbar position
	if (m_pScrollBar != nullptr)
		m_pScrollBar->SetCurrentPos(0);

	SetVisible(true);
}

bool CUIQuestTalk::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtnOk)
		{
			m_iCurTalk++;
			if (m_iCurTalk >= m_iNumTalk)
			{
				m_iCurTalk = 0;
				SetVisible(false);
			}
			else
			{
				CGameBase::ConvertPipesToNewlines(m_szTalk[m_iCurTalk]);
				m_pTextTalk->SetString(m_szTalk[m_iCurTalk]);
			}
		}
		else if (pSender == m_pBtnClose)
		{
			SetVisible(false);
		}
	}
	else if (dwMsg == UIMSG_SCROLLBAR_POS)
	{
		if (pSender == m_pScrollBar)
		{
			UpdateTextForScroll();
			return true;
		}
	}

	return true;
}

bool CUIQuestTalk::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pTextTalk,			GetChildByID<CN3UIString>("Text_Talk"));
	N3_VERIFY_UI_COMPONENT(m_pBtnOk,			GetChildByID<CN3UIButton>("btn_Ok_center"));

	// NOTE(srmeier): new stuff:
	N3_VERIFY_UI_COMPONENT(m_pBtnClose,			GetChildByID<CN3UIButton>("btn_close"));
	N3_VERIFY_UI_COMPONENT(m_pBtnUpperEvent,	GetChildByID<CN3UIButton>("btn_UpperEvent"));
	N3_VERIFY_UI_COMPONENT(m_pBtnNext,			GetChildByID<CN3UIButton>("btn_Next"));
	N3_VERIFY_UI_COMPONENT(m_pBtnOkRight,		GetChildByID<CN3UIButton>("btn_Ok_right"));
	N3_VERIFY_UI_COMPONENT(m_pBtnPre,			GetChildByID<CN3UIButton>("btn_Pre"));
	N3_VERIFY_UI_COMPONENT(m_pScrollBar,		GetChildByID<CN3UIScrollBar>("scroll"));
	
	if (m_pBtnUpperEvent != nullptr)
		m_pBtnUpperEvent->SetVisible(false);

	if (m_pBtnNext != nullptr)
		m_pBtnNext->SetVisible(false);

	if (m_pBtnOkRight != nullptr)
		m_pBtnOkRight->SetVisible(false);

	if (m_pBtnPre != nullptr)
		m_pBtnPre->SetVisible(false);

	return true;
}

bool CUIQuestTalk::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		SetVisible(false);
		return true;
	case DIK_RETURN:
		ReceiveMessage(m_pBtnOk, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIQuestTalk::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CUIQuestTalk::Release()
{
	CN3UIBase::Release();

	m_pTextTalk			= nullptr;
	m_pBtnOk			= nullptr;
	m_pBtnClose			= nullptr;
	m_pBtnUpperEvent	= nullptr;
	m_pBtnNext			= nullptr;
	m_pBtnOkRight		= nullptr;
	m_pBtnPre			= nullptr;
	m_pScrollBar		= nullptr;
	m_iNumTalk			= 0;
	m_iCurTalk			= 0;
}

void CUIQuestTalk::UpdateTextForScroll()
{
	if (m_pTextTalk == nullptr
		|| m_pScrollBar == nullptr)
		return;

	// scrollbar's current position
	const int iScrollPosition = m_pScrollBar->GetCurrentPos();

	// total number of lines of text
	const int iTotalLineCount = m_pTextTalk->GetLineCount();

	// max number of lines visible in text area
	const int iVisibleLineCount = 8;

	const int iMaxScrollableLines = iTotalLineCount - iVisibleLineCount;
	m_pScrollBar->SetRangeMax(iMaxScrollableLines);

	// return if text is shorter than or equal to the visible line count
	if (iTotalLineCount <= iVisibleLineCount)
		return;

	// limit check for the line which displayed first, topline
	int iTopLine = std::clamp(iScrollPosition, 0, iTotalLineCount - iVisibleLineCount);
	m_pTextTalk->SetStartLine(iTopLine);
}

// ===== END WarFare/UIQuestTalk.cpp =====

// ===== BEGIN WarFare/UIQuestTalk.h =====
#line 1 "WarFare/UIQuestTalk.h"
﻿// UIQuestTalk.h: interface for the CUIQuestTalk class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIQUESTTALK_H__DB9A4C59_4BE8_4698_9462_CF036C8D834D__INCLUDED_)
#define AFX_UIQUESTTALK_H__DB9A4C59_4BE8_4698_9462_CF036C8D834D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#define MAX_STRING_TALK		10

class Packet;
class CUIQuestTalk : public CN3UIBase
{
protected:
	CN3UIString*	m_pTextTalk;
	CN3UIButton*	m_pBtnOk;
	CN3UIButton*	m_pBtnClose;
	CN3UIButton*	m_pBtnUpperEvent;
	CN3UIButton*	m_pBtnNext;
	CN3UIButton*	m_pBtnOkRight;
	CN3UIButton*	m_pBtnPre;
	CN3UIScrollBar* m_pScrollBar;

	std::string		m_szTalk[MAX_STRING_TALK];
	int				m_iNumTalk;
	int				m_iCurTalk;

public:
	void Release() override;
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void Open(Packet& pkt);
	CUIQuestTalk();
	~CUIQuestTalk() override;

protected:
	void UpdateTextForScroll();
};

#endif // !defined(AFX_UIQUESTTALK_H__DB9A4C59_4BE8_4698_9462_CF036C8D834D__INCLUDED_)

// ===== END WarFare/UIQuestTalk.h =====

// ===== BEGIN WarFare/UIRepairTooltipDlg.cpp =====
#line 1 "WarFare/UIRepairTooltipDlg.cpp"
﻿// UIRepairTooltipDlg.cpp: implementation of the UIRepairTooltipDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIRepairTooltipDlg.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIRepairTooltipDlg::CUIRepairTooltipDlg()
{
	m_iPosXBack = 0;
	m_iPosYBack = 0;
	m_spItemBack = nullptr;

	m_bBRender = false;
	m_iBxpos = -1;
	m_iBypos = -1;
	m_pBspItem = nullptr;
	m_iBRequiredGold = 0;
	m_bBHaveEnough = true;

	m_iBRequiredGoldBackup = 0;
}

CUIRepairTooltipDlg::~CUIRepairTooltipDlg()
{
	Release();
}

void CUIRepairTooltipDlg::Release()
{
	CN3UIBase::Release();
}

void CUIRepairTooltipDlg::InitPos()
{
	N3_VERIFY_UI_COMPONENT(m_pStr[0], GetChildByID<CN3UIString>("string_repairgold"));				//이름 
	m_pStr[0]->SetString("0");	
	N3_VERIFY_UI_COMPONENT(m_pStr[1], GetChildByID<CN3UIString>("string_dur_max"));					//이름 
	m_pStr[1]->SetString("0");	
	N3_VERIFY_UI_COMPONENT(m_pStr[2], GetChildByID<CN3UIString>("string_dur_current"));				//이름 
	m_pStr[2]->SetString("0");	
	N3_VERIFY_UI_COMPONENT(m_pStr[3], GetChildByID<CN3UIString>("string_title"));					//이름 
	m_pStr[3]->SetString("0");	
	BackupStrColor();
}

void CUIRepairTooltipDlg::BackupStrColor()
{
	m_pStrColor[0] = m_pStr[0]->GetColor();
	m_pStrColor[1] = m_pStr[1]->GetColor();
	m_pStrColor[2] = m_pStr[2]->GetColor();
	m_pStrColor[3] = m_pStr[3]->GetColor();
}

void CUIRepairTooltipDlg::DisplayTooltipsEnable(int xpos, int ypos, __IconItemSkill* spItem, int iRequiredGold, bool bHaveEnough)
{
	int iIndex = 0;
	if ( !spItem ) return;

	if ( !IsVisible() )
		SetVisible(TRUE);

	std::string szMsg; 

	if ( (m_iPosXBack != xpos) || (m_iPosYBack != ypos) )
	{
		int iWidth = m_rcRegion.right-m_rcRegion.left;
		int iHeight = m_rcRegion.bottom-m_rcRegion.top;

		int iRight, iTop;
		iRight = 1024; iTop = 0;

		if ( (xpos+iWidth<iRight) && ((ypos-iHeight)>iTop))
			SetPos(xpos+26, ypos-iHeight);
		else if ( (xpos+iWidth>iRight) && ((ypos-iHeight)<iTop))
			SetPos(xpos-iWidth, ypos);
		else if ( xpos+iWidth>iRight )
			SetPos(xpos-iWidth, ypos-iHeight);
		else
			SetPos(xpos+26, ypos);

		m_iPosXBack = xpos;
		m_iPosYBack = ypos;
	}

	if ( (!m_spItemBack) || (m_spItemBack->pItemBasic->dwID != spItem->pItemBasic->dwID) || 
		(m_iBRequiredGoldBackup != m_iBRequiredGold) )
	{
		m_spItemBack = spItem;

		std::string szString;

		if ( (spItem->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE) && (spItem->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE_SMALL) && 
				(spItem->pItemBasic->siMaxDurability+spItem->pItemExt->siMaxDurability != 1) )
		{
			szMsg = fmt::format_text_resource(IDS_TOOLTIP_NOAH, iRequiredGold);

			SetTooltipTextColor(bHaveEnough);
			if (!m_pStr[iIndex]->IsVisible())
				m_pStr[iIndex]->SetVisible(true);
			m_pStr[iIndex]->SetString(szMsg);
			iIndex++;

			szMsg = fmt::format_text_resource(IDS_TOOLTIP_MAX_DURABILITY,
				spItem->pItemBasic->siMaxDurability + spItem->pItemExt->siMaxDurability);

			if (!m_pStr[iIndex]->IsVisible())
				m_pStr[iIndex]->SetVisible(true);
			m_pStr[iIndex]->SetString(szMsg);
			iIndex++;

			szMsg = fmt::format_text_resource(IDS_TOOLTIP_CUR_DURABILITY,
				spItem->iDurability);

			if (!m_pStr[iIndex]->IsVisible())
				m_pStr[iIndex]->SetVisible(true);
			m_pStr[iIndex]->SetString(szMsg);
			iIndex++;

			szMsg = fmt::format_text_resource(IDS_TOOLTIP_REPAIR_PRICE);

			if (!m_pStr[iIndex]->IsVisible())
				m_pStr[iIndex]->SetVisible(true);
			m_pStr[iIndex]->SetString(szMsg);
			iIndex++;

			for (int i = iIndex; i < MAX_REPAIR_TOOLTIP_COUNT; i++)
				m_pStr[i]->SetString("");
		}
		else
		{
			szMsg = fmt::format_text_resource(IDS_TOOLTIP_CANNOT);

			m_pStr[0]->SetVisible(false);
			m_pStr[1]->SetVisible(false);
			m_pStr[2]->SetVisible(false);
			m_pStr[3]->SetString(szMsg);
			m_pStr[3]->SetVisible(true);
		}
	}

	m_iBRequiredGoldBackup = m_iBRequiredGold;
	CN3UIBase::Render();
}

void CUIRepairTooltipDlg::DisplayTooltipsDisable()
{
	m_spItemBack = nullptr;
	if ( IsVisible() )
		SetVisible(FALSE);
}

void CUIRepairTooltipDlg::SetTooltipTextColor(bool bHaveEnough)
{
	if (bHaveEnough)
		m_pStr[0]->SetColor(m_pStrColor[0]);
	else
		m_pStr[0]->SetColor(0xffdd0000);
}

void CUIRepairTooltipDlg::Render()
{
	if (!m_bBRender)
		DisplayTooltipsDisable();
	else
		DisplayTooltipsEnable(m_iBxpos, m_iBypos, m_pBspItem, m_iBRequiredGold, m_bBHaveEnough);
}

// ===== END WarFare/UIRepairTooltipDlg.cpp =====

// ===== BEGIN WarFare/UIRepairTooltipDlg.h =====
#line 1 "WarFare/UIRepairTooltipDlg.h"
﻿// UIRepairTooltipDlg.h: interface for the UIRepairTooltipDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIREPAIRTOOLTIPDLG_H__BC9FC233_F483_41D2_8D9B_B3656A00A637__INCLUDED_)
#define AFX_UIREPAIRTOOLTIPDLG_H__BC9FC233_F483_41D2_8D9B_B3656A00A637__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#include "N3UIWndBase.h" // __IconItemSkill

#define MAX_REPAIR_TOOLTIP_COUNT 4

//////////////////////////////////////////////////////////////////////

class CUIRepairTooltipDlg      : public CN3UIBase  
{
	CN3UIString*		m_pStr[MAX_REPAIR_TOOLTIP_COUNT];				// 스트륑.. ^^
	D3DCOLOR			m_pStrColor[MAX_REPAIR_TOOLTIP_COUNT];		// 스트륑 색깔.. ^^
	int					m_iPosXBack, m_iPosYBack;
	__IconItemSkill*	m_spItemBack;

public:
	bool				m_bBRender;
	int					m_iBxpos;
	int					m_iBypos;
	__IconItemSkill*	m_pBspItem;
	int					m_iBRequiredGold;
	bool				m_bBHaveEnough;

	int					m_iBRequiredGoldBackup;

protected:
	void				SetTooltipTextColor(bool bHaveEnough);

public:
	CUIRepairTooltipDlg();
	virtual ~CUIRepairTooltipDlg();
	void	Release();
	void	InitPos();
	void	BackupStrColor();

	void	DisplayTooltipsEnable(int xpos, int ypos, __IconItemSkill* spItem, int iRequiredGold, bool bHaveEnough);
	void	DisplayTooltipsDisable();

	void	Render();
};

#endif // !defined(AFX_UIREPAIRTOOLTIPDLG_H__BC9FC233_F483_41D2_8D9B_B3656A00A637__INCLUDED_)

// ===== END WarFare/UIRepairTooltipDlg.h =====

// ===== BEGIN WarFare/UISkillTreeDlg.cpp =====
#line 1 "WarFare/UISkillTreeDlg.cpp"
﻿// UISkillTreeDlg.cpp: implementation of the CUISkillTreeDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UISkillTreeDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "PlayerMySelf.h"
#include "GameProcMain.h"
#include "UIHotKeyDlg.h"
#include "MagicSkillMng.h"
#include "UIManager.h"
#include "N3UIIcon.h"
#include "text_resources.h"

#include <N3Base/N3UIArea.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUISkillTreeDlg::CUISkillTreeDlg()
{
	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0.0f; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

	m_iRBtnDownOffs = -1;

	int i, j, k;

	m_iCurKindOf		= 0;
	m_iCurSkillPage		= 0;

	for( i = 0; i < MAX_SKILL_FROM_SERVER; i++ )
		m_iSkillInfo[i] = 0;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				m_pMySkillTree[i][j][k] = nullptr;	
			
	CN3UIWndBase::s_sSkillSelectInfo.UIWnd = UIWND_HOTKEY;
	CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
}

CUISkillTreeDlg::~CUISkillTreeDlg()
{
	Release();
/*	int i, j, k;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				if ( m_pMySkillTree[i][j][k] != nullptr )
				{
					delete m_pMySkillTree[i][j][k];
					m_pMySkillTree[i][j][k] = nullptr;
				}

	if ( (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo != nullptr) && (CN3UIWndBase::s_sSkillSelectInfo.UIWnd == UIWND_SKILL_TREE) )
	{
		delete CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
		CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
	}*/
}

void CUISkillTreeDlg::Release()
{
	CN3UIBase::Release();

	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0.0f; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

	int i, j, k;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
	{
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
		{
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
			{
				if ( m_pMySkillTree[i][j][k] != nullptr )
				{
					delete m_pMySkillTree[i][j][k];
					m_pMySkillTree[i][j][k] = nullptr;
				}
			}
		}
	}

	if ( (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo != nullptr) && (CN3UIWndBase::s_sSkillSelectInfo.UIWnd == UIWND_SKILL_TREE) )
	{
		delete CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
		CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
	}
}

bool CUISkillTreeDlg::HasIDSkill(int iID)
{
	int i, j, k;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				if ( m_pMySkillTree[i][j][k] != nullptr )
				{
					if ( m_pMySkillTree[i][j][k]->pSkill->dwID == iID )
						return true;
				}

	return false;
}

void CUISkillTreeDlg::UpdateDisableCheck()
{
	int i, j, k;
	uint32_t bitMask;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				if ( m_pMySkillTree[i][j][k] != nullptr )
				{
					bitMask = UISTYLE_ICON_SKILL;
					if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(m_pMySkillTree[i][j][k]->pSkill))
						bitMask |= UISTYLE_DISABLE_SKILL;
					m_pMySkillTree[i][j][k]->pUIIcon->SetStyle(bitMask);
				}
}

void CUISkillTreeDlg::Tick()
{
	if(m_bOpenningNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width - (int)fWidth;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)m_fMoveDelta;
		if(ptCur.x <= iXLimit) // 다열렸다!!
		{
			ptCur.x = iXLimit;
			m_bOpenningNow = false;
		}

		this->SetPos(ptCur.x, ptCur.y);
	}
	else if(m_bClosingNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = CN3Base::s_CameraData.vp.Width;
		ptCur.x = CN3Base::s_CameraData.vp.Width - (int)(fWidth - m_fMoveDelta);
		if(ptCur.x >= iXLimit) // 다 닫혔다..!!
		{
			ptCur.x = iXLimit;
			m_bClosingNow = false;

			this->SetVisibleWithNoSound(false, false, true); // 다 닫혔으니 눈에서 안보이게 한다.
		}

		this->SetPos(ptCur.x, ptCur.y);
	}

	CN3UIBase::Tick();
}

uint32_t CUISkillTreeDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if ( !IsVisible() ) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }
	// 실제로 쓰진 않는다..
	if (s_bWaitFromServer) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	// 드래그 되는 아이콘 갱신..
	if ( GetState() == UI_STATE_ICON_MOVING ) 
	{
		if(CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo)
		{
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetRegion(GetSampleRect());
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetMoveRect(GetSampleRect());
		}
	}

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

int CUISkillTreeDlg::GetIndexInArea(POINT pt)
{
	CN3UIArea* pArea;
	RECT	rect;

	for (int i = 0; i < MAX_SKILL_IN_PAGE; i++)
	{
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_TREE, i);
		rect = pArea->GetRegion();

		if ( (pt.x >= rect.left) && (pt.x <= rect.right) && (pt.y >= rect.top) && (pt.y <= rect.bottom) )
			return i;
	}

	return -1;
}	

bool CUISkillTreeDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "btn_close")
			Close();
		//..
		if(pSender->m_szID == "btn_left")
			PageLeft();
		if(pSender->m_szID == "btn_right")
			PageRight();
		//..
		if(pSender->m_szID == "btn_0")
			PointPushUpButton(1);
		if(pSender->m_szID == "btn_1")
			PointPushUpButton(2);
		if(pSender->m_szID == "btn_2")
			PointPushUpButton(3);
		if(pSender->m_szID == "btn_3")
			PointPushUpButton(4);
		if(pSender->m_szID == "btn_4")
			PointPushUpButton(5);
		if(pSender->m_szID == "btn_5")
			PointPushUpButton(6);
		if(pSender->m_szID == "btn_6")
			PointPushUpButton(7);
		if(pSender->m_szID == "btn_7")
			PointPushUpButton(8);
		//..
		if(pSender->m_szID == "btn_public")
			SetPageInIconRegion(0, 0);
		if( (pSender->m_szID == "btn_ranger0") || (pSender->m_szID == "btn_blade0") || (pSender->m_szID == "btn_mage0") || 
				(pSender->m_szID == "btn_cleric0") || (pSender->m_szID == "btn_hunter0") || (pSender->m_szID == "btn_berserker0") || 
				(pSender->m_szID == "btn_sorcerer0") || (pSender->m_szID == "btn_shaman0") )
			SetPageInIconRegion(1, 0);
		if( (pSender->m_szID == "btn_ranger1") || (pSender->m_szID == "btn_blade1") || (pSender->m_szID == "btn_mage1") || 
				(pSender->m_szID == "btn_cleric1") || (pSender->m_szID == "btn_hunter1") || (pSender->m_szID == "btn_berserker1") || 
				(pSender->m_szID == "btn_sorcerer1") || (pSender->m_szID == "btn_shaman1") )
			SetPageInIconRegion(2, 0);
		if( (pSender->m_szID == "btn_ranger2") || (pSender->m_szID == "btn_blade2") || (pSender->m_szID == "btn_mage2") || 
				(pSender->m_szID == "btn_cleric2") || (pSender->m_szID == "btn_hunter2") || (pSender->m_szID == "btn_berserker2") || 
				(pSender->m_szID == "btn_sorcerer2") || (pSender->m_szID == "btn_shaman2") )
			SetPageInIconRegion(3, 0);
		if ((pSender->m_szID == "btn_master"))
			SetPageInIconRegion(4, 0);
	}

// Temp Define
#define FAIL_CODE {		\
				SetState(UI_STATE_COMMON_NONE);	\
				return false;	\
			}

	__IconItemSkill* spSkill, *spSkillCopy;

	uint32_t dwLBitMask = 0x000f0000;
	uint32_t dwRBitMask = 0x0f000000;
	uint32_t dwBitMask = dwLBitMask | dwRBitMask;

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	uint32_t bitMask;

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_RDOWN_FIRST:
			m_iRBtnDownOffs = GetIndexInArea(ptCur);
			break;

		case UIMSG_ICON_RUP:
			{
				int iRBtn = GetIndexInArea(ptCur);
				if (iRBtn != -1 && m_iRBtnDownOffs != -1 && m_iRBtnDownOffs == iRBtn)
				{
					// 들어갈 자리가 있는지 검사..
					CUIHotKeyDlg* pDlg = CGameProcedure::s_pProcMain->m_pUIHotKeyDlg;
					int iIndex;
					if (pDlg->GetEmptySlotIndex(iIndex))
					{
						// Get Item..
						spSkill = GetHighlightIconItem((CN3UIIcon* )pSender);
						if (CheckSkillCanBeUse(spSkill->pSkill))
						{
							spSkillCopy = new __IconItemSkill();
							spSkillCopy->pSkill = spSkill->pSkill;
							spSkillCopy->szIconFN = spSkill->szIconFN;

							// 아이콘 로드하기.. ^^
							spSkillCopy->pUIIcon = new CN3UIIcon;
							spSkillCopy->pUIIcon->Init(this);
							spSkillCopy->pUIIcon->SetTex(spSkill->szIconFN);
							spSkillCopy->pUIIcon->SetUVRect(0, 0, 1, 1);
							spSkillCopy->pUIIcon->SetUIType(UI_TYPE_ICON);

							bitMask = UISTYLE_ICON_SKILL;
							if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(spSkillCopy->pSkill))
								bitMask |= UISTYLE_DISABLE_SKILL;
							spSkillCopy->pUIIcon->SetStyle(bitMask);

							// Save Select Info..
							CN3UIWndBase::s_sSkillSelectInfo.UIWnd = UIWND_SKILL_TREE;
							CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = spSkillCopy;

							pDlg->SetReceiveSelectedSkill(iIndex);

							CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
							pDlg->CloseIconRegistry();
						}
					}
				}
			}
			break;

		case UIMSG_ICON_DOWN_FIRST:
			// Get Item..
			spSkill = GetHighlightIconItem((CN3UIIcon* )pSender);

			// 복사본을 만든다.. 
			spSkillCopy = new __IconItemSkill();
			spSkillCopy->pSkill = spSkill->pSkill;
			spSkillCopy->szIconFN = spSkill->szIconFN;

			// 아이콘 로드하기.. ^^
			spSkillCopy->pUIIcon = new CN3UIIcon;
			spSkillCopy->pUIIcon->Init(this);
			spSkillCopy->pUIIcon->SetTex(spSkill->szIconFN);
			spSkillCopy->pUIIcon->SetUVRect(0,0,1,1);
			spSkillCopy->pUIIcon->SetUIType(UI_TYPE_ICON);

			bitMask = UISTYLE_ICON_SKILL;
			if (!CGameProcedure::s_pProcMain->m_pMagicSkillMng->CheckValidSkillMagic(spSkillCopy->pSkill))
				bitMask |= UISTYLE_DISABLE_SKILL;
			spSkillCopy->pUIIcon->SetStyle(bitMask);

			spSkillCopy->pUIIcon->SetRegion(GetSampleRect());
			spSkillCopy->pUIIcon->SetMoveRect(GetSampleRect());

			// Save Select Info..
			CN3UIWndBase::s_sSkillSelectInfo.UIWnd = UIWND_SKILL_TREE;
			CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = spSkillCopy;
			break;

		case UIMSG_ICON_DOWN:
			if ( GetState()  == UI_STATE_ICON_MOVING )
			{
				if(CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo)
				{
					CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetRegion(GetSampleRect());
					CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->SetMoveRect(GetSampleRect());
				}
			}
			break;

		case UIMSG_ICON_UP:
			// Hot Key 윈도우를 돌아 다니면서 검사..
			{
				CUIHotKeyDlg* pDlg = CGameProcedure::s_pProcMain->m_pUIHotKeyDlg;
				if ( !IsIn(ptCur.x, ptCur.y) && pDlg->IsIn(ptCur.x, ptCur.y) )
				{
					if (!pDlg->IsSelectedSkillInRealIconArea())
					{
						// 리소스 Free..
						spSkill = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
						if (spSkill)
						{
							// 매니저에서 제거..
							RemoveChild(spSkill->pUIIcon);

							// 리소스 제거..
							spSkill->pUIIcon->Release();
							delete spSkill->pUIIcon;
							spSkill->pUIIcon = nullptr;
							delete spSkill;
							spSkill = nullptr;
						}
					}
				}
				else
				{
					// 리소스 Free..
					spSkill = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
					if (spSkill)
					{
						// 매니저에서 제거..
						RemoveChild(spSkill->pUIIcon);

						// 리소스 제거..
						spSkill->pUIIcon->Release();
						delete spSkill->pUIIcon;
						spSkill->pUIIcon = nullptr;
						delete spSkill;
						spSkill = nullptr;
					}
				}

				CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
				SetState(UI_STATE_COMMON_NONE);
				pDlg->CloseIconRegistry();
			}
			break;

		case UIMSG_ICON_DBLCLK:
			SetState(UI_STATE_COMMON_NONE);
			break;
	}

	return false;
}

void CUISkillTreeDlg::PageLeft()
{
	if ( m_iCurSkillPage == 0 )
		return;

	SetPageInIconRegion(m_iCurKindOf, m_iCurSkillPage-1);
}

void CUISkillTreeDlg::PageRight()
{
	if (m_iCurSkillPage == MAX_SKILL_PAGE_NUM - 1)
		return;

	SetPageInIconRegion(m_iCurKindOf, m_iCurSkillPage+1);
}

void CUISkillTreeDlg::PointPushUpButton(int iValue)
{
	int iCurKindOfBackup, iCurSkillPageBackup;
	iCurKindOfBackup	= m_iCurKindOf;
	iCurSkillPageBackup	= m_iCurSkillPage;

	int iSkillExtra;			// 스킬창의 값..
	int iSkillPoint;
	std::string str;
	CN3UIString* pStrName, *pStrName2;
	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_skillpoint"));
	str = pStrName->GetString();
	iSkillExtra = atoi(str.c_str());

	if ( iSkillExtra == 0 )
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_EXTRA_NOT_EXIST);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
		return;
	}

	if ((iValue == 1) ||(iValue == 2) || (iValue == 3) ||(iValue == 4))	//.. 
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
		return;
	}

	// 전직하지 않은 상태면.. 전문스킬은 올릴수 없다..
	switch (iValue)
	{
		case 5:	case 6:	case 7: case 8:
			{
				switch ( CGameBase::s_pPlayer->m_InfoBase.eNation )
				{
					case NATION_KARUS:			// 카루스..
						switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
						{
							case CLASS_KA_WARRIOR:
							case CLASS_KA_ROGUE:
							case CLASS_KA_WIZARD:
							case CLASS_KA_PRIEST:
								{
									std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_BEFORE_CLASS_CHANGE);
									CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
									return;
								}
								break;
						}
						break;
				
					case NATION_ELMORAD:		// 엘모라도..
						switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
						{
							case CLASS_EL_WARRIOR:
							case CLASS_EL_ROGUE:
							case CLASS_EL_WIZARD:
							case CLASS_EL_PRIEST:
								{
									std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_BEFORE_CLASS_CHANGE);
									CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
									return;
								}
								break;
						}
						break;
				}
			}
		break;
	}

	if (iValue == 8)
	{
		switch ( CGameBase::s_pPlayer->m_InfoBase.eNation )
		{
			case NATION_KARUS:			// Karus
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_KA_SORCERER:
					case CLASS_KA_HUNTER:
					case CLASS_KA_SHAMAN:
					case CLASS_KA_BERSERKER:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;

			case NATION_ELMORAD:		// Elmorad
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_EL_MAGE:
					case CLASS_EL_RANGER:
					case CLASS_EL_CLERIC:
					case CLASS_EL_BLADE:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;
		}
	}
	// WHY ROGUES CANT POINT TO ASSASIN - WHY WARRIORS CANT POINT TO PASSION ?
	/*
	if (iValue == 7)
	{
		switch ( CGameBase::s_pPlayer->m_InfoBase.eNation )
		{
			case NATION_KARUS:			// 카루스..
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_KA_BERSERKER:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;

			case NATION_ELMORAD:		// 엘모라도..
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_EL_BLADE:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;
		}
	}

	if (iValue == 6)
	{
		switch ( CGameBase::s_pPlayer->m_InfoBase.eNation )
		{
			case NATION_KARUS:			// 카루스..
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_KA_HUNTER:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;

			case NATION_ELMORAD:		// 엘모라도..
				switch ( CGameBase::s_pPlayer->m_InfoBase.eClass )
				{
					case CLASS_EL_RANGER:
						{
							std::string szMsg = fmt::format_text_resource(IDS_SKILL_POINT_NOT_YET);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
							return;
						}
						break;
				}
				break;
		}
	}
	*/

	switch(iValue)	
	{
		case 1:			
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_0"));
			break;

		case 2:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_1"));
			break;

		case 3:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_2"));
			break;

		case 4:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_3"));
			break;

		case 5:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_4"));
			break;

		case 6:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_5"));
			break;

		case 7:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_6"));
			break;

		case 8:
			N3_VERIFY_UI_COMPONENT(pStrName2, GetChildByID<CN3UIString>("string_7"));
			break;

	}

	str = pStrName2->GetString();
	iSkillPoint = atoi(str.c_str());

	// 자기 자신 레벨보다 높일수 없다..
	if ( iSkillPoint >= CGameBase::s_pPlayer->m_InfoBase.iLevel )
	{
		std::string szMsg = fmt::format_text_resource(IDS_SKILL_UP_INVALID);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
		return;
	}

	// 써버에게 보내고.. 숫자 업데이트..	
	uint8_t byBuff[4];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_SKILLPT_CHANGE);
	CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)iValue);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	// 스킬 포인트 업데이트..
	iSkillExtra--;
	pStrName->SetStringAsInt(iSkillExtra);
	m_iSkillInfo[0] = iSkillExtra;

	//TRACE("Send to Server Skill point up index %d\n", iValue);

	iSkillPoint++;
	pStrName2->SetStringAsInt(iSkillPoint);
	switch(iValue)	
	{
		case 1:			
			m_iSkillInfo[1] = iSkillPoint;
			break;
		case 2:			
			m_iSkillInfo[2] = iSkillPoint;
			break;
		case 3:			
			m_iSkillInfo[3] = iSkillPoint;
			break;
		case 4:			
			m_iSkillInfo[4] = iSkillPoint;
			break;
		case 5:			
			m_iSkillInfo[5] = iSkillPoint;
			break;
		case 6:			
			m_iSkillInfo[6] = iSkillPoint;
			break;
		case 7:			
			m_iSkillInfo[7] = iSkillPoint;
			break;
		case 8:			
			m_iSkillInfo[8] = iSkillPoint;
			break;
	}

	switch(iValue)		// 스킬 아이콘 업데이트..
	{
		case 5:
		case 6:
		case 7:
		case 8:
			InitIconUpdate();	
			break;
	}

	SetPageInIconRegion(iCurKindOfBackup, iCurSkillPageBackup);
}

bool CUISkillTreeDlg::OnMouseWheelEvent(
	short delta)
{
	if (delta > 0)
		PageLeft();
	else
		PageRight();

	return true;
}

void CUISkillTreeDlg::Render()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.
	__IconItemSkill* spSkill = nullptr;

	TooltipRenderDisable();

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( (GetState() == UI_STATE_ICON_MOVING) && (pChild->UIType() == UI_TYPE_ICON) && (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo) &&
			((CN3UIIcon *)pChild == CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon) )	
			continue;
		pChild->Render();
		if ( (pChild->UIType() == UI_TYPE_ICON) && (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT) && 
			(GetState() == UI_STATE_COMMON_NONE) )
		{
			spSkill = GetHighlightIconItem( (CN3UIIcon* )pChild );
			TooltipRenderEnable(spSkill);
		}
	}

	CheckButtonTooltipRenderEnable();

	if ( (GetState() == UI_STATE_ICON_MOVING) && (CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo) ) 
		CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo->pUIIcon->Render();		
}

void CUISkillTreeDlg::CheckButtonTooltipRenderEnable()
{
#define IN_RECT(a, b)	 ((a.left < b.x) && (a.right > b.x) && (a.top < b.y) && (a.bottom > b.y))

	RECT rect[MAX_SKILL_KIND_OF]; 
	memset(rect, 0, sizeof(RECT)*MAX_SKILL_KIND_OF);

	rect[SKILL_DEF_BASIC]		= GetChildByID<CN3UIButton>("btn_public")->GetClickRect();

	switch ( CGameBase::s_pPlayer->m_InfoBase.eNation )
	{
		case NATION_ELMORAD:
			rect[SKILL_DEF_SPECIAL0]	= GetChildByID<CN3UIButton>("btn_blade0")->GetClickRect();
			rect[SKILL_DEF_SPECIAL1]	= GetChildByID<CN3UIButton>("btn_blade1")->GetClickRect();
			rect[SKILL_DEF_SPECIAL2]	= GetChildByID<CN3UIButton>("btn_blade2")->GetClickRect();
			rect[SKILL_DEF_SPECIAL3]	= GetChildByID<CN3UIButton>("btn_master")->GetClickRect();
			break;
		case NATION_KARUS:
			rect[SKILL_DEF_SPECIAL0]	= GetChildByID<CN3UIButton>("btn_berserker0")->GetClickRect();
			rect[SKILL_DEF_SPECIAL1]	= GetChildByID<CN3UIButton>("btn_berserker1")->GetClickRect();
			rect[SKILL_DEF_SPECIAL2]	= GetChildByID<CN3UIButton>("btn_berserker2")->GetClickRect();
			rect[SKILL_DEF_SPECIAL3]	= GetChildByID<CN3UIButton>("btn_master")->GetClickRect();
			break;
	}

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();

	for( int i = 0; i < MAX_SKILL_KIND_OF; i++ )
	{
		if (IN_RECT(rect[i], ptCur))
			ButtonTooltipRender(i);
	}
}

// Tool tip on hoverover of skill tabs
void CUISkillTreeDlg::ButtonTooltipRender(int iIndex)
{
	std::string szStr;
	if (!m_pStr_info->IsVisible())
		m_pStr_info->SetVisible(true);

	switch (iIndex)
	{
		// basic skill tab
		case SKILL_DEF_BASIC:
			szStr = fmt::format_text_resource(IDS_SKILL_INFO_BASE);
			break;

		// first skill tab
		case SKILL_DEF_SPECIAL0:
			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_EL_BLADE:
				case CLASS_EL_PROTECTOR:
				case CLASS_KA_BERSERKER:
				case CLASS_KA_GUARDIAN:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_BLADE0);
					break;

				case CLASS_EL_RANGER:
				case CLASS_EL_ASSASIN:
				case CLASS_KA_HUNTER:
				case CLASS_KA_PENETRATOR:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_RANGER0);
					break;

				case CLASS_EL_CLERIC:
				case CLASS_EL_DRUID:
				case CLASS_KA_SHAMAN:
				case CLASS_KA_DARKPRIEST:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_CLERIC0);
					break;

				case CLASS_EL_MAGE:
				case CLASS_EL_ENCHANTER:
				case CLASS_KA_SORCERER:
				case CLASS_KA_NECROMANCER:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_MAGE0);
					break;
			}
			break;

		// second skill tab
		case SKILL_DEF_SPECIAL1:
			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_EL_BLADE:
				case CLASS_EL_PROTECTOR:
				case CLASS_KA_BERSERKER:
				case CLASS_KA_GUARDIAN:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_BLADE1);
					break;

				case CLASS_EL_RANGER:
				case CLASS_EL_ASSASIN:
				case CLASS_KA_HUNTER:
				case CLASS_KA_PENETRATOR:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_RANGER1);
					break;

				case CLASS_EL_CLERIC:
				case CLASS_EL_DRUID:
				case CLASS_KA_SHAMAN:
				case CLASS_KA_DARKPRIEST:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_CLERIC1);
					break;

				case CLASS_EL_MAGE:
				case CLASS_EL_ENCHANTER:
				case CLASS_KA_SORCERER:
				case CLASS_KA_NECROMANCER:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_MAGE1);
					break;
			}
			break;

		// third skill tab
		case SKILL_DEF_SPECIAL2:
			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_EL_BLADE:
				case CLASS_EL_PROTECTOR:
				case CLASS_KA_BERSERKER:
				case CLASS_KA_GUARDIAN:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_BLADE2);
					break;

				case CLASS_EL_RANGER:
				case CLASS_EL_ASSASIN:
				case CLASS_KA_HUNTER:
				case CLASS_KA_PENETRATOR:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_RANGER2);
					break;

				case CLASS_EL_CLERIC:
				case CLASS_EL_DRUID:
				case CLASS_KA_SHAMAN:
				case CLASS_KA_DARKPRIEST:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_CLERIC2);
					break;

				case CLASS_EL_MAGE:
				case CLASS_EL_ENCHANTER:
				case CLASS_KA_SORCERER:
				case CLASS_KA_NECROMANCER:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_MAGE2);
					break;
			}
			break;

		// master skill tab
		case SKILL_DEF_SPECIAL3:
			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_EL_PROTECTOR:
				case CLASS_KA_GUARDIAN:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_BLADE3);
					break;

				case CLASS_EL_ASSASIN:
				case CLASS_KA_PENETRATOR:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_RANGER3);
					break;

				case CLASS_EL_DRUID:
				case CLASS_KA_DARKPRIEST:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_CLERIC3);
					break;

				case CLASS_EL_ENCHANTER:
				case CLASS_KA_NECROMANCER:
					szStr = fmt::format_text_resource(IDS_SKILL_INFO_MAGE3);
					break;
			}
			break;
	}

	m_pStr_info->SetString(szStr);
	m_pStr_info->Render();
}

// Render skill tooltip on skill hover
void CUISkillTreeDlg::TooltipRenderEnable(__IconItemSkill* spSkill)
{
	if (spSkill == nullptr
		|| spSkill->pSkill == nullptr)
		return;

	std::string szStr;

	// Tooltip - skill description
	if (!m_pStr_info->IsVisible())
		m_pStr_info->SetVisible(true);

	m_pStr_info->SetString(spSkill->pSkill->szDesc);

	// Tooltip - MP consumed
	if (!m_pStr_skill_mp->IsVisible())
		m_pStr_skill_mp->SetVisible(true);

	if (spSkill->pSkill->iExhaustMSP == 0)
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NO_MANA);
	else
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_USE_MANA, spSkill->pSkill->iExhaustMSP);

	m_pStr_skill_mp->SetString(szStr);
	szStr.clear();

	// Tooltip - Required level (basic job) or skill points (2nd job and master)
	if (!m_pStr_skill_point->IsVisible())
		m_pStr_skill_point->SetVisible(true);

	// Basic skills
	if ((spSkill->pSkill->iNeedSkill % 10) == 0)
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_LEVEL, spSkill->pSkill->iNeedLevel);
	// 2nd job and master skills
	else
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_SKILL_PT, spSkill->pSkill->iNeedLevel);

	m_pStr_skill_point->SetString(szStr);
	szStr.clear();

	// Tooltip - required item (e.g. weapon)
	if (!m_pStr_skill_item0->IsVisible())
		m_pStr_skill_item0->SetVisible(true);

	switch (spSkill->pSkill->dwNeedItem)
	{
		case 0:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID1); break;
		case 1:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID2); break;
		case 2:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID3); break;
		case 3:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID4); break;
		case 4:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID5); break;
		case 5:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID6); break;
		case 6:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID7); break;
		case 7:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID8); break;
		case 8:		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID9); break;
		case 10:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID10); break;
		case 11:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID11); break;
		case 12:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID12); break;
		case 13:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID13); break;
		case 21:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID14); break;
		case 22:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID15); break;
		case 23:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID16); break;
		case 24:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_ID17); break;
		default:	szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_NEED_ITEM_NO); break;
	}

	m_pStr_skill_item0->SetString(szStr);
	szStr.clear();

	// Tooltip - item required (e.g. scroll or arrows)
	if (!m_pStr_skill_item1->IsVisible())
		m_pStr_skill_item1->SetVisible(true);

	if (spSkill->pSkill->dwExhaustItem != 0)
	{
		__TABLE_ITEM_BASIC* pItem = CGameBase::s_pTbl_Items_Basic.Find(spSkill->pSkill->dwExhaustItem);
		__ASSERT(pItem != nullptr, "NULL Item!!!");

		if (pItem != nullptr)
			szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_ITEM_NEED, pItem->szName);
	}
	else
	{
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_ITEM_NO);
	}

	m_pStr_skill_item1->SetString(szStr);
	szStr.clear();

	// Tooltip - item consumed
	if (!m_pStr_skill_item2->IsVisible())
		m_pStr_skill_item2->SetVisible(true);
	uint32_t requiredItemID = spSkill->pSkill->dwExhaustItem;
	uint32_t consumedItemID = 0;
	
	switch (requiredItemID)
	{
		case ITEM_ID_MASTER_SCROLL_WARRIOR:
			consumedItemID = ITEM_ID_STONE_OF_WARRIOR;
			break;

		case ITEM_ID_MASTER_SCROLL_ROGUE:
			consumedItemID = ITEM_ID_STONE_OF_ROGUE;
			break;

		case ITEM_ID_MASTER_SCROLL_MAGE:
			consumedItemID = ITEM_ID_STONE_OF_MAGE;
			break;

		case ITEM_ID_MASTER_SCROLL_PRIEST:
			consumedItemID = ITEM_ID_STONE_OF_PRIEST;
			break;
	}

	if (consumedItemID != 0)
	{
		__TABLE_ITEM_BASIC* pItem = CGameBase::s_pTbl_Items_Basic.Find(consumedItemID);
		__ASSERT(pItem != nullptr, "NULL Item!!!");

		if (pItem != nullptr)
			szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_USE_ITEM_EXIST, pItem->szName);
	}
	else
	{
		szStr = fmt::format_text_resource(IDS_SKILL_TOOLTIP_USE_ITEM_NO);
	}

	m_pStr_skill_item2->SetString(szStr);
	szStr.clear();

	m_pStr_info->Render();
	m_pStr_skill_mp->Render();
	m_pStr_skill_point->Render();
	m_pStr_skill_item0->Render();
	m_pStr_skill_item1->Render();
	m_pStr_skill_item2->Render();
}

void CUISkillTreeDlg::TooltipRenderDisable()
{
	m_pStr_info->SetVisible(false);
	m_pStr_skill_mp->SetVisible(false);
	m_pStr_skill_point->SetVisible(false);
	m_pStr_skill_item0->SetVisible(false);
	m_pStr_skill_item1->SetVisible(false);
	m_pStr_skill_item2->SetVisible(false);
}

void CUISkillTreeDlg::InitIconWnd(e_UIWND eWnd)
{
	CN3UIWndBase::InitIconWnd(eWnd);

	N3_VERIFY_UI_COMPONENT(m_pStr_info,			GetChildByID<CN3UIString>("string_info"));
	N3_VERIFY_UI_COMPONENT(m_pStr_skill_mp,		GetChildByID<CN3UIString>("string_skill_mp"));
	N3_VERIFY_UI_COMPONENT(m_pStr_skill_point,	GetChildByID<CN3UIString>("string_skill_point"));
	N3_VERIFY_UI_COMPONENT(m_pStr_skill_item0,	GetChildByID<CN3UIString>("string_skill_item0"));
	N3_VERIFY_UI_COMPONENT(m_pStr_skill_item1,	GetChildByID<CN3UIString>("string_skill_item1"));
	N3_VERIFY_UI_COMPONENT(m_pStr_skill_item2,	GetChildByID<CN3UIString>("string_skill_item2"));
}

void CUISkillTreeDlg::InitIconUpdate()
{
	int j, k, iDivide;
	__TABLE_UPC_SKILL* pUSkill = nullptr;

	// 기존 아이콘 모두 클리어..
	for(int i = 0; i < MAX_SKILL_KIND_OF; i++ )
		for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				if ( m_pMySkillTree[i][j][k] != nullptr )
				{
					__IconItemSkill* spSkill = m_pMySkillTree[i][j][k];

					// 매니저에서 제거..
					RemoveChild(spSkill->pUIIcon);

					// 리소스 제거..
					spSkill->pUIIcon->Release();
					delete spSkill->pUIIcon;
					spSkill->pUIIcon = nullptr;
					delete spSkill;
					spSkill = nullptr;
					m_pMySkillTree[i][j][k] = nullptr;
				}


	// 아이디 = 직업 코드*1000 + 001부터.. (직업 코드+1)*100 + 001까지..
	int iSkillIDFirst, iSkillIndexFirst, iSkillIndexLast, iModulo;
	iSkillIDFirst = CGameBase::s_pPlayer->m_InfoBase.eClass * 1000 + 1;
	iSkillIndexLast = CGameBase::s_pTbl_Skill.GetSize();

	if (!CGameBase::s_pTbl_Skill.IDToIndex(iSkillIDFirst, &iSkillIndexFirst))
	{
		PageButtonInitialize();
		return;		// 첫번째 스킬이 없으면.. 안된다..
	}

	if ( CGameBase::s_pPlayer->m_InfoBase.eClass <= CLASS_EL_DRUID )
	{
		for (int i = iSkillIndexFirst; i < CGameBase::s_pTbl_Skill.GetSize(); i++)
		{
			pUSkill = CGameBase::s_pTbl_Skill.GetIndexedData(i);
			iDivide = pUSkill->dwID / 1000;
			if ( iDivide != (iSkillIDFirst / 1000) )
			{
				iSkillIndexLast = i;
				break;
			}
		}
	}

	for (int i = iSkillIndexFirst; i < iSkillIndexLast; i++)
	{
		__TABLE_UPC_SKILL* pUSkill = CGameBase::s_pTbl_Skill.GetIndexedData(i);
		if ( pUSkill == nullptr ) continue;
		if ( pUSkill->dwID >= UIITEM_TYPE_USABLE_ID_MIN) continue;

		// 조건이 충족 되는지 확인한다..
		iModulo = pUSkill->iNeedSkill % 10;
		switch ( iModulo )
		{
			case 0:																				// Basic Skills..
				if (pUSkill->iNeedLevel <= CGameBase::s_pPlayer->m_InfoBase.iLevel)		// 내 레벨보다 같거나 작으면..
					AddSkillToPage(pUSkill);
				else
					AddSkillToPage(pUSkill, 0, false);
				break;

			case 5:																				// First Skill Tab..
				if ( pUSkill->iNeedLevel <= m_iSkillInfo[5] )
					AddSkillToPage(pUSkill, 1);
				else
					AddSkillToPage(pUSkill, 1, false);
				break;

			case 6:																				// Second Skill Tab..
				if ( pUSkill->iNeedLevel <= m_iSkillInfo[6] )
					AddSkillToPage(pUSkill, 2);
				else
					AddSkillToPage(pUSkill, 2, false);
				break;

			case 7:																				// Third Skill Tab..
				if ( pUSkill->iNeedLevel <= m_iSkillInfo[7] )
					AddSkillToPage(pUSkill, 3);
				else
					AddSkillToPage(pUSkill, 3, false);
				break;

			case 8:																				// Master Skill Tab..
				if ( pUSkill->iNeedLevel <= m_iSkillInfo[8] )
					AddSkillToPage(pUSkill, 4);
				else
					AddSkillToPage(pUSkill, 4, false);
				break;
		}		
	}

	PageButtonInitialize();
}

void CUISkillTreeDlg::PageButtonInitialize()
{
	SetPageInIconRegion(0, 0);		
	SetPageInCharRegion();		
	
	// 서버에게 받은 값으로 세팅.. m_iSkillInfo[MAX_SKILL_FROM_SERVER];										// 서버로 받는 슬롯 정보..	
	CN3UIString* pStrName = nullptr;
	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_skillpoint"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[0]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_0"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[1]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_1"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[2]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_2"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[3]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_3"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[4]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_4"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[5]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_5"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[6]);

	N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_6"));
	if (pStrName != nullptr)
		pStrName->SetStringAsInt(m_iSkillInfo[7]);

	// N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>("string_7"));
	// if (pStrName != nullptr)
	//	pStrName->SetStringAsInt(m_iSkillInfo[8]);
    
	ButtonVisibleStateSet();
}

void CUISkillTreeDlg::ButtonVisibleStateSet()
{
// temp macro..
#define ASSET_0 {	\
	if (!pButton) return;	pButton->SetVisible(false);	pButton->SetState(UI_STATE_BUTTON_NORMAL); \
}
#define ASSET_1 {	\
	if (!pButton) return;	pButton->SetVisible(true);	if ( m_iCurKindOf == 1 )	pButton->SetState(UI_STATE_BUTTON_DOWN);	\
}
#define ASSET_2 {	\
	if (!pButton) return;	pButton->SetVisible(true);	if ( m_iCurKindOf == 2 )	pButton->SetState(UI_STATE_BUTTON_DOWN);	\
}
#define ASSET_3 {	\
	if (!pButton) return;	pButton->SetVisible(true);	if ( m_iCurKindOf == 3 )	pButton->SetState(UI_STATE_BUTTON_DOWN);	\
}
#define ASSET_4 {	\
	if (!pButton) return;	pButton->SetVisible(true);	if ( m_iCurKindOf == 4 )	pButton->SetState(UI_STATE_BUTTON_DOWN);	\
}

	CN3UIButton* pButton = nullptr;

	N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_public"));
	if (pButton != nullptr)
		pButton->SetState(UI_STATE_BUTTON_NORMAL);

	// Hide all existing buttons by default.
	N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));
	if (pButton != nullptr)
		pButton->SetVisible(false);

	switch (CGameBase::s_pPlayer->m_InfoBase.eNation)
	{
		case NATION_ELMORAD:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_0;
			break;

		case NATION_KARUS:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter3"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker0"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker1"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker2"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker3"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer0"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer1"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer2"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer3"));	ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman0"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman1"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman2"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman3"));		ASSET_0;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_0;
			break;
	}

	if (m_iCurKindOf == 0)
	{
		N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_public"));
		pButton->SetState(UI_STATE_BUTTON_DOWN);
	}

	switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
	{
		case CLASS_KA_BERSERKER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker0"));	ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker1"));	ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker2"));	ASSET_3;
			break;

		case CLASS_KA_GUARDIAN:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker0"));	ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker1"));	ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_berserker2"));	ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_KA_HUNTER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter2"));		ASSET_3;
			break;

		case CLASS_KA_PENETRATOR:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_hunter2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_KA_SHAMAN:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman2"));		ASSET_3;
			break;

		case CLASS_KA_DARKPRIEST:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_shaman2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_KA_SORCERER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer0"));	ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer1"));	ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer2"));	ASSET_3;
			break;

		case CLASS_KA_NECROMANCER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer0"));	ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer1"));	ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_sorcerer2"));	ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_EL_BLADE:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade2"));		ASSET_3;
			break;

		case CLASS_EL_PROTECTOR:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_blade2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_EL_RANGER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger2"));		ASSET_3;
			break;

		case CLASS_EL_ASSASIN:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_ranger2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_EL_MAGE:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage2"));		ASSET_3;
			break;

		case CLASS_EL_ENCHANTER:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_mage2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;

		case CLASS_EL_CLERIC:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric2"));		ASSET_3;
			break;

		case CLASS_EL_DRUID:
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric0"));		ASSET_1;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric1"));		ASSET_2;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_cleric2"));		ASSET_3;
			N3_VERIFY_UI_COMPONENT(pButton, GetChildByID<CN3UIButton>("btn_master"));		ASSET_4;
			break;
	}
}

void CUISkillTreeDlg::AddSkillToPage(__TABLE_UPC_SKILL* pUSkill, int iOffset, bool bHasLevelToUse)
{
	int i, j;
	bool bFound = false;

	// Check if the same ID exists for m_pMySkillTree[iOffset]
	for( i = 0; i < MAX_SKILL_PAGE_NUM; i++ )
		for ( j = 0; j < MAX_SKILL_IN_PAGE; j++ )
		{
			if ( m_pMySkillTree[iOffset][i][j] != nullptr )
			{
				if ( m_pMySkillTree[iOffset][i][j]->pSkill->dwID == pUSkill->dwID )
					goto stop;
			}
		}

	// Check if skill can be placed in m_pMySkillTree[iOffset]
	for( i = 0; i < MAX_SKILL_PAGE_NUM; i++ )
		for ( j = 0; j < MAX_SKILL_IN_PAGE; j++ )
		{
			if ( m_pMySkillTree[iOffset][i][j] == nullptr )
			{
				bFound = true;
				goto stop;
			}
		}

stop:
	if ( !bFound ) return;

	__IconItemSkill* spSkill = new __IconItemSkill();
	spSkill->pSkill = pUSkill;

	// 아이콘 이름 만들기.. ^^
	if (bHasLevelToUse)
		spSkill->szIconFN = fmt::format("UI\\skillicon_{:02}_{}.dxt", pUSkill->dwID % 100, pUSkill->dwID / 100);
	else
		spSkill->szIconFN = "UI\\skillicon_enigma.dxt";
	
	// 아이콘 로드하기.. ^^
	spSkill->pUIIcon = new CN3UIIcon;
	spSkill->pUIIcon->Init(this);
	spSkill->pUIIcon->SetTex(spSkill->szIconFN);
	spSkill->pUIIcon->SetUVRect(0,0,1,1);
	spSkill->pUIIcon->SetUIType(UI_TYPE_ICON);
	spSkill->pUIIcon->SetStyle(UISTYLE_ICON_SKILL);

	CN3UIArea* pArea = nullptr;
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_TREE, j);
	if ( pArea )
	{
		spSkill->pUIIcon->SetRegion(pArea->GetRegion());
		spSkill->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	// 아이콘 정보 저장..
	m_pMySkillTree[iOffset][i][j] = spSkill;
}

bool CUISkillTreeDlg::CheckSkillCanBeUse(__TABLE_UPC_SKILL* pUSkill)
{
	int iModulo = pUSkill->iNeedSkill % 10;
	switch (iModulo)
	{
		case 0:																				// Basic Skills..
			return pUSkill->iNeedLevel <= CGameBase::s_pPlayer->m_InfoBase.iLevel;				
			break;
		case 5:																				// First Skill Tab..
			return pUSkill->iNeedLevel <= m_iSkillInfo[5];
			break;
		case 6:																				// Second Skill Tab..
			return pUSkill->iNeedLevel <= m_iSkillInfo[6];
			break;
		case 7:																				// Third Skill Tab..
			return pUSkill->iNeedLevel <= m_iSkillInfo[7];
			break;
		case 8:																				// Master Skill Tab..
			return pUSkill->iNeedLevel <= m_iSkillInfo[8];
			break;
	}
	return false;
}

void CUISkillTreeDlg::Open()
{
	// 스르륵 열린다!!
	SetVisible(true);
	this->SetPos(CN3Base::s_CameraData.vp.Width, 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = true;
	m_bClosingNow = false;

	m_iRBtnDownOffs = -1;
}

void CUISkillTreeDlg::Close()
{
	// 리소스 Free..
	__IconItemSkill* spSkill = nullptr;
	spSkill = CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo;
	if (spSkill)
	{
		// 매니저에서 제거..
		RemoveChild(spSkill->pUIIcon);

		// 리소스 제거..
		spSkill->pUIIcon->Release();
		delete spSkill->pUIIcon;
		spSkill->pUIIcon = nullptr;
		delete spSkill;
		spSkill = nullptr;
	}
	CN3UIWndBase::s_sSkillSelectInfo.pSkillDoneInfo = nullptr;
	SetState(UI_STATE_COMMON_NONE);
	CN3UIWndBase::AllHighLightIconFree();

	// 스르륵 닫힌다..!!
//	SetVisible(false); // 다 닫히고 나서 해준다..
	RECT rc = this->GetRegion();
	this->SetPos(CN3Base::s_CameraData.vp.Width - (rc.right - rc.left), 10);
	m_fMoveDelta = 0;
	m_bOpenningNow = false;
	m_bClosingNow = true;

	if(m_pSnd_CloseUI) m_pSnd_CloseUI->Play(); // 닫는 소리..

	m_iRBtnDownOffs = -1;
}

__IconItemSkill* CUISkillTreeDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for( int k = 0; k < MAX_SKILL_IN_PAGE; k++ )
	{
		if ( (m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k] != nullptr) && 
			(m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k]->pUIIcon == pUIIcon) )
			return m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k];
	}

	return nullptr;
}

int CUISkillTreeDlg::GetSkilliOrder(__IconItemSkill* spSkill)
{
	for( int k = 0; k < MAX_SKILL_IN_PAGE; k++ )
	{
		if ( m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k] == spSkill )
			return k;
	}

	return -1;
}

RECT CUISkillTreeDlg::GetSampleRect()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_SKILL_TREE, 0);
	rect = pArea->GetRegion();
	float fWidth = (float)(rect.right - rect.left);
	float fHeight = (float)(rect.bottom - rect.top);
	fWidth *= 0.5f; fHeight *= 0.5f;
	rect.left = ptCur.x - (int)fWidth;  rect.right  = ptCur.x + (int)fWidth;
	rect.top  = ptCur.y - (int)fHeight; rect.bottom = ptCur.y + (int)fHeight;
	return rect;
}

void CUISkillTreeDlg::SetPageInIconRegion(int iKindOf, int iPageNum)		// 아이콘 역역에서 현재 페이지 설정..
{
	if ( (iKindOf >= MAX_SKILL_KIND_OF) || (iPageNum >= MAX_SKILL_PAGE_NUM) )
		return;

	m_iCurKindOf		= iKindOf;
	m_iCurSkillPage		= iPageNum;

	int i, j, k;

	for( i = 0; i < MAX_SKILL_KIND_OF; i++ )
	{
		if ( i != iKindOf )
		{
			for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
				for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
				{
					if ( m_pMySkillTree[i][j][k] != nullptr )
						m_pMySkillTree[i][j][k]->pUIIcon->SetVisible(false);
				}
		}
		else
		{
			for( j = 0; j < MAX_SKILL_PAGE_NUM; j++ )
			{
				if( j != iPageNum )
				{
					for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
					{
						if ( m_pMySkillTree[i][j][k] != nullptr )
							m_pMySkillTree[i][j][k]->pUIIcon->SetVisible(false);
					}
				}
				else
				{
					for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
					{
						if ( m_pMySkillTree[i][j][k] != nullptr )
							m_pMySkillTree[i][j][k]->pUIIcon->SetVisible(true);
					}
				}
			}
		}
	}

	// 아이콘 설명 문자열 업데이트.. 현재 스킬 종류와 현재 스킬 페이지중 아이콘이 보이면 String보이게.. 아니면 안보이게..
	CN3UIString* pStrName;
	std::string str;

	for( k = 0; k < MAX_SKILL_IN_PAGE; k++ )
	{
		if ( m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k] != nullptr )
		{
			str = "string_list_" + std::to_string(k);
			N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>(str));
			pStrName->SetString(m_pMySkillTree[m_iCurKindOf][m_iCurSkillPage][k]->pSkill->szName);
			pStrName->SetVisible(true);
		}
		else
		{
			str = "string_list_" + std::to_string(k);
			N3_VERIFY_UI_COMPONENT(pStrName, GetChildByID<CN3UIString>(str));
			pStrName->SetVisible(false);
		}
	}

	ButtonVisibleStateSet();

	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
	if (pStr != nullptr)
		pStr->SetStringAsInt(iPageNum + 1);
}

void CUISkillTreeDlg::AllClearImageByName(std::string_view svHeaderID, bool bVisible, std::string_view svCategoryID)
{
	CN3UIBase* pBase = nullptr;
	std::string str = "img_";
	str += svHeaderID;
	pBase = GetChildByID(str);
	if (pBase != nullptr)
		pBase->SetVisible(bVisible);

	// If a category ID is not set, assume the same as the header ID.
	if (svCategoryID.empty())
		svCategoryID = svHeaderID;

	for (int i = 0; i < 3; i++)
	{
		str = "img_";
		str += svCategoryID;
		str += "_" + std::to_string(i);
		pBase = GetChildByID(str);
		if (pBase != nullptr)
			pBase->SetVisible(bVisible);
	}
}

// 문자 역역에서 현재 페이지 설정..
void CUISkillTreeDlg::SetPageInCharRegion()
{
	AllClearImageByName("public", false);

	switch (CGameBase::s_pPlayer->m_InfoBase.eNation)
	{
		case NATION_KARUS:
			AllClearImageByName("berserker", false);
			AllClearImageByName("Berserker Hero", false);
			AllClearImageByName("hunter", false);
			AllClearImageByName("Shadow Bane", false);
			AllClearImageByName("sorcerer", false);
			AllClearImageByName("Elemental Lord", false);
			AllClearImageByName("shaman", false);
			AllClearImageByName("Shadow Knight", false);

			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_KA_WARRIOR:
				case CLASS_KA_ROGUE:
				case CLASS_KA_WIZARD:
				case CLASS_KA_PRIEST:
					AllClearImageByName("public", true);
					break;

				case CLASS_KA_BERSERKER:
					AllClearImageByName("berserker", true);
					break;

				case CLASS_KA_HUNTER:
					AllClearImageByName("hunter", true);
					break;

				case CLASS_KA_SORCERER:
					AllClearImageByName("sorcerer", true);
					break;

				case CLASS_KA_SHAMAN:
					AllClearImageByName("shaman", true);
					break;

				case CLASS_KA_GUARDIAN:
					AllClearImageByName("Berserker Hero", true, "berserker");
					break;

				case CLASS_KA_PENETRATOR:
					AllClearImageByName("Shadow Bane", true, "hunter");
					break;

				case CLASS_KA_NECROMANCER:
					AllClearImageByName("Elemental Lord", true, "sorcerer");
					break;

				case CLASS_KA_DARKPRIEST:
					AllClearImageByName("Shadow Knight", true, "shaman");
					break;
			}
			break;

		case NATION_ELMORAD:
			AllClearImageByName("blade", false);
			AllClearImageByName("Blade Master", false);
			AllClearImageByName("ranger", false);
			AllClearImageByName("Kasar Hood", false);
			AllClearImageByName("mage", false);
			AllClearImageByName("Arc Mage", false);
			AllClearImageByName("cleric", false);
			AllClearImageByName("Paladin", false);

			switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
			{
				case CLASS_EL_WARRIOR:
				case CLASS_EL_ROGUE:
				case CLASS_EL_WIZARD:
				case CLASS_EL_PRIEST:
					AllClearImageByName("public", true);
					break;

				case CLASS_EL_BLADE:
					AllClearImageByName("blade", true);
					break;

				case CLASS_EL_RANGER:
					AllClearImageByName("ranger", true);
					break;

				case CLASS_EL_MAGE:
					AllClearImageByName("mage", true);
					break;

				case CLASS_EL_CLERIC:
					AllClearImageByName("cleric", true);
					break;

				case CLASS_EL_PROTECTOR:
					AllClearImageByName("Blade Master", true, "blade");
					break;

				case CLASS_EL_ASSASIN:
					AllClearImageByName("Kasar Hood", true, "ranger");
					break;

				case CLASS_EL_ENCHANTER:
					AllClearImageByName("Arc Mage", true, "mage");
					break;

				case CLASS_EL_DRUID:
					AllClearImageByName("Paladin", true, "cleric");
					break;
			}
	}

	CN3UIBase* pImgMaster = GetChildByID("img_master");
	switch (CGameBase::s_pPlayer->m_InfoBase.eClass)
	{
		case CLASS_KA_GUARDIAN:
		case CLASS_KA_PENETRATOR:
		case CLASS_KA_NECROMANCER:
		case CLASS_KA_DARKPRIEST:
		case CLASS_EL_PROTECTOR:
		case CLASS_EL_ASSASIN:
		case CLASS_EL_ENCHANTER:
		case CLASS_EL_DRUID:
			if (pImgMaster != nullptr)
				pImgMaster->SetVisible(true);
			break;

		default:
			if (pImgMaster != nullptr)
				pImgMaster->SetVisible(false);
			break;
	}
}

CN3UIImage*	CUISkillTreeDlg::GetChildImageByName(const std::string& szID)
{
	for (CN3UIBase* pChild : m_Children)
	{
		if (pChild->UIType() == UI_TYPE_IMAGE
			&& lstrcmpiA(szID.c_str(), pChild->m_szID.c_str()) == 0)
			return static_cast<CN3UIImage*>(pChild);
	}

	return nullptr;
}

CN3UIButton* CUISkillTreeDlg::GetChildButtonByName(const std::string& szID)
{
	for (CN3UIBase* pChild : m_Children)
	{
		if (pChild->UIType() == UI_TYPE_BUTTON
			&& lstrcmpiA(szID.c_str(), pChild->m_szID.c_str()) == 0)
			return static_cast<CN3UIButton*>(pChild);
	}

	return nullptr;
}

//this_ui_add_start
bool CUISkillTreeDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_PRIOR:
		PageLeft();
		return true;
	case DIK_NEXT:
		PageRight();
		return true;
	case DIK_ESCAPE:
		if(!m_bClosingNow) this->Close();
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUISkillTreeDlg::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	if(bReFocus)
	{
		if(bVisible)
			CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
		else
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
	}
}

void CUISkillTreeDlg::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}
//this_ui_add_end

// ===== END WarFare/UISkillTreeDlg.cpp =====

// ===== BEGIN WarFare/UISkillTreeDlg.h =====
#line 1 "WarFare/UISkillTreeDlg.h"
﻿// UISkillTreeDlg.h: interface for the CUISkillTreeDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UISKILLTREEDLG_H__2A724E44_B3A7_41E4_B588_8AF6BC7FB911__INCLUDED_)
#define AFX_UISKILLTREEDLG_H__2A724E44_B3A7_41E4_B588_8AF6BC7FB911__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

const int SKILL_DEF_BASIC = 0;
const int SKILL_DEF_SPECIAL0 = 1;
const int SKILL_DEF_SPECIAL1 = 2;
const int SKILL_DEF_SPECIAL2 = 3;
const int SKILL_DEF_SPECIAL3 = 4;

//////////////////////////////////////////////////////////////////////

class CUISkillTreeDlg : public CN3UIWndBase
{
protected:
	bool		m_bOpenningNow; // 열리고 있다..
	bool		m_bClosingNow;	// 닫히고 있다..
	float		m_fMoveDelta; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

	int			m_iRBtnDownOffs;

	CN3UIString*		m_pStr_info;			// Skill description
	CN3UIString*		m_pStr_skill_mp;		// MP Consumed
	CN3UIString*		m_pStr_skill_point;		// Required skill points
	CN3UIString*		m_pStr_skill_item0;		// Required item (weapon)
	CN3UIString*		m_pStr_skill_item1;		// Required item (eg. scrolls or arrows)
	CN3UIString*		m_pStr_skill_item2;		// Required item (consumables eg. master stones)

public:
	int					m_iCurKindOf;
	int					m_iCurSkillPage;

	int					m_iSkillInfo[MAX_SKILL_FROM_SERVER];										// 서버로 받는 슬롯 정보..	
	__IconItemSkill*	m_pMySkillTree[MAX_SKILL_KIND_OF][MAX_SKILL_PAGE_NUM][MAX_SKILL_IN_PAGE];	// 총 스킬 정보..
	int					m_iCurInPageOffset[MAX_SKILL_KIND_OF];										// 스킬당 현재 페이지 옵셋..

protected:
	void				AllClearImageByName(std::string_view svHeaderID, bool bVisible, std::string_view svCategoryID = {});
	RECT				GetSampleRect();
	void				PageButtonInitialize();
	bool				CheckSkillCanBeUse(__TABLE_UPC_SKILL* pUSkill);
public:
	void SetVisible(bool bVisible);
	CUISkillTreeDlg();
	~CUISkillTreeDlg() override;

	void				SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	bool				OnKeyPress(int iKey) override;
	void				Release() override;
	void				Tick() override;
	uint32_t			MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool				ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool				OnMouseWheelEvent(short delta) override;
	void				Render() override;
	void				Open();
	void				Close();

	void				InitIconWnd(e_UIWND eWnd) override;	
	void				InitIconUpdate() override;

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon) override;
	int					GetSkilliOrder(__IconItemSkill* spSkill);

	void				AddSkillToPage(__TABLE_UPC_SKILL* pUSkill, int iOffset = 0, bool bHasLevelToUse = true);

	void				SetPageInIconRegion(int iKindOf, int iPageNum);		// 아이콘 역역에서 현재 페이지 설정..
	void				SetPageInCharRegion();								// 문자 역역에서 현재 페이지 설정..

	CN3UIImage*			GetChildImageByName(const std::string& szID);
	CN3UIButton*		GetChildButtonByName(const std::string& szID);

	void				PageLeft();
	void				PageRight();

	void				PointPushUpButton(int iValue);

	bool				HasIDSkill(int iID);
	void				ButtonVisibleStateSet();

	void				TooltipRenderEnable(__IconItemSkill* spSkill);
	void				TooltipRenderDisable();
	void				CheckButtonTooltipRenderEnable();
	void				ButtonTooltipRender(int iIndex);

	void				UpdateDisableCheck();
	int					GetIndexInArea(POINT pt);
};

#endif // !defined(AFX_UISKILLTREEDLG_H__2A724E44_B3A7_41E4_B588_8AF6BC7FB911__INCLUDED_)

// ===== END WarFare/UISkillTreeDlg.h =====

// ===== BEGIN WarFare/UIStateBar.cpp =====
#line 1 "WarFare/UIStateBar.cpp"
﻿// UIStateBar.cpp: implementation of the CUIStateBar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIStateBar.h"
#include "GameDef.h"
#include "LocalInput.h"
#include "GameProcMain.h"
#include "APISocket.h"
#include "PacketDef.h"
#include "PlayerMySelf.h"
#include "MagicSkillMng.h"
#include "UIManager.h"
#include "UILevelGuide.h"
#include "N3UIDBCLButton.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIProgress.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3Texture.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIStateBar::CUIStateBar()
{
	m_pText_Position = nullptr;
	m_pProgress_HP = nullptr;
	m_pProgress_HP_slow = nullptr;
	m_pProgress_HP_drop = nullptr;
	m_pProgress_HP_lasting = nullptr;
	m_pProgress_MSP = nullptr;
	m_pProgress_ExpC = nullptr;
	m_pProgress_ExpP = nullptr;

	m_pText_FPS = nullptr;

	// 미니맵...
	m_pGroup_MiniMap = nullptr;
	m_pImage_Map = nullptr;
	m_pBtn_ZoomIn = nullptr;
	m_pBtn_ZoomOut = nullptr;
	m_pBtn_Quest = nullptr;
	m_pBtn_Power = nullptr;

	memset(m_vArrows, 0, sizeof(m_vArrows));

	m_fZoom = 6.0f;
	m_fMapSizeX = 0.0f;
	m_fMapSizeZ = 0.0f;
	m_fYawPlayer = 0;
	m_vPosPlayer.Zero();
	m_vViewPos.Zero();

	m_pMagic.clear();
}

CUIStateBar::~CUIStateBar()
{
	it_MagicImg it, ite;
	ite = m_pMagic.end();	
	for(it = m_pMagic.begin(); it!=ite; it++)
	{
		__DurationMagicImg* pMagicImg = (*it);
		if(pMagicImg)
		{
			delete pMagicImg->pIcon;
			delete pMagicImg;
		}
	}

	m_pMagic.clear();
}

void CUIStateBar::Release()
{
	it_MagicImg it, ite;
	ite = m_pMagic.end();	
	for(it = m_pMagic.begin(); it!=ite; it++)
	{
		__DurationMagicImg* pMagicImg = (*it);
		if(pMagicImg)
		{
			delete pMagicImg->pIcon;
			delete pMagicImg;
		}
	}

	m_pMagic.clear();

	CN3UIBase::Release();

	m_pText_Position = nullptr;
	m_pProgress_HP = nullptr;
	m_pProgress_HP_slow = nullptr;
	m_pProgress_HP_drop = nullptr;
	m_pProgress_HP_lasting = nullptr;
	m_pProgress_MSP = nullptr;
	m_pProgress_ExpC = nullptr;
	m_pProgress_ExpP = nullptr;

	// 미니맵...
	m_pGroup_MiniMap = nullptr;
	m_pImage_Map = nullptr;
	m_pBtn_ZoomIn = nullptr;
	m_pBtn_ZoomOut = nullptr; 
	m_pBtn_Power = nullptr;
	m_pBtn_Quest = nullptr;

	memset(m_vArrows, 0, sizeof(m_vArrows));

	m_fZoom = 6.0f;
	m_fMapSizeX = 0.0f;
	m_fMapSizeZ = 0.0f;
	m_fYawPlayer = 0;
	m_vPosPlayer.Zero();
	m_vViewPos.Zero();
}

bool CUIStateBar::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	CN3UIString* pText = nullptr;
	N3_VERIFY_UI_COMPONENT(pText, GetChildByID<CN3UIString>("Text_Version"));
	if (pText != nullptr)
	{
		std::string version = fmt::format("Ver. {:.3f}", CURRENT_VERSION / 1000.0f);
		pText->SetString(version);
	}

	N3_VERIFY_UI_COMPONENT(m_pText_Position, GetChildByID<CN3UIString>("Text_Position"));

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP, GetChildByID<CN3UIProgress>("Progress_HP"));
	N3_VERIFY_UI_COMPONENT(m_pProgress_MSP, GetChildByID<CN3UIProgress>("Progress_MSP"));
	N3_VERIFY_UI_COMPONENT(m_pProgress_ExpC, GetChildByID<CN3UIProgress>("Progress_ExpC"));
	N3_VERIFY_UI_COMPONENT(m_pProgress_ExpP, GetChildByID<CN3UIProgress>("Progress_ExpP"));
	
	if(m_pProgress_HP) m_pProgress_HP->SetRange(0, 100);
	if(m_pProgress_MSP) m_pProgress_MSP->SetRange(0, 100);
	if(m_pProgress_ExpC) m_pProgress_ExpC->SetRange(0, 100);
	if(m_pProgress_ExpP) m_pProgress_ExpP->SetRange(0, 100);

	// NOTE: new components not previously used

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_slow, GetChildByID<CN3UIProgress>("Progress_HP_slow"));
	if (m_pProgress_HP_slow != nullptr)
	{
		m_pProgress_HP_slow->SetRange(0, 100);
		m_pProgress_HP_slow->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_drop, GetChildByID<CN3UIProgress>("Progress_HP_drop"));
	if (m_pProgress_HP_drop != nullptr)
	{
		m_pProgress_HP_drop->SetRange(0, 100);
		m_pProgress_HP_drop->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_lasting, GetChildByID<CN3UIProgress>("Progress_HP_lasting"));
	if (m_pProgress_HP_lasting != nullptr)
	{
		m_pProgress_HP_lasting->SetRange(0, 100);
		m_pProgress_HP_lasting->SetVisible(false);
	}

	// NOTE: new components to display the text
	N3_VERIFY_UI_COMPONENT(m_pText_HP, GetChildByID<CN3UIString>("Text_HP"));
	N3_VERIFY_UI_COMPONENT(m_pText_MP, GetChildByID<CN3UIString>("Text_MSP"));
	N3_VERIFY_UI_COMPONENT(m_pText_Exp, GetChildByID<CN3UIString>("Text_ExpP"));

	CN3UIString* m_pText_SysTime = GetChildByID<CN3UIString>("SystemTime");
	if (m_pText_SysTime) m_pText_SysTime->SetVisible(false);

	m_pText_FPS = GetChildByID<CN3UIString>("string_fps");

	// MiniMap
	N3_VERIFY_UI_COMPONENT(m_pGroup_MiniMap, GetChildByID("Group_MiniMap"));
	if (m_pGroup_MiniMap != nullptr)
	{
		m_pGroup_MiniMap->SetVisible(false);

		N3_VERIFY_UI_COMPONENT(m_pImage_Map,	m_pGroup_MiniMap->GetChildByID<CN3UIImage>("Img_MiniMap"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_ZoomIn,	m_pGroup_MiniMap->GetChildByID<CN3UIButton>("Btn_ZoomIn"));
		N3_VERIFY_UI_COMPONENT(m_pBtn_ZoomOut,	m_pGroup_MiniMap->GetChildByID<CN3UIButton>("Btn_ZoomOut"));
	}

	m_pBtn_Quest = GetChildByID<CN3UIButton>("btn_quest");
	m_pBtn_Power = GetChildByID<CN3UIButton>("btn_power");

	return true;
}

bool CUIStateBar::LoadMap(const std::string& szMiniMapFN, float fMapSizeX, float fMapSizeZ)
{
	m_fMapSizeX = fMapSizeX;
	m_fMapSizeZ = fMapSizeZ;
	if(nullptr == m_pImage_Map) return false;

	m_pImage_Map->SetTex(szMiniMapFN);
	return true;
}


void CUIStateBar::UpdateExp(int64_t iExp, int64_t iExpNext, bool bUpdateImmediately)
{
	__ASSERT(iExpNext, "Next Exp is 0");
	if (iExpNext <= 0)
		return;

	if (m_pProgress_ExpC == nullptr
		|| m_pProgress_ExpP == nullptr)
		return;

	int iPercentage = (int) (100.0 * ((double) iExp / (double) iExpNext));

	if (iExpNext > 10)
	{
		uint64_t iExpNext2 = iExpNext / 10;
		uint64_t iExp2 = iExp % iExpNext2;
		int iPercentage2 = (int) (100 * iExp2 / iExpNext2);

		if (bUpdateImmediately)
			m_pProgress_ExpC->SetCurValue(iPercentage2);	 //SetCurValue --> set경우 
		else
			m_pProgress_ExpC->SetCurValue(iPercentage2, 0.7f, 50.0f);
	}
	else
	{
		m_pProgress_ExpC->SetCurValue(0);	 //SetCurValue --> set경우 
	}

	if (bUpdateImmediately)
		m_pProgress_ExpP->SetCurValue(iPercentage);	 //SetCurValue --> set경우 
	else
		m_pProgress_ExpP->SetCurValue(iPercentage, 0.3f, 100.0f);

	// NOTE: adding the EXP text
	__ASSERT(iExp >= 0 && iExpNext > 0, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_Exp == nullptr)
		return;

	double iPercentage2 = 100.0 * ((double) iExp / (double) iExpNext);

	std::string buff = fmt::format("{:.2f} %", iPercentage2);
	m_pText_Exp->SetString(buff);
}

void CUIStateBar::UpdateMSP(int iMSP, int iMSPMax, bool bUpdateImmediately)
{
	__ASSERT(iMSPMax, "Max MP is 0");
	if (iMSPMax <= 0)
		return;

	if (m_pProgress_MSP == nullptr)
		return;

	int iPercentage = 100 * iMSP / iMSPMax;

	if (bUpdateImmediately)
		m_pProgress_MSP->SetCurValue(iPercentage);	 //SetCurValue --> set경우 
	else
		m_pProgress_MSP->SetCurValue(iPercentage, 0.3f, 100.0f);

	// NOTE: adding the MP text
	__ASSERT(iMSP >= 0 && iMSPMax > 0, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_MP == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iMSP, iMSPMax);
	m_pText_MP->SetString(buff);
}

void CUIStateBar::UpdateHP(int iHP, int iHPMax, bool bUpdateImmediately)
{
	__ASSERT(iHPMax, "Max HP is 0");
	if (iHPMax <= 0)
		return;

	int iPercentage = 100 * iHP / iHPMax;

	if (bUpdateImmediately)
		m_pProgress_HP->SetCurValue(iPercentage);	 //SetCurValue --> set경우 
	else
		m_pProgress_HP->SetCurValue(iPercentage, 0.3f, 100.0f);

	// NOTE: adding the HP text
	__ASSERT(iHP >= 0 && iHP < 10000 && iHPMax >= 0 && iHPMax < 10000, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_HP == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iHP, iHPMax);
	m_pText_HP->SetString(buff);
}

void CUIStateBar::UpdatePosition(const __Vector3& vPos, float fYaw)
{
	if (m_pText_Position == nullptr)
		return;

	std::string pos = fmt::format("{:.1f}, {:.1f}", vPos.x, vPos.z);
	m_pText_Position->SetString(pos);

	// 미니맵.
	m_vPosPlayer = vPos;
	m_fYawPlayer = fYaw;
}

void CUIStateBar::Render()
{
	if(false == m_bVisible) return;

	CN3UIBase::Render();

	if(nullptr == m_pGroup_MiniMap || false == m_pGroup_MiniMap->IsVisible()) return; // 미니맵이 안켜져 있음 돌아간다..
	if(nullptr == m_pImage_Map) return;
	if(m_fMapSizeX <= 0 || m_fMapSizeZ <= 0) return;

	__VertexTransformedColor vPositions[4], vOutLines[4];
 
	vPositions[0].Set(0, 0, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xffffffff);
	vPositions[1] = vPositions[0];
	vPositions[2] = vPositions[0];
	vPositions[3] = vPositions[0];
	vOutLines[0].Set(0, 0, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff000000);
	vOutLines[1] = vOutLines[0];
	vOutLines[2] = vOutLines[0];
	vOutLines[3] = vOutLines[0];
	
	__PositionInfo info;

	RECT rc = m_pImage_Map->GetRegion();
	float fWidth = (float)(rc.right - rc.left);
	float fHeight = (float)(rc.bottom - rc.top);
	float fCenterX = (float)(rc.left) + fWidth / 2.0f;
	float fCenterY = (float)(rc.top) + fHeight / 2.0f;

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR); // 플레이어의 위치및 방향 표시..

	__Vector3 vPos;
	it_PositionInfo it = m_Positions.begin(), itEnd = m_Positions.end();
	for(; it != itEnd; it++)
	{
		info = *it;
		
		vPos = m_vViewPos - info.vPos;
		vPos.x = (float)(int)(fCenterX - m_fZoom * fWidth * (vPos.x / m_fMapSizeX));
		vPos.y = (float)(int)(fCenterY + m_fZoom * fHeight * (vPos.z / m_fMapSizeZ));

		if (vPos.x < rc.left || vPos.x > rc.right || vPos.y < rc.top || vPos.y > rc.bottom)
		{
			continue;
		}

		vPositions[0].color = info.crType;
		vPositions[1].color = info.crType;
		vPositions[2].color = info.crType;
		vPositions[3].color = info.crType;

		vPositions[0].x = vPos.x - 1.0f;
		vPositions[0].y = vPos.y - 1.0f;
		vPositions[1].x = vPos.x + 1.0f;
		vPositions[1].y = vPos.y - 1.0f;
		vPositions[2].x = vPos.x + 1.0f;
		vPositions[2].y = vPos.y + 1.0f;
		vPositions[3].x = vPos.x - 1.0f;
		vPositions[3].y = vPos.y + 1.0f;

		vOutLines[0].x = vPos.x - 2.0f;
		vOutLines[0].y = vPos.y - 2.0f;
		vOutLines[1].x = vPos.x + 2.0f;
		vOutLines[1].y = vPos.y - 2.0f;
		vOutLines[2].x = vPos.x + 2.0f;
		vOutLines[2].y = vPos.y + 2.0f;
		vOutLines[3].x = vPos.x - 2.0f;
		vOutLines[3].y = vPos.y + 2.0f;

		CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vOutLines, sizeof(__VertexTransformedColor));
		CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vPositions, sizeof(__VertexTransformedColor));
	}

	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLELIST, 2, m_vArrows, sizeof(__VertexTransformedColor));

	it = m_PositionsTop.begin(), itEnd = m_PositionsTop.end(); // 나중에 그릴 점덜...
	for(; it != itEnd; it++)
	{
		info = *it;
		
		vPos = m_vViewPos - info.vPos;
		vPos.x = (float)(int)(fCenterX - m_fZoom * fWidth * (vPos.x / m_fMapSizeX));
		vPos.y = (float)(int)(fCenterY + m_fZoom * fHeight * (vPos.z / m_fMapSizeZ));

		if (vPos.x < rc.left || vPos.x > rc.right || vPos.y < rc.top || vPos.y > rc.bottom)
		{
			continue;
		}

		vPositions[0].color = info.crType;
		vPositions[1].color = info.crType;
		vPositions[2].color = info.crType;
		vPositions[3].color = info.crType;

		vPositions[0].x = vPos.x - 1.0f;
		vPositions[0].y = vPos.y - 1.0f;
		vPositions[1].x = vPos.x + 1.0f;
		vPositions[1].y = vPos.y - 1.0f;
		vPositions[2].x = vPos.x + 1.0f;
		vPositions[2].y = vPos.y + 1.0f;
		vPositions[3].x = vPos.x - 1.0f;
		vPositions[3].y = vPos.y + 1.0f;

		vOutLines[0].x = vPos.x - 2.0f;
		vOutLines[0].y = vPos.y - 2.0f;
		vOutLines[1].x = vPos.x + 2.0f;
		vOutLines[1].y = vPos.y - 2.0f;
		vOutLines[2].x = vPos.x + 2.0f;
		vOutLines[2].y = vPos.y + 2.0f;
		vOutLines[3].x = vPos.x - 2.0f;
		vOutLines[3].y = vPos.y + 2.0f;

		CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vOutLines, sizeof(__VertexTransformedColor));
		CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, vPositions, sizeof(__VertexTransformedColor));
	}

	//Render..
	//m_pMagic.clear();
	it_MagicImg itMagic, iteMagic;
	iteMagic = m_pMagic.end();
	for(itMagic = m_pMagic.begin(); itMagic!=iteMagic; itMagic++)
	{
		__DurationMagicImg* pMagicImg = (*itMagic);
		pMagicImg->pIcon->Render();
	}
	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

void CUIStateBar::Tick()
{
	if(!m_bVisible) return;

	CN3UIBase::Tick();

	// NOTE(srmeier): set the FPS string to be displayed
	static int iCount = 0;
	static std::string strFPS;

	if (iCount++ == 60)
	{
		iCount = 0;
		strFPS = fmt::format("{:.1f}", CN3Base::s_fFrmPerSec);
		if (m_pText_FPS != nullptr)
			m_pText_FPS->SetString(strFPS);
	}

	TickMiniMap(); // 맵 이미지...
	TickMagicIcon(); // 아이콘 처리..
}

void CUIStateBar::TickMiniMap()
{
	if (nullptr == m_pImage_Map) return;
	if (m_fMapSizeX <= 0 || m_fMapSizeZ <= 0) return;

	m_vViewPos = m_vPosPlayer;

	RECT rc = m_pImage_Map->GetRegion();

	int minimapWidth = rc.right - rc.left;
	int minimapWidth2 = minimapWidth / 2;
	int minimapHeight = rc.bottom - rc.top;
	int minimapHeight2 = minimapHeight / 2;

	float factorX = m_fZoom * minimapWidth / m_fMapSizeX;
	float factorY = m_fZoom * minimapHeight / m_fMapSizeZ;

	// limit map from scrolling out of bounds

	if (minimapWidth2 > factorX * m_vViewPos.x)
	{
		m_vViewPos.x = minimapWidth2 / factorX;
	}

	if (m_fZoom * minimapWidth - minimapWidth2 < factorX * m_vViewPos.x)
	{
		m_vViewPos.x = (m_fZoom * minimapWidth - minimapWidth2) / factorX;
	}

	if (minimapHeight2 > factorY * m_vViewPos.z)
	{
		m_vViewPos.z = minimapHeight2 / factorY;
	}

	if (m_fZoom * minimapHeight - minimapHeight2 < factorY * m_vViewPos.z)
	{
		m_vViewPos.z = (m_fZoom * minimapHeight - minimapHeight2) / factorY;
	}

	float fOffset = (0.5f / m_fZoom);
	float fX = (m_vViewPos.x / m_fMapSizeX);
	float fY = (m_vViewPos.z / m_fMapSizeZ);

	float x1, y1, x2, y2 = 0;
	x1 = fX - fOffset;
	y1 = fY + fOffset;
	x2 = fX + fOffset;
	y2 = fY - fOffset;

	m_pImage_Map->SetUVRect(x1, 1.0f - y1, x2, 1.0f - y2);

	float fH = (rc.bottom - rc.top) / 30.0f;

	__Matrix44 mtxRot; mtxRot.RotationZ(m_fYawPlayer);
	mtxRot.PosSet(rc.left + minimapWidth2 + factorX * (m_vPosPlayer.x - m_vViewPos.x), rc.top + minimapHeight2 - factorY * (m_vPosPlayer.z - m_vViewPos.z), 0);

	// 화살표 세팅...
	m_vArrows[0].Set(0, -fH, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	m_vArrows[1].Set(0, fH / 2.0f, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	m_vArrows[2].Set(-fH, fH, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);

	m_vArrows[3] = m_vArrows[0];
	m_vArrows[4] = m_vArrows[2]; m_vArrows[4].x = -m_vArrows[4].x;
	m_vArrows[5] = m_vArrows[1];

	for (int i = 0; i < 6; i++) m_vArrows[i] *= mtxRot; // 위치 및 회전 변환..
}

void CUIStateBar::TickMagicIcon()
{
	__TABLE_UPC_SKILL* pRemoveSkill = nullptr;

	for (__DurationMagicImg* pMagicImg : m_pMagic)
	{
		pMagicImg->fDuration -= CN3Base::s_fSecPerFrm;

		if (pMagicImg->fDuration <= 0.0f)
		{
			pMagicImg->pIcon->SetVisible(false);
			pRemoveSkill = CGameBase::s_pTbl_Skill.Find(pMagicImg->dwSkillID);
			break;
		}
		
		if (pMagicImg->fDuration <= 10.0f)
			pMagicImg->pIcon->SetVisible(pMagicImg->fDuration - (int) pMagicImg->fDuration < 0.5f);
	}

	if (pRemoveSkill != nullptr)
		DelMagic(pRemoveSkill);
}

bool CUIStateBar::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_ZoomIn)
		{
			ZoomSet(m_fZoom*1.1f);
			return true;
		}
		else if (pSender == m_pBtn_ZoomOut)
		{
			ZoomSet(m_fZoom*0.9f);
			return true;
		}
		else if (pSender == m_pBtn_Quest)
		{
			if (CGameProcedure::s_pProcMain->m_pUILevelGuide != nullptr)
				CGameProcedure::s_pProcMain->CommandToggleLevelGuide();

			return true;
		}
		else if (pSender == m_pBtn_Power)
		{
			//TODO: Launch msgbox with warning message, on confirm -> open store (Web_Browser UI or maybe external?)
			return false;
		}
	}
	else if(dwMsg==UIMSG_ICON_DBLCLK)
	{
		it_MagicImg it, ite;
		ite = m_pMagic.end();	
		for(it = m_pMagic.begin(); it!=ite; it++)
		{
			__DurationMagicImg* pMagicImg = (*it);

			if(pSender==pMagicImg->pIcon)
			{
				uint32_t MagicID = pMagicImg->dwSkillID;
				__TABLE_UPC_SKILL* pSkill = CGameBase::s_pTbl_Skill.Find(MagicID);
				if(!pSkill) return false;

				if(CGameProcedure::s_pProcMain->m_pMagicSkillMng->IsPositiveMagic(MagicID))
				{
					if(pSkill->dw1stTableType==3 || pSkill->dw2ndTableType==3) pMagicImg->fDuration = 0.0f;

					//없애라..
					uint8_t byBuff[32];
					int iOffset=0;
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)WIZ_MAGIC_PROCESS);
					CAPISocket::MP_AddByte(byBuff, iOffset, (uint8_t)N3_SP_MAGIC_CANCEL);
					CAPISocket::MP_AddDword(byBuff, iOffset, (int)MagicID);
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)CGameBase::s_pPlayer->IDNumber());
					CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)CGameBase::s_pPlayer->IDNumber());

					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);

					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);
					CAPISocket::MP_AddShort(byBuff, iOffset, 0);

					CGameProcedure::s_pSocket->Send(byBuff, iOffset); // 보낸다..					
					return true;
				}
			}
		}	
	}	
	return false;
}

// NOTE: appears to add NPC/Players as dots on map?
void CUIStateBar::PositionInfoAdd(int iID, const __Vector3 &vPos, D3DCOLOR crID, bool bDrawTop)
{
	__PositionInfo info;
	info.iID = iID;
	info.vPos = vPos;
	info.crType = crID;

	if(bDrawTop) m_PositionsTop.push_back(info);
	else m_Positions.push_back(info);
}

void CUIStateBar::PositionInfoClear()
{
	m_Positions.clear();
	m_PositionsTop.clear();
}

void CUIStateBar::ZoomSet(float fZoom)
{
	if (fZoom < 1.0f)
	{
		m_fZoom = 1.0f;
	}
	else if (fZoom > 6.0f)
	{
		m_fZoom = 6.0f;
	}
	else
	{
		m_fZoom = fZoom;
	}
}

bool CUIStateBar::ToggleMiniMap()
{
	if(nullptr == m_pGroup_MiniMap) return false;

	bool bVisible = m_pGroup_MiniMap->IsVisible();
	m_pGroup_MiniMap->SetVisible(!bVisible);

	return !bVisible;
}

void CUIStateBar::AddMagic(__TABLE_UPC_SKILL* pSkill, float fDuration)
{
	std::string buffer = fmt::format("UI\\skillicon_{:02}_{}.dxt",
		pSkill->dwID % 100, pSkill->dwID / 100);

	__DurationMagicImg* pMagicImg = new __DurationMagicImg;
	pMagicImg->fDuration = fDuration;
	pMagicImg->pIcon = new CN3UIDBCLButton;
	pMagicImg->dwSkillID = pSkill->dwID;

	CN3UIDBCLButton* pIcon = pMagicImg->pIcon;
	pIcon->Init(this);
	pIcon->SetTex(buffer);
	pIcon->SetTooltipText(pSkill->szName);
	pIcon->SetUVRect(0,0,1,1);

	CN3Texture* pTex = pIcon->GetTex();
	if(!pTex)
	{
		delete pIcon;
		delete pMagicImg;
		return;
	}

	RECT rt;
	rt.left = rt.top = 0;
	rt.right = pTex->Width();
	rt.bottom = pTex->Height();

	int iconCount = static_cast<int>(m_pMagic.size());
	int PosX = static_cast<int>(s_CameraData.vp.Width) - (rt.right * (iconCount + 1));
	pIcon->SetRegion(rt);
	pIcon->SetPos(PosX, 0);

	m_pMagic.push_back(pMagicImg);
}

void CUIStateBar::DelMagic(__TABLE_UPC_SKILL* pSkill)
{
	std::string buffer = fmt::format("UI\\skillicon_{:02}_{}.dxt",
		pSkill->dwID % 100, pSkill->dwID / 100);

	it_MagicImg it, ite, itRemove;
	itRemove = ite = m_pMagic.end();	
	for(it = m_pMagic.begin(); it!=ite; it++)
	{
		__DurationMagicImg* pMagicImg = (*it);
		CN3UIDBCLButton* pIcon = pMagicImg->pIcon;
		CN3Texture* pTex = pIcon->GetTex();
		if(pTex && lstrcmpi(pTex->FileName().c_str(), buffer.c_str())==0)
		{
			itRemove = it;
		}
		if(itRemove!=ite)
		{
			POINT pos = pIcon->GetPos();
			RECT rt = pIcon->GetRegion();			
			pIcon->SetPos(pos.x + (rt.right-rt.left),0);
		}
	}
	if(itRemove!=ite)
	{
		__DurationMagicImg* pMagicImg = (*itRemove);
		CN3UIDBCLButton* pIcon = pMagicImg->pIcon;
		delete pIcon;
		delete pMagicImg;
		m_pMagic.erase(itRemove);
	}	
}

void CUIStateBar::ClearMagic()
{
	it_MagicImg it, ite;
	ite = m_pMagic.end();
	for(it = m_pMagic.begin(); it!=ite; it++)
	{
		__DurationMagicImg* pMagicImg = (*it);
		CN3UIDBCLButton* pIcon = pMagicImg->pIcon;
		delete pIcon;
		delete pMagicImg;		
	}
	m_pMagic.clear();
}

uint32_t CUIStateBar::MouseProc(uint32_t dwFlags, const POINT &ptCur, const POINT &ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;

	for (const __DurationMagicImg* pMagicImg : m_pMagic)
	{
		dwRet |= pMagicImg->pIcon->MouseProc(
			CGameProcedure::s_pLocalInput->MouseGetFlag(),
			CGameProcedure::s_pLocalInput->MouseGetPos(),
			CGameProcedure::s_pLocalInput->MouseGetPosOld());
	}

	dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);

	return dwRet;
}

bool CUIStateBar::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		{	//hotkey가 포커스 잡혀있을때는 다른 ui를 닫을수 없으므로 DIK_ESCAPE가 들어오면 포커스를 다시잡고
			//열려있는 다른 유아이를 닫아준다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
			CN3UIBase* pFocus = CGameProcedure::s_pUIMgr->GetFocusedUI();
			if(pFocus && pFocus != this) pFocus->OnKeyPress(iKey);
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIStateBar.cpp =====

// ===== BEGIN WarFare/UIStateBar.h =====
#line 1 "WarFare/UIStateBar.h"
﻿// UIStateBar.h: interface for the CUIStateBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIStateBar_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_)
#define AFX_UIStateBar_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

struct __PositionInfo
{
	__Vector3	vPos;
	int			iID;
	D3DCOLOR	crType; // 종류에 따른 색깔... 
};

struct __DurationMagicImg
{
	uint32_t		dwSkillID;
	class CN3UIDBCLButton* pIcon;
	float		fDuration;
};

typedef std::list<__PositionInfo>::iterator it_PositionInfo;
typedef std::list<__DurationMagicImg*>::iterator it_MagicImg;

struct __TABLE_UPC_SKILL;
class CUIStateBar : public CN3UIBase  
{
protected:
	CN3UIString*	m_pText_HP;
	CN3UIString*	m_pText_MP;
	CN3UIString*	m_pText_Exp;

	CN3UIString*	m_pText_Position;
	CN3UIProgress*	m_pProgress_HP;
	CN3UIProgress*	m_pProgress_HP_slow;
	CN3UIProgress*	m_pProgress_HP_drop;
	CN3UIProgress*	m_pProgress_HP_lasting;

	CN3UIProgress*	m_pProgress_MSP;
	CN3UIProgress*	m_pProgress_ExpC;
	CN3UIProgress*	m_pProgress_ExpP;

	// 미니맵...
	CN3UIBase*		m_pGroup_MiniMap;
	CN3UIImage*		m_pImage_Map; // 이 이미지에 미니맵 텍스처를 적용시킨다..
	CN3UIButton*	m_pBtn_ZoomIn;
	CN3UIButton*	m_pBtn_ZoomOut;
	CN3UIButton*	m_pBtn_Quest;
	CN3UIButton*	m_pBtn_Power;

	// NOTE(srmeier): new components
	CN3UIString*	m_pText_FPS;

	float			m_fZoom; // 지도의 배율..
	float			m_fMapSizeX;
	float			m_fMapSizeZ;
	float			m_fYawPlayer;
	__Vector3		m_vPosPlayer;
	__Vector3		m_vViewPos;

	__VertexTransformedColor	m_vArrows[6]; // 플레이어 위치 화살표..
	std::list<__PositionInfo>	m_Positions;
	std::list<__PositionInfo>	m_PositionsTop; // 맨 위에 그릴 위치덜..

	//컬려있는 마법스킬 표시하기..
	std::list<__DurationMagicImg*> m_pMagic;
	
public:
	bool OnKeyPress(int iKey) override;
	uint32_t MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;

	void AddMagic(__TABLE_UPC_SKILL* pSkill, float fDuration);
	void DelMagic(__TABLE_UPC_SKILL* pSkill);
	void ClearMagic();
	void TickMagicIcon();
	void TickMiniMap();
		    
	bool ToggleMiniMap();
		    
	void UpdateExp(int64_t iExp, int64_t iExpNext, bool bUpdateImmediately);
	void UpdateMSP(int iMSP, int iMSPMax, bool bUpdateImmediately);
	void UpdateHP(int iHP, int iHPMax, bool bUpdateImmediately);

	void UpdatePosition(const __Vector3& vPos, float fYaw);

	void ZoomSet(float fZoom);
	void PositionInfoAdd(int iID, const __Vector3& vPos, D3DCOLOR crID, bool bDrawTop);
	void PositionInfoClear();
	bool LoadMap(const std::string& szMiniMapFN, float fMapSizeX, float fMapSizeZ); // 미니맵 비트맵 파일 이름, 매의 너비 길이..(Meter);
	
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override; // 메시지를 받는다.. 보낸놈, msg

	void Tick() override;
	void Render() override; // 미니맵 렌더링..
	bool Load(File& file) override;
	
	void Release() override;
	CUIStateBar();
	~CUIStateBar() override;
};

#endif // !defined(AFX_UIStateBar_H__C1BBB503_F9E5_43BB_93CB_C542AC016F85__INCLUDED_)




// ===== END WarFare/UIStateBar.h =====

// ===== BEGIN WarFare/UITargetBar.cpp =====
#line 1 "WarFare/UITargetBar.cpp"
﻿#include "StdAfx.h"
#include "UITargetBar.h"
#include "GameBase.h"
#include "text_resources.h"

#include <N3Base/N3UIProgress.h>
#include <N3Base/N3UIString.h>

CUITargetBar::CUITargetBar()
{
	m_pProgress_HP = nullptr;
	m_pProgress_HP_slow = nullptr;
	m_pProgress_HP_drop = nullptr;
	m_pProgress_HP_lasting = nullptr;

	m_pStringID = nullptr;
	m_fTimeSendPacketLast = 0;
}

CUITargetBar::~CUITargetBar()
{
}

void CUITargetBar::Release()
{
	CN3UIBase::Release();

	m_pProgress_HP = nullptr;
	m_pProgress_HP_slow = nullptr;
	m_pProgress_HP_drop = nullptr;
	m_pProgress_HP_lasting = nullptr;
	m_pStringID = nullptr;
	m_fTimeSendPacketLast = 0;
}

void CUITargetBar::UpdateHP(int iHP, int iHPMax, bool bUpdateImmediately)
{
	__ASSERT(iHPMax > 0, "Invalid Max HP");
	if(iHP < 0 || iHPMax <= 0) return;
	if(nullptr == m_pProgress_HP) return;

	int iPercentage = iHP * 100 / iHPMax;

	if(bUpdateImmediately) m_pProgress_HP->SetCurValue(iPercentage);
	else m_pProgress_HP->SetCurValue(iPercentage, 0.5f, 50.0f);				// 1초뒤에 초당 50 의 속도로 변하게 한다.
	return;
}

BOOL CUITargetBar::SetIDString(const std::string& szID, D3DCOLOR crID)
{
	m_pStringID->SetString(szID);
	m_pStringID->SetColor(crID);
	return TRUE;
}

bool CUITargetBar::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;
	CN3UIString* amountStr = new CN3UIString();
	amountStr->Init(this);

    N3_VERIFY_UI_COMPONENT(m_pProgress_HP, GetChildByID<CN3UIProgress>("pro_target"));
	N3_VERIFY_UI_COMPONENT(m_pStringID, GetChildByID<CN3UIString>("text_target"));

	if (m_pProgress_HP != nullptr)
		m_pProgress_HP->SetRange(0, 100);

	// 폰트를 바꾼다.
	if (m_pStringID != nullptr)
	{
		std::string szFontID = fmt::format_text_resource(IDS_FONT_ID);

		uint32_t dwH = m_pStringID->GetFontHeight();
		m_pStringID->SetFont(szFontID, dwH, FALSE, FALSE);
	}

	// NOTE: new target health bars depending on poison or curse
	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_slow, GetChildByID<CN3UIProgress>("Progress_HP_slow"));
	if (m_pProgress_HP_slow != nullptr)
	{
		m_pProgress_HP_slow->SetRange(0, 100);
		m_pProgress_HP_slow->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_drop, GetChildByID<CN3UIProgress>("Progress_HP_drop"));
	if (m_pProgress_HP_drop != nullptr)
	{
		m_pProgress_HP_drop->SetRange(0, 100);
		m_pProgress_HP_drop->SetVisible(false);
	}

	N3_VERIFY_UI_COMPONENT(m_pProgress_HP_lasting, GetChildByID<CN3UIProgress>("Progress_HP_lasting"));
	if (m_pProgress_HP_lasting != nullptr)
	{
		m_pProgress_HP_lasting->SetRange(0, 100);
		m_pProgress_HP_lasting->SetVisible(false);
	}

	return true;
}

// ===== END WarFare/UITargetBar.cpp =====

// ===== BEGIN WarFare/UITargetBar.h =====
#line 1 "WarFare/UITargetBar.h"
﻿// UITargetBar.h: interface for the UITargetBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITARGETBAR_H__E572A55F_D4DE_471D_A0E8_CB587043DD5B__INCLUDED_)
#define AFX_UITARGETBAR_H__E572A55F_D4DE_471D_A0E8_CB587043DD5B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUITargetBar : public CN3UIBase
{
public:
	CN3UIProgress*	m_pProgress_HP;
	CN3UIProgress*	m_pProgress_HP_slow;
	CN3UIProgress*	m_pProgress_HP_drop;
	CN3UIProgress*	m_pProgress_HP_lasting;
	CN3UIString*	m_pStringID;
	float m_fTimeSendPacketLast; // 이걸 기준으로 1초에 한번씩 타겟의 정보 요청..

public:
	void UpdateHP(int iHP, int iMaxHP, bool bUpdateImmediately);
	BOOL SetIDString(const std::string& szID, D3DCOLOR crID);
		    
	bool Load(File& file) override;
	void Release() override;
	CUITargetBar();
	~CUITargetBar() override;
};

#endif // !defined(AFX_UITARGETBAR_H__E572A55F_D4DE_471D_A0E8_CB587043DD5B__INCLUDED_)

// ===== END WarFare/UITargetBar.h =====

// ===== BEGIN WarFare/UITradeBBSEditDlg.cpp =====
#line 1 "WarFare/UITradeBBSEditDlg.cpp"
﻿// UITradeBBSEditDlg.cpp: implementation of the CUITradeBBSEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITradeBBSEditDlg.h"
#include "LocalInput.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUITradeBBSEditDlg::CUITradeBBSEditDlg()
{
	m_pEditTitle		= nullptr;
	m_pEditPrice		= nullptr;
	m_pEditExplanation	= nullptr;

	m_pBtn_Ok			= nullptr;
	m_pBtn_Cancel		= nullptr;
}

CUITradeBBSEditDlg::~CUITradeBBSEditDlg()
{

}

std::string CUITradeBBSEditDlg::GetTradeTitle()
{
	if(m_pEditTitle)
		return m_pEditTitle->GetString();
	return "";
}

std::string CUITradeBBSEditDlg::GetTradeExplanation()
{
	if(m_pEditExplanation)
		return m_pEditExplanation->GetString();
	return "";
}

int	CUITradeBBSEditDlg::GetPrice()
{
	if(m_pEditPrice)
		return atoi(m_pEditPrice->GetString().c_str());

	return 0;
}

void CUITradeBBSEditDlg::ShowWindow(int iID, CN3UIBase *pParent)
{
	CN3UIBase::ShowWindow(iID, pParent);
}

bool CUITradeBBSEditDlg::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pEditTitle, GetChildByID<CN3UIEdit>("edit_name"));
	N3_VERIFY_UI_COMPONENT(m_pEditPrice, GetChildByID<CN3UIEdit>("edit_price"));
	N3_VERIFY_UI_COMPONENT(m_pEditExplanation, GetChildByID<CN3UIEdit>("edit_memo"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Ok, GetChildByID<CN3UIButton>("btn_Ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel, GetChildByID<CN3UIButton>("btn_Cancel"));

	m_pEditTitle->SetMaxString(18);
	m_pEditPrice->SetMaxString(8);
	m_pEditExplanation->SetMaxString(40);

	return true;
}

bool CUITradeBBSEditDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if(pSender == m_pBtn_Ok)
		{
			if(m_pParentUI) m_pParentUI->CallBackProc(m_iChildID, 1);
			this->SetVisible(false);
		}
		else if(pSender == m_pBtn_Cancel)
		{
			if(m_pParentUI) m_pParentUI->CallBackProc(m_iChildID, 2);
			this->SetVisible(false);
		}
	}

	return true;
}

void CUITradeBBSEditDlg::SetVisible(bool bVisible)
{
	if(bVisible)
	{
		if(m_pEditTitle)
		{
			m_pEditTitle->SetString("");
			m_pEditTitle->SetFocus();
		}
		if(m_pEditPrice)		m_pEditPrice->SetString("");
		if(m_pEditExplanation)	m_pEditExplanation->SetString("");
	}
	else
	{
		if(m_pEditTitle)		m_pEditTitle->SetString("");
		if(m_pEditPrice)		m_pEditPrice->SetString("");
		if(m_pEditExplanation)	m_pEditExplanation->SetString("");
		if(m_pEditTitle)		m_pEditTitle->KillFocus();
		if(m_pEditPrice)		m_pEditPrice->KillFocus();
		if(m_pEditExplanation)	m_pEditExplanation->KillFocus();
	}
	CN3UIBase::SetVisible(bVisible);
}

bool CUITradeBBSEditDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtn_Cancel, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_RETURN:
		ReceiveMessage(m_pBtn_Ok, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_TAB:
		{
			if(m_pEditTitle->HaveFocus())
				m_pEditPrice->SetFocus();
			else if(m_pEditPrice->HaveFocus())
				m_pEditExplanation->SetFocus();
			else if(m_pEditExplanation->HaveFocus())
				m_pEditTitle->SetFocus();
		}
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UITradeBBSEditDlg.cpp =====

// ===== BEGIN WarFare/UITradeBBSEditDlg.h =====
#line 1 "WarFare/UITradeBBSEditDlg.h"
﻿// UITradeBBSEditDlg.h: interface for the CUITradeBBSEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRADEBBSEDITDLG_H__3AEA6C66_D30B_421A_BA47_DD907AD094F3__INCLUDED_)
#define AFX_UITRADEBBSEDITDLG_H__3AEA6C66_D30B_421A_BA47_DD907AD094F3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUITradeBBSEditDlg : public CN3UIBase
{
protected:
	class CN3UIEdit*		m_pEditTitle;
	class CN3UIEdit*		m_pEditPrice;
	class CN3UIEdit*		m_pEditExplanation;
	class CN3UIButton*		m_pBtn_Ok;
	class CN3UIButton*		m_pBtn_Cancel;

public:
	bool OnKeyPress(int iChar) override;
	void SetVisible(bool bVisible) override;
	void ShowWindow(int iID = -1, CN3UIBase* pParent = nullptr) override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	std::string GetTradeTitle();
	std::string GetTradeExplanation();
	int			GetPrice();

	CUITradeBBSEditDlg();
	~CUITradeBBSEditDlg() override;
};

#endif // !defined(AFX_UITRADEBBSEDITDLG_H__3AEA6C66_D30B_421A_BA47_DD907AD094F3__INCLUDED_)

// ===== END WarFare/UITradeBBSEditDlg.h =====

// ===== BEGIN WarFare/UITradeBBSSelector.cpp =====
#line 1 "WarFare/UITradeBBSSelector.cpp"
﻿// UITradeBBSSelector.cpp: implementation of the CUITradeBBSSelector class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITradeBBSSelector.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "UITradeSellBBS.h"
#include "LocalInput.h"
#include "UIManager.h"

#include <N3Base/N3UIButton.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUITradeBBSSelector::CUITradeBBSSelector()
{
	m_pBtn_BBSSell		= nullptr;
	m_pBtn_BBSBuy		= nullptr;
	m_pBtn_BBSCancel	= nullptr;
}

CUITradeBBSSelector::~CUITradeBBSSelector()
{

}

bool CUITradeBBSSelector::ReceiveMessage(CN3UIBase *pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if(pSender == m_pBtn_BBSSell)
		{
			MsgSend_OpenTradeSellBBS();
			SetVisible(false);
			return true;
		}
		else if(pSender == m_pBtn_BBSBuy)
		{
			MsgSend_OpenTradeBuyBBS();
			SetVisible(false);
			return true;
		}
		else if(pSender == m_pBtn_BBSCancel)
		{
			SetVisible(false);
			return true;
		}
	}
	return true;
}

bool CUITradeBBSSelector::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_BBSSell, GetChildByID<CN3UIButton>("btn_sell"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_BBSBuy, GetChildByID<CN3UIButton>("btn_buy"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_BBSCancel, GetChildByID<CN3UIButton>("btn_cancel"));

	return true;
}

void CUITradeBBSSelector::MsgSend_OpenTradeSellBBS()
{
	uint8_t byBuff[5];		// 패킷 버퍼..
	int iOffset=0;		// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);		
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_BBS_OPEN);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TRADE_BBS_SELL);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUITradeBBSSelector::MsgSend_OpenTradeBuyBBS()
{
	uint8_t byBuff[5];		// 패킷 버퍼..
	int iOffset=0;		// 패킷 오프셋..

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);		
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_BBS_OPEN);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TRADE_BBS_BUY);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

bool CUITradeBBSSelector::OnKeyPress(int iChar)
{
	switch(iChar)
	{
	case DIK_ESCAPE:
		SetVisible(false);
		return true;
	}

	return CN3UIBase::OnKeyPress(iChar);
}

void CUITradeBBSSelector::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

// ===== END WarFare/UITradeBBSSelector.cpp =====

// ===== BEGIN WarFare/UITradeBBSSelector.h =====
#line 1 "WarFare/UITradeBBSSelector.h"
﻿// UITradeBBSSelector.h: interface for the CUITradeBBSSelector class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRADEBBSSELECTOR_H__034D575A_E014_4C70_ABD5_EE647725A1DF__INCLUDED_)
#define AFX_UITRADEBBSSELECTOR_H__034D575A_E014_4C70_ABD5_EE647725A1DF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#define TRADE_BBS_SELL		1
#define TRADE_BBS_BUY		2
#define TRADE_BBS_CANCEL	3

class CUITradeBBSSelector : public CN3UIBase
{
protected:
	CN3UIButton*	m_pBtn_BBSSell;
	CN3UIButton*	m_pBtn_BBSBuy;
	CN3UIButton*	m_pBtn_BBSCancel;

public:
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iChar) override;
	void MsgSend_OpenTradeBuyBBS();
	void MsgSend_OpenTradeSellBBS();
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;

	CUITradeBBSSelector();
	~CUITradeBBSSelector() override;
};

#endif // !defined(AFX_UITRADEBBSSELECTOR_H__034D575A_E014_4C70_ABD5_EE647725A1DF__INCLUDED_)

// ===== END WarFare/UITradeBBSSelector.h =====

// ===== BEGIN WarFare/UITradeEditDlg.cpp =====
#line 1 "WarFare/UITradeEditDlg.cpp"
﻿// UITradeEditDlg.cpp: implementation of the CUITradeEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITradeEditDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "UIImageTooltipDlg.h"
#include "UIInventory.h"
#include "SubProcPerTrade.h"
#include "UIPerTradeDlg.h"
#include "text_resources.h"

#include <N3Base/N3UIEdit.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUITradeEditDlg::CUITradeEditDlg()
{
	m_pSubProcPerTrade = nullptr;
	m_pArea = nullptr;
	m_pImageOfIcon = nullptr;
}

CUITradeEditDlg::~CUITradeEditDlg()
{

}

///////////////////////////////////////////////////////////////////////

void CUITradeEditDlg::Release()
{
	CN3UIBase::Release();
}

int	CUITradeEditDlg::GetQuantity() // "edit_trade" Edit Control 에서 정수값을 얻오온다..
{
	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));

	return atoi(pEdit->GetString().c_str());
}

void CUITradeEditDlg::SetQuantity(int iQuantity) // "edit_trade" Edit Control 에서 정수값을 문자열로 세팅한다..
{
	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));

	std::string buff = std::to_string(iQuantity);
	pEdit->SetString(buff);
}

bool CUITradeEditDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if(nullptr == pSender) return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender->m_szID == "btn_ok")
			m_pSubProcPerTrade->ItemCountEditOK();

		if(pSender->m_szID == "btn_cancel")
			m_pSubProcPerTrade->ItemCountEditCancel();
	}

	return true;
}

void CUITradeEditDlg::Open(bool bCountGold)
{
	std::string szMsg;
	if (bCountGold)
		szMsg = fmt::format_text_resource(IDS_EDIT_BOX_GOLD);
	else
		szMsg = fmt::format_text_resource(IDS_EDIT_BOX_COUNT);

	CN3UIString* pString = nullptr;
	N3_VERIFY_UI_COMPONENT(pString, GetChildByID<CN3UIString>("String_PersonTradeEdit_Msg"));
	__ASSERT(pString, "NULL UI Component!!");
	if (pString)
		pString->SetString(szMsg);

	SetVisible(true);

	CN3UIEdit* pEdit = nullptr;
	N3_VERIFY_UI_COMPONENT(pEdit, GetChildByID<CN3UIEdit>("edit_trade"));
	if(pEdit) pEdit->SetFocus();

	RECT rc, rcThis;
	int iCX, iCY;

	this->SetQuantity(0);

	rc = CGameProcedure::s_pProcMain->m_pSubProcPerTrade->m_pUIPerTradeDlg->GetRegion();
	iCX = (rc.right+rc.left)/2;
	iCY = (rc.bottom+rc.top)/2;
	rcThis = GetRegion();
	SetPos(iCX-(rcThis.right-rcThis.left)/2, iCY-(rcThis.bottom-rcThis.top)/2);
}

void CUITradeEditDlg::Close()
{
	SetVisible(false);

	CN3UIEdit* pEdit = GetFocusedEdit();
	if (pEdit) pEdit->KillFocus();
}


// ===== END WarFare/UITradeEditDlg.cpp =====

// ===== BEGIN WarFare/UITradeEditDlg.h =====
#line 1 "WarFare/UITradeEditDlg.h"
﻿// UITradeEditDlg.h: interface for the CUITradeEditDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRADEEDITDLG_H__347A4D3E_DC71_4F03_8070_946095EB8120__INCLUDED_)
#define AFX_UITRADEEDITDLG_H__347A4D3E_DC71_4F03_8070_946095EB8120__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

//////////////////////////////////////////////////////////////////////

class CSubProcPerTrade;
class CUITradeEditDlg : public CN3UIBase  
{
public:
	CSubProcPerTrade*	m_pSubProcPerTrade;
	CN3UIArea*			m_pArea;
	CN3UIImage*			m_pImageOfIcon;

public:
	CUITradeEditDlg();
	virtual ~CUITradeEditDlg();

	int					GetQuantity();
	void				SetQuantity(int iQuantity); // "edit_trade" Edit Control 에서 정수값을 문자열로 세팅한다..

	virtual void		Release();
	virtual bool		ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg);

	void				Open(bool bCountGold);
	void				Close();
};

#endif // !defined(AFX_UITRADEEDITDLG_H__347A4D3E_DC71_4F03_8070_946095EB8120__INCLUDED_)

// ===== END WarFare/UITradeEditDlg.h =====

// ===== BEGIN WarFare/UITradeExplanation.cpp =====
#line 1 "WarFare/UITradeExplanation.cpp"
﻿// UITradeExplanation.cpp: implementation of the CUITradeExplanation class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITradeExplanation.h"
#include "UITradeSellBBS.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUITradeExplanation::CUITradeExplanation()
{
	m_pBtn_PageUp		= nullptr;
	m_pBtn_PageDown		= nullptr;	
	m_pBtn_Close		= nullptr;
	m_pText_Explanation = nullptr;
	
	m_szExplanation		= "";
	m_iCurSel			= 0;
}

CUITradeExplanation::~CUITradeExplanation()
{

}

void CUITradeExplanation::SetExplanation(int iCurSel, std::string szExplanation)
{
	m_szExplanation = szExplanation;
	m_iCurSel		= iCurSel;
	if(m_pText_Explanation)
	{
		m_pText_Explanation->SetString(m_szExplanation);
	}
}

bool CUITradeExplanation::ReceiveMessage(CN3UIBase *pSender, uint32_t dwMsg)
{
	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		if(pSender == m_pBtn_PageUp)
		{
			if(m_pParentUI)
			{
				m_pParentUI->CallBackProc(m_iChildID,1);
			}
		}
		else if(pSender == m_pBtn_PageDown)
		{
			if(m_pParentUI)
			{
				m_pParentUI->CallBackProc(m_iChildID,2);
			}
		}
		else if(pSender == m_pBtn_Close)
		{
			SetVisible(false);
		}
	}

	return true;
}

bool CUITradeExplanation::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_PageUp, GetChildByID<CN3UIButton>("btn_pageup"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_PageDown, GetChildByID<CN3UIButton>("btn_pagedown"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close, GetChildByID<CN3UIButton>("btn_close"));
	N3_VERIFY_UI_COMPONENT(m_pText_Explanation, GetChildByID<CN3UIString>("Text_Title"));

	return true;
}

bool CUITradeExplanation::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_PRIOR:
		ReceiveMessage(m_pBtn_PageUp, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_NEXT:
		ReceiveMessage(m_pBtn_PageDown, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtn_Close, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UITradeExplanation.cpp =====

// ===== BEGIN WarFare/UITradeExplanation.h =====
#line 1 "WarFare/UITradeExplanation.h"
﻿// UITradeExplanation.h: interface for the CUITradeExplanation class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRADEEXPLANATION_H__DFFA77BD_3013_4389_84CB_EB1DFAD7F3FA__INCLUDED_)
#define AFX_UITRADEEXPLANATION_H__DFFA77BD_3013_4389_84CB_EB1DFAD7F3FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

class CUITradeExplanation : public CN3UIBase  
{
protected:
	class CN3UIButton*		m_pBtn_PageUp;
	class CN3UIButton*		m_pBtn_PageDown;
	class CN3UIButton*		m_pBtn_Close;
	class CN3UIString*		m_pText_Explanation;

	std::string m_szExplanation;
	int			m_iCurSel;

public:
	bool OnKeyPress(int iKey) override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void SetExplanation(int iCurSel, std::string szExplanation);

	CUITradeExplanation();
	~CUITradeExplanation() override;
};

#endif // !defined(AFX_UITRADEEXPLANATION_H__DFFA77BD_3013_4389_84CB_EB1DFAD7F3FA__INCLUDED_)

// ===== END WarFare/UITradeExplanation.h =====

// ===== BEGIN WarFare/UITradeSellBBS.cpp =====
#line 1 "WarFare/UITradeSellBBS.cpp"
﻿// UITradeSellBBS.cpp: implementation of the CUITradeSellBBS class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITradeSellBBS.h"
#include "GameProcMain.h"
#include "UITradeBBSEditDlg.h"
#include "PlayerMySelf.h"
#include "UIManager.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "text_resources.h"

#include <N3Base/N3UIList.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIString.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

#define CHILD_UI_SELL_MSG			1
#define CHILD_UI_TRADE_MSG			2
#define CHILD_UI_EXPLANATION_EDIT	3
#define CHILD_UI_EXPLANATION		4

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
#define TRADE_BBS_MAXSTRING	69
#define TRADE_BBS_MAX_LINE	23

CUITradeSellBBS::CUITradeSellBBS()
{
//	m_pList_Infos			= nullptr;
	m_pBtn_PageUp			= nullptr;
	m_pBtn_PageDown			= nullptr;
	m_pBtn_Refresh			= nullptr;
	m_pBtn_Close			= nullptr;
	m_pBtn_Register			= nullptr;
	m_pBtn_RegisterCancel	= nullptr;
	m_pBtn_Whisper			= nullptr;
	m_pBtn_Trade			= nullptr;

	m_pImage_Sell			= nullptr;
	m_pImage_Buy			= nullptr;
	m_pImage_Sell_Title		= nullptr;
	m_pImage_Buy_Title		= nullptr;

	m_pString_Page			= nullptr;

	m_byBBSKind				= 0;
	m_iCurPage				= 0;
	m_iMaxPage				= 0;
	m_bProcessing			= false;
	m_fTime					= 0.0f;
	m_iCurIndex				= -1;
}

CUITradeSellBBS::~CUITradeSellBBS()
{
	m_Datas.clear();
}

bool CUITradeSellBBS::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_PageUp, GetChildByID<CN3UIButton>("btn_page_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_PageDown, GetChildByID<CN3UIButton>("btn_page_down"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Refresh, GetChildByID<CN3UIButton>("btn_refresh"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close, GetChildByID<CN3UIButton>("btn_exit"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Register, GetChildByID<CN3UIButton>("btn_add"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Whisper, GetChildByID<CN3UIButton>("btn_whisper"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Trade, GetChildByID<CN3UIButton>("btn_sale"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_RegisterCancel, GetChildByID<CN3UIButton>("btn_delete"));

	N3_VERIFY_UI_COMPONENT(m_pImage_Sell, GetChildByID<CN3UIImage>("img_sell gold"));
	N3_VERIFY_UI_COMPONENT(m_pImage_Buy, GetChildByID<CN3UIImage>("img_buy gold"));
	N3_VERIFY_UI_COMPONENT(m_pImage_Sell_Title, GetChildByID<CN3UIImage>("img_sell"));
	N3_VERIFY_UI_COMPONENT(m_pImage_Buy_Title, GetChildByID<CN3UIImage>("img_buy"));

	N3_VERIFY_UI_COMPONENT(m_pString_Page, GetChildByID<CN3UIString>("string_page"));

	std::string szID;
	for(int i = 0; i < TRADE_BBS_MAXSTRING; i++)
	{
		szID = fmt::format("text_{:02}", i);
		N3_VERIFY_UI_COMPONENT(m_pText[i], GetChildByID<CN3UIString>(szID));
	}

	m_iCurPage = 0; // 현재 페이지..

	__TABLE_UI_RESRC*	pTblUI	= nullptr;
	pTblUI = CGameBase::s_pTbl_UI.Find(NATION_ELMORAD);

	m_MsgBox.LoadFromFile(pTblUI->szMessageBox);

	RECT rt = m_MsgBox.GetRegion();
	POINT pt;
	pt.x = (CN3Base::s_CameraData.vp.Width - (rt.right - rt.left)) / 2;
	pt.y = (CN3Base::s_CameraData.vp.Height - (rt.bottom - rt.top)) / 2;
	m_MsgBox.SetPos(pt.x, pt.y);

	m_UIExplanation.LoadFromFile(pTblUI->szTradeMemolist);

	rt = m_UIExplanation.GetRegion();
	pt.x = (CN3Base::s_CameraData.vp.Width - (rt.right - rt.left)) / 2;
	pt.y = (CN3Base::s_CameraData.vp.Height - (rt.bottom - rt.top)) / 2;
	m_UIExplanation.SetPos(pt.x, pt.y);

	return true;
}

bool CUITradeSellBBS::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	int iID = -1;
	if( dwMsg == UIMSG_BUTTON_CLICK )
	{
		if(pSender == m_pBtn_Refresh)
		{
			float fTime = CN3Base::TimeGet();
			if( fTime - m_fTime < 3.0f )
				return true;//너무 자주 새데이터 요청을 못하게 함 3초에 한번정도로 제약을 둠.
			m_fTime = fTime;

			this->MsgSend_RefreshData(m_iCurPage);
		}
		else if(pSender == m_pBtn_PageUp)
		{
			int iCurPage = m_iCurPage;
			iCurPage--;
			if(iCurPage >= 0)
			{
				this->MsgSend_RefreshData(iCurPage);
			}
		}
		else if(pSender == m_pBtn_PageDown)
		{
			int iCurPage = m_iCurPage;
			iCurPage++;
			if(iCurPage < m_iMaxPage)
			{
				this->MsgSend_RefreshData(iCurPage);
			}
		}
		else if(pSender == m_pBtn_Close)
		{
			m_iCurPage = 0;
			m_fTime = 0.0f;
			this->SetVisible(false);
		}
		else if(pSender == m_pBtn_Register)
		{
			m_pBtn_Register->SetState(UI_STATE_BUTTON_NORMAL);
			OnButtonRegister();
		}
		else if(pSender == m_pBtn_RegisterCancel)
		{
			OnButtonRegisterCancel();
		}
		else if(pSender == m_pBtn_Whisper)
		{
			OnButtonWhisper();
		}
		else if(pSender == m_pBtn_Trade)
		{
			m_pBtn_Trade->SetState(UI_STATE_BUTTON_NORMAL);
			if(m_bProcessing == false)
				OnButtonTrade();
		}
	}
	else if( dwMsg == UIMSG_STRING_LCLICK )
	{
		if(SelectedString(pSender, iID))
		{
			m_iCurIndex = iID;
		}
	}
	else if( dwMsg == UIMSG_STRING_LDCLICK )
	{
		OnListExplanation();
	}

	return true;
}

void CUITradeSellBBS::MsgRecv_TradeBBS(Packet& pkt)
{
	m_bProcessing	= false;

	uint8_t bySubType	= pkt.read<uint8_t>();
	uint8_t byBBSKind	= pkt.read<uint8_t>();
	uint8_t byResult	= pkt.read<uint8_t>();

	if (byResult != 0x01)
	{
		uint8_t bySubResult = pkt.read<uint8_t>();
		if (bySubType == N3_SP_TYPE_BBS_OPEN)
		{
			std::string szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL6);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff0000);
		}
		else if (bySubType == N3_SP_TYPE_REGISTER)
		{
			std::string szMsg;

			switch (bySubResult)
			{
				case 1://1: 일반적인 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL1);
					break;

				case 2://2: 돈이 없어서 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL2);
					break;

				case 3://3: 항목이 없어서 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL4);
					break;
			}

			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff0000);
		}
		else if (bySubType == N3_SP_TYPE_REGISTER_CANCEL)
		{
			std::string szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL3);
			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff0000);
		}
		else if (bySubType == N3_SP_TYPE_BBS_DATA)
		{
		}
		else if (bySubType == N3_SP_TYPE_BBS_TRADE)
		{
			std::string szMsg;

			switch (bySubResult)
			{
				case 1://1: 일반적인 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL5);
					break;
				case 2://2: 돈이 없어서 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL2);
					break;
				case 3://3: 항목이 없어서 실패
					szMsg = fmt::format_text_resource(IDS_TRADE_BBS_FAIL4);
					break;
			}

			CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff0000);
		}
		return; //실패했다면
	}

	if (bySubType == N3_SP_TYPE_BBS_OPEN)
	{
		if (!IsVisible()) SetVisible(true);

		if (byBBSKind == N3_SP_TRADE_BBS_BUY)
		{
			m_byBBSKind = N3_SP_TRADE_BBS_BUY;

			if (m_pImage_Sell != nullptr)
				m_pImage_Sell->SetVisible(false);

			if (m_pImage_Buy != nullptr)
				m_pImage_Buy->SetVisible(true);

			if (m_pImage_Sell_Title != nullptr)
				m_pImage_Sell_Title->SetVisible(false);

			if (m_pImage_Buy_Title != nullptr)
				m_pImage_Buy_Title->SetVisible(true);
		}
		else
		{
			m_byBBSKind = N3_SP_TRADE_BBS_SELL;

			if (m_pImage_Sell != nullptr)
				m_pImage_Sell->SetVisible(true);

			if (m_pImage_Buy != nullptr)
				m_pImage_Buy->SetVisible(false);

			if (m_pImage_Sell_Title != nullptr)
				m_pImage_Sell_Title->SetVisible(true);

			if (m_pImage_Buy_Title != nullptr)
				m_pImage_Buy_Title->SetVisible(false);
		}
	}
	else if (bySubType == N3_SP_TYPE_BBS_TRADE)
	{
		CGameProcedure::s_pProcMain->MsgSend_PerTradeBBSReq(m_ITSB.szID, m_ITSB.sID);
		SetVisible(false);
		return;
	}

	MsgRecv_RefreshData(pkt);
}

void CUITradeSellBBS::MsgRecv_RefreshData(Packet& pkt)
{
	int iLen;
	m_Datas.clear();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++ )
	{
		__InfoTradeSellBBS Info;
		Info.sID = pkt.read<int16_t>();
		iLen = pkt.read<int16_t>();
		if(iLen>0) pkt.readString(Info.szID, iLen);
		iLen = pkt.read<int16_t>();
		if(iLen>0) pkt.readString(Info.szTitle, iLen);
		iLen = pkt.read<int16_t>();
		if(iLen>0) pkt.readString(Info.szExplanation, iLen);
		Info.iPrice = pkt.read<uint32_t>();		//아이템에 제시한 가격
		Info.sIndex = pkt.read<int16_t>();		//등록된 인덱스

		if( Info.sID != -1 )
			m_Datas.push_back(Info);
	}

	int16_t sPage = pkt.read<int16_t>();
	int16_t sTotal = pkt.read<int16_t>();

	//TRACE("TRADE_BBS_PAGE:%d\n",sPage);
	m_iCurPage = sPage;
	m_iMaxPage = sTotal / TRADE_BBS_MAX_LINE;
	if( (sTotal % TRADE_BBS_MAX_LINE) > 0 )
		m_iMaxPage++;

	RefreshPage();
}

void CUITradeSellBBS::RefreshPage()
{
	if(m_pString_Page) m_pString_Page->SetStringAsInt(m_iCurPage+1); // 페이지 표시..

	ResetContent();

	it_TradeSellBBS it = m_Datas.begin();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++ )
	{
		if(it==m_Datas.end()) break;

		__InfoTradeSellBBS ITSB = (*it);
		SetContentString(i, ITSB.szID.c_str(), ITSB.iPrice, ITSB.szTitle.c_str());
		it++;
	}
}

void CUITradeSellBBS::MsgSend_RefreshData(int iCurPage)
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	uint8_t byBuff[10];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);	
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_BBS_DATA);
	CAPISocket::MP_AddByte(byBuff, iOffset, m_byBBSKind);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iCurPage);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;

}

void CUITradeSellBBS::MsgSend_Register()
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면
	if(!CGameProcedure::s_pProcMain->m_pUITradeBBSEdit) return;
	int16_t sLen = 0;
	std::string szTitle;
	std::string szExplanation;
	int	iPrice = 0;

	szTitle			= CGameProcedure::s_pProcMain->m_pUITradeBBSEdit->GetTradeTitle();
	szExplanation	= CGameProcedure::s_pProcMain->m_pUITradeBBSEdit->GetTradeExplanation();
	iPrice			= CGameProcedure::s_pProcMain->m_pUITradeBBSEdit->GetPrice();

	sLen = 15;
	sLen += (int16_t)szTitle.size();
	sLen += (int16_t)szExplanation.size();

	uint8_t* byBuff = new uint8_t[sLen];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);	
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_REGISTER);
	CAPISocket::MP_AddByte(byBuff, iOffset, m_byBBSKind);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szTitle.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szTitle);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szExplanation.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szExplanation);
	CAPISocket::MP_AddDword(byBuff, iOffset, iPrice);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
	delete [] byBuff;
}

void CUITradeSellBBS::MsgSend_RegisterCancel(int16_t sIndex)
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	uint8_t byBuff[10];
	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_REGISTER_CANCEL);
	CAPISocket::MP_AddByte(byBuff, iOffset, m_byBBSKind);
	CAPISocket::MP_AddShort(byBuff, iOffset, sIndex);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
}

void CUITradeSellBBS::CallBackProc(int iID, uint32_t dwFlag)
{
	//TRACE("OnButton ID:%d Btn %d\n",iID, dwFlag);

	if(iID == CHILD_UI_SELL_MSG)
	{
		if(dwFlag == 1)//OK
		{
			if(CGameProcedure::s_pProcMain->m_pUITradeBBSEdit)
				CGameProcedure::s_pProcMain->m_pUITradeBBSEdit->ShowWindow(CHILD_UI_EXPLANATION_EDIT,this);
		}
	}
	else if(iID == CHILD_UI_TRADE_MSG)
	{
		if(dwFlag == 1)//OK
		{
			MsgSend_PerTrade();
		}
	}
	else if(iID == CHILD_UI_EXPLANATION_EDIT)
	{
		if(dwFlag == 1)//OK
		{
			MsgSend_Register();
		}
		else //CANCEL
		{
		}
	}
	else if(iID == CHILD_UI_EXPLANATION)
	{
		if(dwFlag == 1)//pageup
		{
			RefreshExplanation(true);
		}
		else if(dwFlag == 2)//pagedown
		{
			RefreshExplanation(false);
		}
	}

}

void CUITradeSellBBS::OnButtonRegister()
{
	// 전에 보낸 패킷 응답이 없으면
	if (m_bProcessing)
		return;

	if (m_byBBSKind == N3_SP_TRADE_BBS_BUY)
	{
		std::string szMsg = fmt::format_text_resource(IDS_TRADE_BBS_BUY_REGISTER, 500);

		m_MsgBox.SetBoxStyle(MB_YESNO);
		m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
		m_MsgBox.SetTitle("");
		m_MsgBox.SetText(szMsg);
		m_MsgBox.ShowWindow(CHILD_UI_SELL_MSG, this);
	}
	else
	{
		std::string szMsg = fmt::format_text_resource(IDS_TRADE_BBS_SELL_REGISTER, 1000);

		m_MsgBox.SetBoxStyle(MB_YESNO);
		m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
		m_MsgBox.SetTitle("");
		m_MsgBox.SetText(szMsg);
		m_MsgBox.ShowWindow(CHILD_UI_SELL_MSG, this);
	}
}

void CUITradeSellBBS::OnButtonRegisterCancel()
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면
	if(m_iCurIndex <= -1) return;

	it_TradeSellBBS it = m_Datas.begin();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoTradeSellBBS ITSB = (*it);

			if (lstrcmpi(ITSB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) == 0)
			{//자기것만 등록해제하게..
				MsgSend_RegisterCancel(ITSB.sIndex);
				break;
			}
			else if (CGameProcedure::s_pProcMain->s_pPlayer->m_InfoBase.iAuthority == AUTHORITY_MANAGER)
			{//운영자에게는 해제 권한을 준다...(도배나 욕설등의 게시물 삭제를 위해서...)
				MsgSend_RegisterCancel(ITSB.sIndex);
				break;
			}
		}
	}//for(
}

void CUITradeSellBBS::OnButtonWhisper()
{
	if(m_iCurIndex <= -1) return;

	it_TradeSellBBS it = m_Datas.begin();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoTradeSellBBS ITSB = (*it);
			//나 자신에게는 귓속말을 못하게 한다...
			if (lstrcmpi(ITSB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) != 0)
				CGameProcedure::s_pProcMain->MsgSend_ChatSelectTarget(ITSB.szID);
			break;
		}
	}
}

void CUITradeSellBBS::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CUITradeSellBBS::OnButtonTrade()
{
	if(m_bProcessing) return; //전에 보낸 패킷 응답이 없으면

	if(m_iCurIndex <= -1) return;

	it_TradeSellBBS it = m_Datas.begin();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoTradeSellBBS ITSB = (*it);

			if (lstrcmpi(ITSB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) != 0)
			{
				std::string szMsg = fmt::format_text_resource(IDS_TRADE_BBS_PER_TRADE, 5000);

				m_ITSB = ITSB;
				m_MsgBox.SetBoxStyle(MB_YESNO);
				m_MsgBox.m_eBehavior = BEHAVIOR_NOTHING;
				m_MsgBox.SetTitle("");
				m_MsgBox.SetText(szMsg);
				m_MsgBox.ShowWindow(CHILD_UI_TRADE_MSG, this);
				break;
			}
		}
	}//for(
}

void CUITradeSellBBS::RefreshExplanation(bool bPageUp)
{
	if (m_iCurIndex <= -1)
		return;

	if (bPageUp)
	{
		if (m_iCurIndex == 0)
			return;

		--m_iCurIndex;
	}
	else
	{
		if ((m_iCurIndex + 1) >= static_cast<int>(m_Datas.size()))
			return;

		++m_iCurIndex;
	}

	auto it = m_Datas.begin();

	for (int i = 0; i < TRADE_BBS_MAX_LINE; i++, it++)
	{
		if (it == m_Datas.end())
			break;

		if (i == m_iCurIndex)
		{
			__InfoTradeSellBBS ITSB = (*it);

			m_UIExplanation.SetExplanation(m_iCurIndex, ITSB.szExplanation);
			break;
		}
	}//for(
}

void CUITradeSellBBS::OnListExplanation()
{
	if(m_iCurIndex <= -1) return;

	it_TradeSellBBS it = m_Datas.begin();

	for( int i = 0 ; i < TRADE_BBS_MAX_LINE ; i++, it++ )
	{
		if( it == m_Datas.end() ) break;
		if( i == m_iCurIndex )
		{
			__InfoTradeSellBBS ITSB = (*it);

			m_UIExplanation.ShowWindow(CHILD_UI_EXPLANATION, this);
			m_UIExplanation.SetExplanation(m_iCurIndex,ITSB.szExplanation);
			break;
		}
	}//for(
}

void CUITradeSellBBS::MsgSend_PerTrade()
{
	// 전에 보낸 패킷 응답이 없으면
	if (m_bProcessing)
		return;

	// 자기 자신에게는 거래를 하지 못하게
	if (lstrcmpi(m_ITSB.szID.c_str(), CGameBase::s_pPlayer->m_InfoBase.szID.c_str()) == 0)
		return;

	uint8_t byBuff[10];

	int iOffset=0;

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_MARKET_BBS);	
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TYPE_BBS_TRADE);
	CAPISocket::MP_AddByte(byBuff, iOffset, m_byBBSKind);
	CAPISocket::MP_AddShort(byBuff, iOffset, m_ITSB.sIndex);
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);

	m_bProcessing = true;
}

bool CUITradeSellBBS::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		SetVisible(false);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUITradeSellBBS::RenderSelectContent()
{
	if(!IsVisible())	return;
	if(m_iCurIndex < 0)	return;
	if(m_iCurIndex >= TRADE_BBS_MAX_LINE) return;

	RECT rc, rc1;
	if(m_pText[m_iCurIndex])
	{
		rc = m_pText[m_iCurIndex]->GetRegion();
		if(m_pText[m_iCurIndex + TRADE_BBS_MAX_LINE*2])
		{
			rc1 = m_pText[m_iCurIndex + TRADE_BBS_MAX_LINE*2]->GetRegion();
			rc.right = rc1.right;
		}
	}
	else
		return;

	__VertexTransformedColor vLines[5];
	vLines[0].Set((float)rc.left, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[1].Set((float)rc.right, (float)rc.top, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[2].Set((float)rc.right, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[3].Set((float)rc.left, (float)rc.bottom, UI_DEFAULT_Z, UI_DEFAULT_RHW, 0xff00ff00);
	vLines[4] = vLines[0];

	DWORD dwZ, dwFog, dwAlpha, dwCOP, dwCA1, dwSrcBlend, dwDestBlend, dwVertexShader, dwAOP, dwAA1;
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ZENABLE, &dwZ);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_FOGENABLE, &dwFog);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlpha);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_SRCBLEND, &dwSrcBlend);
	CN3Base::s_lpD3DDev->GetRenderState(D3DRS_DESTBLEND, &dwDestBlend);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLOROP, &dwCOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_COLORARG1, &dwCA1);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAOP, &dwAOP);
	CN3Base::s_lpD3DDev->GetTextureStageState(0, D3DTSS_ALPHAARG1, &dwAA1);
	CN3Base::s_lpD3DDev->GetFVF(&dwVertexShader);

	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);

	CN3Base::s_lpD3DDev->SetFVF(FVF_TRANSFORMEDCOLOR);
	CN3Base::s_lpD3DDev->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, vLines, sizeof(__VertexTransformedColor));
	
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ZENABLE, dwZ);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_FOGENABLE, dwFog);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_ALPHABLENDENABLE, dwAlpha);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_SRCBLEND, dwSrcBlend);
	CN3Base::s_lpD3DDev->SetRenderState(D3DRS_DESTBLEND, dwDestBlend);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLOROP, dwCOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_COLORARG1, dwCA1);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAOP, dwAOP);
	CN3Base::s_lpD3DDev->SetTextureStageState(0, D3DTSS_ALPHAARG1, dwAA1);
	CN3Base::s_lpD3DDev->SetFVF(dwVertexShader);
}

bool CUITradeSellBBS::SelectedString(CN3UIBase* pSender, int& iID)
{
	int iIndex = -1;
	for (int i = 0; i < TRADE_BBS_MAXSTRING; i++)
	{
		if (pSender == m_pText[i])
		{
			iIndex = i % TRADE_BBS_MAX_LINE;
			if (iIndex >= static_cast<int>(m_Datas.size()))
				return false;

			iID = iIndex;
			return true;
		}
	}

	return false;
}

void CUITradeSellBBS::Render()
{
	if(!IsVisible()) return;

	CN3UIBase::Render();
	RenderSelectContent();
}

void CUITradeSellBBS::ResetContent()
{
	if(m_Datas.size()>0)
		m_iCurIndex = 0;
	else
		m_iCurIndex = -1;

	for(int i = 0 ; i < TRADE_BBS_MAXSTRING ; i++)
	{
		if(m_pText[i])
		{
			m_pText[i]->SetString("");
			m_pText[i]->SetColor(0xffffffff);
		}
	}
}

void CUITradeSellBBS::SetContentString(int iIndex, std::string szID, int iPrice, std::string szTitle)
{
	std::string szGold = fmt::format_text_resource(IDS_TOOLTIP_GOLD);

	if(m_pText[iIndex])
		m_pText[iIndex]->SetString(szID);

	if(m_pText[iIndex + TRADE_BBS_MAX_LINE])
		m_pText[iIndex + TRADE_BBS_MAX_LINE]->SetString(szTitle);

	if (m_pText[iIndex + TRADE_BBS_MAX_LINE * 2] != nullptr)
	{
		std::string buff = fmt::format("{} {}", iPrice, szGold);
		m_pText[iIndex + TRADE_BBS_MAX_LINE * 2]->SetString(buff);
	}
}

// ===== END WarFare/UITradeSellBBS.cpp =====

// ===== BEGIN WarFare/UITradeSellBBS.h =====
#line 1 "WarFare/UITradeSellBBS.h"
﻿// UITradeSellBBS.h: interface for the CUITradeSellBBS class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRADESELLBBS_H__2550F618_FFC2_425A_B66A_2275D1E1FCAB__INCLUDED_)
#define AFX_UITRADESELLBBS_H__2550F618_FFC2_425A_B66A_2275D1E1FCAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/N3UIBase.h>

#include "UIMessageBox.h"
#include "UITradeExplanation.h"

#include <list>

struct __InfoTradeSellBBS // 파티 지원 게시판 구조체..
{
	std::string szID;			// 파티 이름 문자열
	std::string szTitle;		// 제목
	std::string szExplanation;	// 설명
	int			iPrice;			// 가격
	int16_t		sIndex;			// 등록 인덱스
	int16_t		sID;			// 캐릭터 아이디

	void Init()
	{
		szID			= "";
		szTitle			= "";
		szExplanation	= "";
		iPrice			= 0;
		sIndex			= -1;
	};

	__InfoTradeSellBBS()
	{
		this->Init();
	}
};

typedef std::list<__InfoTradeSellBBS>::iterator it_TradeSellBBS;

class Packet;
class CUITradeSellBBS : public CN3UIBase  
{
protected:
//	class CN3UIList*		m_pList_Infos;

	class CN3UIButton*		m_pBtn_PageUp;
	class CN3UIButton*		m_pBtn_PageDown;
	class CN3UIButton*		m_pBtn_Refresh;
	class CN3UIButton*		m_pBtn_Close;
	class CN3UIButton*		m_pBtn_Register;
	class CN3UIButton*		m_pBtn_RegisterCancel;
	class CN3UIButton*		m_pBtn_Whisper;
	class CN3UIButton*		m_pBtn_Trade;

	class CN3UIImage*		m_pImage_Sell;
	class CN3UIImage*		m_pImage_Buy;
	class CN3UIImage*		m_pImage_Sell_Title;
	class CN3UIImage*		m_pImage_Buy_Title;

	class CN3UIString*		m_pString_Page;
	class CN3UIString*		m_pText[69];

	CUIMessageBox			m_MsgBox;
	CUITradeExplanation		m_UIExplanation;

	std::list<__InfoTradeSellBBS>	m_Datas;
	__InfoTradeSellBBS				m_ITSB;

	int			m_iCurPage; // 현재 페이지..
	int			m_iMaxPage;	// 총 페이지..
	bool		m_bProcessing;
	uint8_t		m_byBBSKind;
	int			m_iCurIndex;
	float		m_fTime;

public:
	void SetContentString();
	void ResetContent();
	void Render() override;
	void RenderSelectContent();
	bool OnKeyPress(int iKey) override;
	void MsgSend_PerTrade();
	void OnListExplanation();
	void RefreshExplanation(bool bPageUp = true);
	void OnButtonTrade();
	void OnButtonWhisper();
	void OnButtonRegisterCancel();
	void OnButtonRegister();
	void CallBackProc(int iID, uint32_t dwFlag) override;
	void MsgSend_RegisterCancel(int16_t sIndex);
	void MsgSend_Register();
	void MsgSend_RefreshData(int iCurPage);
	void RefreshPage();
	bool SelectedString(CN3UIBase* pSender, int& iID);
	void MsgRecv_RefreshData(Packet& pkt);
	void MsgRecv_TradeBBS(Packet& pkt);
	void SetContentString(int iIndex, std::string szID, int iPrice, std::string szTitle);

	void SetBBSKind(uint8_t byKind){ m_byBBSKind = byKind; }
	bool Load(File& file) override;
	bool ReceiveMessage(class CN3UIBase* pSender, uint32_t dwMsg) override;
	void SetVisible(bool bVisible) override;

	CUITradeSellBBS();
	~CUITradeSellBBS() override;
};

#endif // !defined(AFX_UITRADESELLBBS_H__2550F618_FFC2_425A_B66A_2275D1E1FCAB__INCLUDED_)

// ===== END WarFare/UITradeSellBBS.h =====

// ===== BEGIN WarFare/UITransactionDlg.cpp =====
#line 1 "WarFare/UITransactionDlg.cpp"
﻿// UITransactionDlg.cpp: implementation of the CUITransactionDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UITransactionDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "UIImageTooltipDlg.h"
#include "UIInventory.h"
#include "UIManager.h"
#include "UIMsgBoxOkCancel.h"
#include "PlayerMySelf.h"
#include "CountableItemEditDlg.h"
#include "UIHotKeyDlg.h"
#include "UISkillTreeDlg.h"
#include "text_resources.h"

#include <N3Base/LogWriter.h>

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

static constexpr int CHILD_UI_MSGBOX_OKCANCEL = 1;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUITransactionDlg::CUITransactionDlg()
{
	m_iCurPage = 0;

	for (int j = 0; j < MAX_ITEM_TRADE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
			m_pMyTrade[j][i] = nullptr;
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		m_pMyTradeInv[i] = nullptr;

	m_pUITooltipDlg = nullptr;
	m_pStrMyGold    = nullptr;

	m_pUIInn		= nullptr;
	m_pUIBlackSmith	= nullptr;
	m_pUIStore		= nullptr;
	m_pText_Weight	= nullptr;

	m_pUIMsgBoxOkCancel = nullptr;

	m_bVisible		= false;
}

CUITransactionDlg::~CUITransactionDlg()
{
	Release();
}

void CUITransactionDlg::Release()
{
	for (int j = 0; j < MAX_ITEM_TRADE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
		{
			delete m_pMyTrade[j][i];
			m_pMyTrade[j][i] = nullptr;
		}
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		delete m_pMyTradeInv[i];
		m_pMyTradeInv[i] = nullptr;
	}

	m_pUITooltipDlg = nullptr;
	m_pStrMyGold    = nullptr;

	m_pUIInn		= nullptr;
	m_pUIBlackSmith	= nullptr;
	m_pUIStore		= nullptr;
	m_pText_Weight	= nullptr;

	m_pUIMsgBoxOkCancel = nullptr;

	CN3UIBase::Release();
}

void CUITransactionDlg::Render()
{
	if (!m_bVisible) return;	// 보이지 않으면 자식들을 render하지 않는다.

	int i;

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	m_pUITooltipDlg->DisplayTooltipsDisable();

	bool bTooltipRender = false;
	__IconItemSkill* spItem = nullptr;

	for(UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if ( (GetState() == UI_STATE_ICON_MOVING) && (pChild->UIType() == UI_TYPE_ICON) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) &&
			((CN3UIIcon *)pChild == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon) )	continue;
			pChild->Render();
		if ( (GetState() == UI_STATE_COMMON_NONE) && 
				(pChild->UIType() == UI_TYPE_ICON) && (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT) )
		{
			bTooltipRender = true;
			spItem = GetHighlightIconItem( (CN3UIIcon* )pChild );
		}
	}

	// 갯수 표시되야 할 아이템 갯수 표시..
	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pMyTradeInv[i] && ( (m_pMyTradeInv[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || 
			(m_pMyTradeInv[i]->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) ) )
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
			{
				if ( (GetState() == UI_STATE_ICON_MOVING) && (m_pMyTradeInv[i] == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				{
					pStr->SetVisible(false);
				}
				else
				{
					if ( m_pMyTradeInv[i]->pUIIcon->IsVisible() )
					{
						pStr->SetVisible(true);
						pStr->SetStringAsInt(m_pMyTradeInv[i]->iCount);
						pStr->Render();
					}
					else
					{
						pStr->SetVisible(false);
					}
				}
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if(pStr) 
				pStr->SetVisible(false);
		}
	}

	if ( (GetState() == UI_STATE_ICON_MOVING) && (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) ) 
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->Render();		

	if ( bTooltipRender && spItem )
	{
		e_UIWND_DISTRICT eUD = GetWndDistrict(spItem);
		switch (eUD)
		{
			case UIWND_DISTRICT_TRADE_NPC:
				m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem, true, true );
				break;
			case UIWND_DISTRICT_TRADE_MY:
				m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem, true, false );
				break;
		}
	}
}

void CUITransactionDlg::InitIconWnd(e_UIWND eWnd)
{
	__TABLE_UI_RESRC* pTbl = CGameBase::s_pTbl_UI.Find(CGameBase::s_pPlayer->m_InfoBase.eNation);

	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(pTbl->szItemInfo);
	m_pUITooltipDlg->InitPos();
	m_pUITooltipDlg->SetVisible(false);

	m_pUIMsgBoxOkCancel = new CUIMsgBoxOkCancel();
	m_pUIMsgBoxOkCancel->Init(this);
	m_pUIMsgBoxOkCancel->LoadFromFile(pTbl->szMsgBoxOkCancel);

	int iX = (m_rcRegion.right + m_rcRegion.left) / 2;
	int iY = (m_rcRegion.bottom + m_rcRegion.top) / 2;
	m_pUIMsgBoxOkCancel->SetPos(
		iX - (m_pUIMsgBoxOkCancel->GetWidth() / 2),
		iY - (m_pUIMsgBoxOkCancel->GetHeight() / 2) - 80);
	m_pUIMsgBoxOkCancel->SetVisible(false);

	CN3UIWndBase::InitIconWnd(eWnd);

	N3_VERIFY_UI_COMPONENT(m_pStrMyGold,	GetChildByID<CN3UIString>("string_item_name"));
	if(m_pStrMyGold) m_pStrMyGold->SetString("0");

	N3_VERIFY_UI_COMPONENT(m_pUIInn,		GetChildByID<CN3UIImage>("img_inn"));
	N3_VERIFY_UI_COMPONENT(m_pUIBlackSmith,	GetChildByID<CN3UIImage>("img_blacksmith"));
	N3_VERIFY_UI_COMPONENT(m_pUIStore,		GetChildByID<CN3UIImage>("img_store"));
	N3_VERIFY_UI_COMPONENT(m_pText_Weight,	GetChildByID<CN3UIString>("text_weight"));
}

void CUITransactionDlg::InitIconUpdate()
{
	CN3UIArea* pArea;
	float fUVAspect = (float)45.0f/(float)64.0f;
	int i, j;

	for( j = 0; j < MAX_ITEM_TRADE_PAGE; j++ )
		for( i = 0; i < MAX_ITEM_TRADE; i++ )
		{
			if ( m_pMyTrade[j][i] != nullptr )
			{
				m_pMyTrade[j][i]->pUIIcon = new CN3UIIcon;
				m_pMyTrade[j][i]->pUIIcon->Init(this);
				m_pMyTrade[j][i]->pUIIcon->SetTex(m_pMyTrade[j][i]->szIconFN);
				m_pMyTrade[j][i]->pUIIcon->SetUVRect(0,0,fUVAspect,fUVAspect);
				m_pMyTrade[j][i]->pUIIcon->SetUIType(UI_TYPE_ICON);
				m_pMyTrade[j][i]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, i);
				if ( pArea )
				{
					m_pMyTrade[j][i]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyTrade[j][i]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
		}
}

__IconItemSkill* CUITransactionDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	int i;
	for( i = 0; i < MAX_ITEM_TRADE; i++ )
	{
		if ( (m_pMyTrade[m_iCurPage][i] != nullptr) && (m_pMyTrade[m_iCurPage][i]->pUIIcon == pUIIcon) )
			return m_pMyTrade[m_iCurPage][i];
	}

	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( (m_pMyTradeInv[i] != nullptr) && (m_pMyTradeInv[i]->pUIIcon == pUIIcon) ) 
			return m_pMyTradeInv[i];
	}

	return nullptr;
}

void CUITransactionDlg::EnterTransactionState()
{
	int i, j;
	for( j = 0; j < MAX_ITEM_TRADE_PAGE; j++ )
		for( i = 0; i < MAX_ITEM_TRADE; i++ )
		{
			if ( m_pMyTrade[j][i] != nullptr )
			{
				if ( m_pMyTrade[j][i]->pUIIcon )
				{
					RemoveChild(m_pMyTrade[j][i]->pUIIcon);
					m_pMyTrade[j][i]->pUIIcon->Release();
					delete m_pMyTrade[j][i]->pUIIcon;
					m_pMyTrade[j][i]->pUIIcon = nullptr;
				}
				delete m_pMyTrade[j][i];	
				m_pMyTrade[j][i] = nullptr;
			}
		}

	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( m_pMyTradeInv[i] != nullptr )
		{
			if ( m_pMyTradeInv[i]->pUIIcon )
			{
				RemoveChild(m_pMyTradeInv[i]->pUIIcon);
				m_pMyTradeInv[i]->pUIIcon->Release();
				delete m_pMyTradeInv[i]->pUIIcon;
				m_pMyTradeInv[i]->pUIIcon = nullptr;
			}
			delete m_pMyTradeInv[i];	
			m_pMyTradeInv[i] = nullptr;
		}
	}

	std::string szIconFN;
	__IconItemSkill*	spItem = nullptr;
	__TABLE_ITEM_BASIC*	pItem = nullptr;													// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_EXT*	pItemExt = nullptr;

	int iOrg = m_iTradeID/1000;
	int iExt = m_iTradeID%1000;
	int iSize = CGameBase::s_pTbl_Items_Basic.GetSize();

	j = 0;	int k = 0;
	for ( i = 0; i < iSize; i++ )
	{
		if (k >= MAX_ITEM_TRADE)
		{
			j++;	k = 0;
		}

		if (j >= MAX_ITEM_TRADE_PAGE)
			break;

		pItem = CGameBase::s_pTbl_Items_Basic.GetIndexedData(i);
		if(nullptr == pItem) // 아이템이 없으면..
		{
			__ASSERT(0, "아이템 포인터 테이블에 없음!!");
			CLogWriter::Write("CUITransactionDlg::EnterTransactionState - Invalid Item ID : {}, {}", iOrg, iExt);
			continue;
		}

		if(pItem->byExtIndex < 0 || pItem->byExtIndex >= MAX_ITEM_EXTENSION)
			continue;

		if (pItem->bySellGroup != iOrg)
			continue;

		pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iExt);	
		if(nullptr == pItemExt) // 아이템이 없으면..
		{
			__ASSERT(0, "아이템 포인터 테이블에 없음!!");
			CLogWriter::Write("CUITransactionDlg::EnterTransactionState - Invalid Item ID : {}, {}", iOrg, iExt);
			continue;
		}

		if ( pItemExt->dwID != iExt )
			continue;

		e_PartPosition ePart;
		e_PlugPosition ePlug;
		e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug); // 아이템에 따른 파일 이름을 만들어서
		__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");

		spItem = new __IconItemSkill;
		spItem->pItemBasic	= pItem;
		spItem->pItemExt	= pItemExt;
		spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
		spItem->iCount		= 1;
		spItem->iDurability = pItem->siMaxDurability+pItemExt->siMaxDurability;

		m_pMyTrade[j][k] = spItem; 

		k++;
	}

	InitIconUpdate();
	m_iCurPage = 0;

	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
	if (pStr != nullptr)
		pStr->SetStringAsInt(m_iCurPage + 1);

	for( j = 0; j < MAX_ITEM_TRADE_PAGE; j++ )
	{
		if (j == m_iCurPage)
		{
			for( i = 0; i < MAX_ITEM_TRADE; i++ )
			{
				if ( m_pMyTrade[j][i] != nullptr )
					m_pMyTrade[j][i]->pUIIcon->SetVisible(true);
			}	
		}
		else
		{
			for( i = 0; i < MAX_ITEM_TRADE; i++ )
			{
				if ( m_pMyTrade[j][i] != nullptr )
					m_pMyTrade[j][i]->pUIIcon->SetVisible(false);
			}	
		}
	}

	ItemMoveFromInvToThis();

	GoldUpdate();

	switch ((int)(m_iTradeID/1000))
	{
		case 122:
		case 222:
			ShowTitle(UI_BLACKSMITH);
			break;
		default:
			ShowTitle(UI_STORE);
			break;
	}
}

void CUITransactionDlg::UpdateWeight(const std::string& szWeight)
{
	if (m_pText_Weight != nullptr)
		m_pText_Weight->SetString(szWeight);
}

void CUITransactionDlg::GoldUpdate()
{
	if (m_pStrMyGold == nullptr)
		return;

	std::string strGold = CGameBase::FormatNumber(CGameBase::s_pPlayer->m_InfoExt.iGold);
	m_pStrMyGold->SetString(strGold);
}

std::string CUITransactionDlg::GetItemName(const __IconItemSkill* spItem)
{
	std::string name;

	if ((e_ItemAttrib) (spItem->pItemExt->byMagicOrRare) != ITEM_ATTRIB_UNIQUE)
	{
		name = spItem->pItemBasic->szName;

		if ((spItem->pItemExt->dwID % 10) != 0)
			name += fmt::format("(+{})", spItem->pItemExt->dwID % 10);
	}
	else
	{
		name = spItem->pItemExt->szHeader;
	}

	return name;
}

void CUITransactionDlg::ItemMoveFromInvToThis()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if(!pInven) return;

	int i;
	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		m_pMyTradeInv[i] = nullptr;
	}

	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if(pInven->m_pMyInvWnd[i])
		{
			__IconItemSkill* spItem = pInven->m_pMyInvWnd[i];
			spItem->pUIIcon->SetParent(this);

			pInven->m_pMyInvWnd[i] = nullptr;
			CN3UIArea* pArea;

			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, i);
			if ( pArea )
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}			

			m_pMyTradeInv[i] = spItem;
		}
	}
}

void CUITransactionDlg::LeaveTransactionState()
{
	if ( IsVisible() )
		SetVisible(false);

	if (GetState() == UI_STATE_ICON_MOVING)
		IconRestore();
	SetState(UI_STATE_COMMON_NONE);
	CN3UIWndBase::AllHighLightIconFree();

	// 이 윈도우의 inv 영역의 아이템을 이 인벤토리 윈도우의 inv영역으로 옮긴다..	
	ItemMoveFromThisToInv();

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg) CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();
	if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg) CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CUITransactionDlg::ItemMoveFromThisToInv()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if(!pInven) return;

	int i;
	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if(m_pMyTradeInv[i])
		{
			__IconItemSkill* spItem = m_pMyTradeInv[i];
			spItem->pUIIcon->SetParent(pInven);

			m_pMyTradeInv[i] = nullptr;

			CN3UIArea* pArea;

			pArea = pInven->GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
			if ( pArea )
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}			

			pInven->m_pMyInvWnd[i] = spItem;
		}
	}
}

void CUITransactionDlg::ItemCountOK()
{
	int iGold = CN3UIWndBase::s_pCountableItemEdit->GetQuantity();
	__IconItemSkill* spItem, *spItemNew = nullptr;
	__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);
	int iWeight;

	switch (CN3UIWndBase::s_pCountableItemEdit->GetCallerWndDistrict())
	{
		case UIWND_DISTRICT_TRADE_NPC:		// 사는 경우..
			spItem = m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			switch (spItem->pItemBasic->byContable)
			{
				case UIITEM_TYPE_ONLYONE:
				case UIITEM_TYPE_SOMOONE:
					iWeight = spItem->pItemBasic->siWeight;

					// 무게 체크..
					if ( (pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{	 
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);	
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
						return;
					}
					break;

				case UIITEM_TYPE_COUNTABLE:
					if ( iGold <= 0 ) return;
					if ( iGold > UIITEM_COUNT_MANY ) 
					{
						std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_BUY_FAIL);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					if (spItem->iCount + iGold > UIITEM_COUNT_MANY)
					{
						std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					if ( (iGold * spItem->pItemBasic->iPrice)	> pInfoExt->iGold )	
					{
						std::string szMsg = fmt::format_text_resource(IDS_COUNTABLE_ITEM_BUY_NOT_ENOUGH_MONEY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					iWeight = iGold * spItem->pItemBasic->siWeight;

					if ( (pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{	 
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);	
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
						return;
					}
					break;

				case UIITEM_TYPE_COUNTABLE_SMALL:
					if ( iGold <= 0 ) return;

					if ( iGold > UIITEM_COUNT_FEW ) 
					{
						std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_BUY_FAIL);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					if (spItem->iCount + iGold > UIITEM_COUNT_FEW)
					{
						std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					if ( (iGold * spItem->pItemBasic->iPrice)	> pInfoExt->iGold )	
					{
						std::string szMsg = fmt::format_text_resource(IDS_COUNTABLE_ITEM_BUY_NOT_ENOUGH_MONEY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);				
						return;
					}

					iWeight = iGold * spItem->pItemBasic->siWeight;

					// 무게 체크..
					if ( (pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);	
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	
						return;
					}
					break;
			}

			s_bWaitFromServer = true;

			if ( m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] )	// 해당 위치에 아이콘이 있으면..
			{
				//  숫자 업데이트..
				m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount += iGold;

				// 표시는 아이콘 렌더링할때.. Inventory의 Render에서..
				// 서버에게 보냄..
				SendToServerBuyMsg(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder, iGold);
			}
			else
			{
				spItem = m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
				CN3UIArea* pArea;
				spItemNew				= new __IconItemSkill;
				spItemNew->pItemBasic	= spItem->pItemBasic;
				spItemNew->pItemExt		= spItem->pItemExt;
				spItemNew->szIconFN		= spItem->szIconFN; // 아이콘 파일 이름 복사..
				spItemNew->iCount		= iGold;
				spItemNew->iDurability  = spItem->pItemBasic->siMaxDurability+spItem->pItemExt->siMaxDurability;

				// 아이콘 리소스 만들기..
				spItemNew->pUIIcon = new CN3UIIcon;
				float fUVAspect		= (float)45.0f/(float)64.0f;
				spItemNew->pUIIcon->Init(this); 
				spItemNew->pUIIcon->SetTex(spItemNew->szIconFN);
				spItemNew->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
				spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
				spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
				spItemNew->pUIIcon->SetVisible(true);
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
				if ( pArea )
				{
					spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
					spItemNew->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemNew;

				// 서버에게 보냄..
				SendToServerBuyMsg(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
					CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder, iGold);
			}
			// Sound..
			if (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic) PlayItemSound(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic);
			break;

		case UIWND_DISTRICT_TRADE_MY:		//  파는 경우..
			spItem = m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			if ( iGold <= 0 ) return;
			if ( iGold > spItem->iCount ) return;

			s_bWaitFromServer = true;

			if ( (spItem->iCount - iGold) > 0 )
			{	
				//  숫자 업데이트..
				spItem->iCount -= iGold;
			}
			else
			{
				spItem->pUIIcon->SetVisible(false);
			}

			// 서버에게 보냄..
			SendToServerSellMsg(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
				CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iGold);
			break;
	}

	CN3UIWndBase::s_pCountableItemEdit->Close();
}

void CUITransactionDlg::ItemCountCancel()
{
	// Sound..
	if (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic) PlayItemSound(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic);

	// 취소..
	s_bWaitFromServer				= false;
	s_sRecoveryJobInfo.pItemSource	= nullptr;
	s_sRecoveryJobInfo.pItemTarget	= nullptr;

	s_pCountableItemEdit->Close();
}

void CUITransactionDlg::CallBackProc(int iID, uint32_t dwFlag)
{
	if (iID == CHILD_UI_MSGBOX_OKCANCEL)
	{
		if (dwFlag == CUIMsgBoxOkCancel::CALLBACK_OK)
			OnConfirm();
		else if (dwFlag == CUIMsgBoxOkCancel::CALLBACK_CANCEL)
			OnCancel();
	}
}

void CUITransactionDlg::OnConfirm()
{
	__IconItemSkill* spItem = nullptr;

	switch (s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict)
	{
		case UIWND_DISTRICT_TRADE_MY: // sell, inventory to NPC
			spItem = m_pMyTradeInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			s_bWaitFromServer = true;

			spItem->pUIIcon->SetVisible(false);
			
			SendToServerSellMsg(s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID +
				s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
				s_sRecoveryJobInfo.UIWndSourceStart.iOrder, 
				s_sRecoveryJobInfo.pItemSource->iCount);
			break;
	}
}

void CUITransactionDlg::OnCancel()
{
	s_sRecoveryJobInfo.pItemSource = nullptr;
	s_sRecoveryJobInfo.pItemTarget = nullptr;
}

void CUITransactionDlg::SendToServerSellMsg(int itemID, byte pos, int iCount)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_TRADE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TRADE_SELL);
	CAPISocket::MP_AddDword(byBuff, iOffset, itemID);	
	CAPISocket::MP_AddByte(byBuff, iOffset, pos);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iCount);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUITransactionDlg::SendToServerBuyMsg(int itemID, byte pos, int iCount)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_TRADE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TRADE_BUY);
	CAPISocket::MP_AddDword(byBuff, iOffset, m_iTradeID);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)m_iNpcID);
	CAPISocket::MP_AddDword(byBuff, iOffset, itemID);	
	CAPISocket::MP_AddByte(byBuff, iOffset, pos);
	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)iCount);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUITransactionDlg::SendToServerMoveMsg(int itemID, byte startpos, byte destpos)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_ITEM_TRADE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_TRADE_MOVE);
	CAPISocket::MP_AddDword(byBuff, iOffset, itemID);	
	CAPISocket::MP_AddByte(byBuff, iOffset, startpos);
	CAPISocket::MP_AddByte(byBuff, iOffset, destpos);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUITransactionDlg::ReceiveResultTradeMoveSuccess()
{
	s_bWaitFromServer = false;
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUITransactionDlg::ReceiveResultTradeMoveFail()
{
	CN3UIArea* pArea;
	s_bWaitFromServer = false;

	__IconItemSkill *spItemSource = nullptr, *spItemTarget = nullptr;
	spItemSource = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;
	spItemTarget = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;

	if (spItemSource)
	{
		pArea = nullptr;
		pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
		if ( pArea )
		{
			spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
			spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
		}

		m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemSource;
	}

	if (spItemTarget)
	{
		pArea = nullptr;
		pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
		if ( pArea )
		{
			spItemTarget->pUIIcon->SetRegion(pArea->GetRegion());
			spItemTarget->pUIIcon->SetMoveRect(pArea->GetRegion());
		}

		m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemTarget;
	}
	else
	{
		m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
	}

	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUITransactionDlg::ReceiveItemDropByTradeSuccess()
{
	// 원래 아이템을 삭제해야 하지만.. 되살릴 방법이 없기 때문에 원래 위치로 옮기고.. 
	__IconItemSkill* spItem;
	spItem = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;

	CN3UIArea* pArea;

	pArea = CGameProcedure::s_pProcMain->m_pUIInventory->GetChildAreaByiOrder(UI_AREA_TYPE_INV, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
	if ( pArea )
	{
		spItem->pUIIcon->SetRegion(pArea->GetRegion());
		spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
	}

	// Invisible로 하고 삭제는 서버가 성공을 줄때 한다..
	spItem->pUIIcon->SetVisible(false);

	if( (spItem->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || (spItem->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
	{
		// 활이나 물약등 아이템인 경우..
		spItem->pUIIcon->SetVisible(true);
	}
}

bool CUITransactionDlg::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
// Temp Define 
#define FAIL_RETURN {	\
		CN3UIWndBase::AllHighLightIconFree();	\
		SetState(UI_STATE_COMMON_NONE);	\
		return false;	\
	}

	CN3UIArea* pArea;
	e_UIWND_DISTRICT eUIWnd = UIWND_DISTRICT_UNKNOWN;
	if (!m_bVisible) return false;

	// 내가 가졌던 아이콘이 아니면..
	if ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd != m_eUIWnd )
		FAIL_RETURN
	if ( (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict != UIWND_DISTRICT_TRADE_NPC) &&
			(CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict != UIWND_DISTRICT_TRADE_MY) )
		FAIL_RETURN

	// 내가 가졌던 아이콘이면.. npc영역인지 검사한다..
	int i, iDestiOrder = -1; bool bFound = false;
	for( i = 0; i < MAX_ITEM_TRADE; i++ )
	{
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, i);
		if ( (pArea) && (pArea->IsIn(ptCur.x, ptCur.y)) )
		{
			bFound = true;
			eUIWnd = UIWND_DISTRICT_TRADE_NPC;
			break;
		}
	}

	if (!bFound)
	{
		for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
		{
			pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, i);
			if ( (pArea) && (pArea->IsIn(ptCur.x, ptCur.y)) )
			{
				bFound = true;
				eUIWnd = UIWND_DISTRICT_TRADE_MY;
				break;
			}
		}
	}

	if (!bFound)	FAIL_RETURN

	// 같은 윈도우 내에서의 움직임은 fail!!!!!
	if ( (eUIWnd == CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict) && (eUIWnd != UIWND_DISTRICT_TRADE_MY))	FAIL_RETURN

	// 본격적으로 Recovery Info를 활용하기 시작한다..
	// 먼저 WaitFromServer를 On으로 하고.. Select Info를 Recovery Info로 복사.. 이때 Dest는 팰요없다..
	if ( spItem != CN3UIWndBase::s_sSelectedIconInfo.pItemSelect )
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect = spItem;

	s_bWaitFromServer									= true;
	s_sRecoveryJobInfo.pItemSource						= s_sSelectedIconInfo.pItemSelect;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= s_sSelectedIconInfo.UIWndSelect.UIWnd;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict	= s_sSelectedIconInfo.UIWndSelect.UIWndDistrict;
	s_sRecoveryJobInfo.UIWndSourceStart.iOrder			= s_sSelectedIconInfo.UIWndSelect.iOrder;
	s_sRecoveryJobInfo.pItemTarget						= nullptr;

	s_sRecoveryJobInfo.UIWndSourceEnd.UIWnd				= UIWND_TRANSACTION;
	s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict		= eUIWnd;

	for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, i);
		if ( pArea && pArea->IsIn(ptCur.x, ptCur.y) )
		{
			iDestiOrder = i;
			break;
		}
	}

	switch (CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict)
	{
		case UIWND_DISTRICT_TRADE_NPC:
			if (eUIWnd == UIWND_DISTRICT_TRADE_MY)		// 사는 경우..
			{
				if( (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) ||
					(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
				{
					// 활이나 물약등 아이템인 경우..
					// 면저 인벤토리에 해당 아이콘이 있는지 알아본다..
					bFound = false;

					for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
					{
						if ( bFound )
						{
							CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
							break;
						}

						if( (m_pMyTradeInv[i]) && (m_pMyTradeInv[i]->pItemBasic->dwID == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID) &&
							(m_pMyTradeInv[i]->pItemExt->dwID == CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemExt->dwID) )
						{
							bFound = true;
							iDestiOrder = i;
						}
					}

					// 못찾았으면.. 
					if ( !bFound )
					{
						if ( m_pMyTradeInv[iDestiOrder] )	// 해당 위치에 아이콘이 있으면..
						{
							// 인벤토리 빈슬롯을 찾아 들어간다..
							for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
							{
								if ( !m_pMyTradeInv[i] )
								{
									bFound = true;
									iDestiOrder = i;
									break;
								}
							}

							if ( !bFound )	// 빈 슬롯을 찾지 못했으면..
							{
								s_bWaitFromServer				= false;
								s_sRecoveryJobInfo.pItemSource	= nullptr;
								s_sRecoveryJobInfo.pItemTarget	= nullptr;
								FAIL_RETURN
							}
						}
					}

					s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
					s_bWaitFromServer							= false;

					s_pCountableItemEdit->Open(UIWND_TRANSACTION, s_sSelectedIconInfo.UIWndSelect.UIWndDistrict, false);
					FAIL_RETURN
				}
				else
				{
					__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

					// 매수가 X 갯수가 내가 가진 돈보다 많으면.. 그냥 리턴..
					if ( (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->iPrice)	> pInfoExt->iGold )	
					{
						std::string szMsg = fmt::format_text_resource(IDS_COUNTABLE_ITEM_BUY_NOT_ENOUGH_MONEY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	

						s_bWaitFromServer				= false;
						s_sRecoveryJobInfo.pItemSource	= nullptr;
						s_sRecoveryJobInfo.pItemTarget	= nullptr;
						FAIL_RETURN	
					}

					// 무게 체크..
					if ( (pInfoExt->iWeight + CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->siWeight) > pInfoExt->iWeightMax)
					{	 
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);	
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);	

						s_bWaitFromServer				= false;
						s_sRecoveryJobInfo.pItemSource	= nullptr;
						s_sRecoveryJobInfo.pItemTarget	= nullptr;
						FAIL_RETURN	
					}

					// 일반 아이템인 경우..
					if ( m_pMyTradeInv[iDestiOrder] )	// 해당 위치에 아이콘이 있으면..
					{
						// 인벤토리 빈슬롯을 찾아 들어간다..
						bFound = false;
						for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
						{
							if ( !m_pMyTradeInv[i] )
							{
								bFound = true;
								iDestiOrder = i;
								break;
							}
						}

						if ( !bFound )	// 빈 슬롯을 찾지 못했으면..
						{
							s_bWaitFromServer				= false;
							s_sRecoveryJobInfo.pItemSource	= nullptr;
							s_sRecoveryJobInfo.pItemTarget	= nullptr;
							FAIL_RETURN
						}

						CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
					}
					else
						CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;

					SendToServerBuyMsg(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
						CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, iDestiOrder, 
						CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->iCount);

					std::string szIconFN;
					e_PartPosition ePart;
					e_PlugPosition ePlug;
					
					__IconItemSkill* spItemTrade = m_pMyTrade[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					CGameBase::MakeResrcFileNameForUPC(spItemTrade->pItemBasic, spItemTrade->pItemExt, nullptr, &szIconFN, ePart, ePlug); // 아이템에 따른 파일 이름을 만들어서

					__IconItemSkill* spItemNew;
					spItemNew				= new __IconItemSkill;
					spItemNew->pItemBasic	= m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pItemBasic;
					spItemNew->pItemExt		= m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pItemExt;
					spItemNew->szIconFN		= szIconFN; // 아이콘 파일 이름 복사..
					spItemNew->iCount		= 1;
					spItemNew->iDurability	= m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pItemBasic->siMaxDurability
						+m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pItemExt->siMaxDurability;

					// 아이콘 리소스 만들기..
					spItemNew->pUIIcon = new CN3UIIcon;
					float fUVAspect		= (float)45.0f/(float)64.0f;
					spItemNew->pUIIcon->Init(this); 
					spItemNew->pUIIcon->SetTex(szIconFN);
					spItemNew->pUIIcon->SetUVRect(0,0, fUVAspect, fUVAspect);
					spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
					spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM|UISTYLE_ICON_CERTIFICATION_NEED);
					spItemNew->pUIIcon->SetVisible(true);
					pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, iDestiOrder);
					if ( pArea )
					{
						spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
						spItemNew->pUIIcon->SetMoveRect(pArea->GetRegion());
					}

					m_pMyTradeInv[iDestiOrder] = spItemNew;
					FAIL_RETURN
				}
			}
			else
			{
				s_bWaitFromServer				= false;
				s_sRecoveryJobInfo.pItemSource	= nullptr;
				s_sRecoveryJobInfo.pItemTarget	= nullptr;
				FAIL_RETURN					
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			if (eUIWnd == UIWND_DISTRICT_TRADE_NPC)		// 파는 경우..
			{
				s_bWaitFromServer = false;

				if (s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
					|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
				{
					// 활이나 물약등 아이템인 경우..
					s_pCountableItemEdit->Open(UIWND_TRANSACTION, s_sSelectedIconInfo.UIWndSelect.UIWndDistrict, false);
				}
				else
				{
					std::string strMessage = fmt::format_text_resource(IDS_TRANSACTION_OK_CANCEL_MESSAGE,
						GetItemName(s_sRecoveryJobInfo.pItemSource));

					m_pUIMsgBoxOkCancel->ShowWindow(CHILD_UI_MSGBOX_OKCANCEL, this);
					m_pUIMsgBoxOkCancel->SetText(strMessage);
				}

				FAIL_RETURN
			}
			else	
			{
				// 이동.. 
				__IconItemSkill *spItemSource, *spItemTarget = nullptr;
				spItemSource = CN3UIWndBase::s_sRecoveryJobInfo.pItemSource;

				pArea = nullptr;
				pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, iDestiOrder);
				if ( pArea )
				{
					spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
					spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder				= iDestiOrder;
				if ( m_pMyTradeInv[iDestiOrder] )	// 해당 위치에 아이콘이 있으면..
				{
					CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= m_pMyTradeInv[iDestiOrder];
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWnd			= UIWND_TRANSACTION;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_TRADE_MY;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetStart.iOrder		= iDestiOrder;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd			= UIWND_TRANSACTION;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict	= UIWND_DISTRICT_TRADE_MY;
					CN3UIWndBase::s_sRecoveryJobInfo.UIWndTargetEnd.iOrder			= 
						CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder;

					spItemTarget = CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget;

					pArea = nullptr;
					pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
					if ( pArea )
					{
						spItemTarget->pUIIcon->SetRegion(pArea->GetRegion());
						spItemTarget->pUIIcon->SetMoveRect(pArea->GetRegion());
					}
				}
				else
					CN3UIWndBase::s_sRecoveryJobInfo.pItemTarget					= nullptr;

				m_pMyTradeInv[iDestiOrder] = spItemSource;
				m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemTarget;

				SendToServerMoveMsg(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID+
						CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemExt->dwID, 
						CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, 
						iDestiOrder );
				//TRACE("Source %d, Target %d \n", CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder, iDestiOrder);
				FAIL_RETURN					
			}				
			break;
		}

	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);

	return false;
}

void CUITransactionDlg::ReceiveResultTradeFromServer(byte bResult, byte bType, int	iMoney)
{
	s_bWaitFromServer = false;
	__IconItemSkill* spItem = nullptr;
	__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);

	// 소스 영역이 UIWND_DISTRICT_TRADE_NPC 이면 아이템 사는거..
	switch ( CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict )
	{
		case UIWND_DISTRICT_TRADE_NPC:
			if ( bResult != 0x01 )	// 실패라면.. 
			{	
				if( (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) ||
					(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
				{
					int iGold = CN3UIWndBase::s_pCountableItemEdit->GetQuantity();

					if ( (m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount - iGold) > 0 )
					{	
						//  숫자 업데이트..
						m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount -= iGold;
					}
					else
					{
						// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
						__IconItemSkill* spItem;
						spItem = m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

						// 인벤토리에서도 지운다..
						m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

						// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
						RemoveChild(spItem->pUIIcon);

						// 아이콘 리소스 삭제...
						spItem->pUIIcon->Release();
						delete spItem->pUIIcon;
						spItem->pUIIcon = nullptr;
						delete spItem;
						spItem = nullptr;
					}
				}
				else
				{
					// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
					__IconItemSkill* spItem;
					spItem = m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

					// 인벤토리에서도 지운다..
					m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

					// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
					RemoveChild(spItem->pUIIcon);

					// 아이콘 리소스 삭제...
					spItem->pUIIcon->Release();
					delete spItem->pUIIcon;
					spItem->pUIIcon = nullptr;
					delete spItem;
					spItem = nullptr;
				}

				if (bType == 0x04)
				{
					std::string szMsg = fmt::format_text_resource(IDS_ITEM_TOOMANY_OR_HEAVY);
					CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
				}
			}
			else
			{
				pInfoExt->iGold = iMoney;

				CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
				GoldUpdate();
			}
			
			CN3UIWndBase::AllHighLightIconFree();
			SetState(UI_STATE_COMMON_NONE);
			break;

		case UIWND_DISTRICT_TRADE_MY:
			if ( bResult != 0x01 )	// 실패라면.. 
			{	
				if( (CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) ||
					(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL) )
				{
					int iGold = CN3UIWndBase::s_pCountableItemEdit->GetQuantity();

					if (m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible()) // 기존 아이콘이 보인다면..
					{
						// 숫자만 바꿔준다..
						m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount += iGold;
					}
					else
					{
						// 기존 아이콘이 안 보인다면..
						m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount = iGold;

						// 아이콘이 보이게..
						m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetVisible(true);
					}
				}
				else
				{
					// Invisible로 아쳬杉?Icon Visible로..					
					spItem = m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					spItem->pUIIcon->SetVisible(true);
				}
			}
			else
			{
				// 활이나 물약등 아이템인 경우 기존 아이콘이 안보인다면.. 아이템 삭제..
				if( ( ((CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE) || 
					(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL))
					&&	!m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible()) ||
					((CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE) &&
					(CN3UIWndBase::s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable != UIITEM_TYPE_COUNTABLE_SMALL)) )
				{
					// 아이템 삭제.. 현재 내 영역 윈도우만.. 
					__IconItemSkill* spItem;
					spItem = m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

					// 내 영역에서도 지운다..
					m_pMyTradeInv[CN3UIWndBase::s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

					// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
					RemoveChild(spItem->pUIIcon);

					// 아이콘 리소스 삭제...
					spItem->pUIIcon->Release();
					delete spItem->pUIIcon;
					spItem->pUIIcon = nullptr;
					delete spItem;
					spItem = nullptr;
				}

				// 성공이면.. 돈 업데이트..
				pInfoExt->iGold = iMoney;

				CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();
				GoldUpdate();
			}

			CN3UIWndBase::AllHighLightIconFree();
			SetState(UI_STATE_COMMON_NONE);
			break;
	}
}

void CUITransactionDlg::CancelIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUITransactionDlg::AcceptIconDrop(__IconItemSkill* spItem)
{
	CN3UIWndBase::AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUITransactionDlg::IconRestore()
{
	CN3UIArea* pArea;

	switch ( CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict )
	{
		case UIWND_DISTRICT_TRADE_NPC:
			if ( m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyTrade[m_iCurPage][CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			if ( m_pMyTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr )
			{
				pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder);
				if ( pArea )
				{
					m_pMyTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyTradeInv[CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;
	}
}

uint32_t CUITransactionDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible) return dwRet;
	if (s_bWaitFromServer) { dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);  return dwRet; }

	// 드래그 되는 아이콘 갱신..
	if ( (GetState() == UI_STATE_ICON_MOVING) && 
			(CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd == UIWND_TRANSACTION) )
	{
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
		CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
	}

	if (m_pChildUI != nullptr
		&& m_pChildUI->IsVisible())
		return m_pChildUI->MouseProc(dwFlags, ptCur, ptOld);

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

int CUITransactionDlg::GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist)
{
	int iReturn = -1;
	int i;

	switch ( eWndDist )
	{
		case UIWND_DISTRICT_TRADE_NPC:
			for( i = 0; i < MAX_ITEM_TRADE; i++ )
			{
				if ( (m_pMyTrade[m_iCurPage][i] != nullptr) && (m_pMyTrade[m_iCurPage][i] == spItem) )
					return i;
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			for( i = 0; i < MAX_ITEM_INVENTORY; i++ )
			{
				if ( (m_pMyTradeInv[i] != nullptr) && (m_pMyTradeInv[i] == spItem) )
					return i;
			}
			break;
	}

	return iReturn;
}

RECT CUITransactionDlg::GetSampleRect()
{
	RECT rect;
	CN3UIArea* pArea;
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	pArea = CN3UIWndBase::GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, 0);
	rect = pArea->GetRegion();
	float fWidth = (float)(rect.right - rect.left);
	float fHeight = (float)(rect.bottom - rect.top);
	fWidth *= 0.5f; fHeight *= 0.5f;
	rect.left = ptCur.x - (int)fWidth;  rect.right  = ptCur.x + (int)fWidth;
	rect.top  = ptCur.y - (int)fHeight; rect.bottom = ptCur.y + (int)fHeight;
	return rect;
}

e_UIWND_DISTRICT CUITransactionDlg::GetWndDistrict(__IconItemSkill* spItem)
{
	for( int i = 0; i < MAX_ITEM_TRADE; i++ )
	{
		if ( (m_pMyTrade[m_iCurPage][i] != nullptr) && (m_pMyTrade[m_iCurPage][i] == spItem) )
			return UIWND_DISTRICT_TRADE_NPC;
	}

	for(int i = 0; i < MAX_ITEM_INVENTORY; i++ )
	{
		if ( (m_pMyTradeInv[i] != nullptr) && (m_pMyTradeInv[i] == spItem) )
			return UIWND_DISTRICT_TRADE_MY;
	}
	return UIWND_DISTRICT_UNKNOWN;
}

bool CUITransactionDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
// Temp Define
#define FAIL_CODE {		\
				SetState(UI_STATE_COMMON_NONE);	\
				return false;	\
			}

	if(nullptr == pSender) return false;
	int i, j;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtnClose)
			LeaveTransactionState();

		CN3UIString* pStr;

		if (pSender == m_pBtnPageUp)
		{
			if (GetState() == UI_STATE_ICON_MOVING)
			{
				IconRestore();
				SetState(UI_STATE_COMMON_NONE);
			}

			SetState(UI_STATE_COMMON_NONE);
			AllHighLightIconFree();

			m_iCurPage--;
			if (m_iCurPage < 0)
				m_iCurPage = 0;

			N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
			if (pStr != nullptr)
				pStr->SetStringAsInt(m_iCurPage + 1);

			for (j = 0; j < MAX_ITEM_TRADE_PAGE; j++)
			{
				if (j == m_iCurPage)
				{
					for (i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyTrade[j][i] != nullptr)
							m_pMyTrade[j][i]->pUIIcon->SetVisible(true);
					}
				}
				else
				{
					for (i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyTrade[j][i] != nullptr)
							m_pMyTrade[j][i]->pUIIcon->SetVisible(false);
					}
				}
			}
		}
		else if (pSender == m_pBtnPageDown)
		{
			if (GetState() == UI_STATE_ICON_MOVING)
			{
				IconRestore();
				SetState(UI_STATE_COMMON_NONE);
			}

			SetState(UI_STATE_COMMON_NONE);
			AllHighLightIconFree();

			m_iCurPage++;
			if (m_iCurPage >= MAX_ITEM_TRADE_PAGE)
				m_iCurPage = MAX_ITEM_TRADE_PAGE - 1;

			N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
			if (pStr != nullptr)
				pStr->SetStringAsInt(m_iCurPage + 1);

			for (j = 0; j < MAX_ITEM_TRADE_PAGE; j++)
			{
				if (j == m_iCurPage)
				{
					for (i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyTrade[j][i] != nullptr)
							m_pMyTrade[j][i]->pUIIcon->SetVisible(true);
					}
				}
				else
				{
					for (i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyTrade[j][i] != nullptr)
							m_pMyTrade[j][i]->pUIIcon->SetVisible(false);
					}
				}
			}
		}
	}

	__IconItemSkill* spItem = nullptr;
	e_UIWND_DISTRICT eUIWnd;
	int iOrder;

	uint32_t dwBitMask = 0x000f0000;

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_DOWN_FIRST:
			CN3UIWndBase::AllHighLightIconFree();

			// Get Item..
			spItem = GetHighlightIconItem((CN3UIIcon* )pSender);

			// Save Select Info..
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWnd = UIWND_TRANSACTION;
			eUIWnd = GetWndDistrict(spItem);
			if ( eUIWnd == UIWND_DISTRICT_UNKNOWN )	FAIL_CODE
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = eUIWnd;
			iOrder = GetItemiOrder(spItem, eUIWnd);
			if ( iOrder == -1 )	FAIL_CODE
			CN3UIWndBase::s_sSelectedIconInfo.UIWndSelect.iOrder = iOrder;
			CN3UIWndBase::s_sSelectedIconInfo.pItemSelect = spItem;
			// Do Ops..
			((CN3UIIcon* )pSender)->SetRegion(GetSampleRect());
			((CN3UIIcon* )pSender)->SetMoveRect(GetSampleRect());
			// Sound..
			if (spItem) PlayItemSound(spItem->pItemBasic);
			break;

		case UIMSG_ICON_UP:
			// 아이콘 매니저 윈도우들을 돌아 다니면서 검사..
			if ( !CGameProcedure::s_pUIMgr->BroadcastIconDropMsg(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) )
				// 아이콘 위치 원래대로..
				IconRestore();
			// Sound..
			if (CN3UIWndBase::s_sSelectedIconInfo.pItemSelect) PlayItemSound(CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pItemBasic);
			break;

		case UIMSG_ICON_DOWN:
			if ( GetState()  == UI_STATE_ICON_MOVING )
			{
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
				CN3UIWndBase::s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
			}
			break;
	}

	return true;
}

bool CUITransactionDlg::OnMouseWheelEvent(
	short delta)
{
	if (delta > 0)
		ReceiveMessage(m_pBtnPageUp, UIMSG_BUTTON_CLICK);
	else
		ReceiveMessage(m_pBtnPageDown, UIMSG_BUTTON_CLICK);

	return true;
}

CN3UIBase* CUITransactionDlg::GetChildButtonByName(const std::string& szFN)
{
	for(UIListItor itor = m_Children.begin(); m_Children.end() != itor; ++itor)
	{
		CN3UIBase* pChild = (CN3UIBase* )(*itor);
		if ( (pChild->UIType() == UI_TYPE_BUTTON) && (szFN.compare(pChild->m_szID) == 0) )
			return pChild;
	}

	return nullptr;
}

void CUITransactionDlg::ShowTitle(e_NpcTrade eNT)
{
	m_pUIInn->SetVisible(false);
	m_pUIBlackSmith->SetVisible(false);
	m_pUIStore->SetVisible(false);

	switch (eNT)
	{
		case UI_BLACKSMITH:
			m_pUIBlackSmith->SetVisible(true);
			break;
		case UI_STORE:
			m_pUIStore->SetVisible(true);
			break;
		case UI_INN:
			m_pUIInn->SetVisible(true);
			break;
	}
}

//this_ui_add_start
void CUITransactionDlg::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
	{
		if(CN3UIWndBase::s_pCountableItemEdit && CN3UIWndBase::s_pCountableItemEdit->IsVisible())
			ItemCountCancel();

		if (m_pUIMsgBoxOkCancel != nullptr
			&& m_pUIMsgBoxOkCancel->IsVisible())
		{
			OnCancel();
			m_pUIMsgBoxOkCancel->SetVisible(false);
		}

		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
	}
}

void CUITransactionDlg::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	if(bWork && !bVisible)
	{
		if(CN3UIWndBase::s_pCountableItemEdit && CN3UIWndBase::s_pCountableItemEdit->IsVisible())
			ItemCountCancel();

		if (m_pUIMsgBoxOkCancel != nullptr
			&& m_pUIMsgBoxOkCancel->IsVisible())
		{
			OnCancel();
			m_pUIMsgBoxOkCancel->SetVisible(false);
		}

		if (GetState() == UI_STATE_ICON_MOVING)
			IconRestore();
		SetState(UI_STATE_COMMON_NONE);
		CN3UIWndBase::AllHighLightIconFree();

		// 이 윈도우의 inv 영역의 아이템을 이 인벤토리 윈도우의 inv영역으로 옮긴다..	
		ItemMoveFromThisToInv();

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg) CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();
		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg) CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
		if(m_pUITooltipDlg) m_pUITooltipDlg->DisplayTooltipsDisable();
	}
}

bool CUITransactionDlg::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtnClose, GetChildByID<CN3UIButton>("btn_close"));
	N3_VERIFY_UI_COMPONENT(m_pBtnPageUp, GetChildByID<CN3UIButton>("btn_page_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtnPageDown, GetChildByID<CN3UIButton>("btn_page_down"));

	return true;
}

bool CUITransactionDlg::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_PRIOR:
		ReceiveMessage(m_pBtnPageUp, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_NEXT:
		ReceiveMessage(m_pBtnPageDown, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtnClose, UIMSG_BUTTON_CLICK);
		if(m_pUITooltipDlg) m_pUITooltipDlg->DisplayTooltipsDisable();
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}
//this_ui_add_end

// ===== END WarFare/UITransactionDlg.cpp =====

// ===== BEGIN WarFare/UITransactionDlg.h =====
#line 1 "WarFare/UITransactionDlg.h"
﻿// UITransactionDlg.h: interface for the CUITransactionDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UITRANSACTIONDLG_H__42671245_FF4F_42FC_AF7B_DACEDA8734B7__INCLUDED_)
#define AFX_UITRANSACTIONDLG_H__42671245_FF4F_42FC_AF7B_DACEDA8734B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

enum e_NpcTrade {	UI_BLACKSMITH = 1, UI_STORE, UI_INN	};

//////////////////////////////////////////////////////////////////////

class CUIMsgBoxOkCancel;
class CUITransactionDlg : public CN3UIWndBase
{
	friend class CUIInventory;

public:
// 직접 접근해야 할 객체 참조 포인터
	__IconItemSkill*		m_pMyTrade[MAX_ITEM_TRADE_PAGE][MAX_ITEM_TRADE];
	__IconItemSkill*		m_pMyTradeInv[MAX_ITEM_INVENTORY];
	CN3UIString*			m_pStrMyGold;
	CN3UIString*			m_pText_Weight;

	int						m_iCurPage;
	int						m_iTradeID;
	int						m_iNpcID;
	CUIImageTooltipDlg*		m_pUITooltipDlg;
	
	CN3UIImage*				m_pUIInn;
	CN3UIImage*				m_pUIBlackSmith;
	CN3UIImage*				m_pUIStore;

	//this_ui_add_start
	CN3UIButton*			m_pBtnClose;
	CN3UIButton*			m_pBtnPageUp;
	CN3UIButton*			m_pBtnPageDown;
	//this_ui_add_end

	CUIMsgBoxOkCancel*		m_pUIMsgBoxOkCancel;

protected:
	int					GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist);
	RECT				GetSampleRect();

	e_UIWND_DISTRICT	GetWndDistrict(__IconItemSkill* spItem);

public:
	CUITransactionDlg();
	~CUITransactionDlg() override;
	void				Release() override;

	//this_ui_add_start
	bool				OnKeyPress(int iKey) override;
	bool				Load(File& file) override;
	void				SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	void				SetVisible(bool bVisible) override;
	//this_ui_add_end

	uint32_t			MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool				ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool				OnMouseWheelEvent(short delta) override;
	void				Render() override;
	void				LeaveTransactionState();
	void				EnterTransactionState();

	void				InitIconWnd(e_UIWND eWnd) override;
	void				InitIconUpdate() override;

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon) override;

	void				IconRestore() override;

	bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur) override;

	void				CancelIconDrop(__IconItemSkill* spItem) override;
	void				AcceptIconDrop(__IconItemSkill* spItem) override;

	void				SendToServerSellMsg(int itemID, byte pos, int iCount);
	void				SendToServerBuyMsg(int itemID, byte pos, int iCount);
	void				SendToServerMoveMsg(int itemID, byte startpos, byte destpos);

	// 물건 구입이 서버에게 보내기전 성공..
	void				ReceiveItemDropByTradeSuccess();

	CN3UIBase*			GetChildButtonByName(const std::string& szFN);

	// Item Count OK..
	void				ItemCountOK();
	void				ItemCountCancel();

	// MsgBox Ok Cancel
	void				CallBackProc(int iID, uint32_t dwFlag) override;
	void				OnConfirm();
	void				OnCancel();

	void				ItemMoveFromInvToThis();
	void				ItemMoveFromThisToInv();

	void				ReceiveResultTradeFromServer(byte bResult, byte bType, int	iMoney);
	void				ReceiveResultTradeMoveSuccess();
	void				ReceiveResultTradeMoveFail();

	// 타이틀 표시..
	void				ShowTitle(e_NpcTrade eNT);

	void				GoldUpdate();
	void				UpdateWeight(const std::string& szWeight);
	static std::string	GetItemName(const __IconItemSkill* spItem);
};

#endif // !defined(AFX_UITRANSACTIONDLG_H__42671245_FF4F_42FC_AF7B_DACEDA8734B7__INCLUDED_)

// ===== END WarFare/UITransactionDlg.h =====

// ===== BEGIN WarFare/UIUpgradeSelect.cpp =====
#line 1 "WarFare/UIUpgradeSelect.cpp"
﻿#include "StdAfx.h"
#include "UIUpgradeSelect.h"
#include "GameProcMain.h"
// #include "UIItemUpgrade.h"
// #include "UIRingUpgrade.h"
#include "UIManager.h"

#include <N3BASE/N3UIButton.h>

CUIUpgradeSelect::CUIUpgradeSelect()
{
	m_pBtn_Upgrade_1	= nullptr;
	m_pBtn_Upgrade_2	= nullptr;
	m_pBtn_Close		= nullptr;
}

CUIUpgradeSelect::~CUIUpgradeSelect()
{
}

bool CUIUpgradeSelect::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Upgrade_1,	GetChildByID<CN3UIButton>("upgrade_1"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Upgrade_2,	GetChildByID<CN3UIButton>("upgrade_2"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close,		GetChildByID<CN3UIButton>("btn_close"));

	return true;
}

bool CUIUpgradeSelect::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtn_Upgrade_1)
		{
#if 1
			CGameProcedure::MessageBoxPost(
				"CUIItemUpgrade needs to be implemented.",
				"Not implemented",
				MB_OK);
#else
			CUIItemUpgrade* pUIItemUpgrade = CGameProcedure::s_pProcMain->m_pUIItemUpgrade;
			if (pUIItemUpgrade != nullptr)
			{
				pUIItemUpgrade->SetVisible(true);
				pUIItemUpgrade->SetNpcID(m_iNpcID);
			}
#endif

			SetVisible(false);
		}
		else if (pSender == m_pBtn_Upgrade_2)
		{
#if 1
			CGameProcedure::MessageBoxPost(
				"CUIRingUpgrade needs to be implemented.",
				"Not implemented",
				MB_OK);
#else
			CUIRingUpgrade* pUIRingUpgrade = CGameProcedure::s_pProcMain->m_pUIRingUpgrade;
			if (pUIRingUpgrade != nullptr)
			{
				pUIRingUpgrade->SetVisible(true);
				pUIRingUpgrade->SetNpcID(m_iNpcID);
			}
#endif

			SetVisible(false);
		}
		else if (pSender == m_pBtn_Close)
		{
			SetVisible(false);
		}
	}

	return true;
}

void CUIUpgradeSelect::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);

	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();
}

// ===== END WarFare/UIUpgradeSelect.cpp =====

// ===== BEGIN WarFare/UIUpgradeSelect.h =====
#line 1 "WarFare/UIUpgradeSelect.h"
﻿#pragma once

#include <N3BASE/N3UIBase.h>

class CUIUpgradeSelect : public CN3UIBase
{
public:
	inline void SetNpcID(int iNpcID) {
		m_iNpcID = iNpcID;
	}

	CUIUpgradeSelect();
	~CUIUpgradeSelect() override;
	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	void SetVisible(bool bVisible) override;

protected:
	CN3UIButton*	m_pBtn_Upgrade_1;
	CN3UIButton*	m_pBtn_Upgrade_2;
	CN3UIButton*	m_pBtn_Close;
	int				m_iNpcID;
};

// ===== END WarFare/UIUpgradeSelect.h =====

// ===== BEGIN WarFare/UIVarious.cpp =====
#line 1 "WarFare/UIVarious.cpp"
﻿// UIState.cpp: implementation of the CUIState class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIVarious.h"
#include "UIManager.h"
#include "UIInventory.h"
#include "UITransactionDlg.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "PlayerOtherMgr.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "text_resources.h"

#include <N3Base/N3UIString.h>
#include <N3Base/N3UIImage.h>
#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIList.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIState::CUIState()
{
	m_pText_ID = nullptr;
	m_pText_Level = nullptr;
	m_pText_RealmPoint = nullptr;

	m_pText_Class = nullptr;
	m_pText_Race = nullptr;
	m_pText_Nation = nullptr;

	m_pText_HP = nullptr;
	m_pText_MP = nullptr;
	m_pText_Exp = nullptr;
	m_pText_AP = nullptr;	// 공격 = nullptr력
	m_pText_GP = nullptr;			// 방어 = nullptr력
	m_pText_Weight = nullptr;

	
	m_pText_BonusPoint = nullptr;

	m_pBtn_Strength = nullptr;
	m_pBtn_Stamina = nullptr;
	m_pBtn_Dexterity = nullptr;
	m_pBtn_MagicAttak = nullptr;
	m_pBtn_Intelligence = nullptr;

	m_pText_Strength = nullptr;
	m_pText_Stamina = nullptr;
	m_pText_Dexterity = nullptr;
	m_pText_MagicAttak = nullptr;
	m_pText_Intelligence = nullptr;

	m_pText_RegistFire = nullptr;
	m_pText_RegistMagic = nullptr;
	m_pText_RegistIce = nullptr;
	m_pText_RegistCurse = nullptr;
	m_pText_RegistLight = nullptr;
	m_pText_RegistPoison = nullptr;

	m_pImg_Str = nullptr;
	m_pImg_Sta = nullptr;
	m_pImg_Dex = nullptr;
	m_pImg_Int = nullptr;
	m_pImg_MAP = nullptr;
}

CUIState::~CUIState()
{
}

void CUIState::Release()
{
	CN3UIBase::Release();

	m_pText_ID = nullptr;
	m_pText_Level = nullptr;
	m_pText_RealmPoint = nullptr;

	m_pText_Class = nullptr;
	m_pText_Race = nullptr;
	m_pText_Nation = nullptr;

	m_pText_HP = nullptr;
	m_pText_MP = nullptr;
	m_pText_Exp = nullptr;
	m_pText_AP = nullptr;	// 공격 = nullptr력
	m_pText_GP = nullptr;			// 방어 = nullptr력
	m_pText_Weight = nullptr;

	
	m_pText_BonusPoint = nullptr;

	m_pBtn_Strength = nullptr;
	m_pBtn_Stamina = nullptr;
	m_pBtn_Dexterity = nullptr;
	m_pBtn_MagicAttak = nullptr;
	m_pBtn_Intelligence = nullptr;

	m_pText_Strength = nullptr;
	m_pText_Stamina = nullptr;
	m_pText_Dexterity = nullptr;
	m_pText_MagicAttak = nullptr;
	m_pText_Intelligence = nullptr;

	m_pText_RegistFire = nullptr;
	m_pText_RegistMagic = nullptr;
	m_pText_RegistIce = nullptr;
	m_pText_RegistCurse = nullptr;
	m_pText_RegistLight = nullptr;
	m_pText_RegistPoison = nullptr;

	m_pImg_Str = nullptr;
	m_pImg_Sta = nullptr;
	m_pImg_Dex = nullptr;
	m_pImg_Int = nullptr;
	m_pImg_MAP = nullptr;
}

bool CUIState::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pText_ID, GetChildByID<CN3UIString>("Text_ID"));
	N3_VERIFY_UI_COMPONENT(m_pText_Level, GetChildByID<CN3UIString>("Text_Level"));
	N3_VERIFY_UI_COMPONENT(m_pText_RealmPoint, GetChildByID<CN3UIString>("Text_RealmPoint"));

	N3_VERIFY_UI_COMPONENT(m_pText_Class, GetChildByID<CN3UIString>("Text_Class"));
	N3_VERIFY_UI_COMPONENT(m_pText_Race, GetChildByID<CN3UIString>("Text_Race"));
	N3_VERIFY_UI_COMPONENT(m_pText_Nation, GetChildByID<CN3UIString>("Text_Nation"));

	N3_VERIFY_UI_COMPONENT(m_pText_HP, GetChildByID<CN3UIString>("Text_HP"));
	N3_VERIFY_UI_COMPONENT(m_pText_MP, GetChildByID<CN3UIString>("Text_MP"));
	N3_VERIFY_UI_COMPONENT(m_pText_Exp, GetChildByID<CN3UIString>("Text_Exp"));
	N3_VERIFY_UI_COMPONENT(m_pText_AP, GetChildByID<CN3UIString>("Text_AP"));
	N3_VERIFY_UI_COMPONENT(m_pText_GP, GetChildByID<CN3UIString>("Text_GP"));
	N3_VERIFY_UI_COMPONENT(m_pText_Weight, GetChildByID<CN3UIString>("Text_Weight"));

	N3_VERIFY_UI_COMPONENT(m_pText_BonusPoint, GetChildByID<CN3UIString>("Text_BonusPoint"));

	N3_VERIFY_UI_COMPONENT(m_pBtn_Strength, GetChildByID<CN3UIButton>("Btn_Strength"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Stamina, GetChildByID<CN3UIButton>("Btn_Stamina"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Dexterity, GetChildByID<CN3UIButton>("Btn_Dexterity"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_MagicAttak, GetChildByID<CN3UIButton>("Btn_MagicAttack"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Intelligence, GetChildByID<CN3UIButton>("Btn_Intelligence"));

	N3_VERIFY_UI_COMPONENT(m_pText_Strength, GetChildByID<CN3UIString>("Text_Strength"));
	N3_VERIFY_UI_COMPONENT(m_pText_Stamina, GetChildByID<CN3UIString>("Text_Stamina"));
	N3_VERIFY_UI_COMPONENT(m_pText_Dexterity, GetChildByID<CN3UIString>("Text_Dexterity"));
	N3_VERIFY_UI_COMPONENT(m_pText_MagicAttak, GetChildByID<CN3UIString>("Text_MagicAttack"));
	N3_VERIFY_UI_COMPONENT(m_pText_Intelligence, GetChildByID<CN3UIString>("Text_Intelligence"));

	N3_VERIFY_UI_COMPONENT(m_pText_RegistFire, GetChildByID<CN3UIString>("Text_RegistFire"));
	N3_VERIFY_UI_COMPONENT(m_pText_RegistMagic, GetChildByID<CN3UIString>("Text_RegistMagic"));
	N3_VERIFY_UI_COMPONENT(m_pText_RegistIce, GetChildByID<CN3UIString>("Text_RegistIce"));
	N3_VERIFY_UI_COMPONENT(m_pText_RegistCurse, GetChildByID<CN3UIString>("Text_RegistCurse"));
	N3_VERIFY_UI_COMPONENT(m_pText_RegistLight, GetChildByID<CN3UIString>("Text_RegistLightR"));
	N3_VERIFY_UI_COMPONENT(m_pText_RegistPoison, GetChildByID<CN3UIString>("Text_RegistPoison"));

	N3_VERIFY_UI_COMPONENT(m_pImg_Str, GetChildByID("img_str"));
	N3_VERIFY_UI_COMPONENT(m_pImg_Sta, GetChildByID("img_sta"));
	N3_VERIFY_UI_COMPONENT(m_pImg_Dex, GetChildByID("img_dex"));
	N3_VERIFY_UI_COMPONENT(m_pImg_Int, GetChildByID("img_int"));
	N3_VERIFY_UI_COMPONENT(m_pImg_MAP, GetChildByID("img_map"));

	return true;
}

void CUIState::UpdateBonusPointAndButtons(int iBonusPointRemain) // 보너스 포인트 적용이 가능한가??
{
	bool bEnable = false;
	if(iBonusPointRemain > 0) bEnable = true;
	else bEnable = false;

	if(m_pText_BonusPoint) m_pText_BonusPoint->SetStringAsInt(iBonusPointRemain);

	if(m_pBtn_Strength)		m_pBtn_Strength->SetVisible(bEnable); // 경험치 체인지..
	if(m_pBtn_Stamina)		m_pBtn_Stamina->SetVisible(bEnable);
	if(m_pBtn_Dexterity)	m_pBtn_Dexterity->SetVisible(bEnable);
	if(m_pBtn_Intelligence)	m_pBtn_Intelligence->SetVisible(bEnable);
	if(m_pBtn_MagicAttak)	m_pBtn_MagicAttak->SetVisible(bEnable);
}

void CUIState::UpdateID(const std::string& szID)
{
	if (m_pText_ID != nullptr)
		m_pText_ID->SetString(szID);
}

void CUIState::UpdateLevel(int iVal)
{
	if (m_pText_Level != nullptr)
		m_pText_Level->SetStringAsInt(iVal);
}

void CUIState::UpdateRealmPoint(int iLoyalty, int iLoyaltyMonthly) // 국가 기여도는 10을 나누어서 표시
{
	if (m_pText_RealmPoint == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iLoyalty, iLoyaltyMonthly);
	m_pText_RealmPoint->SetString(buff); // 국가 기여도는 10을 나누어서 표시
}

void CUIState::UpdateHP(int iVal, int iValMax)
{
	__ASSERT(iVal >= 0 && iVal < 10000 && iValMax >= 0 && iValMax < 10000, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_HP == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iVal, iValMax);
	m_pText_HP->SetString(buff);
}

void CUIState::UpdateMSP(int iVal, int iValMax)
{
	__ASSERT(iVal >= 0 && iValMax > 0, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_MP == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iVal, iValMax);
	m_pText_MP->SetString(buff);
}

void CUIState::UpdateExp(int64_t iVal, int64_t iValMax)
{
	__ASSERT(iVal >= 0 && iValMax > 0, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
	if (m_pText_Exp == nullptr)
		return;

	std::string buff = fmt::format("{} / {}", iVal, iValMax);
	m_pText_Exp->SetString(buff);
}

void CUIState::UpdateAttackPoint(int iVal, int iDelta)
{
	if (m_pText_AP == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_AP->SetString(buff);
	}
	else
	{
		m_pText_AP->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateGuardPoint(int iVal, int iDelta)
{
	if (m_pText_GP == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_GP->SetString(buff);
	}
	else
	{
		m_pText_GP->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateWeight(int iVal, int iValMax)
{
	if (m_pText_Weight == nullptr)
		return;

	std::string szVal = fmt::format("{:.1f}/{:.1f}", (iVal * 0.1f), (iValMax * 0.1f));
	m_pText_Weight->SetString(szVal);

	std::string szMsg = fmt::format_text_resource(IDS_INVEN_WEIGHT);
	std::string str = szMsg + szVal;

	CUIInventory* pInv = CGameProcedure::s_pProcMain->m_pUIInventory;
	if (pInv != nullptr)
		pInv->UpdateWeight(str);

	CUITransactionDlg* pUITransactionDlg = CGameProcedure::s_pProcMain->m_pUITransactionDlg;
	if (pUITransactionDlg != nullptr)
		pUITransactionDlg->UpdateWeight(str);
}

void CUIState::UpdateStrength(int iVal, int iDelta)
{
	if (m_pText_Strength == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_Strength->SetString(buff);
	}
	else
	{
		m_pText_Strength->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateStamina(int iVal, int iDelta)
{
	if (m_pText_Stamina == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_Stamina->SetString(buff);
	}
	else
	{
		m_pText_Stamina->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateDexterity(int iVal, int iDelta)
{
	if (m_pText_Dexterity == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_Dexterity->SetString(buff);
	}
	else
	{
		m_pText_Dexterity->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateIntelligence(int iVal, int iDelta)
{
	if (m_pText_Intelligence == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_Intelligence->SetString(buff);
	}
	else
	{
		m_pText_Intelligence->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateMagicAttak(int iVal, int iDelta)
{
	if (m_pText_MagicAttak == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_MagicAttak->SetString(buff);
	}
	else
	{
		m_pText_MagicAttak->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistFire(int iVal, int iDelta)
{
	if (m_pText_RegistFire == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistFire->SetString(buff);
	}
	else
	{
		m_pText_RegistFire->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistCold(int iVal, int iDelta)
{
	if (m_pText_RegistIce == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistIce->SetString(buff);
	}
	else
	{
		m_pText_RegistIce->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistLight(int iVal, int iDelta)
{
	if (m_pText_RegistLight == nullptr)
		return;

	if (iDelta)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistLight->SetString(buff);
	}
	else
	{
		m_pText_RegistLight->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistMagic(int iVal, int iDelta)
{
	if (m_pText_RegistMagic == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistMagic->SetString(buff);
	}
	else
	{
		m_pText_RegistMagic->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistCurse(int iVal, int iDelta)
{
	if (m_pText_RegistCurse == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistCurse->SetString(buff);
	}
	else
	{
		m_pText_RegistCurse->SetStringAsInt(iVal);
	}
}

void CUIState::UpdateRegistPoison(int iVal, int iDelta)
{
	if (m_pText_RegistPoison == nullptr)
		return;

	if (iDelta != 0)
	{
		std::string buff = FormatWithDelta(iVal, iDelta);
		m_pText_RegistPoison->SetString(buff);
	}
	else
	{
		m_pText_RegistPoison->SetStringAsInt(iVal);
	}
}

std::string CUIState::FormatWithDelta(int iVal, int iDelta)
{
	if (iDelta > 0)
		return fmt::format("{}(+{})", iVal, iDelta);

	return fmt::format("{}({})", iVal, iDelta);
}

bool CUIState::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtn_Strength) // 경험치 체인지..
			this->MsgSendAblityPointChange(0x01, +1);
		else if(pSender == m_pBtn_Stamina)
			this->MsgSendAblityPointChange(0x02, +1);
		else if(pSender == m_pBtn_Dexterity)
			this->MsgSendAblityPointChange(0x03, +1);
		else if(pSender == m_pBtn_Intelligence)
			this->MsgSendAblityPointChange(0x04, +1);
		else if(pSender == m_pBtn_MagicAttak)
			this->MsgSendAblityPointChange(0x05, +1);
	}

	return true;
}

void CUIState::MsgSendAblityPointChange(uint8_t byType, int16_t siValueDelta)
{
	uint8_t byBuff[4];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_POINT_CHANGE);
	CAPISocket::MP_AddByte(byBuff, iOffset, byType);
	CAPISocket::MP_AddShort(byBuff, iOffset, siValueDelta); // 0x00 - 점차 늘어나게끔.. 0x01 - 즉시 업데이트..

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

CUIKnights::CUIKnights()
{
	m_iPageCur = 1;
	// m_MemberList = nullptr;

	m_pText_Name = nullptr;
	m_pText_Duty = nullptr;
	m_pText_Page = nullptr;
	m_pText_MemberCount = nullptr;

	// m_pImage_Grade = nullptr;

	m_pList_CharGrades = nullptr;
	m_pList_CharIDs = nullptr;
	m_pList_CharLevels = nullptr;
	m_pList_CharJobs = nullptr;

	m_pBtn_Admit = nullptr;
	m_pBtn_Appoint = nullptr;
	m_pBtn_Remove = nullptr;
	m_pBtn_Refresh = nullptr;
	m_pBtn_ClanParty = nullptr;

	m_fTimeLimit_Refresh = 0.0f;
	m_fTimeLimit_Appoint = 0.0f;
	m_fTimeLimit_Remove = 0.0f;
	m_fTimeLimit_Admit = 0.0f;
}

CUIKnights::~CUIKnights()
{
}

void CUIKnights::Release()
{
	CN3UIBase::Release();

	m_iPageCur = 1;
	// m_MemberList = nullptr;

	m_pText_Name = nullptr;
	m_pText_Duty = nullptr;
	m_pText_Page = nullptr;
	m_pText_MemberCount = nullptr;

	// m_pImage_Grade = nullptr;

	m_pList_CharGrades = nullptr;
	m_pList_CharIDs = nullptr;
	m_pList_CharLevels = nullptr;
	m_pList_CharJobs = nullptr;

	m_pBtn_Admit = nullptr;
	m_pBtn_Appoint = nullptr;
	m_pBtn_Remove = nullptr;
	m_pBtn_Refresh = nullptr;
	m_pBtn_ClanParty = nullptr;
}

void CUIKnights::Clear()
{
	m_MemberList.clear();

	ClearLists();
	UpdatePageNumber(1);
	UpdateMemberCount(0, 0);

	m_pText_Name->SetString("");
	m_pText_Duty->SetString("");
	m_pText_MemberCount->SetString("0");

	this->ChangeUIByDuty(CGameBase::s_pPlayer->m_InfoExt.eKnightsDuty);
}

void CUIKnights::SetVisible(bool bVisible)
{
	if (bVisible == this->IsVisible()) return;

	if (bVisible)
		RefreshButtonHandler(true);

	CN3UIBase::SetVisible(bVisible);
}

bool CUIKnights::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pText_Name,			GetChildByID<CN3UIString>("Text_ClansName"));
	N3_VERIFY_UI_COMPONENT(m_pText_Duty,			GetChildByID<CN3UIString>("Text_clan_Duty"));
	N3_VERIFY_UI_COMPONENT(m_pText_Page,			GetChildByID<CN3UIString>("Text_clan_Page"));
	N3_VERIFY_UI_COMPONENT(m_pText_MemberCount,		GetChildByID<CN3UIString>("Text_clan_MemberCount"));

	N3_VERIFY_UI_COMPONENT(m_pList_CharGrades,		GetChildByID<CN3UIList>("List_clan_Grade"));
	N3_VERIFY_UI_COMPONENT(m_pList_CharIDs,			GetChildByID<CN3UIList>("List_clan_ChrID"));
	N3_VERIFY_UI_COMPONENT(m_pList_CharLevels,		GetChildByID<CN3UIList>("List_clan_Level"));
	N3_VERIFY_UI_COMPONENT(m_pList_CharJobs,		GetChildByID<CN3UIList>("List_clan_Job"));

	N3_VERIFY_UI_COMPONENT(m_pBtn_Admit,			GetChildByID<CN3UIButton>("btn_clan_admit"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Appoint,			GetChildByID<CN3UIButton>("btn_clan_Appoint"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Remove,			GetChildByID<CN3UIButton>("btn_clan_Remove"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Refresh,			GetChildByID<CN3UIButton>("btn_clan_refresh"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_ClanParty,		GetChildByID<CN3UIButton>("btn_Clan_party"));

	std::string szID;
	for (int i = 0; i < MAX_CLAN_GRADE; i++)
	{
		szID = fmt::format("image_grade{:02}", i);
		N3_VERIFY_UI_COMPONENT(m_pImage_Grade[i],	GetChildByID<CN3UIImage>(szID));

		if (m_pImage_Grade[i] != nullptr)
			m_pImage_Grade[i]->SetVisible(false);
	}

	UpdatePageNumber(1);

	if (m_pList_CharGrades != nullptr)
		m_pList_CharGrades->SetState(UI_STATE_LIST_DISABLE);

	if (m_pList_CharLevels != nullptr)
		m_pList_CharLevels->SetState(UI_STATE_LIST_DISABLE);

	if (m_pList_CharJobs != nullptr)
		m_pList_CharJobs->SetState(UI_STATE_LIST_DISABLE);

	return true;
}

void CUIKnights::UpdatePageNumber(int iNewPageNo /*= -1*/)
{
	if (iNewPageNo != -1)
		m_iPageCur = iNewPageNo;

	m_pText_Page->SetStringAsInt(m_iPageCur);
}

void CUIKnights::UpdateMemberCount(int iMemberCountOnline, int iMemberCountTotal)
{
	std::string memberCount = fmt::format("{} / {}", iMemberCountOnline, iMemberCountTotal);
	m_pText_MemberCount->SetString(memberCount);
}

bool CUIKnights::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg != UIMSG_BUTTON_CLICK)
		return false; // @Demircivi: Since we don't care about anything else click.

	if (pSender->m_szID == "btn_clan_up")
		PreviousPageButtonHandler();
	else if (pSender->m_szID == "btn_clan_down")
		NextPageButtonHandler();
	else if (pSender == m_pBtn_Refresh)
		RefreshButtonHandler();
	else if (pSender == m_pBtn_ClanParty)
		ClanPartyButtonHandler();
	else if (pSender->m_szID == "btn_clan_whisper")
		WhisperButtonHandler();
	else if (pSender == m_pBtn_Admit)
		AdmitButtonHandler();
	else if (pSender == m_pBtn_Remove)
		RemoveButtonHandler();
	else if (pSender == m_pBtn_Appoint)
		AppointButtonHandler();
	else
		return false;

	return true;
}

void CUIKnights::PreviousPageButtonHandler()
{
	m_iPageCur--;
	if (m_iPageCur < 1)
		m_iPageCur = 1;

	RefreshList();
}

void CUIKnights::NextPageButtonHandler()
{
	m_iPageCur++;
	int MaxPage = static_cast<int>(m_MemberList.size()) / 10 + 1;
	if (m_iPageCur > MaxPage)
		m_iPageCur = MaxPage;

	UpdatePageNumber();
	RefreshList();
}

void CUIKnights::RefreshButtonHandler(bool blBypassTime)
{
	if (m_fTimeLimit_Refresh < 5.0f && !blBypassTime)
		return;

	m_fTimeLimit_Refresh = 0.0f;

	Clear();
	UpdateExceptList();

	MsgSend_MemberInfoAll();
}

void CUIKnights::ClanPartyButtonHandler()
{
	int iSel = m_pList_CharIDs->GetCurSel();

	std::string szID;
	if (!m_pList_CharIDs->GetString(iSel, szID))
		return;

	const std::string& myID = CGameProcedure::s_pPlayer->IDString();
	std::string szMsg;

	// Prevent inviting yourself
	if (lstrcmpiA(szID.c_str(), myID.c_str()) == 0)
	{
		szMsg = fmt::format_text_resource(IDS_PARTY_INVITE_FAILED);
		CGameProcedure::s_pProcMain->MsgOutput(szID + szMsg, 0xffffff00);
		return;
	}

	// Try to send party invite
	if (CGameProcedure::s_pProcMain->MsgSend_PartyOrForceCreate(0, szID))
		szMsg = fmt::format_text_resource(IDS_PARTY_INVITE);
	else
		szMsg = fmt::format_text_resource(IDS_PARTY_INVITE_FAILED);
	CGameProcedure::s_pProcMain->MsgOutput(szID + szMsg, 0xffffff00);
}

void CUIKnights::WhisperButtonHandler()
{
	std::string szName;
	int index = m_pList_CharIDs->GetCurSel();
	if (m_pList_CharIDs->GetString(index, szName))
		CGameProcedure::s_pProcMain->MsgSend_ChatSelectTarget(szName);
}

void CUIKnights::AdmitButtonHandler()
{
	if (m_fTimeLimit_Admit < 3.0f)
		return;

	m_fTimeLimit_Admit = 0.0f;

	CGameProcedure::s_pProcMain->MsgSend_KnightsJoin(CGameBase::s_pPlayer->m_iIDTarget);
	m_fTimeLimit_Admit = 0.0f;
}

void CUIKnights::RemoveButtonHandler() // TODO: @Demircivi, maybe add confirmation dialog in further development? just saying.
{
	if (m_fTimeLimit_Remove < 3.0f)
		return;

	m_fTimeLimit_Remove = 0.0f;

	std::string szName;
	int index = m_pList_CharIDs->GetCurSel();
	if (m_pList_CharIDs->GetString(index, szName))
		CGameProcedure::s_pProcMain->MsgSend_KnightsLeave(szName);
}

void CUIKnights::AppointButtonHandler()
{
	if (m_fTimeLimit_Appoint < 3.0f)
		return;

	m_fTimeLimit_Appoint = 0.0f;

	std::string szName;
	int index = m_pList_CharIDs->GetCurSel();
	if (m_pList_CharIDs->GetString(index, szName))
		CGameProcedure::s_pProcMain->MsgSend_KnightsAppointViceChief(szName);
}

void CUIKnights::ClearLists()
{
	m_pList_CharGrades->ResetContent();
	m_pList_CharIDs->ResetContent();
	m_pList_CharLevels->ResetContent();
	m_pList_CharJobs->ResetContent();
}

void CUIKnights::RefreshList()
{
	ClearLists();

	auto it = m_MemberList.begin();

	int i = 10;
	int e = m_iPageCur * 10;

	for (; i < e; i++)
	{
		if (it == m_MemberList.end()) break;
		it++;
	}

	for (i = 0; i < 10; i++)
	{
		if (it == m_MemberList.end()) break;

		__KnightsMemberInfo KMI = (*it);

		if (KMI.iConnected)
		{
			std::string szClass, szDuty;
			CGameBase::GetTextByKnightsDuty(KMI.eDuty, szDuty);
			CGameBase::GetTextByClass(KMI.eClass, szClass);

			std::string level = std::to_string(KMI.iLevel);

			int index = m_pList_CharGrades->AddString(szDuty); // TODO: @Demircivi, Char Grade is not loading from language files.
			m_pList_CharIDs->AddString(KMI.szName);
			m_pList_CharLevels->AddString(level);
			m_pList_CharJobs->AddString(szClass);

			m_pList_CharGrades->SetFontColor(index, 0xff00ff00);
			m_pList_CharIDs->SetFontColor(index, 0xff00ff00);
			m_pList_CharLevels->SetFontColor(index, 0xff00ff00);
			m_pList_CharJobs->SetFontColor(index, 0xff00ff00);
		}
		else
		{
			int index = m_pList_CharGrades->AddString("....");
			m_pList_CharIDs->AddString(KMI.szName);
			m_pList_CharLevels->AddString("....");
			m_pList_CharJobs->AddString("....");

			m_pList_CharGrades->SetFontColor(index, 0xff808080);
			m_pList_CharIDs->SetFontColor(index, 0xff808080);
			m_pList_CharLevels->SetFontColor(index, 0xff808080);
			m_pList_CharJobs->SetFontColor(index, 0xff808080);
		}
		it++;
	}

	m_pList_CharGrades->SetCurSel(-1);
	m_pList_CharLevels->SetCurSel(-1);
	m_pList_CharJobs->SetCurSel(-1);
}

void CUIKnights::MemberListSort()
{
	it_KMI it = m_MemberList.begin(), itEnd = m_MemberList.end();

	__KnightsMemberInfo Chief; Chief.eDuty = KNIGHTS_DUTY_UNKNOWN;
	__KnightsMemberInfo ViceChief[3];
	ViceChief[0].eDuty = KNIGHTS_DUTY_UNKNOWN;
	ViceChief[1].eDuty = KNIGHTS_DUTY_UNKNOWN;
	ViceChief[2].eDuty = KNIGHTS_DUTY_UNKNOWN;

	int iViceChiefCount = 0;
	while (it != itEnd)
	{
		__KnightsMemberInfo kmi = (*it);

		if (kmi.eDuty == KNIGHTS_DUTY_CHIEF)
		{
			Chief = kmi;
			it = m_MemberList.erase(it);
			continue;
		}

		if (kmi.eDuty == KNIGHTS_DUTY_VICECHIEF)
		{
			ViceChief[iViceChiefCount] = kmi;
			it = m_MemberList.erase(it);
			iViceChiefCount++;
			continue;
		}
		it++;
	}

	for (int i = 0; i<3; i++)
		if (ViceChief[i].eDuty != KNIGHTS_DUTY_UNKNOWN) m_MemberList.push_front(ViceChief[i]);

	if (Chief.eDuty != KNIGHTS_DUTY_UNKNOWN) m_MemberList.push_front(Chief);
}

void CUIKnights::MemberListUpdate()
{
	MemberListSort();
	RefreshList();
}

void CUIKnights::MsgSend_MemberInfoAll()
{
	int iOffset = 0;
	uint8_t byBuff[32];
	
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_KNIGHTS_PROCESS);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_KNIGHTS_MEMBER_INFO_ALL);
	
	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

bool CUIKnights::MsgRecv_MemberInfo(Packet& pkt)
{
	pkt.read<int16_t>(); // @Demircivi: packet sizes, which are unused.
	int iMemberCountOnline = pkt.read<int16_t>();
	int iMemberCountTotal = pkt.read<int16_t>();

	int iMemberCountList = pkt.read<int16_t>();

	UpdateMemberCount(iMemberCountOnline, iMemberCountTotal);

	for (int i = 0; i < iMemberCountList; i++)
	{
		int iNameLength = pkt.read<int16_t>();
		__ASSERT(iNameLength > 0, "iNameLength was below 0!");

		__KnightsMemberInfo KMI;

		pkt.readString(KMI.szName, iNameLength);
		// KMI.szName = szName;
		KMI.eDuty = (e_KnightsDuty)pkt.read<uint8_t>();
		KMI.iLevel = pkt.read<uint8_t>();
		KMI.eClass = (e_Class)pkt.read<int16_t>();
		KMI.iConnected = pkt.read<uint8_t>();

		m_MemberList.push_back(KMI);
	}

	UpdatePageNumber(1);

	this->MemberListUpdate(); // List 에 다 넣었으면 UI Update!!
	
	return true;
}

void CUIKnights::UpdateKnightsName(const std::string& szName)
{
	if(nullptr == m_pText_Name) return;
	m_pText_Name->SetString(szName);
}

void CUIKnights::UpdateKnightsDuty(e_KnightsDuty eDuty)
{
	if(nullptr == m_pText_Duty) return;
	std::string szDuty;
	switch(eDuty)
	{
		case KNIGHTS_DUTY_CHIEF:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_CHIEF); break;
		case KNIGHTS_DUTY_VICECHIEF:	szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_VICECHIEF); break;
		case KNIGHTS_DUTY_OFFICER:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_OFFICER); break;
		case KNIGHTS_DUTY_KNIGHT:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_KNIGHT); break;
		case KNIGHTS_DUTY_TRAINEE:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_TRAINEE); break;
		case KNIGHTS_DUTY_PUNISH:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_PUNISH); break;
		case KNIGHTS_DUTY_UNKNOWN:		szDuty = fmt::format_text_resource(IDS_KNIGHTS_DUTY_UNKNOWN); break;
		default: __ASSERT(0, "Invalid Knights Duty"); break;
	}	
	m_pText_Duty->SetString(szDuty);	
}

void CUIKnights::UpdateKnightsGrade(int iVal)
{
	for(int i = 0; i < MAX_CLAN_GRADE; i++)
		if(m_pImage_Grade[i])
			m_pImage_Grade[i]->SetVisible(false);

	if(iVal <= MAX_CLAN_GRADE && iVal > 0)
		if(m_pImage_Grade[iVal - 1]) 
			m_pImage_Grade[iVal - 1]->SetVisible(true);
}

void CUIKnights::UpdateKnightsRank(int iVal)
{
	// TODO: @Demircivi.
}

void CUIKnights::ChangeUIByDuty(e_KnightsDuty eDuty) // 권한에 따라 UI 변경..
{
	if (KNIGHTS_DUTY_CHIEF == eDuty)
	{
		m_pBtn_Admit->SetVisible(true);
		m_pBtn_Appoint->SetVisible(true);
		m_pBtn_Remove->SetVisible(true);
	}
	else if (KNIGHTS_DUTY_VICECHIEF == eDuty)
	{
		m_pBtn_Admit->SetVisible(true);
		m_pBtn_Appoint->SetVisible(false);
		m_pBtn_Remove->SetVisible(false);
	}
	else
	{
		m_pBtn_Admit->SetVisible(false);
		m_pBtn_Appoint->SetVisible(false);
		m_pBtn_Remove->SetVisible(false);
	}
}

void CUIKnights::UpdateExceptList()
{
	UpdateKnightsDuty(CGameBase::s_pPlayer->m_InfoExt.eKnightsDuty);
	UpdateKnightsName(CGameBase::s_pPlayer->m_InfoExt.szKnights);
	UpdateKnightsGrade(CGameBase::s_pPlayer->m_InfoExt.iKnightsGrade);
	UpdateKnightsRank(CGameBase::s_pPlayer->m_InfoExt.iKnightsRank);
	ChangeUIByDuty(CGameBase::s_pPlayer->m_InfoExt.eKnightsDuty);
}





CUIFriends::CUIFriends()
{
	m_iPageCur = 0;

	m_pList_Friends = nullptr;
	m_pText_Page = nullptr;

	m_pBtn_NextPage = nullptr;
	m_pBtn_PrevPage = nullptr;
	
	m_pBtn_Refresh = nullptr;
	m_pBtn_Party = nullptr;
	m_pBtn_Whisper = nullptr;
	m_pBtn_Add = nullptr;
	m_pBtn_Delete = nullptr;
}

CUIFriends::~CUIFriends()
{
	this->SaveListToTextFile(""); // 몽땅 저장..
}

bool CUIFriends::Load(File& file)
{
	if(false == CN3UIBase::Load(file)) return false;

	N3_VERIFY_UI_COMPONENT(m_pList_Friends, GetChildByID<CN3UIList>("List_Friends"));
	N3_VERIFY_UI_COMPONENT(m_pText_Page, GetChildByID<CN3UIString>("String_Page"));

	N3_VERIFY_UI_COMPONENT(m_pBtn_NextPage, GetChildByID<CN3UIButton>("Btn_Page_Down"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_PrevPage, GetChildByID<CN3UIButton>("Btn_Page_Up"));
	
	N3_VERIFY_UI_COMPONENT(m_pBtn_Refresh, GetChildByID<CN3UIButton>("Btn_Refresh"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Party, GetChildByID<CN3UIButton>("Btn_Party"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Whisper, GetChildByID<CN3UIButton>("Btn_Whisper"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Add, GetChildByID<CN3UIButton>("Btn_Add"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Delete, GetChildByID<CN3UIButton>("Btn_Delete"));

	std::string szFN = CGameProcedure::s_szAccount + "_" + CGameProcedure::s_szServer + ".txt"; // 파일이름은 계정_서버.txt 로 한다.
	FILE* pFile = fopen(szFN.c_str(), "r");
	if (pFile != nullptr)
	{
		char szLine[256] = "";
		char* pszResult = fgets(szLine, 256, pFile); // 줄을 읽고..
		while (pszResult)
		{
			int iLen = lstrlen(szLine);
			if (iLen > 3 && iLen <= 22)
			{
				std::string szTmp = szLine;

				size_t pos = szTmp.find("\r");
				if (pos != std::string::npos)
					szTmp = szTmp.substr(0, pos);

				pos = szTmp.find("\n");
				if (pos != std::string::npos)
					szTmp = szTmp.substr(0, pos);

				if (!szTmp.empty())
					MemberAdd(szTmp, -1, false, false);
			}
			pszResult = fgets(szLine, 256, pFile); // 첫째 줄을 읽고..
		}
		fclose(pFile);

		UpdateList();
	}

	return true;
}

void CUIFriends::SaveListToTextFile(const std::string& szID) // 문자열이 있으면 추가하고.. 없으면 몽땅 저장..
{
	// TEMP: to avoid the "_.txt" file in the data directory
	return;

	std::string szFN = CGameProcedure::s_szAccount + "_" + CGameProcedure::s_szServer + ".txt"; // 파일이름은 계정_서버.txt 로 한다.
	char szFlags[4] = "w";
	if(!szID.empty()) lstrcpy(szFlags, "a");
	FILE* pFile = fopen(szFN.c_str(), szFlags);
	if (nullptr == pFile) return;

	std::string szIDTmp;
	if(szID.empty())
	{
		it_FI it = m_MapFriends.begin(), itEnd = m_MapFriends.end();
		for(; it != itEnd; it++)
		{
			szIDTmp = it->second.szName + "\r\n";
			fputs(szIDTmp.c_str(), pFile);
		}
	}
	else
	{
		szIDTmp = szID + "\r\n";
		fputs(szIDTmp.c_str(), pFile);
	}

	fclose(pFile);
}

bool CUIFriends::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	CGameProcMain* pProcMain = CGameProcedure::s_pProcMain;

	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if (pSender == m_pBtn_PrevPage
			|| pSender == m_pBtn_NextPage)
		{
			int iPagePrev = m_iPageCur;

			if (pSender == m_pBtn_PrevPage)
				m_iPageCur--;
			else
				m_iPageCur++;

			if (m_iPageCur < 0)
			{
				m_iPageCur = 0;
			}
			else
			{
				int iLinePerPage = 0;
				if (m_pList_Friends != nullptr)
				{
//					RECT rc = m_pList_Friends->GetRegion();
//					uint32_t dwH = m_pList_Friends->FontHeight();
//					iLinePerPage = (rc.bottom - rc.top) / dwH;
					iLinePerPage = 10;
				}

				int iPageMax = 0;
				if (iLinePerPage > 0)
					iPageMax = (static_cast<int>(m_MapFriends.size()) / iLinePerPage) + 1;
				
				if (m_iPageCur >= iPageMax)
					m_iPageCur = iPageMax - 1;
			}
			
			if(iPagePrev != m_iPageCur) // 페이지가 변경될때 
			{
				this->UpdateList();
				this->MsgSend_MemberInfo(false);
			}
		}
		else if(pSender == m_pBtn_Refresh) // 새 화면으로 갱신...
		{
			this->MsgSend_MemberInfo(true);
		}
		else if(pSender == m_pBtn_Add) // 추가.
		{
			CPlayerOther* pUPC = CGameProcedure::s_pOPMgr->UPCGetByID(CGameBase::s_pPlayer->m_iIDTarget, false);
			if (pUPC != nullptr)
			{
				if(this->MemberAdd(pUPC->IDString(), pUPC->IDNumber(), true, false)) // 추가 성공이면..
				{
					this->SaveListToTextFile(pUPC->IDString()); // 파일에 추가 저장..
					this->MsgSend_MemberInfo(pUPC->IDString());
				}
			}
		}
		else if(pSender == m_pBtn_Delete) // 멤버 삭제
		{
			if(m_pList_Friends)
			{
				int iSel = m_pList_Friends->GetCurSel();
				std::string szID;
				m_pList_Friends->GetString(iSel, szID);

				if(this->MemberDelete(szID))
					this->UpdateList(); // 리스트 업데이트..
			}
		}
		else if(pSender == m_pBtn_Whisper) // 귓속말
		{
			if(m_pList_Friends)
			{
				int iSel = m_pList_Friends->GetCurSel();
				std::string szID;
				m_pList_Friends->GetString(iSel, szID);
				pProcMain->MsgSend_ChatSelectTarget(szID);
			}
		}
		else if(pSender == m_pBtn_Party) // 파티 신청
		{
			int iSel = m_pList_Friends->GetCurSel();
			std::string szID;
			m_pList_Friends->GetString(iSel, szID);
			it_FI it = m_MapFriends.find(szID);
			if(it != m_MapFriends.end())
			{
				std::string szMsg;
				if (pProcMain->MsgSend_PartyOrForceCreate(0, szID))
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE); // 파티
				else
					szMsg = fmt::format_text_resource(IDS_PARTY_INVITE_FAILED); // 파티 초대 실패
				pProcMain->MsgOutput(it->second.szName + szMsg, 0xffffff00);
			}
		}
	}

	return false;
}

bool CUIFriends::MemberAdd(const std::string &szID, int iID, bool bOnLine, bool bIsParty)
{
	if(szID.empty()) return false;
	if(m_MapFriends.find(szID) != m_MapFriends.end()) return false;

	__FriendsInfo FI;
	FI.szName = szID;
	FI.iID = iID;
	FI.bOnLine = bOnLine;
	FI.bIsParty = bIsParty;
	m_MapFriends.insert(val_FI(FI.szName, FI));

	return true;
}

bool CUIFriends::MemberDelete(const std::string &szID)
{
	it_FI it = m_MapFriends.find(szID);
	if(it == m_MapFriends.end()) return false;

	m_MapFriends.erase(it);

	return true;
}

void CUIFriends::UpdateList()
{
	if(nullptr == m_pList_Friends) return;
	int iSelPrev = m_pList_Friends->GetCurSel();

	m_pList_Friends->ResetContent();
	if(m_MapFriends.empty()) return;

//	RECT rc = m_pList_Friends->GetRegion();
//	uint32_t dwH = m_pList_Friends->FontHeight();
//	int iLinePerPage = (rc.bottom - rc.top) / dwH;
	int iLinePerPage = 10;
//	if(iLinePerPage <= 0) return;

	int iPageMax = static_cast<int>(m_MapFriends.size()) / iLinePerPage;
	if (m_iPageCur < 0
		|| m_iPageCur > iPageMax)
		return;

	size_t iSkip = static_cast<size_t>(m_iPageCur * iLinePerPage);
	if (iSkip >= m_MapFriends.size())
		return;

	if(m_pText_Page) m_pText_Page->SetStringAsInt(m_iPageCur+1); // 페이지 표시..

	auto it = m_MapFriends.begin();
	std::advance(it, iSkip);

	for (int i = 0; i < iLinePerPage && it != m_MapFriends.end(); i++, it++)
	{
		__FriendsInfo& FI = it->second;
		int iIndex = m_pList_Friends->AddString(FI.szName);
		
		D3DCOLOR crStatus;
		if(FI.bOnLine)
		{
			if(FI.bIsParty) crStatus = 0xffff0000;
			else crStatus = 0xff00ff00;
		}
		else crStatus = 0xff808080;

		m_pList_Friends->SetFontColor(iIndex, crStatus);		
	}

	m_pList_Friends->SetCurSel(iSelPrev); // 전의 선택으로 돌리기..	
}

void CUIFriends::MsgSend_MemberInfo(bool bDisableInterval)
{
	float fTime = CN3Base::TimeGet();
	static float fTimePrev = 0;
	if(bDisableInterval) if(fTime < fTimePrev + 3.0f) return;
	fTimePrev = fTime;


	if(m_MapFriends.empty()) return;
	if(nullptr == m_pList_Friends) return;

	int iFC = m_pList_Friends->GetCount();
	if(iFC <= 0) return;

	int iOffset = 0;
	std::vector<uint8_t> buffers(iFC * 32, 0);

	CAPISocket::MP_AddByte(&(buffers[0]), iOffset, WIZ_FRIEND_PROCESS); // 친구 정보.. Send s1(이름길이), str1(유저이름) | Receive s1(이름길이), str1(유저이름), s1(ID), b2(접속, 파티)
	CAPISocket::MP_AddShort(&(buffers[0]), iOffset, iFC);
	for(int i = 0; i < iFC; i++)
	{
		std::string szID;
		m_pList_Friends->GetString(i, szID);
		CAPISocket::MP_AddShort(&(buffers[0]), iOffset, (int16_t)szID.size());
		CAPISocket::MP_AddString(&(buffers[0]), iOffset, szID);
	}

	CGameProcedure::s_pSocket->Send(&(buffers[0]), iOffset);	
}

void CUIFriends::MsgSend_MemberInfo(const std::string& szID)
{
	if(szID.empty() || szID.size() > 20) return;
	int iFC = 1;

	int iOffset = 0;
	uint8_t byBuff[32];

	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_FRIEND_PROCESS); // 친구 정보.. Send s1(이름길이), str1(유저이름) | Receive s1(이름길이), str1(유저이름), s1(ID), b2(접속, 파티)
	CAPISocket::MP_AddShort(byBuff, iOffset, iFC);

	CAPISocket::MP_AddShort(byBuff, iOffset, (int16_t)szID.size());
	CAPISocket::MP_AddString(byBuff, iOffset, szID);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIFriends::MsgRecv_MemberInfo(Packet& pkt)
{
	std::string szID;
	int iLen = 0;
	int iID = 0;
	uint8_t bStatus = 0;

	int iFC = pkt.read<int16_t>(); 
	for(int i = 0; i < iFC; i++)
	{
		iLen = pkt.read<int16_t>(); // 친구 정보.. Send s1(이름길이), str1(유저이름) | Receive s1(이름길이), str1(유저이름), s1(ID), b2(접속, 파티)
		pkt.readString(szID, iLen);
		iID = pkt.read<int16_t>(); 
		bStatus = pkt.read<uint8_t>();

		it_FI it = m_MapFriends.find(szID);
		if(it == m_MapFriends.end()) continue;

		__FriendsInfo& FI = it->second;
		FI.iID = iID;
		(bStatus & 0x01) ? FI.bOnLine = true : FI.bOnLine = false;
		(bStatus & 0x02) ? FI.bIsParty = true : FI.bIsParty = false;
	}
	this->UpdateList();
}



bool CUIQuest::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	return true;
}

CUIQuest::CUIQuest()
{
}


CUIQuest::~CUIQuest()
{
}



CUIVarious::CUIVarious()
{
	m_pBtn_Knights = nullptr;
	m_pBtn_State = nullptr;
	m_pBtn_Quest = nullptr;
	m_pBtn_Friends = nullptr;
	m_pBtn_Close = nullptr;

	m_pPageState = nullptr;
	m_pPageKnights = nullptr;
	m_pPageQuest = nullptr;
	m_pPageFriends = nullptr;

	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..
}

CUIVarious::~CUIVarious()
{
}

void CUIVarious::Release()
{
	CN3UIBase::Release();
	
	m_pBtn_Knights = nullptr;
	m_pBtn_State = nullptr;
	m_pBtn_Quest = nullptr;
	m_pBtn_Friends = nullptr;
	m_pBtn_Close = nullptr;

	m_pPageState = nullptr;
	m_pPageKnights = nullptr;
	m_pPageQuest = nullptr;
	m_pPageFriends = nullptr;

	m_bOpenningNow = false; // 열리고 있다..
	m_bClosingNow = false;	// 닫히고 있다..
	m_fMoveDelta = 0; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..
}

bool CUIVarious::Load(File& file)
{
	if(CN3UIBase::Load(file)==false) return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Knights, GetChildByID<CN3UIButton>("btn_clan"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_State, GetChildByID<CN3UIButton>("Btn_State"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Quest, GetChildByID<CN3UIButton>("Btn_Quest"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Friends, GetChildByID<CN3UIButton>("Btn_Friends"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Close, GetChildByID<CN3UIButton>("Btn_Close"));

	// 아직 UI 가 안되어 있으니 막자..
	if(m_pBtn_Quest) m_pBtn_Quest->SetState(UI_STATE_BUTTON_DISABLE);
	if(m_pBtn_Friends) m_pBtn_Friends->SetState(UI_STATE_BUTTON_DISABLE);

	if(nullptr == m_pPageState) m_pPageState = new CUIState();
	else m_pPageState->Release();
	m_pPageState->Init(this);

	if(nullptr == m_pPageKnights) m_pPageKnights = new CUIKnights();
	else m_pPageKnights->Release();
	m_pPageKnights->Init(this);
	
	m_pPageQuest = nullptr;
	if(nullptr == m_pPageQuest) m_pPageQuest = new CUIQuest();
	else m_pPageQuest->Release();
	m_pPageQuest->Init(this);
	
	m_pPageFriends = nullptr;
	if(nullptr == m_pPageFriends) m_pPageFriends = new CUIFriends();
	else m_pPageFriends->Release();
	m_pPageFriends->Init(this);
	
	this->UpdatePageButtons(m_pBtn_State);

	return true;
}

bool CUIVarious::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg == UIMSG_BUTTON_CLICK)					
	{
		if(pSender == m_pBtn_Close)			this->Close(); // 닫는다..
		else if(pSender == m_pBtn_State)	this->UpdatePageButtons(m_pBtn_State);
		else if(pSender == m_pBtn_Quest)	this->UpdatePageButtons(m_pBtn_Quest);		// 퀘스트...
		else if(pSender == m_pBtn_Knights)	this->UpdatePageButtons(m_pBtn_Knights);	// 기사단... 잠시 막자..
		else if(pSender == m_pBtn_Friends)	this->UpdatePageButtons(m_pBtn_Friends);
	}

	return true;
}

void CUIVarious::UpdatePageButtons(CN3UIButton* pButtonToActive)
{
	static CN3UIButton* pButtonPrev = nullptr;
	if(nullptr == pButtonToActive || pButtonToActive == pButtonPrev) return;
	pButtonPrev = pButtonToActive;

	CN3UIButton*	pBtns[4] = { m_pBtn_Knights, m_pBtn_State, m_pBtn_Quest, m_pBtn_Friends };
	CN3UIBase*		pPages[4] = { m_pPageKnights, m_pPageState, m_pPageQuest, m_pPageFriends };
	
	for(int i = 0; i < 4; i++)
	{
		if(nullptr == pBtns[i]) continue;

		if(pBtns[i] == pButtonToActive)
		{
			pBtns[i]->SetState(UI_STATE_BUTTON_DOWN);
			if(pPages[i]) pPages[i]->SetVisible(true);
		}
		else
		{
			pBtns[i]->SetState(UI_STATE_BUTTON_NORMAL);
			if(pPages[i]) pPages[i]->SetVisible(false);
		}
	}

	if(pButtonToActive == m_pBtn_Friends && m_pPageFriends)
		m_pPageFriends->MsgSend_MemberInfo(false); // 이러면 친구리스트를 업데이트한다..
}

void CUIVarious::Open()
{
	// 스르륵 열린다!!
	this->SetVisible(true);
	RECT rc = this->GetRegion();
	this->SetPos(-(rc.right - rc.left), 80);
	m_fMoveDelta = 0;
	m_bOpenningNow = true;
	m_bClosingNow = false;

	// 기사단 리스트가 없으면 요청해서 받는다.
//	__InfoPlayerMySelf*	pInfoExt = &(CGameBase::s_pPlayer->m_InfoExt);
//	if(m_pPageKnights->NeedMemberListRequest() && CGameBase::s_pPlayer->m_InfoBase.iKnightsID > 0)
//	{
//		m_pPageKnights->MsgSend_MemberInfoOnline(0);
//	}
//	// 기사단장이거나 간부급이면...UI 가 달라야 한다..
//	m_pPageKnights->ChangeUIByDuty(pInfoExt->eKnightsDuty); // 권한에 따라 UI 변경..
}

void CUIVarious::Close()
{
	// 스르륵 닫힌다..!!
//	SetVisible(false); // 다 닫히고 나서 해준다..
	this->SetPos(0, 80);
	m_fMoveDelta = 0;
	m_bOpenningNow = false;
	m_bClosingNow = true;

	if(m_pSnd_CloseUI) m_pSnd_CloseUI->Play(); // 닫는 소리..
}

void CUIVarious::Tick()
{
	if(m_pPageKnights)
	{
		m_pPageKnights->m_fTimeLimit_Admit += CN3Base::s_fSecPerFrm;
		m_pPageKnights->m_fTimeLimit_Appoint += CN3Base::s_fSecPerFrm;
		m_pPageKnights->m_fTimeLimit_Refresh += CN3Base::s_fSecPerFrm;
		m_pPageKnights->m_fTimeLimit_Remove += CN3Base::s_fSecPerFrm;
	}

	if(m_bOpenningNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = 0;
		ptCur.x = (int)(m_fMoveDelta - fWidth);
		if(ptCur.x >= iXLimit) // 다열렸다!!
		{
			ptCur.x = iXLimit;
			m_bOpenningNow = false;
		}

		this->SetPos(ptCur.x, ptCur.y);
	}
	else if(m_bClosingNow) // 오른쪽에서 왼쪽으로 스르륵...열려야 한다면..
	{
		POINT ptCur = this->GetPos();
		RECT rc = this->GetRegion();
		float fWidth = (float)(rc.right - rc.left);

		float fDelta = 5000.0f * CN3Base::s_fSecPerFrm;
		fDelta *= (fWidth - m_fMoveDelta) / fWidth;
		if(fDelta < 2.0f) fDelta = 2.0f;
		m_fMoveDelta += fDelta;

		int iXLimit = (int)-fWidth;
		ptCur.x = (int)-m_fMoveDelta;
		if(ptCur.x <= iXLimit) // 다 닫혔다..!!
		{
			ptCur.x = iXLimit;
			m_bClosingNow = false;

			this->SetVisibleWithNoSound(false, false, true); // 다 닫혔으니 눈에서 안보이게 한다.
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
		}

		this->SetPos(ptCur.x, ptCur.y);
	}

	CN3UIBase::Tick();
}

void CUIVarious::UpdateAllStates(const __InfoPlayerBase* pInfoBase, const __InfoPlayerMySelf* pInfoExt)
{
	if(nullptr == pInfoBase || nullptr == pInfoExt) return;
	
	std::string szVal;
	
	if(m_pPageState->m_pText_Class) // 직업
	{
		CGameBase::GetTextByClass(pInfoBase->eClass, szVal);
		m_pPageState->m_pText_Class->SetString(szVal);
	}

	// 종족
	if(m_pPageState->m_pText_Race) 
	{
		CGameBase::GetTextByRace(pInfoBase->eRace, szVal);
		m_pPageState->m_pText_Race->SetString(szVal);
	}
	
	// 국가
	if(m_pPageState->m_pText_Nation)
	{
		CGameBase::GetTextByNation(pInfoBase->eNation, szVal);
		m_pPageState->m_pText_Nation->SetString(szVal);
	}

	m_pPageState->UpdateLevel(pInfoBase->iLevel);
	m_pPageState->UpdateExp(pInfoExt->iExp, pInfoExt->iExpNext);
	m_pPageState->UpdateHP(pInfoBase->iHP, pInfoBase->iHPMax);
	m_pPageState->UpdateMSP(pInfoExt->iMSP, pInfoExt->iMSPMax);
	m_pPageState->UpdateWeight(pInfoExt->iWeight, pInfoExt->iWeightMax);
	
	m_pPageState->UpdateAttackPoint(pInfoExt->iAttack, pInfoExt->iAttack_Delta);
	m_pPageState->UpdateGuardPoint(pInfoExt->iGuard, pInfoExt->iGuard_Delta);
	m_pPageState->UpdateBonusPointAndButtons(pInfoExt->iBonusPointRemain);  // 보너스 포인트 적용이 가능한가??
	
	m_pPageState->UpdateStrength(pInfoExt->iStrength, pInfoExt->iStrength_Delta);
	m_pPageState->UpdateStamina(pInfoExt->iStamina, pInfoExt->iStamina_Delta);
	m_pPageState->UpdateDexterity(pInfoExt->iDexterity, pInfoExt->iDexterity_Delta);
	m_pPageState->UpdateIntelligence(pInfoExt->iIntelligence, pInfoExt->iIntelligence_Delta);
	m_pPageState->UpdateMagicAttak(pInfoExt->iMagicAttak, pInfoExt->iMagicAttak_Delta);
	
	m_pPageState->UpdateRegistFire(pInfoExt->iRegistFire, pInfoExt->iRegistFire_Delta);
	m_pPageState->UpdateRegistCold(pInfoExt->iRegistCold, pInfoExt->iRegistCold_Delta);
	m_pPageState->UpdateRegistMagic(pInfoExt->iRegistMagic, pInfoExt->iRegistMagic_Delta);
	m_pPageState->UpdateRegistCurse(pInfoExt->iRegistCurse, pInfoExt->iRegistCurse_Delta);
	m_pPageState->UpdateRegistLight(pInfoExt->iRegistLight, pInfoExt->iRegistLight_Delta);
	m_pPageState->UpdateRegistPoison(pInfoExt->iRegistPoison, pInfoExt->iRegistPoison_Delta);

	// 기사단 관련 정보 업데이트...
	m_pPageState->UpdateRealmPoint(pInfoExt->iRealmPoint, pInfoExt->iRealmPointMonthly); // Edited by @Demircivi while integrating monthly np system.  // 국가 기여도는 10을 나누어서 표시

	// 캐릭터 능력치 포인트 이미지 업데이트..
	if (m_pPageState->m_pImg_Str) m_pPageState->m_pImg_Str->SetVisible(false);
	if (m_pPageState->m_pImg_Sta) m_pPageState->m_pImg_Sta->SetVisible(false);
	if (m_pPageState->m_pImg_Dex) m_pPageState->m_pImg_Dex->SetVisible(false);
	if (m_pPageState->m_pImg_Int) m_pPageState->m_pImg_Int->SetVisible(false);
	if (m_pPageState->m_pImg_MAP) m_pPageState->m_pImg_MAP->SetVisible(false);

	switch ( pInfoBase->eClass )
	{
		case CLASS_KA_WARRIOR:
		case CLASS_KA_BERSERKER:
		case CLASS_EL_WARRIOR:
		case CLASS_EL_BLADE:
			if (m_pPageState->m_pImg_Str) m_pPageState->m_pImg_Str->SetVisible(true);
			if (m_pPageState->m_pImg_Sta) m_pPageState->m_pImg_Sta->SetVisible(true);
			break;

		case CLASS_KA_ROGUE:
		case CLASS_KA_HUNTER:
		case CLASS_EL_ROGUE:
		case CLASS_EL_RANGER:
			if (m_pPageState->m_pImg_Sta) m_pPageState->m_pImg_Sta->SetVisible(true);
			if (m_pPageState->m_pImg_Dex) m_pPageState->m_pImg_Dex->SetVisible(true);
			break;

		case CLASS_KA_WIZARD:
		case CLASS_KA_SORCERER:
		case CLASS_EL_WIZARD:
		case CLASS_EL_MAGE:
			if (m_pPageState->m_pImg_Int) m_pPageState->m_pImg_Int->SetVisible(true);
			if (m_pPageState->m_pImg_MAP) m_pPageState->m_pImg_MAP->SetVisible(true);
			break;

		case CLASS_KA_PRIEST:
		case CLASS_KA_SHAMAN:
		case CLASS_EL_PRIEST:
		case CLASS_EL_CLERIC:
			if (m_pPageState->m_pImg_Str) m_pPageState->m_pImg_Str->SetVisible(true);
			if (m_pPageState->m_pImg_Int) m_pPageState->m_pImg_Int->SetVisible(true);
			break;
	}
}

void CUIVarious::UpdateKnightsInfo()
{
	if(nullptr == m_pPageKnights) return;

	/*
		m_pPageKnights->UpdateKnightsDuty(CGameBase::s_pPlayer->m_InfoExt.eKnightsDuty);
		m_pPageKnights->UpdateKnightsName(CGameBase::s_pPlayer->m_InfoExt.szKnights);
		m_pPageKnights->UpdateKnightsGrade(CGameBase::s_pPlayer->m_InfoExt.iKnightsGrade);
		m_pPageKnights->UpdateKnightsRank(CGameBase::s_pPlayer->m_InfoExt.iKnightsRank);
	*/

	m_pPageKnights->UpdateExceptList();
}

bool CUIVarious::OnKeyPress(int iKey)
{
	if(DIK_ESCAPE == iKey)
	{
		if(!m_bClosingNow) this->Close();
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

void CUIVarious::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

void CUIVarious::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	if(bReFocus)
	{
		if(bVisible)
			CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
		else
			CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
	}
}

// ===== END WarFare/UIVarious.cpp =====

// ===== BEGIN WarFare/UIVarious.h =====
#line 1 "WarFare/UIVarious.h"
﻿// UIVarious.h: interface for the CUIState class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIVarious_H__094F9A3E_1620_4E07_8726_82881B21B48C__INCLUDED_)
#define AFX_UIVarious_H__094F9A3E_1620_4E07_8726_82881B21B48C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"

#include <N3Base/N3UIBase.h>

#include <string>
#include <list>

class CUIState : public CN3UIBase  
{
public:
	CN3UIString*	m_pText_ID;
	CN3UIString*	m_pText_Level;
	CN3UIString*	m_pText_RealmPoint;

	CN3UIString*	m_pText_Class;
	CN3UIString*	m_pText_Race;
	CN3UIString*	m_pText_Nation;

	CN3UIString*	m_pText_HP;
	CN3UIString*	m_pText_MP;
	CN3UIString*	m_pText_Exp;
	CN3UIString*	m_pText_AP;			// 공격력
	CN3UIString*	m_pText_GP;			// 방어력
	CN3UIString*	m_pText_Weight;

	CN3UIString*	m_pText_BonusPoint;

	CN3UIButton*	m_pBtn_Strength;
	CN3UIButton*	m_pBtn_Stamina;
	CN3UIButton*	m_pBtn_Dexterity;
	CN3UIButton*	m_pBtn_MagicAttak;
	CN3UIButton*	m_pBtn_Intelligence;

	CN3UIString*	m_pText_Strength;
	CN3UIString*	m_pText_Stamina;
	CN3UIString*	m_pText_Dexterity;
	CN3UIString*	m_pText_MagicAttak;
	CN3UIString*	m_pText_Intelligence;

	CN3UIString*	m_pText_RegistFire;
	CN3UIString*	m_pText_RegistMagic;
	CN3UIString*	m_pText_RegistIce;
	CN3UIString*	m_pText_RegistCurse;
	CN3UIString*	m_pText_RegistLight;
	CN3UIString*	m_pText_RegistPoison;

	CN3UIBase*		m_pImg_MAP;
	CN3UIBase*		m_pImg_Sta;
	CN3UIBase*		m_pImg_Int;
	CN3UIBase*		m_pImg_Dex;
	CN3UIBase*		m_pImg_Str;

public:
	void	UpdateBonusPointAndButtons(int iBonusPointRemain); // 보너스 포인트 적용이 가능한가??

	void	UpdateID(const std::string& szID);
	void	UpdateLevel(int iVal);
	void	UpdateRealmPoint(int iLoyalty, int iLoyaltyMonthly); // Edited by @Demircivi while integrating monthly np system. // 국가 기여도는 10을 나누어서 표시

	void	UpdateHP(int iVal, int iValMax);
	void	UpdateMSP(int iVal, int iValMax);
	void	UpdateExp(int64_t iVal, int64_t iValMax);
	void	UpdateAttackPoint(int iVal, int iDelta);
	void	UpdateGuardPoint(int iVal, int iDelta);
	void	UpdateWeight(int iVal, int iValMax);
	void	UpdateStrength(int iVal, int iDelta);
	void	UpdateStamina(int iVal, int iDelta);
	void	UpdateDexterity(int iVal, int iDelta);
	void	UpdateIntelligence(int iVal, int iDelta);
	void	UpdateMagicAttak(int iVal, int iDelta);

	void	UpdateRegistFire(int iVal, int iDelta);
	void	UpdateRegistCold(int iVal, int iDelta);
	void	UpdateRegistLight(int iVal, int iDelta);
	void	UpdateRegistMagic(int iVal, int iDelta);
	void	UpdateRegistCurse(int iVal, int iDelta);
	void	UpdateRegistPoison(int iVal, int iDelta);

	static std::string FormatWithDelta(int iVal, int iDelta);

	void MsgSendAblityPointChange(uint8_t byType, int16_t siValueDelta); // 능력치 변화 패킷으로 보내기..

	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;

	void Release() override;
	CUIState();
	~CUIState() override;
};

struct __KnightsMemberInfo // 기사 단원 정보..
{
	std::string		szName;
	e_KnightsDuty	eDuty;	// 기사단 직위.
	int				iLevel; // 플레이어 레벨..
	e_Class			eClass; // 직업.
	int				iConnected;
};

typedef std::list<__KnightsMemberInfo>::iterator it_KMI;
#define MAX_CLAN_GRADE	5

class CUIKnights : public CN3UIBase  
{
protected:
	int								m_iPageCur;
	std::list<__KnightsMemberInfo>	m_MemberList;

	CN3UIString*	m_pText_Name;
	CN3UIString*	m_pText_Duty;
	CN3UIString*	m_pText_Page;
	CN3UIString*	m_pText_MemberCount;

	CN3UIImage*		m_pImage_Grade[MAX_CLAN_GRADE];

	CN3UIList*		m_pList_CharGrades;
	CN3UIList*		m_pList_CharIDs;
	CN3UIList*		m_pList_CharLevels;
	CN3UIList*		m_pList_CharJobs;

	CN3UIButton*	m_pBtn_Admit;
	CN3UIButton*	m_pBtn_Appoint;
	CN3UIButton*	m_pBtn_Remove;
	CN3UIButton*	m_pBtn_Refresh;
	CN3UIButton*	m_pBtn_ClanParty;

public:	
	float			m_fTimeLimit_Refresh;
	float			m_fTimeLimit_Appoint;
	float			m_fTimeLimit_Remove;
	float			m_fTimeLimit_Admit;
	
public:
	void Clear();
	void UpdateKnightsName(const std::string& szName);
	void UpdateKnightsDuty(e_KnightsDuty eDuty);
	void UpdateKnightsGrade(int iVal);
	void UpdateKnightsRank(int iVal);
	void UpdateExceptList();
		    
	void MemberListUpdate();
	void MemberListSort();
		    
	void RefreshList(); 
		    
	void MsgSend_MemberInfoAll();

	void SetVisible(bool bVisible) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;

	void ClearLists();

	void UpdatePageNumber(int iNewPageNo = -1);
	void UpdateMemberCount(int iMemberCountOnline, int iMemberCountTotal);

	void PreviousPageButtonHandler();
	void NextPageButtonHandler();
	void RefreshButtonHandler(bool blBypassTime = false);
	void ClanPartyButtonHandler();
	void WhisperButtonHandler();
	void AdmitButtonHandler();
	void RemoveButtonHandler();
	void AppointButtonHandler();

	void Release() override;
	CUIKnights();
	~CUIKnights() override;

	//쓰지 않음....
	bool	NeedMemberListRequest() { if(m_MemberList.empty()) return true; else return false; }
	
	void	ChangeUIByDuty(e_KnightsDuty eDuty);
	//void	VisibleAppointButtons(bool bVisible); // 기사단장 전용 임명 Interface
	
	//void	MsgSend_MemberInfoOnline(int iPage);
	bool	MsgRecv_MemberInfo(Packet& pkt);
	
	//void	MsgSend_MemberJoinAdmit();
	//void	MsgSend_MemberJoinReject();
	//void	MsgSend_MemberPunish();
	//void	MsgSend_MemberRemove();
	//void	MsgSend_DutyAppoint(e_KnightsDuty eDuty);
};

struct __FriendsInfo // 기사 단원 정보..
{
	std::string	szName;
	int			iID; // ID
	bool		bOnLine; // 접속했나?
	bool		bIsParty; // 파티 플레이중인가?

	void Init()
	{
		szName = "";
		iID = -1;
		bOnLine = false;
		bIsParty = false;
	}

	bool operator () (const __FriendsInfo& x, const __FriendsInfo& y) const
	{
		return (x.szName >= y.szName);
	}

	__FriendsInfo()
	{
		Init();
	}
};

typedef std::map<std::string, __FriendsInfo>::iterator it_FI;
typedef std::map<std::string, __FriendsInfo>::value_type val_FI;

class CUIFriends : public CN3UIBase  
{
protected:
	int m_iPageCur;
	std::map<std::string, __FriendsInfo> m_MapFriends;

	CN3UIList* m_pList_Friends;
	CN3UIString* m_pText_Page;

	CN3UIButton* m_pBtn_NextPage;
	CN3UIButton* m_pBtn_PrevPage;
	
	CN3UIButton* m_pBtn_Refresh;
	CN3UIButton* m_pBtn_Party;
	CN3UIButton* m_pBtn_Whisper;
	CN3UIButton* m_pBtn_Add;
	CN3UIButton* m_pBtn_Delete;

public:
	void SaveListToTextFile(const std::string& szID);  // 문자열이 있으면 추가하고.. 없으면 몽땅 저장..
	void MsgSend_MemberInfo(bool bDisableInterval); // 현재 페이지 정보 요청
	void MsgSend_MemberInfo(const std::string& szID); // 이넘만 요청..
	void MsgRecv_MemberInfo(Packet& pkt);
	void UpdateList();
	bool MemberDelete(const std::string& szID);
	bool MemberAdd(const std::string& szID, int iID, bool bOnLine, bool bIsParty);

	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;

	CUIFriends();
	~CUIFriends() override;
};



class CUIQuest : public CN3UIBase
{
public:
	bool Load(File& file) override;

	CUIQuest();
	~CUIQuest() override;
};



class CUIVarious : public CN3UIBase // 다용도 UI
{
public:
	CUIState*		m_pPageState;
	CUIKnights*		m_pPageKnights;
	CUIQuest*		m_pPageQuest;
	CUIFriends*		m_pPageFriends;
	
protected:
	CN3UIButton*	m_pBtn_Knights;
	CN3UIButton*	m_pBtn_State;
	CN3UIButton*	m_pBtn_Quest;
	CN3UIButton*	m_pBtn_Friends;
	CN3UIButton*	m_pBtn_Close;

	bool		m_bOpenningNow; // 열리고 있다..
	bool		m_bClosingNow;	// 닫히고 있다..
	float		m_fMoveDelta; // 부드럽게 열리고 닫히게 만들기 위해서 현재위치 계산에 부동소수점을 쓴다..

public:
	void SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	void SetVisible(bool bVisible) override;
	bool OnKeyPress(int iKey) override;
	void UpdatePageButtons(CN3UIButton* pButtonToActive);
	void UpdateAllStates(const struct __InfoPlayerBase* pInfoBase, const struct __InfoPlayerMySelf* pInfoExt);
	void UpdateKnightsInfo(); // 기사단 관련 정보 업데이트
	void Open();
	void Close();
	
	void Tick() override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool Load(File& file) override;

	void Release() override;
	CUIVarious();
	~CUIVarious() override;
};

#endif // !defined(AFX_UIVarious_H__094F9A3E_1620_4E07_8726_82881B21B48C__INCLUDED_)

// ===== END WarFare/UIVarious.h =====

// ===== BEGIN WarFare/UIWareHouseDlg.cpp =====
#line 1 "WarFare/UIWareHouseDlg.cpp"
﻿// UIWareHouseDlg.cpp: implementation of the UIWareHouseDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIWareHouseDlg.h"
#include "PacketDef.h"
#include "LocalInput.h"
#include "APISocket.h"
#include "GameProcMain.h"
#include "PlayerMySelf.h"
#include "UIImageTooltipDlg.h"
#include "UIInventory.h"
#include "UIManager.h"
#include "CountableItemEditDlg.h"
#include "SubProcPerTrade.h"
#include "UIHotKeyDlg.h"
#include "UISkillTreeDlg.h"
#include "text_resources.h"

#include <N3Base/LogWriter.h>

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIEdit.h>
#include <N3Base/N3SndObj.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIWareHouseDlg::CUIWareHouseDlg()
{
	m_iCurPage = 0;
	for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
			m_pMyWare[j][i] = nullptr;
	}
	
	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		m_pMyWareInv[i] = nullptr;

	m_pUITooltipDlg		= nullptr;
	m_pStrMyGold		= nullptr;
	m_pStrWareGold		= nullptr;

	m_pBtnGold			= nullptr;
	m_pBtnGoldWareHouse = nullptr;
	m_pBtnClose			= nullptr;
	m_pBtnPageUp		= nullptr;
	m_pBtnPageDown		= nullptr;

	m_bSendedItemGold	= false;
	m_iGoldOffsetBackup	= 0;

	SetVisible(false);
}

CUIWareHouseDlg::~CUIWareHouseDlg()
{
	Release();
}

void CUIWareHouseDlg::Release()
{
	CN3UIBase::Release();

	for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
		{
			delete m_pMyWare[j][i];
			m_pMyWare[j][i] = nullptr;
		}
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		delete m_pMyWareInv[i];
		m_pMyWareInv[i] = nullptr;
	}
}

void CUIWareHouseDlg::Render()
{
	// 보이지 않으면 자식들을 render하지 않는다.
	if (!m_bVisible)
		return;

	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	m_pUITooltipDlg->DisplayTooltipsDisable();

	bool bTooltipRender = false;
	__IconItemSkill* spItem = nullptr;

	for (UIListReverseItor itor = m_Children.rbegin(); m_Children.rend() != itor; ++itor)
	{
		CN3UIBase* pChild = (*itor);
		if (GetState() == UI_STATE_ICON_MOVING
			&& pChild->UIType() == UI_TYPE_ICON
			&& s_sSelectedIconInfo.pItemSelect != nullptr
			&& pChild == s_sSelectedIconInfo.pItemSelect->pUIIcon)
			continue;

		pChild->Render();

		if (GetState() == UI_STATE_COMMON_NONE
			&& pChild->UIType() == UI_TYPE_ICON
			&& (pChild->GetStyle() & UISTYLE_ICON_HIGHLIGHT))
		{
			bTooltipRender = true;
			spItem = GetHighlightIconItem((CN3UIIcon*) pChild);
		}
	}

	// 갯수 표시되야 할 아이템 갯수 표시..
	for (int i = 0; i < MAX_ITEM_TRADE; i++)
	{
		__IconItemSkill* spItemWare = m_pMyWare[m_iCurPage][i];
		if (spItemWare != nullptr
			&& (spItemWare->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE || spItemWare->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL))
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i + 100);
			if (pStr != nullptr)
			{
				if ((GetState() == UI_STATE_ICON_MOVING)
					&& (spItemWare == s_sSelectedIconInfo.pItemSelect))
				{
					pStr->SetVisible(false);
				}
				else if (spItemWare->pUIIcon->IsVisible())
				{
					pStr->SetVisible(true);
					pStr->SetStringAsInt(spItemWare->iCount);
					pStr->Render();
				}
				else
				{
					pStr->SetVisible(false);
				}
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i + 100);
			if (pStr != nullptr)
				pStr->SetVisible(false);
		}
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		__IconItemSkill* spItemInv = m_pMyWareInv[i];
		if (spItemInv != nullptr
			&& (spItemInv->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE || spItemInv->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL))
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if (pStr != nullptr)
			{
				if ((GetState() == UI_STATE_ICON_MOVING)
					&& (spItemInv == s_sSelectedIconInfo.pItemSelect))
				{
					pStr->SetVisible(false);
				}
				else if (spItemInv->pUIIcon->IsVisible())
				{
					pStr->SetVisible(true);
					pStr->SetStringAsInt(spItemInv->iCount);
					pStr->Render();
				}
				else
				{
					pStr->SetVisible(false);
				}
			}
		}
		else
		{
			// string 얻기..
			CN3UIString* pStr = GetChildStringByiOrder(i);
			if (pStr != nullptr)
				pStr->SetVisible(false);
		}
	}

	if (GetState() == UI_STATE_ICON_MOVING
		&& s_sSelectedIconInfo.pItemSelect != nullptr)
		s_sSelectedIconInfo.pItemSelect->pUIIcon->Render();

	if (bTooltipRender
		&& spItem != nullptr)
		m_pUITooltipDlg->DisplayTooltipsEnable(ptCur.x, ptCur.y, spItem);
}

void CUIWareHouseDlg::InitIconWnd(e_UIWND eWnd)
{
	__TABLE_UI_RESRC* pTbl = CGameBase::s_pTbl_UI.Find(CGameBase::s_pPlayer->m_InfoBase.eNation);

	m_pUITooltipDlg = new CUIImageTooltipDlg();
	m_pUITooltipDlg->Init(this);
	m_pUITooltipDlg->LoadFromFile(pTbl->szItemInfo);
	m_pUITooltipDlg->InitPos();
	m_pUITooltipDlg->SetVisible(false);	

	CN3UIWndBase::InitIconWnd(eWnd);

	N3_VERIFY_UI_COMPONENT(m_pStrWareGold,	GetChildByID<CN3UIString>("string_wareitem_name"));
	if (m_pStrWareGold != nullptr)
		m_pStrWareGold->SetString("0");

	N3_VERIFY_UI_COMPONENT(m_pStrMyGold,	GetChildByID<CN3UIString>("string_item_name"));
	if (m_pStrMyGold)
		m_pStrMyGold->SetString("0");
}

void CUIWareHouseDlg::InitIconUpdate()
{
	float fUVAspect = (float) 45.0f / (float) 64.0f;

	for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
		{
			if (m_pMyWare[j][i] != nullptr)
			{
				m_pMyWare[j][i]->pUIIcon = new CN3UIIcon();
				m_pMyWare[j][i]->pUIIcon->Init(this);
				m_pMyWare[j][i]->pUIIcon->SetTex(m_pMyWare[j][i]->szIconFN);
				m_pMyWare[j][i]->pUIIcon->SetUVRect(0, 0, fUVAspect, fUVAspect);
				m_pMyWare[j][i]->pUIIcon->SetUIType(UI_TYPE_ICON);
				m_pMyWare[j][i]->pUIIcon->SetStyle(UISTYLE_ICON_ITEM | UISTYLE_ICON_CERTIFICATION_NEED);
	
				CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, i);
				if (pArea != nullptr)
				{
					m_pMyWare[j][i]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyWare[j][i]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
		}
	}
}

int CUIWareHouseDlg::GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist)
{
	int iReturn = -1;

	switch (eWndDist)
	{
		case UIWND_DISTRICT_TRADE_NPC:
			for (int i = 0; i < MAX_ITEM_TRADE; i++)
			{
				if (m_pMyWare[m_iCurPage][i] != nullptr
					&& m_pMyWare[m_iCurPage][i] == spItem)
					return i;
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
			{
				if (m_pMyWareInv[i] != nullptr
					&& m_pMyWareInv[i] == spItem)
					return i;
			}
			break;
	}

	return iReturn;
}

RECT CUIWareHouseDlg::GetSampleRect()
{
	POINT ptCur = CGameProcedure::s_pLocalInput->MouseGetPos();
	CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, 0);

	RECT rect = pArea->GetRegion();

	float fWidth = (float) (rect.right - rect.left) * 0.5f;
	float fHeight = (float) (rect.bottom - rect.top) * 0.5f;

	rect.left	= ptCur.x - (int) fWidth;
	rect.right	= ptCur.x + (int) fWidth;
	rect.top	= ptCur.y - (int) fHeight;
	rect.bottom	= ptCur.y + (int) fHeight;

	return rect;
}

e_UIWND_DISTRICT CUIWareHouseDlg::GetWndDistrict(__IconItemSkill* spItem)
{
	for (int i = 0; i < MAX_ITEM_TRADE; i++)
	{
		if (m_pMyWare[m_iCurPage][i] != nullptr
			&& m_pMyWare[m_iCurPage][i] == spItem)
			return UIWND_DISTRICT_TRADE_NPC;
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		if (m_pMyWareInv[i] != nullptr
			&& m_pMyWareInv[i] == spItem)
			return UIWND_DISTRICT_TRADE_MY;
	}
	return UIWND_DISTRICT_UNKNOWN;
}

uint32_t CUIWareHouseDlg::MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld)
{
	uint32_t dwRet = UI_MOUSEPROC_NONE;
	if (!m_bVisible)
		return dwRet;

	if (s_bWaitFromServer)
	{
		dwRet |= CN3UIBase::MouseProc(dwFlags, ptCur, ptOld);
		return dwRet;
	}

	// 드래그 되는 아이콘 갱신..
	if (GetState() == UI_STATE_ICON_MOVING
		&& s_sSelectedIconInfo.UIWndSelect.UIWnd == UIWND_WARE_HOUSE)
	{
		s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
		s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
	}

	return CN3UIWndBase::MouseProc(dwFlags, ptCur, ptOld);
}

bool CUIWareHouseDlg::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
// Temp Define
#define FAIL_CODE {		\
				SetState(UI_STATE_COMMON_NONE);	\
				return false;	\
			}

	if (pSender == nullptr)
		return false;

	if (dwMsg == UIMSG_BUTTON_CLICK)
	{
		if (pSender == m_pBtnGold)
		{
			// 인벤토리만 떠 있을때..
			s_pCountableItemEdit->Open(UIWND_WARE_HOUSE, UIWND_DISTRICT_TRADE_MY, true, true);
			return true;
		}

		if (pSender == m_pBtnGoldWareHouse)
		{
			// 인벤토리만 떠 있을때..
			s_pCountableItemEdit->Open(UIWND_WARE_HOUSE, UIWND_DISTRICT_TRADE_NPC, true, true);
			return true;
		}

		if (pSender == m_pBtnClose)
			LeaveWareHouseState();

		CN3UIString* pStr = nullptr;

		if (pSender == m_pBtnPageUp)
		{
			m_iCurPage--;
			if (m_iCurPage < 0)
				m_iCurPage = 0;

			N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
			if (pStr != nullptr)
			{
				std::string pageNo = std::to_string(m_iCurPage + 1);
				pStr->SetString(pageNo);
			}

			for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
			{
				if (j == m_iCurPage)
				{
					for (int i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyWare[j][i] != nullptr)
							m_pMyWare[j][i]->pUIIcon->SetVisible(true);
					}
				}
				else
				{
					for (int i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyWare[j][i] != nullptr)
							m_pMyWare[j][i]->pUIIcon->SetVisible(false);
					}
				}
			}
		}

		if (pSender == m_pBtnPageDown)
		{
			m_iCurPage++;
			if (m_iCurPage >= MAX_ITEM_WARE_PAGE)
				m_iCurPage = MAX_ITEM_WARE_PAGE - 1;

			N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
			if (pStr != nullptr)
			{
				std::string pageNo = std::to_string(m_iCurPage + 1);
				pStr->SetString(pageNo);
			}

			for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
			{
				if (j == m_iCurPage)
				{
					for (int i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyWare[j][i] != nullptr)
							m_pMyWare[j][i]->pUIIcon->SetVisible(true);
					}
				}
				else
				{
					for (int i = 0; i < MAX_ITEM_TRADE; i++)
					{
						if (m_pMyWare[j][i] != nullptr)
							m_pMyWare[j][i]->pUIIcon->SetVisible(false);
					}
				}
			}
		}
	}

	__IconItemSkill* spItem = nullptr;
	e_UIWND_DISTRICT eUIWnd;
	int iOrder;

	uint32_t dwBitMask = 0x000f0000;

	switch (dwMsg & dwBitMask)
	{
		case UIMSG_ICON_DOWN_FIRST:
			AllHighLightIconFree();

			// Get Item..
			spItem = GetHighlightIconItem((CN3UIIcon*) pSender);

			// Save Select Info..
			s_sSelectedIconInfo.UIWndSelect.UIWnd = UIWND_WARE_HOUSE;
			eUIWnd = GetWndDistrict(spItem);
			if (eUIWnd == UIWND_DISTRICT_UNKNOWN)
				FAIL_CODE

			s_sSelectedIconInfo.UIWndSelect.UIWndDistrict = eUIWnd;
			iOrder = GetItemiOrder(spItem, eUIWnd);
			if (iOrder == -1)
				FAIL_CODE

			s_sSelectedIconInfo.UIWndSelect.iOrder = iOrder;
			s_sSelectedIconInfo.pItemSelect = spItem;

			// Do Ops..
			pSender->SetRegion(GetSampleRect());
			pSender->SetMoveRect(GetSampleRect());

			// Sound..
			if (spItem != nullptr)
				PlayItemSound(spItem->pItemBasic);
			break;

		case UIMSG_ICON_UP:
			// 아이콘 매니저 윈도우들을 돌아 다니면서 검사..
			// 아이콘 위치 원래대로..
			if (!CGameProcedure::s_pUIMgr->BroadcastIconDropMsg(s_sSelectedIconInfo.pItemSelect))
				IconRestore();

			// Sound..
			if (s_sSelectedIconInfo.pItemSelect != nullptr)
				PlayItemSound(s_sSelectedIconInfo.pItemSelect->pItemBasic);
			break;

		case UIMSG_ICON_DOWN:
			if (GetState() == UI_STATE_ICON_MOVING)
			{
				s_sSelectedIconInfo.pItemSelect->pUIIcon->SetRegion(GetSampleRect());
				s_sSelectedIconInfo.pItemSelect->pUIIcon->SetMoveRect(GetSampleRect());
			}
			break;
	}

	return true;
}

bool CUIWareHouseDlg::OnMouseWheelEvent(short delta)
{
	if (delta > 0)
		ReceiveMessage(m_pBtnPageUp, UIMSG_BUTTON_CLICK);
	else
		ReceiveMessage(m_pBtnPageDown, UIMSG_BUTTON_CLICK);

	return true;
}

void CUIWareHouseDlg::LeaveWareHouseState()
{
	if (IsVisible())
		SetVisible(false);

	if (GetState() == UI_STATE_ICON_MOVING)
		IconRestore();

	SetState(UI_STATE_COMMON_NONE);
	AllHighLightIconFree();

	// 이 윈도우의 inv 영역의 아이템을 이 인벤토리 윈도우의 inv영역으로 옮긴다..	
	ItemMoveFromThisToInv();

	if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
		CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

	if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
		CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
}

void CUIWareHouseDlg::EnterWareHouseStateStart(int iWareGold)
{
	for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
	{
		for (int i = 0; i < MAX_ITEM_TRADE; i++)
		{
			if (m_pMyWare[j][i] != nullptr)
			{
				if (m_pMyWare[j][i]->pUIIcon != nullptr)
				{
					RemoveChild(m_pMyWare[j][i]->pUIIcon);
					m_pMyWare[j][i]->pUIIcon->Release();
					delete m_pMyWare[j][i]->pUIIcon;
					m_pMyWare[j][i]->pUIIcon = nullptr;
				}

				delete m_pMyWare[j][i];
				m_pMyWare[j][i] = nullptr;
			}
		}
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		if (m_pMyWareInv[i] != nullptr)
		{
			if (m_pMyWareInv[i]->pUIIcon != nullptr)
			{
				RemoveChild(m_pMyWareInv[i]->pUIIcon);
				m_pMyWareInv[i]->pUIIcon->Release();
				delete m_pMyWareInv[i]->pUIIcon;
				m_pMyWareInv[i]->pUIIcon = nullptr;
			}

			delete m_pMyWareInv[i];
			m_pMyWareInv[i] = nullptr;
		}
	}

	if (m_pStrWareGold != nullptr)
		m_pStrWareGold->SetString(CGameBase::FormatNumber(iWareGold));
}

void CUIWareHouseDlg::EnterWareHouseStateEnd()
{
	InitIconUpdate();

	m_iCurPage = 0;

	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_page"));
	if (pStr != nullptr)
	{
		std::string pageNo = std::to_string(m_iCurPage + 1);
		pStr->SetString(pageNo);
	}

	for (int j = 0; j < MAX_ITEM_WARE_PAGE; j++)
	{
		if (j == m_iCurPage)
		{
			for (int i = 0; i < MAX_ITEM_TRADE; i++)
			{
				if (m_pMyWare[j][i] != nullptr)
					m_pMyWare[j][i]->pUIIcon->SetVisible(true);
			}
		}
		else
		{
			for (int i = 0; i < MAX_ITEM_TRADE; i++)
			{
				if (m_pMyWare[j][i] != nullptr)
					m_pMyWare[j][i]->pUIIcon->SetVisible(false);
			}
		}
	}

	ItemMoveFromInvToThis();

	if (m_pStrMyGold != nullptr)
	{
		__InfoPlayerMySelf* pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;
		m_pStrMyGold->SetString(CGameBase::FormatNumber(pInfoExt->iGold));
	}
}

__IconItemSkill* CUIWareHouseDlg::GetHighlightIconItem(CN3UIIcon* pUIIcon)
{
	for (int i = 0; i < MAX_ITEM_TRADE; i++)
	{
		if (m_pMyWare[m_iCurPage][i] != nullptr
			&& m_pMyWare[m_iCurPage][i]->pUIIcon == pUIIcon)
			return m_pMyWare[m_iCurPage][i];
	}

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		if (m_pMyWareInv[i] != nullptr
			&& m_pMyWareInv[i]->pUIIcon == pUIIcon)
			return m_pMyWareInv[i];
	}

	return nullptr;
}

void CUIWareHouseDlg::IconRestore()
{
	switch (s_sSelectedIconInfo.UIWndSelect.UIWndDistrict)
	{
		case UIWND_DISTRICT_TRADE_NPC:
			if (m_pMyWare[m_iCurPage][s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr)
			{
				CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, s_sSelectedIconInfo.UIWndSelect.iOrder);
				if (pArea != nullptr)
				{
					m_pMyWare[m_iCurPage][s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyWare[m_iCurPage][s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			if (m_pMyWareInv[s_sSelectedIconInfo.UIWndSelect.iOrder] != nullptr)
			{
				CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sSelectedIconInfo.UIWndSelect.iOrder);
				if (pArea != nullptr)
				{
					m_pMyWareInv[s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
					m_pMyWareInv[s_sSelectedIconInfo.UIWndSelect.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
				}
			}
			break;
	}
}

bool CUIWareHouseDlg::ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur)
{
// Temp Define 
#define FAIL_RETURN {	\
		AllHighLightIconFree();	\
		SetState(UI_STATE_COMMON_NONE);	\
		return false;	\
	}

	CN3UIArea* pArea = nullptr;
	e_UIWND_DISTRICT eUIWnd = UIWND_DISTRICT_UNKNOWN;
	if (!m_bVisible)
		return false;

	// 내가 가졌던 아이콘이 아니면..
	if (s_sSelectedIconInfo.UIWndSelect.UIWnd != m_eUIWnd)
		FAIL_RETURN

	if (s_sSelectedIconInfo.UIWndSelect.UIWndDistrict != UIWND_DISTRICT_TRADE_NPC
		&& s_sSelectedIconInfo.UIWndSelect.UIWndDistrict != UIWND_DISTRICT_TRADE_MY)
		FAIL_RETURN

	// 내가 가졌던 아이콘이면.. npc영역인지 검사한다..
	int iDestiOrder = -1; bool bFound = false;
	for (int i = 0; i < MAX_ITEM_TRADE; i++)
	{
		pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, i);
		if (pArea != nullptr && pArea->IsIn(ptCur.x, ptCur.y))
		{
			bFound = true;
			eUIWnd = UIWND_DISTRICT_TRADE_NPC;
			iDestiOrder = i;
			break;
		}
	}

	if (!bFound)
	{
		for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
		{
			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, i);
			if (pArea != nullptr && pArea->IsIn(ptCur.x, ptCur.y))
			{
				bFound = true;
				eUIWnd = UIWND_DISTRICT_TRADE_MY;
				iDestiOrder = i;
				break;
			}
		}
	}

	if (!bFound)
		FAIL_RETURN

	// 본격적으로 Recovery Info를 활용하기 시작한다..
	// 먼저 WaitFromServer를 On으로 하고.. Select Info를 Recovery Info로 복사.. 이때 Dest는 팰요없다..
	if (spItem != s_sSelectedIconInfo.pItemSelect)
		s_sSelectedIconInfo.pItemSelect = spItem;

	s_bWaitFromServer									= true;
	s_sRecoveryJobInfo.pItemSource						= s_sSelectedIconInfo.pItemSelect;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWnd			= s_sSelectedIconInfo.UIWndSelect.UIWnd;
	s_sRecoveryJobInfo.UIWndSourceStart.UIWndDistrict	= s_sSelectedIconInfo.UIWndSelect.UIWndDistrict;
	s_sRecoveryJobInfo.UIWndSourceStart.iOrder			= s_sSelectedIconInfo.UIWndSelect.iOrder;
	s_sRecoveryJobInfo.pItemTarget						= nullptr;

	s_sRecoveryJobInfo.UIWndSourceEnd.UIWnd				= UIWND_WARE_HOUSE;
	s_sRecoveryJobInfo.UIWndSourceEnd.UIWndDistrict		= eUIWnd;

	switch (s_sSelectedIconInfo.UIWndSelect.UIWndDistrict)
	{
		case UIWND_DISTRICT_TRADE_NPC:
			// 빼는 경우..
			if (eUIWnd == UIWND_DISTRICT_TRADE_MY)
			{
				if (s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
					|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
				{
					// 활이나 물약등 아이템인 경우..
					// 면저 인벤토리에 해당 아이콘이 있는지 알아본다..
					bFound = false;

					for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
					{
						if (m_pMyWareInv[i] != nullptr
							&& m_pMyWareInv[i]->pItemBasic->dwID == s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID
							&& m_pMyWareInv[i]->pItemExt->dwID == s_sSelectedIconInfo.pItemSelect->pItemExt->dwID)
						{
							bFound = true;
							iDestiOrder = i;
							s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;
							break;
						}
					}

					// 못찾았으면.. 
					if (!bFound)
					{
						// 해당 위치에 아이콘이 있으면..
						if (m_pMyWareInv[iDestiOrder] != nullptr)
						{
							// 인벤토리 빈슬롯을 찾아 들어간다..
							for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
							{
								if (m_pMyWareInv[i] == nullptr)
								{
									bFound = true;
									iDestiOrder = i;
									break;
								}
							}

							// 빈 슬롯을 찾지 못했으면..
							if (!bFound)
							{
								s_bWaitFromServer				= false;
								s_sRecoveryJobInfo.pItemSource	= nullptr;
								s_sRecoveryJobInfo.pItemTarget	= nullptr;
								FAIL_RETURN
							}
						}
					}

					s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
					s_bWaitFromServer							= false;

					s_pCountableItemEdit->Open(UIWND_WARE_HOUSE, s_sSelectedIconInfo.UIWndSelect.UIWndDistrict, false);
					FAIL_RETURN
				}
				else
				{
					// 일반 아이템인 경우..
					// 해당 위치에 아이콘이 있으면..
					if (m_pMyWareInv[iDestiOrder] != nullptr)
					{
						// 인벤토리 빈슬롯을 찾아 들어간다..
						bFound = false;
						for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
						{
							if (m_pMyWareInv[i] == nullptr)
							{
								bFound = true;
								iDestiOrder = i;
								break;
							}
						}

						// 빈 슬롯을 찾지 못했으면..
						if (!bFound)
						{
							s_bWaitFromServer					= false;
							s_sRecoveryJobInfo.pItemSource		= nullptr;
							s_sRecoveryJobInfo.pItemTarget		= nullptr;
							FAIL_RETURN
						}
					}

					s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;

					// 무게 체크..
					__InfoPlayerMySelf* pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;
					if ((pInfoExt->iWeight + s_sRecoveryJobInfo.pItemSource->pItemBasic->siWeight) > pInfoExt->iWeightMax)
					{
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);

						s_bWaitFromServer				= false;
						s_sRecoveryJobInfo.pItemSource	= nullptr;
						s_sRecoveryJobInfo.pItemTarget	= nullptr;
						FAIL_RETURN
					}

					SendToServerFromWareMsg(
						s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
						m_iCurPage,
						s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
						iDestiOrder,
						s_sRecoveryJobInfo.pItemSource->iCount);

					m_pMyWareInv[iDestiOrder] = m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

					pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, iDestiOrder);
					if (pArea != nullptr)
					{
						m_pMyWareInv[iDestiOrder]->pUIIcon->SetRegion(pArea->GetRegion());
						m_pMyWareInv[iDestiOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					}
					FAIL_RETURN
				}
			}
			else
			{
				// 이동.. 
				__IconItemSkill* spItemSource, *spItemTarget = nullptr;
				spItemSource = s_sRecoveryJobInfo.pItemSource;

				pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, iDestiOrder);
				if (pArea != nullptr)
				{
					spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
					spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;

				// 창고 내에서 이동..	(모두 일반 아이템으로 취급한다..)
				// 해당 위치에 아이콘이 있으면..
				if (m_pMyWare[m_iCurPage][iDestiOrder] != nullptr)
				{
					s_bWaitFromServer				= false;
					s_sRecoveryJobInfo.pItemSource	= nullptr;
					s_sRecoveryJobInfo.pItemTarget	= nullptr;
					FAIL_RETURN
				}
				else
				{
					s_sRecoveryJobInfo.pItemTarget = nullptr;
				}

				m_pMyWare[m_iCurPage][iDestiOrder] = spItemSource;
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemTarget;

				// 이동 메시지를 보낸다..
				SendToServerWareToWareMsg(
					s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
					m_iCurPage,
					s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
					iDestiOrder);

				FAIL_RETURN
			}
			break;

		case UIWND_DISTRICT_TRADE_MY:
			// 넣는 경우..
			if (eUIWnd == UIWND_DISTRICT_TRADE_NPC)
			{
				if (s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
					|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
				{
					// 활이나 물약등 아이템인 경우..
					// 면저 Ware에 아이콘이 있는지 알아본다..
					bFound = false;

					// 10개의 폐이지를 다 뒤진다..
					for (int iPage = 0; iPage < MAX_ITEM_WARE_PAGE; iPage++)
					{
						if (bFound)
							break;

						for (int i = 0; i < MAX_ITEM_TRADE; i++)
						{
							if (m_pMyWare[iPage][i] != nullptr
								&& m_pMyWare[iPage][i]->pItemBasic->dwID == s_sSelectedIconInfo.pItemSelect->pItemBasic->dwID
								&& m_pMyWare[iPage][i]->pItemExt->dwID == s_sSelectedIconInfo.pItemSelect->pItemExt->dwID)
							{
								bFound = true;
								iDestiOrder = i;
								s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;
								s_sRecoveryJobInfo.m_iPage = iPage;
								break;
							}
						}
					}

					// 못찾았으면.. 
					if (!bFound)
					{
						// 해당 위치에 아이콘이 있으면..
						if (m_pMyWare[m_iCurPage][iDestiOrder] != nullptr)
						{
							// 빈슬롯을 찾아 들어간다..
							for (int iPage = 0; iPage < MAX_ITEM_WARE_PAGE; iPage++)
							{
								if (bFound)
									break;

								for (int i = 0; i < MAX_ITEM_TRADE; i++)
								{
									if (bFound)
									{
										s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;
										s_sRecoveryJobInfo.m_iPage = iPage;
										break;
									}

									if (m_pMyWare[iPage][i] == nullptr)
									{
										bFound = true;
										iDestiOrder = i;
									}
								}

								if (!bFound)	// 빈 슬롯을 찾지 못했으면..
								{
									s_bWaitFromServer					= false;
									s_sRecoveryJobInfo.pItemSource		= nullptr;
									s_sRecoveryJobInfo.pItemTarget		= nullptr;
									FAIL_RETURN
								}
							}
						}
						else
						{
							s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
							s_sRecoveryJobInfo.m_iPage					= m_iCurPage;
						}
					}

					s_bWaitFromServer = false;

					s_pCountableItemEdit->Open(UIWND_WARE_HOUSE, s_sSelectedIconInfo.UIWndSelect.UIWndDistrict, false);
					FAIL_RETURN
				}
				else
				{
					// 일반 아이템인 경우..
					if (m_pMyWare[m_iCurPage][iDestiOrder] != nullptr)	// 해당 위치에 아이콘이 있으면..
					{
						// 인벤토리 빈슬롯을 찾아 들어간다..
						bFound = false;

						// 10개의 폐이지를 다 뒤진다..
						for (int iPage = 0; iPage < MAX_ITEM_WARE_PAGE; iPage++)
						{
							if (bFound)
								break;

							for (int i = 0; i < MAX_ITEM_TRADE; i++)
							{
								if (bFound)
								{
									s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;
									s_sRecoveryJobInfo.m_iPage = iPage;
									break;
								}

								if (m_pMyWare[iPage][i] == nullptr)
								{
									bFound = true;
									iDestiOrder = i;
								}
							}
						}

						// 빈 슬롯을 찾지 못했으면..
						if (!bFound)
						{
							s_bWaitFromServer						= false;
							s_sRecoveryJobInfo.pItemSource			= nullptr;
							s_sRecoveryJobInfo.pItemTarget			= nullptr;
							FAIL_RETURN
						}
					}
					else
					{
						s_sRecoveryJobInfo.UIWndSourceEnd.iOrder	= iDestiOrder;
						s_sRecoveryJobInfo.m_iPage					= m_iCurPage;
					}

					SendToServerToWareMsg(
						s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
						s_sRecoveryJobInfo.m_iPage,
						s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
						iDestiOrder,
						s_sRecoveryJobInfo.pItemSource->iCount);

					m_pMyWare[s_sRecoveryJobInfo.m_iPage][iDestiOrder] = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
					m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

					pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, iDestiOrder);
					if (pArea != nullptr)
					{
						m_pMyWare[s_sRecoveryJobInfo.m_iPage][iDestiOrder]->pUIIcon->SetRegion(pArea->GetRegion());
						m_pMyWare[s_sRecoveryJobInfo.m_iPage][iDestiOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
					}

					if (s_sRecoveryJobInfo.m_iPage != m_iCurPage)
						m_pMyWare[s_sRecoveryJobInfo.m_iPage][iDestiOrder]->pUIIcon->SetVisibleWithNoSound(false);

					FAIL_RETURN
				}
			}
			else
			{
				// 이동.. 
				__IconItemSkill* spItemSource, *spItemTarget = nullptr;
				spItemSource = s_sRecoveryJobInfo.pItemSource;

				pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, iDestiOrder);
				if (pArea != nullptr)
				{
					spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
					spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				s_sRecoveryJobInfo.UIWndSourceEnd.iOrder = iDestiOrder;

				// Inv 내에서 이동..	(모두 일반 아이템으로 취급한다..)
				// 해당 위치에 아이콘이 있으면..
				if (m_pMyWareInv[iDestiOrder] != nullptr)
				{
					s_sRecoveryJobInfo.pItemTarget = m_pMyWareInv[iDestiOrder];
					s_sRecoveryJobInfo.UIWndTargetStart.UIWnd = UIWND_WARE_HOUSE;
					s_sRecoveryJobInfo.UIWndTargetStart.UIWndDistrict = UIWND_DISTRICT_TRADE_MY;
					s_sRecoveryJobInfo.UIWndTargetStart.iOrder = iDestiOrder;
					s_sRecoveryJobInfo.UIWndTargetEnd.UIWnd = UIWND_WARE_HOUSE;
					s_sRecoveryJobInfo.UIWndTargetEnd.UIWndDistrict = UIWND_DISTRICT_TRADE_MY;
					s_sRecoveryJobInfo.UIWndTargetEnd.iOrder = s_sRecoveryJobInfo.UIWndSourceStart.iOrder;

					spItemTarget = s_sRecoveryJobInfo.pItemTarget;

					pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
					if (pArea != nullptr)
					{
						spItemTarget->pUIIcon->SetRegion(pArea->GetRegion());
						spItemTarget->pUIIcon->SetMoveRect(pArea->GetRegion());
					}
				}
				else
				{
					s_sRecoveryJobInfo.pItemTarget = nullptr;
				}

				m_pMyWareInv[iDestiOrder] = spItemSource;
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemTarget;

				// 이동 메시지를 보낸다..
				SendToServerInvToInvMsg(
					s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
					m_iCurPage,
					s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
					iDestiOrder);

				FAIL_RETURN
			}
			break;
	}


	AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);

	return false;
}

void CUIWareHouseDlg::CancelIconDrop(__IconItemSkill* spItem)
{
	AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIWareHouseDlg::AcceptIconDrop(__IconItemSkill* spItem)
{
	AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIWareHouseDlg::SendToServerToWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t pos, int iCount)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WAREHOUSE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_WARE_GET_IN);
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemID);
	CAPISocket::MP_AddByte(byBuff, iOffset, page);
	CAPISocket::MP_AddByte(byBuff, iOffset, startpos);
	CAPISocket::MP_AddByte(byBuff, iOffset, pos);
	CAPISocket::MP_AddDword(byBuff, iOffset, iCount);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIWareHouseDlg::SendToServerFromWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t pos, int iCount)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WAREHOUSE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_WARE_GET_OUT);
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemID);
	CAPISocket::MP_AddByte(byBuff, iOffset, page);
	CAPISocket::MP_AddByte(byBuff, iOffset, startpos);
	CAPISocket::MP_AddByte(byBuff, iOffset, pos);
	CAPISocket::MP_AddDword(byBuff, iOffset, iCount);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIWareHouseDlg::SendToServerWareToWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t destpos)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WAREHOUSE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_WARE_WARE_MOVE);
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemID);
	CAPISocket::MP_AddByte(byBuff, iOffset, page);
	CAPISocket::MP_AddByte(byBuff, iOffset, startpos);
	CAPISocket::MP_AddByte(byBuff, iOffset, destpos);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

void CUIWareHouseDlg::SendToServerInvToInvMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t destpos)
{
	uint8_t byBuff[32];
	int iOffset = 0;
	CAPISocket::MP_AddByte(byBuff, iOffset, WIZ_WAREHOUSE);
	CAPISocket::MP_AddByte(byBuff, iOffset, N3_SP_WARE_INV_MOVE);
	CAPISocket::MP_AddDword(byBuff, iOffset, iItemID);	
	CAPISocket::MP_AddByte(byBuff, iOffset, page);	
	CAPISocket::MP_AddByte(byBuff, iOffset, startpos);
	CAPISocket::MP_AddByte(byBuff, iOffset, destpos);

	CGameProcedure::s_pSocket->Send(byBuff, iOffset);
}

// 넣는 경우..
void CUIWareHouseDlg::ReceiveResultToWareMsg(uint8_t bResult)
{
	s_bWaitFromServer = false;

	int iGold = s_pCountableItemEdit->GetQuantity();
	__IconItemSkill* spItem = nullptr;
	CN3UIArea* pArea = nullptr;

	// 실패..
	if (bResult != 0x01)
	{
		if (m_bSendedItemGold)
		{
			ReceiveResultGoldToWareFail();
			return;
		}

		// 활이나 물약등 아이템인 경우..
		if (s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
			|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
		{
			// Ware Side..
			if ((m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount - iGold) > 0)
			{
				//  숫자 업데이트..
				m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount -= iGold;
			}
			else
			{
				// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
				spItem = m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

				// 인벤토리에서도 지운다..
				m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

				// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
				RemoveChild(spItem->pUIIcon);

				// 아이콘 리소스 삭제...
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;
			}

			// Inv Side..	//////////////////////////////////////////////////////

			if (!m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible())
			{
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetVisible(true);
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount = iGold;
			}
			else
			{
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount += iGold;
			}
		}
		// 일반 아이템인 경우..
		else
		{
			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]
				= m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
			if (pArea != nullptr)
			{
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
		}
	}
	// 성공.. 
	else
	{
		// 원래 대로..
		if (m_bSendedItemGold)
		{
			m_bSendedItemGold = false;
			return;
		}

		// 활이나 물약등 아이템인 경우..
		if ((s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
			|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
			&& !m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible())
		{
			spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			// 인벤토리에서도 지운다..
			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

			// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
			RemoveChild(spItem->pUIIcon);

			// 아이콘 리소스 삭제...
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
		}
	}
}

// 빼는 경우..
void CUIWareHouseDlg::ReceiveResultFromWareMsg(uint8_t bResult)
{
	s_bWaitFromServer = false;

	int iGold = s_pCountableItemEdit->GetQuantity();
	__IconItemSkill* spItem = nullptr;
	CN3UIArea* pArea = nullptr;

	if (bResult != 0x01)	// 실패..
	{
		if (m_bSendedItemGold)
		{
			ReceiveResultGoldFromWareFail();
			return;
		}

		if (s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
			|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
		{
			// Inv Side..	//////////////////////////////////////////////////////
			if ((m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount - iGold) > 0)
			{
				// 숫자 업데이트..
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount -= iGold;
			}
			else
			{
				// 아이템 삭제.. 현재 인벤토리 윈도우만.. 
				spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

				// 인벤토리에서도 지운다..
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;

				// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
				RemoveChild(spItem->pUIIcon);

				// 아이콘 리소스 삭제...
				spItem->pUIIcon->Release();
				delete spItem->pUIIcon;
				spItem->pUIIcon = nullptr;
				delete spItem;
				spItem = nullptr;
			}

			// Ware Side..

			if (!m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible())
			{
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetVisible(true);
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount = iGold;
			}
			else
			{
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->iCount += iGold;
			}
		}
		else
		{
			// 일반 아이템..
			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder] =
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];

			pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
			if (pArea != nullptr)
			{
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetRegion(pArea->GetRegion());
				m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
		}

		std::string szMsg = fmt::format_text_resource(IDS_ITEM_TOOMANY_OR_HEAVY);
		CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
	}
	else
	{
		// 성공.. 
		if (m_bSendedItemGold)
		{
			// 원래 대로..
			m_bSendedItemGold = false;
			return;
		}

		// 활이나 물약등 아이템인 경우..
		if ((s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE
			|| s_sRecoveryJobInfo.pItemSource->pItemBasic->byContable == UIITEM_TYPE_COUNTABLE_SMALL)
			&& !m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder]->pUIIcon->IsVisible())
		{
			spItem = m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			// 인벤토리에서도 지운다..
			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = nullptr;

			// iOrder로 내 매니저의 아이템을 리스트에서 삭제한다..
			RemoveChild(spItem->pUIIcon);

			// 아이콘 리소스 삭제...
			spItem->pUIIcon->Release();
			delete spItem->pUIIcon;
			spItem->pUIIcon = nullptr;
			delete spItem;
			spItem = nullptr;
		}
	}
}

void CUIWareHouseDlg::ReceiveResultWareToWareMsg(uint8_t bResult)
{
	s_bWaitFromServer = false;

	// 실패..
	if (bResult != 0x01)
	{
		__IconItemSkill* spItemSource = s_sRecoveryJobInfo.pItemSource;
		__IconItemSkill* spItemTarget = s_sRecoveryJobInfo.pItemTarget;

		if (spItemSource != nullptr)
		{
			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
			if (pArea != nullptr)
			{
				spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
				spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemSource;
		}

		if (spItemTarget != nullptr)
		{
			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
			if (pArea != nullptr)
			{
				spItemTarget->pUIIcon->SetRegion(pArea->GetRegion());
				spItemTarget->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemTarget;
		}
		else
		{
			m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
		}
	}

	AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIWareHouseDlg::ReceiveResultInvToInvMsg(uint8_t bResult)
{
	s_bWaitFromServer = false;

	// 실패..
	if (bResult != 0x01)
	{
		__IconItemSkill* spItemSource = s_sRecoveryJobInfo.pItemSource;
		__IconItemSkill* spItemTarget = s_sRecoveryJobInfo.pItemTarget;

		if (spItemSource != nullptr)
		{
			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sRecoveryJobInfo.UIWndSourceStart.iOrder);
			if (pArea != nullptr)
			{
				spItemSource->pUIIcon->SetRegion(pArea->GetRegion());
				spItemSource->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder] = spItemSource;
		}

		if (spItemTarget != nullptr)
		{
			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
			if (pArea != nullptr)
			{
				spItemTarget->pUIIcon->SetRegion(pArea->GetRegion());
				spItemTarget->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemTarget;
		}
		else
		{
			m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = nullptr;
		}
	}

	AllHighLightIconFree();
	SetState(UI_STATE_COMMON_NONE);
}

void CUIWareHouseDlg::ItemCountOK()
{
	int iGold = s_pCountableItemEdit->GetQuantity();
	__IconItemSkill* spItem = nullptr;
	CN3UIArea* pArea = nullptr;
	float fUVAspect = 45.0f / 64.0f;
	int iWeight;
	__InfoPlayerMySelf* pInfoExt = &CGameBase::s_pPlayer->m_InfoExt;

	switch (s_pCountableItemEdit->GetCallerWndDistrict())
	{
		// 빼는 경우..
		case UIWND_DISTRICT_TRADE_NPC:
			spItem = m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
			if (iGold > spItem->iCount)
				return;

			switch (spItem->pItemBasic->byContable)
			{
				case UIITEM_TYPE_ONLYONE:
				case UIITEM_TYPE_SOMOONE:
					iWeight = spItem->pItemBasic->siWeight;

					// 무게 체크..
					if ((pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}
					break;

				case UIITEM_TYPE_COUNTABLE:
					if (iGold <= 0)
						return;

					// int16_t 범위이상은 살수 없다..
					if (iGold > UIITEM_COUNT_MANY)
					{
						std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}

					if (m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] != nullptr)
					{
						spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];
						if (spItem->iCount + iGold > UIITEM_COUNT_MANY)
						{
							std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_GET_MANY);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return;
						}
					}

					// 무게 체크..
					iWeight = iGold * spItem->pItemBasic->siWeight;
					if ((pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}
					break;

				case UIITEM_TYPE_COUNTABLE_SMALL:
					if (iGold <= 0)
						return;

					// int16_t 범위이상은 살수 없다..
					if (iGold > UIITEM_COUNT_FEW)
					{
						std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}

					if (m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] != nullptr)
					{
						spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];
						if (spItem->iCount + iGold > UIITEM_COUNT_FEW)
						{
							std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_GET_MANY);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return;
						}
					}

					// 무게 체크..
					iWeight = iGold * spItem->pItemBasic->siWeight;
					if ((pInfoExt->iWeight + iWeight) > pInfoExt->iWeightMax)
					{
						std::string szMsg = fmt::format_text_resource(IDS_ITEM_WEIGHT_OVERFLOW);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}
					break;
			}

			spItem = m_pMyWare[m_iCurPage][s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			s_bWaitFromServer = true;

			// 해당 위치에 아이콘이 있으면..
			if (m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] != nullptr)
			{
				// 숫자 업데이트..
				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount += iGold;
			}
			else	// 없으면 아이콘을 만든다...
			{
				__IconItemSkill* spItemNew	= new __IconItemSkill();
				spItemNew->pItemBasic		= spItem->pItemBasic;
				spItemNew->pItemExt			= spItem->pItemExt;
				spItemNew->szIconFN			= spItem->szIconFN;
				spItemNew->iCount			= iGold;
				spItemNew->iDurability		= spItem->iDurability;
				spItemNew->pUIIcon			= new CN3UIIcon();
				spItemNew->pUIIcon->Init(this);
				spItemNew->pUIIcon->SetTex(spItem->szIconFN);
				spItemNew->pUIIcon->SetUVRect(0, 0, fUVAspect, fUVAspect);
				spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
				spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM | UISTYLE_ICON_CERTIFICATION_NEED);
				spItemNew->pUIIcon->SetVisible(true);

				pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
				if (pArea != nullptr)
				{
					spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
					spItemNew->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemNew;
			}

			// 숫자 업데이트..
			if ((spItem->iCount - iGold) > 0)
				spItem->iCount -= iGold;
			else
				spItem->pUIIcon->SetVisible(false);

			// 표시는 아이콘 렌더링할때.. Inventory의 Render에서..
			// 서버에게 보냄..
			SendToServerFromWareMsg(
				s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
				m_iCurPage,
				s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
				s_sRecoveryJobInfo.UIWndSourceEnd.iOrder,
				iGold);

			// Sound..
			if (s_sRecoveryJobInfo.pItemSource != nullptr)
				PlayItemSound(s_sRecoveryJobInfo.pItemSource->pItemBasic);
			break;

		// 넣는 경우..
		case UIWND_DISTRICT_TRADE_MY:
			spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];
			if (iGold > spItem->iCount)
				return;

			switch (spItem->pItemBasic->byContable)
			{
				case UIITEM_TYPE_COUNTABLE:
					if (iGold <= 0)
						return;

					// int16_t 범위이상은 살수 없다..
					if (iGold > UIITEM_COUNT_MANY)
					{
						std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}

					if (m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] != nullptr)
					{
						spItem = m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];
						if (spItem->iCount + iGold > UIITEM_COUNT_MANY)
						{
							std::string szMsg = fmt::format_text_resource(IDS_MANY_COUNTABLE_ITEM_GET_MANY);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return;
						}
					}
					break;

				case UIITEM_TYPE_COUNTABLE_SMALL:
					if (iGold <= 0)
						return;

					// int16_t 범위이상은 살수 없다..
					if (iGold > UIITEM_COUNT_FEW)
					{
						std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_GET_MANY);
						CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
						return;
					}

					if (m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] != nullptr)
					{
						spItem = m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder];
						if (spItem->iCount + iGold > UIITEM_COUNT_FEW)
						{
							std::string szMsg = fmt::format_text_resource(IDS_SMALL_COUNTABLE_ITEM_GET_MANY);
							CGameProcedure::s_pProcMain->MsgOutput(szMsg, 0xffff3b3b);
							return;
						}
					}
					break;
			}

			spItem = m_pMyWareInv[s_sRecoveryJobInfo.UIWndSourceStart.iOrder];

			s_bWaitFromServer = true;

			// 해당 위치에 아이콘이 있으면..
			if (m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder])
			{
				// 숫자 업데이트..
				m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder]->iCount += iGold;
			}
			// 없으면 아이콘을 만든다..
			else
			{
				__IconItemSkill* spItemNew	= new __IconItemSkill();
				spItemNew->pItemBasic		= spItem->pItemBasic;
				spItemNew->pItemExt			= spItem->pItemExt;
				spItemNew->szIconFN			= spItem->szIconFN;
				spItemNew->iCount			= iGold;
				spItemNew->iDurability		= spItem->iDurability;
				spItemNew->pUIIcon			= new CN3UIIcon();
				spItemNew->pUIIcon->Init(this);
				spItemNew->pUIIcon->SetTex(spItem->szIconFN);
				spItemNew->pUIIcon->SetUVRect(0, 0, fUVAspect, fUVAspect);
				spItemNew->pUIIcon->SetUIType(UI_TYPE_ICON);
				spItemNew->pUIIcon->SetStyle(UISTYLE_ICON_ITEM | UISTYLE_ICON_CERTIFICATION_NEED);
				spItemNew->pUIIcon->SetVisible(true);

				pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_NPC, s_sRecoveryJobInfo.UIWndSourceEnd.iOrder);
				if (pArea != nullptr)
				{
					spItemNew->pUIIcon->SetRegion(pArea->GetRegion());
					spItemNew->pUIIcon->SetMoveRect(pArea->GetRegion());
				}

				if (s_sRecoveryJobInfo.m_iPage != m_iCurPage)
					spItemNew->pUIIcon->SetVisibleWithNoSound(false);

				m_pMyWare[s_sRecoveryJobInfo.m_iPage][s_sRecoveryJobInfo.UIWndSourceEnd.iOrder] = spItemNew;
			}

			//  숫자 업데이트..
			if ((spItem->iCount - iGold) > 0)
				spItem->iCount -= iGold;
			else
				spItem->pUIIcon->SetVisible(false);

			// 표시는 아이콘 렌더링할때.. Inventory의 Render에서..
			// 서버에게 보냄..
			SendToServerToWareMsg(
				s_sRecoveryJobInfo.pItemSource->pItemBasic->dwID + s_sRecoveryJobInfo.pItemSource->pItemExt->dwID,
				s_sRecoveryJobInfo.m_iPage,
				s_sRecoveryJobInfo.UIWndSourceStart.iOrder,
				s_sRecoveryJobInfo.UIWndSourceEnd.iOrder,
				iGold);

			break;
	}

	s_pCountableItemEdit->Close();
}

void CUIWareHouseDlg::ItemCountCancel()
{
	// Sound..
	if (s_sRecoveryJobInfo.pItemSource != nullptr)
		PlayItemSound(s_sRecoveryJobInfo.pItemSource->pItemBasic);

	// 취소..
	s_bWaitFromServer				= false;
	s_sRecoveryJobInfo.pItemSource	= nullptr;
	s_sRecoveryJobInfo.pItemTarget	= nullptr;

	s_pCountableItemEdit->Close();
}

void CUIWareHouseDlg::ItemMoveFromInvToThis()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if (pInven == nullptr)
		return;

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		m_pMyWareInv[i] = nullptr;

		if (pInven->m_pMyInvWnd[i] != nullptr)
		{
			__IconItemSkill* spItem = pInven->m_pMyInvWnd[i];
			spItem->pUIIcon->SetParent(this);

			pInven->m_pMyInvWnd[i] = nullptr;

			CN3UIArea* pArea = GetChildAreaByiOrder(UI_AREA_TYPE_TRADE_MY, i);
			if (pArea != nullptr)
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			m_pMyWareInv[i] = spItem;
		}
	}
}

void CUIWareHouseDlg::ItemMoveFromThisToInv()
{
	CUIInventory* pInven = CGameProcedure::s_pProcMain->m_pUIInventory;
	if (pInven == nullptr)
		return;

	for (int i = 0; i < MAX_ITEM_INVENTORY; i++)
	{
		if (m_pMyWareInv[i] != nullptr)
		{
			__IconItemSkill* spItem = m_pMyWareInv[i];
			spItem->pUIIcon->SetParent(pInven);

			m_pMyWareInv[i] = nullptr;

			CN3UIArea* pArea = pInven->GetChildAreaByiOrder(UI_AREA_TYPE_INV, i);
			if (pArea != nullptr)
			{
				spItem->pUIIcon->SetRegion(pArea->GetRegion());
				spItem->pUIIcon->SetMoveRect(pArea->GetRegion());
			}

			pInven->m_pMyInvWnd[i] = spItem;
		}
	}
}

void CUIWareHouseDlg::AddItemInWare(int iItem, int iDurability, int iCount, int iIndex)
{
	if (iItem <= 0)
		return;

	std::string szIconFN;
	__IconItemSkill* spItem = nullptr;
	// 아이템 테이블 구조체 포인터..
	__TABLE_ITEM_BASIC* pItem = nullptr;
	__TABLE_ITEM_EXT* pItemExt = nullptr;
	// 열 데이터 얻기..
	pItem = CGameBase::s_pTbl_Items_Basic.Find(iItem / 1000 * 1000);
	if (pItem && pItem->byExtIndex >= 0 && pItem->byExtIndex < MAX_ITEM_EXTENSION)
		pItemExt = CGameBase::s_pTbl_Items_Exts[pItem->byExtIndex].Find(iItem % 1000);	// 열 데이터 얻기..
	if (pItem == nullptr || pItemExt == nullptr)
	{
		__ASSERT(0, "NULL Item!!!");
		CLogWriter::Write("WareHouse - Ware - Unknown Item {}, IDNumber", iItem);
		// 아이템이 없으면..
		return;
	}

	e_PartPosition ePart;
	e_PlugPosition ePlug;
	// 아이템에 따른 파일 이름을 만들어서
	e_ItemType eType = CGameBase::MakeResrcFileNameForUPC(pItem, pItemExt, nullptr, &szIconFN, ePart, ePlug);
	if (ITEM_TYPE_UNKNOWN == eType)
		CLogWriter::Write("MyInfo - slot - Unknown Item");
	__ASSERT(ITEM_TYPE_UNKNOWN != eType, "Unknown Item");

	spItem = new __IconItemSkill();
	spItem->pItemBasic	= pItem;
	spItem->pItemExt	= pItemExt;
	spItem->szIconFN	= szIconFN; // 아이콘 파일 이름 복사..
	spItem->iCount		= iCount;
	spItem->iCount		= iCount;
	spItem->iDurability = iDurability;

	m_pMyWare[iIndex / MAX_ITEM_TRADE][iIndex % MAX_ITEM_TRADE] = spItem;
	//TRACE("Init Inv Msg Inve %d, iOrder %d \n", iItem, iIndex);
}

// 돈을 넣는 경우..
void CUIWareHouseDlg::GoldCountToWareOK()
{
	// 인벤토리의 값..
	int iGold, iMyMoney, iWareMoney;
	std::string str;

	// 돈을 보관함에 보관하는 경우..
	iGold = s_pCountableItemEdit->GetQuantity();

	// Gold Offset Backup..
	m_iGoldOffsetBackup = iGold;

	// 현재 내가 가진 돈을 얻어 온다..
	iMyMoney = CGameBase::s_pPlayer->m_InfoExt.iGold;

	// 보관함의 돈을 얻어온다..
	CN3UIString* pStr = GetChildByID<CN3UIString>("string_wareitem_name");
	__ASSERT(pStr, "NULL UI Component!!");
	str = CGameBase::UnformatNumber(pStr->GetString());
	iWareMoney = atoi(str.c_str());

	if (iGold <= 0)
		return;

	if (iGold > iMyMoney)
		return;

	// 보낸 아이템이 돈이다.. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	m_bSendedItemGold = true;

	// 돈을 감소 시킨다..
	iMyMoney -= iGold;
	CGameBase::s_pPlayer->m_InfoExt.iGold = iMyMoney;

	iWareMoney += iGold;

	// 돈 표시.. Ware..
	pStr->SetString(CGameBase::FormatNumber(iWareMoney));

	// 돈 표시.. 인벤토리..
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

	// 돈 표시.. Inv..
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_item_name"));
	if (pStr != nullptr)
		pStr->SetString(CGameBase::FormatNumber(iMyMoney));

	// 서버에게 패킷 만들어서 날림..
	SendToServerToWareMsg(dwGold, 0xff, 0xff, 0xff, iGold);

	// 상태를 변화시키고.. 창을 닫고..
	s_bWaitFromServer = true;
	s_pCountableItemEdit->Close();

	PlayGoldSound();
}

// 돈을 빼는 경우..
void CUIWareHouseDlg::GoldCountFromWareOK()
{
	int iGold, iMyMoney, iWareMoney;			// 인벤토리의 값..
	std::string str;

	// 돈을 보관함에서 빼는 경우..
	iGold = s_pCountableItemEdit->GetQuantity();

	// Gold Offset Backup..
	m_iGoldOffsetBackup = iGold;

	// 현재 내가 가진 돈을 얻어 온다..
	iMyMoney = CGameBase::s_pPlayer->m_InfoExt.iGold;

	// 보관함의 돈을 얻어온다..
	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_wareitem_name"));
	str = CGameBase::UnformatNumber(pStr->GetString());
	iWareMoney = atoi(str.c_str());

	if (iGold <= 0)
		return;

	if (iGold > iWareMoney)
		return;

	// 보낸 아이템이 돈이다.. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	m_bSendedItemGold = true;

	// 돈을 감소 시킨다..
	iMyMoney += iGold;
	CGameBase::s_pPlayer->m_InfoExt.iGold = iMyMoney;

	iWareMoney -= iGold;

	// 돈 표시.. Ware..
	pStr->SetString(CGameBase::FormatNumber(iWareMoney));

	// 돈 표시.. 인벤토리..
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

	// 돈 표시.. Inv..
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_item_name"));
	if (pStr != nullptr)
		pStr->SetString(CGameBase::FormatNumber(iMyMoney));

	// 서버에게 패킷 만들어서 날림..
	SendToServerFromWareMsg(dwGold, 0xff, 0xff, 0xff, iGold);

	// 상태를 변화시키고.. 창을 닫고..
	s_bWaitFromServer = true;
	s_pCountableItemEdit->Close();

	PlayGoldSound();
}

void CUIWareHouseDlg::GoldCountToWareCancel()
{
	// 돈을 보관함에 보관하는 경우 취소..
	// Sound..
	PlayGoldSound();

	// 취소..
	s_bWaitFromServer = false;
	s_sRecoveryJobInfo.pItemSource = nullptr;
	s_sRecoveryJobInfo.pItemTarget = nullptr;

	s_pCountableItemEdit->Close();
}

void CUIWareHouseDlg::GoldCountFromWareCancel()
{
	// 돈을 보관함에서 빼오는 경우 취소..
	// Sound..
	PlayGoldSound();

	// 취소..
	s_bWaitFromServer				= false;
	s_sRecoveryJobInfo.pItemSource	= nullptr;
	s_sRecoveryJobInfo.pItemTarget	= nullptr;

	s_pCountableItemEdit->Close();
}

void CUIWareHouseDlg::ReceiveResultGoldToWareFail()
{
	// 원래 대로..
	m_bSendedItemGold = false;

	// 인벤토리의 값..
	int iGold, iMyMoney, iWareMoney;
	std::string str;

	// 돈을 보관함에서 빼는 경우..
	iGold = s_pCountableItemEdit->GetQuantity();

	// Gold Offset Backup..
	m_iGoldOffsetBackup = iGold;

	// 현재 내가 가진 돈을 얻어 온다..
	iMyMoney = CGameBase::s_pPlayer->m_InfoExt.iGold;

	// 보관함의 돈을 얻어온다..
	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_wareitem_name"));
	str = CGameBase::UnformatNumber(pStr->GetString());
	iWareMoney = atoi(str.c_str());

	// 돈을 감소 시킨다..
	iMyMoney += iGold;
	CGameBase::s_pPlayer->m_InfoExt.iGold = iMyMoney;

	iWareMoney -= iGold;

	// 돈 표시.. Ware..
	pStr->SetStringAsInt(iWareMoney);

	// 돈 표시.. 인벤토리..
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

	// 돈 표시.. Inv..
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_item_name"));
	if (pStr != nullptr)
		pStr->SetStringAsInt(iMyMoney);
}

void CUIWareHouseDlg::ReceiveResultGoldFromWareFail()
{
	// 원래 대로..
	m_bSendedItemGold = false;

	// 인벤토리의 값..
	int iGold, iMyMoney, iWareMoney;
	std::string str;

	// 돈을 보관함에 보관하는 경우..
	iGold = s_pCountableItemEdit->GetQuantity();

	// Gold Offset Backup..
	m_iGoldOffsetBackup = iGold;

	// 현재 내가 가진 돈을 얻어 온다..
	iMyMoney = CGameBase::s_pPlayer->m_InfoExt.iGold;

	// 보관함의 돈을 얻어온다..
	CN3UIString* pStr = nullptr;
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_wareitem_name"));
	str = CGameBase::UnformatNumber(pStr->GetString());
	iWareMoney = atoi(str.c_str());

	// 돈을 감소 시킨다..
	iMyMoney -= iGold;
	CGameBase::s_pPlayer->m_InfoExt.iGold = iMyMoney;

	iWareMoney += iGold;

	// 돈 표시.. Ware..
	pStr->SetStringAsInt(iWareMoney);

	// 돈 표시.. 인벤토리..
	CGameProcedure::s_pProcMain->m_pUIInventory->GoldUpdate();

	// 돈 표시.. Inv..
	N3_VERIFY_UI_COMPONENT(pStr, GetChildByID<CN3UIString>("string_item_name"));
	if (pStr != nullptr)
		pStr->SetStringAsInt(iMyMoney);
}

bool CUIWareHouseDlg::OnKeyPress(int iKey)
{
	switch (iKey)
	{
		case DIK_PRIOR:
			ReceiveMessage(m_pBtnPageUp, UIMSG_BUTTON_CLICK);
			return true;

		case DIK_NEXT:
			ReceiveMessage(m_pBtnPageDown, UIMSG_BUTTON_CLICK);
			return true;

		case DIK_ESCAPE:
			ReceiveMessage(m_pBtnClose, UIMSG_BUTTON_CLICK);
			return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

bool CUIWareHouseDlg::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtnGold,			GetChildByID<CN3UIButton>("btn_gold"));
	N3_VERIFY_UI_COMPONENT(m_pBtnGoldWareHouse,	GetChildByID<CN3UIButton>("btn_gold_warehouse"));
	N3_VERIFY_UI_COMPONENT(m_pBtnClose,			GetChildByID<CN3UIButton>("btn_close"));
	N3_VERIFY_UI_COMPONENT(m_pBtnPageUp,		GetChildByID<CN3UIButton>("btn_page_up"));
	N3_VERIFY_UI_COMPONENT(m_pBtnPageDown,		GetChildByID<CN3UIButton>("btn_page_down"));

	return true;
}

void CUIWareHouseDlg::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if (bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();
}

void CUIWareHouseDlg::SetVisibleWithNoSound(bool bVisible, bool bWork, bool bReFocus)
{
	CN3UIBase::SetVisibleWithNoSound(bVisible, bWork, bReFocus);

	if (bWork)
	{
		if (s_pCountableItemEdit != nullptr && s_pCountableItemEdit->IsVisible())
			s_pCountableItemEdit->SetVisibleWithNoSound(bVisible, bWork, bReFocus);

		if (GetState() == UI_STATE_ICON_MOVING)
			IconRestore();

		SetState(UI_STATE_COMMON_NONE);
		AllHighLightIconFree();

		// 이 윈도우의 inv 영역의 아이템을 이 인벤토리 윈도우의 inv영역으로 옮긴다..	
		ItemMoveFromThisToInv();

		if (CGameProcedure::s_pProcMain->m_pUISkillTreeDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUISkillTreeDlg->UpdateDisableCheck();

		if (CGameProcedure::s_pProcMain->m_pUIHotKeyDlg != nullptr)
			CGameProcedure::s_pProcMain->m_pUIHotKeyDlg->UpdateDisableCheck();
	}
}

// ===== END WarFare/UIWareHouseDlg.cpp =====

// ===== BEGIN WarFare/UIWareHouseDlg.h =====
#line 1 "WarFare/UIWareHouseDlg.h"
﻿// UIWareHouseDlg.h: interface for the UIWareHouseDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIWAREHOUSEDLG_H__47E9608F_598A_49CF_B10E_3D95FA647768__INCLUDED_)
#define AFX_UIWAREHOUSEDLG_H__47E9608F_598A_49CF_B10E_3D95FA647768__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GameDef.h"
#include "N3UIWndBase.h"

class CUIWareHouseDlg : public CN3UIWndBase
{
	friend class CUIInventory;

public:
// 직접 접근해야 할 객체 참조 포인터
	__IconItemSkill*		m_pMyWare[MAX_ITEM_WARE_PAGE][MAX_ITEM_TRADE];
	__IconItemSkill*		m_pMyWareInv[MAX_ITEM_INVENTORY];
	CN3UIString*			m_pStrMyGold;
	CN3UIString*			m_pStrWareGold;

	//this_ui_add_start
	CN3UIButton*			m_pBtnGold;
	CN3UIButton*			m_pBtnGoldWareHouse;
	CN3UIButton*			m_pBtnClose;
	CN3UIButton*			m_pBtnPageUp;
	CN3UIButton*			m_pBtnPageDown;
	//this_ui_add_end

	bool					m_bSendedItemGold;
	int						m_iGoldOffsetBackup;

	int						m_iCurPage;
	CUIImageTooltipDlg*		m_pUITooltipDlg;

protected:
	int					GetItemiOrder(__IconItemSkill* spItem, e_UIWND_DISTRICT eWndDist);
	RECT				GetSampleRect();

	e_UIWND_DISTRICT	GetWndDistrict(__IconItemSkill* spItem);

public:
	CUIWareHouseDlg();
	~CUIWareHouseDlg() override;
	void				Release() override;

	//this_ui_add_start
	void				SetVisibleWithNoSound(bool bVisible, bool bWork = false, bool bReFocus = false) override;
	void				SetVisible(bool bVisible) override;
	bool				Load(File& file) override;
	bool				OnKeyPress(int iKey) override;
	//this_ui_add_end

	uint32_t			MouseProc(uint32_t dwFlags, const POINT& ptCur, const POINT& ptOld) override;
	bool				ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
	bool				OnMouseWheelEvent(short delta) override;
	void				Render() override;
	void				LeaveWareHouseState();
	void				EnterWareHouseStateStart(int iWareGold);
	void				AddItemInWare(int iItem, int iDurability, int iCount, int iIndex);
	void				EnterWareHouseStateEnd();

	void				InitIconWnd(e_UIWND eWnd) override;
	void				InitIconUpdate() override;

	__IconItemSkill*	GetHighlightIconItem(CN3UIIcon* pUIIcon) override;

	void				IconRestore() override;
	
	bool				ReceiveIconDrop(__IconItemSkill* spItem, POINT ptCur) override;

	void				CancelIconDrop(__IconItemSkill* spItem) override;
	void				AcceptIconDrop(__IconItemSkill* spItem) override;

	void				SendToServerToWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t pos, int iCount);
	void				SendToServerFromWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t pos, int iCount);
	void				SendToServerWareToWareMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t destpos);
	void				SendToServerInvToInvMsg(int iItemID, uint8_t page, uint8_t startpos, uint8_t destpos);
	void				ReceiveResultToWareMsg(uint8_t bResult);
	void				ReceiveResultFromWareMsg(uint8_t bResult);
	void				ReceiveResultWareToWareMsg(uint8_t bResult);
	void				ReceiveResultInvToInvMsg(uint8_t bResult);
	void				ReceiveResultGoldToWareFail();
	void				ReceiveResultGoldFromWareFail();

	// Item Count OK..
	void				ItemCountOK();
	void				ItemCountCancel();

	void				GoldCountToWareOK();
	void				GoldCountFromWareOK();
	void				GoldCountToWareCancel();
	void				GoldCountFromWareCancel();

	void				ItemMoveFromInvToThis();
	void				ItemMoveFromThisToInv();
};

#endif // !defined(AFX_UIWAREHOUSEDLG_H__47E9608F_598A_49CF_B10E_3D95FA647768__INCLUDED_)

// ===== END WarFare/UIWareHouseDlg.h =====

// ===== BEGIN WarFare/UIWarp.cpp =====
#line 1 "WarFare/UIWarp.cpp"
﻿// UIWarp.cpp: implementation of the UIWarp class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "UIWarp.h"
#include "UIManager.h"
#include "GameProcMain.h"
#include "text_resources.h"

#include <N3Base/N3UIButton.h>
#include <N3Base/N3UIString.h>
#include <N3Base/N3UIList.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUIWarp::CUIWarp()
{
	m_pBtn_Ok = nullptr;
	m_pBtn_Cancel = nullptr;
	m_pList_Infos = nullptr;
	m_pText_Agreement = nullptr; // 동의 사항..
}

CUIWarp::~CUIWarp()
{

}

bool CUIWarp::Load(File& file)
{
	if (!CN3UIBase::Load(file))
		return false;

	N3_VERIFY_UI_COMPONENT(m_pBtn_Ok,			GetChildByID<CN3UIButton>("Btn_Ok"));
	N3_VERIFY_UI_COMPONENT(m_pBtn_Cancel,		GetChildByID<CN3UIButton>("Btn_Cancel"));
	N3_VERIFY_UI_COMPONENT(m_pList_Infos,		GetChildByID<CN3UIList>("List_Infos"));
	N3_VERIFY_UI_COMPONENT(m_pText_Agreement,	GetChildByID<CN3UIString>("Text_Agreement"));

	return true;
}

bool CUIWarp::ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg)
{
	if (dwMsg & UIMSG_BUTTON_CLICK)
	{
		if(pSender == m_pBtn_Ok)
		{
			CGameProcedure::s_pProcMain->MsgSend_Warp();
		}
		else if(pSender == m_pBtn_Cancel)
		{
		}
		this->SetVisible(false);
	}
	else if(dwMsg & UIMSG_LIST_SELCHANGE)
	{
		if(pSender == m_pList_Infos)
		{
			this->UpdateAgreement(); // 동의문 업데이트..
		}
	}
	else if (dwMsg & UIMSG_LIST_DBLCLK)
	{
		CGameProcedure::s_pProcMain->MsgSend_Warp();
		this->SetVisible(false);
	}

	return true;
}

void CUIWarp::InfoAdd(const __WarpInfo& WI)
{
	m_ListInfos.push_back(WI);
}

bool CUIWarp::InfoGetCur(__WarpInfo& WI)
{
	if (m_pList_Infos == nullptr)
		return false;
	
	int iSel = m_pList_Infos->GetCurSel();
	if (iSel < 0
		|| iSel >= static_cast<int>(m_ListInfos.size()))
		return false;
	
	auto it = m_ListInfos.begin();
	std::advance(it, iSel);
	WI = *it;

	return true;
}

void CUIWarp::UpdateList()
{
	if (m_pList_Infos == nullptr)
		return;

	m_pList_Infos->ResetContent();
	it_WI it = m_ListInfos.begin(), itEnd = m_ListInfos.end();
	for(; it != itEnd; it++)
	{
		m_pList_Infos->AddString(it->szName);
	}

	m_pList_Infos->SetCurSel(0);
	this->UpdateAgreement();
}

void CUIWarp::UpdateAgreement()
{
	if (m_pList_Infos == nullptr || m_pText_Agreement == nullptr)
		return;

	int iSel = m_pList_Infos->GetCurSel();
	if (iSel < 0
		|| iSel >= static_cast<int>(m_ListInfos.size()))
		return;

	auto it = m_ListInfos.begin();
	std::advance(it, iSel);
	m_pText_Agreement->SetString(it->szAgreement);
}

void CUIWarp::Reset()
{
	m_ListInfos.clear();
	this->UpdateList();
}

void CUIWarp::SetVisible(bool bVisible)
{
	CN3UIBase::SetVisible(bVisible);
	if(bVisible)
		CGameProcedure::s_pUIMgr->SetVisibleFocusedUI(this);
	else
		CGameProcedure::s_pUIMgr->ReFocusUI();//this_ui
}

bool CUIWarp::OnKeyPress(int iKey)
{
	switch(iKey)
	{
	case DIK_ESCAPE:
		ReceiveMessage(m_pBtn_Cancel, UIMSG_BUTTON_CLICK);
		return true;
	case DIK_RETURN:
		ReceiveMessage(m_pBtn_Ok, UIMSG_BUTTON_CLICK);
		return true;
	}

	return CN3UIBase::OnKeyPress(iKey);
}

// ===== END WarFare/UIWarp.cpp =====

// ===== BEGIN WarFare/UIWarp.h =====
#line 1 "WarFare/UIWarp.h"
﻿// UIWarp.h: interface for the UIWarp class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UIWarp_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_)
#define AFX_UIWarp_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <string>
#include <list>
#include <N3Base/N3UIBase.h>

struct __WarpInfo
{
	int iID; // 이 번호를 서버에게 날린다.. 
	std::string szName;
	std::string szAgreement; // 유저한테 알리고 동의를 구하는 글..
	int iZone;
	int iMaxUser; // 최대 제한 인원수..
	int iGold;
	__Vector3 vPos;
};

typedef std::list<__WarpInfo>::iterator it_WI;

class CUIWarp : public CN3UIBase
{
protected:
	class CN3UIButton*		m_pBtn_Ok;
	class CN3UIButton*		m_pBtn_Cancel;
	
	class CN3UIList*		m_pList_Infos;
	class CN3UIString*		m_pText_Agreement; // 동의 사항..

	std::list<__WarpInfo> m_ListInfos;

public:
	bool OnKeyPress(int iKey) override;
	void SetVisible(bool bVisible) override;
	void Reset();
	CUIWarp();
	~CUIWarp() override;

	void	InfoAdd(const __WarpInfo& ZW);
	bool	InfoGetCur(__WarpInfo& ZW);
	void	UpdateList();
	void	UpdateAgreement();

	bool Load(File& file) override;
	bool ReceiveMessage(CN3UIBase* pSender, uint32_t dwMsg) override;
};

#endif // !defined(AFX_UIWarp_H__27F6610C_5D61_4A22_97F2_93211B77BF9C__INCLUDED_)

// ===== END WarFare/UIWarp.h =====

// ===== BEGIN WarFare/WarFareMain.cpp =====
#line 1 "WarFare/WarFareMain.cpp"
﻿#include "stdafx.h"
#include "UIChat.h"
#include "GameEng.h"
#include "resource.h"
#include "text_resources.h"
#include "PacketDef.h"
#include "APISocket.h"
#include "PlayerMySelf.h"
#include "GameProcMain.h"
#include "N3WorldManager.h"

#include <shared/Ini.h>

#include <WinSock2.h>
#include <time.h>

#include "UIManager.h"
#include "UIMessageBoxManager.h"

#include <N3Base/DFont.h>
#include <N3Base/N3SndMgr.h>
#include <N3Base/N3UIEdit.h>

#include <windowsx.h>

HWND CreateMainWindow(HINSTANCE hInstance);
LRESULT CALLBACK WndProcMain(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

int APIENTRY WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR     lpCmdLine,
	int       nCmdShow)
{
	// NOTE: get the current directory and make it known to CN3Base
	char szPath[_MAX_PATH] = "";
	GetCurrentDirectory(_MAX_PATH, szPath);
	CN3Base::PathSet(szPath);

	// NOTE: we are anticipating an Options file to exist within this directory
	char szIniPath[_MAX_PATH] = "";
	lstrcpy(szIniPath, CN3Base::PathGet().c_str());
	lstrcat(szIniPath, "Option.ini");

	CIni ini(szIniPath);

	// NOTE: what is the texture quality?
	CN3Base::s_Options.iTexLOD_Chr = ini.GetInt("Texture", "LOD_Chr", 0);
	if(CN3Base::s_Options.iTexLOD_Chr < 0) CN3Base::s_Options.iTexLOD_Chr = 0;
	if(CN3Base::s_Options.iTexLOD_Chr >= 2) CN3Base::s_Options.iTexLOD_Chr = 1;
	
	// NOTE: what is the texture quality?
	CN3Base::s_Options.iTexLOD_Shape = ini.GetInt("Texture", "LOD_Shape", 0);
	if(CN3Base::s_Options.iTexLOD_Shape < 0) CN3Base::s_Options.iTexLOD_Shape = 0;
	if(CN3Base::s_Options.iTexLOD_Shape >= 2) CN3Base::s_Options.iTexLOD_Shape = 1;

	// NOTE: what is the texture quality?
	CN3Base::s_Options.iTexLOD_Terrain = ini.GetInt("Texture", "LOD_Terrain", 0);
	if(CN3Base::s_Options.iTexLOD_Terrain < 0) CN3Base::s_Options.iTexLOD_Terrain = 0;
	if(CN3Base::s_Options.iTexLOD_Terrain >= 2) CN3Base::s_Options.iTexLOD_Terrain = 1;

	// NOTE: should we use shadows?
	CN3Base::s_Options.iUseShadow = ini.GetInt("Shadow", "Use", 1);

	// NOTE: what is the screen resolution?
	CN3Base::s_Options.iViewWidth = ini.GetInt("ViewPort", "Width", 1024);
	CN3Base::s_Options.iViewHeight = ini.GetInt("ViewPort", "Height", 768);
	
	if(CN3Base::s_Options.iViewWidth == 1024) CN3Base::s_Options.iViewHeight = 768;
	else if(1280 == CN3Base::s_Options.iViewWidth) CN3Base::s_Options.iViewHeight = 1024;
	else if(1600 == CN3Base::s_Options.iViewWidth) CN3Base::s_Options.iViewHeight = 1200;
	else if (1366 == CN3Base::s_Options.iViewWidth) CN3Base::s_Options.iViewHeight = 768;
	else if(1920 == CN3Base::s_Options.iViewWidth) CN3Base::s_Options.iViewHeight = 1080;
	/*
	else {
		CN3Base::s_Options.iViewWidth = 1024;
		CN3Base::s_Options.iViewHeight = 768;
	*/

	// NOTE: what is the viewport's color depth?
	// Officially this defaults to 16-bit, but this isn't as supported these days so we should
	// just default to 32-bit to ensure compatibility with ChangeDisplaySettings().
	CN3Base::s_Options.iViewColorDepth = ini.GetInt("ViewPort", "ColorDepth", 32);
	if (CN3Base::s_Options.iViewColorDepth != 16
		&& CN3Base::s_Options.iViewColorDepth != 32)
		CN3Base::s_Options.iViewColorDepth = 32;

	// NOTE: what is the viewport's draw distance?
	CN3Base::s_Options.iViewDist = ini.GetInt("ViewPort", "Distance", 512);
	if(CN3Base::s_Options.iViewDist < 256) CN3Base::s_Options.iViewDist = 256;
	if(CN3Base::s_Options.iViewDist > 512) CN3Base::s_Options.iViewDist = 512;

	// NOTE: what is the distance for sound events?
	CN3Base::s_Options.iEffectSndDist = ini.GetInt("Sound", "Distance", 48);
	if(CN3Base::s_Options.iEffectSndDist < 20) CN3Base::s_Options.iEffectSndDist = 20;
	if(CN3Base::s_Options.iEffectSndDist > 48) CN3Base::s_Options.iEffectSndDist = 48;

	// NOTE: is sound enabled?
	CN3Base::s_Options.bSndBgmEnable = ini.GetBool("Sound", "Bgm", true);
	CN3Base::s_Options.bSndEffectEnable = ini.GetBool("Sound", "Effect", true);
	CN3Base::s_Options.bSndEnable = (CN3Base::s_Options.bSndBgmEnable || CN3Base::s_Options.bSndEffectEnable);

	// NOTE: is sound duplicated?
	CN3Base::s_Options.bSndDuplicated = ini.GetBool("Sound", "Duplicate", false);

	// NOTE: should we use the Windows cursor? If false, will use the software cursor (CGameCursor) instead.
	CN3Base::s_Options.bWindowCursor = ini.GetBool("Cursor", "WindowCursor", true);
																	   
	// NOTE: should we show window full screen?
	CN3Base::s_Options.bWindowMode = ini.GetBool(
		"Screen",
		"WindowMode",
		// In debug builds, if not otherwise configured, we should just prefer to use windowed mode.
#if defined(_DEBUG)
		true
#else
		false
#endif
	);

	CN3Base::s_Options.bVSyncEnabled = ini.GetBool("Screen", "VSyncEnabled", true);

	srand((uint32_t) time(nullptr));

	// 메인 윈도우를 만들고..
	HWND hWndMain = CreateMainWindow(hInstance);
	if (hWndMain == nullptr)
	{
		CLogWriter::Write("Cannot create window.");
		exit(-1);
	}

	::ShowWindow(hWndMain, nCmdShow); // 보여준다..
	::SetActiveWindow(hWndMain);

	CGameProcedure::s_bWindowed = true;

	// allocate the static members
	CGameProcedure::StaticMemberInit(
		hInstance,
		hWndMain);

	// set the game's current procedure to s_pProcLogIn
	CGameProcedure::ProcActiveSet((CGameProcedure*)CGameProcedure::s_pProcLogIn);

#if _DEBUG
	HACCEL hAccel = LoadAccelerators( nullptr, MAKEINTRESOURCE(IDR_MAIN_ACCELATOR) );
	HDC hDC = GetDC(hWndMain);
#endif // #if _DEBUG

	MSG msg = {};
	BOOL bGotMsg = FALSE;

	while (WM_QUIT != msg.message)
	{
		// Use PeekMessage() if the app is active, so we can use idle time to
		// render the scene. Else, use GetMessage() to avoid eating CPU time.
		bGotMsg = PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE);
		if (bGotMsg)
		{
#if _DEBUG
			if (0 == TranslateAccelerator(hWndMain, hAccel, &msg))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
#else
			TranslateMessage(&msg);
			DispatchMessage(&msg);
#endif // #if _DEBUG
		}
		else
		{
			// Render a frame during idle time (no messages are waiting)
			CGameProcedure::TickActive();
			CGameProcedure::RenderActive();
		}
	}

#if _DEBUG
	ReleaseDC(hWndMain, hDC);
	DestroyAcceleratorTable(hAccel);
#endif // #if _DEBUG

	CGameProcedure::StaticMemberRelease();

	return static_cast<int>(msg.wParam);
}

HWND CreateMainWindow(HINSTANCE hInstance)
{
	WNDCLASSEXA wc;

	//  only register the window class once - use hInstance as a flag. 
	wc.cbSize        = sizeof(WNDCLASSEXA);
	wc.style         = 0;
	wc.lpfnWndProc   = (WNDPROC) WndProcMain;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInstance;
	wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAIN));
	wc.hCursor       = nullptr;
	wc.hbrBackground = (HBRUSH) GetStockObject(NULL_BRUSH);
	wc.lpszMenuName  = nullptr;
	wc.lpszClassName = "Knight OnLine Client";
	wc.hIconSm       = nullptr;

	if (0 == ::RegisterClassExA(&wc))
	{
		CLogWriter::Write("Cannot register window class.");
		exit(-1);
	}

	DWORD style;
	int iViewWidth, iViewHeight;
	if (CN3Base::s_Options.bWindowMode)
	{
		style = WS_CLIPCHILDREN | WS_CAPTION | WS_SYSMENU | WS_GROUP;

		RECT rc;
		rc.left = 0;
		rc.right = CN3Base::s_Options.iViewWidth;
		rc.top = 0;
		rc.bottom = CN3Base::s_Options.iViewHeight;

		AdjustWindowRect(&rc, style, FALSE);

		iViewWidth = rc.right - rc.left;
		iViewHeight = rc.bottom - rc.top;
	}
	else
	{
		style = WS_POPUP | WS_CLIPCHILDREN;
		iViewWidth = CN3Base::s_Options.iViewWidth;
		iViewHeight = CN3Base::s_Options.iViewHeight;
	}

	return ::CreateWindowExA(
		0,
		wc.lpszClassName,
		"Knight OnLine Client",
		style,
		0,
		0,
		iViewWidth,
		iViewHeight,
		0,
		0,
		hInstance,
		nullptr);
}

/*
	WndProcMain processes the messages for the main window
*/
LRESULT CALLBACK WndProcMain(
	HWND hWnd,
	UINT message,
	WPARAM wParam,
	LPARAM lParam)
{
	switch(message)
	{
		case WM_COMMAND:
		{
			uint16_t wNotifyCode = HIWORD(wParam); // notification code
			CN3UIEdit* pEdit = CN3UIEdit::GetFocusedEdit();

			if (wNotifyCode == EN_CHANGE && pEdit)
			{
				uint16_t wID = LOWORD(wParam); // item, control, or accelerator identifier
				HWND hwndCtl = (HWND) lParam;

				if (CN3UIEdit::s_hWndEdit == hwndCtl)
				{
					pEdit->UpdateTextFromEditCtrl();
					pEdit->UpdateCaretPosFromEditCtrl();
					CGameProcedure::SetGameCursor(CGameProcedure::s_hCursorNormal);
				}
			}
		} break;

		case WM_SOCKETMSG:
		{
			switch (WSAGETSELECTEVENT(lParam))
			{
				case FD_CONNECT:
				{
				  //TRACE("Socket connected..\n");
				} break;
				case FD_CLOSE:
				{
					CGameProcedure::ReportServerConnectionClosed(true);
					//TRACE("Socket closed..\n");
				}  break;
				case FD_READ:
				{
					CGameProcedure::s_pSocket->Receive();
				} break;
				default:
				{
					__ASSERT(0, "WM_SOCKETMSG: unknown socket flag.");
				} break;
			}
		} break;

		case WM_ACTIVATE:
		{
			int iActive = LOWORD(wParam);           // activation flag 
			int iMinimized = (BOOL) HIWORD(wParam); // minimized flag 
			HWND hwndPrevious = (HWND) lParam;      // window handle 

			switch (iActive)
			{
				case WA_CLICKACTIVE:
				case WA_ACTIVE:
				{
					SetFocus(hWnd);

					CN3UIEdit* pUIFocused = CN3UIBase::GetFocusedEdit();
					if (pUIFocused != nullptr)
					{
						pUIFocused->KillFocus();
						pUIFocused->SetFocus();
					}

					CGameProcedure::s_bIsWindowInFocus = true;
				}
				return 1;

				case WA_INACTIVE:
					CGameProcedure::s_bIsWindowInFocus = false;

					if (!CGameProcedure::s_bWindowed)
					{
						CLogWriter::Write("WA_INACTIVE.");
						PostQuitMessage(0);
					}
					break;
			}
		} break;

		case WM_CLOSE:
		case WM_DESTROY:
		case WM_QUIT:
		{
			if (CGameProcedure::s_pProcActive != nullptr
				&& CGameProcedure::s_pProcActive == CGameProcedure::s_pProcMain)
			{
				if (!_IsKeyDown(VK_MENU))
				{
					CGameProcedure::s_pProcMain->RequestExit();
					return 1;
				}

				if (CGameProcedure::s_pProcMain->m_fExitTimer != -1.0f)
				{
					if (CGameProcedure::s_pProcMain->m_pUIChatDlg != nullptr)
					{
						std::string szMsg = fmt::format_text_resource(IDS_CANNOT_EXIT_DURING_A_BATTLE);
						CGameProcedure::s_pProcMain->m_pUIChatDlg->AddChatMsg(N3_CHAT_NORMAL, szMsg, 0xFFFF0000);
						CGameProcedure::s_pProcMain->m_eExitType = EXIT_TYPE_QUIT;
					}

					return 1;
				}
			}

			CGameProcedure::s_pSocket->Disconnect();
			CGameProcedure::s_pSocketSub->Disconnect();

			PostQuitMessage(0);
		} break;

		case WM_MOUSEWHEEL:
		{
			CN3UIBase* pUI = nullptr;
			if (CGameProcedure::s_pMsgBoxMgr != nullptr)
				pUI = CGameProcedure::s_pMsgBoxMgr->GetFocusMsgBox();

			short delta = GET_WHEEL_DELTA_WPARAM(wParam);

			if (pUI != nullptr
				&& pUI->IsVisible()
				&& pUI->OnMouseWheelEvent(delta))
				break;

			if (CGameProcedure::s_pUIMgr != nullptr)
				pUI = CGameProcedure::s_pUIMgr->GetFocusedUI();

			if (pUI != nullptr
				&& pUI->IsVisible()
				&& pUI->OnMouseWheelEvent(delta))
				break;

			if (CGameProcedure::s_pProcActive == CGameProcedure::s_pProcMain)
				CGameProcedure::s_pEng->CameraZoom(delta * 0.05f);
		} break;
	}

	return DefWindowProc(hWnd, message, wParam, lParam);
}

// ===== END WarFare/WarFareMain.cpp =====

// ===== BEGIN WarFare/WarMessage.cpp =====
#line 1 "WarFare/WarMessage.cpp"
﻿// WarMessage.cpp: implementation of the CWarMessage class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WarMessage.h"
#include "GameBase.h"
#include "text_resources.h"

#define MESSAGE_FONT_SIZE		20
#define WAR_MESSAGE_SHOW_TIME	60

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWarMessage::CWarMessage()
{
	m_pMessageFont = nullptr;
	m_fTime = 0.0f;
}

CWarMessage::~CWarMessage()
{
	Release();
}

void CWarMessage::InitFont()
{
	Release();

	std::string szFont = fmt::format_text_resource(IDS_FONT_ID);

	m_pMessageFont = new CDFont(szFont, MESSAGE_FONT_SIZE);
	__ASSERT(m_pMessageFont, "Font Create Fail!!");

	if (m_pMessageFont)
	{
		m_pMessageFont->InitDeviceObjects(CN3Base::s_lpD3DDev);
		m_pMessageFont->RestoreDeviceObjects();

#ifdef _DEBUG
		m_ptMessage.y = 80;
#else
		m_ptMessage.y = 20;
#endif
		m_ptMessage.x = CN3Base::s_CameraData.vp.Width;

	}
}

void CWarMessage::Release()
{
	if (m_pMessageFont) delete m_pMessageFont; m_pMessageFont = nullptr;
}

void CWarMessage::SetMessage(const std::string& szText, uint32_t dwFlags, uint32_t dwColor)
{
	if (m_pMessageFont)
	{
		m_pMessageFont->SetText(szText, dwFlags); // 폰트에 텍스트 지정.
		m_pMessageFont->SetFontColor(dwColor);
		m_fTime = WAR_MESSAGE_SHOW_TIME;
	}
}

void CWarMessage::RenderMessage()
{
	if (m_fTime <= 0) return;

	if (m_pMessageFont)
	{
		D3DCOLOR crFont = m_pMessageFont->GetFontColor();

		m_pMessageFont->DrawText(m_ptMessage.x - 1.0f, m_ptMessage.y + 0.0f, 0xff000000, 0);
		m_pMessageFont->DrawText(m_ptMessage.x + 1.0f, m_ptMessage.y + 0.0f, 0xff000000, 0);
		m_pMessageFont->DrawText(m_ptMessage.x + 0.0f, m_ptMessage.y + 1.0f, 0xff000000, 0);
		m_pMessageFont->DrawText(m_ptMessage.x + 0.0f, m_ptMessage.y - 1.0f, 0xff000000, 0);

		m_pMessageFont->DrawText(m_ptMessage.x + 0.0f, m_ptMessage.y + 0.0f, crFont, 0);
	}
}

void CWarMessage::Tick()
{
	if (m_fTime > 0)
	{
		m_fTime -= CN3Base::s_fSecPerFrm;

		const int iScreenWidth = CN3Base::s_CameraData.vp.Width;

		m_ptMessage.x = iScreenWidth - ((int)(100 * (WAR_MESSAGE_SHOW_TIME - m_fTime)) % (iScreenWidth + m_pMessageFont->GetSize().cx));
	}
}

// ===== END WarFare/WarMessage.cpp =====

// ===== BEGIN WarFare/WarMessage.h =====
#line 1 "WarFare/WarMessage.h"
﻿// WarMessage.h: interface for the CWarMessage class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WARMESSAGE_H__F05854B5_6723_4F5C_BDAB_329F1939FEA6__INCLUDED_)
#define AFX_WARMESSAGE_H__F05854B5_6723_4F5C_BDAB_329F1939FEA6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <N3Base/DFont.h> // D3DFONT_BOLD

class CWarMessage  
{
private:
	float	m_fTime;
	CDFont*	m_pMessageFont;
	POINT	m_ptMessage;
public:
	void Tick();
	void	RenderMessage();
	void	SetMessage(const std::string& szText, uint32_t dwFlags = D3DFONT_BOLD,uint32_t dwColor = 0xffffffff);
	void	Release();
	void	InitFont();
	CWarMessage();
	virtual ~CWarMessage();

};

#endif // !defined(AFX_WARMESSAGE_H__F05854B5_6723_4F5C_BDAB_329F1939FEA6__INCLUDED_)

// ===== END WarFare/WarMessage.h =====

// ===== BEGIN WarFare/resource.h =====
#line 1 "WarFare/resource.h"
﻿//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDC_CURSOR_ATTACK               1
#define IDC_CURSOR_CLICK                2
#define IDC_CURSOR_CLICK1               3
#define IDC_CURSOR_NORMAL               4
#define IDC_CURSOR_NORMAL1              5
#define IDC_CURSOR_NOW_REPAIR           6
#define IDC_CURSOR_PRE_REPAIR           7
#define IDI_MAIN                        101
#define IDR_MAIN_ACCELATOR              201
#define ID_DEBUG0                       4901

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

// ===== END WarFare/resource.h =====

// ===== BEGIN WarFare/text_resources.h =====
#line 1 "WarFare/text_resources.h"
﻿#pragma once

#include "ClientResourceFormatter.h"

// Resource IDs from Data\Texts_us.tbl in the client.
enum e_TextResourceID
{
	IDS_BIND_POINT_FAILED						= 1001, // Failed designating re-spawn point. 
	IDS_BIND_POINT_REQUEST_FAIL					= 1002, // The re-spawn point is too far away. 
	IDS_BIND_POINT_SUCCESS						= 1003, // Successfully designated a re-spawn point. 
	IDS_WARP_WRONG_GATE							= 1004, // You've selected the wrong Warp Gate. 
	IDS_CHAT_SELECT_TARGET_FAIL					= 1101, // Failed to connect for a private chat 
	IDS_CHAT_SELECT_TARGET_SUCCESS				= 1102, // Successfully connected for a private chat 
	IDS_CHR_SELECT_FMT_INFO						= 1201, // Level : %d \nSpecialty : %s \nID : %s
	IDS_CHR_SELECT_HINT							= 1202, // Left click and\nyou can create a\nnew character. 
	IDS_CLASS_CHANGE_ALREADY					= 1301, // How are you? We need people like you to work hard for our victory!
	IDS_CLASS_CHANGE_NOT_YET					= 1302, // I think you need more training
	IDS_CLASS_CHANGE_SUCCESS					= 1303, // You can now obtain a greater strength. From now, you shall be called..
	IDS_CLASS_KINDOF_WARRIOR					= 1304, // Warrior
	IDS_CLASS_KINDOF_ROGUE						= 1305, // Rogue
	IDS_CLASS_KINDOF_WIZARD						= 1306, // Magician
	IDS_CLASS_KINDOF_PRIEST						= 1307, // Priest
	IDS_CLASS_KINDOF_ATTACK_WARRIOR				= 1308, // Offensive Warrior
	IDS_CLASS_KINDOF_DEFEND_WARRIOR				= 1309, // Defensive Warrior
	IDS_CLASS_KINDOF_ARCHER						= 1310, // Archer
	IDS_CLASS_KINDOF_ASSASSIN					= 1311, // Assassin
	IDS_CLASS_KINDOF_ATTACK_WIZARD				= 1312, // Offensive Magician
	IDS_CLASS_KINDOF_PET_WIZARD					= 1313, // Pet Magician
	IDS_CLASS_KINDOF_HEAL_PRIEST				= 1314, // Healing Priest
	IDS_CLASS_KINDOF_CURSE_PRIEST				= 1315, // Cursing Priest
	IDS_CLASS_EL_ASSASIN						= 1401, // Kasar Hood
	IDS_CLASS_EL_BLADE							= 1402, // Blade
	IDS_CLASS_EL_CLERIC							= 1403, // Cleric
	IDS_CLASS_EL_DRUID							= 1404, // Paladin
	IDS_CLASS_EL_ENCHANTER						= 1405, // Arch Mage
	IDS_CLASS_EL_MAGE							= 1406, // Mage
	IDS_CLASS_EL_PROTECTOR						= 1407, // Blade Master
	IDS_CLASS_EL_RANGER							= 1408, // Ranger
	IDS_CLASS_KA_BERSERKER						= 1409, // Berserker
	IDS_CLASS_KA_DARKPRIEST						= 1410, // Shadow Knight    
	IDS_CLASS_KA_GUARDIAN						= 1411, // Berserker Hero
	IDS_CLASS_KA_HUNTER							= 1412, // Hunter
	IDS_CLASS_KA_NECROMANCER					= 1413, // Elemental Lord
	IDS_CLASS_KA_PENETRATOR						= 1414, // Shadow Vain
	IDS_CLASS_KA_SHAMAN							= 1415, // Shaman
	IDS_CLASS_KA_SORCERER						= 1416, // Sorcerer
	IDS_CLASS_PRIEST							= 1417, // Priest
	IDS_CLASS_ROGUE								= 1418, // Rogue
	IDS_CLASS_UNKNOWN							= 1419, // Unconfirmed Specialty 
	IDS_CLASS_WARRIOR							= 1420, // Warrior
	IDS_CLASS_WIZARD							= 1421, // Magician
	IDS_CONFIRM_DELETE_CHR						= 1501, // Character deletion has been disabled currently
	IDS_CONFIRM_EXIT_GAME						= 1502, // Are you sure you want to exit? 
	IDS_CONNECTION_CLOSED						= 1601, // Disconnected from server
	IDS_CONNECT_IP								= 1602,
	IDS_COUNTABLE_ITEM_BUY_FAIL					= 1701, // You cannot buy more than 9,999 items at once.
	IDS_MANY_COUNTABLE_ITEM_BUY_FAIL			= 1701, // You cannot buy more than 9,999 items at once.
	IDS_COUNTABLE_ITEM_BUY_NOT_ENOUGH_MONEY		= 1702, // You don't have enough Coins. 
	IDS_COUNTABLE_ITEM_GET_MANY					= 1703, // You cannot carry more than 9,999 items at once. 
	IDS_MANY_COUNTABLE_ITEM_GET_MANY			= 1703, // You cannot carry more than 9,999 items at once. 
	IDS_COUNTABLE_ITEM_TOO_MAMY					= 1704, // You cannot have more than 9,999 items. 
	IDS_MANY_COUNTABLE_ITEM_TOO_MAMY			= 1704, // You cannot have more than 9,999 items. 
	IDS_SMALL_COUNTABLE_ITEM_BUY_FAIL			= 1705, // You cannot buy more than 500 items at once. 
	IDS_SMALL_COUNTABLE_ITEM_GET_MANY			= 1706, // You cannot carry more than 500 items at once. 
	IDS_SMALL_COUNTABLE_ITEM_TOO_MAMY			= 1707, // You cannot have more than 500 items. 
	IDS_ITEM_TOOMANY_OR_HEAVY					= 1708, // You cannot trade or pick up items because you have either exceeded the possible quantity or the weight. 
	IDS_DOOR_CLOSED								= 1801, // The Castle Gate has been closed
	IDS_DOOR_OPENED								= 1802, // The Castle Gate has opened
	IDS_ERR_CHARACTER_CREATE					= 1901, // Failed creating character
	IDS_ERR_DB_CREATE							= 1902, // Failed creating Database
	IDS_ERR_GOTO_TOWN_OUT_OF_HP					= 1903, // You cannot teleport back to town when you have half the HP or less
	IDS_ERR_INVALID_CLASS						= 1904, // Please select a specialty.
	IDS_ERR_INVALID_NAME						= 1905, // Please enter your character ID. 
	IDS_ERR_INVALID_NAME_HAS_SPECIAL_LETTER		= 1906, // You cannot use this character ID. 
	IDS_ERR_INVALID_NATION_RACE					= 1907, // The selected nation and the race does not match. 
	IDS_ERR_INVALID_RACE						= 1908, // Please select a race. 
	IDS_ERR_KNIGHTS_CREATE_FAILED_NAME_EMPTY	= 1909, // You need to have a name in order to create a Knights
	IDS_ERR_NOT_SUPPORTED_RACE					= 1910, // This race is not available yet. 
	IDS_ERR_NO_MORE_CHARACTER					= 1911, // You cannot create anymore characters. 
	IDS_ERR_OVERLAPPED_ID						= 1912, // This ID is already used on another character.
	IDS_ERR_REMAIN_BONUS_POINT					= 1913, // There are stat points still remaining. 
	IDS_ERR_REQUEST_OBJECT_EVENT_SO_FAR			= 1914, // You are too far away from the object. 
	IDS_ERR_UNKNOWN								= 1915, // Unknown error. 
	IDS_EXIT									= 2001, // Are you sure you want to exit? 
	IDS_FMT_CONCURRENT_USER_COUNT				= 2101, // *** Current concurrent user : %d ***
	IDS_FONT_BALLOON							= 2201, // Arial
	IDS_FONT_ID									= 2202, // Arial
	IDS_FONT_INFO								= 2203, // Arial
	IDS_INV_ITEM_FULL							= 2301, // You cannot pick up the item because your item inventory is full. 
	IDS_ITEM_ATTRIB_CRAFT						= 2401, // Craft item. 
	IDS_ITEM_ATTRIB_GENERAL						= 2402, // Regular item. 
	IDS_ITEM_ATTRIB_LAIR						= 2403, // Rare item. 
	IDS_ITEM_ATTRIB_MAGIC						= 2404, // Magic item. 
	IDS_ITEM_ATTRIB_UNIQUE						= 2405, // Unique item. 
	IDS_ITEM_ATTRIB_UPGRADE						= 2406, // Upgrade item. 
	IDS_ITEM_CLASS_AMULET						= 2501, // Necklace
	IDS_ITEM_CLASS_ARMOR_MAGE					= 2502, // Magician Armor
	IDS_ITEM_CLASS_ARMOR_PRIEST					= 2503, // Priest Armor
	IDS_ITEM_CLASS_ARMOR_ROGUE					= 2504, // Rogue Armor
	IDS_ITEM_CLASS_ARMOR_WARRIOR				= 2505, // Warrior Armor
	IDS_ITEM_CLASS_ARROW						= 2506, // Arrow
	IDS_ITEM_CLASS_AXE							= 2507, // Axe
	IDS_ITEM_CLASS_AXE_2H						= 2508, // Two-handed Axe
	IDS_ITEM_CLASS_BELT							= 2509, // Belt
	IDS_ITEM_CLASS_BOW							= 2510, // Bow
	IDS_ITEM_CLASS_BOW_CROSS					= 2511, // Crossbow
	IDS_ITEM_CLASS_BOW_LONG						= 2512, // Long Bow
	IDS_ITEM_CLASS_CHARM						= 2513, // Lune Item
	IDS_ITEM_CLASS_DAGGER						= 2514, // Dagger
	IDS_ITEM_CLASS_EARRING						= 2515, // Earring 
	IDS_ITEM_CLASS_ETC							= 2516, // Others
	IDS_ITEM_CLASS_JAVELIN						= 2517, // Javelin
	IDS_ITEM_CLASS_JEWEL						= 2518, // Jewelry
	IDS_ITEM_CLASS_LAUNCHER						= 2519, // IDS_ITEM_CLASS_LAUNCHER
	IDS_ITEM_CLASS_MACE							= 2520, // Club
	IDS_ITEM_CLASS_MACE_2H						= 2521, // Two-handed Club
	IDS_ITEM_CLASS_POLEARM						= 2522, // Long Spear
	IDS_ITEM_CLASS_POTION						= 2523, // Potion
	IDS_ITEM_CLASS_RING							= 2524, // Ring
	IDS_ITEM_CLASS_SCROLL						= 2525, // Scroll
	IDS_ITEM_CLASS_SHIELD						= 2526, // Shield
	IDS_ITEM_CLASS_SPEAR						= 2527, // Spear
	IDS_ITEM_CLASS_STAFF						= 2528, // Staff
	IDS_ITEM_CLASS_SWORD						= 2529, // One-handed Sword
	IDS_ITEM_CLASS_SWORD_2H						= 2530, // Two-handed Sword
	IDS_ITEM_WEIGHT_OVERFLOW					= 2601, // You've exceeded your possible carrying weight. 
	IDS_KNIGHTS_ADMIT_FAILED					= 2701, // Request for Joining Knights has been declined.
	IDS_KNIGHTS_ADMIT_SUCCESS					= 2702, // Successfully admitted into the Knights
	IDS_KNIGHTS_APPOINT_CHIEF_FAILED			= 2703, // Failed to be appointed as a Knights Leader 
	IDS_KNIGHTS_APPOINT_CHIEF_SUCCESS			= 2704, // Successfully appointed as a Knights Leader
	IDS_KNIGHTS_APPOINT_OFFICER_FAILED			= 2705, // Failed to be appointed as Officer
	IDS_KNIGHTS_APPOINT_OFFICER_SUCCESS			= 2706, // Successfully appointed as a Officer
	IDS_KNIGHTS_APPOINT_VICECHIEF_FAILED		= 2707, // Failed to be appointed as Assistant Leader
	IDS_KNIGHTS_APPOINT_VICECHIEF_SUCCES		= 2708, // Successfully appointed as Assistant Leader
	IDS_KNIGHTS_CREATE_FAILED					= 2709, // Failed to create the Knights
	IDS_KNIGHTS_CREATE_SUCCESS					= 2710, // Succesfully created the Knights
	IDS_KNIGHTS_DESTROY_CONFIRM					= 2711, // Do you want to disband the Knights?
	IDS_KNIGHTS_DESTROY_FAILED					= 2712, // Failed to disband the Knights
	IDS_KNIGHTS_DESTROY_SUCCESS					= 2713, // Successfully disbanded the Knights
	IDS_KNIGHTS_DUTY_CHIEF						= 2714, // Leader
	IDS_KNIGHTS_DUTY_KNIGHT						= 2715, // Member
	IDS_KNIGHTS_DUTY_OFFICER					= 2716, // Staff Officer
	IDS_KNIGHTS_DUTY_PUNISH						= 2717, // Under disciplinary punishment
	IDS_KNIGHTS_DUTY_TRAINEE					= 2718, // Apprentice
	IDS_KNIGHTS_DUTY_UNKNOWN					= 2719, // none
	IDS_KNIGHTS_DUTY_VICECHIEF					= 2720, // Assistant Leader
	IDS_KNIGHTS_JOIN_FAILED						= 2721, // Failed to join the Knights
	IDS_KNIGHTS_JOIN_SUCCESS					= 2722, // Successfully joined the Knights
	IDS_KNIGHTS_PUNISH_FAILED					= 2723, // Failed to displine a member of the Knights
	IDS_KNIGHTS_PUNISH_SUCCESS					= 2724, // Successfully disciplined a member of the Knights
	IDS_KNIGHTS_REJECT_FAILED					= 2725, // Failed to decline a request to join the Knights
	IDS_KNIGHTS_REJECT_SUCCESS					= 2726, // Successfully declined a request to join the Knights
	IDS_KNIGHTS_REMOVE_MEMBER_FAILED			= 2727, // Failed to ban a member of the Knights
	IDS_KNIGHTS_REMOVE_MEMBER_SUCCESS			= 2728, // Successfully banned a member of the Knights
	IDS_KNIGHTS_WITHDRAW_CONFIRM				= 2729, // Do you want to quit the Knights?
	IDS_KNIGHTS_WITHROW_FAILED					= 2730, // Failed to quit the Knights
	IDS_KNIGHTS_WITHROW_SUCCESS					= 2731, // Successfully quitted the Knights
	IDS_LEVER_ACTIVATE							= 2801, // The lever has been activated. 
	IDS_LEVER_DEACTIVATE						= 2802, // The lever has been deactivated. 
	IDS_LOGIN_FAILED							= 2901, // Log in failed.  Please contact customer service. 
	IDS_LOGIN_ERR_ALREADY_CONNECTED_ACCOUNT		= 2902, // Log in failed.  Please try again.  
	IDS_NOACCOUNT_RETRY_MGAMEID					= 2903, // No such registered ID
	IDS_NO_MGAME_ACCOUNT						= 2904, // The ID doesn't exist on MGame either.  
	IDS_FMT_CONNECT_ERROR						= 2905, // Failed logging into the %s server. (%d)
	IDS_FMT_GAME_SERVER_LOGIN_ERROR				= 2906, // Successfully connected to %s server but failed logging into the game. (%d)
	IDS_SERVER_CONNECT_FAIL						= 2907, // Your account is currently blocked. Please contact customer support.
	IDS_CURRENT_SERVER_ERROR					= 2908, // There is an error in the selected server. 
	IDS_CONNECT_FAIL							= 2909, // Connection failed.
	IDS_MSG_ATTACK_DISABLE						= 3001, // Could not attack because you're facing the wrong direction or the target is too far. 
	IDS_MSG_ATTACK_START						= 3002, // Beginning attack on %s
	IDS_MSG_ATTACK_STOP							= 3003, // Stop Attack
	IDS_MSG_CASTING_FAIL_LACK_MP				= 3004, // Skill Failed - Not enough MP
	IDS_MSG_CASTING_FAIL_LOW_MP					= 3005,
	IDS_MSG_FAIL_LOW_SP							= 3006,
	IDS_MSG_FMT_EXP_GET							= 3007, // Earned %d Experience Points
	IDS_MSG_FMT_EXP_LOST						= 3008, // Lost %d Experience Points
	IDS_MSG_FMT_HP_LOST							= 3009, // %d HP Damage
	IDS_MSG_FMT_HP_RECOVER						= 3010, // %d HP Recovered
	IDS_MSG_FMT_MP_RECOVER						= 3011, // %d MP Recovered
	IDS_MSG_FMT_MP_USE							= 3012, // %d MP Used
	IDS_MSG_FMT_SP_RECOVER						= 3013, // %d SP Recovered
	IDS_MSG_FMT_SP_USE							= 3014, // %d SP Used
	IDS_MSG_FMT_TARGET_ATTACK_FAILED			= 3015, // %s Missed.
	IDS_MSG_FMT_TARGET_HP_LOST					= 3016, // %s received %d damage
	IDS_MSG_FMT_TARGET_HP_RECOVER				= 3017, // %s received %d HP  
	IDS_MSG_VALID_CLASSNRACE_INVALID_RACE		= 3018, // You cannot equip this item.  This item is designed for a different race. 
	IDS_MSG_VALID_CLASSNRACE_LOW_CHA			= 3019, // You cannot equip this item because you don't have enough Magic Power stat point
	IDS_MSG_VALID_CLASSNRACE_LOW_DEX			= 3020, // You cannot equip this item because you don't have enough Dexterity stat point
	IDS_MSG_VALID_CLASSNRACE_LOW_INT			= 3021, // You cannot equip this item because you don't have enough Intelligence stat point
	IDS_MSG_VALID_CLASSNRACE_LOW_LEVEL			= 3022, // You cannot equip this item because your level is too low
	IDS_MSG_VALID_CLASSNRACE_LOW_POWER			= 3023, // You cannot equip this item because you don't have enough Strength stat points. 
	IDS_MSG_VALID_CLASSNRACE_LOW_RANK			= 3024, // You cannot equip this item because of your class. 
	IDS_MSG_VALID_CLASSNRACE_LOW_STR			= 3025, // You cannot equip this item because you don't have enough Health stat points. 
	IDS_MSG_VALID_CLASSNRACE_LOW_TITLE			= 3026, // You cannot equip this item because your title is too low. 
	IDS_MSG_CONCURRENT_USER_OVERFLOW			= 3027, // The number of users has surpassed its maximum limit allowed for a specific zone 
	IDS_MSG_VALID_CLASSNRACE_INVALID_CLASS		= 3028, // You cannot equip this item.  This item is not designed for your character's specialty.
	IDS_NATION_ELMORAD							= 3101, // El Morad
	IDS_NATION_KARUS							= 3102, // Karus
	IDS_NATION_UNKNOWN							= 3103, // Unconfirmed nation
	IDS_NEWCHR_MAP								= 3201, // This is the stat that affects the character's power for magic attacks.  
	IDS_NEWCHR_DEX								= 3202, // This stat increases character's dodging ability and affects the power of arrow attacks for rogues.
	IDS_NEWCHR_EL_BABA							= 3203, // The barbarians are warriors with strong physiques from the north.  They can only become a warrior.
	IDS_NEWCHR_EL_FEMALE						= 3204, // El Moradian female characters possess strong Magic Power and high Intelligence.  
	IDS_NEWCHR_EL_MAGE							= 3205, // The Magicians can become a Mage which uses 4 basic elements to perform attack magic or they can become an Enchanter, the master of mind control.
	IDS_NEWCHR_EL_MALE							= 3206, // El Moradian males have balanced Strength and Intelligence which makes them fit for any kind of job.  
	IDS_NEWCHR_EL_PRIEST						= 3207, // The Priests can become a Cleric to heal friends or become a Druid to cast a curse on the enemy or increase ally's stats. 
	IDS_NEWCHR_EL_ROGUE							= 3208, // The Rogues can become an Assassin to sneak up to the enemy and inflict a critical damage, or they can become a Ranger that can attack enemies from far away with bows and spears.  
	IDS_NEWCHR_EL_WARRIOR						= 3209, // The Warriors can become a Blade that uses variety of weapons to inflict critical damage, or they can become a Protector with high defense ability to protect ally's magicians and priests.  
	IDS_NEWCHR_INT								= 3210, // This stat affects the amount of Mental Power (MP) for Magicians and Priests. 
	IDS_NEWCHR_KA_ARKTUAREK						= 3211, // Arch Tuarek is a physically strong race who are fit to become a warrior. 
	IDS_NEWCHR_KA_MAGE							= 3212, // The Magicians can become a Sorcerer which uses 4 basic elements to perform attack magic or they can become a Necromancer, the master of the dead. 
	IDS_NEWCHR_KA_PRIEST						= 3213, // The Priests can become a Shaman that heals its ally or become a Dark Priest that can use cursing skills. 
	IDS_NEWCHR_KA_PURITUAREK					= 3214, // 퓨리 투아렉은 순수하게 정화된 정신 에너지를 이용해 치료 마법과 저주 마법을 구사하는 카루스의 여성 캐릭터로 법사와 사제의 직업을 선택할 수 있습니다.
	IDS_NEWCHR_KA_ROGUE							= 3215, // The Rogues can become an Assassin to sneak up to the enemy and inflict a critical damage, or they can become a Hunter that can attack enemies from far away with bows and spears.  
	IDS_NEWCHR_KA_TUAREK						= 3216, // Tuareks have balanced Strength and Intelligence which makes them fit for any kind of job.
	IDS_NEWCHR_KA_WARRIOR						= 3217, // The Warriors can become a Berserker that uses variety of weapons to inflict critical damage, or they can become a Guardian with high defense ability to protect ally's magicians and priests.  
	IDS_NEWCHR_KA_WRINKLETUAREK					= 3218, // Wrinkle Tuareks have strong mental powers. Wrinkle Tuareks can only become a Magician.   
	IDS_NEWCHR_POW								= 3219, // This stat affects the attack/defense power of a character that uses a weapon.
	IDS_NEWCHR_STA								= 3220, // This stat affects the amount of character's Health Point (HP). 
	IDS_NPCEVENT_TITLE_REPAIR					= 3301, // A great blacksmith like me is hard to find.  Tell me if you need anything… 
	IDS_NPC_EVENT_TITLE_TRADE					= 3302, // I have many items.  Would you like to take a look at them? 
	IDS_PARTY_CONFIRM_DESTROY					= 3401, // Are you sure you want to disband the party? 
	IDS_PARTY_CONFIRM_DISCHARGE					= 3402, // Would you like to ban %s form the party? 
	IDS_PARTY_CONFIRM_LEAVE						= 3403, // Would you like to quit the party? 
	IDS_PARTY_DESTROY							= 3404, // The party has been disbanded. 
	IDS_PARTY_INSERT							= 3405, //  has joined the party. 
	IDS_PARTY_INSERT_ERR						= 3406, // The invitation to the party has been declined. 
	IDS_PARTY_INSERT_ERR_INVALID_NATION			= 3407, // You cannot form a party with a user from the other nation. 
	IDS_PARTY_INSERT_ERR_LEVEL_DIFFERENCE		= 3408, // You cannot form a party because of the Level difference.
	IDS_PARTY_INSERT_ERR_REJECTED				= 3409, // The invitation to the party has been declined. 
	IDS_PARTY_INSERT_FAILED						= 3410,
	IDS_PARTY_INVITE							= 3411, // Player was invited into the party. Waiting for a response.
	IDS_PARTY_INVITE_FAILED						= 3412, //  could not be invited into the party. 
	IDS_PARTY_ITEM_GET							= 3413, // %s got %s
	IDS_PARTY_LEAVE								= 3414, // You've quit the party. 
	IDS_PARTY_PERMIT							= 3415, //  has invited you to join the party. Will you join? 
	IDS_PERSONAL_TRADE_FMT_WAIT					= 3501, // %s has sent a request for a trade to %s. Please wait for a reply.
	IDS_PERSONAL_TRADE_PERMIT					= 3502, // %s has received a request for a trade from %s. Will you accept? 
	IDS_PERSONAL_TRADE_REQUEST					= 3503, //  is requesting to trade.
	IDS_PER_TRADEING_OTHER						= 3504, // A request for a trade has been received from another user while you were trading.  
	IDS_RACE_ALL								= 3601, // All race
	IDS_RACE_EL_BABARIAN						= 3602, // Barbarian
	IDS_RACE_EL_MAN								= 3603, // Male El Moradian
	IDS_RACE_EL_WOMEN							= 3604, // Female El Moradian
	IDS_RACE_KA_ARKTUAREK						= 3605, // Arch Tuarek 
	IDS_RACE_KA_PURITUAREK						= 3606, // Puri Tuarek 
	IDS_RACE_KA_TUAREK							= 3607, // Tuarek 
	IDS_RACE_KA_WRINKLETUAREK					= 3608, // Wrinkle Tuarek 
	IDS_RACE_UNKNOWN							= 3609, // Unconfirmed race
	IDS_REGENERATION							= 3701, // Press OK to teleport back to the re-spawn point. 
	IDS_REPAIR_LACK_GOLD						= 3801, // You don't have enough money for the repair. 
	IDS_REQUEST_BINDPOINT						= 3901, // Would you like to designate this place as your re-spawn point? 
	IDS_SKILL_ATTACK_FAIL_SOFAR					= 4001,
	IDS_SKILL_FAIL_CASTING						= 4002, // Casting failed
	IDS_SKILL_FAIL_DIFFURENTCLASS				= 4003, // You cannot user this Skill/Magic. 
	IDS_SKILL_FAIL_EFFECTING					= 4004, // %s failed
	IDS_SKILL_FAIL_INVALID_ITEM					= 4005, // Skill Failed - Improper item
	IDS_SKILL_FAIL_LACK_HP						= 4006, // Skill Failed - Not enough HP
	IDS_SKILL_FAIL_LACK_ITEM					= 4007, // Skill Failed - Not enough item
	IDS_SKILL_FAIL_LACK_SP						= 4008, // Skill Failed - Not enough SP
	IDS_SKILL_FAIL_SOFAR						= 4009, // Skill Failed - Too far
	IDS_SKILL_HEALING_FAIL_SOFAR				= 4010, // Skill Failed - Blocked by an object
	IDS_SKILL_FAIL_OBJECT_BLOCK					= 4010, // Skill Failed - Blocked by an object
	IDS_SKILL_POINT_BEFORE_CLASS_CHANGE			= 4101, // You cannot distribute your skill points because you haven't picked your specialty yet.
	IDS_SKILL_POINT_EXTRA_NOT_EXIST				= 4102, // There's no remaining skill point. 
	IDS_SKILL_POINT_NOT_YET						= 4103, // This skill is not available. 
	IDS_SKILL_SUCCESS_HEALING_FROM				= 4201, // %s heals you %d HP 
	IDS_SKILL_SUCCESS_HEALING_TO				= 4202, // %s received %d HP 
	IDS_SKILL_TOOLTIP_DOUBLE					= 4301, // Required Item : Double Hand
	IDS_SKILL_TOOLTIP_NEED_ITEM_DUAL			= 4302, // Required Item : Dual Hand
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID1				= 4303, // Required Item : All Weapons
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID10			= 4304, // Required Item : Launcher
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID11			= 4305, // Required Item : Staff
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID12			= 4306, // Required Item : Arrow
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID13			= 4307, // Required Item : Javelin
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID14			= 4308, // Required Item : Warrior Armor
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID15			= 4309, // Required Item : Rogue Armor
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID16			= 4310, // Required Item : Magician Armor
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID17			= 4311, // Required Item : Priest Armor
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID2				= 4312, // Required Item : Dagger
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID3				= 4313, // Required Item : Sword
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID4				= 4314, // Required Item : Ax
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID5				= 4315, // Required Item : Striking Weapon
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID6				= 4316, // Required Item : Spear
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID7				= 4317, // Required Item : Shield
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID8				= 4318, // Required Item : Bow
	IDS_SKILL_TOOLTIP_NEED_ITEM_ID9				= 4319, // Required Item : Longbow
	IDS_SKILL_TOOLTIP_NO_MANA					= 4320, // Doesn't use MP
	IDS_SKILL_TOOLTIP_USE_ITEM_EXIST			= 4321, // Item Consumed : %s
	IDS_SKILL_TOOLTIP_USE_ITEM_NO				= 4322, // No item consumed
	IDS_SKILL_TOOLTIP_USE_MANA					= 4323, // MP consumed : %d
	IDS_SKILL_TOOLTIP_NEED_LEVEL				= 4324, // Required Level : %d
	IDS_SKILL_TOOLTIP_NEED_SKILL_PT				= 4325, // Required Skill Point : %d
	IDS_SKILL_TOOLTIP_NEED_ITEM_NO				= 4328, // No basic item
	IDS_SKILL_TOOLTIP_ITEM_NEED					= 4329, // Required item : %s
	IDS_SKILL_TOOLTIP_ITEM_NO					= 4330, // No required item
	IDS_SKILL_UP_INVALID						= 4401, // The value of a Skill Point cannot be greater than your level. 
	IDS_SKILL_USE								= 4402, // Using %s
	IDS_TOOLTIP_ATTACK							= 4501,
	IDS_TOOLTIP_ATTACKINT_FAST					= 4502, // Attack Speed : Fast
	IDS_TOOLTIP_ATTACKINT_NORMAL				= 4503, // Attack Speed : Normal
	IDS_TOOLTIP_ATTACKINT_SLOW					= 4504, // Attack Speed : Slow
	IDS_TOOLTIP_ATTACKINT_VERYFAST				= 4505, // Attack Speed : Very Fast
	IDS_TOOLTIP_ATTACKINT_VERYSLOW				= 4506, // Attack Speed : Very Slow
	IDS_TOOLTIP_ATTACKRANGE						= 4507, // Effective Range : %.2f
	IDS_TOOLTIP_ATTRMAGIC1						= 4508, // Flame Damage : %d
	IDS_TOOLTIP_ATTRMAGIC2						= 4509, // Glacier Damage : %d
	IDS_TOOLTIP_ATTRMAGIC3						= 4510, // Lightning Damage : %d
	IDS_TOOLTIP_ATTRMAGIC4						= 4511, // Poison Damage : %d
	IDS_TOOLTIP_ATTRMAGIC5						= 4512, // HP Absorbed : %d
	IDS_TOOLTIP_ATTRMAGIC6						= 4513, // MP Damage : %d
	IDS_TOOLTIP_ATTRMAGIC7						= 4514, // MP Absorbed : %d
	IDS_TOOLTIP_AVOIDRATE_OVER					= 4515, // Increase Dodging Rate by %d%%
	IDS_TOOLTIP_AVOIDRATE_UNDER					= 4516, // Decrease Dodging Rate by %d%%
	IDS_TOOLTIP_BONUSMAGICATTACK				= 4517, // Magic Power Bonus : %d
	IDS_TOOLTIP_BONUSDEX						= 4518, // Dexterity Bonus : %d
	IDS_TOOLTIP_BONUSHP							= 4519, // HP Bonus : %d
	IDS_TOOLTIP_BONUSINT						= 4520, // Intelligence Bonus : %d
	IDS_TOOLTIP_BONUSSTR						= 4521, // Strength Bonus : %d
	IDS_TOOLTIP_BONUSWIZ						= 4522, // MP Bonus : %d
	IDS_TOOLTIP_BUY_PRICE						= 4523, // Purchasing Price : %s
	IDS_TOOLTIP_CUR_DURABILITY					= 4524, // Current Durability : %d
	IDS_TOOLTIP_DAMAGE							= 4525, // Attack Power : %d
	IDS_TOOLTIP_DEFENSE							= 4526, // Defense Ability : %d
	IDS_TOOLTIP_DEFENSE_RATE_ARROW				= 4527, // Defense Ability (Arrow) : %d
	IDS_TOOLTIP_DEFENSE_RATE_AXE				= 4528, // Defense Ability (Ax) : %d
	IDS_TOOLTIP_DEFENSE_RATE_BLOW				= 4529, // Defense Ability (Club) : %d
	IDS_TOOLTIP_DEFENSE_RATE_DAGGER				= 4530, // Defense Ability (Dagger) : %d
	IDS_TOOLTIP_DEFENSE_RATE_SPEAR				= 4531, // Defense Ability (Spear) : %d
	IDS_TOOLTIP_DEFENSE_RATE_SWORD				= 4532, // Defense Ability (Sword) : %d
	IDS_TOOLTIP_GOLD							= 4533, // Coin
	IDS_TOOLTIP_HITRATE_OVER					= 4534, // Increase Attack Power by %d%%
	IDS_TOOLTIP_HITRATE_UNDER					= 4535, // Decrease Attack Power by %d%%
	IDS_TOOLTIP_MAX_DURABILITY					= 4536, // Max Durability : %d
	IDS_TOOLTIP_NEEDMAGICATTACK					= 4537, // Required Magic Power : %d %s
	IDS_TOOLTIP_NEEDDEXTERITY					= 4538, // Required Dexterity : %d %s
	IDS_TOOLTIP_NEEDHEALTH						= 4539,
	IDS_TOOLTIP_NEEDINTELLI						= 4540, // Required Intelligence : %d %s
	IDS_TOOLTIP_NEEDLEVEL						= 4541, // Required Level : %d
	IDS_TOOLTIP_NEEDRANK						= 4542, // Required Class : %d
	IDS_TOOLTIP_NEEDSTAMINA						= 4543, // Required Health : %d %s
	IDS_TOOLTIP_NEEDSTRENGTH					= 4544, // Required Strength : %d %s
	IDS_TOOLTIP_NEEDTITLE						= 4545, // Required Title : %s
	IDS_TOOLTIP_REGISTCURSE						= 4546, // Resistance to Curse : %d
	IDS_TOOLTIP_REGISTELEC						= 4547, // Resistance to Lightning : %d
	IDS_TOOLTIP_REGISTFIRE						= 4548, // Resistance to Flame : %d
	IDS_TOOLTIP_REGISTICE						= 4549, // Resistance to Glacier : %d
	IDS_TOOLTIP_REGISTMAGIC						= 4550, // Resistance to Magic : %d
	IDS_TOOLTIP_REGISTPOISON					= 4551, // Resistance to Poison : %d
	IDS_TOOLTIP_SELL_PRICE						= 4552, // Selling Price : %s
	IDS_TOOLTIP_WEIGHT							= 4553, // Weight : %.2f
	IDS_TOOLTIP_REDUCE							= 4554, // (Reduce)
	IDS_TOOLTIP_REPEL_PHYSICAL					= 4555, // Repel Physical Attack : %d
	IDS_TOOLTIP_RENTAL_TIME						= 4556, // [%s] Remaining Time : %d minutes
	IDS_TOOLTIP_NEEDLEVEL_RANGE					= 4558, // Required Level : %d ~ %d
	IDS_TOOLTIP_NEEDTITLE2						= 4559, // Required Title : %s
	IDS_TOOLTIP_GRADE							= 4560, // Item Grade : %d Grade
	IDS_TOOLTIP_UNIQUE							= 4561, // Unique
	IDS_TOOLTIP_LOW_CLASS						= 4562, // Item Grade : low Class
	IDS_TOOLTIP_MIDDLE_CLASS					= 4563, // Item Grade : middle Class
	IDS_TOOLTIP_HIGH_CLASS						= 4564, // Item Grade : high Class
	IDS_TRY_SPEED_HACKING						= 4601, // Speed Hacking has been tried. 
	IDS_URL_JOIN								= 4701, // http://www.knightonlineworld.com
	IDS_VERSION_CONFIRM							= 4801, // This client is version %.3f. You'll need to have version %.3f in order to log in to the server. 
	IDS_TOOLTIP_BONUSSTA						= 4802, // Health Bonus : %d
	IDS_VERSION_CONFIRM_TW						= 4803, // This is an outdated version. Please install the newest client. 
	IDS_HELP_TIP1								= 5001, // Recover rapidly by sitting down - 'C'
	IDS_HELP_TIP2								= 5002, // You can move using your mouse in the 'quarter-view' mode. 
	IDS_HELP_TIP3								= 5003, // Toggle Auto Walk/Run - 'E'
	IDS_HELP_TIP4								= 5004, // When you want to teleport back to town - Type'/town'
	IDS_HELP_TIP5								= 5005, // To find the nearest enemy/monster - Press the 'Z' key
	IDS_HELP_TIP6								= 5006, // Using Skill : Drag the skill icon to the shortcut key window. 
	IDS_HELP_TIP7								= 5007, // Designate re-spawn spot : Right-click on the Resurrection Stone. 
	IDS_HELP_TIP8								= 5008, // Visit the blacksmith to increase the durability of an item. 
	IDS_HELP_TIP9								= 5009, // Item Storage : Right-click on the Inn-Keeper. 
	IDS_HELP_TIP10								= 5010, // Selecting Specialty : You can select your specialty when you reach level 10. 
	IDS_HELP_TIP11								= 5011, // Pick up item : Click on the dead monster.
	IDS_HELP_TIP12								= 5012, // Walk/Run : Press the 'Y' key
	IDS_HELP_TIP13								= 5013, // Toggle Attack : Press the 'R' key or double click on the target. 
	IDS_HELP_TIP14								= 5014, // Toggle View : shortcut key 'F9'
	IDS_HELP_TIP15								= 5015, // You can move your character by pressing 'W,A,S,D's keys or the arrow keys. 
	IDS_HELP_TIP16								= 5016, // Using Skill : Press the skill icon placed on the shortcut key window or press '1~8'
	IDS_HELP_TIP17								= 5017, // You can level up faster if you form a party. 
	IDS_HELP_TIP18								= 5018, // Display request for party : Type'/Seeking_party'
	IDS_HELP_TIP19								= 5019, // Invite into a party : Type '/party'
	IDS_HELP_TIP20								= 5020, // Trade Item : Select a character and type '/trade'
	IDS_HELP_TIP21								= 5021, // Party Chat : Click on the 'Party Chat' button on the chat window
	IDS_HELP_TIP22								= 5022, // General Chat : Click on the 'General Chat' button on the chat window
	IDS_HELP_TIP23								= 5023, // Gaining Stat Points : Gain 3 stat points every time you level up. 
	IDS_HELP_TIP24								= 5024, // Gaining Skill Points : You can gain 2 skill points every time you level up once you've reached level 10. 
	IDS_HELP_TIP25								= 5025, // Destroy Item : Drag and drop the item you wish to destroy on to the red mark on the inventory window. 
	IDS_HELP_TIP26								= 5026, // View Description of the Skill : Put your cursor over the skill icon.
	IDS_HELP_TIP27								= 5027, // Private Message : Type '/pm' ID
	IDS_HELP_TIP28								= 5028, // View Mini-map : Press 'N'.  The red and orange dots are enemies. 
	IDS_HELP_TIP29								= 5029, // Flip through shortcut key window : 'PageUp/PageDown'
	IDS_HELP_TIP30								= 5030, // Use the 'Home / End' keys to change views in the quarter-view mode. 
	IDS_HELP_TIP31								= 5031, // Take 5 Silk Bundles to the Proconsul standing near the accessory vendor and he'll give you a weapon.  
	IDS_HELP_TIP32								= 5032, // Lock on the closest NPC - 'B'
	IDS_HELP_TIP33								= 5033, // View Overall Map : 'M'
	IDS_HELP_TIP_ALL							= 5034, // [Knight Online Tip of the Day!]
	IDS_EDIT_BOX_GOLD							= 6033, // Please enter the amount. 
	IDS_EDIT_BOX_COUNT							= 6034, // Please enter the quantity. 
	IDS_SKILL_INFO_BASE							= 6035, // Basic skills that you get before you choose a specialty.
	IDS_SKILL_INFO_BLADE0						= 6036, // Learn various attack skills. 
	IDS_SKILL_INFO_BLADE1						= 6037, // Learn various defense skills. 
	IDS_SKILL_INFO_BLADE2						= 6038, // Increases Warrior's mental power.   
	IDS_SKILL_INFO_BLADE3						= 6039, // Learn the Master Skills of various weapons. 
	IDS_SKILL_INFO_RANGER0						= 6044, // Learn various archery skills.
	IDS_SKILL_INFO_RANGER1						= 6045, // Learn the various techniques of assassination. 
	IDS_SKILL_INFO_RANGER2						= 6046, // Learn the various techniques of exploring. 
	IDS_SKILL_INFO_RANGER3						= 6047, // Learn the Master Skills of Archery and Assassination.
	IDS_SKILL_INFO_MAGE0						= 6052, // Learn various magic that uses flame. 
	IDS_SKILL_INFO_MAGE1						= 6053, // Learn various magic that uses Glacier. 
	IDS_SKILL_INFO_MAGE2						= 6054, // Learn various magic that uses lightning(Lightning). 
	IDS_SKILL_INFO_MAGE3						= 6055, // Learn the Master Skills of elemental magic.
	IDS_SKILL_INFO_CLERIC0						= 6060, // Learn various healing magic. 
	IDS_SKILL_INFO_CLERIC1						= 6061, // Learn magic that increase character's stat points. 
	IDS_SKILL_INFO_CLERIC2						= 6062, // Learn simple attack magic. 
	IDS_SKILL_INFO_CLERIC3						= 6063, // Learn the Master Skill of a Priest. 
	IDS_ERR_CHARACTER_SELECT					= 6066, // cannot select the character. 
	IDS_DROPPED_NOAH_GET						= 6067, // Picked up %d Coins.
	IDS_DURABILITY_EXOAST						= 6068, // The durability on %s is all gone. 
	IDS_ITEM_GET_BY_RULE						= 6069, // Picked up %s
	IDS_OTHER_PER_TRADE_NO						= 6070, // %s refused the request for a trade. 
	IDS_PER_TRADE_FAIL							= 6071, // Failed trading. 
	IDS_OTHER_PER_TRADE_CANCEL					= 6072, // Trading with %s has been canceled. 
	IDS_ITEM_KIND_BRONS							= 6073, // Bronze
	IDS_ITEM_KIND_SILVER						= 6074, // Silver
	IDS_ITEM_KIND_GOLDEN						= 6075, // Gold
	IDS_ITEM_KIND_PLATINUM						= 6076, // Platinum
	IDS_ITEM_KIND_CRIMSON						= 6077, // Crimson
	IDS_ITEM_KIND_LUNA							= 6078, // Luna
	IDS_ITEM_KIND_SOLAR							= 6079, // Sola
	IDS_ITEM_KIND_ANCIENT						= 6080, // Ancient
	IDS_ITEM_KIND_MISTIQ						= 6081, // Mystic
	IDS_TOOLTIP_NOAH							= 6082, // Coin : %d
	IDS_TOOLTIP_REPAIR_PRICE					= 6084, // Repair Cost
	IDS_TOOLTIP_CANNOT							= 6085, // irreparable item
	IDS_POINTINIT_NOT_ENOUGH_NOAH				= 6086, // You need %d Coins
	IDS_POINTINIT_ALREADY						= 6087, // There are no points to reset. 
	IDS_NOAH_CHANGE_GET							= 6088, // Earned %d Coins.
	IDS_NOAH_CHANGE_LOST						= 6089, // Lost %d Coins. 
	IDS_NOAH_CHANGE_SPEND						= 6099, // Used %d Coins.
	IDS_LOYALTY_CHANGE_GET						= 6100, // Earned %d national points. 
	IDS_MANNER_CHANGE_GET						= 6101, // Earned %d manner points. 
	IDS_BEGINNER_HELPER_30						= 6102, // Congratulations on reaching level 30 on Beginner Helper event. 
	IDS_LADDER_CHANGE_GET						= 6103, // Received %d leader points. 
	IDS_LOYALTY_CHANGE_LOST						= 6104, // %d 국가기여도를 잃었습니다.
	IDS_LADDER_CHANGE_LOST						= 6105, // %d 레더포인트를 잃었습니다.
	IDS_MSG_HASITEMINSLOT						= 6112, // You cannot change your stat while there are items equipped on you.
	IDS_ERR_REQUEST_NPC_EVENT_SO_FAR			= 6116, // You are too far away from the NPC. 
	IDS_WRONG_PASSWORD							= 6120, // Invalid password. 
	IDS_WANT_PARTY_MEMBER						= 6123, // Seeking Party : Level %d ~ %d
	IDS_SETTING_KARUS_SCREEN					= 6124, // \n\nKarus Character Window.
	IDS_SETTING_ELMORAD_SCREEN					= 6125, // \n\nEl Morad Character Window. 

	IDS_PARTY_BBS_REGISTER						= 6300, // Posting request for a party on the Party Request Board. 
	IDS_PARTY_BBS_REGISTER_CANCEL				= 6301, // Delete the request for a party from the Party Request Board. 
	IDS_TRADE_BBS_SELL_REGISTER					= 6302, // You need %d Coins to register the selling item. 
	IDS_TRADE_BBS_PER_TRADE						= 6303, // You'll have to pay the Inn Keeper %d Coins in order to trade with somebody that is far away. 
	IDS_TRADE_BBS_BUY_REGISTER					= 6304, // Registering items you want to buy will cost %d coins per hour.
	IDS_TRADE_BBS_FAIL1							= 6305, // Failed registering. 
	IDS_TRADE_BBS_FAIL2							= 6306, // You don't have enough Coins. 
	IDS_TRADE_BBS_FAIL3							= 6307, // Failed canceling the registration.
	IDS_TRADE_BBS_FAIL4							= 6308, // Failed. Please press the refresh button.
	IDS_TRADE_BBS_FAIL5							= 6309, // Failed requesting for a trade. 
	IDS_TRADE_BBS_FAIL6							= 6310, // Could not access the trade board.
	IDS_OTHER_PER_TRADE_ID_NO					= 6311, // The user has declined the request for a trade. 
	IDS_CLAN_DENY_LOWLEVEL						= 6500, // Sorry.  A weakling like you are not fit to become a leader!!
	IDS_CLAN_DENY_LOWGOLD						= 6501, // Sorry.  You need %d Coins in order to create a clan. 
	IDS_CLAN_DENY_INVALIDDAY					= 6502, // You cannot create a clan today. 
	IDS_CLAN_DENY_ALREADYJOINED					= 6503, // You can't create a clan because you're already in another clan. 
	IDS_CLAN_DENY_UNKNOWN						= 6504, // Hm.. You can't create a can right now.  Please come back later. 
	IDS_CLAN_MAKE_SUCCESS						= 6505, // You are now a leader of a clan.  Congratulations!!!
	IDS_CLAN_WARNING_COST						= 6506, // You need %d Coins to create a clan. 
	IDS_CLAN_INPUT_NAME							= 6507, // Oh~ho~.. Welcome my brave friend.. Tell me, what would you like to name your clan? 
	IDS_CLAN_REINPUT_NAME						= 6508, // Oh~ I'm sorry, but somebody else is already using that name. Try a different name. 
	IDS_CLAN_WITHDRAW_SUCCESS					= 6509, // Successfully quitted the clan. 
	IDS_CLAN_WITHDRAW_FAIL						= 6510, // Failed quitting the clan. 
	IDS_CLAN_JOIN_SUCCESS						= 6511, // Successfully joined the clan. 
	IDS_CLAN_JOIN_FAIL_CLAN_FULL				= 6512, // Failed because the clan has reached the maximum number of people allowed.
	IDS_CLAN_JOIN_FAIL_NONE_CLAN				= 6513, // This clan is not valid. 
	IDS_CLAN_JOIN_FAIL_INVALIDRIGHT				= 6514, // You do not have the authority. 
	IDS_CLAN_JOIN_FAIL_OTHER_CLAN_USER			= 6515, // This user is already in a clan. 
	IDS_CLAN_JOIN_FAIL_ENEMY_USER				= 6516, // This user is from a different nation. 
	IDS_CLAN_JOIN_FAIL_DEAD_USER				= 6517, // This user is dead. 
	IDS_CLAN_JOIN_FAIL_NONE_USER				= 6518, // This user does not exist. 
	IDS_CLAN_COMMON_FAIL_ME						= 6519, // You cannot choose yourself. 
	IDS_CLAN_COMMON_FAIL_NOTJOINED				= 6520, // This user is not in the clan. 
	IDS_CLAN_JOIN_REQ							= 6521, // Will you join the clan %s ? 
	IDS_CLAN_JOIN_REJECT						= 6522, // The user has declined. 
	IDS_CLAN_COMMON_FAIL_BATTLEZONE				= 6523, // It is not allowed in this zone. 
	IDS_CONFIRM_EXECUTE_OPTION					= 6524, // Exiting game and configuring options. Will you continue? 
	IDS_REQUEST_GAME_SAVE						= 6525, // Saved character information. 
	IDS_DELAY_GAME_SAVE							= 6526, // You can save every %d minutes. 
	IDS_CLAN_DENY_INVALID_SERVER				= 6527, // Creating a clan is only allowed in the 1st server group. 
	IDS_DEAD_RETURN_TOWN						= 6600, // Return to town. 
	IDS_DEAD_REVIVAL							= 6601, // Re-spawn. 
	IDS_DEAD_LACK_LIFE_STONE					= 6602, // You don't have enough Stone of Life.
	IDS_DEAD_REVIVAL_MESSAGE					= 6603, // You need to offer %d Stone of Life on to the shrine if you want to be revived. 
	IDS_DEAD_LOW_LEVEL							= 6604, // You cannot be re-spawned because your level is too low. 
	IDS_INVEN_WEIGHT							= 6605, // Weight : 
	IDS_WARP_ARRIVED_AT							= 6606, // You've arrived at %s.
	IDS_CONNECTING_PLEASE_WAIT					= 6609, // Connecting.  Please wait. 
	IDS_WARP_MIN_LEVEL							= 6610, // You need to be at least level %d.
	IDS_WARP_NOT_DURING_WAR						= 6611, // You cannot enter during the Lunar War. 
	IDS_WARP_NOT_DURING_CSW						= 6612, // You cannot enter during the Castle Siege War. 
	IDS_WARP_NEED_LOYALTY						= 6613, // You cannot enter when you have 0 national points. 

	IDS_TELEPORT_TO_X_NEED_Y_COINS				= 7612, // To teleport to %s, you need %d coins

	IDS_EXITING_GAME_IN_X_SECONDS				= 7632, // Exiting game in %d seconds. 
	IDS_EXITING_GAME_CANCELED					= 7633, // Exiting game canceled.
	IDS_CANNOT_EXIT_DURING_A_BATTLE				= 7634, // You cannot exit from the client during a battle. 

	IDS_WARP_LEVEL_30_TO_50						= 7657, // Only characters with level 30~50 can enter. 
	IDS_SKILL_FAIL_PLEASE_EQUIP_YOUR_WEAPON		= 7658, // Please equip your weapon. 
	IDS_WARP_DO_NOT_QUALIFY						= 7659, // You cannot enter because you do not qualify. 

	IDS_PRIVATE_CMD_CAT							= 7800, // Private
	IDS_TRADE_CMD_CAT							= 7801, // Trade
	IDS_PARTY_CMD_CAT							= 7802, // Party
	IDS_CLAN_CMD_CAT							= 7803, // Clan
	IDS_KNIGHTS_CMD_CAT							= 7804, // Knights
	IDS_GUARDIAN_MON_CMD_CAT					= 7805, // Guardian Monster
	IDS_KING_CMD_CAT							= 7806, // King
	IDS_GM_CMD_CAT								= 7807, // GM

	IDS_PRIVATE_TIP								= 7900, // Character related commands. 
	IDS_TRADE_TIP								= 7901, // Trade related commands. 
	IDS_PARTY_TIP								= 7902, // Party related commands.
	IDS_CLAN_TIP								= 7903, // Clan related commands. 
	IDS_KNIGHTS_TIP								= 7904, // Knights related commands. 
	IDS_GUARDIAN_MON_TIP						= 7905, // Commands for guard monsters.
	IDS_KING_TIP								= 7906, // Commands for King.
	IDS_GM_TIP									= 7906, // Commands for King.

	IDS_PRIVATE_PM_CMD							= 8000, // PM
	IDS_PRIVATE_TWN_CMD							= 8001, // Town
	IDS_PRIVATE_EXIT_CMD						= 8002, // Exit
	IDS_PRIVATE_GREET_CMD						= 8003, // Greeting
	IDS_PRIVATE_GREET2_CMD						= 8004, // Greeting2
	IDS_PRIVATE_GREET3_CMD						= 8005, // Greeting3
	IDS_PRIVATE_PROVOKE_CMD						= 8006, // Provoke
	IDS_PRIVATE_PROVOKE2_CMD					= 8007, // Provoke2
	IDS_PRIVATE_PROVOKE3_CMD					= 8008, // Provoke3
	IDS_PRIVATE_SAVE_CMD						= 8009, // Save
	IDS_PRIVATE_BATTLE_CMD						= 8010, // Recommend

	IDS_ITEM_RECEIVED							= 7613, // You've received the %s item. 
	IDS_TRADE_COIN_RECV							= 7682, // Received %s coins.
	IDS_TRADE_COIN_PAID							= 7683, // Paid %s coins. 

	IDS_CMD_WHISPER								= 8000, // PM
	IDS_CMD_TOWN								= 8001, // Town
	IDS_CMD_EXIT								= 8002, // Exit
	IDS_CMD_GREETING							= 8003, // Greeting
	IDS_CMD_GREETING2							= 8004, // Greeting2
	IDS_CMD_GREETING3							= 8005, // Greeting3
	IDS_CMD_PROVOKE								= 8006, // Provoke
	IDS_CMD_PROVOKE2							= 8007, // Provoke2
	IDS_CMD_PROVOKE3							= 8008, // Provoke3
	IDS_CMD_GAME_SAVE							= 8009, // Save
	IDS_CMD_RECOMMEND							= 8010, // Recommend
	IDS_CMD_INDIVIDUAL_BATTLE					= 8011, // Individual_Battle
	IDS_CMD_SIT_STAND							= 8012, // 앉기/서기
	IDS_CMD_WALK_RUN							= 8013, // 걷기/뛰기
	IDS_CMD_LOCATION							= 8014, // 위치

	IDS_CMD_TRADE								= 8200, // Trade
	IDS_CMD_FORBIDTRADE							= 8201, // Block_Trade_Request
	IDS_CMD_PERMITTRADE							= 8202, // Allow_Trade_Request
	IDS_CMD_MERCHANT							= 8203, // Merchant

	IDS_CMD_PARTY								= 8400, // Party
	IDS_CMD_LEAVEPARTY							= 8401, // Quit_party
	IDS_CMD_RECRUITPARTY						= 8402, // Seeking_Party
	IDS_CMD_FORBIDPARTY							= 8403, // Block_Party
	IDS_CMD_PERMITPARTY							= 8404, // Allow_Party

	IDS_CMD_JOINCLAN							= 8600, // Join_Clan
	IDS_CMD_WITHDRAWCLAN						= 8601, // Quit_Clan
	IDS_CMD_FIRECLAN							= 8602, // Ban_from_Clan
	IDS_CMD_COMMAND								= 8603, // Command
	IDS_CMD_CLAN_WAR							= 8604, // Clan_War
	IDS_CMD_SURRENDER							= 8605, // Surrender
	IDS_CMD_APPOINTVICECHIEF					= 8606, // Appoint_as_Assistant_Clan_Leader
	IDS_CMD_CLAN_CHAT							= 8607, // Clan_Chat
	IDS_CMD_CLAN_BATTLE							= 8608, // Clan_Battle

	IDS_CMD_CONFEDERACY							= 8800, // Confederacy
	IDS_CMD_BAN_KNIGHTS							= 8801, // Ban_Knights
	IDS_CMD_QUIT_KNIGHTS						= 8802, // Quit_Knights
	IDS_CMD_BASE								= 8803, // Base
	IDS_CMD_DECLARATION							= 8804, // Declaration

	IDS_CMD_VISIBLE								= 9000, // VISIBLE
	IDS_CMD_INVISIBLE							= 9001, // INVISIBLE
	IDS_CMD_CLEAN								= 9002, // CLEAN
	IDS_CMD_RAINING								= 9003, // RAINING
	IDS_CMD_SNOWING								= 9004, // SNOWING
	IDS_CMD_TIME								= 9005, // TIME
	IDS_CMD_CU_COUNT							= 9006, // COUNT
	IDS_CMD_NOTICE								= 9007, // NOTICE
	IDS_CMD_ARREST								= 9008, // ARREST
	IDS_CMD_FORBIDCONNECT						= 9009, // FORBIDCONNECT
	IDS_CMD_FORBIDCHAT							= 9010, // FORBIDCHAT
	IDS_CMD_PERMITCHAT							= 9011, // PERMITCHAT
	IDS_CMD_NOTICEALL							= 9012, // NOTICEALL
	IDS_CMD_CUTOFF								= 9013, // CUTOFF
	IDS_CMD_VIEW								= 9014, // VIEW
	IDS_CMD_UNVIEW								= 9015, // UNVIEW
	IDS_CMD_FORBIDUSER							= 9016, // FORBIDUSER
	IDS_CMD_SUMMONUSER							= 9017, // SUMMONUSER
	IDS_CMD_ATTACKDISABLE						= 9018, // ATTACKDISABLE
	IDS_CMD_ATTACKENABLE						= 9019, // ATTAKCENABLE
	IDS_CMD_PLC									= 9020, // PROGRAMLISTCHECK

	IDS_CMD_HIDE								= 9200, // Hide
	IDS_CMD_GUARD								= 9201, // Guard
	IDS_CMD_DEFEND								= 9202, // Defend
	IDS_CMD_LOOK_OUT							= 9203, // Look Out
	IDS_CMD_STRATEGIC_FORMATION					= 9204, // Strategic Formation
	IDS_CMD_REST								= 9205, // Rest
	IDS_CMD_DESTROY								= 9206, // Destroy

	IDS_CMD_ROYALORDER							= 9400, // RoyalOrder
	IDS_CMD_PRIZE								= 9401, // Prize
	IDS_CMD_EXPERIENCEPOINT						= 9402, // ExperiencePoint
	IDS_CMD_DROPRATE							= 9403, // DropRate
	IDS_CMD_RAIN								= 9404, // Rain
	IDS_CMD_SNOW								= 9405, // Snow
	IDS_CMD_CLEAR								= 9406, // Clear
	IDS_CMD_REWARD								= 9407, // Reward

	IDS_QUEST_SEARCH_LEVEL_ERROR				= 10100, // You can only search up to +%d levels from your current level.
	IDS_TRANSACTION_OK_CANCEL_MESSAGE			= 11500, // Will you sell %s? 
};

// ===== END WarFare/text_resources.h =====

