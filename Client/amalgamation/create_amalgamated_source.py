#!/usr/bin/env python3
"""
Create a single, amalgamated translation unit for the client sources.

This script concatenates all C/C++ sources and headers under the client tree
into a single file, adding markers so the original file boundaries remain
clear. It is intended for situations where a monolithic source drop is
required (for example, sharing the client code as one massive .cpp or .h).

Usage:
    python create_amalgamated_source.py \
        --output ClientAmalgamated.cpp \
        --root ..

The default output path is `ClientAmalgamated.cpp` next to this script. You can
override the output extension to generate either a .cpp or .h as needed.
"""

from __future__ import annotations

import argparse
import datetime
import pathlib
from typing import Iterable, Sequence


DEFAULT_EXTENSIONS = (".cpp", ".c", ".h", ".hpp")
DEFAULT_EXCLUDES = {"amalgamation"}


def iter_sources(
    root: pathlib.Path,
    *,
    extensions: Sequence[str],
    exclude_dirs: Iterable[str],
    output_path: pathlib.Path,
) -> list[pathlib.Path]:
    """Return a sorted list of source files under ``root``."""
    normalized_exts = {ext.lower() for ext in extensions}
    excluded = {pathlib.Path(part) for part in exclude_dirs}

    def is_excluded(path: pathlib.Path) -> bool:
        return any(part in excluded for part in path.relative_to(root).parts)

    sources: list[pathlib.Path] = []
    for path in root.rglob("*"):
        if not path.is_file():
            continue
        if path.resolve() == output_path.resolve():
            continue
        if path.suffix.lower() not in normalized_exts:
            continue
        if is_excluded(path):
            continue
        sources.append(path)
    return sorted(sources)


def write_amalgamation(
    sources: Sequence[pathlib.Path], *, root: pathlib.Path, output_path: pathlib.Path
) -> None:
    header = (
        "// Auto-generated amalgamation of client sources.\n"
        f"// Generated on {datetime.datetime.utcnow().isoformat()}Z\n"
        "// Do not edit this file manually; run create_amalgamated_source.py instead.\n\n"
    )

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as output:
        output.write(header)
        for source in sources:
            relative = source.relative_to(root)
            output.write(f"// ===== BEGIN {relative.as_posix()} =====\n")
            output.write(f"#line 1 \"{relative.as_posix()}\"\n")
            output.write(source.read_text(encoding="utf-8", errors="replace"))
            output.write(f"\n// ===== END {relative.as_posix()} =====\n\n")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create a single .cpp or .h amalgamation of the client sources."
    )
    parser.add_argument(
        "--root",
        type=pathlib.Path,
        default=pathlib.Path(__file__).resolve().parent.parent,
        help="Client root directory to scan for source files.",
    )
    parser.add_argument(
        "--output",
        type=pathlib.Path,
        default=pathlib.Path(__file__).resolve().parent / "ClientAmalgamated.cpp",
        help="Path to write the amalgamated file (extension controls the format).",
    )
    parser.add_argument(
        "--extensions",
        nargs="+",
        default=list(DEFAULT_EXTENSIONS),
        help="File extensions to include in the amalgamation.",
    )
    parser.add_argument(
        "--exclude-dirs",
        nargs="+",
        default=list(DEFAULT_EXCLUDES),
        help="Directory names (relative to root) to exclude from the scan.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    root = args.root.resolve()
    output_path = args.output.resolve()
    sources = iter_sources(
        root,
        extensions=args.extensions,
        exclude_dirs=args.exclude_dirs,
        output_path=output_path,
    )
    write_amalgamation(sources, root=root, output_path=output_path)
    print(
        f"Wrote {len(sources)} files into {output_path} "
        f"(relative to {root}) as a single translation unit."
    )


if __name__ == "__main__":
    main()
